@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from examples.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT examples.doc INSTEAD
@comment Id: examples.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the examples

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').
@ignore
%**start
\input texinfo.tex
@setfilename examples.hlp
@node Top, Examples
@menu
* General concepts::
@end menu
@node Examples, Mathematical Background, Tricks and pitfalls, Top
@appendix Examples
%**end
@end ignore

@ifinfo
The following topics are treated:
@end ifinfo

@ifset singularmanual
@menu
* Milnor and Tjurina::
* Procedures and LIB::
* Critical points::
* Saturation::
* Long coefficients::
* Parameters::
* T1 and T2::
* Deformations::
* Finite fields::
* Elimination::
* Free resolution::
* Computation of Ext::
* Polar curves::
* Depth::
* Formatting output::
* Cyclic roots::
* G_a -Invariants::
* Invariants of a finite group::
* Factorization::
* Puiseux pairs::
* Primary decomposition::
* Normalization::
* Branches of an Isolated Space Curve Singularity::
* Kernel of module homomorphisms::
* Algebraic dependence::
* Classification::
* Fast lexicographical GB::
* Parallelization with MPtcp links::
@end menu
@end ifset

@ifclear singularmanual
@menu
* Milnor and Tjurina::
* Procedures and LIB::
* Critical points::
* Saturation::
* Parameters::
* Deformations::
* Elimination::
* Free resolution::
* Formatting output::
* Factorization::
* Kernel of module homomorphisms::
* Algebraic dependence::
@end menu
@end ifclear

@c ----------------------------------------------------------------------------
@c @node Start SINGULAR, Milnor and Tjurina,Examples, Examples
@c @section Start SINGULAR
@c @cindex Start SINGULAR

@c Call @sc{Singular} by typing @code{Singular} [return]

@c To use the online help type for instance:
@c    @code{help;} @code{help command;} @code{help General syntax;} @code{help ring;}...
@c Please note:  EVERY COMMAND MUST END WITH A SEMICOLON ";"

@c To leave @sc{Singular}, type one of the:
@c    @code{quit;} @code{exit;} @code{$}

@c The two characters @code{//} make the rest of the line a comment.

@c ----------------------------------------------------------------------------
@node Milnor and Tjurina, Procedures and LIB, Examples, Examples
@section Milnor and Tjurina
@cindex Milnor
@cindex Tjurina

The Milnor number, resp.@: the Tjurina number, of a power
series f in
@tex
$K[[x_1,\ldots,x_n]]$
@end tex
@ifinfo
K[[x1,...,xn]]
@end ifinfo
is
@ifinfo
@*      milnor(f) = dim_K(K[[x1,...,xn]]/jacob(f))
@*resp.@:
@*      tjurina(f) = dim_K(K[[x1,...,xn]]/((f)+jacob(f)))
@*where
@end ifinfo
@tex
$$
\hbox{milnor}(f) = \hbox{dim}_K(K[[x_1,\ldots,x_n]]/\hbox{jacob}(f)),
$$
respectively
$$
\hbox{tjurina}(f) = \hbox{dim}_K(K[[x_1,\ldots,x_n]]/((f)+\hbox{jacob}(f)))
$$
where
@end tex
@code{jacob(f)} is the ideal generated by the partials
of @code{f}. @code{tjurina(f)} is finite, if and only if @code{f} has an
isolated singularity. The same holds for @code{milnor(f)} if
K has characteristic 0.
@sc{Singular} displays -1 if the dimension is infinite.

@sc{Singular} cannot compute with infinite power series. But it can
work in
@tex
$\hbox{Loc}_{(x)}K[x_1,\ldots,x_n]$,
@end tex
@ifinfo
Loc_(x)K[x1,...,xn],
@end ifinfo
the localization of
@tex
$K[x_1,\ldots,x_n]$
@end tex
@ifinfo
K[x1,...,xn]
@end ifinfo
at the maximal ideal
@tex
$(x_1,\ldots,x_n)$.
@end tex
@ifinfo
(x1,...,xn).
@end ifinfo
To do this one has to define an
s-ordering like ds, Ds, ls, ws, Ws or an appropriate matrix
ordering (look at the manual to get information about the possible
monomial orderings in @sc{Singular}, or type @code{help Monomial orderings;}
to get a menu of possible orderings. For further help type, e.g.,
@code{help local orderings;}).
@ifset singularmanual
See @ref{Monomial orderings}.
@end ifset

We shall show in the example below how to realize the following:
@itemize @bullet
@item
set option @code{prot} to have a short protocol during standard basis
computation
@item
define the ring @code{r1} with char 32003, variables @code{x,y,z}, monomial
  ordering @code{ds}, series ring (i.e., K[x,y,z] localized at (x,y,z))
@item
list the information about @code{r1} by typing its name
@item
define the integers @code{a,b,c,t}
@item
define a polynomial @code{f} (depending on @code{a,b,c,t}) and display it
@item
define the jacobian ideal @code{i} of @code{f}
@item
compute a standard basis of @code{i}
@item
compute the Milnor number (=250) with @code{vdim} and create and display
  a string in order to comment the result
  (text between quotes "  "; is a 'string')
@item
compute a standard basis of @code{i+(f)}
@item
compute the Tjurina number (=195) with @code{vdim}
@item
then compute the Milnor number (=248) and the Tjurina number
(=195) for @code{t}=1
@item
reset the option to @code{noprot}
@end itemize

@smallexample
@c computed example Milnor_and_Tjurina examples.doc:196 
  option(prot);
  ring r1 = 32003,(x,y,z),ds;
  r1;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering ds
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
  int a,b,c,t=11,5,3,0;
  poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
           x^(c-2)*y^c*(y^2+t*x)^2;
  f;
@expansion{} y5+x5y2+x2y2z3+xy7+z9+x11
  ideal i=jacob(f);
  i;
@expansion{} i[1]=5x4y2+2xy2z3+y7+11x10
@expansion{} i[2]=5y4+2x5y+2x2yz3+7xy6
@expansion{} i[3]=3x2y2z2+9z8
  ideal j=std(i);
@expansion{} [1023:2]7(2)s8s10s11s12s(3)s13(4)s(5)s14(6)s(7)15--.s(6)-16.-.s(5)17.s(7)\
   s--s18(6).--19-..sH(24)20(3)...21....22....23.--24-
@expansion{} product criterion:10 chain criterion:69
  "The Milnor number of f(11,5,3) for t=0 is", vdim(j);
@expansion{} The Milnor number of f(11,5,3) for t=0 is 250
  j=i+f;    // overwrite j
  j=std(j);
@expansion{} [1023:2]7(3)s8(2)s10s11(3)ss12(4)s(5)s13(6)s(8)s14(9).s(10).15--sH(23)(8)\
   ...16......17.......sH(21)(9)sH(20)16(10).17...........18.......19..----.\
   .sH(19)
@expansion{} product criterion:10 chain criterion:53
  vdim(j);  // compute the Tjurina number for t=0
@expansion{} 195
  t=1;
  f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
    +x^(c-2)*y^c*(y^2+t*x)^2;
  ideal i1=jacob(f);
  ideal j1=std(i1);
@expansion{} [1023:2]7(2)s8s10s11s12s13(3)ss(4)s14(5)s(6)s15(7).....s(8)16.s...s(9)..1\
   7............s18(10).....s(11)..-.19.......sH(24)(10).....20...........21\
   ..........22.............................23..............................\
   .24.----------.25.26
@expansion{} product criterion:11 chain criterion:83
  "The Milnor number of f(11,5,3) for t=1:",vdim(j1);
@expansion{} The Milnor number of f(11,5,3) for t=1: 248
  vdim(std(j1+f));   // compute the Tjurina number for t=1
@expansion{} [1023:2]7(16)s8(15)s10s11ss(16)-12.s-s13s(17)s(18)s(19)-s(18).-14-s(17)-s\
   (16)ss(17)s15(18)..-s...--.16....-.......s(16).sH(23)s(18)...17..........\
   18.........sH(20)17(17)....................18..........19..---....-.-....\
   .....20.-----...s17(9).........18..............19..-.......20.-......21..\
   .......sH(19)16(5).....18......19.-----
@expansion{} product criterion:15 chain criterion:174
@expansion{} 195
  option(noprot);
@c end example Milnor_and_Tjurina examples.doc:196
@end smallexample

@c ----------------------------------------------------------------------------
@node Procedures and LIB, Critical points, Milnor and Tjurina, Examples
@section Procedures and LIB
@cindex Procedures and LIB

The computation of the Milnor number (for an arbitrary isolated complete
intersection singularity ICIS) and the Tjurina number (for an arbitrary
isolated singularity) can be done by using procedures from the library
@code{sing.lib}. For a hypersurface singularity it is very easy to write a
procedure which computes the Milnor number and the Tjurina number.

We shall demonstrate:
@itemize @bullet
@item
load the library @code{sing.lib}
@c item
@c disable the protocol option
@item
define a local ring in 2 variables and characteristic 0
@item
define a plane curve singularity
@item
compute Milnor number and Tjurina number by using the procedures
@code{milnor} and @code{tjurina}
@item
write your own procedures:
(A procedure has a list of input parameters and of return values, both
lists may be empty.)
  @itemize @minus
  @item
  the procedure @code{mil} which must be called with one parameter, a
  polynomial.
  The name g is local to the procedure and is killed automatically.
  @code{mil} returns the Milnor number (and displays a comment).
  @item
  the procedure @code{tjur} where the parameters are not specified. They
  are referred
  to by @code{#[1]} for the 1st, @code{#[2]} for the 2nd parameter, etc.
  @code{tjur} returns the Tjurina number (and displays a comment).
  @item
  the procedure @code{milrina} which returns a list consisting of two
  integers,
  the Milnor and the Tjurina number.
  @end itemize
@end itemize

@smallexample
LIB "sing.lib";
// you should get the information that sing.lib has been loaded
// together with some other libraries which are needed by sing.lib
ring r = 0,(x,y),ds;
poly f = x7+y7+(x-y)^2*x2y2;
milnor(f);
@expansion{} 28
tjurina(f);
@expansion{} 24

proc mil (poly g)
@{
   "Milnor number:";
   return(vdim(std(jacob(g))));
@}
mil(f);
@expansion{} Milnor number:
@expansion{} 28

proc tjur
@{
   "Tjurina number:";
   return(vdim(std(jacob(#[1])+#[1])));
@}
tjur(f);
@expansion{} Tjurina number:
@expansion{} 24

proc milrina (poly f)
@{
   ideal j=jacob(f);
   list L=vdim(std(j)),vdim(std(j+f));
   return(L);
@}
milrina(f);     // a list containing Milnor and Tjurina number
@expansion{} [1]:
@expansion{}    28
@expansion{} [2]:
@expansion{}    24
milrina(f)[2];  // the second element of the list
@expansion{} 24
@end smallexample

@c ----------------------------------------------------------------------------
@node Critical points, Saturation, Procedures and LIB, Examples
@section Critical points
@cindex Critical points

The same computation which computes the Milnor, resp.@: the Tjurina,
number, but with ordering @code{dp} instead of @code{ds} (i.e., in
@tex
$K[x_1,\ldots,x_n]$
@end tex
@ifinfo
K[x1,...,xn]
@end ifinfo
instead of
@tex
$\hbox{Loc}_{(x)}K[x_1,\ldots,x_n])$
@end tex
@ifinfo
Loc_(x)K[x1,...,xn])
@end ifinfo
gives:
@itemize @bullet
@item
the number of critical points of @code{f} in the affine plane
(counted with multiplicities)
@item
the number of singular points of @code{f} on the affine plane curve @code{f}=0
(counted with multiplicities).
@end itemize

We start with the ring @code{r1} from section @ref{Milnor and Tjurina} and its elements.

The following will be realized below:
@itemize @bullet
@item
reset the protocol option and activate the timer
@item
define the ring @code{r2} with char 32003, variables @code{x,y,z} and monomial
  ordering @code{dp} (= degrevlex) (i.e., the polynomial ring = K[x,y,z]).
@item
Note that polynomials, ideals, matrices (of polys), vectors,
  modules belong to a ring, hence we have to define @code{f} and @code{jacob(f)}
  again in @code{r2}. Since these objects are local to a ring, we may use
  the same names.
  Instead of defining @code{f} again we map it from ring @code{r1} to @code{r2}
  by using the @code{imap} command
  (@code{imap} is a convenient way to map variables
  from some ring identically to variables with the same name in the
  basering, even if the ground field is different. Compare with @code{fetch}
  which works for almost identical rings,
  e.g., if the rings differ only by the ordering or by the names of the
  variables and which may be used to rename variables).
  Integers and strings, however, do not belong to any ring. Once
  defined they are globally known.
@item
The result of the computation here (together with the previous one in
 @ref{Milnor and Tjurina}) shows that (for @code{t}=0)
@tex
$\hbox{dim}_K(\hbox{Loc}_{(x,y,z)}K[x,y,z]/\hbox{jacob}(f))$
@end tex
@ifinfo
  dim_K(Loc_(x,y,z)K[x,y,z]/jacob(f))
@end ifinfo
= 250 (previously computed) while
@tex
$\hbox{dim}_K(K[x,y,z]/\hbox{jacob}(f))$
@end tex
@ifinfo
  dim_K(K[x,y,z]/jacob(f))
@end ifinfo
= 536. Hence @code{f} has 286 critical points,
  counted with multiplicity, outside the origin.
  Moreover, since
@tex
$\hbox{dim}_K(\hbox{Loc}_{(x,y,z)}K[x,y,z]/(\hbox{jacob}(f)+(f)))$
@end tex
@ifinfo
dim_K(Loc_(x,y,z)K[x,y,z]/(jacob(f)+(f)))
@end ifinfo
= 195 =
@tex
$\hbox{dim}_K(K[x,y,z]/(\hbox{jacob}(f)+(f)))$,
@end tex
@ifinfo
dim_K(K[x,y,z]/(jacob(f)+(f))),
@end ifinfo
the affine surface @code{f}=0 is smooth outside the origin.
@end itemize

@smallexample
@c computed example Critical_points examples.doc:402 
  ring r1 = 32003,(x,y,z),ds;
  int a,b,c,t=11,5,3,0;
  poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
           x^(c-2)*y^c*(y^2+t*x)^2;
  option(noprot);
  timer=1;
  ring r2 = 32003,(x,y,z),dp;
  poly f=imap(r1,f);
  ideal j=jacob(f);
  vdim(std(j));
@expansion{} 536
  vdim(std(j+f));
@expansion{} 195
  timer=0;  // reset timer
@c end example Critical_points examples.doc:402
@end smallexample

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Saturation, Long coefficients, Critical points, Examples
@end ifset
@ifclear singularmanual
@node Saturation, Parameters, Critical points, Examples
@end ifclear
@section Saturation
@cindex Saturation

Since in the example above, the ideal 
@ifinfo
@math{j+(f)}
@end ifinfo
@tex
$j+(f)$
@end tex
 has the same @code{vdim}
in the polynomial ring and in the localization at 0 (each 195),

@ifinfo
@math{f=0}
@end ifinfo
@tex
$f=0$
@end tex
 is smooth outside 0.
Hence 
@ifinfo
@math{j+(f)}
@end ifinfo
@tex
$j+(f)$
@end tex
 contains some power of the maximal ideal 
@ifinfo
@math{m}
@end ifinfo
@tex
$m$
@end tex
. We shall
check this in a different manner:
For any two ideals 
@ifinfo
@math{i, j}
@end ifinfo
@tex
$i, j$
@end tex
 in the basering 
@ifinfo
@math{R}
@end ifinfo
@tex
$R$
@end tex
 let
@tex
$$
\hbox{sat}(i,j)=\{x\in R\;|\; \exists\;n\hbox{ s.t. }
x\cdot(j^n)\subseteq i\}
= \bigcup_{n=1}^\infty i:j^n$$
@end tex
@ifinfo
@*sat(i,j) = @{x in @math{R} | there is an n s.t. x*(j^n) contained in i@}
@*         = union_(n=1...) of i:j^n,
@end ifinfo
@*denote the saturation of 
@ifinfo
@math{i}
@end ifinfo
@tex
$i$
@end tex
 with respect to 
@ifinfo
@math{j}
@end ifinfo
@tex
$j$
@end tex
. This defines,
geometrically, the closure of the complement of V(
@ifinfo
@math{j}
@end ifinfo
@tex
$j$
@end tex
) in V(
@ifinfo
@math{i}
@end ifinfo
@tex
$i$
@end tex
)
(V(
@ifinfo
@math{i}
@end ifinfo
@tex
$i$
@end tex
) denotes the variety defined by 
@ifinfo
@math{i}
@end ifinfo
@tex
$i$
@end tex
).
In our case, 
@ifinfo
@math{sat(j+(f),m)}
@end ifinfo
@tex
$sat(j+(f),m)$
@end tex
 must be the whole ring, hence
generated by 1.

The saturation is computed by the procedure @code{sat} in
@code{elim.lib} by computing iterated ideal quotients with the maximal
ideal.  @code{sat} returns a list of two elements: the saturated ideal
and the number of iterations.  (Note that @code{maxideal(n)} denotes the
n-th power of the maximal ideal).

@smallexample
@c computed example Saturation examples.doc:457 
  LIB "elim.lib";         // loading library elim.lib
  // you should get the information that elim.lib has been loaded
  // together with some other libraries which are needed by it
  option(noprot);         // no protocol
  ring r2 = 32003,(x,y,z),dp;
  poly f = x^11+y^5+z^(3*3)+x^(3+2)*y^(3-1)+x^(3-1)*y^(3-1)*z3+
    x^(3-2)*y^3*(y^2)^2;
  ideal j=jacob(f);
  sat(j+f,maxideal(1));
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{} [2]:
@expansion{}    17
  // list the variables defined so far:
  listvar();
@expansion{} // r2                   [0]  *ring
@expansion{} //      j                    [0]  ideal, 3 generator(s)
@expansion{} //      f                    [0]  poly
@expansion{} // LIB                  [0]  string standard.lib,elim.li..., 83 char(s)
@c end example Saturation examples.doc:457
@end smallexample

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Long coefficients, Parameters, Saturation, Examples
@section Long coefficients
@cindex Long coefficients

The following innocent example produces in its standard basis
extremely long coefficients in char 0 for the lexicographical
ordering.
But a very small deformation does not (the undeformed
example is degenerate with respect to the Newton boundary).
This example demonstrates that it might be wise, for complicated
examples, to do the calculation first in positive char (e.g., 32003).
It has been shown, that in complicated examples, more than 95 percent of
the time needed for a standard basis computation is used in the
computation of the coefficients (in char 0).
The representation of long integers with real is demonstrated.

@smallexample
@c computed example Long_coefficients examples.doc:491 
timer = 1;                              // activate the timer
option(prot);
ring R0 = 0,(x,y),lp;
poly f = x5+y11+xy9+x3y9;
ideal i = jacob(f);
ideal i1 = i,i[1]*i[2];                 // undeformed ideal
ideal i2 = i,i[1]*i[2]+1/1000000*x5y8;  // deformation of i1
i1; i2;
@expansion{} i1[1]=5x4+3x2y9+y9
@expansion{} i1[2]=9x3y8+9xy8+11y10
@expansion{} i1[3]=45x7y8+27x5y17+45x5y8+55x4y10+36x3y17+33x2y19+9xy17+11y19
@expansion{} i2[1]=5x4+3x2y9+y9
@expansion{} i2[2]=9x3y8+9xy8+11y10
@expansion{} i2[3]=45x7y8+27x5y17+45000001/1000000x5y8+55x4y10+36x3y17+33x2y19+9xy17+1\
   1y19
ideal j = std(i1);
@expansion{} [65535:1]11(2)ss19s20s21s22(3)-23-s27s28s29s30s31s32s33s34s35s36s37s38s39\
   s40s70-
@expansion{} product criterion:1 chain criterion:30
j;
@expansion{} j[1]=264627y39+26244y35-1323135y30-131220y26+1715175y21+164025y17+1830125\
   y16
@expansion{} j[2]=12103947791971846719838321886393392913750065060875xy8-28639152114168\
   3198701331939250003266767738632875y38-31954402206909026926764622877573565\
   78554430672591y37+57436621420822663849721381265738895282846320y36+1657764\
   214948799497573918210031067353932439400y35+213018481589308191195677223898\
   98682697001205500y34+1822194158663066565585991976961565719648069806148y33\
   -4701709279892816135156972313196394005220175y32-1351872269688192267600786\
   97600850686824231975y31-3873063305929810816961516976025038053001141375y30\
   +1325886675843874047990382005421144061861290080000y29+1597720195476063141\
   9467945895542406089526966887310y28-26270181336309092660633348002625330426\
   7126525y27-7586082690893335269027136248944859544727953125y26-867853074106\
   49464602285843351672148965395945625y25-5545808143273594102173252331151835\
   700278863924745y24+19075563013460437364679153779038394895638325y23+548562\
   322715501761058348996776922561074021125y22+157465452677648386073957464715\
   68100780933983125y21-1414279129721176222978654235817359505555191156250y20\
   -20711190069445893615213399650035715378169943423125y19+272942733337472665\
   573418092977905322984009750y18+789065115845334505801847294677413365720955\
   3750y17+63554897038491686787729656061044724651089803125y16-22099251729923\
   906699732244761028266074350255961625y14+147937139679655904353579489722585\
   91339027857296625y10
@expansion{} j[3]=5x4+3x2y9+y9
// Compute average coefficient length (=51) by
//   - converting j[2] to a string in order to compute the number
//   of characters
//   - divide this by the number of monomials:
size(string(j[2]))/size(j[2]);
@expansion{} 51
vdim(j);
@expansion{} 63
// For a better representation normalize the long coefficients
// of the polynomial j[2] and map it  to real:
poly p=(1/12103947791971846719838321886393392913750065060875)*j[2];
ring R1=real,(x,y),lp;
short=0; // force the long output format
poly p=imap(R0,p);
p;
@expansion{} x*y^8-2.366e-02*y^38-2.640e-01*y^37+4.745e-06*y^36+1.370e-04*y^35+1.760e-\
   03*y^34+1.505e-01*y^33+3.884e-07*y^32-1.117e-05*y^31-3.200e-04*y^30+1.095\
   e-01*y^29+1.320e+00*y^28-2.170e-05*y^27-6.267e-04*y^26-7.170e-03*y^25-4.5\
   82e-01*y^24+1.576e-06*y^23+4.532e-05*y^22+1.301e-03*y^21-1.168e-01*y^20-1\
   .711e+00*y^19+2.255e-05*y^18+6.519e-04*y^17+5.251e-03*y^16-1.826e+00*y^14\
   +1.222e+00*y^10
// Compute a standard basis for the deformed ideal:
setring R0;
j = std(i2);
@expansion{} [65535:1]11(2)ss19s20s21s22(3)-s23(2)s27.28.s29(3)s30.s31ss32sss33sss34ss\
   35--38-
@expansion{} product criterion:11 chain criterion:21
j;
@expansion{} j[1]=y16
@expansion{} j[2]=65610xy8+17393508y27+7223337y23+545292y19+6442040y18-119790y14+80190\
   y10
@expansion{} j[3]=5x4+3x2y9+y9
vdim(j);
@expansion{} 40
@c end example Long_coefficients examples.doc:491
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Parameters, T1 and T2, Long coefficients, Examples
@end ifset
@ifclear singularmanual
@node Parameters, Deformations, Saturation, Examples
@end ifclear
@section Parameters
@cindex Parameters

@ifset singularmanual
Let us deform the above ideal now by introducing a parameter t
and compute over the ground field Q(t).
We compute the dimension at the generic point,
@end ifset
@ifclear singularmanual
Let us now deform a given 0-dimensional ideal j by introducing a parameter t
and compute over the ground field Q(t).
We compute the dimension at the generic point,
@end ifclear
i.e.,
@tex
$dim_{Q(t)}Q(t)[x,y]/j$.
@end tex
@ifinfo
dim_Q(t) Q(t)[x,y]/j.
@end ifinfo
@ifset singularmanual
(This gives the
same result as for the deformed ideal above. Hence, the above small
deformation was "generic".)
@end ifset

For almost all
@tex
$a \in Q$
@end tex
@ifinfo
a in Q
@end ifinfo
this is the same as
@tex
$dim_Q Q[x,y]/j_0$,
@end tex
@ifinfo
dim_Q Q[x,y]/j0,
@end ifinfo
where
@tex
$j_0=j|_{t=a}$.
@end tex
@ifinfo
j_0=j_t=a
@end ifinfo

@smallexample
@c computed example Parameters examples.doc:579 
  ring Rt = (0,t),(x,y),lp;
  Rt;
@expansion{} //   characteristic : 0
@expansion{} //   1 parameter    : t 
@expansion{} //   minpoly        : 0
@expansion{} //   number of vars : 2
@expansion{} //        block   1 : ordering lp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering C
  poly f = x5+y11+xy9+x3y9;
  ideal i = jacob(f);
  ideal j = i,i[1]*i[2]+t*x5y8;  // deformed ideal, parameter t
  vdim(std(j));
@expansion{} 40
  ring R=0,(x,y),lp;
  ideal i=imap(Rt,i);
  int a=random(1,30000);
  ideal j=i,i[1]*i[2]+a*x5y8;  // deformed ideal, fixed integer a
  vdim(std(j));
@expansion{} 40
@c end example Parameters examples.doc:579
@end smallexample

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node T1 and T2, Deformations, Parameters, Examples
@section T1 and T2
@cindex T1
@cindex T2


@ifinfo
@math{T^1}
@end ifinfo
@tex
$T^1$
@end tex
, resp.@: 
@ifinfo
@math{T^2}
@end ifinfo
@tex
$T^2$
@end tex
, of an ideal 
@ifinfo
@math{j}
@end ifinfo
@tex
$j$
@end tex
 usually denote the modules of
infinitesimal deformations, resp.@: of obstructions.
In @sc{Singular} there are procedures @code{T_1} and @code{T_2} in
@code{sing.lib} such that
@code{T_1(j)} and @code{T_2(j)} compute a standard basis of
a presentation of these modules.
If T_1 and T_2 are finite dimensional K-vector spaces (e.g., for isolated
singularities), a basis can be computed by applying
@code{kbase(T_1(j));}, resp.@: @code{kbase(T_2(j));}, the dimensions by
applying @code{vdim}.
For a complete intersection j the procedure @code{Tjurina} also
computes T_1, but faster (T_2=0 in this case).
For a non complete intersection, it is faster to use the procedure @code{T_12}
instead of @code{T_1} and @code{T_2}.
Type @code{help T_1;} (or @code{help T_2;} or @code{help T_12;}) to obtain
more detailed information about these procedures.

We give three examples, the first being a hypersurface, the second a complete
intersection, the third no complete intersection:
@itemize @bullet
@item
load @code{sing.lib}
@item
check whether the ideal j is a complete intersection. It is, if
     number of variables = dimension + minimal number of generators
@item
compute the Tjurina number
@item
compute a vector space basis (kbase) of T_1
@item
compute the Hilbert function of T_1
@item
create a polynomial encoding the Hilbert series
@item
compute the dimension of T_2
@end itemize

@smallexample
@c computed example T1_and_T2 examples.doc:639 
  LIB "sing.lib";
  ring R=32003,(x,y,z),ds;
  // ---------------------------------------
  // hypersurface case (from series T[p,q,r]):
  int p,q,r = 3,3,4;
  poly f = x^p+y^q+z^r+xyz;
  tjurina(f);
@expansion{} 8
  // Tjurina number = 8
  kbase(Tjurina(f));
@expansion{} // Tjurina number = 8
@expansion{} _[1]=z3
@expansion{} _[2]=z2
@expansion{} _[3]=yz
@expansion{} _[4]=xz
@expansion{} _[5]=z
@expansion{} _[6]=y
@expansion{} _[7]=x
@expansion{} _[8]=1
  // ---------------------------------------
  // complete intersection case (from series P[k,l]):
  int k,l =3,2;
  ideal j=xy,x^k+y^l+z2;
  dim(std(j));          // Krull dimension
@expansion{} 1
  size(minbase(j));     // minimal number of generators
@expansion{} 2
  tjurina(j);           // Tjurina number
@expansion{} 6
  module T=Tjurina(j);
@expansion{} // Tjurina number = 6
  kbase(T);             // a sparse output of the k-basis of T_1
@expansion{} _[1]=z*gen(1)
@expansion{} _[2]=gen(1)
@expansion{} _[3]=y*gen(2)
@expansion{} _[4]=x2*gen(2)
@expansion{} _[5]=x*gen(2)
@expansion{} _[6]=gen(2)
  print(kbase(T));      // columns of matrix are a k-basis of T_1
@expansion{} z,1,0,0, 0,0,
@expansion{} 0,0,y,x2,x,1 
  // ---------------------------------------
  // general case (cone over rational normal curve of degree 4):
  ring r1=0,(x,y,z,u,v),ds;
  matrix m[2][4]=x,y,z,u,y,z,u,v;
  ideal i=minor(m,2);   // 2x2 minors of matrix m
  module M=T_1(i);       // a presentation matrix of T_1
@expansion{} // dim T_1 = 4
  vdim(M);              // Tjurina number
@expansion{} 4
  hilb(M);              // display of both Hilbert series
@expansion{} //         4 t^0
@expansion{} //       -20 t^1
@expansion{} //        40 t^2
@expansion{} //       -40 t^3
@expansion{} //        20 t^4
@expansion{} //        -4 t^5
@expansion{} 
@expansion{} //         4 t^0
@expansion{} // dimension (local)   = 0
@expansion{} // multiplicity = 4
  intvec v1=hilb(M,1);  // first Hilbert series as intvec
  intvec v2=hilb(M,2);  // second Hilbert series as intvec
  v1;
@expansion{} 4,-20,40,-40,20,-4,0
  v2;
@expansion{} 4,0
  v1[3];                // 3rd coefficient of the 1st Hilbert series
@expansion{} 40
  module N=T_2(i);
@expansion{} // dim T_2 = 3
@c end example T1_and_T2 examples.doc:639
@end smallexample
@smallexample
// In some cases it might be useful to have a polynomial in some ring
// encoding the Hilbert series. This polynomial can then be
// differentiated, evaluated etc. It can be done as follows:
ring H = 0,t,ls;
poly h1;
int ii;
for (ii=1; ii<=size(v1); ii=ii+1)
@{
   h1=h1+v1[ii]*t^(ii-1);
@}
h1;                   // 1st Hilbert series
@expansion{} 4-20t+40t2-40t3+20t4-4t5
diff(h1,t);           // differentiate  h1
@expansion{} -20+80t-120t2+80t3-20t4
subst(h1,t,1);        // substitute t by 1
@expansion{} 0

// The procedures T_1, T_2, T_12 may be called with two arguments and then
// they return a list with more information (type help T_1; etc.)
// e.g., T_12(i,<any>); returns a list with 9 nonempty objects where
// _[1] = std basis of T_1-module, _[2] = std basis of T_2-module,
// _[3]= vdim of T_1, _[4]= vdim of T_2
setring r1;           // make r1 again the basering
list L = T_12(i,1);
@expansion{} // dim T_1  =  4
@expansion{} // dim T_2  =  3
kbase(L[1]);          // kbase of T_1
@expansion{} _[1]=1*gen(2)
@expansion{} _[2]=1*gen(3)
@expansion{} _[3]=1*gen(6)
@expansion{} _[4]=1*gen(7)
kbase(L[2]);          // kbase of T_2
@expansion{} _[1]=1*gen(6)
@expansion{} _[2]=1*gen(8)
@expansion{} _[3]=1*gen(9)
L[3];                 // vdim of T_1
@expansion{} 4
L[4];                 // vdim of T_2
@expansion{} 3
@end smallexample
@c killall();            // a procedure from general.lib
@c @expansion{} // ** killing the basering for level 0
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Deformations, Finite fields, T1 and T2, Examples
@end ifset
@ifclear singularmanual
@node Deformations, Elimination, Parameters, Examples
@end ifclear
@section Deformations
@cindex Deformations

@itemize @bullet
@item
The libraries @code{sing.lib}, resp.@: @code{deform.lib}, contain procedures
to compute total and base space of the
miniversal (= semiuniversal) deformation of an
isolated complete intersection singularity, resp.@: arbitrary isolated
singularity.
@item
The procedure @code{deform} in @code{sing.lib} returns a matrix whose columns
@ifinfo
@code{h_1,..., h_r}
@end ifinfo
@tex
$h_1,\ldots,h_r$
@end tex
represent all 1st order deformations. More precisely, if
@ifinfo
I in R is the ideal generated by @code{f_1,...,f_s}, then any infinitesimal
deformation of R/I over K[e]/(e^2) is given by @code{f+eg},
where f=(f_1,...,f_s), g a K-linear combination of the h_i.
@end ifinfo
@tex
$I \subset R$ is the ideal generated by $f_1,...,f_s$, then any infinitesimal
deformation of $R/I$ over $K[\varepsilon]/(\varepsilon^2)$ is given
by $f+\varepsilon g$,
where $f=(f_1,...,f_s)$, $g$ a $K$-linear combination of the $h_i$.
@end tex

@item
The procedure @code{versal} in @code{deform.lib} computes a formal
miniversal deformation up to a certain order which can be
prescribed by the user. For a complete intersection the 1st order
part is already miniversal.
@item
The procedure @code{versal} extends the basering to a new ring with
additional deformation parameters which contains the equations for the
miniversal base space and the miniversal total space.
@item
There are default names for the objects created, but the user may also
choose his own names.
@item
If the user sets @code{printlevel=2;} before running @code{versal}, some
intermediate results are shown. This is useful since @code{versal}
is already complicated and might run for some time on more
complicated examples. (type @code{help versal;})
@end itemize

@ifset singularmanual
We compute for the same examples as in the preceding section
the miniversal deformations:
@end ifset
@ifclear singularmanual
We give three examples, the first being a hypersurface, the second a
complete intersection, the third no complete intersection and compute
in each of the cases the miniversal deformation:
@end ifclear

@smallexample
@c computed example Deformations examples.doc:787 
  LIB "deform.lib";
  ring R=32003,(x,y,z),ds;
  //----------------------------------------------------
  // hypersurface case (from series T[p,q,r]):
  int p,q,r = 3,3,4;
  poly f = x^p+y^q+z^r+xyz;
  print(deform(f));
@expansion{} z3,z2,yz,xz,z,y,x,1
  // the miniversal deformation of f=0 is the projection from the
  // miniversal total space to the miniversal base space:
  // @{ (A,B,C,D,E,F,G,H,x,y,z) | x3+y3+xyz+z4+A+Bx+Cxz+Dy+Eyz+Fz+Gz2+Hz3 =0 @}
  //  --> @{ (A,B,C,D,E,F,G,H) @}
  //----------------------------------------------------
  // complete intersection case (from series P[k,l]):
  int k,l =3,2;
  ideal j=xy,x^k+y^l+z2;
  print(deform(j));
@expansion{} 0,0, 0,0,z,1,
@expansion{} y,x2,x,1,0,0 
  versal(j);                  // using default names
@expansion{} // smooth base space
@expansion{} // ready: T_1 and T_2
@expansion{} 
@expansion{} // Result belongs to ring Px.
@expansion{} // Equations of total space of miniversal deformation are 
@expansion{} // given by Fs, equations of miniversal base space by Js.
@expansion{} // Make Px the basering and list objects defined in Px by typing:
@expansion{}    setring Px; show(Px);
@expansion{}    listvar(matrix);
@expansion{} // NOTE: rings Qx, Px, So are alive!
@expansion{} // (use 'kill_rings("");' to remove)
  setring Px;
  show(Px);                   // show is a procedure from inout.lib
@expansion{} // ring: (32003),(A,B,C,D,E,F,x,y,z),(ds(6),ds(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // Rs                   [0]  matrix 2 x 1
@expansion{} // Fs                   [0]  matrix 1 x 2
@expansion{} // Js                   [0]  matrix 1 x 0
  listvar(matrix);
@expansion{} // Rs                   [0]  matrix 2 x 1
@expansion{} // Fs                   [0]  matrix 1 x 2
@expansion{} // Js                   [0]  matrix 1 x 0
  // ___ Equations of miniversal base space ___:
  Js;
@expansion{} 
  // ___ Equations of miniversal total space ___:
  Fs;
@expansion{} Fs[1,1]=xy+Ez+F
@expansion{} Fs[1,2]=y2+z2+x3+Ay+Bx2+Cx+D
  // the miniversal deformation of V(j) is the projection from the
  // miniversal total space to the miniversal base space:
  // @{ (A,B,C,D,E,F,x,y,z) | xy+F+Ez=0, y2+z2+x3+D+Cx+Bx2+Ay=0 @}
  //  --> @{ (A,B,C,D,E,F) @}
  //----------------------------------------------------
  // general case (cone over rational normal curve of degree 4):
  ring r1=0,(x,y,z,u,v),ds;
  matrix m[2][4]=x,y,z,u,y,z,u,v;
  ideal i=minor(m,2);                 // 2x2 minors of matrix m
  int time=timer;
  // Def_r is the name of the miniversal base space with
  // parameters A(1),...,A(4)
  versal(i,0,"Def_r","A(");
@expansion{} // ready: T_1 and T_2
@expansion{} 
@expansion{} // Result belongs to ring Def_rPx.
@expansion{} // Equations of total space of miniversal deformation are 
@expansion{} // given by Fs, equations of miniversal base space by Js.
@expansion{} // Make Def_rPx the basering and list objects defined in Def_rPx by typin\
   g:
@expansion{}    setring Def_rPx; show(Def_rPx);
@expansion{}    listvar(matrix);
@expansion{} // NOTE: rings Def_rQx, Def_rPx, Def_rSo are alive!
@expansion{} // (use 'kill_rings("Def_r");' to remove)
  "// used time:",timer-time,"sec";   // time of last command
@expansion{} // used time: 1 sec
  // the miniversal deformation of V(i) is the projection from the
  // miniversal total space to the miniversal base space:
  // @{ (A(1..4),x,y,z,u,v) |
  //         -y^2+x*z+A(2)*x-A(3)*y=0, -y*z+x*u-A(1)*x-A(3)*z=0,
  //         -y*u+x*v-A(3)*u-A(4)*z=0, -z^2+y*u-A(1)*y-A(2)*z=0,
  //         -z*u+y*v-A(2)*u-A(4)*u=0, -u^2+z*v+A(1)*u-A(4)*v=0 @}
  //  --> @{ A(1..4) |
  //         -A(1)*A(4) = A(3)*A(4) = -A(2)*A(4)-A(4)^2 = 0 @}
  //----------------------------------------------------
@c end example Deformations examples.doc:787
@end smallexample

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Finite fields, Elimination, Deformations, Examples
@section Finite fields
@cindex Finite fields

We define a variety in 
@ifinfo
@math{n}
@end ifinfo
@tex
$n$
@end tex
-space of codimension 2 defined by
polynomials of degree 
@ifinfo
@math{d}
@end ifinfo
@tex
$d$
@end tex
 with generic coefficients over the prime
field 
@ifinfo
@math{Z/p}
@end ifinfo
@tex
$Z/p$
@end tex
 and look for zeros on the torus. First over the prime
field and then in the finite extension field with
@tex
$p^k$
@end tex
@ifinfo
p^k
@end ifinfo
elements.
In general there will be many more solutions in the second case.
(Since the @sc{Singular} language is interpreted, the evaluation of many
@code{for}-loops is not very fast):

@smallexample
@c computed example Finite_fields examples.doc:860 
  int p=3;  int n=3;  int d=5; int k=2;
  ring rp = p,(x(1..n)),dp;
  int s = size(maxideal(d));
  s;
@expansion{} 21
  // create a dense homogeneous ideal m, all generators of degree d, with
  // generic (random) coefficients:
  ideal m = maxideal(d)*random(p,s,n-2);
  m;
@expansion{} m[1]=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^3*x\
   (3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5
  // look for zeros on the torus by checking all points (with no component 0)
  // of the affine n-space over the field with p elements :
  ideal mt;
  int i(1..n);                    // initialize integers i(1),...,i(n)
  int l;
  s=0;
  for (i(1)=1;i(1)<p;i(1)=i(1)+1)
  @{
    for (i(2)=1;i(2)<p;i(2)=i(2)+1)
    @{
      for (i(3)=1;i(3)<p;i(3)=i(3)+1)
      @{
        mt=m;
        for (l=1;l<=n;l=l+1)
        @{
          mt=subst(mt,x(l),i(l));
        @}
        if (size(mt)==0)
        @{
          "solution:",i(1..n);
          s=s+1;
        @}
      @}
    @}
  @}
@expansion{} solution: 1 1 2
@expansion{} solution: 1 2 1
@expansion{} solution: 1 2 2
@expansion{} solution: 2 1 1
@expansion{} solution: 2 1 2
@expansion{} solution: 2 2 1
  "//",s,"solutions over GF("+string(p)+")";
@expansion{} // 6 solutions over GF(3)
  // Now go to the field with p^3 elements:
  // As long as there is no map from Z/p to the field with p^3 elements
  // implemented, use the following trick: convert the ideal to be mapped
  // to the new ring to a string and then execute this string in the
  // new ring
  string ms="ideal m="+string(m)+";";
  ms;
@expansion{} ideal m=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^\
   3*x(3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5;
  // define a ring rpk with p^k elements, call the primitive element z. Hence
  // 'solution exponent: 0 1 5' means that (z^0,z^1,z^5) is a solution
  ring rpk=(p^k,z),(x(1..n)),dp;
  rpk;
@expansion{} //   # ground field : 9
@expansion{} //   primitive element : z
@expansion{} //   minpoly        : 1*z^2+1*z^1+2*z^0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x(1) x(2) x(3) 
@expansion{} //        block   2 : ordering C
  execute(ms);
  s=0;
  ideal mt;
  for (i(1)=0;i(1)<p^k-1;i(1)=i(1)+1)
  @{
    for (i(2)=0;i(2)<p^k-1;i(2)=i(2)+1)
    @{
      for (i(3)=0;i(3)<p^k-1;i(3)=i(3)+1)
      @{
        mt=m;
        for (l=1;l<=n;l=l+1)
        @{
          mt=subst(mt,x(l),z^i(l));
        @}
        if (size(mt)==0)
        @{
          "solution exponent:",i(1..n);
          s=s+1;
        @}
      @}
    @}
  @}
@expansion{} solution exponent: 0 0 2
@expansion{} solution exponent: 0 0 4
@expansion{} solution exponent: 0 0 6
@expansion{} solution exponent: 0 1 0
@expansion{} solution exponent: 0 3 0
@expansion{} solution exponent: 0 4 0
@expansion{} solution exponent: 0 4 4
@expansion{} solution exponent: 0 4 5
@expansion{} solution exponent: 0 4 7
@expansion{} solution exponent: 1 1 3
@expansion{} solution exponent: 1 1 5
@expansion{} solution exponent: 1 1 7
@expansion{} solution exponent: 1 2 1
@expansion{} solution exponent: 1 4 1
@expansion{} solution exponent: 1 5 0
@expansion{} solution exponent: 1 5 1
@expansion{} solution exponent: 1 5 5
@expansion{} solution exponent: 1 5 6
@expansion{} solution exponent: 2 2 0
@expansion{} solution exponent: 2 2 4
@expansion{} solution exponent: 2 2 6
@expansion{} solution exponent: 2 3 2
@expansion{} solution exponent: 2 5 2
@expansion{} solution exponent: 2 6 1
@expansion{} solution exponent: 2 6 2
@expansion{} solution exponent: 2 6 6
@expansion{} solution exponent: 2 6 7
@expansion{} solution exponent: 3 3 1
@expansion{} solution exponent: 3 3 5
@expansion{} solution exponent: 3 3 7
@expansion{} solution exponent: 3 4 3
@expansion{} solution exponent: 3 6 3
@expansion{} solution exponent: 3 7 0
@expansion{} solution exponent: 3 7 2
@expansion{} solution exponent: 3 7 3
@expansion{} solution exponent: 3 7 7
@expansion{} solution exponent: 4 0 0
@expansion{} solution exponent: 4 0 1
@expansion{} solution exponent: 4 0 3
@expansion{} solution exponent: 4 0 4
@expansion{} solution exponent: 4 4 0
@expansion{} solution exponent: 4 4 2
@expansion{} solution exponent: 4 4 6
@expansion{} solution exponent: 4 5 4
@expansion{} solution exponent: 4 7 4
@expansion{} solution exponent: 5 0 5
@expansion{} solution exponent: 5 1 1
@expansion{} solution exponent: 5 1 2
@expansion{} solution exponent: 5 1 4
@expansion{} solution exponent: 5 1 5
@expansion{} solution exponent: 5 5 1
@expansion{} solution exponent: 5 5 3
@expansion{} solution exponent: 5 5 7
@expansion{} solution exponent: 5 6 5
@expansion{} solution exponent: 6 1 6
@expansion{} solution exponent: 6 2 2
@expansion{} solution exponent: 6 2 3
@expansion{} solution exponent: 6 2 5
@expansion{} solution exponent: 6 2 6
@expansion{} solution exponent: 6 6 0
@expansion{} solution exponent: 6 6 2
@expansion{} solution exponent: 6 6 4
@expansion{} solution exponent: 6 7 6
@expansion{} solution exponent: 7 0 7
@expansion{} solution exponent: 7 2 7
@expansion{} solution exponent: 7 3 3
@expansion{} solution exponent: 7 3 4
@expansion{} solution exponent: 7 3 6
@expansion{} solution exponent: 7 3 7
@expansion{} solution exponent: 7 7 1
@expansion{} solution exponent: 7 7 3
@expansion{} solution exponent: 7 7 5
  "//",s,"solutions over GF("+string(p^k)+")";
@expansion{} // 72 solutions over GF(9)
@c end example Finite_fields examples.doc:860
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Elimination, Free resolution, Finite fields, Examples
@end ifset
@ifclear singularmanual
@node Elimination, Free resolution, Deformations, Examples
@end ifclear
@section Elimination
@cindex Elimination

Elimination is the algebraic counterpart of the geometric concept of
projection. If
@tex
$f=(f_1,\ldots,f_n):k^r\rightarrow k^n$
@end tex
@ifinfo
f=(f1,...,fn) : k^r --> k^n
@end ifinfo
is a polynomial map,
the Zariski-closure of the image is the zero-set of the ideal
@tex
$$
\displaylines{
j=J \cap k[x_1,\ldots,x_n], \;\quad\hbox{\rm where}\cr
J=(x_1-f_1(t_1,\ldots,t_r),\ldots,x_n-f_n(t_1,\ldots,t_r))\subseteq
k[t_1,\ldots,t_r,x_1,\ldots,x_n]
}
$$
@end tex
@ifinfo

@smallexample
        j = J intersected with K[x1,...,xn]
J=(x1-f1(t1,...,tr),...,xn-fn(t1,...,tr)) in k[t1,...tr,x1,...,xn]
@end smallexample

@end ifinfo
i.e, of the ideal j obtained from J by eliminating the variables
@tex
$t_1,\ldots,t_r$.
@end tex
@ifinfo
t1,...,tr.
@end ifinfo
This can be done by computing a standard basis of J with respect to a product
ordering where the block of t-variables precedes the block of
x-variables and then selecting those polynomials which do not contain
any t. In @sc{Singular} the most convenient way is to use the
@code{eliminate} command.
In contrast to the first method, with @code{eliminate} the result needs not be a
standard basis in the given ordering.
Hence, there may be cases where the first method is the preferred one.

@strong{WARNING:} In the case of a local or a mixed ordering, elimination needs special
care. f may be considered as a map of germs
@tex
$f:(k^r,0)\rightarrow(k^n,0)$,
@end tex
@ifinfo
f : (k^r,0) --> (k^n,0),
@end ifinfo
but even
if this map germ is finite, we are in general not able to compute the image
germ because for this we would need an implementation of the Weierstrass
preparation theorem. What we can compute, and what @code{eliminate} actually does,
is the following: let V(J) be the zero-set of J in
@tex
$k^r\times(k^n,0)$,
@end tex
@ifinfo
k^r x (k^n,0),
@end ifinfo
then the
closure of the image of V(J) under the projection
@tex
$$\hbox{pr}:k^r\times(k^n,0)\rightarrow(k^n,0)$$
can be computed.
@end tex
@ifinfo
@*           pr:  k^r x (k^n,0) --> (k^n,0)
@*can be computed.
@end ifinfo
Note that this germ contains also those components
of V(J) which meet the fiber of pr outside the origin.
This is achieved by an ordering with the block of t-variables having a
global ordering (and preceding the x-variables) and the x-variables having
a local ordering. In a local situation we propose @code{eliminate} with
ordering ls.

In any case, if the input is weighted homogeneous (=quasihomogeneous),
the weights given to the variables should be chosen accordingly.
@sc{Singular} offers a function @code{weight} which proposes,
given an ideal or module, integer weights for the variables, such that
the ideal, resp.@: module, is as homogeneous as possible with respect to these weights.
The function finds correct weights, if the input is weighted homogeneous
(but is rather slow for many variables). In order to check, whether the
input is quasihomogeneous, use the function @code{qhweight}, which returns
an intvec of correct weights if the input is quasihomogeneous and an intvec
of zeros otherwise.

Let us give two examples:
@enumerate
@item
First we compute the equations of the simple space curve
@tex
$\hbox{T}[7]^\prime$
@end tex
@ifinfo
T[7]'
@end ifinfo
   consisting of two tangential cusps given in parametric form.
@item
We compute weights for the equations such that the
   equations are quasihomogeneous w.r.t. these weights.
@item
Then we compute the tangent developable of the rational
   normal curve in
@tex
$P^4$.
@end tex
@ifinfo
P^4.
@end ifinfo
@end enumerate

@smallexample
@c computed example Elimination examples.doc:1058 
  // 1. Compute equations of curve given in parametric form:
  // Two transversal cusps in (k^3,0):
  ring r1 = 0,(t,x,y,z),ls;
  ideal i1 = x-t2,y-t3,z;        // parametrization of the first branch
  ideal i2 = y-t2,z-t3,x;        // parametrization of the second branch
  ideal j1 = eliminate(i1,t);
  j1;                            // equations of the first branch
@expansion{} j1[1]=z
@expansion{} j1[2]=y2-x3
  ideal j2 = eliminate(i2,t);
  j2;                            // equations of the second branch
@expansion{} j2[1]=x
@expansion{} j2[2]=z2-y3
  // Now map to a ring with only x,y,z as variables and compute the
  // intersection of j1 and j2 there:
  ring r2 = 0,(x,y,z),ds;
  ideal j1= imap(r1,j1);         // imap is a convenient ringmap for
  ideal j2= imap(r1,j2);         // inclusions and projections of rings
  ideal i = intersect(j1,j2);
  i;                             // equations of both branches
@expansion{} i[1]=z2-y3+x3y
@expansion{} i[2]=xz
@expansion{} i[3]=xy2-x4
@expansion{} i[4]=x3z
  //
  // 2. Compute the weights:
  intvec v= qhweight(i);         // compute weights
  v;
@expansion{} 4,6,9
  //
  // 3. Compute the tangent developable
  // The tangent developable of a projective variety given parametrically
  // by F=(f1,...,fn) : P^r --> P^n is the union of all tangent spaces
  // of the image. The tangent space at a smooth point F(t1,...,tr)
  // is given as the image of the tangent space at (t1,...,tr) under
  // the tangent map (affine coordinates)
  //   T(t1,...,tr): (y1,...,yr) --> jacob(f)*transpose((y1,...,yr))
  // where jacob(f) denotes the jacobian matrix of f with respect to the
  // t's evaluated at the point (t1,...,tr).
  // Hence we have to create the graph of this map and then to eliminate
  // the t's and y's.
  // The rational normal curve in P^4 is given as the image of
  //        F(s,t) = (s4,s3t,s2t2,st3,t4)
  // each component being homogeneous of degree 4.
  ring P = 0,(s,t,x,y,a,b,c,d,e),dp;
  ideal M = maxideal(1);
  ideal F = M[1..2];     // take the 1st two generators of M
  F=F^4;
  // simplify(...,2); deletes 0-columns
  matrix jac = simplify(jacob(F),2);
  ideal T = x,y;
  ideal J = jac*transpose(T);
  ideal H = M[5..9];
  ideal i = H-J;         // this is tricky: difference between two
                         // ideals is not defined, but between two
                         // matrices. By automatic type conversion
                         // the ideals are converted to matrices,
                         // subtracted and afterwards converted
                         // to an ideal. Note that '+' is defined
                         // and adds (concatenates) two ideals
  i;
@expansion{} i[1]=-4s3x+a
@expansion{} i[2]=-3s2tx-s3y+b
@expansion{} i[3]=-2st2x-2s2ty+c
@expansion{} i[4]=-t3x-3st2y+d
@expansion{} i[5]=-4t3y+e
  // Now we define a ring with product ordering and weights 4
  // for the variables a,...,e.
  // Then we map i from P to P1 and eliminate s,t,x,y from i.
  ring P1 = 0,(s,t,x,y,a,b,c,d,e),(dp(4),wp(4,4,4,4,4));
  ideal i = fetch(P,i);
  ideal j= eliminate(i,stxy);    // equations of tangent developable
  j;
@expansion{} j[1]=3c2-4bd+ae
@expansion{} j[2]=2bcd-3ad2-3b2e+4ace
@expansion{} j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde
  // We can use the product ordering to eliminate s,t,x,y from i
  // by a std-basis computation.
  // We need proc 'nselect' from elim.lib.
  LIB "elim.lib";
  j = std(i);                    // compute a std basis j
  j = nselect(j,1,4);            // select generators from j not
  j;                             // containing variable 1,...,4
@expansion{} j[1]=3c2-4bd+ae
@expansion{} j[2]=2bcd-3ad2-3b2e+4ace
@expansion{} j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde
@c end example Elimination examples.doc:1058
@end smallexample
@c  killall();


@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Free resolution, Computation of Ext, Elimination, Examples
@end ifset
@ifclear singularmanual
@node Free resolution, Formatting output, Elimination, Examples
@end ifclear
@section  Free resolution
@cindex  Free resolution

In @sc{Singular} a free resolution of a module or ideal has its own type:
@code{resolution}. It is a structure that stores all information related to
free resolutions. This allows partial computations of resolutions via
the command @code{res}. After applying @code{res}, only a pre-format of the
resolution is computed which allows to determine invariants like
Betti-numbers or homological dimension. To see the differentials
of the complex, a resolution must be converted into the type list which
yields a list of modules: the k-th module in this
list is the first syzygy-module (module of relations) of the (k-1)st module.
There are the following commands to compute a resolution:
@table @code
@item res
@ifset singularmanual
@ref{res}@*
@end ifset
computes a free resolution of an ideal or module using a heuristically
chosen method.
This is the preferred method to compute free resolutions of ideals or
modules.
@item lres
@ifset singularmanual
@ref{lres}@*
@end ifset
computes a free resolution of an ideal or module with La Scala's
method. The input needs to be homogeneous.
@item mres
@ifset singularmanual
@ref{mres}@*
@end ifset
computes a minimal free resolution of an ideal or module with the syzygy
method.
@item sres
@ifset singularmanual
@ref{sres}@*
@end ifset
computes a free resolution of an ideal or module with Schreyer's
method. The input has to be a standard basis.
@item nres
@ifset singularmanual
@ref{nres}@*
@end ifset
computes a free resolution of an ideal or module with the standard basis
method.
@item minres
@ifset singularmanual
@ref{minres}@*
@end ifset
minimizes a free resolution of an ideal or module.
@item syz
@ifset singularmanual
@ref{syz}@*
@end ifset
computes the first syzygy module.
@end table
@code{res(i,r)}, @code{lres(i,r)}, @code{sres(i,r)}, @code{mres(i,r)},
@code{nres(i,r)} compute the first r modules of the resolution
of i, resp.@: the full resolution if r=0 and the basering is not a qring.
See the manual for a precise description of these commands.
@*Note: The command @code{betti} does not require a minimal
resolution for the minimal betti numbers.

Now let's look at an example which uses resolutions: The Hilbert-Burch
theorem says that the ideal i of a reduced curve in
@tex
$K^3$
@end tex
@ifinfo
K^3
@end ifinfo
has a free resolution of length 2 and that i is given by the 2x2 minors
of the 2nd matrix in the resolution.
We test this for two transversal cusps in
@tex
$K^3$.
@end tex
@ifinfo
K^3.
@end ifinfo
Afterwards we compute the resolution of the ideal j of the tangent developable
of the rational normal curve in
@tex
$P^4$
@end tex
@ifinfo
P^4
@end ifinfo
from above.
Finally we demonstrate the use of the type @code{resolution} in connection with
the @code{lres} command.

@smallexample
@c computed example Free_resolution examples.doc:1231 
  // Two transversal cusps in (k^3,0):
  ring r2 =0,(x,y,z),ds;
  ideal i =z2-1y3+x3y,xz,-1xy2+x4,x3z;
  resolution rs=mres(i,0);   // computes a minimal resolution
  rs;                        // the standard representation of complexes
@expansion{}   1       3       2       
@expansion{} r2 <--  r2 <--  r2
@expansion{} 
@expansion{} 0       1       2       
@expansion{} 
    list resi=rs;            // convertion to a list
  print(resi[1]);            // the 1st module is i minimized
@expansion{} xz,
@expansion{} z2-y3+x3y,
@expansion{} xy2-x4
  print(resi[2]);            // the 1st syzygy module of i
@expansion{} -z,-y2+x3,
@expansion{} x, 0,     
@expansion{} y, z      
  resi[3];                   // the 2nd syzygy module of i
@expansion{} _[1]=0
  ideal j=minor(resi[2],2);
  reduce(j,std(i));          // check whether j is contained in i
@expansion{} _[1]=0
@expansion{} _[2]=0
@expansion{} _[3]=0
  size(reduce(i,std(j)));    // check whether i is contained in j
@expansion{} 0
  // size(<ideal>) counts the non-zero generators
  // ---------------------------------------------
  // The tangent developable of the rational normal curve in P^4:
  ring P = 0,(a,b,c,d,e),dp;
  ideal j= 3c2-4bd+ae, -2bcd+3ad2+3b2e-4ace,
           8b2d2-9acd2-9b2ce+9ac2e+2abde-1a2e2;
  resolution rs=mres(j,0);
  rs;
@expansion{}  1      2      1      
@expansion{} P <--  P <--  P
@expansion{} 
@expansion{} 0      1      2      
@expansion{} 
  list L=rs;
  print(L[2]);
@expansion{} 2bcd-3ad2-3b2e+4ace,
@expansion{} -3c2+4bd-ae         
  // create an intmat with graded betti numbers
  intmat B=betti(rs);
  // this gives a nice output of betti numbers
  print(B,"betti");
@expansion{}            0     1     2
@expansion{} ------------------------
@expansion{}     0:     1     -     -
@expansion{}     1:     -     1     -
@expansion{}     2:     -     1     -
@expansion{}     3:     -     -     1
@expansion{} ------------------------
@expansion{} total:     1     2     1
  // the user has access to all betti numbers
  // the 2-nd column of B:
  B[1..4,2];
@expansion{} 0 1 1 0
  ring cyc5=32003,(a,b,c,d,e,h),dp;
  ideal i=
  a+b+c+d+e,
  ab+bc+cd+de+ea,
  abc+bcd+cde+dea+eab,
  abcd+bcde+cdea+deab+eabc,
  h5-abcde;
  resolution rs=lres(i,0);   //computes the resolution according La Scala
  rs;                        //the shape of the minimal resolution
@expansion{}     1         5         10         10         5         1         
@expansion{} cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
@expansion{} 
@expansion{} 0         1         2          3          4         5         
@expansion{} resolution not minimized yet
@expansion{} 
  print(betti(rs),"betti");  //shows the Betti-numbers of cyclic 5
@expansion{}            0     1     2     3     4     5
@expansion{} ------------------------------------------
@expansion{}     0:     1     1     -     -     -     -
@expansion{}     1:     -     1     1     -     -     -
@expansion{}     2:     -     1     1     -     -     -
@expansion{}     3:     -     1     2     1     -     -
@expansion{}     4:     -     1     2     1     -     -
@expansion{}     5:     -     -     2     2     -     -
@expansion{}     6:     -     -     1     2     1     -
@expansion{}     7:     -     -     1     2     1     -
@expansion{}     8:     -     -     -     1     1     -
@expansion{}     9:     -     -     -     1     1     -
@expansion{}    10:     -     -     -     -     1     1
@expansion{} ------------------------------------------
@expansion{} total:     1     5    10    10     5     1
  dim(rs);                   //the homological dimension
@expansion{} 4
  size(list(rs));            //gets the full (non-reduced) resolution
@expansion{} 6
  minres(rs);                //minimizes the resolution
@expansion{}     1         5         10         10         5         1         
@expansion{} cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
@expansion{} 
@expansion{} 0         1         2          3          4         5         
@expansion{} 
  size(list(rs));            //gets the minimized resolution
@expansion{} 6
@c end example Free_resolution examples.doc:1231
@end smallexample


@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Computation of Ext, Polar curves, Free resolution, Examples
@section  Computation of Ext
@cindex  Ext

We start by showing how to calculate the 
@ifinfo
@math{n}
@end ifinfo
@tex
$n$
@end tex
-th Ext group of an
ideal. The ingredients to do this are by the definition of Ext the
following: calculate a (minimal) resolution at least up to length

@ifinfo
@math{n}
@end ifinfo
@tex
$n$
@end tex
, apply the Hom-functor, and calculate the 
@ifinfo
@math{n}
@end ifinfo
@tex
$n$
@end tex
-th homology
group, that is form the quotient
@tex
$\hbox{\rm ker} / \hbox{\rm Im}$
@end tex
@ifinfo
ker/Im
@end ifinfo
in the resolution sequence.

The Hom functor is given simply by transposing (hence dualizing) the
module or the corresponding matrix with the command @code{transpose}.
The image of the 
@ifinfo
@math{(n-1)}
@end ifinfo
@tex
$(n-1)$
@end tex
-st map is generated by the columns of the
corresponding matrix. To calculate the kernel apply the command
@code{syz} at the 
@ifinfo
@math{(n-1)}
@end ifinfo
@tex
$(n-1)$
@end tex
-st transposed entry of the resolution.
Finally, the quotient is obtained by the command @code{modulo}, which
gives for two modules A = ker, B = Im the module of relations of
@tex
$A/(A \cap B)$
@end tex
@ifinfo
A/(A intersect B)
@end ifinfo
in the usual way. As we have a chain complex this is obviously the same
as ker/Im.

We collect these statements in the following short procedure:

@smallexample
proc ext(int n, ideal I)
@{
  resolution rs = mres(I,n+1);
  module tAn    = transpose(rs[n+1]);
  module tAn_1  = transpose(rs[n]);
  module ext_n  = modulo(syz(tAn),tAn_1);
  return(ext_n);
@}
@end smallexample

Now consider the following example:

@smallexample
ring r5 = 32003,(a,b,c,d,e),dp;
ideal I = a2b2+ab2c+b2cd, a2c2+ac2d+c2de,a2d2+ad2e+bd2e,a2e2+abe2+bce2;
print(ext(2,I));
@expansion{} 1,0,0,0,0,0,0,
@expansion{} 0,1,0,0,0,0,0,
@expansion{} 0,0,1,0,0,0,0,
@expansion{} 0,0,0,1,0,0,0,
@expansion{} 0,0,0,0,1,0,0,
@expansion{} 0,0,0,0,0,1,0,
@expansion{} 0,0,0,0,0,0,1
ext(3,I);   // too big to be displayed here
@end smallexample

The library @code{homolog.lib} contains several procedures for computing
Ext-modules and related modules, which are much more general and
sophisticated then the above one. They are used in the following
example.

If 
@ifinfo
@math{M}
@end ifinfo
@tex
$M$
@end tex
 is a module, then
@tex
$\hbox{Ext}^1(M,M)$, resp.\ $\hbox{Ext}^2(M,M)$,
@end tex
@ifinfo
Ext^1(M,M), resp.@: Ext^2(M,M),
@end ifinfo
are the modules of infinitesimal deformations, resp.@: of obstructions, of

@ifinfo
@math{M}
@end ifinfo
@tex
$M$
@end tex
 (like T1 and T2 for a singularity).  Similar to the treatment
for singularities, the semiuniversal deformation of 
@ifinfo
@math{M}
@end ifinfo
@tex
$M$
@end tex
 can be
computed (if
@tex
$\hbox{Ext}^1$
@end tex
@ifinfo
Ext^1
@end ifinfo
is finite dimensional) with the help of
@tex
$\hbox{Ext}^1$, $\hbox{Ext}^2$
@end tex
@ifinfo
Ext^1, Ext^2
@end ifinfo
and the cup product. There is an extra procedure for
@tex
$\hbox{Ext}^k(R/J,R)$
@end tex
@ifinfo
Ext^k(R/J,R)
@end ifinfo
if 
@ifinfo
@math{J}
@end ifinfo
@tex
$J$
@end tex
 is an ideal in 
@ifinfo
@math{R}
@end ifinfo
@tex
$R$
@end tex
 since this is faster than the
general Ext.

We compute
@itemize @bullet
@item
the infinitesimal deformations
@tex
($=\hbox{Ext}^1(K,K)$)
@end tex
@ifinfo
(=Ext^1(K,K))
@end ifinfo
and obstructions
@tex
($=\hbox{Ext}^2(K,K)$)
@end tex
@ifinfo
(=Ext^2(K,K))
@end ifinfo
of the residue field 
@ifinfo
@math{K=R/m}
@end ifinfo
@tex
$K=R/m$
@end tex
 of an ordinary cusp,
@tex
$R=Loc_m K[x,y]/(x^2-y^3)$, $m=(x,y)$.
@end tex
@ifinfo
R=Loc_m K[x,y]/(x^2-y^3), m=(x,y).
@end ifinfo
To compute
@tex
$\hbox{Ext}^1(m,m)$
@end tex
@ifinfo
Ext^1(m,m),
@end ifinfo
we have to apply @code{Ext(1,syz(m),syz(m))} with
@code{syz(m)} the first syzygy module of 
@ifinfo
@math{m}
@end ifinfo
@tex
$m$
@end tex
, which is isomorphic to
@tex
$\hbox{Ext}^2(K,K)$.
@end tex
@ifinfo
Ext^2(K,K).
@end ifinfo
@item
@tex
$\hbox{Ext}^k(R/i,R)$
@end tex
@ifinfo
Ext^k(R/i,R)
@end ifinfo
for some ideal 
@ifinfo
@math{i}
@end ifinfo
@tex
$i$
@end tex
 and with an extra option.
@end itemize

@smallexample
@c computed example Computation_of_Ext examples.doc:1432 
  LIB "homolog.lib";
  ring R=0,(x,y),ds;
  ideal i=x2-y3;
  qring q = std(i);      // defines the quotient ring Loc_m k[x,y]/(x2-y3)
  ideal m = maxideal(1);
  module T1K = Ext(1,m,m);  // computes Ext^1(R/m,R/m)
@expansion{} // dimension of Ext^1:  0
@expansion{} // vdim of Ext^1:       2
@expansion{} 
  print(T1K);
@expansion{} 0,  0,y,x,0,y,0,    x2-y3,
@expansion{} -y2,x,x,0,y,0,x2-y3,0,    
@expansion{} 1,  0,0,0,0,0,0,    0     
  printlevel=2;             // gives more explanation
  module T2K=Ext(2,m,m);    // computes Ext^2(R/m,R/m)
@expansion{} // Computing Ext^2 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F2,G0)-->Hom(F3,G0) is given by:
@expansion{} y2,x,
@expansion{} x, y 
@expansion{} // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
@expansion{} -y,x,  x,0,y,0,
@expansion{} x, -y2,0,x,0,y 
@expansion{} 
@expansion{} // dimension of Ext^2:  0
@expansion{} // vdim of Ext^2:       2
@expansion{} 
  print(std(T2K));
@expansion{} -y2,0,x,0,y,
@expansion{} 0,  x,0,y,0,
@expansion{} 1,  0,0,0,0 
  printlevel=0;
  module E = Ext(1,syz(m),syz(m));
@expansion{} // dimension of Ext^1:  0
@expansion{} // vdim of Ext^1:       2
@expansion{} 
  print(std(E));
@expansion{} -y,x, 0, 0,0,x,0,y,
@expansion{} 0, -y,-y,0,x,0,y,0,
@expansion{} 0, 0, 0, 1,0,0,0,0,
@expansion{} 0, 0, 1, 0,0,0,0,0,
@expansion{} 0, 1, 0, 0,0,0,0,0,
@expansion{} 1, 0, 0, 0,0,0,0,0 
  //The matrices which we have just computed are presentation matrices
  //of the modules T2K and E. Hence we may ignore those columns
  //containing 1 as an entry and see that T2K and E are isomorphic
  //as expected, but differently presented.
  //-------------------------------------------
  ring S=0,(x,y,z),dp;
  ideal  i = x2y,y2z,z3x;
  module E = Ext_R(2,i);
@expansion{} // dimension of Ext^2:  1
@expansion{} 
  print(E);
@expansion{} 0,y,0,z2,
@expansion{} z,0,0,-x,
@expansion{} 0,0,x,-y 
  // if a 3-rd argument is given (of any type)
  // a list of Ext^k(R/i,R), a SB of Ext^k(R/i,R) and a vector space basis
  // is returned:
  list LE = Ext_R(3,i,"");
@expansion{} // dimension of Ext^3:  0
@expansion{} // vdim of Ext^3:       2
@expansion{} 
  LE;
@expansion{} [1]:
@expansion{}    _[1]=y*gen(1)
@expansion{}    _[2]=x*gen(1)
@expansion{}    _[3]=z2*gen(1)
@expansion{} [2]:
@expansion{}    _[1]=y*gen(1)
@expansion{}    _[2]=x*gen(1)
@expansion{}    _[3]=z2*gen(1)
@expansion{} [3]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=1
  print(LE[2]);
@expansion{} y,x,z2
  print(kbase(LE[2]));
@expansion{} z,1
@c end example Computation_of_Ext examples.doc:1432
@end smallexample
@c  killall();
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Polar curves, Depth, Computation of Ext, Examples
@section   Polar curves
@cindex Polar curves

The polar curve of a hypersurface given by a polynomial
@tex
$f\in k[x_1,\ldots,x_n,t]$
@end tex
@ifinfo
f in k[x1,...,xn,t]
@end ifinfo
with respect to 
@ifinfo
@math{t}
@end ifinfo
@tex
$t$
@end tex
 (we may consider 
@ifinfo
@math{f=0}
@end ifinfo
@tex
$f=0$
@end tex
 as a family of
hypersurfaces parametrized by 
@ifinfo
@math{t}
@end ifinfo
@tex
$t$
@end tex
) is defined as the Zariski
closure of
@tex
$V(\partial f/\partial x_1,\ldots,\partial f/\partial x_n) \setminus V(f)$
@end tex
@ifinfo
V(diff(f,x1),...,diff(f,xn)) \ V(f)
@end ifinfo
if this happens to be a curve.  Some authors consider
@tex
$V(\partial f/\partial x_1,\ldots,\partial f/\partial x_n)$
@end tex
@ifinfo
V(diff(f,x1),...,diff(f,xn))
@end ifinfo
itself as polar curve.

We may consider projective hypersurfaces
@tex
(in $P^n$),
@end tex
@ifinfo
(in P^n),
@end ifinfo
affine hypersurfaces
@tex
(in $k^n$)
@end tex
@ifinfo
(in k^n)
@end ifinfo
or germs of hypersurfaces
@tex
(in $(k^n,0)$),
@end tex
@ifinfo
(in (k^n,0)),
@end ifinfo
getting in this way
projective, affine or local polar curves.

Now let us compute this for a family of curves.  We need the library
@code{elim.lib} for saturation and @code{sing.lib} for the singular
locus.

@smallexample
@c computed example Polar_curves examples.doc:1526 
  LIB "elim.lib";
  LIB "sing.lib";
  // Affine polar curve:
  ring R = 0,(x,z,t),dp;              // global ordering dp
  poly f = z5+xz3+x2-tz6;
  dim_slocus(f);                      // dimension of singular locus
@expansion{} 1
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // dim V(j)
@expansion{} 1
  dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
@expansion{} 1
  // j defines a curve, but to get the polar curve we must remove the
  // branches contained in f=0 (they exist since dim V(j,f) = 1). This
  // gives the polar curve set theoretically. But for the structure we
  // may take either j:f or j:f^k for k sufficiently large. The first is
  // just the ideal quotient, the second the iterated ideal quotient
  // or saturation. In our case both coincide.
  ideal q = quotient(j,ideal(f));     // ideal quotient
  ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
  ideal sq = std(q);
  dim(sq);
@expansion{} 1
  // 1-dimensional, hence q defines the affine polar curve
  //
  // to check that q and qsat are the same, we show both inclusions, i.e.,
  // both reductions must give the 0-ideal
  size(reduce(qsat,sq));
@expansion{} 0
  size(reduce(q,std(qsat)));
@expansion{} 0
  qsat;
@expansion{} qsat[1]=12zt+3z-10
@expansion{} qsat[2]=5z2+12xt+3x
@expansion{} qsat[3]=144xt2+72xt+9x+50z
  // We see that the affine polar curve does not pass through the origin,
  // hence we expect the local polar "curve" to be empty
  // ------------------------------------------------
  // Local polar curve:
  ring r = 0,(x,z,t),ds;              // local ordering ds
  poly f = z5+xz3+x2-tz6;
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // V(j) 1-dimensional
@expansion{} 1
  dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
@expansion{} 1
  ideal q = quotient(j,ideal(f));     // ideal quotient
  q;
@expansion{} q[1]=1
  // The local polar "curve" is empty, i.e., V(j) is contained in V(f)
  // ------------------------------------------------
  // Projective polar curve: (we need "sing.lib" and "elim.lib")
  ring P = 0,(x,z,t,y),dp;            // global ordering dp
  poly f = z5y+xz3y2+x2y4-tz6;
                                      // but consider t as parameter
  dim_slocus(f);              // projective 1-dimensional singular locus
@expansion{} 2
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // V(j), projective 1-dimensional
@expansion{} 2
  dim(std(j+ideal(f)));               // V(j,f) also projective 1-dimensional
@expansion{} 2
  ideal q = quotient(j,ideal(f));
  ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
  dim(std(qsat));
@expansion{} 2
  // projective 1-dimensional, hence q and/or qsat define the projective
  // polar curve. In this case, q and qsat are not the same, we needed
  // 2 quotients.
  // Let us check both reductions:
  size(reduce(qsat,std(q)));
@expansion{} 4
  size(reduce(q,std(qsat)));
@expansion{} 0
  // Hence q is contained in qsat but not conversely
  q;
@expansion{} q[1]=12zty+3zy-10y2
@expansion{} q[2]=60z2t-36xty-9xy-50zy
  qsat;
@expansion{} qsat[1]=12zt+3z-10y
@expansion{} qsat[2]=12xty+5z2+3xy
@expansion{} qsat[3]=144xt2+72xt+9x+50z
@expansion{} qsat[4]=z3+2xy2
  //
  // Now consider again the affine polar curve,
  // homogenize it with respect to y (deg t=0) and compare:
  // affine polar curve:
  ideal qa = 12zt+3z-10,5z2+12xt+3x,-144xt2-72xt-9x-50z;
  // homogenized:
  ideal qh = 12zt+3z-10y,5z2+12xyt+3xy,-144xt2-72xt-9x-50z;
  size(reduce(qh,std(qsat)));
@expansion{} 0
  size(reduce(qsat,std(qh)));
@expansion{} 0
  // both ideals coincide
@c end example Polar_curves examples.doc:1526
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Depth, Formatting output, Polar curves, Examples
@section Depth
@cindex Depth

We compute the depth of the module of Kaehler differentials
@tex
D$_k$(R)
@end tex
@ifinfo
D_k(R)
@end ifinfo
of the variety defined by the 
@ifinfo
@math{(m+1)}
@end ifinfo
@tex
$(m+1)$
@end tex
-minors of a generic symmetric
@tex
$(n \times n)$-matrix.
@end tex
@ifinfo
(n x n)-matrix.
@end ifinfo
We do this by computing the resolution over the polynomial
ring.  Then, by the Auslander-Buchsbaum formula, the depth is equal to
the number of variables minus the length of a minimal resolution.  This
example was suggested by U.@: Vetter in order to check whether his bound
@tex
$\hbox{depth}(\hbox{D}_k(R))\geq m(m+1)/2 + m-1$
@end tex
@ifinfo
depth(D_k(R)) >= m(m+1)/2 + m-1
@end ifinfo
could be improved.

@smallexample
@c computed example Depth examples.doc:1632 
  LIB "matrix.lib"; LIB "sing.lib";
  int n = 4;
  int m = 3;
  int N = n*(n+1)/2;           // will become number of variables
  ring R = 32003,x(1..N),dp;
  matrix X = symmat(n);        // proc from matrix.lib
                               // creates the symmetric generic nxn matrix
  print(X);
@expansion{} x(1),x(2),x(3),x(4),
@expansion{} x(2),x(5),x(6),x(7),
@expansion{} x(3),x(6),x(8),x(9),
@expansion{} x(4),x(7),x(9),x(10)
  ideal J = minor(X,m);
  J=std(J);
  // Kaehler differentials D_k(R)
  // of R=k[x1..xn]/J:
  module D = J*freemodule(N)+transpose(jacob(J));
  ncols(D);
@expansion{} 110
  nrows(D);
@expansion{} 10
  //
  // Note: D is a submodule with 110 generators of a free module
  // of rank 10 over a polynomial ring in 10 variables.
  // Compute a full resolution of D with sres.
  // This takes about 17 sec on a Mac PB 520c and 2 sec an a HP 735
  int time = timer;
  module sD = std(D);
  list Dres = sres(sD,0);                // the full resolution
  timer-time;                            // time used for std + sres
@expansion{} 0
  intmat B = betti(Dres);
  print(B,"betti");
@expansion{}            0     1     2     3     4     5     6
@expansion{} ------------------------------------------------
@expansion{}     0:    10     -     -     -     -     -     -
@expansion{}     1:     -    10     -     -     -     -     -
@expansion{}     2:     -    84   144    60     -     -     -
@expansion{}     3:     -     -    35    80    60    16     1
@expansion{} ------------------------------------------------
@expansion{} total:    10    94   179   140    60    16     1
  N-ncols(B)+1;                          // the desired depth
@expansion{} 4
@c end example Depth examples.doc:1632
@end smallexample
@c  killall();
@end ifset

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Formatting output, Cyclic roots, Depth, Examples
@end ifset
@ifclear singularmanual
@node Formatting output, Factorization, Free resolution, Examples
@end ifclear
@section Formatting output
@cindex Formatting output

We show how to insert the result of a computation inside a text
by using strings.
First we compute the powers of 2 and comment the result with some text.
Then we do the same and give the output a nice format by computing and
adding appropriate space.

@smallexample
@c computed example Formatting_output examples.doc:1682 
  // The powers of 2:
  int  n;
  for (n = 2; n <= 128; n = n * 2)
  @{"n = " + string (n);@}
@expansion{} n = 2
@expansion{} n = 4
@expansion{} n = 8
@expansion{} n = 16
@expansion{} n = 32
@expansion{} n = 64
@expansion{} n = 128
  // The powers of 2 in a nice format
  int j;
  string space = "";
  for (n = 2; n <= 128; n = n * 2)
  @{
    space = "";
    for (j = 1; j <= 5 - size (string (n)); j = j+1)
    @{ space = space + " "; @}
    "n =" + space + string (n);
  @}
@expansion{} n =    2
@expansion{} n =    4
@expansion{} n =    8
@expansion{} n =   16
@expansion{} n =   32
@expansion{} n =   64
@expansion{} n =  128
@c end example Formatting_output examples.doc:1682
@end smallexample

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Cyclic roots, G_a -Invariants, Formatting output, Examples
@section Cyclic roots
@cindex Cyclic roots

We write a procedure returning a string that enables us to create
automatically the ideal of cyclic roots over the basering with n
variables. The procedure assumes that the variables consist of a single
letter each (hence no indexed variables are allowed; the procedure
@code{cyclic} in @code{poly.lib} does not have this restriction). Then
we compute a standard basis of this ideal and some numerical
information.  (This ideal is used as a classical benchmark for standard
basis computations).

@smallexample
// We call the procedure 'cyclic':
proc cyclic (int n)
@{
   string vs = varstr(basering)+varstr(basering);
   int c=find(vs,",");
   while ( c!=0 )
   @{
      vs=vs[1,c-1]+vs[c+1,size(vs)];
      c=find(vs,",");
   @}
   string t,s;
   int i,j;
   for ( j=1; j<=n-1; j=j+1 )
   @{
      t="";
      for ( i=1; i <=n; i=i+1 )
      @{
         t = t + vs[i,j] + "+";
      @}
      t = t[1,size(t)-1] + ","+newline;
      s=s+t;
   @}
   s=s+vs[1,n]+"-1";
   return (s);
@}

ring r=0,(a,b,c,d,e),lp;         // basering, char 0, lex ordering
string sc=cyclic(nvars(basering));
sc;                              // the string of the ideal
@expansion{} a+b+c+d+e,
@expansion{} ab+bc+cd+de+ea,
@expansion{} abc+bcd+cde+dea+eab,
@expansion{} abcd+bcde+cdea+deab+eabc,
@expansion{} abcde-1
execute("ideal i="+sc+";");      // this defines the ideal of cyclic roots
i;
@expansion{} i[1]=a+b+c+d+e
@expansion{} i[2]=ab+bc+cd+ae+de
@expansion{} i[3]=abc+bcd+abe+ade+cde
@expansion{} i[4]=abcd+abce+abde+acde+bcde
@expansion{} i[5]=abcde-1
timer=1;
ideal j=std(i);
@expansion{} //used time: 7.5 sec
size(j);                         // number of elements in the std basis
@expansion{} 11
degree(j);
@expansion{} // codimension = 5
@expansion{} // dimension   = 0
@expansion{} // degree      = 70
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node G_a -Invariants, Invariants of a finite group, Cyclic roots, Examples
@section G_a -Invariants
@cindex G_a -Invariants

We work in characteristic 0 and use the Lie algebra generated by one
vector field of the form
@tex
$\sum x_i \partial /\partial x_{i+1}$.
@end tex
@ifinfo
sum x(i)*d/dx(i+1).
@end ifinfo
@smallexample
@c computed example G_a_-Invariants examples.doc:1783 
  LIB "ainvar.lib";
  int n=5;
  int i;
  ring s=32003,(x(1..n)),wp(1,2,3,4,5);
  // definition of the vector field m=sum m[i,1]*d/dx(i)
  matrix m[n][1];
  for (i=1;i<=n-1;i=i+1)
  @{
     m[i+1,1]=x(i);
  @}
  // computation of the ring of invariants
  ideal in=invariantRing(m,x(2),x(1),0);
  in;   //invariant ring is generated by 5 invariants
@expansion{} in[1]=x(1)
@expansion{} in[2]=x(2)^2-2*x(1)*x(3)
@expansion{} in[3]=x(3)^2-2*x(2)*x(4)+2*x(1)*x(5)
@expansion{} in[4]=x(2)^3-3*x(1)*x(2)*x(3)+3*x(1)^2*x(4)
@expansion{} in[5]=x(3)^3-3*x(2)*x(3)*x(4)-15997*x(1)*x(4)^2+3*x(2)^2*x(5)-6*x(1)*x(3)\
   *x(5)
  ring q=32003,(x,y,z,u,v,w),dp;
  matrix m[6][1];
  m[2,1]=x;
  m[3,1]=y;
  m[5,1]=u;
  m[6,1]=v;
  // the vector field is: xd/dy+yd/dz+ud/dv+vd/dw
  ideal in=invariantRing(m,y,x,0);
  in; //invariant ring is generated by 6 invariants
@expansion{} in[1]=x
@expansion{} in[2]=u
@expansion{} in[3]=v2-2uw
@expansion{} in[4]=zu-yv+xw
@expansion{} in[5]=yu-xv
@expansion{} in[6]=y2-2xz
@c end example G_a_-Invariants examples.doc:1783
@end smallexample
@c kill n,i,s,q;
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Invariants of a finite group, Factorization, G_a -Invariants, Examples
@section Invariants of a finite group
@cindex Invariants of a finite group

Two algorithms to compute the invariant ring are implemented in
@sc{Singular}, @code{invariant_ring} and @code{invariant_ring_random},
both by Agnes E. Heydtmann (@code{agnes@@math.uni-sb.de}).

Bases of homogeneous invariants are generated successively and those are
chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1997) to appear in JSC).  In the
non-modular case secondary invariants are calculated by finding a basis
(in terms of monomials) of the basering modulo the primary invariants,
mapping to invariants with the Reynolds operator and using those or
their power products such that they are linearly independent modulo the
primary invariants (see paper "Some Algorithms in Invariant Theory of
Finite Groups" by Kemper and Steel (1997)).  In the modular case they
are generated according to "Generating Invariant Rings of Finite Groups
over Arbitrary Fields" by Kemper (1996, to appear in JSC).

We calculate now an example from Sturmfels: "Algorithms in Invariant
Theory 2.3.7":

@smallexample
@c computed example Invariants_of_a_finite_group examples.doc:1838 
  LIB "finvar.lib";
  ring R=0,(x,y,z),dp;
  matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
  // the group G is generated by A in Gl(3,Q);
  print(A);
@expansion{} 0, 1,0,
@expansion{} -1,0,0,
@expansion{} 0, 0,-1
  print(A*A*A*A); // the fourth power of A is 1
@expansion{} 1,0,0,
@expansion{} 0,1,0,
@expansion{} 0,0,1 
  // Use the first method to compute the invariants of G:
  matrix B(1..3);
  B(1..3)=invariant_ring(A);
  // SINGULAR returns 2 matrices, the first containing
  // primary invariants and the second secondary
  // invariants, i.e., module generators over a Noetherian
  // normalization
  // the third result are the irreducible secondary invariants
  // if the Molien series was available
  print(B(1));
@expansion{} z2,x2+y2,x2y2
  print(B(2));
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
  print(B(3));
@expansion{} xyz,x2z-y2z,x3y-xy3
  // Use the second method,
  // with random numbers between -1 and 1:
  B(1..3)=invariant_ring_random(A,1);
  print(B(1..3));
@expansion{} z2,x2+y2,x4+y4-z4
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
@expansion{} xyz,x2z-y2z,x3y-xy3
@c end example Invariants_of_a_finite_group examples.doc:1838
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Factorization, Puiseux pairs, Invariants of a finite group, Examples
@end ifset
@ifclear singularmanual
@node Factorization, Kernel of module homomorphisms, Formatting output, Examples
@end ifclear
@section Factorization
@cindex Factorization

The factorization of polynomials is implemented in the C++ libraries
Factory (written mainly by Ruediger Stobbe) and libfac (written by
Michael Messollen) which are part of the @sc{Singular} system.

@smallexample
@c computed example Factorization examples.doc:1879 
  ring r = 0,(x,y),dp;
  poly f = 9x16-18x13y2-9x12y3+9x10y4-18x11y2+36x8y4
         +18x7y5-18x5y6+9x6y4-18x3y6-9x2y7+9y8;
  // = 9 * (x5-1y2)^2 * (x6-2x3y2-1x2y3+y4)
  factorize(f);
@expansion{} [1]:
@expansion{}    _[1]=9
@expansion{}    _[2]=x6-2x3y2-x2y3+y4
@expansion{}    _[3]=-x5+y2
@expansion{} [2]:
@expansion{}    1,1,2
  // returns factors and multiplicities,
  // first factor is a constant.
  poly g = (y4+x8)*(x2+y2);
  factorize(g);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x8+y4
@expansion{}    _[3]=x2+y2
@expansion{} [2]:
@expansion{}    1,1,1
  // The same in characteristic 2:
  ring s =2,(x,y),dp;
  poly g = (y4+x8)*(x2+y2);
  factorize(g);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x+y
@expansion{}    _[3]=x2+y
@expansion{} [2]:
@expansion{}    1,2,4
@c end example Factorization examples.doc:1879
@end smallexample

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Puiseux pairs, Primary decomposition, Factorization, Examples
@section Puiseux pairs
@cindex Puiseux pairs

The Puiseux pairs of an irreducible and reduced curve singularity are
its most important invariants.  They can be computed from its
Hamburger-Noether expansion.  The library @code{hnoether.lib} written by
Martin Lamm uses the algorithm of Antonio Campillo "Algebroid curves in
positive characteristic" SLN 813, 1980.  This algorithm has the
advantage that it needs least possible field extensions and, moreover,
works in any characteristic. This fact can be used to compute the
invariants over a field of finite characteristic, say 32003, which will
then most probably be the same in characteristic 0.

We compute the Hamburger-Noether expansion of a plane curve
singularity given by a polynomial 
@ifinfo
@math{f}
@end ifinfo
@tex
$f$
@end tex
 in two variables. This is a
matrix which allows to compute the parametrization (up to a given order)
and all numerical invariants like the
@itemize @bullet
@item
    characteristic exponents,
@item
    Puiseux pairs (of a complex model),
@item
    degree of the conductor,
@item
    delta invariant,
@item
    generators of the semigroup.
@end itemize
Besides this, the library contains procedures to compute the Newton
polygon of 
@ifinfo
@math{f}
@end ifinfo
@tex
$f$
@end tex
, the squarefree part of 
@ifinfo
@math{f}
@end ifinfo
@tex
$f$
@end tex
 and a procedure to
convert one set of invariants to another.


@smallexample
@c computed example Puiseux_pairs examples.doc:1934 
  LIB "hnoether.lib";
  // ======== The irreducible case ========
  ring s = 0,(x,y),ds;
  poly f = y4-2x3y2-4x5y+x6-x7;
  list hn = develop(f);
  show(hn[1]);     // Hamburger-Noether matrix
@expansion{} // matrix, 3x3
@expansion{} 0,x,  0,  
@expansion{} 0,1,  x,  
@expansion{} 0,1/4,-1/2
  displayHNE(hn);  // Hamburger-Noether development
@expansion{} HNE[1]=-y+z(0)*z(1)
@expansion{} HNE[2]=-x+z(1)^2+z(1)^2*z(2)
@expansion{} HNE[3]=1/4*z(2)^2-1/2*z(2)^3
  setring s;
  displayInvariants(hn);
@expansion{}  characteristic exponents  : 4,6,7
@expansion{}  generators of semigroup   : 4,6,13
@expansion{}  Puiseux pairs             : (3,2)(7,2)
@expansion{}  degree of the conductor   : 16
@expansion{}  delta invariant           : 8
@expansion{}  sequence of multiplicities: 4,2,2,1,1
  // invariants(hn);  returns the invariants as list
  // partial parametrization of f: param takes the first variable
  // as infinite except the ring has more than 2 variables. Then
  // the 3rd variable is chosen.
  param(hn);
@expansion{} // ** Warning: result is exact up to order 5 in x and 7 in y !
@expansion{} _[1]=1/16x4-3/16x5+1/4x7
@expansion{} _[2]=1/64x6-5/64x7+3/32x8+1/16x9-1/8x10
  ring extring=0,(x,y,t),ds;
  poly f=x3+2xy2+y2;
  list hn=develop(f,-1);
  param(hn);       // partial parametrization of f
@expansion{} // ** Warning: result is exact up to order 2 in x and 3 in y !
@expansion{} _[1]=-t2
@expansion{} _[2]=-t3
  list hn1=develop(f,6);
  param(hn1);     // a better parametrization
@expansion{} // ** Warning: result is exact up to order 6 in x and 7 in y !
@expansion{} _[1]=-t2+2t4-4t6
@expansion{} _[2]=-t3+2t5-4t7
  // instead of recomputing you may extend the development:
  list hn2=extdevelop(hn,12);
  param(hn2);     // a still better parametrization
@expansion{} // ** Warning: result is exact up to order 12 in x and 13 in y !
@expansion{} _[1]=-t2+2t4-4t6+8t8-16t10+32t12
@expansion{} _[2]=-t3+2t5-4t7+8t9-16t11+32t13
  //
  // ======== The reducible case ========
  ring r = 0,(x,y),dp;
  poly f=x11-2y2x8-y3x7-y2x6+y4x5+2y4x3+y5x2-y6;
  // = (x5-1y2) * (x6-2x3y2-1x2y3+y4)
  list hn=reddevelop(f);
  show(hn[1][1]);     // Hamburger-Noether matrix of 1st branch
@expansion{} // matrix, 3x3
@expansion{} 0,x,0,
@expansion{} 0,1,x,
@expansion{} 0,1,-1
  displayInvariants(hn);
@expansion{}  --- invariants of branch number 1 : ---
@expansion{}  characteristic exponents  : 4,6,7
@expansion{}  generators of semigroup   : 4,6,13
@expansion{}  Puiseux pairs             : (3,2)(7,2)
@expansion{}  degree of the conductor   : 16
@expansion{}  delta invariant           : 8
@expansion{}  sequence of multiplicities: 4,2,2,1,1
@expansion{} 
@expansion{}  --- invariants of branch number 2 : ---
@expansion{}  characteristic exponents  : 2,5
@expansion{}  generators of semigroup   : 2,5
@expansion{}  Puiseux pairs             : (5,2)
@expansion{}  degree of the conductor   : 4
@expansion{}  delta invariant           : 2
@expansion{}  sequence of multiplicities: 2,2,1,1
@expansion{} 
@expansion{}  -------------- contact numbers : -------------- 
@expansion{} 
@expansion{} branch |    2    
@expansion{} -------+-----
@expansion{}     1  |    2
@expansion{} 
@expansion{}  -------------- intersection multiplicities : -------------- 
@expansion{} 
@expansion{} branch |    2    
@expansion{} -------+-----
@expansion{}     1  |   12
@expansion{} 
@expansion{}  -------------- delta invariant of the curve :  22
  param(hn[2]);      // parametrization of 2nd branch
@expansion{} _[1]=x2
@expansion{} _[2]=x5
@c end example Puiseux_pairs examples.doc:1934
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Primary decomposition, Normalization, Puiseux pairs, Examples
@section Primary decomposition
@cindex Primary decomposition

There are two algorithms implemented in @sc{Singular} which provide
primary decomposition: @code{primdecGTZ}, based on
Gianni/Trager/Zacharias (written by Gerhard Pfister) and
@code{primdecSY}, based on Shimoyama/Yokoyama (written by Wolfram Decker
and Hans Schoenemann).

The result of @code{primdecGTZ} and @code{primdecSY} is returned as
a list of pairs of ideals,
where the second ideal form the prime ideal and the first
ideal form the corresponding primary ideal.

@smallexample
@c computed example Primary_decomposition examples.doc:1988 
  LIB "primdec.lib";
  ring r = 0,(a,b,c,d,e,f),dp;
  ideal i= f3, ef2, e2f, bcf-adf, de+cf, be+af, e3;
  primdecGTZ(i);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=f
@expansion{}       _[2]=e
@expansion{}    [2]:
@expansion{}       _[1]=f
@expansion{}       _[2]=e
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=f3
@expansion{}       _[2]=ef2
@expansion{}       _[3]=e2f
@expansion{}       _[4]=e3
@expansion{}       _[5]=de+cf
@expansion{}       _[6]=be+af
@expansion{}       _[7]=-bc+ad
@expansion{}    [2]:
@expansion{}       _[1]=f
@expansion{}       _[2]=e
@expansion{}       _[3]=-bc+ad
  // We consider now the ideal J of the base space of the
  // miniversal deformation of the cone over the rational
  // normal curve computed in section *8* and compute
  // its primary decomposition.
  ring R = 0,(A,B,C,D),dp;
  ideal J = CD, BD+D2, AD;
  primdecGTZ(J);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=D
@expansion{}    [2]:
@expansion{}       _[1]=D
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=C
@expansion{}       _[2]=B+D
@expansion{}       _[3]=A
@expansion{}    [2]:
@expansion{}       _[1]=C
@expansion{}       _[2]=B+D
@expansion{}       _[3]=A
  // We see that there are two components which are both
  // prime, even linear subspaces, one 3-dimensional,
  // the other 1-dimensional.
  // (This is Pinkhams example and was the first known
  // surface singularity with two components of
  // different dimensions)
  //
  // Let us now produce an embedded component in the last
  // example, compute the minimal associated primes and
  // the radical. We use the Characteristic set methods
  // from prim_dec.lib.
  J = intersect(J,maxideal(3));
  // The following shows that the maximal ideal defines an embedded
  // (prime) component.
  primdecSY(J);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=D
@expansion{}    [2]:
@expansion{}       _[1]=D
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=C
@expansion{}       _[2]=B+D
@expansion{}       _[3]=A
@expansion{}    [2]:
@expansion{}       _[1]=C
@expansion{}       _[2]=B+D
@expansion{}       _[3]=A
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=D2
@expansion{}       _[2]=C2
@expansion{}       _[3]=B2
@expansion{}       _[4]=AB
@expansion{}       _[5]=A2
@expansion{}       _[6]=BCD
@expansion{}       _[7]=ACD
@expansion{}    [2]:
@expansion{}       _[1]=D
@expansion{}       _[2]=C
@expansion{}       _[3]=B
@expansion{}       _[4]=A
  minAssChar(J);
@expansion{} [1]:
@expansion{}    _[1]=C
@expansion{}    _[2]=B+D
@expansion{}    _[3]=A
@expansion{} [2]:
@expansion{}    _[1]=D
  radical(J);
@expansion{} _[1]=CD
@expansion{} _[2]=BD+D2
@expansion{} _[3]=AD
@c end example Primary_decomposition examples.doc:1988
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Normalization, Branches of an Isolated Space Curve Singularity, Primary decomposition, Examples
@section Normalization
@cindex Normalization
The normalization will be computed for a reduced ring 
@ifinfo
@math{R/I}
@end ifinfo
@tex
$R/I$
@end tex
. The
result is a list of rings; ideals are always called @code{norid} in the
rings of this list. The normalization of 
@ifinfo
@math{R/I}
@end ifinfo
@tex
$R/I$
@end tex
 is the product of
the factor rings of the rings in the list divided out by the ideals
@code{norid}.

@smallexample
@c computed example Normalization examples.doc:2032 
  LIB "normal.lib";
  // ----- first example: rational quadruple point -----
  ring R=32003,(x,y,z),wp(3,5,15);
  ideal I=z*(y3-x5)+x10;
  list pr=normal(I);
@expansion{} 
@expansion{} // 'normal' created a list of 1 ring(s).
@expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
  def S=pr[1];
  setring S;
  norid;
@expansion{} norid[1]=T(2)*T(3)-T(1)*T(4)
@expansion{} norid[2]=T(1)^7-T(1)^2*T(3)+T(2)*T(5)
@expansion{} norid[3]=T(1)^2*T(5)-T(2)*T(4)
@expansion{} norid[4]=T(1)^5*T(4)-T(3)*T(4)+T(5)^2
@expansion{} norid[5]=T(1)^6*T(3)-T(1)*T(3)^2+T(4)*T(5)
@expansion{} norid[6]=T(1)*T(3)*T(5)-T(4)^2
  // ----- second example: union of straight lines -----
  ring R1=0,(x,y,z),dp;
  ideal I=(x-y)*(x-z)*(y-z);
  list qr=normal(I);
@expansion{} 
@expansion{} // 'normal' created a list of 3 ring(s).
@expansion{} // nor[3+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
  def S1=qr[1]; def S2=qr[2];
  setring S1; norid;
@expansion{} norid[1]=0
  setring S2; norid;
@expansion{} norid[1]=0
@c end example Normalization examples.doc:2032
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Branches of an Isolated Space Curve Singularity, Kernel of module homomorphisms, Normalization,Examples
@section Branches of an Isolated Space Curve Singularity
@cindex Branches of an Isolated Space Curve Singularity

In this example, the number of branches of a given quasihomogeneous isolated
space curve singularity will be computed as an example of the pitfalls
appearing in the use of primary decomposition. When dealing with singularities,
two situations are possible in which the primary decomposition algorithm
might not lead to a complete decomposition: first of all, one of the computed
components could be globally irreducible, but analytically reducible
(this is impossible for quasihomogeneous singularities) and,
as a second possibility, a component might be irreducible over the rational
numbers, but reducible over the complex numbers.
@smallexample
@c computed example Branches_of_an_Isolated_Space_Curve_Singularity examples.doc:2067 
  ring r=0,(x,y,z),ds;
  ideal i=x^4-y*z^2,x*y-z^3,y^2-x^3*z;  // the space curve singularity
  qhweight(i);
@expansion{} 1,2,1
  // The given space curve singularity is quasihomogeneous. Hence we can pass
  // to the polynomial ring.
  ring rr=0,(x,y,z),dp;
  ideal i=imap(r,i);
  resolution ires=mres(i,0);
  ires;
@expansion{}   1       3       2       
@expansion{} rr <--  rr <--  rr
@expansion{} 
@expansion{} 0       1       2       
@expansion{} 
  // From the structure of the resolution, we see that the Cohen-Macaulay
  // type of the given singularity is 2
  //
  // Let us now look for the branches using the primdec library.
  LIB "primdec.lib";
  primdecSY(i);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=z3-xy
@expansion{}       _[2]=x3+x2z+xz2+xy+yz
@expansion{}       _[3]=x2z2+x2y+xyz+yz2+y2
@expansion{}    [2]:
@expansion{}       _[1]=z3-xy
@expansion{}       _[2]=x3+x2z+xz2+xy+yz
@expansion{}       _[3]=x2z2+x2y+xyz+yz2+y2
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=x-z
@expansion{}       _[2]=z2-y
@expansion{}    [2]:
@expansion{}       _[1]=x-z
@expansion{}       _[2]=z2-y
  def li=_[2];
  ideal i2=li[2];       // call the second ideal i2
  // The curve seems to have 2 branches by what we computed using the
  // algorithm of Shimoyama-Yokoyama.
  // Now the same computation by the Gianni-Trager-Zacharias algorithm:
  primdecGTZ(i);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=z8+yz6+y2z4+y3z2+y4
@expansion{}       _[2]=xz5+z6+yz4+y2z2+y3
@expansion{}       _[3]=-z3+xy
@expansion{}       _[4]=x2z2+xz3+xyz+yz2+y2
@expansion{}       _[5]=x3+x2z+xz2+xy+yz
@expansion{}    [2]:
@expansion{}       _[1]=z8+yz6+y2z4+y3z2+y4
@expansion{}       _[2]=xz5+z6+yz4+y2z2+y3
@expansion{}       _[3]=-z3+xy
@expansion{}       _[4]=x2z2+xz3+xyz+yz2+y2
@expansion{}       _[5]=x3+x2z+xz2+xy+yz
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=-z2+y
@expansion{}       _[2]=x-z
@expansion{}    [2]:
@expansion{}       _[1]=-z2+y
@expansion{}       _[2]=x-z
  // Having computed the primary decomposition in 2 different ways and
  // having obtained the same number of branches, we might expect that the
  // number of branches is really 2, but we can check this by formulae
  // for the invariants of space curve singularities:
  //
  // mu = tau - t + 1 (for quasihomogeneous curve singularities)
  // where mu denotes the Milnor number, tau the Tjurina number and
  // t the Cohen-Macaulay type
  //
  // mu = 2 delta - r + 1
  // where delta denotes the delta-Invariant and r the number of branches
  //
  // tau can be computed by using the corresponding procedure T1 from
  // sing.lib.
  setring r;
  LIB "sing.lib";
  T_1(i);
@expansion{} // dim T_1 = 13
@expansion{} _[1]=gen(6)+2z*gen(5)
@expansion{} _[2]=gen(4)+3x2*gen(2)
@expansion{} _[3]=gen(3)+gen(1)
@expansion{} _[4]=x*gen(5)-y*gen(2)-z*gen(1)
@expansion{} _[5]=x*gen(1)-z2*gen(2)
@expansion{} _[6]=y*gen(5)+3x2z*gen(2)
@expansion{} _[7]=y*gen(2)-z*gen(1)
@expansion{} _[8]=2y*gen(1)-z2*gen(5)
@expansion{} _[9]=z2*gen(5)
@expansion{} _[10]=z2*gen(1)
@expansion{} _[11]=x3*gen(2)
@expansion{} _[12]=x2z2*gen(2)
@expansion{} _[13]=xz3*gen(2)
@expansion{} _[14]=z4*gen(2)
  setring rr;
  // Hence tau is 13 and therefore mu is 12. But then it is impossible that
  // the singularity has two branches, since mu is even and delta is an
  // integer!
  // So obviously, we did not decompose completely. Because the first branch
  // is smooth, only the second ideal can be the one which can be decomposed
  // further.
  // Let us now consider the normalization of this second ideal i2.
  LIB "normal.lib";
  normal(i2);
@expansion{} 
@expansion{} // 'normal' created a list of 1 ring(s).
@expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 1
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    T(1) 
@expansion{} //        block   2 : ordering C
  def rno=_[1];
  setring rno;
  norid;
@expansion{} norid[1]=0
  // The ideal is generated by a polynomial in one variable of degree 4 which
  // factors completely into 4 polynomials of type T(2)+a.
  // From this, we know that the ring of the normalization is the direct sum of 
  // 4 polynomial rings in one variable.
  // Hence our original curve has these 4 branches plus a smooth one
  // which we already determined by primary decomposition.
  // Our final result is therefore: 5 branches.
@c end example Branches_of_an_Isolated_Space_Curve_Singularity examples.doc:2067
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Kernel of module homomorphisms, Algebraic dependence, Branches of an Isolated Space Curve Singularity, Examples
@end ifset
@ifclear singularmanual
@node Kernel of module homomorphisms, Algebraic dependence, Factorization, Examples
@end ifclear
@section Kernel of module homomorphisms
@cindex Kernel of module homomorphisms
Let 
@ifinfo
@math{A}
@end ifinfo
@tex
$A$
@end tex
, 
@ifinfo
@math{B}
@end ifinfo
@tex
$B$
@end tex
 be two matrices of size
@tex
$m\times r$ and $m\times s$
@end tex
@ifinfo
m x r and m x s
@end ifinfo
over the ring 
@ifinfo
@math{R}
@end ifinfo
@tex
$R$
@end tex
 and consider the corresponding maps
@tex
$$
R^r \buildrel{A}\over{\longrightarrow}
R^m \buildrel{B}\over{\longleftarrow} R^s\;.
$$
@end tex
@ifinfo

@smallexample
   r   A     m
  R  -----> R
            ^
            |
            |
             s
            R  .
@end smallexample

@end ifinfo
We want to compute the kernel of the map
@tex
$R^r \buildrel{A}\over{\longrightarrow}
R^m\longrightarrow
R^m/\hbox{Im}(B) \;.$
@end tex
@ifinfo

@smallexample
   r   A     m         m
  R  -----> R  -----> R /Im(B) .
@end smallexample

@end ifinfo
This can be done using the @code{modulo} command:
@tex
$$
\hbox{\tt modulo}(A,B)=\hbox{ker}(R^r
\buildrel{A}\over{\longrightarrow}R^m/\hbox{Im}(B)) \; .
$$
@end tex
@ifinfo

@smallexample
                   r   A     m
  modulo(A,B)=ker(R  -----> R /Im(B))  .
@end smallexample

@end ifinfo

@smallexample
@c computed example Kernel_of_module_homomorphisms examples.doc:2196 
  ring r=0,(x,y,z),(c,dp);
  matrix A[2][2]=x,y,z,1;
  matrix B[2][2]=x2,y2,z2,xz;
  print(modulo(A,B));
@expansion{} yz2-x2, xyz-y2,  x2z-xy, x3-y2z,
@expansion{} x2z-xz2,-x2z+y2z,xyz-yz2,0      
@c end example Kernel_of_module_homomorphisms examples.doc:2196
@end smallexample

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Algebraic dependence, Classification, Kernel of module homomorphisms, Examples
@end ifset
@ifclear singularmanual
@node Algebraic dependence,  , Kernel of module homomorphisms, Examples
@end ifclear
@section Algebraic dependence
@cindex Algebraic dependence
Let
@tex
$g$, $f_1$, \dots, $f_r\in K[x_1,\ldots,x_n]$.
@end tex
@ifinfo
g, f_1, @dots{}, f_r in K[x1,@dots{},xn].
@end ifinfo
We want to check whether
@enumerate
@item
@tex
$f_1$, \dots, $f_r$
@end tex
@ifinfo
f_1, @dots{}, f_r
@end ifinfo
are algebraically dependent.

Let
@tex
$I=\langle Y_1-f_1,\ldots,Y_r-f_r \rangle \subseteq
K[x_1,\ldots,x_n,Y_1,\ldots,Y_r]$.
@end tex
@ifinfo

@smallexample
I=<Y_1-f_1,@dots{},Y_r-f_r> subset K[x1,@dots{},xn,Y_1,@dots{},Y_r].
@end smallexample

@end ifinfo
Then
@tex
$I \cap K[Y_1,\ldots,Y_r]$
@end tex
@ifinfo
I intersected with K[Y_1,@dots{},Y_r]
@end ifinfo
are the algebraic relations between
@tex
$f_1$, \dots, $f_r$.
@end tex
@ifinfo
f_1, @dots{}, f_r.
@end ifinfo

@item
@tex
$g \in K [f_1,\ldots,f_r]$.
@end tex
@ifinfo
g in K[f_1,@dots{},f_r].
@end ifinfo

@tex
$g \in K[f_1,\ldots,f_r]$
@end tex
@ifinfo
g in K[f_1,@dots{},f_r]
@end ifinfo
if and only if the normal form of 
@ifinfo
@math{g}
@end ifinfo
@tex
$g$
@end tex
 with respect to 
@ifinfo
@math{I}
@end ifinfo
@tex
$I$
@end tex
 and a
block ordering with respect to
@tex
$X=(x_1,\ldots,x_n)$ and $Y=(Y_1,\ldots,Y_r)$ with $X>Y$
@end tex
@ifinfo
X=(x1,@dots{},xn) and Y=(Y_1,@dots{},Y_r) with X>Y
@end ifinfo
is in 
@ifinfo
@math{K[Y]}
@end ifinfo
@tex
$K[Y]$
@end tex
.
@end enumerate

Both questions can be answered using the following procedure. If the
second argument is zero, it checks for algebraic dependence and returns
the ideal of relations between the generators of the given ideal.
Otherwise it checks for subring membership and returns the normal form
of the second argument with respect to the ideal I.

@smallexample
@c computed example Algebraic_dependence examples.doc:2290 
  proc algebraicDep(ideal J, poly g)
  @{
    def R=basering;         // give a name to the basering
    int n=size(J);
    int k=nvars(R);
    int i;
    intvec v;

    // construction of the new ring:

    // construct a weight vector
    v[n+k]=0;         // gives a zero vector of length n+k
    for(i=1;i<=k;i++)
    @{
      v[i]=1;
    @}
    string orde="(a("+string(v)+"),dp);";
    string ri="ring Rhelp=("+charstr(R)+"),
                          ("+varstr(R)+",Y(1.."+string(n)+")),"+orde;
                            // ring definition as a string
    execute(ri);            // execution of the string

    // construction of the new ideal I=(J[1]-Y(1),...,J[n]-Y(n))
    ideal I=imap(R,J);
    for(i=1;i<=n;i++)
    @{
      I[i]=I[i]-var(k+i);
    @}
    poly g=imap(R,g);
    if(g==0)
    @{
      // construction of the ideal of relations by elimination
      poly el=var(1);
      for(i=2;i<=k;i++)
      @{
        el=el*var(i);
      @}
      ideal KK=eliminate(I,el);
      keepring(Rhelp);
      return(KK);
    @}
    // reduction of g with respect to I
    ideal KK=reduce(g,std(I));
    keepring(Rhelp);
    return(KK);
  @}

  // applications of the procedure
  ring r=0,(x,y,z),dp;
  ideal i=xz,yz;
  algebraicDep(i,0);
@expansion{} _[1]=0
  // Note: after call of algebraicDep(), the basering is Rhelp.
  setring r; kill Rhelp;
  ideal j=xy+z2,z2+y2,x2y2-2xy3+y4;
  algebraicDep(j,0);
@expansion{} _[1]=Y(1)^2-2*Y(1)*Y(2)+Y(2)^2-Y(3)
  setring r; kill Rhelp;
  poly g=y2z2-xz;
  algebraicDep(i,g);
@expansion{} _[1]=Y(2)^2-Y(1)
  // this shows that g is contained in i.
  setring r; kill Rhelp;
  algebraicDep(j,g);
@expansion{} _[1]=-z^4+z^2*Y(2)-x*z
  // this shows that g is contained in j.
@c end example Algebraic_dependence examples.doc:2290
@end smallexample

@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Classification, Fast lexicographical GB, Algebraic dependence, Examples
@section Classification
@cindex Classification

Classification of isolated hypersurface singularities with respect to
right equivalence is provided by the command @code{classify} of the
library @code{classify.lib}. The classification is done using the
algorithm of Arnold. Before entering this algorithm, a first guess based
on the Hilbert polynomial of the Milnor algebra is made.

@smallexample
@c computed example Classification examples.doc:2369 
  LIB "classify.lib";
  ring r=0,(x,y,z),ds;
  poly p=singularity("E[6k+2]",2)[1];
  p=p+z^2;
  p;
@expansion{} z2+x3+xy6+y8
  // We received an E_14 singularity in normal form
  // from the database of normal forms. Since only the residual
  // part is saved in the database, we added z^2 to get an E_14
  // of embedding dimension 3.
  //
  // Now we apply a coordinate change in order to deal with a
  // singularity which is not in normal form:
  map phi=r,x+y,y+z,x;
  poly q=phi(p);
  // Yes, q really looks ugly, now:
  q;
@expansion{} x2+x3+3x2y+3xy2+y3+xy6+y7+6xy5z+6y6z+15xy4z2+15y5z2+20xy3z3+20y4z3+15xy2z\
   4+15y3z4+6xyz5+6y2z5+xz6+yz6+y8+8y7z+28y6z2+56y5z3+70y4z4+56y3z5+28y2z6+8\
   yz7+z8
  // Classification
  classify(q);
@expansion{} About the singularity :
@expansion{}           Milnor number(f)   = 14
@expansion{}           Corank(f)          = 2
@expansion{}           Determinacy       <= 12
@expansion{} Guessing type via Milnorcode:   E[6k+2]=E[14]
@expansion{} 
@expansion{} Computing normal form ...
@expansion{} I have to apply the splitting lemma. This will take some time....:-)
@expansion{}    Arnold step number 9
@expansion{} The singularity
@expansion{}    x3-9/4x4+27/4x5-189/8x6+737/8x7+6x6y+15x5y2+20x4y3+15x3y4+6x2y5+xy6-24\
   089/64x8-x7y+11/2x6y2+26x5y3+95/2x4y4+47x3y5+53/2x2y6+8xy7+y8+104535/64x9\
   +27x8y+135/2x7y2+90x6y3+135/2x5y4+27x4y5+9/2x3y6-940383/128x10-405/4x9y-2\
   025/8x8y2-675/2x7y3-2025/8x6y4-405/4x5y5-135/8x4y6+4359015/128x11+1701/4x\
   10y+8505/8x9y2+2835/2x8y3+8505/8x7y4+1701/4x6y5+567/8x5y6-82812341/512x12\
   -15333/8x11y-76809/16x10y2-25735/4x9y3-78525/16x8y4-16893/8x7y5-8799/16x6\
   y6-198x5y7-495/4x4y8-55x3y9-33/2x2y10-3xy11-1/4y12
@expansion{} is R-equivalent to E[14].
@expansion{}    Milnor number = 14
@expansion{}    modality      = 1
@expansion{} 2z2+x3+xy6+y8
  // The library also provides routines to determine the corank of q
  // and its residual part without going through the whole
  // classification algorithm.
  corank(q);
@expansion{} 2
  morsesplit(q);
@expansion{} y3-9/4y4+27/4y5-189/8y6+737/8y7+6y6z+15y5z2+20y4z3+15y3z4+6y2z5+yz6-24089\
   /64y8-y7z+11/2y6z2+26y5z3+95/2y4z4+47y3z5+53/2y2z6+8yz7+z8+104535/64y9+27\
   y8z+135/2y7z2+90y6z3+135/2y5z4+27y4z5+9/2y3z6-940383/128y10-405/4y9z-2025\
   /8y8z2-675/2y7z3-2025/8y6z4-405/4y5z5-135/8y4z6+4359015/128y11+1701/4y10z\
   +8505/8y9z2+2835/2y8z3+8505/8y7z4+1701/4y6z5+567/8y5z6-82812341/512y12-15\
   333/8y11z-76809/16y10z2-25735/4y9z3-78525/16y8z4-16893/8y7z5-8799/16y6z6-\
   198y5z7-495/4y4z8-55y3z9-33/2y2z10-3yz11-1/4z12
@c end example Classification examples.doc:2369
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node Fast lexicographical GB, Parallelization with MPtcp links, Classification, Examples
@section Fast lexicographical GB
@cindex Fast lexicographical GB

Compute Groebner basis in lexicographical ordering
by using the FGLM algorithm (@code{stdfglm})
and Hilbert driven Groebner (@code{stdhilb}).

The command @code{stdfglm} applies only for zero-dimensional ideals and
returns a reduced Groebner basis.

For the ideal below, @code{stdfglm} is more than 100 times
and @code{stdhilb} about 10 times faster than @code{std}.

@smallexample
@c computed example Fast_lexicographical_GB examples.doc:2413 
  ring r =32003,(a,b,c,d,e),lp;
  ideal i=a+b+c+d, ab+bc+cd+ae+de, abc+bcd+abe+ade+cde,
          abc+abce+abde+acde+bcde, abcde-1;
  int t=timer;
  ideal j1=stdfglm(i);
  timer-t;
@expansion{} 0
  size(j1);   // size (no. of polys) in computed GB
@expansion{} 5
  t=timer;
  ideal j2=stdhilb(i);
  timer-t;
@expansion{} 0
  size(j2);   // size (no. of polys) in computed GB
@expansion{} 158
  // usual Groebner basis computation for lex ordering
  t=timer;
  ideal j0 =std(i);
  timer-t;
@expansion{} 1
@c end example Fast_lexicographical_GB examples.doc:2413
@end smallexample
@end ifset
@c ----------------------------------------------------------------------------
@ifset singularmanual
@node  Parallelization with MPtcp links,  , Fast lexicographical GB, Examples
@section Parallelization with MPtcp links
@cindex Parallelization
@cindex MPtcp
@cindex link
In this example, we demonstrate how MPtcp links can be used to
parallelize computations.

To compute a standard basis for a zero-dimensional ideal in the
lexicographical ordering, one of the two powerful routines
@code{stdhilb}
@ifset singularmanual
(see @ref{stdhilb})
@end ifset
and @code{stdfglm}
@ifset singularmanual
(see @ref{stdfglm})
@end ifset
should be used. However, a priory one can not predict
which one of the two commands is faster. This very much depends on the
(input) example. Therefore, we use MPtcp links to let both commands
work on the problem independently and in parallel, so that the one which
finishes first delivers the result.

The example we use is the so-called "omdi example". See @i{Tim
Wichmann; Der FGLM-Algorithmus: verallgemeinert und implementiert in
Singular; Diplomarbeit Fachbereich Mathematik, Universitaet
Kaiserslautern; 1997} for more details.

@smallexample
@c computed example Parallelization_with_MPtcp_links examples.doc:2464 
ring r=0,(a,b,c,u,v,w,x,y,z),lp;
ideal i=a+c+v+2x-1, ab+cu+2vw+2xy+2xz-2/3,  ab2+cu2+2vw2+2xy2+2xz2-2/5,
ab3+cu3+2vw3+2xy3+2xz3-2/7, ab4+cu4+2vw4+2xy4+2xz4-2/9, vw2+2xyz-1/9,
vw4+2xy2z2-1/25, vw3+xyz2+xy2z-1/15, vw4+xyz3+xy3z-1/21;

link l_hilb,l_fglm = "MPtcp:fork","MPtcp:fork";         // 1.

open(l_fglm); open(l_hilb);

write(l_hilb, quote(system("pid")));                    // 2.
write(l_fglm, quote(system("pid")));
int pid_hilb,pid_fglm = read(l_hilb),read(l_fglm);

write(l_hilb, quote(stdhilb(i)));                       // 3.
write(l_fglm, quote(stdfglm(eval(i))));

while ((! status(l_hilb, "read", "ready", 1)) &&        // 4.
       (! status(l_fglm, "read", "ready", 1))) @{@}

if (status(l_hilb, "read", "ready"))
@{
  "stdhilb won !!!!"; size(read(l_hilb));
  close(l_hilb); pid_fglm = system("sh","kill "+string(pid_fglm));
@}
else                                                    // 5.
@{
  "stdfglm won !!!!"; size(read(l_fglm));
  close(l_fglm); pid_hilb = system("sh","kill "+string(pid_hilb));
@}
@expansion{} stdfglm won !!!!
@expansion{} 9
@c end example Parallelization_with_MPtcp_links examples.doc:2464
@end smallexample
Some explanatory remarks are in order:
@enumerate
@item
Instead of using links of the type @code{MPtcp:fork}, we alternatively
could use @code{MPtcp:launch} links such that the two "competing"
@sc{Singular} processes run on different machines. This has the
advantage of "true" parallel computing since no resource sharing is
involved (as it usually is with forked processes).

@item
Unfortunately, MPtcp links do not offer means to (asynchronously)
interrupt or kill an attached (i.e., launched or forked)
process. Therefore, we explicitly need to get the process id numbers of
the competing @sc{Singular} processes, so that we can "kill" the
looser later.

@item
Notice how quoting is used in order to prevent local evaluation
(i.e., local computation of results). Since we "forked" the two
competing processes, the identifier @code{i} is defined and has
identical values in both child processes. Therefore, the innermost
@code{eval} can be omitted (as is done for the @code{l_hilb} link),
and only the identifier @code{i} needs to be communicated to the
children. However, when @code{MPtcp:launch} links are used, the inner
evaluation must be applied so that actual values, and not the
identifiers are communicated (as is done for the @code{l_fglm} link).

@item
We go into a "sleepy" loop and wait until one of the two children
finished the computation. That is, the current process checks approximately
once per second the status of one of the connecting links, and sleeps
(i.e., suspends its execution) in the intermediate time.

@item
The child which has won delivers the result and is terminated with the usual
@code{close} command. The other child which is still computing needs to
be terminated by an explicit (i.e., system) kill command, since it can
not be terminated through the link while it is still computing.
@end enumerate
@end ifset

@c --------------------------------------------------------------------
@ifclear singularmanual
@section Further smallexamples

The example section of the @sc{Singular} manual contains further examples,
e.g.:
@itemize @bullet
@item Long coefficients
@*how they arise in innocent smallexamples
@item T1 and T2
@*compute first order deformations and obstructions
@item Finite fields
@*compute in fields with
@tex
$q=p^n$
@end tex
@ifinfo
q=p^n
@end ifinfo
elements
@item Ext
@*compute Ext groups, derived from the Hom functor
@item Polar curves
@*compute local and global polar curves
@item Depth
@*various ways to compute the depth of a module
@item Cyclic roots
@*create and compute with this standard benchmark smallexample
@item Invariants of finite group
@*compute invariant rings for finite group
@item Puiseux pairs
@*compute Puiseux development and invariants with the
Hamburger-Noether method
@item Primary decomposition
@*compute primar decomposition of an ideal
@item Normalization
@*compute the normalization of a ring
@item Classification
@*determine type and normal form of a hypersurface singularity
after Arnold
@item Fast lexicographical GB
@*FGLM and Hilbert-driven Groebner
@item Parallelization with MPtcp links
@*use MP for distributed and parallel computation
@end itemize

In this list the names of the items are the names of the
examples in the online help system. So by the command
@code{help T1 and T2} the example about the computation of
first order deformations and obstructions is displayed.
@end ifclear
