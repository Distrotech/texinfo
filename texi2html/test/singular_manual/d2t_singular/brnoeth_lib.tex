@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/brnoeth_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/brnoeth_lib.doc INSTEAD
@c library version: (1.11.2.5,2002/10/18)
@c library file: ../Singular/LIB/brnoeth.lib
@cindex brnoeth.lib
@cindex brnoeth_lib
@table @asis
@item @strong{Library:}
brnoeth.lib
@item @strong{Purpose:}
  Brill-Noether Algorithm, Weierstrass-SG and AG-codes
@item @strong{Authors:}
Jose Ignacio Farran Martin, ignfar@@eis.uva.es
@*Christoph Lossen, lossen@@mathematik.uni-kl.de

@item @strong{Overview:}
Implementation of the Brill-Noether algorithm for solving the
Riemann-Roch problem and applications in Algebraic Geometry codes.
The computation of Weierstrass semigroups is also implemented.@*
The procedures are intended only for plane (singular) curves defined over
a prime field of positive characteristic.@*
For more information about the library see the end of the file brnoeth.lib.

@end table

@strong{Main procedures:}
@menu
* Adj_div:: computes the conductor of a curve
* NSplaces:: computes non-singular places with given degrees
* BrillNoether:: computes a vector space basis of the linear system L(D)
* Weierstrass:: computes the Weierstrass semigroup of C at P up to m
* extcurve:: extends the curve C to an extension of degree d
* AGcode_L:: computes the evaluation AG code with divisors G and D
* AGcode_Omega:: computes the residual AG code with divisors G and D
* prepSV:: preprocessing for the basic decoding algorithm
* decodeSV:: decoding of a word with the basic decoding algorithm
@end menu
@strong{Auxiliary procedures:}
@menu
* closed_points:: computes the zero-set of a zero-dim. ideal in 2 vars
* dual_code:: computes the dual code
* sys_code:: computes an equivalent systematic code
* permute_L:: applies a permutation to a list
@end menu
@cindex Weierstrass semigroup
@cindex Algebraic Geometry codes
@cindex Brill-Noether algorithm
@c inserted refs from d2t_singular/brnoeth_lib.doc:47
@ifinfo
@menu
See also:
* hnoether_lib::
* triang_lib::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{hnoether_lib};
@ref{triang_lib}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:47

@c ---end content LibInfo---

@c ------------------- Adj_div -------------
@node Adj_div, NSplaces,, brnoeth_lib
@subsubsection Adj_div
@cindex Adj_div
@c ---content Adj_div---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
Adj_div( f [,l] ); f a poly, [l a list]

@item @strong{Return:}
list L with the computed data:
  @format
  L[1] a list of rings: L[1][1]=aff_r (affine), L[1][2]=Proj_R (projective),
  L[2] an intvec with 2 entries (degree, genus),
  L[3] a list of intvec (closed places),
  L[4] an intvec (conductor),
  L[5] a list of lists:
     L[5][d][1] a (local) ring over an extension of degree d,
     L[5][d][2] an intvec (degrees of base points of places of degree d)
  @end format

@item @strong{Note:}
@code{Adj_div(f);} computes and stores the fundamental data of the
plane curve defined by f as needed for AG codes.
@*In the affine ring you can find the following data:
   @format
   poly CHI:  affine equation of the curve,
   ideal Aff_SLocus:  affine singular locus (std),
   list Inf_Points:  points at infinity
            Inf_Points[1]:  singular points
            Inf_Points[2]:  non-singular points,
   list Aff_SPoints:  affine singular points (if not empty).
   @end format
In the projective ring you can find the projective equation
CHI of the curve (poly).
@*In the local rings L[5][d][1] you find:
   @format
   list POINTS:  base points of the places of degree d,
   list LOC_EQS:  local equations of the curve at the base points,
   list BRANCHES:  Hamburger-Noether developments of the places,
   list PARAMETRIZATIONS:  local parametrizations of the places,
   @end format
Each entry of the list L[3] corresponds to one closed place (i.e.,
a place and all its conjugates) which is represented by an intvec
of size two, the first entry is the degree of the place (in
particular, it tells the local ring where to find the data
describing one representative of the closed place), and the
second one is the position of those data in the lists POINTS, etc.,
inside this local ring.@*
In the intvec L[4] (conductor) the i-th entry corresponds to the
i-th entry in the list of places L[3].

With no optional arguments, the conductor is computed by
local invariants of the singularities; otherwise it is computed
by the Dedekind formula. @*
An affine point is represented by a list P where P[1] is std
of a prime ideal and P[2] is an intvec containing the position
of the places above P in the list of closed places L[3]. @*
If the point is at infinity, P[1] is a homogeneous irreducible
polynomial in two variables.

If @code{printlevel>=0} additional comments are displayed (default:
@code{printlevel=0}).

@cindex Hamburger-Noether expansions
@cindex adjunction divisor
@end table
@strong{Example:}
@smallexample
@c computed example Adj_div d2t_singular/brnoeth_lib.doc:124 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(y9+y8+xy6+x2y3+y2+x3);
@expansion{} The genus of the curve is 3
def aff_R=C[1][1];      // the affine ring
setring aff_R;
listvar(aff_R);         // data in the affine ring
@expansion{} // aff_R                [0]  *ring
@expansion{} // Inf_Points           [0]  list, size: 2
@expansion{} // Aff_SPoints          [0]  list, size: 3
@expansion{} // Aff_SLocus           [0]  ideal (SB), 2 generator(s)
@expansion{} // CHI                  [0]  poly
CHI;                    // affine equation of the curve
@expansion{} x3+x2y3+xy6+y9+y8+y2
Aff_SLocus;             // ideal of the affine singular locus
@expansion{} Aff_SLocus[1]=y8+y2
@expansion{} Aff_SLocus[2]=x2+y6
Aff_SPoints[1];         // 1st affine singular point: (1:1:1), no.1
@expansion{} [1]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x+1
@expansion{} [2]:
@expansion{}    1
Inf_Points[1];          // singular point(s) at infinity: (1:0:0), no.4
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       y
@expansion{}    [2]:
@expansion{}       4
Inf_Points[2];          // list of non-singular points at infinity
@expansion{} empty list
//
def proj_R=C[1][2];     // the projective ring
setring proj_R;
CHI;                    // projective equation of the curve
@expansion{} x3z6+x2y3z4+xy6z2+y9+y8z+y2z7
C[2][1];                // degree of the curve
@expansion{} 9
C[2][2];                // genus of the curve
@expansion{} 3
C[3];                   // list of computed places
@expansion{} [1]:
@expansion{}    2,1
@expansion{} [2]:
@expansion{}    1,1
@expansion{} [3]:
@expansion{}    1,2
@expansion{} [4]:
@expansion{}    1,3
C[4];                   // adjunction divisor (all points are singular!)
@expansion{} 2,2,2,42
//
// we look at the place(s) of degree 2 by changing to the ring
C[5][2][1];
@expansion{} //   characteristic : 2
@expansion{} //   1 parameter    : a 
@expansion{} //   minpoly        : ...
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering ls
@expansion{} //                  : names    x y t 
@expansion{} //        block   2 : ordering C
def S(2)=C[5][2][1];
setring S(2);
POINTS;                // base point(s) of place(s) of degree 2: (1:a:1)
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       (a)
@expansion{}    [3]:
@expansion{}       1
LOC_EQS;               // local equation(s)
@expansion{} [1]:
@expansion{}    y2+y3+(a+1)*y4+y6+(a+1)*y8+y9+(a)*xy2+(a+1)*xy4+xy6+(a+1)*x2y+(a)*x2y2\
   +x2y3+x3
PARAMETRIZATIONS;      // parametrization(s) and exactness
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=t2+(a+1)*t3
@expansion{}       _[2]=t3+(a+1)*t4
@expansion{}    [2]:
@expansion{}       3,4
BRANCHES;              // Hamburger-Noether development
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1,1]=0
@expansion{}       _[1,2]=x
@expansion{}       _[1,3]=0
@expansion{}       _[2,1]=0
@expansion{}       _[2,2]=1
@expansion{}       _[2,3]=(a+1)
@expansion{}    [2]:
@expansion{}       1,-4
@expansion{}    [3]:
@expansion{}       0
@expansion{}    [4]:
@expansion{}       y+(a+1)*xy+(a)*x2y+(a)*x2y2+(a+1)*x3+x3y+x3y3+(a)*x4+(a+1)*x4y2+(a+\
   1)*x4y3+x5+x5y2+(a)*x6+(a+1)*x6y2+x6y4+x6y5+x7y+(a+1)*x8+(a+1)*x8y+x8y4+(\
   a+1)*x8y6+x9+x9y7+(a+1)*x10+x11y6+(a+1)*x12y4+x13y5+x14+x14y+x15y4+x16+(a\
   +1)*x16y2+x17y3+x19y2+(a+1)*x20+x21y+x23
printlevel=plevel;
@c end example Adj_div d2t_singular/brnoeth_lib.doc:124
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:158
@ifinfo
@menu
See also:
* NSplaces::
* closed_points::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{NSplaces};
@ref{closed_points}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:158

@c ---end content Adj_div---

@c ------------------- NSplaces -------------
@node NSplaces, BrillNoether, Adj_div, brnoeth_lib
@subsubsection NSplaces
@cindex NSplaces
@c ---content NSplaces---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
NSplaces( h, CURVE ), where h is an intvec and CURVE is a list

@item @strong{Return:}
list L with updated data of CURVE after computing all non-singular
affine closed places whose degrees are in the intvec h: @*
   @format
   in L[1][1]: (affine ring) lists Aff_Points(d) with affine non-singular
               (closed) points of degree d (if non-empty),
   in L[3]:    the newly computed closed places are added,
   in L[5]:    local rings created/updated to store (repres. of) new places.
   @end format
See @ref{Adj_div} for a description of the entries in L.

@item @strong{Note:}
The list_expression should be the output of the procedure Adj_div.@*
If @code{printlevel>=0} additional comments are displayed (default:
@code{printlevel=0}).

@end table
@strong{Example:}
@smallexample
@c computed example NSplaces d2t_singular/brnoeth_lib.doc:194 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(x3y+y3+x);
@expansion{} The genus of the curve is 3
// The list of computed places:
C[3];
@expansion{} [1]:
@expansion{}    1,1
@expansion{} [2]:
@expansion{}    1,2
// create places up to degree 4
list L=NSplaces(1..4,C);
// The list of computed places is now:
L[3];
@expansion{} [1]:
@expansion{}    1,1
@expansion{} [2]:
@expansion{}    1,2
@expansion{} [3]:
@expansion{}    1,3
@expansion{} [4]:
@expansion{}    2,1
@expansion{} [5]:
@expansion{}    3,1
@expansion{} [6]:
@expansion{}    3,2
@expansion{} [7]:
@expansion{}    3,3
@expansion{} [8]:
@expansion{}    3,4
@expansion{} [9]:
@expansion{}    3,5
@expansion{} [10]:
@expansion{}    3,6
@expansion{} [11]:
@expansion{}    3,7
@expansion{} [12]:
@expansion{}    4,1
@expansion{} [13]:
@expansion{}    4,2
@expansion{} [14]:
@expansion{}    4,3
// e.g., affine non-singular points of degree 4 :
def aff_r=L[1][1];
setring aff_r;
Aff_Points(4);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=y2+y+1
@expansion{}       _[2]=x2+xy+x+1
@expansion{}    [2]:
@expansion{}       12
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=y4+y3+y2+y+1
@expansion{}       _[2]=x+y2+y+1
@expansion{}    [2]:
@expansion{}       13
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=y4+y3+1
@expansion{}       _[2]=x+y3+y
@expansion{}    [2]:
@expansion{}       14
// e.g., base point of the 1st place of degree 4 :
def S(4)=L[5][4][1];
setring S(4);
POINTS[1];
@expansion{} [1]:
@expansion{}    (a3)
@expansion{} [2]:
@expansion{}    (a2+a)
@expansion{} [3]:
@expansion{}    1
printlevel=plevel;
@c end example NSplaces d2t_singular/brnoeth_lib.doc:194
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:217
@ifinfo
@menu
See also:
* Adj_div::
* closed_points::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{Adj_div};
@ref{closed_points}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:217

@c ---end content NSplaces---

@c ------------------- BrillNoether -------------
@node BrillNoether, Weierstrass, NSplaces, brnoeth_lib
@subsubsection BrillNoether
@cindex BrillNoether
@c ---content BrillNoether---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
BrillNoether(G,CURVE); G an intvec, CURVE a list

@item @strong{Return:}
list of ideals (each of them with two homogeneous generators,
which represent the numerator, resp. denominator, of a rational
function).@*
The corresponding rational functions form a vector basis of the
linear system L(G), G a rational divisor over a non-singular curve.

@item @strong{Note:}
The procedure must be called from the ring CURVE[1][2], where
CURVE is the output of the procedure @code{NSplaces}. @*
The intvec G represents a rational divisor supported on the closed
places of CURVE[3] (e.g. @code{G=2,0,-1;} means 2 times the closed
place 1 minus 1 times the closed place 3).

@end table
@strong{Example:}
@smallexample
@c computed example BrillNoether d2t_singular/brnoeth_lib.doc:251 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(x3y+y3+x);
@expansion{} The genus of the curve is 3
C=NSplaces(1..4,C);
// the first 3 Places in C[3] are of degree 1.
// we define the rational divisor G = 4*C[3][1]+4*C[3][3] (of degree 8):
intvec G=4,0,4;
def R=C[1][2];
setring R;
list LG=BrillNoether(G,C);
@expansion{} Vector basis successfully computed 
// here is the vector basis of L(G):
LG;
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=1
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x
@expansion{} [3]:
@expansion{}    _[1]=z
@expansion{}    _[2]=x
@expansion{} [4]:
@expansion{}    _[1]=y2
@expansion{}    _[2]=x2
@expansion{} [5]:
@expansion{}    _[1]=xz2+y3
@expansion{}    _[2]=x3
@expansion{} [6]:
@expansion{}    _[1]=xyz2+y4
@expansion{}    _[2]=x4
printlevel=plevel;
@c end example BrillNoether d2t_singular/brnoeth_lib.doc:251
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:269
@ifinfo
@menu
See also:
* Adj_div::
* NSplaces::
* Weierstrass::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{Adj_div};
@ref{NSplaces};
@ref{Weierstrass}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:269

@c ---end content BrillNoether---

@c ------------------- Weierstrass -------------
@node Weierstrass, extcurve, BrillNoether, brnoeth_lib
@subsubsection Weierstrass
@cindex Weierstrass
@c ---content Weierstrass---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
Weierstrass( i, m, CURVE ); i,m integers and CURVE a list

@item @strong{Return:}
list WS of two lists:
  @format
  WS[1] list of integers (Weierstr. semigroup of the curve at place i up to m)
  WS[2] list of ideals (the associated rational functions)
  @end format

@item @strong{Note:}
The procedure must be called from the ring CURVE[1][2],
where CURVE is the output of the procedure @code{NSplaces}.
@* i represents the place CURVE[3][i].
@* Rational functions are represented by numerator/denominator
in form of ideals with two homogeneous generators.

@item @strong{Warning:}
The place must be rational, i.e., necessarily CURVE[3][i][1]=1. @*

@end table
@strong{Example:}
@smallexample
@c computed example Weierstrass d2t_singular/brnoeth_lib.doc:306 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(x3y+y3+x);
@expansion{} The genus of the curve is 3
C=NSplaces(1..4,C);
def R=C[1][2];
setring R;
// Place C[3][1] has degree 1 (i.e it is rational);
list WS=Weierstrass(1,7,C);
@expansion{} Vector basis successfully computed 
// the first part of the list is the Weierstrass semigroup up to 7 :
WS[1];
@expansion{} [1]:
@expansion{}    0
@expansion{} [2]:
@expansion{}    3
@expansion{} [3]:
@expansion{}    5
@expansion{} [4]:
@expansion{}    6
@expansion{} [5]:
@expansion{}    7
// and the second part are the corresponding functions :
WS[2];
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=1
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{}    _[2]=z
@expansion{} [3]:
@expansion{}    _[1]=xy
@expansion{}    _[2]=z2
@expansion{} [4]:
@expansion{}    _[1]=y2
@expansion{}    _[2]=z2
@expansion{} [5]:
@expansion{}    _[1]=y3
@expansion{}    _[2]=xz2
printlevel=plevel;
@c end example Weierstrass d2t_singular/brnoeth_lib.doc:306
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:324
@ifinfo
@menu
See also:
* Adj_div::
* BrillNoether::
* NSplaces::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{Adj_div};
@ref{BrillNoether};
@ref{NSplaces}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:324

@c ---end content Weierstrass---

@c ------------------- extcurve -------------
@node extcurve, AGcode_L, Weierstrass, brnoeth_lib
@subsubsection extcurve
@cindex extcurve
@c ---content extcurve---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
extcurve( d, CURVE ); d an integer, CURVE a list

@item @strong{Return:}
list L which is the update of the list CURVE with additional entries
   @format
   L[1][3]: ring (p,a),(x,y),lp (affine),
   L[1][4]: ring (p,a),(x,y,z),lp (projective),
   L[1][5]: ring (p,a),(x,y,t),ls (local),
   L[2][3]: int  (the number of rational places),
   @end format
the rings being defined over a field extension of degree d. @*
If d<2 then @code{extcurve(d,CURVE);} creates a list L which
is the update of the list CURVE with additional entries
   @format
   L[1][5]: ring p,(x,y,t),ls,
   L[2][3]: int  (the number of computed places over the base field).
   @end format
In both cases, in the ring L[1][5] lists with the data for all the
computed rational places (after a field extension of degree d) are
created (see @ref{Adj_div}):
   @format
   lists POINTS, LOC_EQS, BRANCHES, PARAMETRIZATIONS.
   @end format

@item @strong{Note:}
The list CURVE should be the output of @code{NSplaces},
and must contain (at least) one place of degree d. @*
You actually need all the places with degree dividing d.
Otherwise, not all the places are computed, but only part of them. @*
This procedure must be executed before constructing AG codes,
even if no extension is needed. The ring L[1][4] must be active
when constructing codes over the field extension.@*

@end table
@strong{Example:}
@smallexample
@c computed example extcurve d2t_singular/brnoeth_lib.doc:375 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(x5+y2+y);
@expansion{} The genus of the curve is 2
C=NSplaces(1..4,C);
// since we have all points up to degree 4, we can extend the curve
// to that extension, in order to get rational points over F_16;
C=extcurve(4,C);
@expansion{} Total number of rational places : NrRatPl = 33
// e.g., display the basepoint of place no. 32:
def R=C[1][5];
setring R;
POINTS[32];
@expansion{} [1]:
@expansion{}    (a3+a2+a+1)
@expansion{} [2]:
@expansion{}    (a2+a)
@expansion{} [3]:
@expansion{}    1
printlevel=plevel;
@c end example extcurve d2t_singular/brnoeth_lib.doc:375
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:392
@ifinfo
@menu
See also:
* AGcode_L::
* AGcode_Omega::
* Adj_div::
* NSplaces::
* closed_points::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{AGcode_L};
@ref{AGcode_Omega};
@ref{Adj_div};
@ref{NSplaces};
@ref{closed_points}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:392

@c ---end content extcurve---

@c ------------------- AGcode_L -------------
@node AGcode_L, AGcode_Omega, extcurve, brnoeth_lib
@subsubsection AGcode_L
@cindex AGcode_L
@c ---content AGcode_L---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
AGcode_L( G, D, EC ); G,D intvec, EC a list

@item @strong{Return:}
a generator matrix for the evaluation AG code defined by the
divisors G and D.

@item @strong{Note:}
The procedure must be called within the ring EC[1][4],
where EC is the output of @code{extcurve(d)} (or within
the ring EC[1][2] if d=1). @*
The entry i in the intvec D refers to the i-th rational
place in EC[1][5] (i.e., to POINTS[i], etc., see @ref{extcurve}).@*
The intvec G represents a rational divisor (see @ref{BrillNoether}
for more details).@*
The code evaluates the vector basis of L(G) at the rational
places given by D.

@item @strong{Warnings:}
G should satisfy 
@ifinfo
@math{ 2*genus-2 < deg(G) < size(D) }
@end ifinfo
@tex
$ 2*genus-2 < deg(G) < size(D) $
@end tex
, which is
not checked by the algorithm.
@*G and D should have disjoint supports (checked by the algorithm).

@end table
@strong{Example:}
@smallexample
@c computed example AGcode_L d2t_singular/brnoeth_lib.doc:432 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list HC=Adj_div(x3+y2+y);
@expansion{} The genus of the curve is 1
HC=NSplaces(1..2,HC);
HC=extcurve(2,HC);
@expansion{} Total number of rational places : NrRatPl = 9
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// let us construct the corresponding evaluation AG code :
matrix C=AGcode_L(G,D,HC);
@expansion{} Vector basis successfully computed 
// here is a linear code of type [8,5,>=3] over F_4
print(C);
@expansion{} 0,0,(a),  (a+1),1,  1,    (a+1),(a),  
@expansion{} 1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),
@expansion{} 1,1,1,    1,    1,  1,    1,    1,    
@expansion{} 0,0,(a+1),(a),  1,  1,    (a),  (a+1),
@expansion{} 0,0,(a+1),(a),  (a),(a+1),1,    1     
printlevel=plevel;
@c end example AGcode_L d2t_singular/brnoeth_lib.doc:432
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:451
@ifinfo
@menu
See also:
* AGcode_Omega::
* Adj_div::
* BrillNoether::
* extcurve::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{AGcode_Omega};
@ref{Adj_div};
@ref{BrillNoether};
@ref{extcurve}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:451

@c ---end content AGcode_L---

@c ------------------- AGcode_Omega -------------
@node AGcode_Omega, prepSV, AGcode_L, brnoeth_lib
@subsubsection AGcode_Omega
@cindex AGcode_Omega
@c ---content AGcode_Omega---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
AGcode_Omega( G, D, EC ); G,D intvec, EC a list

@item @strong{Return:}
a generator matrix for the residual AG code defined by the
divisors G and D.

@item @strong{Note:}
The procedure must be called within the ring EC[1][4],
where EC is the output of @code{extcurve(d)} (or within
the ring EC[1][2] if d=1). @*
The entry i in the intvec D refers to the i-th rational
place in EC[1][5] (i.e., to POINTS[i], etc., see @ref{extcurve}).@*
The intvec G represents a rational divisor (see @ref{BrillNoether}
for more details).@*
The code computes the residues of a vector space basis of

@ifinfo
@math{\Omega(G-D)}
@end ifinfo
@tex
$\Omega(G-D)$
@end tex
 at the rational places given by D.

@item @strong{Warnings:}
G should satisfy 
@ifinfo
@math{ 2*genus-2 < deg(G) < size(D) }
@end ifinfo
@tex
$ 2*genus-2 < deg(G) < size(D) $
@end tex
, which is
not checked by the algorithm.
@*G and D should have disjoint supports (checked by the algorithm).

@end table
@strong{Example:}
@smallexample
@c computed example AGcode_Omega d2t_singular/brnoeth_lib.doc:491 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list HC=Adj_div(x3+y2+y);
@expansion{} The genus of the curve is 1
HC=NSplaces(1..2,HC);
HC=extcurve(2,HC);
@expansion{} Total number of rational places : NrRatPl = 9
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// let us construct the corresponding residual AG code :
matrix C=AGcode_Omega(G,D,HC);
@expansion{} Vector basis successfully computed 
// here is a linear code of type [8,3,>=5] over F_4
print(C);
@expansion{} 0,    (a),(a),(a),  (a+1),1,0,  0,
@expansion{} (a+1),1,  (a),0,    (a),  0,(a),0,
@expansion{} (a+1),0,  (a),(a+1),(a+1),0,0,  1 
printlevel=plevel;
@c end example AGcode_Omega d2t_singular/brnoeth_lib.doc:491
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:510
@ifinfo
@menu
See also:
* AGcode_L::
* Adj_div::
* BrillNoether::
* extcurve::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{AGcode_L};
@ref{Adj_div};
@ref{BrillNoether};
@ref{extcurve}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:510

@c ---end content AGcode_Omega---

@c ------------------- prepSV -------------
@node prepSV, decodeSV, AGcode_Omega, brnoeth_lib
@subsubsection prepSV
@cindex prepSV
@c ---content prepSV---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
prepSV( G, D, F, EC ); G,D,F intvecs and EC a list

@item @strong{Return:}
list E of size n+3, where n=size(D). All its entries but E[n+3]
are matrices:
   @format
   E[1]:  parity check matrix for the current AG code
   E[2] ... E[n+2]:  matrices used in the procedure decodeSV
   E[n+3]:  intvec with
       E[n+3][1]: correction capacity 
@ifinfo
@math{epsilon}
@end ifinfo
@tex
$epsilon$
@end tex
 of the algorithm
       E[n+3][2]: designed Goppa distance 
@ifinfo
@math{delta}
@end ifinfo
@tex
$delta$
@end tex
 of the current AG code
   @end format

@item @strong{Note:}
Computes the preprocessing for the basic (Skorobogatov-Vladut)
decoding algorithm.@*
The procedure must be called within the ring EC[1][4], where EC is
the output of @code{extcurve(d)} (or in the ring EC[1][2] if d=1) @*
The intvec G and F represent rational divisors (see
@ref{BrillNoether} for more details).@*
The intvec D refers to rational places (see @ref{AGcode_Omega}
for more details.).
The current AG code is @code{AGcode_Omega(G,D,EC)}.@*
If you know the exact minimum distance d and you want to use it in
@code{decodeSV} instead of 
@ifinfo
@math{delta}
@end ifinfo
@tex
$delta$
@end tex
, you can change the value
of E[n+3][2] to d before applying decodeSV.
@*If you have a systematic encoding for the current code and want to
keep it during the decoding, you must previously permute D (using
@code{permute_L(D,P);}), e.g., according to the permutation
P=L[3], L being the output of @code{sys_code}.

@item @strong{Warnings:}
F must be a divisor with support disjoint from the support of D and
with degree 
@ifinfo
@math{epsilon + genus}
@end ifinfo
@tex
$epsilon + genus$
@end tex
, where

@ifinfo
@math{epsilon:=[(deg(G)-3*genus+1)/2]}
@end ifinfo
@tex
$epsilon:=[(deg(G)-3*genus+1)/2]$
@end tex
.@*
G should satisfy 
@ifinfo
@math{ 2*genus-2 < deg(G) < size(D) }
@end ifinfo
@tex
$ 2*genus-2 < deg(G) < size(D) $
@end tex
, which is
not checked by the algorithm.
@*G and D should also have disjoint supports (checked by the
algorithm).

@cindex SV-decoding algorithm, preprocessing
@end table
@strong{Example:}
@smallexample
@c computed example prepSV d2t_singular/brnoeth_lib.doc:569 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list HC=Adj_div(x3+y2+y);
@expansion{} The genus of the curve is 1
HC=NSplaces(1..2,HC);
HC=extcurve(2,HC);
@expansion{} Total number of rational places : NrRatPl = 9
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// construct the corresp. residual AG code of type [8,3,>=5] over F_4:
matrix C=AGcode_Omega(G,D,HC);
@expansion{} Vector basis successfully computed 
// we can correct 1 error and the genus is 1, thus F must have degree 2
// and support disjoint from that of D;
intvec F=2;
list SV=prepSV(G,D,F,HC);
@expansion{} Vector basis successfully computed 
@expansion{} Vector basis successfully computed 
@expansion{} Vector basis successfully computed 
// now everything is prepared to decode with the basic algorithm;
// for example, here is a parity check matrix to compute the syndrome :
print(SV[1]);
@expansion{} 0,0,(a),  (a+1),1,  1,    (a+1),(a),  
@expansion{} 1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),
@expansion{} 1,1,1,    1,    1,  1,    1,    1,    
@expansion{} 0,0,(a+1),(a),  1,  1,    (a),  (a+1),
@expansion{} 0,0,(a+1),(a),  (a),(a+1),1,    1     
// and here you have the correction capacity of the algorithm :
int epsilon=SV[size(D)+3][1];
epsilon;
@expansion{} 1
printlevel=plevel;
@c end example prepSV d2t_singular/brnoeth_lib.doc:569
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:596
@ifinfo
@menu
See also:
* AGcode_Omega::
* decodeSV::
* extcurve::
* permute_L::
* sys_code::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{AGcode_Omega};
@ref{decodeSV};
@ref{extcurve};
@ref{permute_L};
@ref{sys_code}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:596

@c ---end content prepSV---

@c ------------------- decodeSV -------------
@node decodeSV, closed_points, prepSV, brnoeth_lib
@subsubsection decodeSV
@cindex decodeSV
@c ---content decodeSV---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
decodeSV( y, K ); y a row-matrix and K a list

@item @strong{Return:}
a codeword (row-matrix) if possible, resp. the 0-matrix (of size
1) if decoding is impossible.
@*For decoding the basic (Skorobogatov-Vladut) decoding algorithm
is applied.

@item @strong{Note:}
The list_expression should be the output K of the procedure
@code{prepSV}.@*
The matrix_expression should be a (1 x n)-matrix, where
n = ncols(K[1]).@*
The decoding may fail if the number of errors is greater than
the correction capacity of the algorithm.

@cindex SV-decoding algorithm
@end table
@strong{Example:}
@smallexample
@c computed example decodeSV d2t_singular/brnoeth_lib.doc:631 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list HC=Adj_div(x3+y2+y);
@expansion{} The genus of the curve is 1
HC=NSplaces(1..2,HC);
HC=extcurve(2,HC);
@expansion{} Total number of rational places : NrRatPl = 9
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// construct the corresp. residual AG code of type [8,3,>=5] over F_4:
matrix C=AGcode_Omega(G,D,HC);
@expansion{} Vector basis successfully computed 
// we can correct 1 error and the genus is 1, thus F must have degree 2
// and support disjoint from that of D
intvec F=2;
list SV=prepSV(G,D,F,HC);
@expansion{} Vector basis successfully computed 
@expansion{} Vector basis successfully computed 
@expansion{} Vector basis successfully computed 
// now we produce 1 error on the zero-codeword :
matrix y[1][8];
y[1,3]=a;
// and then we decode :
print(decodeSV(y,SV));
@expansion{} 0,0,0,0,0,0,0,0
printlevel=plevel;
@c end example decodeSV d2t_singular/brnoeth_lib.doc:631
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:657
@ifinfo
@menu
See also:
* AGcode_Omega::
* extcurve::
* prepSV::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{AGcode_Omega};
@ref{extcurve};
@ref{prepSV}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:657

@c ---end content decodeSV---

@c ------------------- closed_points -------------
@node closed_points, dual_code, decodeSV, brnoeth_lib
@subsubsection closed_points
@cindex closed_points
@c ---content closed_points---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
closed_points(I); I an ideal

@item @strong{Return:}
list of prime ideals (each a Groebner basis), corresponding to
the (distinct affine closed) points of V(I)

@item @strong{Note:}
The ideal must have dimension 0, the basering must have 2
variables, the ordering must be lp, and the base field must
be finite and prime.@*
It might be convenient to set the option(redSB) in advance.

@end table
@strong{Example:}
@smallexample
@c computed example closed_points d2t_singular/brnoeth_lib.doc:687 
LIB "brnoeth.lib";
ring s=2,(x,y),lp;
// this is just the affine plane over F_4 :
ideal I=x4+x,y4+y;
list L=closed_points(I);
// and here you have all the points :
L;
@expansion{} [1]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x+y
@expansion{} [2]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x+1
@expansion{} [3]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x+y+1
@expansion{} [4]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x
@expansion{} [5]:
@expansion{}    _[1]=y+1
@expansion{}    _[2]=x2+x+1
@expansion{} [6]:
@expansion{}    _[1]=y+1
@expansion{}    _[2]=x+1
@expansion{} [7]:
@expansion{}    _[1]=y+1
@expansion{}    _[2]=x
@expansion{} [8]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x2+x+1
@expansion{} [9]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x+1
@expansion{} [10]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x
@c end example closed_points d2t_singular/brnoeth_lib.doc:687
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:697
@ifinfo
@menu
See also:
* triang_lib::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{triang_lib}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:697

@c ---end content closed_points---

@c ------------------- dual_code -------------
@node dual_code, sys_code, closed_points, brnoeth_lib
@subsubsection dual_code
@cindex dual_code
@c ---content dual_code---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
dual_code(G); G a matrix of numbers

@item @strong{Return:}
a generator matrix of the dual code generated by G

@item @strong{Note:}
The input should be a matrix G of numbers. @*
The output is also a parity check matrix for the code defined by G

@cindex linear code, dual
@end table
@strong{Example:}
@smallexample
@c computed example dual_code d2t_singular/brnoeth_lib.doc:725 
LIB "brnoeth.lib";
ring s=2,T,lp;
// here is the Hamming code of length 7 and dimension 3
matrix G[3][7]=1,0,1,0,1,0,1,0,1,1,0,0,1,1,0,0,0,1,1,1,1;
print(G);
@expansion{} 1,0,1,0,1,0,1,
@expansion{} 0,1,1,0,0,1,1,
@expansion{} 0,0,0,1,1,1,1 
matrix H=dual_code(G);
print(H);
@expansion{} 1,1,1,0,0,0,0,
@expansion{} 1,0,0,1,1,0,0,
@expansion{} 0,1,0,1,0,1,0,
@expansion{} 1,1,0,1,0,0,1 
@c end example dual_code d2t_singular/brnoeth_lib.doc:725
@end smallexample
@c ---end content dual_code---

@c ------------------- sys_code -------------
@node sys_code, permute_L, dual_code, brnoeth_lib
@subsubsection sys_code
@cindex sys_code
@c ---content sys_code---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
sys_code(C); C is a matrix of constants

@item @strong{Return:}
list L with:
   @format
   L[1] is the generator matrix in standard form of an equivalent code,
   L[2] is the parity check matrix in standard form of such code,
   L[3] is an intvec which represents the needed permutation.
   @end format

@item @strong{Note:}
Computes a systematic code which is equivalent to the given one.@*
The input should be a matrix of numbers.@*
The output has to be interpreted as follows: if the input was
the generator matrix of an AG code then one should apply the
permutation L[3] to the divisor D of rational points by means
of @code{permute_L(D,L[3]);} before continuing to work with the
code (for instance, if you want to use the systematic encoding
together with a decoding algorithm).

@cindex linear code, systematic
@end table
@strong{Example:}
@smallexample
@c computed example sys_code d2t_singular/brnoeth_lib.doc:770 
LIB "brnoeth.lib";
ring s=3,T,lp;
matrix C[2][5]=0,1,0,1,1,0,1,0,0,1;
print(C);
@expansion{} 0,1,0,1,1,
@expansion{} 0,1,0,0,1 
list L=sys_code(C);
L[3];
@expansion{} 2,4,3,1,5
// here is the generator matrix in standard form
print(L[1]);
@expansion{} 1,0,0,0,1,
@expansion{} 0,1,0,0,0 
// here is the control matrix in standard form
print(L[2]);
@expansion{} 0, 0,1,0,0,
@expansion{} 0, 0,0,1,0,
@expansion{} -1,0,0,0,1 
// we can check that both codes are dual to each other
print(L[1]*transpose(L[2]));
@expansion{} 0,0,0,
@expansion{} 0,0,0 
@c end example sys_code d2t_singular/brnoeth_lib.doc:770
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:785
@ifinfo
@menu
See also:
* AGcode_Omega::
* permute_L::
* prepSV::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{AGcode_Omega};
@ref{permute_L};
@ref{prepSV}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:785

@c ---end content sys_code---

@c ------------------- permute_L -------------
@node permute_L,, sys_code, brnoeth_lib
@subsubsection permute_L
@cindex permute_L
@c ---content permute_L---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
permute_L( L, P ); L,P either intvecs or lists

@item @strong{Return:}
list obtained from L by applying the permutation given by P.

@item @strong{Note:}
If P is a list, all entries must be integers.

@end table
@strong{Example:}
@smallexample
@c computed example permute_L d2t_singular/brnoeth_lib.doc:811 
LIB "brnoeth.lib";
list L=list();
L[1]="a";
L[2]="b";
L[3]="c";
L[4]="d";
intvec P=1,3,4,2;
// the list L is permuted according to P :
permute_L(L,P);
@expansion{} [1]:
@expansion{}    a
@expansion{} [2]:
@expansion{}    c
@expansion{} [3]:
@expansion{}    d
@expansion{} [4]:
@expansion{}    b
@c end example permute_L d2t_singular/brnoeth_lib.doc:811
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:823
@ifinfo
@menu
See also:
* AGcode_Omega::
* prepSV::
* sys_code::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{AGcode_Omega};
@ref{prepSV};
@ref{sys_code}.
@end iftex
@c end inserted refs from d2t_singular/brnoeth_lib.doc:823

@c ---end content permute_L---
