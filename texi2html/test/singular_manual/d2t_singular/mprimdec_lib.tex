@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/mprimdec_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/mprimdec_lib.doc INSTEAD
@c library version: (1.1.2.3,2002/03/19)
@c library file: ../Singular/LIB/mprimdec.lib
@cindex mprimdec.lib
@cindex mprimdec_lib
@table @asis
@item @strong{Library:}
mprimdec.lib
@item @strong{Purpose:}
   procedures for primary decomposition of modules
@item @strong{Authors:}
Alexander Dreyer, dreyer@@mathematik.uni-kl.de; adreyer@@web.de

@item @strong{Remark:}
These procedures are implemented to be used in characteristic 0.
@*They also work in positive characteristic >> 0.
@*In small characteristic and for algebraic extensions, the
procedures via Gianni, Trager, Zacharias may not terminate.

@end table

@strong{Procedures:}
@menu
* separator:: computes a list of separators of prime ideals
* PrimdecA:: (not necessarily minimal) primary decomposition via Shimoyama/Yokoyama (suggested by Graebe)
* PrimdecB:: (not necessarily minimal) primary decomposition for pseudo-primary ideals
* modDec:: minimal primary decomposition via Shimoyama/Yokoyama (suggested by Graebe)
* zeroMod:: minimal zero-dimensional primary decomposition via Gianni, Trager and Zacharias
* GTZmod:: minimal primary decomposition via Gianni, Trager and Zacharias
* dec1var:: primary decomposition for one variable
* annil:: the annihilator of M/N in the basering
* splitting:: splitting to simpler modules
* primTest:: tests whether i is prime or homogeneous
* preComp:: enhanced Version of splitting
* indSet:: lists with varstrings of(in)dependent variables
* GTZopt:: a faster version of GTZmod
* zeroOpt:: a faster version of zeroMod
* clrSBmod:: extracts an minimal SB from a SB
* minSatMod:: minimal saturation of N w.r.t. I
* specialModulesEqual:: checks for equality of standard bases of modules if N1 is contained in N2 or vice versa
* stdModulesEqual:: checks for equality of standard bases
* modulesEqual:: checks for equality of modules
* getData:: extracts oldData and computes the remaining data
@end menu
@c ---end content LibInfo---

@c ------------------- separator -------------
@node separator, PrimdecA,, mprimdec_lib
@subsubsection separator
@cindex separator
@c ---content separator---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
separator(l); list l of prime ideals

@item @strong{Return:}
list sepList;
@*a list of separators of the prime ideals in l,
@*i.e. polynomials p_ij, s.th. p_ij is in l[j],
@*for all l[j] not contained in l[i]
@*but p_ij is not in l[i]

@end table
@strong{Example:}
@smallexample
@c computed example separator d2t_singular/mprimdec_lib.doc:68 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
ideal i=(x2y,xz2,y2z,z3);
list l=minAssGTZ(i);
list sepL=separator(l);
sepL;
@expansion{} [1]:
@expansion{}    x
@expansion{} [2]:
@expansion{}    y
@c end example separator d2t_singular/mprimdec_lib.doc:68
@end smallexample
@c ---end content separator---

@c ------------------- PrimdecA -------------
@node PrimdecA, PrimdecB, separator, mprimdec_lib
@subsubsection PrimdecA
@cindex PrimdecA
@c ---content PrimdecA---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
PrimdecA (N[, i]); module N, int i

@item @strong{Return:}
list l
@*a (not necessarily minimal) primary decomposition of N
computed by a generalized version of
@*the algorithm of Schimoyama/Yokoyama,
@*if i=1 is given, the factorizing Groebner is used
@*to compute the isolated primes.

@end table
@strong{Example:}
@smallexample
@c computed example PrimdecA d2t_singular/mprimdec_lib.doc:101 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1)+ y*gen(2),
x*gen(1)-x2*gen(2);
list l=PrimdecA(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=x*gen(1)+y*gen(2)
@expansion{}       _[2]=x*gen(2)-gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x2+y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=x*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=y*gen(1)
@expansion{}       _[2]=y*gen(2)
@expansion{}       _[3]=x*gen(1)
@expansion{}       _[4]=x*gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=y
@expansion{}       _[2]=x
@c end example PrimdecA d2t_singular/mprimdec_lib.doc:101
@end smallexample
@c ---end content PrimdecA---

@c ------------------- PrimdecB -------------
@node PrimdecB, modDec, PrimdecA, mprimdec_lib
@subsubsection PrimdecB
@cindex PrimdecB
@c ---content PrimdecB---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
PrimdecB (N, p); pseudo-primary module N, isolated prime ideal p

@item @strong{Return:}
list l
@*a (not necessarily minimal) primary decomposition of N

@end table
@strong{Example:}
@smallexample
@c computed example PrimdecB d2t_singular/mprimdec_lib.doc:130 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=y*gen(1),y2*gen(2),yz*gen(2),yx*gen(2);
ideal p=y;
list l=PrimdecB(N,p);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=y*gen(1)
@expansion{}       _[2]=y*gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=y*gen(1)
@expansion{}       _[2]=y*gen(2)
@expansion{}       _[3]=x*gen(1)
@expansion{}       _[4]=x*gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=y
@expansion{}       _[2]=x
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=z*gen(1)
@expansion{}       _[2]=z*gen(2)
@expansion{}       _[3]=y*gen(1)
@expansion{}       _[4]=x*gen(1)
@expansion{}       _[5]=x*gen(2)
@expansion{}       _[6]=y2*gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{}       _[2]=y
@expansion{}       _[3]=x
@c end example PrimdecB d2t_singular/mprimdec_lib.doc:130
@end smallexample
@c ---end content PrimdecB---

@c ------------------- modDec -------------
@node modDec, zeroMod, PrimdecB, mprimdec_lib
@subsubsection modDec
@cindex modDec
@c ---content modDec---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
modDec (N[, i]); module N, int i

@item @strong{Return:}
list l
@*a minimal primary decomposition of N
@*computed by an generalized version of
@*the algorithm of Schimoyama/Yokoyama,
@*if i=1 is given, the factorizing Groebner is used

@end table
@strong{Example:}
@smallexample
@c computed example modDec d2t_singular/mprimdec_lib.doc:162 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1)+ y*gen(2),
x*gen(1)-x2*gen(2);
list l=modDec(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=x*gen(1)+y*gen(2)
@expansion{}       _[2]=x*gen(2)-gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x2+y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=x*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x
@c end example modDec d2t_singular/mprimdec_lib.doc:162
@end smallexample
@c ---end content modDec---

@c ------------------- zeroMod -------------
@node zeroMod, GTZmod, modDec, mprimdec_lib
@subsubsection zeroMod
@cindex zeroMod
@c ---content zeroMod---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
zeroMod (N[, check]); zero-dimensional module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of a zero-dimensional module N,
computed by a generalized version of the algorithm
@*of Gianni, Trager and Zacharias

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example zeroMod d2t_singular/mprimdec_lib.doc:197 
LIB "mprimdec.lib";
ring r=0,z,dp;
module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
list l=zeroMod(N);
@expansion{} 2
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(3)
@expansion{}       _[3]=z*gen(2)-gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z-1
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=gen(3)
@expansion{}       _[3]=z*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}       _[3]=z*gen(3)+gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@c end example zeroMod d2t_singular/mprimdec_lib.doc:197
@end smallexample
@c ---end content zeroMod---

@c ------------------- GTZmod -------------
@node GTZmod, dec1var, zeroMod, mprimdec_lib
@subsubsection GTZmod
@cindex GTZmod
@c ---content GTZmod---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
GTZmod (N[, check]); module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of the module N,
@*computed by a generalized version of the algorithm
@*of Gianny, Trager and Zacharias

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example GTZmod d2t_singular/mprimdec_lib.doc:231 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1)+ y*gen(2),
x*gen(1)-x2*gen(2);
list l=GTZmod(N);
@expansion{} 2
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=x*gen(1)+y*gen(2)
@expansion{}       _[2]=x*gen(2)-gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x2+y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=x*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x
@c end example GTZmod d2t_singular/mprimdec_lib.doc:231
@end smallexample
@c ---end content GTZmod---

@c ------------------- dec1var -------------
@node dec1var, annil, GTZmod, mprimdec_lib
@subsubsection dec1var
@cindex dec1var
@c ---content dec1var---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
dec1var (N); zero-dimensional module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of a submodule N of R^s
if nvars(R)=1

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example dec1var d2t_singular/mprimdec_lib.doc:265 
LIB "mprimdec.lib";
ring r=0,z,dp;
module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
list l=dec1var(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(3)
@expansion{}       _[3]=z*gen(2)-gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z-1
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=gen(3)
@expansion{}       _[3]=z*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}       _[3]=z*gen(3)+gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@c end example dec1var d2t_singular/mprimdec_lib.doc:265
@end smallexample
@c ---end content dec1var---

@c ------------------- annil -------------
@node annil, splitting, dec1var, mprimdec_lib
@subsubsection annil
@cindex annil
@c ---content annil---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
annil(N); module N

@item @strong{Return:}
ideal ann=std(quotient(N,freemodule(nrows(N))));
@*the annihilator of M/N in the basering

@item @strong{Note:}
ann is a std basis in the basering

@end table
@strong{Example:}
@smallexample
@c computed example annil d2t_singular/mprimdec_lib.doc:296 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1), y*gen(2);
ideal ann=annil(N);
ann;
@expansion{} ann[1]=xy
@c end example annil d2t_singular/mprimdec_lib.doc:296
@end smallexample
@c ---end content annil---

@c ------------------- splitting -------------
@node splitting, primTest, annil, mprimdec_lib
@subsubsection splitting
@cindex splitting
@c ---content splitting---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
splitting(N[,check[, ann]]); module N, module check, ideal ann

@item @strong{Return:}
(l, check) list l, module check
@*the elements of l consists of a triple with
@*[1] of type module [2] and [3] of type ideal
@*s.th. the intersection of the modules is equal to the
zero-dimensional module N, furthermore l[j][3]=annil(l[j][1])
if l[j][2]!=0 then the module l[j][1] is primary
@*with associated prime l[j][2],
@*and check=intersect(check, l[j][1]) is computed

@item @strong{Note:}
if the parameter check is given, only components not containing
check are computed; if ann is given, ann is used instead of annil(N)

@end table
@strong{Example:}
@smallexample
@c computed example splitting d2t_singular/mprimdec_lib.doc:334 
LIB "mprimdec.lib";
ring r=0,z,lp;
module N=z*gen(1), (z+1)*gen(2);
N=std(N);
list l; module check;
(l, check)=splitting(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=z*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{}    [3]:
@expansion{}       _[1]=z
@expansion{}    [4]:
@expansion{}       _[1]=z
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=z*gen(2)+gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@expansion{}    [3]:
@expansion{}       _[1]=z+1
@expansion{}    [4]:
@expansion{}       _[1]=z+1
check;
@expansion{} check[1]=z*gen(2)+gen(2)
@expansion{} check[2]=z*gen(1)
@c end example splitting d2t_singular/mprimdec_lib.doc:334
@end smallexample
@c ---end content splitting---

@c ------------------- primTest -------------
@node primTest, preComp, splitting, mprimdec_lib
@subsubsection primTest
@cindex primTest
@c ---content primTest---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
primTest(i[, p]); a zero-dimensional ideal i, irreducible poly p in i

@item @strong{Return:}
if i neither is prime nor is homogeneous then ideal(0) is returned,
else radical(i)

@end table
@strong{Example:}
@smallexample
@c computed example primTest d2t_singular/mprimdec_lib.doc:365 
LIB "mprimdec.lib";
ring r=0,(x,y,z),lp;
ideal i=x+1,y-1,z;
i=std(i);
ideal primId=primTest(i,z);
primId;
@expansion{} primId[1]=z
@expansion{} primId[2]=y-1
@expansion{} primId[3]=x+1
i=x,z2,yz,y2;
i=std(i);
primId=primTest(i);
primId;
@expansion{} primId[1]=x
@expansion{} primId[2]=y
@expansion{} primId[3]=z
@c end example primTest d2t_singular/mprimdec_lib.doc:365
@end smallexample
@c ---end content primTest---

@c ------------------- preComp -------------
@node preComp, indSet, primTest, mprimdec_lib
@subsubsection preComp
@cindex preComp
@c ---content preComp---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
preComp(N,check[, ann]); module N, module check, ideal ann

@item @strong{Return:}
(l, check) list l, module check
@*the elements of l consists of a triple with
@*[1] of type module [2] and [3] of type ideal
@*s.th. the intersection of the modules is equal to the
zero-dimensional module N, furthermore l[j][3]=annil(l[j][1])
if l[j][2]!=0 then the module l[j][1] is primary
@*with associated prime l[j][2],
@*and check=intersect(check, l[j][1]) is computed

@item @strong{Note:}
only components not containing check are computed;
@*if ann is given, ann is used instead of annil(N)

@end table
@strong{Example:}
@smallexample
@c computed example preComp d2t_singular/mprimdec_lib.doc:408 
LIB "mprimdec.lib";
ring r=0,z,lp;
module N=z*gen(1), (z+1)*gen(2);
N=std(N);
list l; module check;
(l, check)=preComp(N,freemodule(2));
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=z*gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{}    [3]:
@expansion{}       _[1]=z
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=z*gen(2)+gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@expansion{}    [3]:
@expansion{}       _[1]=z+1
check;
@expansion{} check[1]=z*gen(1)
@expansion{} check[2]=z*gen(2)+gen(2)
@c end example preComp d2t_singular/mprimdec_lib.doc:408
@end smallexample
@c ---end content preComp---

@c ------------------- indSet -------------
@node indSet, GTZopt, preComp, mprimdec_lib
@subsubsection indSet
@cindex indSet
@c ---content indSet---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
indSet(i); i ideal

@item @strong{Return:}
list with two entrees
@*both are lists of new varstrings with the dependent variables
the independent set, the ordstring with the corresp. block ordering,
and the integer where the independent set starts in the varstring

@item @strong{Note:}
the first entry gives the strings for all maximal independent sets
the second gives the strings for the independent sets,
@*which cannot be enhanced

@end table
@strong{Example:}
@smallexample
@c computed example indSet d2t_singular/mprimdec_lib.doc:446 
LIB "mprimdec.lib";
ring s1=(0,x,y),(a,b,c,d,e,f,g),lp;
ideal i=ea-fbg,fa+be,ec-fdg,fc+de;
i=std(i);
list  l=indSet(i);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       [1]:
@expansion{}          e,f
@expansion{}       [2]:
@expansion{}          a,b,c,d,g
@expansion{}       [3]:
@expansion{}          (C,dp(2),dp)
@expansion{}       [4]:
@expansion{}          5
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       [1]:
@expansion{}          a,b,c,d
@expansion{}       [2]:
@expansion{}          e,f,g
@expansion{}       [3]:
@expansion{}          (C,dp(4),dp)
@expansion{}       [4]:
@expansion{}          3
@expansion{}    [2]:
@expansion{}       [1]:
@expansion{}          a,c,e
@expansion{}       [2]:
@expansion{}          b,d,f,g
@expansion{}       [3]:
@expansion{}          (C,dp(3),dp)
@expansion{}       [4]:
@expansion{}          4
@c end example indSet d2t_singular/mprimdec_lib.doc:446
@end smallexample
@c ---end content indSet---

@c ------------------- GTZopt -------------
@node GTZopt, zeroOpt, indSet, mprimdec_lib
@subsubsection GTZopt
@cindex GTZopt
@c ---content GTZopt---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
GTZopt (N[, check]); module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of the module N,
@*computed by a generalized and optimized version of
@*the algorithm of Gianny, Trager and Zacharias

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example GTZopt d2t_singular/mprimdec_lib.doc:481 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1)+ y*gen(2),
x*gen(1)-x2*gen(2);
list l=GTZopt(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=x*gen(1)+y*gen(2)
@expansion{}       _[2]=x*gen(2)-gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x2+y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=x*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x
@c end example GTZopt d2t_singular/mprimdec_lib.doc:481
@end smallexample
@c ---end content GTZopt---

@c ------------------- zeroOpt -------------
@node zeroOpt, clrSBmod, GTZopt, mprimdec_lib
@subsubsection zeroOpt
@cindex zeroOpt
@c ---content zeroOpt---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
zeroOpt (N[, check]); zero-dimensional module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of a zero-dimensional module N,
computed by a generalized and optimized version of the algorithm
of Gianny, Trager and Zacharias

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example zeroOpt d2t_singular/mprimdec_lib.doc:516 
LIB "mprimdec.lib";
ring r=0,z,dp;
module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
list l=zeroOpt(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=z*gen(2)-gen(2)
@expansion{}       _[3]=gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z-1
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=z*gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}       _[3]=gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}       _[3]=z*gen(3)+gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@c end example zeroOpt d2t_singular/mprimdec_lib.doc:516
@end smallexample
@c ---end content zeroOpt---

@c ------------------- clrSBmod -------------
@node clrSBmod, minSatMod, zeroOpt, mprimdec_lib
@subsubsection clrSBmod
@cindex clrSBmod
@c ---content clrSBmod---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
clrSBmod(N); N module which is SB ordered by monomial ordering

@item @strong{Return:}
module = minimal SB

@end table
@strong{Example:}
@smallexample
@c computed example clrSBmod d2t_singular/mprimdec_lib.doc:543 
LIB "mprimdec.lib";
ring  r = (0,a,b),(x,y,z),dp;
module N1=ax2+y,a2x+y,bx;
module N2=clrSBmod(N1);
N2;
@expansion{} N2[1]=(a)*x2*gen(1)+y*gen(1)
@expansion{} N2[2]=(b)*x*gen(1)
@c end example clrSBmod d2t_singular/mprimdec_lib.doc:543
@end smallexample
@c ---end content clrSBmod---

@c ------------------- minSatMod -------------
@node minSatMod, specialModulesEqual, clrSBmod, mprimdec_lib
@subsubsection minSatMod
@cindex minSatMod
@c ---content minSatMod---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
minSatMod(N, I); module N, ideal I

@item @strong{Return:}
list with 2 elements:
@*[1]=sat(N,product(I))[1],
@*[2]=p, the polynomial of minimal degree s.th. [1]=quotient(N,p)

@end table
@strong{Example:}
@smallexample
@c computed example minSatMod d2t_singular/mprimdec_lib.doc:572 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),dp;
module N=xy*gen(1);
ideal h=yz,z2;
list l=minSatMod(N,h);
l;
@expansion{} [1]:
@expansion{}    _[1]=x*gen(1)
@expansion{} [2]:
@expansion{}    y
@c end example minSatMod d2t_singular/mprimdec_lib.doc:572
@end smallexample
@c ---end content minSatMod---

@c ------------------- specialModulesEqual -------------
@node specialModulesEqual, stdModulesEqual, minSatMod, mprimdec_lib
@subsubsection specialModulesEqual
@cindex specialModulesEqual
@c ---content specialModulesEqual---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
specialModulesEqual(N1, N2) N1, N2 standard bases of modules,
s.th. N1 is contained in N2 or vice versa

@item @strong{Return:}
int i
@*if (N1==N2) then i=1
@*else i=0

@end table
@strong{Example:}
@smallexample
@c computed example specialModulesEqual d2t_singular/mprimdec_lib.doc:603 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),dp;
module N1=x*freemodule(2);
module N2=xy*freemodule(2);
int i=specialModulesEqual(N1,N2);
i;
@expansion{} 0
N2=N1;
i=specialModulesEqual(N1,N2);
i;
@expansion{} 1
@c end example specialModulesEqual d2t_singular/mprimdec_lib.doc:603
@end smallexample
@c ---end content specialModulesEqual---

@c ------------------- stdModulesEqual -------------
@node stdModulesEqual, modulesEqual, specialModulesEqual, mprimdec_lib
@subsubsection stdModulesEqual
@cindex stdModulesEqual
@c ---content stdModulesEqual---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
stdModulesEqual(N1, N2) N1, N2 standard bases of modules,

@item @strong{Return:}
int i
@*if (N1==N2) then i=1
@*else i=0

@end table
@strong{Example:}
@smallexample
@c computed example stdModulesEqual d2t_singular/mprimdec_lib.doc:636 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),dp;
module N1=x*freemodule(2);
module N2=xy*freemodule(2);
int i=stdModulesEqual(N1,N2);
i;
@expansion{} 0
N2=N1;
i=stdModulesEqual(N1,N2);
i;
@expansion{} 1
@c end example stdModulesEqual d2t_singular/mprimdec_lib.doc:636
@end smallexample
@c ---end content stdModulesEqual---

@c ------------------- modulesEqual -------------
@node modulesEqual, getData, stdModulesEqual, mprimdec_lib
@subsubsection modulesEqual
@cindex modulesEqual
@c ---content modulesEqual---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
modulesEqual(N1, N2) N1, N2 modules,

@item @strong{Return:}
int i
@*if (N1==N2) then i=1
@*else i=0

@end table
@strong{Example:}
@smallexample
@c computed example modulesEqual d2t_singular/mprimdec_lib.doc:669 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),dp;
module N1=x*freemodule(2);
module N2=xy*freemodule(2);
int i=modulesEqual(N1,N2);
i;
@expansion{} 0
N2=N1;
i=modulesEqual(N1,N2);
i;
@expansion{} 1
@c end example modulesEqual d2t_singular/mprimdec_lib.doc:669
@end smallexample
@c ---end content modulesEqual---

@c ------------------- getData -------------
@node getData,, modulesEqual, mprimdec_lib
@subsubsection getData
@cindex getData
@c ---content getData---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
getData(N, l[, noCheck]); module N, list l[, int noCheck]

@item @strong{Return:}
(ann, check, M, checked)
@*ideal ann, module check, M, int checked

if l[1] is contained in N [and noCheck is not given]
@*then checked=1, ann=ideal(0), check=0, M=0;
@*else checked=0, M=freemodule(nrows(N)); check=l[1]
@*(resp. check=M if l is an empty list) and
@*if size(l)>1 then ann=l[2] else ann is the annihilator of M/N.

@item @strong{Note:}
ann is a std basis in the basering

@end table
@strong{Example:}
@smallexample
@c computed example getData d2t_singular/mprimdec_lib.doc:710 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),lp;
module N=x*gen(1),y*gen(2);
N=std(N);
ideal ann; module check, M; int checked; list l;
(ann, check, M, checked)=getData(N,l);
ann; check; M; checked;
@expansion{} ann[1]=xy
@expansion{} check[1]=gen(1)
@expansion{} check[2]=gen(2)
@expansion{} M[1]=gen(1)
@expansion{} M[2]=gen(2)
@expansion{} 0
l=list(check,ann);
(ann, check, M, checked)=getData(N,l);
ann; check; M; checked;
@expansion{} ann[1]=xy
@expansion{} check[1]=gen(1)
@expansion{} check[2]=gen(2)
@expansion{} M[1]=gen(1)
@expansion{} M[2]=gen(2)
@expansion{} 0
l=list(N);
(ann, check, M, checked)=getData(N,l);
ann; check; M; checked;
@expansion{} ann[1]=0
@expansion{} check[1]=0
@expansion{} M[1]=0
@expansion{} 1
@c end example getData d2t_singular/mprimdec_lib.doc:710
@end smallexample
@c ---end content getData---
