@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/spcurve_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/spcurve_lib.doc INSTEAD
@c library version: (1.15.2.1,2002/02/20)
@c library file: ../Singular/LIB/spcurve.lib
@cindex spcurve.lib
@cindex spcurve_lib
@table @asis
@item @strong{Library:}
spcurve.lib
@item @strong{Purpose:}
    Deformations and Invariants of CM-codim 2 Singularities
@item @strong{Author:}
Anne Fruehbis-Krueger, anne@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* isCMcod2:: presentation matrix of the ideal i, if i is CM
* CMtype:: Cohen-Macaulay type of the ideal i
* matrixT1:: 1st order deformation T1 in matrix description
* semiCMcod2:: semiuniversal deformation of maximal minors of M
* discr:: discriminant of semiuniversal deformation
* qhmatrix:: weights if M is quasihomogeneous
* relweight:: relative matrix weight of N w.r.t. weights (W,a)
* posweight:: deformation of coker(M) of non-negative weight
* KSpencerKernel:: kernel of the Kodaira-Spencer map
@end menu
@c ---end content LibInfo---

@c ------------------- isCMcod2 -------------
@node isCMcod2, CMtype,, spcurve_lib
@subsubsection isCMcod2
@cindex isCMcod2
@c ---content isCMcod2---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
isCMcod2(i); i an ideal

@item @strong{Return:}
presentation matrix of i, if i is Cohen-Macaulay of codimension 2 @*
a zero matrix otherwise

@end table
@strong{Example:}
@smallexample
@c computed example isCMcod2 d2t_singular/spcurve_lib.doc:48 
LIB "spcurve.lib";
ring r=32003,(x,y,z),ds;
ideal i=xz,yz,x^3-y^4;
print(isCMcod2(i));
@expansion{} -y,-x2,
@expansion{} x, y3, 
@expansion{} 0, z   
@c end example isCMcod2 d2t_singular/spcurve_lib.doc:48
@end smallexample
@c ---end content isCMcod2---

@c ------------------- CMtype -------------
@node CMtype, matrixT1, isCMcod2, spcurve_lib
@subsubsection CMtype
@cindex CMtype
@c ---content CMtype---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
CMtype(i); i an ideal, CM of codimension 2

@item @strong{Return:}
Cohen-Macaulay type of i (integer)
@*(-1, if i is not Cohen-Macaulay of codimension 2)

@end table
@strong{Example:}
@smallexample
@c computed example CMtype d2t_singular/spcurve_lib.doc:75 
LIB "spcurve.lib";
ring r=32003,(x,y,z),ds;
ideal i=xy,xz,yz;
CMtype(i);
@expansion{} 2
@c end example CMtype d2t_singular/spcurve_lib.doc:75
@end smallexample
@c ---end content CMtype---

@c ------------------- matrixT1 -------------
@node matrixT1, semiCMcod2, CMtype, spcurve_lib
@subsubsection matrixT1
@cindex matrixT1
@c ---content matrixT1---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
matrixT1(M,n); M matrix, n integer

@item @strong{Assume:}
M is a presentation matrix of an ideal i, CM of codimension 2;
consider i as a family of ideals in a ring in the first n
variables where the remaining variables are considered as
parameters

@item @strong{Return:}
list consisting of the k x (k+1) matrix M and a module K_M such that
T1=Mat(k,k+1;R)/K_M is the space of first order deformations of i

@end table
@strong{Example:}
@smallexample
@c computed example matrixT1 d2t_singular/spcurve_lib.doc:108 
LIB "spcurve.lib";
ring r=32003,(x(1),x(2),x(3)),ds;
ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
matrix M=isCMcod2(curve);
matrixT1(M,3);
@expansion{} [1]:
@expansion{}    _[1,1]=0
@expansion{}    _[1,2]=-x(3)
@expansion{}    _[2,1]=-x(2)
@expansion{}    _[2,2]=x(2)
@expansion{}    _[3,1]=x(1)
@expansion{}    _[3,2]=0
@expansion{} [2]:
@expansion{}    _[1]=gen(5)
@expansion{}    _[2]=gen(4)-gen(3)
@expansion{}    _[3]=-gen(2)
@expansion{}    _[4]=x(1)*gen(5)-x(2)*gen(3)
@expansion{}    _[5]=x(1)*gen(6)-x(2)*gen(4)
@expansion{}    _[6]=x(2)*gen(3)-x(3)*gen(1)
@expansion{}    _[7]=x(2)*gen(4)-x(3)*gen(2)
@expansion{}    _[8]=-x(3)*gen(2)
@expansion{}    _[9]=x(2)*gen(2)-x(2)*gen(1)
@expansion{}    _[10]=x(1)*gen(1)
@expansion{}    _[11]=-x(3)*gen(4)
@expansion{}    _[12]=x(2)*gen(4)-x(2)*gen(3)
@expansion{}    _[13]=x(1)*gen(3)
@expansion{}    _[14]=-x(3)*gen(6)
@expansion{}    _[15]=x(2)*gen(6)-x(2)*gen(5)
@expansion{}    _[16]=x(1)*gen(5)
@c end example matrixT1 d2t_singular/spcurve_lib.doc:108
@end smallexample
@c ---end content matrixT1---

@c ------------------- semiCMcod2 -------------
@node semiCMcod2, discr, matrixT1, spcurve_lib
@subsubsection semiCMcod2
@cindex semiCMcod2
@c ---content semiCMcod2---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
semiCMcod2(M,t1); M matrix, t1 module

@item @strong{Assume:}
M is a presentation matrix of an ideal i, CM of codimension 2,
and t1 is a presentation of the space of first order deformations
of i ((M,t1) as returned by the procedure matrixT1)

@item @strong{Create:}
new basering with name rneu

@item @strong{Return:}
ideal in rneu describing the semiuniversal deformation of i

@item @strong{Note:}
The current basering should not contain any variables named
A(j) where j is some integer!

@end table
@strong{Example:}
@smallexample
@c computed example semiCMcod2 d2t_singular/spcurve_lib.doc:147 
LIB "spcurve.lib";
ring r=32003,(x(1),x(2),x(3)),ds;
ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
matrix M=isCMcod2(curve);
list l=matrixT1(M,3);
semiCMcod2(l[1],std(l[2]));
@expansion{} _[1]=A(2)*A(3)-x(2)*A(3)-x(1)*x(2)
@expansion{} _[2]=A(1)*A(3)+x(1)*x(3)
@expansion{} _[3]=-x(2)*A(1)-x(3)*A(2)+x(2)*x(3)
@c end example semiCMcod2 d2t_singular/spcurve_lib.doc:147
@end smallexample
@c ---end content semiCMcod2---

@c ------------------- discr -------------
@node discr, qhmatrix, semiCMcod2, spcurve_lib
@subsubsection discr
@cindex discr
@c ---content discr---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
discr(sem,n); sem ideal, n integer

@item @strong{Assume:}
sem is the versal deformation of an ideal of codimension 2. @*
the first n variables of the ring are treated as variables
all the others as parameters

@item @strong{Return:}
ideal describing the discriminant

@item @strong{Note:}
This is not a powerful algorithm!

@end table
@strong{Example:}
@smallexample
@c computed example discr d2t_singular/spcurve_lib.doc:183 
LIB "spcurve.lib";
ring r=32003,(x(1),x(2),x(3)),ds;
ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
matrix M=isCMcod2(curve);
list l=matrixT1(M,3);
def sem=semiCMcod2(l[1],std(l[2]));
basering;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 6
@expansion{} //        block   1 : ordering ds
@expansion{} //                  : names    x(1) x(2) x(3) 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    A(1) A(2) A(3) 
@expansion{} //        block   3 : ordering C
discr(sem,3);
@expansion{} _[1]=A(1)*A(2)*A(3)
@c end example discr d2t_singular/spcurve_lib.doc:183
@end smallexample
@c ---end content discr---

@c ------------------- qhmatrix -------------
@node qhmatrix, relweight, discr, spcurve_lib
@subsubsection qhmatrix
@cindex qhmatrix
@c ---content qhmatrix---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
qhmatrix(M); M a k x (k+1) matrix

@item @strong{Return:}
list, consisting of an integer vector containing the weights of
the variables of the basering and an integer matrix giving the
weights of the entries of M, if M is quasihomogeneous;
zero integer vector and zero integer matrix, if M is not
quasihomogeneous, i.e. does not allow row and column weights

@end table
@strong{Example:}
@smallexample
@c computed example qhmatrix d2t_singular/spcurve_lib.doc:217 
LIB "spcurve.lib";
ring r=0,(x,y,z),ds;
matrix M[3][2]=z,0,y,x,x^3,y;
qhmatrix(M);
@expansion{} [1]:
@expansion{}    1,2,1
@expansion{} [2]:
@expansion{}    1,0,
@expansion{}    2,1,
@expansion{}    3,2 
pmat(M);
@expansion{} z,  0, 
@expansion{} y,  x, 
@expansion{} x3, y
@c end example qhmatrix d2t_singular/spcurve_lib.doc:217
@end smallexample
@c ---end content qhmatrix---

@c ------------------- relweight -------------
@node relweight, posweight, qhmatrix, spcurve_lib
@subsubsection relweight
@cindex relweight
@c ---content relweight---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Assume:}
N is a non-zero matrix
@*W is an integer matrix of the same size as N
@*a is an integer vector giving the weights of the variables

@item @strong{Return:}
integer, max(a-weighted order(N_ij) - W_ij | all entries ij) @*
string "ERROR" if sizes do not match

@end table
@strong{Example:}
@smallexample
@c computed example relweight d2t_singular/spcurve_lib.doc:247 
LIB "spcurve.lib";
ring r=32003,(x,y,z),ds;
matrix N[2][3]=z,0,y,x,x^3,y;
intmat W[2][3]=1,1,1,1,1,1;
intvec a=1,1,1;
relweight(N,W,a);
@expansion{} 2
@c end example relweight d2t_singular/spcurve_lib.doc:247
@end smallexample
@c ---end content relweight---

@c ------------------- posweight -------------
@node posweight, KSpencerKernel, relweight, spcurve_lib
@subsubsection posweight
@cindex posweight
@c ---content posweight---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
posweight(M,t1,n[,s]); M matrix, t1 module, n int, s string @*
n=0 : all deformations of non-negative weight @*
n=1 : only non-constant deformations of non-negative weight @*
n=2 : all deformations of positive weight @*
As an optional parameter the name of a new ring may be
specified.

@item @strong{Assume:}
M is a presentation matrix of a Cohen-Macaulay codimension 2
ideal and t1 is its T1 space in matrix notation

@item @strong{Create:}
new basering (default name: rneu); a different name for this ring
may be given as a 4th parameter

@item @strong{Return:}
list, consisting of a presentation matrix describing the deformation
given by the generators of T1 of non-negative/positive weight
and the weight vector for the new variables

@item @strong{Note:}
The current basering should not contain any variables named
T(i) where i is some integer!

@end table
@strong{Example:}
@smallexample
@c computed example posweight d2t_singular/spcurve_lib.doc:294 
LIB "spcurve.lib";
ring r=32003,(x(1),x(2),x(3)),ds;
ideal curve=(x(3)-x(1)^2)*x(3),(x(3)-x(1)^2)*x(2),x(2)^2-x(1)^7*x(3);
matrix M=isCMcod2(curve);
list l=matrixT1(M,3);
list li=posweight(l[1],std(l[2]),0);
pmat(li[1]);
@expansion{} T(2)+x(1)*T(1), -x(3)+x(1)^2, 
@expansion{} -x(3),          x(2),         
@expansion{} x(2),           -x(1)^7
li[2];
@expansion{} 3,1
@c end example posweight d2t_singular/spcurve_lib.doc:294
@end smallexample
@c ---end content posweight---

@c ------------------- KSpencerKernel -------------
@node KSpencerKernel,, posweight, spcurve_lib
@subsubsection KSpencerKernel
@cindex KSpencerKernel
@c ---content KSpencerKernel---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
KSpencerKernel(M[,s][,v]); M matrix, s string, v intvec @*
optional parameters (please specify in this order, if both are
present):
@** s = first of the names of the new rings
@*e.g. "R" leads to ring names R and R1
@** v of size n(n+1) leads to the following module ordering @*
gen(v[1]) > gen(v[2]) > ... > gen(v[n(n+1)]) where the matrix
entry ij corresponds to gen((i-1)*n+j)

@item @strong{Assume:}
M is a quasihomogeneous n x (n+1) matrix where the n minors define
an isolated space curve singularity

@item @strong{Create:}
2 new rings (default names: rneu and reneu)
@*different ring names may be specified as a 2nd parameter

@item @strong{Return:}
coefficient matrix representing the kernel of the Kodaira-
Spencer map of the family of non-negative deformations
having the given singularity as special fibre

@item @strong{Note:}
* the initial basering should not contain variables with name
e(i) or T(i), since those variable names will internally be
used by the script
@** setting an intvec with 5 entries and name watchProgress
shows the progress of the computations: @*
watchProgress[1]>0 => option(prot) in groebner commands @*
watchProgress[2]>0 => trace output for highcorner @*
watchProgress[3]>0 => output of deformed matrix @*
watchProgress[4]>0 => result of elimination step @*
watchProgress[4]>1 => trace output of multiplications with xyz
and subsequent reductions @*
watchProgress[5]>0 => matrix representing the kernel using print

@end table
@strong{Example:}
@smallexample
@c computed example KSpencerKernel d2t_singular/spcurve_lib.doc:355 
LIB "spcurve.lib";
ring r=0,(x,y,z),ds;
matrix M[3][2]=z-x^7,0,y^2,z,x^9,y;
def KS=KSpencerKernel(M,"ar");
print(KS);
@expansion{} T(7),   0,      0,      0,     0,     0,     0,     0,  
@expansion{} KS[2,1],6*T(3), 3*T(7), 0,     0,     0,     0,     0,  
@expansion{} KS[3,1],KS[3,2],KS[3,3],6*T(3),3*T(7),0,     0,     0,  
@expansion{} 10*T(4),8*T(1), 7*T(5), 5*T(2),4*T(6),2*T(8),2*T(3),T(7)
nameof(basering);
@expansion{} ar
basering;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 17
@expansion{} //        block   1 : ordering Ws
@expansion{} //                  : names    e(1) e(2) e(3) e(4) e(5) e(6) x y z 
@expansion{} //                  : weights  -21 -10 -32 -21 -27 -16 3 16 21 
@expansion{} //        block   2 : ordering wp
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) T(8) 
@expansion{} //                  : weights     8    5    2   10    7    4    1    2 
@expansion{} //        block   3 : ordering C
@c end example KSpencerKernel d2t_singular/spcurve_lib.doc:355
@end smallexample
@c ---end content KSpencerKernel---
