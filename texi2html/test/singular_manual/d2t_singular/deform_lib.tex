@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/deform_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/deform_lib.doc INSTEAD
@c library version: (1.25.2.2,2003/02/24)
@c library file: ../Singular/LIB/deform.lib
@cindex deform.lib
@cindex deform_lib
@table @asis
@item @strong{Library:}
deform.lib
@item @strong{Purpose:}
    Miniversal Deformation of Singularities and Modules
@item @strong{Author:}
Bernd Martin, email: martin@@math.tu-cottbus.de

@end table

@strong{Procedures:}
@menu
* versal:: miniversal deformation of isolated singularity Fo
* mod_versal:: miniversal deformation of module Mo modulo ideal I
* lift_kbase:: lifting N into standard kbase of M
* lift_rel_kb:: relative lifting N into a kbase of M
* kill_rings:: kills the exported rings from above
@end menu
@c ---end content LibInfo---

@c ------------------- versal -------------
@node versal, mod_versal,, deform_lib
@subsubsection versal
@cindex versal
@c ---content versal---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
versal(Fo[,d,any]); Fo=ideal, d=int, any=list

@item @strong{Compute:}
miniversal deformation of Fo up to degree d (default d=100),

@item @strong{Create:}
Rings (exported):
@*'my'Px = extending the basering Po by new variables given by
"A,B,.." (deformation parameters), returns as basering; the
new variables precede the old ones, the ordering is the
product between "ls" and "ord(Po)"
@*'my'Qx = Px/Fo extending Qo=Po/Fo,
@*'my'So = the embedding-ring of the versal base space,
@*'my'Ox = Px/Js extending So/Js. (default my="")

Matrices (in Px, exported):
@*Js = giving the versal base space (obstructions),
@*Fs = giving the versal family of Fo,
@*Rs = giving the lifting of Ro=syz(Fo).

If d is defined (!=0), it computes up to degree d.
@*If 'any' is defined and any[1] is no string, interactive version.
@*Otherwise 'any' gives predefined strings: "my","param","order","out"
("my" prefix-string, "param" is a letter (e.g. "A") for the name of
first parameter or (e.g. "A(") for index parameter variables, "order"
ordering string for ring extension), "out" name of output-file).

@item @strong{Note:}
printlevel < 0 no output at all,
@*printlevel >=0,1,2,.. informs you, what is going on;
@*this proc uses 'execute'.

@end table
@strong{Example:}
@smallexample
@c computed example versal d2t_singular/deform_lib.doc:70 
LIB "deform.lib";
int p          = printlevel;
printlevel     = 0;
ring r1        = 0,(x,y,z,u,v),ds;
matrix m[2][4] = x,y,z,u,y,z,u,v;
ideal Fo       = minor(m,2);
// cone over rational normal curve of degree 4
versal(Fo);
@expansion{} // ready: T_1 and T_2
@expansion{} // start computation in degree 2.
@expansion{} 
@expansion{} // Result belongs to ring Px.
@expansion{} // Equations of total space of miniversal deformation are 
@expansion{} // given by Fs, equations of miniversal base space by Js.
@expansion{} // Make Px the basering and list objects defined in Px by typing:
@expansion{}    setring Px; show(Px);
@expansion{}    listvar(matrix);
@expansion{} // NOTE: rings Qx, Px, So are alive!
@expansion{} // (use 'kill_rings("");' to remove)
setring Px;
// ___ Equations of miniversal base space ___:
Js;"";
@expansion{} Js[1,1]=BD
@expansion{} Js[1,2]=-AD+D2
@expansion{} Js[1,3]=-CD
@expansion{} 
// ___ Equations of miniversal total space ___:
Fs;"";
@expansion{} Fs[1,1]=-u2+zv+Bu+Dv
@expansion{} Fs[1,2]=-zu+yv-Au+Du
@expansion{} Fs[1,3]=-yu+xv+Cu+Dz
@expansion{} Fs[1,4]=z2-yu+Az+By
@expansion{} Fs[1,5]=yz-xu+Bx-Cz
@expansion{} Fs[1,6]=-y2+xz+Ax+Cy
@expansion{} 
@c end example versal d2t_singular/deform_lib.doc:70
@end smallexample
@c ---end content versal---

@c ------------------- mod_versal -------------
@node mod_versal, lift_kbase, versal, deform_lib
@subsubsection mod_versal
@cindex mod_versal
@c ---content mod_versal---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
mod_versal(Mo,I[,d,any]); I=ideal, M=module, d=int, any =list

@item @strong{Compute:}
miniversal deformation of coker(Mo) over Qo=Po/Io, Po=basering;

@item @strong{Create:}
Ringsr (exported):
@*'my'Px = extending the basering by new variables (deformation
parameters), the new variables precede the old ones,
@*the ordering is the product between "my_ord"
@*and "ord(Po)"
@*'my'Qx = Px/Io extending Qo (returns as basering),
@*'my'Ox = Px/(Io+Js) ring of the versal deformation of coker(Ms),
@*'my'So = embedding-ring of the versal base space. (default 'my'="")

Matrices (in Qx, exported):
@*Js = giving the versal base space (obstructions),
@*Ms = giving the versal family of Mo,
@*Ls = giving the lifting of syzygies Lo=syz(Mo),

If d is defined (!=0), it computes up to degree d.
@*If 'any' is defined and any[1] is no string, interactive version.
@*Otherwise 'any' gives predefined strings:"my","param","order","out"
("my" prefix-string, "param" is a letter (e.g. "A") for the name of
first parameter or (e.g. "A(") for index parameter variables, "ord"
ordering string for ring extension), "out" name of output-file).

@item @strong{Note:}
printlevel < 0 no output at all,
@*printlevel >=0,1,2,.. informs you, what is going on,
@*this proc uses 'execute'.

@end table
@strong{Example:}
@smallexample
@c computed example mod_versal d2t_singular/deform_lib.doc:132 
LIB "deform.lib";
int p = printlevel;
printlevel = 1;
ring  Ro = 0,(x,y),wp(3,4);
ideal Io = x4+y3;
matrix Mo[2][2] = x2,y,-y2,x2;
mod_versal(Mo,Io);
@expansion{} // vdim (Ext^2) = 4
@expansion{} // vdim (Ext^1) = 4
@expansion{} // ready: Ext1 and Ext2
@expansion{} // Ext1 is quasi-homogeneous represented: 3,6,1,4
@expansion{} // infinitesimal extension
@expansion{} x2-Ax-B,   y+Cx+D,
@expansion{} -y2+Cxy+Dy,x2+Ax+B
@expansion{} // start deg = 2
@expansion{} // start deg = 3
@expansion{} // start deg = 4
@expansion{} // start deg = 5
@expansion{} // finished in degree 
@expansion{} 5
@expansion{} // quasi-homogeneous weights of miniversal base
@expansion{} 3,6,1,4
@expansion{} // Result belongs to qring Qx
@expansion{} // Equations of total space of miniversal deformation are in Js
@expansion{} -2AB+A3+3CD2-BC3-3AC2D+A2C3,
@expansion{} -B2+A2B+D3-3BC2D+ABC3
@expansion{} // Matrix of the deformed module is Ms and lifted syzygies are Ls.
@expansion{} // Make Qx the basering and list objects defined in Qx by typing:
@expansion{}    listvar(ring);setring Qx; show(Qx);listvar(ideal);listvar(matrix);
@expansion{} // NOTE: rings Qx, Ox, So are still alive!
@expansion{} // (use: 'kill_rings();' to remove them)
printlevel = p;
if(system("with","Namespaces")) @{
if(nameof(Current) == "Ring" ) @{
kill Top::Px,Top::Qx,Top::So;
@} else @{
kill Ring::Px,Ring::So;
@}
@}
kill Px,Qx,So;
@c end example mod_versal d2t_singular/deform_lib.doc:132
@end smallexample
@c ---end content mod_versal---

@c ------------------- lift_kbase -------------
@node lift_kbase, lift_rel_kb, mod_versal, deform_lib
@subsubsection lift_kbase
@cindex lift_kbase
@c ---content lift_kbase---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
lift_kbase(N,M); N,M=poly/ideal/vector/module

@item @strong{Return:}
matrix A, coefficient matrix expressing N as linear combination of
k-basis of M. Let the k-basis have k elements and size(N)=c columns.
Then A satisfies:
@*matrix(reduce(N,std(M)),k,c) = matrix(kbase(std(M)))*A

@item @strong{Assume:}
dim(M)=0 and the monomial ordering is a well ordering or the last
block of the ordering is c or C

@end table
@strong{Example:}
@smallexample
@c computed example lift_kbase d2t_singular/deform_lib.doc:177 
LIB "deform.lib";
ring R=0,(x,y),ds;
module M=[x2,xy],[y2,xy],[0,xx],[0,yy];
module N=[x3+xy,x],[x,x+y2];
print(M);
@expansion{} x2,y2,0, 0,
@expansion{} xy,xy,x2,y2
module kb=kbase(std(M));
print(kb);
@expansion{} y2,xy,y,x,1,0,0,0,
@expansion{} 0, 0, 0,0,0,y,x,1 
print(N);
@expansion{} xy+x3,x,  
@expansion{} x,    x+y2
matrix A=lift_kbase(N,M);
print(A);
@expansion{} 0,0,
@expansion{} 1,0,
@expansion{} 0,0,
@expansion{} 0,1,
@expansion{} 0,0,
@expansion{} 0,0,
@expansion{} 1,1,
@expansion{} 0,0 
matrix(reduce(N,std(M)),nrows(kb),ncols(A)) - matrix(kbase(std(M)))*A;
@expansion{} _[1,1]=0
@expansion{} _[1,2]=0
@expansion{} _[2,1]=0
@expansion{} _[2,2]=0
@c end example lift_kbase d2t_singular/deform_lib.doc:177
@end smallexample
@c ---end content lift_kbase---

@c ------------------- lift_rel_kb -------------
@node lift_rel_kb, kill_rings, lift_kbase, deform_lib
@subsubsection lift_rel_kb
@cindex lift_rel_kb
@c ---content lift_rel_kb---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
lift_rel_kb(N,M[,kbaseM,p]);

@item @strong{Assume:}
[p a monomial ] or the product of all variables
@*N, M modules of same rank, M depending only on variables not in p
and vdim(M) is finite in this ring,
@*[ kbaseM the kbase of M in the subring given by variables not in p ] @*
warning: these assumptions are not checked by the procedure

@item @strong{Return:}
matrix A, whose j-th columns present the coeff's of N[j] in kbaseM,
i.e. kbaseM*A = reduce(N,std(M))

@end table
@strong{Example:}
@smallexample
@c computed example lift_rel_kb d2t_singular/deform_lib.doc:218 
LIB "deform.lib";
ring r=0,(A,B,x,y),dp;
module M      = [x2,xy],[xy,y3],[y2],[0,x];
module kbaseM = [1],[x],[xy],[y],[0,1],[0,y],[0,y2];
poly f=xy;
module N = [AB,BBy],[A3xy+x4,AB*(1+y2)];
matrix A = lift_rel_kb(N,M,kbaseM,f);
print(A);
@expansion{} AB,0, 
@expansion{} 0, 0, 
@expansion{} 0, A3,
@expansion{} 0, 0, 
@expansion{} 0, AB,
@expansion{} B2,0, 
@expansion{} 0, AB 
"TEST:";
@expansion{} TEST:
print(matrix(kbaseM)*A-matrix(reduce(N,std(M))));
@expansion{} 0,0,
@expansion{} 0,0 
@c end example lift_rel_kb d2t_singular/deform_lib.doc:218
@end smallexample
@c ---end content lift_rel_kb---

@c ------------------- kill_rings -------------
@node kill_rings,, lift_rel_kb, deform_lib
@subsubsection kill_rings
@cindex kill_rings
@c ---content kill_rings---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
kill_rings([string]);

@item @strong{Return:}
nothing, but kills exported rings generated by procedures
'versal' and 'mod_versal' with optional prefix 'string'

@end table
@c ---end content kill_rings---
