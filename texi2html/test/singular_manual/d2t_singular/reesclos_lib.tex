@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/reesclos_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/reesclos_lib.doc INSTEAD
@c library version: (1.50,2001/08/06)
@c library file: ../Singular/LIB/reesclos.lib
@cindex reesclos.lib
@cindex reesclos_lib
@table @asis
@item @strong{Library:}
reesclos.lib
@item @strong{Purpose:}
     procedures to compute the int. closure of an ideal
@item @strong{Author:}
Tobias Hirsch, email: hirsch@@math.tu-cottbus.de

@item @strong{Overview:}
A library to compute the integral closure of an ideal I in a polynomial ring
R=K[x(1),...,x(n)] using the Rees Algebra R[It] of I. It computes the integral
closure of R[It] (in the same manner as done in the library 'normal.lib'),
which is a graded subalgebra of R[t]. The degree-k-component is the integral
closure of the k-th power of I.
@*These procedures can also be used to compute the integral closure R^ of an
integral domain R=k[x(1),...,x(n)]/ker, ker a prime ideal, in its quotient
field K=Q(R), as an affine ring R^=k[T(1),...,T(s)]]/J and to get
representations of elements of R^ as fractions of elements of R.

@end table

@strong{Procedures:}
@menu
* ReesAlgebra:: computes the Rees Algebra of an ideal I
* normalI:: computes the integral closure of an ideal I using R[It]
* primeClosure:: computes the integral closure of the int. domain R
* closureRingtower:: defines the rings in the list L as global objects R(i)
* closureFrac:: computes fractions representing elements of R^=L[n]
@end menu
@c ---end content LibInfo---

@c ------------------- ReesAlgebra -------------
@node ReesAlgebra, normalI,, reesclos_lib
@subsubsection ReesAlgebra
@cindex ReesAlgebra
@c ---content ReesAlgebra---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Usage:}
ReesAlgebra (I); I = ideal

@item @strong{Return:}
The Rees algebra R[It] as an affine ring, where I is an ideal in R.
The procedure returns a list containing two rings:
@*[1]: a ring, say RR; in the ring an ideal ker such that R[It]=RR/ker

[2]: a ring, say Kxt; the basering with additional variable t
containing an ideal mapI that defines the map RR-->Kxt

@end table
@strong{Example:}
@smallexample
@c computed example ReesAlgebra d2t_singular/reesclos_lib.doc:59 
LIB "reesclos.lib";
ring R = 0,(x,y),dp;
ideal I = x2,xy4,y5;
list L = ReesAlgebra(I);
def Rees = L[1];       // defines the ring Rees, containing the ideal ker
setring Rees;          // passes to the ring Rees
Rees;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y U(1) U(2) U(3) 
@expansion{} //        block   2 : ordering C
ker;                   // R[It] is isomorphic to Rees/ker
@expansion{} ker[1]=y*U(2)-x*U(3)
@expansion{} ker[2]=y^3*U(1)*U(3)-U(2)^2
@expansion{} ker[3]=y^4*U(1)-x*U(2)
@expansion{} ker[4]=x*y^2*U(1)*U(3)^2-U(2)^3
@expansion{} ker[5]=x^2*y*U(1)*U(3)^3-U(2)^4
@expansion{} ker[6]=x^3*U(1)*U(3)^4-U(2)^5
@c end example ReesAlgebra d2t_singular/reesclos_lib.doc:59
@end smallexample
@c ---end content ReesAlgebra---

@c ------------------- normalI -------------
@node normalI, primeClosure, ReesAlgebra, reesclos_lib
@subsubsection normalI
@cindex normalI
@c ---content normalI---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Usage:}
normalI(I [,p[,c]]); I an ideal, p and c optional integers

@item @strong{Return:}
the integral closure of I,...,I^p. If p is not given, or p==0,
compute the closure of all powers up to the maximum degree in t
occurring in the generators of the closure of R[It] (so this is the
last one that is not just the sum/product of the above ones).
c is transferred to the procedure primeClosure and toggles its
behavior in computing the integral closure of R[It].
@*The result is a list containing the closure of the desired powers of
I as ideals of the basering.

@end table
@strong{Example:}
@smallexample
@c computed example normalI d2t_singular/reesclos_lib.doc:96 
LIB "reesclos.lib";
ring R=0,(x,y),dp;
ideal I = x2,xy4,y5;
list J = normalI(I);
I;
@expansion{} I[1]=x2
@expansion{} I[2]=xy4
@expansion{} I[3]=y5
J;                             // J[1] is the integral closure of I
@expansion{} [1]:
@expansion{}    _[1]=x2
@expansion{}    _[2]=y5
@expansion{}    _[3]=-xy3
@c end example normalI d2t_singular/reesclos_lib.doc:96
@end smallexample
@c ---end content normalI---

@c ------------------- primeClosure -------------
@node primeClosure, closureRingtower, normalI, reesclos_lib
@subsubsection primeClosure
@cindex primeClosure
@c ---content primeClosure---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Usage:}
primeClosure(L [,c]); L a list of a ring containing a prime ideal
ker, c an optional integer

@item @strong{Return:}
a list L consisting of rings L[1],...,L[n] such that
@*- L[1] is a copy of (not a reference to!) the input ring L[1]
- all rings L[i] contain ideals ker, L[2],...,L[n] contain ideals phi
such that
@*L[1]/ker --> ... --> L[n]/ker
@*are injections given by the corresponding ideals phi, and L[n]/ker
is the integral closure of L[1]/ker in its quotient field.
- all rings L[i] contain a polynomial nzd such that elements of
L[i]/ker are quotients of elements of L[i-1]/ker with denominator
nzd via the injection phi.

@item @strong{Note:}
- L is constructed by recursive calls of primeClosure itself.
- c determines the choice of nzd:
@*- c not given or equal to 0: first generator of the ideal SL,
the singular locus of Spec(L[i]/ker)
@*- c<>0: the generator of SL with least number of monomials.

@end table
@strong{Example:}
@smallexample
@c computed example primeClosure d2t_singular/reesclos_lib.doc:141 
LIB "reesclos.lib";
ring R=0,(x,y),dp;
ideal I=x4,y4;
def K=ReesAlgebra(I)[1];        // K contains ker such that K/ker=R[It]
list L=primeClosure(K);
def R(1)=L[1];                  // L[4] contains ker, L[4]/ker is the
def R(4)=L[4];                  // integral closure of L[1]/ker
setring R(1);
R(1);
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y U(1) U(2) 
@expansion{} //        block   2 : ordering C
ker;
@expansion{} ker[1]=y^4*U(1)-x^4*U(2)
setring R(4);
R(4);
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 7
@expansion{} //        block   1 : ordering a
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
@expansion{} //                  : weights     1    1    1    1    1    1    1 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
@expansion{} //        block   3 : ordering C
ker;
@expansion{} ker[1]=T(2)*T(5)-T(1)*T(7)
@expansion{} ker[2]=T(1)*T(5)-T(2)*T(6)
@expansion{} ker[3]=T(5)*T(6)-T(3)*T(7)
@expansion{} ker[4]=T(4)*T(6)-T(5)*T(7)
@expansion{} ker[5]=T(5)^2-T(6)*T(7)
@expansion{} ker[6]=T(4)*T(5)-T(7)^2
@expansion{} ker[7]=T(3)*T(5)-T(6)^2
@expansion{} ker[8]=T(2)^2*T(6)-T(1)^2*T(7)
@expansion{} ker[9]=T(3)*T(4)-T(6)*T(7)
@expansion{} ker[10]=T(1)*T(4)-T(2)*T(7)
@expansion{} ker[11]=T(2)*T(3)-T(1)*T(6)
@expansion{} ker[12]=T(2)^2*T(6)^2-T(1)^2*T(6)*T(7)
@c end example primeClosure d2t_singular/reesclos_lib.doc:141
@end smallexample
@c ---end content primeClosure---

@c ------------------- closureRingtower -------------
@node closureRingtower, closureFrac, primeClosure, reesclos_lib
@subsubsection closureRingtower
@cindex closureRingtower
@c ---content closureRingtower---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Usage:}
closureRingtower(list L); L a list of rings

@item @strong{Create:}
rings R(1),...,R(n) such that R(i)=L[i] for all i

@end table
@strong{Example:}
@smallexample
@c computed example closureRingtower d2t_singular/reesclos_lib.doc:176 
LIB "reesclos.lib";
ring R=0,(x,y),dp;
ideal I=x4,y4;
list L=primeClosure(ReesAlgebra(I)[1]);
closureRingtower(L);
R(1);
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y U(1) U(2) 
@expansion{} //        block   2 : ordering C
R(4);
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 7
@expansion{} //        block   1 : ordering a
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
@expansion{} //                  : weights     1    1    1    1    1    1    1 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
@expansion{} //        block   3 : ordering C
@c end example closureRingtower d2t_singular/reesclos_lib.doc:176
@end smallexample
@c ---end content closureRingtower---

@c ------------------- closureFrac -------------
@node closureFrac,, closureRingtower, reesclos_lib
@subsubsection closureFrac
@cindex closureFrac
@c ---content closureFrac---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Create:}
a list fraction of two elements of L[1], such that
@*f=fraction[1]/fraction[2] via the injections phi L[i]-->L[i+1].

@end table
@strong{Example:}
@smallexample
@c computed example closureFrac d2t_singular/reesclos_lib.doc:203 
LIB "reesclos.lib";
ring R=0,(x,y),dp;
ideal ker=x2+y2;
export R;
@expansion{} // ** `R` is already global
list L=primeClosure(R);          // We normalize R/ker
closureRingtower(L);             // Now R/ker=R(1) with normalization R(2)
setring R(2);
kill(R);
phi;                             // The map R(1)-->R(2)
@expansion{} phi[1]=T(1)*T(2)
@expansion{} phi[2]=T(1)
poly f=T(1)*T(2);                // We will get a representation of f
export R(2);
@expansion{} // ** `R(2)` is already global
closureFrac(L);
setring R(1);
kill (R(2));
fraction;                        // f=fraction[1]/fraction[2] via phi
@expansion{} [1]:
@expansion{}    xy
@expansion{} [2]:
@expansion{}    y
@c end example closureFrac d2t_singular/reesclos_lib.doc:203
@end smallexample
@c ---end content closureFrac---
