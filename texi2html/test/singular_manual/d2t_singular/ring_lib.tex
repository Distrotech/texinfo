@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/ring_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/ring_lib.doc INSTEAD
@c library version: (1.17.2.1,2002/02/20)
@c library file: ../Singular/LIB/ring.lib
@cindex ring.lib
@cindex ring_lib
@table @asis
@item @strong{Library:}
ring.lib
@item @strong{Purpose:}
      Manipulating Rings and Maps

@end table

@strong{Procedures:}
@menu
* changechar:: make a copy R of basering [ring r] with new char c
* changeord:: make a copy R of basering [ring r] with new ord o
* changevar:: make a copy R of basering [ring r] with new vars v
* defring:: define a ring R in specified char c, n vars v, ord o
* defrings:: define ring Sn in n vars, char 32003 [p], ord ds
* defringp:: define ring Pn in n vars, char 32003 [p], ord dp
* extendring:: extend given ring by n vars v, ord o and name it R
* fetchall:: fetch all objects of ring R to basering
* imapall:: imap all objects of ring R to basering
* mapall:: map all objects of ring R via ideal i to basering
* ord_test:: test whether ordering of R is global, local or mixed
* ringtensor:: create ring R, tensor product of rings s,t,...
* ringweights:: intvec of weights of ring variables of ring r
@end menu
@c ---end content LibInfo---

@c ------------------- changechar -------------
@node changechar, changeord,, ring_lib
@subsubsection changechar
@cindex changechar
@c ---content changechar---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
changechar(newr,c[,r]); newr,c=strings, r=ring

@item @strong{Create:}
create a new ring with name `newr` and make it the basering if r is
an existing ring [default: r=basering].
@*The new ring differs from the old ring only in the characteristic.
If, say, (newr,c) = ("R","0,A") and the ring r exists, the new
basering will have name R, characteristic 0 and one parameter A.

@item @strong{Return:}
No return value

@item @strong{Note:}
Works for qrings if map from old_char to new_char is implemented
This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@.

@end table
@strong{Example:}
@smallexample
@c computed example changechar d2t_singular/ring_lib.doc:62 
LIB "ring.lib";
ring r=0,(x,y,u,v),(dp(2),ds);
changechar("R","2,A"); R;"";
@expansion{} // basering is now R
@expansion{} //   characteristic : 2
@expansion{} //   1 parameter    : A 
@expansion{} //   minpoly        : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering ds
@expansion{} //                  : names    u v 
@expansion{} //        block   3 : ordering C
@expansion{} 
changechar("R1","32003",R); R1;
@expansion{} // basering is now R1
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering ds
@expansion{} //                  : names    u v 
@expansion{} //        block   3 : ordering C
kill R,R1;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R,Top::R1;
@} else @{
kill Ring::R,Ring::R1;
@}
@}
@c end example changechar d2t_singular/ring_lib.doc:62
@end smallexample
@c ---end content changechar---

@c ------------------- changeord -------------
@node changeord, changevar, changechar, ring_lib
@subsubsection changeord
@cindex changeord
@c ---content changeord---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
changeord(newr,o[,r]); newr,o=strings, r=ring/qring

@item @strong{Create:}
create a new ring with name `newr` and make it the basering if r is
an existing ring/qring [default: r=basering].
@*The new ring differs from the old ring only in the ordering. If, say,
(newr,o) = ("R","wp(2,3),dp") and the ring r exists and has >=3
variables, the new basering will have name R and ordering wp(2,3),dp.

@item @strong{Return:}
No return value

@item @strong{Note:}
This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@.

@end table
@strong{Example:}
@smallexample
@c computed example changeord d2t_singular/ring_lib.doc:108 
LIB "ring.lib";
ring r=0,(x,y,u,v),(dp(2),ds);
changeord("R","wp(2,3),dp"); R; "";
@expansion{} // basering is now R
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering wp
@expansion{} //                  : names    x y 
@expansion{} //                  : weights  2 3 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    u v 
@expansion{} //        block   3 : ordering C
@expansion{} 
ideal i = x^2,y^2-u^3,v;
qring Q = std(i);
changeord("Q'","lp",Q); Q';
@expansion{} // basering is now Q'
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering lp
@expansion{} //                  : names    x y u v 
@expansion{} //        block   2 : ordering C
@expansion{} // quotient ring from ideal
@expansion{} _[1]=v
@expansion{} _[2]=x2
@expansion{} _[3]=y2-u3
kill R,Q,Q';
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R,Top::Q';
@} else @{
kill Ring::R,Ring::Q';
@}
@}
@c end example changeord d2t_singular/ring_lib.doc:108
@end smallexample
@c ---end content changeord---

@c ------------------- changevar -------------
@node changevar, defring, changeord, ring_lib
@subsubsection changevar
@cindex changevar
@c ---content changevar---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
changevar(newr,vars[,r]); newr,vars=strings, r=ring/qring

@item @strong{Create:}
creates a new ring with name `newr` and makes it the basering if r
is an existing ring/qring [default: r=basering].
@*The new ring differs from the old ring only in the variables. If,
say, (newr,vars) = ("R","t()") and the ring r exists and has n
variables, the new basering will have name R and variables
t(1),...,t(n).
@*If vars = "a,b,c,d", the new ring will have the variables a,b,c,d.

@item @strong{Return:}
No return value

@item @strong{Note:}
This procedure is useful in connection with the procedure ringtensor,
when a conflict between variable names must be avoided.
This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@.

@end table
@strong{Example:}
@smallexample
@c computed example changevar d2t_singular/ring_lib.doc:160 
LIB "ring.lib";
ring r=0,(x,y,u,v),(dp(2),ds);
ideal i = x^2,y^2-u^3,v;
qring Q = std(i);
setring(r);
changevar("R","A()"); R; "";
@expansion{} // basering is now R
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    A(1) A(2) 
@expansion{} //        block   2 : ordering ds
@expansion{} //                  : names    A(3) A(4) 
@expansion{} //        block   3 : ordering C
@expansion{} 
changevar("Q'","a,b,c,d",Q); Q';
@expansion{} // basering is now Q'
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    a b 
@expansion{} //        block   2 : ordering ds
@expansion{} //                  : names    c d 
@expansion{} //        block   3 : ordering C
@expansion{} // quotient ring from ideal
@expansion{} _[1]=d
@expansion{} _[2]=a2
@expansion{} _[3]=b2-c3
kill R,Q,Q';
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R,Top::Q';
@} else @{
kill Ring::R,Ring::Q';
@}
@}
@c end example changevar d2t_singular/ring_lib.doc:160
@end smallexample
@c ---end content changevar---

@c ------------------- defring -------------
@node defring, defrings, changevar, ring_lib
@subsubsection defring
@cindex defring
@c ---content defring---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
defring(s1,s2,n,s3,s4); s1..s4=strings, n=integer

@item @strong{Create:}
Define a ring with name 's1', characteristic 's2', ordering 's4' and
n variables with names derived from s3 and make it the basering.
If s3 is a single letter, say s3="a", and if n<=26 then a and the
following n-1 letters from the alphabet (cyclic order) are taken as
variables. If n>26 or if s3 is a single letter followed by (, say
s3="T(", the variables are T(1),...,T(n).

@item @strong{Return:}
No return value

@item @strong{Note:}
This proc is useful for defining a ring in a procedure.
This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@.

@end table
@strong{Example:}
@smallexample
@c computed example defring d2t_singular/ring_lib.doc:211 
LIB "ring.lib";
defring("r","0",5,"u","ls"); r; "";
@expansion{} // basering is now: r
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering ls
@expansion{} //                  : names    u v w x y 
@expansion{} //        block   2 : ordering C
@expansion{} 
defring("R","2,A",10,"x(","dp(3),ws(1,2,3),ds"); R;
@expansion{} // basering is now: R
@expansion{} //   characteristic : 2
@expansion{} //   1 parameter    : A 
@expansion{} //   minpoly        : 0
@expansion{} //   number of vars : 10
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x(1) x(2) x(3) 
@expansion{} //        block   2 : ordering ws
@expansion{} //                  : names    x(4) x(5) x(6) 
@expansion{} //                  : weights     1    2    3 
@expansion{} //        block   3 : ordering ds
@expansion{} //                  : names    x(7) x(8) x(9) x(10) 
@expansion{} //        block   4 : ordering C
kill r,R;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::r,Top::R;
@} else @{
kill Ring::r,Ring::R;
@}
@}
@c end example defring d2t_singular/ring_lib.doc:211
@end smallexample
@c ---end content defring---

@c ------------------- defrings -------------
@node defrings, defringp, defring, ring_lib
@subsubsection defrings
@cindex defrings
@c ---content defrings---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
defrings(n,[p]); n,p integers

@item @strong{Create:}
Defines a ring with name Sn, characteristic p, ordering ds and n
variables x,y,z,a,b,...if n<=26 (resp. x(1..n) if n>26) and makes it
the basering (default: p=32003)

@item @strong{Return:}
No return value

@end table
@strong{Example:}
@smallexample
@c computed example defrings d2t_singular/ring_lib.doc:249 
LIB "ring.lib";
defrings(5,0); S5; "";
@expansion{} // basering is now: ring S5=0,(x,y,z,a,b),ds;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering ds
@expansion{} //                  : names    x y z a b 
@expansion{} //        block   2 : ordering C
@expansion{} 
defrings(30); S30;
@expansion{} // basering is now: ring S30=32003,x(1..30),ds;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 30
@expansion{} //        block   1 : ordering ds
@expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(\
   9) x(10) x(11) x(12) x(13) x(14) x(15) x(16) x(17) x(18) x(19) x(20) x(21\
   ) x(22) x(23) x(24) x(25) x(26) x(27) x(28) x(29) x(30) 
@expansion{} //        block   2 : ordering C
kill S5, S30;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::S5,Top::S30;
@} else @{
kill Ring::S5,Ring::S30;
@}
@}
@c end example defrings d2t_singular/ring_lib.doc:249
@end smallexample
@c ---end content defrings---

@c ------------------- defringp -------------
@node defringp, extendring, defrings, ring_lib
@subsubsection defringp
@cindex defringp
@c ---content defringp---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
defringp(n,[p]); n,p=integers

@item @strong{Create:}
defines a ring with name Pn, characteristic p, ordering dp and n
variables x,y,z,a,b,...if n<=26 (resp. x(1..n) if n>26) and makes it
the basering (default: p=32003)

@item @strong{Return:}
No return value

@end table
@strong{Example:}
@smallexample
@c computed example defringp d2t_singular/ring_lib.doc:287 
LIB "ring.lib";
defringp(5,0); P5; "";
@expansion{} // basering is now: ring P5=0,(x,y,z,a,b),dp;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z a b 
@expansion{} //        block   2 : ordering C
@expansion{} 
defringp(30); P30;
@expansion{} // basering is now: ring P30=32003,x(1..30),dp;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 30
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(\
   9) x(10) x(11) x(12) x(13) x(14) x(15) x(16) x(17) x(18) x(19) x(20) x(21\
   ) x(22) x(23) x(24) x(25) x(26) x(27) x(28) x(29) x(30) 
@expansion{} //        block   2 : ordering C
kill P5, P30;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::P5,Top::P30;
@} else @{
kill Ring::P5,Ring::P30;
@}
@}
@c end example defringp d2t_singular/ring_lib.doc:287
@end smallexample
@c ---end content defringp---

@c ------------------- extendring -------------
@node extendring, fetchall, defringp, ring_lib
@subsubsection extendring
@cindex extendring
@c ---content extendring---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
extendring(na,n,va,o[iv,i,r]); na,va,o=strings,
@*n,i=integers, r=ring, iv=intvec of positive integers or iv=0

@item @strong{Create:}
Define a ring with name `na` which extends the ring r by adding n new
variables in front of [after, if i!=0] the old variables and make it
the basering [default: (i,r)=(0,basering)].
@* -- The characteristic is the characteristic of r.
@* -- The new vars are derived from va. If va is a single letter, say
va="T", and if n<=26 then T and the following n-1 letters from
T..Z..T (resp. T(1..n) if n>26) are taken as additional variables.
If va is a single letter followed by (, say va="x(", the new
variables are x(1),...,x(n).
@* -- The ordering is the product ordering between the ordering of r and
an ordering derived from `o` [and iv].
@* - If o contains a 'c' or a 'C' in front resp. at the end this is
taken for the whole ordering in front resp. at the end. If o does
not contain a 'c' or a 'C' the same rule applies to ordstr(r).
@* - If no intvec iv is given, or if iv=0, o may be any allowed ordstr,
like "ds" or "dp(2),wp(1,2,3),Ds(2)" or "ds(a),dp(b),ls" if
a and b are globally (!) defined integers and if a+b+1<=n.
If, however, a and b are local to a proc calling extendring, the
intvec iv must be used to let extendring know the values of a and b
@* - If an intvec iv !=0 is given, iv[1],iv[2],... is taken for the
1st, 2nd,... block of o, if o contains no substring "w" or "W"
i.e. no weighted ordering (in the above case o="ds,dp,ls"
and iv=a,b).
@*If o contains a weighted ordering (only one (!) weighted block is
allowed) iv[1] is taken as size for the weight-vector, the next
iv[1] values of iv are taken as weights and the remaining values of
iv as block-size for the remaining non-weighted blocks.
e.g. o="dp,ws,Dp,ds", iv=3,2,3,4,2,5 creates the ordering
dp(2),ws(2,3,4),Dp(5),ds

@item @strong{Return:}
No return value

@item @strong{Note:}
This proc is useful for adding deformation parameters.
@*This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@ (see the file HelpForProc)

@end table
@strong{Example:}
@smallexample
@c computed example extendring d2t_singular/ring_lib.doc:358 
LIB "ring.lib";
ring r=0,(x,y,z),ds;
show(r);"";
@expansion{} // ring: (0),(x,y,z),(ds(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} 
//blocksize is derived from no of vars:
int t=5;
extendring("R1",t,"a","dp");         //t global: "dp" -> "dp(5)"
@expansion{} // basering is now R1
show(R1); "";
@expansion{} // ring: (0),(a,b,c,d,e,x,y,z),(dp(5),ds(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} 
extendring("R2",4,"T(","c,dp",1,r);    //"dp" -> "c,..,dp(4)"
@expansion{} // basering is now R2
show(R2);"";
@expansion{} // ring: (0),(x,y,z,T(1),T(2),T(3),T(4)),(c,ds(3),dp(4));
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} 
//no intvec given, blocksize given: given blocksize is used:
extendring("R3",4,"T(","dp(2)",0,r);   // "dp(2)" -> "dp(2)"
@expansion{} // basering is now R3
show(R3);"";
@expansion{} // ring: (0),(T(1),T(2),T(3),T(4),x,y,z),(dp(2),ds(5),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} 
//intvec given: weights and blocksize is derived from given intvec
//(no specification of a blocksize in the given ordstr is allowed!)
//if intvec does not cover all given blocks, the last block is used
//for the remaining variables, if intvec has too many components,
//the last ones are ignored
intvec v=3,2,3,4,1,3;
extendring("R4",10,"A","ds,ws,Dp,dp",v,0,r);
@expansion{} // basering is now R4
//v covers 3 blocks: v[1] (=3) : no of components of ws
//next v[1] values (=v[2..4]) give weights
//remaining components of v are used for the remaining blocks
show(R4);
@expansion{} // ring: (0),(A,B,C,D,E,F,G,H,I,J,x,y,z),(ds(1),ws(2,3,4),Dp(3),dp(3),ds(\
   3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
kill r,R1,R2,R3,R4;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R1,Top::R2,Top::R3,Top::R4;
@} else @{
kill Ring::R1,Ring::R2,Ring::R3,Ring::R4;
@}
@}
@c end example extendring d2t_singular/ring_lib.doc:358
@end smallexample
@c ---end content extendring---

@c ------------------- fetchall -------------
@node fetchall, imapall, extendring, ring_lib
@subsubsection fetchall
@cindex fetchall
@c ---content fetchall---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
fetchall(R[,s]); R=ring/qring, s=string

@item @strong{Create:}
fetch all objects of ring R (of type poly/ideal/vector/module/number/
matrix) into the basering.
@*If no 3rd argument is present, the names are the same as in R. If,
say, f is a poly in R and the 3rd argument is the string "R", then f
is mapped to f_R etc.

@item @strong{Return:}
no return value

@item @strong{Note:}
As fetch, this procedure maps the 1st, 2nd, ... variable of R to the
1st, 2nd, ... variable of the basering.
@*The 3rd argument is useful in order to avoid conflicts of names, the
empty string is allowed

@item @strong{Caution:}
fetchall does not work inside a procedure.
@*It does not work if R contains a map.

@end table
@strong{Example:}
@smallexample
@c computed example fetchall d2t_singular/ring_lib.doc:428 
LIB "ring.lib";
// The example is not shown since fetchall does not work in a procedure;
// (and hence not in the example procedure). Try the following commands:
//   ring R=0,(x,y,z),dp;
//   ideal j=x,y2,z2;
//   matrix M[2][3]=1,2,3,x,y,z;
//   j; print(M);
//   ring S=0,(a,b,c),ds;
//   fetchall(R);       //map from R to S: x->a, y->b, z->c;
//   names(S);
//   j; print(M);
//   fetchall(S,"1");   //identity map of S: copy objects, change names
//   names(S);
//   kill R,S;
@c end example fetchall d2t_singular/ring_lib.doc:428
@end smallexample
@c ---end content fetchall---

@c ------------------- imapall -------------
@node imapall, mapall, fetchall, ring_lib
@subsubsection imapall
@cindex imapall
@c ---content imapall---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
imapall(R[,s]); R=ring/qring, s=string

@item @strong{Create:}
map all objects of ring R (of type poly/ideal/vector/module/number/
matrix) into the basering, by applying imap to all objects of R.
If no 3rd argument is present, the names are the same as in R. If,
say, f is a poly in R and the 3rd argument is the string "R", then f
is mapped to f_R etc.

@item @strong{Return:}
no return value

@item @strong{Note:}
As imap, this procedure maps the variables of R to the variables with
the same name in the basering, the other variables are mapped to 0.
The 3rd argument is useful in order to avoid conflicts of names, the
empty string is allowed

@item @strong{Caution:}
imapall does not work inside a procedure
@*It does not work if R contains a map

@end table
@strong{Example:}
@smallexample
@c computed example imapall d2t_singular/ring_lib.doc:481 
LIB "ring.lib";
// The example is not shown since imapall does not work in a procedure
// (and hence not in the example procedure). Try the following commands:
//   ring R=0,(x,y,z,u),dp;
//   ideal j=x,y,z,u2+ux+z;
//   matrix M[2][3]=1,2,3,x,y,uz;
//   j; print(M);
//   ring S=0,(a,b,c,x,z,y),ds;
//   imapall(R);         //map from R to S: x->x, y->y, z->z, u->0
//   names(S);
//   j; print(M);
//   imapall(S,"1");     //identity map of S: copy objects, change names
//   names(S);
//   kill R,S;
@c end example imapall d2t_singular/ring_lib.doc:481
@end smallexample
@c ---end content imapall---

@c ------------------- mapall -------------
@node mapall, ord_test, imapall, ring_lib
@subsubsection mapall
@cindex mapall
@c ---content mapall---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
mapall(R,i[,s]); R=ring/qring, i=ideal of basering, s=string

@item @strong{Create:}
map all objects of ring R (of type poly/ideal/vector/module/number/
matrix, map) into the basering, by mapping the j-th variable of R to
the j-th generator of the ideal i. If no 3rd argument is present, the
names are the same as in R. If, say, f is a poly in R and the 3rd
argument is the string "R", then f is mapped to f_R etc.

@item @strong{Return:}
no return value.

@item @strong{Note:}
This procedure has the same effect as defining a map, say psi, by
map psi=R,i; and then applying psi to all objects of R. In particular,
maps from R to some ring S are composed with psi, creating thus a map
from the basering to S.
@*mapall may be combined with copyring to change vars for all objects.
The 3rd argument is useful in order to avoid conflicts of names, the
empty string is allowed.

@item @strong{Caution:}
mapall does not work inside a procedure.

@end table
@strong{Example:}
@smallexample
@c computed example mapall d2t_singular/ring_lib.doc:536 
LIB "ring.lib";
// The example is not shown since mapall does not work in a procedure
// (and hence not in the example procedure). Try the following commands:
//   ring R=0,(x,y,z),dp;
//   ideal j=x,y,z;
//   matrix M[2][3]=1,2,3,x,y,z;
//   map phi=R,x2,y2,z2;
//   ring S=0,(a,b,c),ds;
//   ideal i=c,a,b;
//   mapall(R,i);         //map from R to S: x->c, y->a, z->b
//   names(S);
//   j; print(M); phi;    //phi maps R to S: x->c2, y->a2, z->b2
//   ideal i1=a2,a+b,1;
//   mapall(R,i1,"");   //map from R to S: x->a2, y->a+b, z->1
//   names(S);
//   j_; print(M_); phi_;
//   changevar("T","x()",R);  //change vars in R and call result T
//   mapall(R,maxideal(1));       //identity map from R to T
//   names(T);
//   j; print(M); phi;
//   kill R,S,T;
@c end example mapall d2t_singular/ring_lib.doc:536
@end smallexample
@c ---end content mapall---

@c ------------------- ord_test -------------
@node ord_test, ringtensor, mapall, ring_lib
@subsubsection ord_test
@cindex ord_test
@c ---content ord_test---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
ord_test(r); r ring

@item @strong{Return:}
int 1 (resp. -1, resp. 0) if ordering of r is global (resp. local,
resp. mixed)

@end table
@strong{Example:}
@smallexample
@c computed example ord_test d2t_singular/ring_lib.doc:580 
LIB "ring.lib";
ring R = 0,(x,y),dp;
ring S = 0,(u,v),ls;
ord_test(R);
@expansion{} 1
ord_test(S);
@expansion{} -1
ord_test(R+S);
@expansion{} 0
@c end example ord_test d2t_singular/ring_lib.doc:580
@end smallexample
@c ---end content ord_test---

@c ------------------- ringtensor -------------
@node ringtensor, ringweights, ord_test, ring_lib
@subsubsection ringtensor
@cindex ringtensor
@c ---content ringtensor---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
ringtensor(s,r1,r2,...); s=string, r1,r2,...=rings

@item @strong{Create:}
A new base ring with name `s` if r1,r2,... are existing rings.
If, say, s = "R" and the rings r1,r2,... exist, the new ring will
have name R, variables from all rings r1,r2,... and as monomial
ordering the block (product) ordering of r1,r2,... . Hence, R
is the tensor product of the rings r1,r2,... with ordering matrix
equal to the direct sum of the ordering matrices of r1,r2,...

@item @strong{Return:}
no return value

@item @strong{Note:}
The characteristic of the new ring will be that of r1. The names of
variables in the rings r1,r2,... should differ (if a name, say x,
occurs in r1 and r2, then, in the new ring r, x always refers to the
variable with name x in r1, there is no access to x in r2).
The procedure works also for quotient rings ri, if the characteristic
of ri is compatible with the characteristic of r1 (i.e. if imap from
ri to r1 is implemented)
@*This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@ (see the file HelpForProc)

@end table
@strong{Example:}
@smallexample
@c computed example ringtensor d2t_singular/ring_lib.doc:628 
LIB "ring.lib";
ring r=32003,(x,y,u,v),dp;
ring s=0,(a,b,c),wp(1,2,3);
ring t=0,x(1..5),(c,ls);
ringtensor("R",r,s,t);
@expansion{} // basering is now R
type R;
@expansion{} // R                    [0]  *ring
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 12
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y u v 
@expansion{} //        block   2 : ordering wp
@expansion{} //                  : names    a b c 
@expansion{} //                  : weights  1 2 3 
@expansion{} //        block   3 : ordering ls
@expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) 
@expansion{} //        block   4 : ordering C
setring s;
ideal i = a2+b3+c5;
changevar("S","x,y,z");       //change vars of sand make S the basering
@expansion{} // basering is now S
qring qS =std(fetch(s,i));    //create qring of S mod i (mapped to S)
changevar("T","d,e,f,g,h",t); //change vars of t and make T the basering
@expansion{} // basering is now T
qring qT=std(d2+e2-f3);       //create qring of T mod d2+e2-f3
ringtensor("Q",s,qS,t,qT);
@expansion{} // basering is now Q
type Q;
@expansion{} // Q                    [0]  *qring
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 16
@expansion{} //        block   1 : ordering wp
@expansion{} //                  : names    a b c 
@expansion{} //                  : weights  1 2 3 
@expansion{} //        block   2 : ordering wp
@expansion{} //                  : names    x y z 
@expansion{} //                  : weights  1 2 3 
@expansion{} //        block   3 : ordering ls
@expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) 
@expansion{} //        block   4 : ordering ls
@expansion{} //                  : names    d e f g h 
@expansion{} //        block   5 : ordering C
@expansion{} // quotient ring from ideal
@expansion{} _[1]=f3-e2-d2
@expansion{} _[2]=z5+y3+x2
kill R,Q,S,T;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R,Top::Q,Top::S,Top::T;
@} else @{
kill Ring::R,Ring::Q,Ring::S,Ring::T;
@}
@}
@c end example ringtensor d2t_singular/ring_lib.doc:628
@end smallexample
@c ---end content ringtensor---

@c ------------------- ringweights -------------
@node ringweights,, ringtensor, ring_lib
@subsubsection ringweights
@cindex ringweights
@c ---content ringweights---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
ringweights(P); P=name of an existing ring (true name, not a string)

@item @strong{Return:}
intvec consisting of the weights of the variables of P, as they
appear when typing P;.

@item @strong{Note:}
This is useful when enlarging P but keeping the weights of the old
variables.

@end table
@strong{Example:}
@smallexample
@c computed example ringweights d2t_singular/ring_lib.doc:677 
LIB "ring.lib";
ring r0 = 0,(x,y,z),dp;
ringweights(r0);
@expansion{} 1,1,1
ring r1 = 0,x(1..5),(ds(3),wp(2,3));
ringweights(r1);"";
@expansion{} 1,1,1,2,3
@expansion{} 
// an example for enlarging the ring, keeping the first weights:
intvec v = ringweights(r1),6,2,3,4,5;
ring R = 0,x(1..10),(a(v),dp);
ordstr(R);
@expansion{} a(1,1,1,2,3,6,2,3,4,5),dp(10),C
@c end example ringweights d2t_singular/ring_lib.doc:677
@end smallexample
@c ---end content ringweights---
