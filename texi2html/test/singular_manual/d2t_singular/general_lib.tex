@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/general_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/general_lib.doc INSTEAD
@c library version: (1.38.2.9,2003/04/04)
@c library file: ../Singular/LIB/general.lib
@cindex general.lib
@cindex general_lib
@table @asis
@item @strong{Library:}
general.lib
@item @strong{Purpose:}
   Elementary Computations of General Type

@end table

@strong{Procedures:}
@menu
* A_Z:: string a,b,... of n comma separated letters
* ASCII:: string of printable ASCII characters (number n to m)
* absValue:: absolute value of c
* binomial:: n choose m (type int), [type string/type number]
* deleteSublist:: delete entries given by iv from list l
* factorial:: n factorial (=n!) (type int), [type string/number]
* fibonacci:: nth Fibonacci number [char p]
* kmemory:: active [allocated] memory in kilobyte
* killall:: kill all user-defined variables
* number_e:: compute exp(1) up to n decimal digits
* number_pi:: compute pi (area of unit circle) up to n digits
* primes:: intvec of primes p, n<=p<=m
* product:: multiply components of vector/ideal/...[indices v]
* sort:: sort generators according to monomial ordering
* sum:: add components of vector/ideal/...[with indices v]
* watchdog:: only wait for result of command cmd for i seconds
* which:: search for command and return absolute path, if found
* primecoeffs:: primefactors <= min(p,32003) of coeffs of J
* primefactors:: primefactors <= min(p,32003) of n
* timeStd:: std(i) if computation finished after d seconds else i
* timeFactorize:: works as timeStd with factorization
* factorH:: factorizes with good choice of principal variable
@end menu
@c ---end content LibInfo---

@c ------------------- A_Z -------------
@node A_Z, ASCII,, general_lib
@subsubsection A_Z
@cindex A_Z
@c ---content A_Z---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
A_Z("a",n); a any letter, n integer (-26<= n <=26, !=0)

@item @strong{Return:}
string of n small (if a is small) or capital (if a is capital)
letters, comma separated, beginning with a, in alphabetical
order (or revers alphabetical order if n<0)

@end table
@strong{Example:}
@smallexample
@c computed example A_Z d2t_singular/general_lib.doc:60 
LIB "general.lib";
A_Z("c",5);
@expansion{} c,d,e,f,g
A_Z("Z",-5);
@expansion{} Z,Y,X,W,V
string sR = "ring R = (0,"+A_Z("A",6)+"),("+A_Z("a",10)+"),dp;";
sR;
@expansion{} ring R = (0,A,B,C,D,E,F),(a,b,c,d,e,f,g,h,i,j),dp;
execute(sR);
R;
@expansion{} //   characteristic : 0
@expansion{} //   6 parameter    : A B C D E F 
@expansion{} //   minpoly        : 0
@expansion{} //   number of vars : 10
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    a b c d e f g h i j 
@expansion{} //        block   2 : ordering C
@c end example A_Z d2t_singular/general_lib.doc:60
@end smallexample
@c ---end content A_Z---

@c ------------------- ASCII -------------
@node ASCII, absValue, A_Z, general_lib
@subsubsection ASCII
@cindex ASCII
@c ---content ASCII---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
ASCII([n,m]); n,m= integers (32 <= n <= m <= 126)

@item @strong{Return:}
string of printable ASCII characters (no native language support)
ASCII(): string of all ASCII characters with its numbers,
ASCII(n): n-th ASCII character
@*ASCII(n,m): n-th up to m-th ASCII character (inclusive)

@end table
@strong{Example:}
@smallexample
@c computed example ASCII d2t_singular/general_lib.doc:92 
LIB "general.lib";
ASCII();"";
@expansion{}      !    "    #    $    %    &    '    (    )    *    +    ,    -    .
@expansion{} 32   33   34   35   36   37   38   39   40   41   42   43   44   45   46
@expansion{} /    0    1    2    3    4    5    6    7    8    9    :    ;    <    =
@expansion{} 47   48   49   50   51   52   53   54   55   56   57   58   59   60   61
@expansion{} >    ?    @@    A    B    C    D    E    F    G    H    I    J    K    L
@expansion{} 62   63   64   65   66   67   68   69   70   71   72   73   74   75   76
@expansion{} M    N    O    P    Q    R    S    T    U    V    W    X    Y    Z    [
@expansion{} 77   78   79   80   81   82   83   84   85   86   87   88   89   90   91
@expansion{} \    ]    ^    _    `    a    b    c    d    e    f    g    h    i    j
@expansion{} 92   93   94   95   96   97   98   99  100  101  102  103  104  105  10
@expansion{} k    l    m    n    o    p    q    r    s    t    u    v    w    x    y
@expansion{} 107  108  109  110  111  112  113  114  115  116  117  118  119  120  121
@expansion{} z    @{    |    @}    ~
@expansion{} 122  123  124  125  126 
@expansion{} 
ASCII(42);
@expansion{} *
ASCII(32,126);
@expansion{}  !"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh\
   ijklmnopqrstuvwxyz@{|@}~
@c end example ASCII d2t_singular/general_lib.doc:92
@end smallexample
@c ---end content ASCII---

@c ------------------- absValue -------------
@node absValue, binomial, ASCII, general_lib
@subsubsection absValue
@cindex absValue
@c ---content absValue---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
absValue(c); c int, number or poly

@item @strong{Return:}
absValue(c); the absolute value of c

@item @strong{Note:}
absValue(c)=c if c>=0; absValue=-c if c<=0.
@* So the function can be applied to any type, for which comparison
@* operators are defined.

@end table
@strong{Example:}
@smallexample
@c computed example absValue d2t_singular/general_lib.doc:123 
LIB "general.lib";
ring r1 = 0,x,dp;
absValue(-2002);
@expansion{} 2002
poly f=-4;
absValue(f);
@expansion{} 4
@c end example absValue d2t_singular/general_lib.doc:123
@end smallexample
@c inserted refs from d2t_singular/general_lib.doc:131
@ifinfo
@menu
See also:
* boolean expressions::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{boolean expressions}.
@end iftex
@c end inserted refs from d2t_singular/general_lib.doc:131

@c ---end content absValue---

@c ------------------- binomial -------------
@node binomial, deleteSublist, absValue, general_lib
@subsubsection binomial
@cindex binomial
@c ---content binomial---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
binomial(n,k[,p]); n,k,p integers

@item @strong{Return:}
binomial(n,k); binomial coefficient n choose k
@* - of type string (computed in characteristic 0)
@* binomial(n,k,p); n choose k, computed in characteristic 0 or prime(p)
@* - of type number if a basering, say R, is present and p=0=char(R)
or if prime(p)=char(R)
@* - of type string else

@item @strong{Note:}
In any characteristic, binomial(n,k) = coefficient of x^k in (1+x)^n

@end table
@strong{Example:}
@smallexample
@c computed example binomial d2t_singular/general_lib.doc:162 
LIB "general.lib";
binomial(200,100);"";                   //type string, computed in char 0
@expansion{} 90548514656103281165404177077484163874504589675413336841320
@expansion{} 
binomial(200,100,3);"";                 //type string, computed in char 3
@expansion{} 0
@expansion{} 
int n,k = 200,100;
ring r = 0,x,dp;
number b1 = binomial(n,k,0);            //type number, computed in ring r
poly b2 = coeffs((x+1)^n,x)[k+1,1];     //coefficient of x^k in (x+1)^n
b1-b2;                                  //b1 and b2 should coincide
@expansion{} 0
@c end example binomial d2t_singular/general_lib.doc:162
@end smallexample
@c inserted refs from d2t_singular/general_lib.doc:173
@ifinfo
@menu
See also:
* prime::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{prime}.
@end iftex
@c end inserted refs from d2t_singular/general_lib.doc:173

@c ---end content binomial---

@c ------------------- deleteSublist -------------
@node deleteSublist, factorial, binomial, general_lib
@subsubsection deleteSublist
@cindex deleteSublist
@c ---content deleteSublist---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
deleteSublist(v,l); intvec v; list l
@*where the entries of the integer vector v correspond to the
positions of the elements to be deleted

@item @strong{Return:}
list without the deleted elements

@end table
@strong{Example:}
@smallexample
@c computed example deleteSublist d2t_singular/general_lib.doc:198 
LIB "general.lib";
list l=1,2,3,4,5;
intvec v=1,3,4;
l=deleteSublist(v,l);
l;
@expansion{} [1]:
@expansion{}    2
@expansion{} [2]:
@expansion{}    5
@c end example deleteSublist d2t_singular/general_lib.doc:198
@end smallexample
@c ---end content deleteSublist---

@c ------------------- factorial -------------
@node factorial, fibonacci, deleteSublist, general_lib
@subsubsection factorial
@cindex factorial
@c ---content factorial---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
factorial(n[,p]); n,p integers

@item @strong{Return:}
factorial(n): n! (computed in characteristic 0), of type string.
@* factorial(n,p): n! computed in characteristic 0 or prime(p)
@* - of type number if a basering is present and 0=p=char(basering)
or if prime(p)=char(basering)
@* - of type string else

@end table
@strong{Example:}
@smallexample
@c computed example factorial d2t_singular/general_lib.doc:229 
LIB "general.lib";
factorial(37);"";                 //37! of type string (as long integer)
@expansion{} 13763753091226345046315979581580902400000000
@expansion{} 
ring r1 = 0,x,dp;
number p = factorial(37,0);       //37! of type number, computed in r
p;
@expansion{} 13763753091226345046315979581580902400000000
@c end example factorial d2t_singular/general_lib.doc:229
@end smallexample
@c inserted refs from d2t_singular/general_lib.doc:237
@ifinfo
@menu
See also:
* prime::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{prime}.
@end iftex
@c end inserted refs from d2t_singular/general_lib.doc:237

@c ---end content factorial---

@c ------------------- fibonacci -------------
@node fibonacci, kmemory, factorial, general_lib
@subsubsection fibonacci
@cindex fibonacci
@c ---content fibonacci---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
fibonacci(n); n,p integers

@item @strong{Return:}
fibonacci(n): nth Fibonacci number, f(0)=f(1)=1, f(i+1)=f(i-1)+f(i)
@* - computed in characteristic 0, of type string
@* fibonacci(n,p): f(n) computed in characteristic 0 or prime(p)
@* - of type number if a basering is present and p=0=char(basering)
or if prime(p)=char(basering)
@* - of type string else

@end table
@strong{Example:}
@smallexample
@c computed example fibonacci d2t_singular/general_lib.doc:265 
LIB "general.lib";
fibonacci(42); "";             //f(42) of type string (as long integer)
@expansion{} 267914296
@expansion{} 
ring r = 2,x,dp;
number b = fibonacci(42,2);    //f(42) of type number, computed in r
b;
@expansion{} 0
@c end example fibonacci d2t_singular/general_lib.doc:265
@end smallexample
@c inserted refs from d2t_singular/general_lib.doc:273
@ifinfo
@menu
See also:
* prime::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{prime}.
@end iftex
@c end inserted refs from d2t_singular/general_lib.doc:273

@c ---end content fibonacci---

@c ------------------- kmemory -------------
@node kmemory, killall, fibonacci, general_lib
@subsubsection kmemory
@cindex kmemory
@c ---content kmemory---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
kmemory([n,[v]]); n,v integers

@item @strong{Return:}
memory in kilobyte of type int
@* n=0: memory used by active variables (same as no parameters)
@* n=1: total memory allocated by Singular
@* n=2: difference between top and init memory address (sbrk memory)
@* n!=0,1,2: 0

@item @strong{Display:}
detailed information about allocated and used memory if v!=0

@item @strong{Note:}
kmemory uses internal function 'memory' to compute kilobyte, and
is the same as 'memory' for n!=0,1,2

@end table
@strong{Example:}
@smallexample
@c computed example kmemory d2t_singular/general_lib.doc:307 
LIB "general.lib";
kmemory();
@expansion{} 152
kmemory(1,1);
@expansion{} // total memory allocated, at the moment, by SINGULAR (kilobyte):
@expansion{} 650
@c end example kmemory d2t_singular/general_lib.doc:307
@end smallexample
@c ---end content kmemory---

@c ------------------- killall -------------
@node killall, number_e, kmemory, general_lib
@subsubsection killall
@cindex killall
@c ---content killall---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
killall(); (no parameter)
@*killall("type_name");
@*killall("not", "type_name");

@item @strong{Return:}
killall(); kills all user-defined variables except loaded procedures,
no return value.
@* - killall("type_name"); kills all user-defined variables,
of type "type_name"
@* - killall("not", "type_name"); kills all user-defined variables,
except those of type "type_name" and except loaded procedures
@* - killall("not", "name_1", "name_2", ...);
kills all user-defined variables, except those of name "name_i"
and except loaded procedures

@item @strong{Note:}
killall should never be used inside a procedure

@end table
@strong{Example:}
@smallexample
@c computed example killall d2t_singular/general_lib.doc:345 
LIB "general.lib";
ring rtest; ideal i=x,y,z; string str="hi"; int j = 3;
export rtest,i,str,j;       //this makes the local variables global
@expansion{} // ** `rtest` is already global
@expansion{} // ** `i` is already global
@expansion{} // ** `str` is already global
@expansion{} // ** `j` is already global
listvar();
@expansion{} // j                    [0]  int 3
@expansion{} // str                  [0]  string hi
@expansion{} // rtest                [0]  *ring
@expansion{} //      i                    [0]  ideal, 3 generator(s)
@expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
killall("ring");            // kills all rings
@expansion{} // ** killing the basering for level 0
listvar();
@expansion{} // j                    [0]  int 3
@expansion{} // str                  [0]  string hi
@expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
killall("not", "int");      // kills all variables except int's (and procs)
listvar();
@expansion{} // j                    [0]  int 3
@expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
killall();                  // kills all vars except loaded procs
listvar();
@expansion{} // j                    [0]  int 3
@expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
@c end example killall d2t_singular/general_lib.doc:345
@end smallexample
@c ---end content killall---

@c ------------------- number_e -------------
@node number_e, number_pi, killall, general_lib
@subsubsection number_e
@cindex number_e
@c ---content number_e---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
number_e(n); n integer

@item @strong{Return:}
Euler number e=exp(1) up to n decimal digits (no rounding)
@* - of type string if no basering of char 0 is defined
@* - of type number if a basering of char 0 is defined

@item @strong{Display:}
decimal format of e if printlevel > 0 (default:printlevel=0 )

@item @strong{Note:}
procedure uses algorithm of A.H.J. Sale

@end table
@strong{Example:}
@smallexample
@c computed example number_e d2t_singular/general_lib.doc:385 
LIB "general.lib";
number_e(30);"";
@expansion{} 2.71828182845904523536028747135
@expansion{} 
ring R = 0,t,lp;
number e = number_e(30);
e;
@expansion{} 13591409142295226176801437356763/5000000000000000000000000000000
@c end example number_e d2t_singular/general_lib.doc:385
@end smallexample
@c ---end content number_e---

@c ------------------- number_pi -------------
@node number_pi, primes, number_e, general_lib
@subsubsection number_pi
@cindex number_pi
@c ---content number_pi---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
number_pi(n); n positive integer

@item @strong{Return:}
pi (area of unit circle) up to n decimal digits (no rounding)
@* - of type string if no basering of char 0 is defined,
@* - of type number, if a basering of char 0 is defined

@item @strong{Display:}
decimal format of pi if printlevel > 0 (default:printlevel=0 )

@item @strong{Note:}
procedure uses algorithm of S. Rabinowitz

@end table
@strong{Example:}
@smallexample
@c computed example number_pi d2t_singular/general_lib.doc:420 
LIB "general.lib";
number_pi(11);"";
@expansion{} 3.1415926535
@expansion{} 
ring r = (real,10),t,dp;
number pi = number_pi(11); pi;
@expansion{} 3.1415926536
@c end example number_pi d2t_singular/general_lib.doc:420
@end smallexample
@c ---end content number_pi---

@c ------------------- primes -------------
@node primes, product, number_pi, general_lib
@subsubsection primes
@cindex primes
@c ---content primes---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
primes(n,m); n,m integers

@item @strong{Return:}
intvec, consisting of all primes p, prime(n)<=p<=m, in increasing
order if n<=m, resp. prime(m)<=p<=n, in decreasing order if m<n.

@item @strong{Note:}
prime(n); returns the biggest prime number <= min(n,32003)
if n>=2, else 2

@end table
@strong{Example:}
@smallexample
@c computed example primes d2t_singular/general_lib.doc:451 
LIB "general.lib";
primes(50,100);"";
@expansion{} 47,53,59,61,67,71,73,79,83,89,97
@expansion{} 
intvec v = primes(37,1); v;
@expansion{} 37,31,29,23,19,17,13,11,7,5,3,2
@c end example primes d2t_singular/general_lib.doc:451
@end smallexample
@c ---end content primes---

@c ------------------- product -------------
@node product, sort, primes, general_lib
@subsubsection product
@cindex product
@c ---content product---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
product(id[,v]); id ideal/vector/module/matrix/intvec/intmat/list,
v intvec (default: v=1..number of entries of id)

@item @strong{Assume:}
list members can be multiplied.

@item @strong{Return:}
The product of all entries of id [with index given by v] of type
depending on the entries of id.

@item @strong{Note:}
If id is not a list, id is treated as a list of polys resp. integers.
A module m is identified with the corresponding matrix M (columns
of M generate m).
@* If v is outside the range of id, we have the empty product and the
result will be 1 (of type int).

@end table
@strong{Example:}
@smallexample
@c computed example product d2t_singular/general_lib.doc:488 
LIB "general.lib";
ring r= 0,(x,y,z),dp;
ideal m = maxideal(1);
product(m);
@expansion{} xyz
product(m[2..3]);
@expansion{} yz
matrix M[2][3] = 1,x,2,y,3,z;
product(M);
@expansion{} 6xyz
intvec v=2,4,6;
product(M,v);
@expansion{} xyz
intvec iv = 1,2,3,4,5,6,7,8,9;
v=1..5,7,9;
product(iv,v);
@expansion{} 7560
intmat A[2][3] = 1,1,1,2,2,2;
product(A,3..5);
@expansion{} 4
@c end example product d2t_singular/general_lib.doc:488
@end smallexample
@c ---end content product---

@c ------------------- sort -------------
@node sort, sum, product, general_lib
@subsubsection sort
@cindex sort
@c ---content sort---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
sort(id[v,o,n]); id = ideal/module/intvec/list(of intvec's or int's)
@* sort may be called with 1, 2 or 3 arguments in the following way:
@* sort(id[v,n]); v=intvec of positive integers, n=integer,
@* sort(id[o,n]); o=string (any allowed ordstr of a ring), n=integer

@item @strong{Return:}
a list l of two elements:
@format
        l[1]: object of same type as input but sorted in the following way:
           - if id=ideal/module: generators of id are sorted w.r.t. intvec v
             (id[v[1]] becomes 1-st, id[v[2]]  2-nd element, etc.). If no v is
             present, id is sorted w.r.t. ordering o (if o is given) or w.r.t.
             actual monomial ordering (if no o is given):
             NOTE: generators with SMALLER(!) leading term come FIRST
             (e.g. sort(id); sorts backwards to actual monomial ordering)
           - if id=list of intvec's or int's: consider a list element, say
             id[1]=3,2,5, as exponent vector of the monomial x^3*y^2*z^5;
             the corresponding monomials are ordered w.r.t. intvec v (s.a.).
             If no v is present, the monomials are sorted w.r.t. ordering o
             (if o is given) or w.r.t. lexicographical ordering (if no o is
             given). The corresponding ordered list of exponent vectors is
             returned.
             (e.g. sort(id); sorts lexicographically, smaller int's come first)
             WARNING: Since negative exponents create the 0 polynomial in
             Singular, id should not contain negative integers: the result
             might not be as expected
           - if id=intvec: id is treated as list of integers
           - if n!=0 the ordering is inverse, i.e. w.r.t. v(size(v)..1)
             default: n=0
         l[2]: intvec, describing the permutation of the input (hence l[2]=v
             if v is given (with positive integers))
@end format

@item @strong{Note:}
If v is given id may be any simply indexed object (e.g. any list or
string); if v[i]<0 and i<=size(id) v[i] is set internally to i;
entries of v must be pairwise distinct to get a permutation if id.
Zero generators of ideal/module are deleted

@end table
@strong{Example:}
@smallexample
@c computed example sort d2t_singular/general_lib.doc:558 
LIB "general.lib";
ring r0 = 0,(x,y,z,t),lp;
ideal i = x3,z3,xyz;
sort(i);            //sorts using lex ordering, smaller polys come first
@expansion{} [1]:
@expansion{}    _[1]=z3
@expansion{}    _[2]=xyz
@expansion{}    _[3]=x3
@expansion{} [2]:
@expansion{}    2,3,1
sort(i,3..1);
@expansion{} [1]:
@expansion{}    _[1]=xyz
@expansion{}    _[2]=z3
@expansion{}    _[3]=x3
@expansion{} [2]:
@expansion{}    3,2,1
sort(i,"ls")[1];     //sort w.r.t. negative lex ordering
@expansion{} _[1]=x3
@expansion{} _[2]=xyz
@expansion{} _[3]=z3
intvec v =1,10..5,2..4;v;
@expansion{} 1,10,9,8,7,6,5,2,3,4
sort(v)[1];          // sort v lexicographically
@expansion{} 1,2,3,4,5,6,7,8,9,10
sort(v,"Dp",1)[1];   // sort v w.r.t (total sum, reverse lex)
@expansion{} 10,9,8,7,6,5,4,3,2,1
@c end example sort d2t_singular/general_lib.doc:558
@end smallexample
@c ---end content sort---

@c ------------------- sum -------------
@node sum, watchdog, sort, general_lib
@subsubsection sum
@cindex sum
@c ---content sum---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
sum(id[,v]); id ideal/vector/module/matrix/intvec/intmat/list,
v intvec (default: v=1..number of entries of id)

@item @strong{Assume:}
list members can be added.

@item @strong{Return:}
The sum of all entries of id [with index given by v] of type
depending on the entries of id.

@item @strong{Note:}
If id is not a list, id is treated as a list of polys resp. integers.
A module m is identified with the corresponding matrix M (columns
of M generate m).
@* If v is outside the range of id, we have the empty sum and the
result will be 0 (of type int).

@end table
@strong{Example:}
@smallexample
@c computed example sum d2t_singular/general_lib.doc:601 
LIB "general.lib";
ring r= 0,(x,y,z),dp;
vector pv = [xy,xz,yz,x2,y2,z2];
sum(pv);
@expansion{} x2+xy+y2+xz+yz+z2
sum(pv,2..5);
@expansion{} x2+y2+xz+yz
matrix M[2][3] = 1,x,2,y,3,z;
intvec w=2,4,6;
sum(M,w);
@expansion{} x+y+z
intvec iv = 1,2,3,4,5,6,7,8,9;
sum(iv,2..4);
@expansion{} 9
@c end example sum d2t_singular/general_lib.doc:601
@end smallexample
@c ---end content sum---

@c ------------------- watchdog -------------
@node watchdog, which, sum, general_lib
@subsubsection watchdog
@cindex watchdog
@c ---content watchdog---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Return:}
Result of cmd, if the result can be computed in i seconds.
Otherwise the computation is interrupted after i seconds,
the string "Killed" is returned and the global variable
'watchdog_interrupt' is defined.

@item @strong{Note:}
* the MP package must be enabled
@** the current basering should not be watchdog_rneu, since
watchdog_rneu will be killed
@** if there are variable names of the structure x(i) all
polynomials have to be put into eval(...) in order to be
interpreted correctly
@** a second Singular process is started by this procedure

@end table
@strong{Example:}
@smallexample
@c computed example watchdog d2t_singular/general_lib.doc:642 
LIB "general.lib";
ring r=0,(x,y,z),dp;
poly f=x^30+y^30;
watchdog(1,"factorize(eval("+string(f)+"))");
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x16+x14y2-x10y6-x8y8-x6y10+x2y14+y16
@expansion{}    _[3]=x8-x6y2+x4y4-x2y6+y8
@expansion{}    _[4]=x4-x2y2+y4
@expansion{}    _[5]=x2+y2
@expansion{} [2]:
@expansion{}    1,1,1,1,1
watchdog(100,"factorize(eval("+string(f)+"))");
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x16+x14y2-x10y6-x8y8-x6y10+x2y14+y16
@expansion{}    _[3]=x8-x6y2+x4y4-x2y6+y8
@expansion{}    _[4]=x4-x2y2+y4
@expansion{}    _[5]=x2+y2
@expansion{} [2]:
@expansion{}    1,1,1,1,1
@c end example watchdog d2t_singular/general_lib.doc:642
@end smallexample
@c ---end content watchdog---

@c ------------------- which -------------
@node which, primecoeffs, watchdog, general_lib
@subsubsection which
@cindex which
@c ---content which---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
which(command); command = string expression

@item @strong{Return:}
Absolute pathname of command, if found in search path.
Empty string, otherwise.

@item @strong{Note:}
Based on the Unix command 'which'.

@end table
@strong{Example:}
@smallexample
@c computed example which d2t_singular/general_lib.doc:673 
LIB "general.lib";
which("sh");
@expansion{} /bin/sh
@c end example which d2t_singular/general_lib.doc:673
@end smallexample
@c ---end content which---

@c ------------------- primecoeffs -------------
@node primecoeffs, primefactors, which, general_lib
@subsubsection primecoeffs
@cindex primecoeffs
@c ---content primecoeffs---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
primecoeffs(J[,q]); J any type which can be converted to a matrix
e.g. ideal, matrix, vector, module, int, intvec
@*q = intger

@item @strong{Compute:}
primefactors <= min(p,32003) of coeffs of J (default p = 32003)

@item @strong{Return:}
a list, say l, of two intvectors:
@*l[1] : the different primefactors of all coefficients of J
l[2] : the different remaining factors

@item @strong{Note:}
the procedure works for small integers only, just by testing all
primes (not to be considerd as serious prime factorization!)

@end table
@strong{Example:}
@smallexample
@c computed example primecoeffs d2t_singular/general_lib.doc:708 
LIB "general.lib";
primecoeffs(intvec(7*8*121,7*8));"";
@expansion{} [1]:
@expansion{}    2,7,11
@expansion{} [2]:
@expansion{}    1
@expansion{} 
ring r = 0,(b,c,t),dp;
ideal I = -13b6c3t+4b5c4t,-10b4c2t-5b4ct2;
primecoeffs(I);
@expansion{} [1]:
@expansion{}    2,5,13
@expansion{} [2]:
@expansion{}    _[1]=1
@c end example primecoeffs d2t_singular/general_lib.doc:708
@end smallexample
@c ---end content primecoeffs---

@c ------------------- primefactors -------------
@node primefactors, timeStd, primecoeffs, general_lib
@subsubsection primefactors
@cindex primefactors
@c ---content primefactors---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
primefactors(n [,p]); n = int or number, p = integer

@item @strong{Compute:}
primefactors <= min(p,32003) of n (default p = 32003)

@item @strong{Return:}
a list, say l,
@*l[1] : primefactors <= min(p,32003) of n
@*l[2] : l[2][i] = multiplicity of l[1][i]
@*l[3] : remaining factor ( n=product@{ (l[1][i]^l[2][i])*l[3]@} )
type(l[3])=typeof(n)

@item @strong{Note:}
If n is a long integer (of type number) then the procedure
finds primefactors <= min(p,32003) but n may be larger as
2147483647 (max. integer representation)

@item @strong{Warning:}
the procedure works for small integers only, just by testing all
primes (not to be considerd as serious prime factorization!)

@end table
@strong{Example:}
@smallexample
@c computed example primefactors d2t_singular/general_lib.doc:751 
LIB "general.lib";
primefactors(7*8*121);
@expansion{} [1]:
@expansion{}    2,7,11
@expansion{} [2]:
@expansion{}    3,1,2
@expansion{} [3]:
@expansion{}    1
ring r = 0,x,dp;
primefactors(123456789100);
@expansion{} [1]:
@expansion{}    2,5
@expansion{} [2]:
@expansion{}    2,2
@expansion{} [3]:
@expansion{}    1234567891
@c end example primefactors d2t_singular/general_lib.doc:751
@end smallexample
@c ---end content primefactors---

@c ------------------- timeStd -------------
@node timeStd, timeFactorize, primefactors, general_lib
@subsubsection timeStd
@cindex timeStd
@c ---content timeStd---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
timeStd(i,d), i ideal, d integer

@item @strong{Return:}
std(i) if the standard basis computation finished after
d-1 seconds and i otherwise

@end table
@strong{Example:}
@smallexample
@c computed example timeStd d2t_singular/general_lib.doc:778 
LIB "general.lib";
ring r=32003,(a,b,c,d,e),dp;
int n=6;
ideal i=
a^n-b^n,
b^n-c^n,
c^n-d^n,
d^n-e^n,
a^(n-1)*b+b^(n-1)*c+c^(n-1)*d+d^(n-1)*e+e^(n-1)*a;
ideal j=timeStd(i,2);
j;
@expansion{} j[1]=a6-b6
@expansion{} j[2]=b6-c6
@expansion{} j[3]=c6-d6
@expansion{} j[4]=d6-e6
@expansion{} j[5]=a5b+b5c+c5d+d5e+ae5
@c end example timeStd d2t_singular/general_lib.doc:778
@end smallexample
@c ---end content timeStd---

@c ------------------- timeFactorize -------------
@node timeFactorize, factorH, timeStd, general_lib
@subsubsection timeFactorize
@cindex timeFactorize
@c ---content timeFactorize---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
timeFactorize(p,d) poly p , integer d

@item @strong{Return:}
factorize(p) if the factorization finished after d-1
@*seconds otherwise f is considered to be irreducible

@end table
@strong{Example:}
@smallexample
@c computed example timeFactorize d2t_singular/general_lib.doc:812 
LIB "general.lib";
ring r=0,(x,y),dp;
poly p=((x2+y3)^2+xy6)*((x3+y2)^2+x10y);
p=p^2;
list l=timeFactorize(p,2);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       x22y14+2x21y14+4x23y11+x20y14+2x25y8+4x22y11+6x24y8+4x26y5+2x18y13+\
   x28y2+4x17y13+4x15y15+8x19y10+2x16y13+8x14y15+2x12y17+4x21y7+8x18y10+16x1\
   6y12+4x13y15+4x11y17+12x20y7+8x18y9+16x15y12+8x13y14+2x10y17+8x22y4+24x17\
   y9+4x15y11+x14y12+8x12y14+2x24y+16x19y6+12x14y11+2x13y12+4x11y14+4x21y3+8\
   x16y8+4x15y9+x12y12+8x10y14+6x8y16+2x18y5+2x17y6+4x14y9+16x12y11+4x9y14+1\
   2x7y16+4x5y18+6x16y6+8x14y8+16x11y11+24x9y13+6x6y16+8x4y18+x2y20+4x18y3+2\
   4x13y8+12x11y10+24x8y13+16x6y15+4x3y18+2xy20+x20+16x15y5+36x10y10+8x8y12+\
   16x5y15+4x3y17+y20+4x17y2+24x12y7+24x7y12+2x5y14+4x2y17+6x14y4+16x9y9+6x4\
   y14+4x11y6+4x6y11+x8y8
@expansion{} [2]:
@expansion{}    1,1
@c end example timeFactorize d2t_singular/general_lib.doc:812
@end smallexample
@c ---end content timeFactorize---

@c ------------------- factorH -------------
@node factorH,, timeFactorize, general_lib
@subsubsection factorH
@cindex factorH
@c ---content factorH---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
factorH(p) p poly

@item @strong{Return:}
factorize(p)

@item @strong{Note:}
changes variables to become the last variable the principal
one in the multivariate factorization and factorizes then
the polynomial

@end table
@strong{Example:}
@smallexample
@c computed example factorH d2t_singular/general_lib.doc:845 
LIB "general.lib";
system("random",992851144);
ring r=32003,(x,y,z,w,t),lp;
poly p=y2w9+yz7t-yz5w4-z2w4t4-w8t3;
//factorize(p);  //fast
//system("random",992851262);
//factorize(p);  //slow
//system("random",992851262);
factorH(p);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=y2w9+yz7t-yz5w4-z2w4t4-w8t3
@expansion{} [2]:
@expansion{}    1,1
@c end example factorH d2t_singular/general_lib.doc:845
@end smallexample
@c ---end content factorH---
