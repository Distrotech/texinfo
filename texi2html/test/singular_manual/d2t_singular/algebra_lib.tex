@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/algebra_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/algebra_lib.doc INSTEAD
@c library version: (1.9.2.3,2002/04/11)
@c library file: ../Singular/LIB/algebra.lib
@cindex algebra.lib
@cindex algebra_lib
@table @asis
@item @strong{Library:}
algebra.lib
@item @strong{Purpose:}
   Compute with Algebras and Algebra Maps
@item @strong{Authors:}
Gert-Martin Greuel, greuel@@mathematik.uni-kl.de,
@* Agnes Eileen Heydtmann, agnes@@math.uni-sb.de,
@* Gerhard Pfister, pfister@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* algebra_containment:: query of algebra containment
* module_containment:: query of module containment over a subalgebra
* inSubring:: test whether poly p is in subring generated by I
* algDependent:: computes algebraic relations between generators of I
* alg_kernel:: computes the kernel of the ring map phi
* is_injective:: test for injectivity of ring map phi
* is_surjective:: test for surjectivity of ring map phi
* is_bijective:: test for bijectivity of ring map phi
* noetherNormal:: noether normalization of ideal id
* mapIsFinite:: query for finiteness of map phi:R --> basering/I
* finitenessTest:: find variables which occur as pure power in lead(i)
@end menu
@c ---end content LibInfo---

@c ------------------- algebra_containment -------------
@node algebra_containment, module_containment,, algebra_lib
@subsubsection algebra_containment
@cindex algebra_containment
@c ---content algebra_containment---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
algebra_containment(p,A[,k]); p poly, A ideal, k integer.
@* A = A[1],...,A[m] generators of subalgebra of the basering

@item @strong{Return:}
@format
         - k=0 (or if k is not given) an integer:
           1  : if p is contained in the subalgebra K[A[1],...,A[m]]
           0  : if p is not contained in K[A[1],...,A[m]]
         - k=1 : a list, say l, of size 2, l[1] integer, l[2] ring, satisfying
           l[1]=1 if p is in the subalgebra K[A[1],...,A[m]] and then the ring
           l[2] contains poly check = h(y(1),...,y(m)) if p=h(A[1],...,A[m])
           l[1]=0 if p is in not the subalgebra K[A[1],...,A[m]] and then
           l[2] contains the poly check = h(x,y(1),...,y(m)) if p satisfies
           the nonlinear relation p = h(x,A[1],...,A[m]) where
           x = x(1),...,x(n) denote the variables of the basering
@end format

@item @strong{Display:}
if k=0 and printlevel >= voice+1 (default) display the poly check

@item @strong{Note:}
The proc inSubring uses a different algorithm which is sometimes
faster.

@item @strong{Theory:}
The ideal of algebraic relations of the algebra generators A[1],...,
A[m] is computed introducing new variables y(i) and the product
order with x(i) >> y(i).
@*p reduces to a polynomial only in the y(i) <=> p is contained in the
subring generated by the polynomials A[1],...,A[m].

@end table
@strong{Example:}
@smallexample
@c computed example algebra_containment d2t_singular/algebra_lib.doc:77 
LIB "algebra.lib";
int p = printlevel; printlevel = 1;
ring R = 0,(x,y,z),dp;
ideal A=x2+y2,z2,x4+y4,1,x2z-1y2z,xyz,x3y-1xy3;
poly p1=z;
poly p2=
x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
algebra_containment(p1,A);
@expansion{} // x(3)
@expansion{} 0
algebra_containment(p2,A);
@expansion{} // y(1)*y(2)*y(5)^2+y(3)*y(5)^3+4*y(1)*y(2)*y(6)^2+4*y(6)^3*y(7)+2*y(2)*y\
   (5)*y(7)^2
@expansion{} 1
list L = algebra_containment(p2,A,1);
@expansion{} 
@expansion{} // 'algebra_containment' created a ring as 2nd element of the list.
@expansion{} // The ring contains the poly check which defines the algebraic relation.
@expansion{} // To access to the ring and see check you must give the ring a name,
@expansion{} // e.g.:
@expansion{}                def S = l[2]; setring S; check;
@expansion{} 	
L[1];
@expansion{} 1
def S = L[2]; setring S;
check;
@expansion{} y(1)*y(2)*y(5)^2+y(3)*y(5)^3+4*y(1)*y(2)*y(6)^2+4*y(6)^3*y(7)+2*y(2)*y(5)\
   *y(7)^2
printlevel = p;
@c end example algebra_containment d2t_singular/algebra_lib.doc:77
@end smallexample
@c ---end content algebra_containment---

@c ------------------- module_containment -------------
@node module_containment, inSubring, algebra_containment, algebra_lib
@subsubsection module_containment
@cindex module_containment
@c ---content module_containment---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
module_containment(p,P,M[,k]); p poly, P ideal, M ideal, k int
@* P = P[1],...,P[n] generators of a subalgebra of the basering,
@* M = M[1],...,M[m] generators of a module over the subalgebra K[P]

@item @strong{Assume:}
ncols(P) = nvars(basering), the P[i] are algebraically independent

@item @strong{Return:}
@format
         - k=0 (or if k is not given), an integer:
           1    : if p is contained in the module <M[1],...,M[m]> over K[P]
           0    : if p is not contained in <M[1],...,M[m]>
         - k=1, a list, say l, of size 2, l[1] integer, l[2] ring:
           l[1]=1 : if p is in <M[1],...,M[m]> and then the ring l[2] contains
             the polynomial check = h(y(1),...,y(m),z(1),...,z(n)) if
             p = h(M[1],...,M[m],P[1],...,P[n])
           l[1]=0 : if p is in not in <M[1],...,M[m]>, then l[2] contains the
             poly check = h(x,y(1),...,y(m),z(1),...,z(n)) if p satisfies
             the nonlinear relation p = h(x,M[1],...,M[m],P[1],...,P[n]) where
             x = x(1),...,x(n) denote the variables of the basering
@end format

@item @strong{Display:}
the polynomial h(y(1),...,y(m),z(1),...,z(n)) if k=0, resp.
a comment how to access the relation check if k=1, provided
printlevel >= voice+1 (default).

@item @strong{Theory:}
The ideal of algebraic relations of all the generators p1,...,pn,
s1,...,st given by P and S is computed introducing new variables y(j),
z(i) and the product order: x^a*y^b*z^c > x^d*y^e*z^f if x^a > x^d
with respect to the lp ordering or else if z^c > z^f with respect to
the dp ordering or else if y^b > y^e with respect to the lp ordering
again. p reduces to a polynomial only in the y(j) and z(i), linear in
the z(i) <=> p is contained in the module.

@end table
@strong{Example:}
@smallexample
@c computed example module_containment d2t_singular/algebra_lib.doc:144 
LIB "algebra.lib";
int p = printlevel; printlevel = 1;
ring R=0,(x,y,z),dp;
ideal P = x2+y2,z2,x4+y4;           //algebra generators
ideal M = 1,x2z-1y2z,xyz,x3y-1xy3;  //module generators
poly p1=
x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
module_containment(p1,P,M);
@expansion{} // y(2)*z(2)*z(3)^2+z(1)^3*z(2)^2
@expansion{} 1
poly p2=z;
list l = module_containment(p2,P,M,1);
@expansion{} 
@expansion{} // 'module_containment' created a ring as 2nd element of the list. The
@expansion{} // ring contains the poly check which defines the algebraic relation
@expansion{} // for p. To access to the ring and see check you must give the ring
@expansion{} // a name, e.g.:
@expansion{}      def S = l[2]; setring S; check;
@expansion{}       
l[1];
@expansion{} 0
def S = l[2]; setring S; check;
@expansion{} x(3)
printlevel=p;
@c end example module_containment d2t_singular/algebra_lib.doc:144
@end smallexample
@c ---end content module_containment---

@c ------------------- inSubring -------------
@node inSubring, algDependent, module_containment, algebra_lib
@subsubsection inSubring
@cindex inSubring
@c ---content inSubring---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
inSubring(p,i); p poly, i ideal

@item @strong{Return:}
@format
         a list l of size 2, l[1] integer, l[2] string
         l[1]=1 iff p is in the subring generated by i=i[1],...,i[k],
                and then l[2] = y(0)-h(y(1),...,y(k)) if p = h(i[1],...,i[k])
         l[1]=0 iff p is in not the subring generated by i,
                and then l[2] = h(y(0),y(1),...,y(k) where p satisfies the
                nonlinear relation h(p,i[1],...,i[k])=0.
@end format

@item @strong{Note:}
the proc algebra_containment tests the same with a different
algorithm, which is often faster

@end table
@strong{Example:}
@smallexample
@c computed example inSubring d2t_singular/algebra_lib.doc:190 
LIB "algebra.lib";
ring q=0,(x,y,z,u,v,w),dp;
poly p=xyzu2w-1yzu2w2+u4w2-1xu2vw+u2vw2+xyz-1yzw+2u2w-1xv+vw+2;
ideal I =x-w,u2w+1,yz-v;
inSubring(p,I);
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    y(1)*y(2)*y(3)+y(2)^2-y(0)+1
@c end example inSubring d2t_singular/algebra_lib.doc:190
@end smallexample
@c ---end content inSubring---

@c ------------------- algDependent -------------
@node algDependent, alg_kernel, inSubring, algebra_lib
@subsubsection algDependent
@cindex algDependent
@c ---content algDependent---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
algDependent(f[,c]); f ideal (say, f = f1,...,fm), c integer

@item @strong{Return:}
@format	
         a list l  of size 2, l[1] integer, l[2] ring:
         - l[1] = 1 if f1,...,fm are algebraic dependent, 0 if not
         - l[2] is a ring with variables x(1),...,x(n),y(1),...,y(m) if the
           basering has n variables. It contains the ideal 'ker', depending
           only on the y(i) and generating the algebraic relations between the
           f[i], i.e. substituting y(i) by fi yields 0. Of course, ker is
           nothing but the kernel of the ring map
              K[y(1),...,y(m)] ---> basering,  y(i) --> fi.
@end format

@item @strong{Note:}
Three different algorithms are used depending on c = 1,2,3.
If c is not given or c=0, a heuristically best method is chosen.
The basering may be a quotient ring.
@*To access to the ring l[2] and see ker you must give the ring a name,
e.g. def S=l[2]; setring S; ker;

@item @strong{Display:}
The above comment is displayed if printlevel >= 0 (default).

@end table
@strong{Example:}
@smallexample
@c computed example algDependent d2t_singular/algebra_lib.doc:236 
LIB "algebra.lib";
int p = printlevel; printlevel = 1;
ring R = 0,(x,y,z,u,v,w),dp;
ideal I = xyzu2w-1yzu2w2+u4w2-1xu2vw+u2vw2+xyz-1yzw+2u2w-1xv+vw+2,
x-w, u2w+1, yz-v;
list l = algDependent(I);
@expansion{} 
@expansion{} // The 2nd element of the list l is a ring with variables x(1),...,x(n),
@expansion{} // and y(1),...,y(m) if the basering has n variables and if the ideal
@expansion{} // is f[1],...,f[m]. The ring contains the ideal ker which depends only
@expansion{} // on the y(i) and generates the relations between the f[i].
@expansion{} // I.e. substituting y(i) by f[i] yields 0.
@expansion{} // To access to the ring and see ker you must give the ring a name,
@expansion{} // e.g.:
@expansion{}              def S = l[2]; setring S; ker;
@expansion{} 	
l[1];
@expansion{} 1
def S = l[2]; setring S;
ker;
@expansion{} ker[1]=y(2)*y(3)*y(4)+y(3)^2-y(1)+1
printlevel = p;
@c end example algDependent d2t_singular/algebra_lib.doc:236
@end smallexample
@c ---end content algDependent---

@c ------------------- alg_kernel -------------
@node alg_kernel, is_injective, algDependent, algebra_lib
@subsubsection alg_kernel
@cindex alg_kernel
@c ---content alg_kernel---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
alg_kernel(phi,pr[,s,c]); phi map to basering, pr preimage ring,
s string (name of kernel in pr), c integer.

@item @strong{Return:}
a string, the kernel of phi as string.
@*If, moreover, a string s is given, the algorithm creates, in the
preimage ring pr the kernel of phi with name s.
@*Three different algorithms are used depending on c = 1,2,3.
If c is not given or c=0, a heuristically best method is chosen.
(algorithm 1 uses the preimage command)

@item @strong{Note:}
Since the kernel of phi lives in pr, it cannot be returned to the
basering. If s is given, the user has access to it in pr via s.
The basering may be a quotient ring.

@end table
@strong{Example:}
@smallexample
@c computed example alg_kernel d2t_singular/algebra_lib.doc:279 
LIB "algebra.lib";
ring r = 0,(a,b,c),ds;
ring s = 0,(x,y,z,u,v,w),dp;
ideal I = x-w,u2w+1,yz-v;
map phi = r,I;                // a map from r to s:
alg_kernel(phi,r);            // a,b,c ---> x-w,u2w+1,yz-v
@expansion{} 0
ring S = 0,(a,b,c),ds;
ring R = 0,(x,y,z),dp;
qring Q = std(x-y);
ideal i = x, y, x2-y3;
map phi = S,i;                 // a map to a quotient ring
alg_kernel(phi,S,"ker",3);     // uses algorithm 3
@expansion{} a-b,b^3-b^2+c
setring S;                     // you have access to kernel in preimage
ker;
@expansion{} ker[1]=a-b
@expansion{} ker[2]=c-b2+b3
@c end example alg_kernel d2t_singular/algebra_lib.doc:279
@end smallexample
@c ---end content alg_kernel---

@c ------------------- is_injective -------------
@node is_injective, is_surjective, alg_kernel, algebra_lib
@subsubsection is_injective
@cindex is_injective
@c ---content is_injective---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
is_injective(phi,pr[,c,s]); phi map, pr preimage ring, c int, s string

@item @strong{Return:}
@format	
         - 1 (type int) if phi is injective, 0 if not (if s is not given).
         - If s is given, return a list l of size 2, l[1] int, l[2] ring:
           l[1] is 1 if phi is injective, 0 if not
           l[2] is a ring with variables x(1),...,x(n),y(1),...,y(m) if the
           basering has n variables and the map m components, it contains the
           ideal 'ker', depending only on the y(i), the kernel of the given map
@end format

@item @strong{Note:}
Three different algorithms are used depending on c = 1,2,3.
If c is not given or c=0, a heuristically best method is chosen.
The basering may be a quotient ring. However, if the preimage ring is
a quotient ring, say pr = P/I, consider phi as a map from P and then
the algorithm returns 1 if the kernel of phi is 0 mod I.
To access to the ring l[2] and see ker you must give the ring a name,
e.g. def S=l[2]; setring S; ker;

@item @strong{Display:}
The above comment is displayed if printlevel >= 0 (default).

@end table
@strong{Example:}
@smallexample
@c computed example is_injective d2t_singular/algebra_lib.doc:334 
LIB "algebra.lib";
int p = printlevel;
ring r = 0,(a,b,c),ds;
ring s = 0,(x,y,z,u,v,w),dp;
ideal I = x-w,u2w+1,yz-v;
map phi = r,I;                    // a map from r to s:
is_injective(phi,r);              // a,b,c ---> x-w,u2w+1,yz-v
@expansion{} 1
ring R = 0,(x,y,z),dp;
ideal i = x, y, x2-y3;
map phi = R,i;                    // a map from R to itself, z --> x2-y3
list l = is_injective(phi,R,"");
@expansion{} 
@expansion{} // The 2nd element of the list is a ring with variables x(1),...,x(n),
@expansion{} // y(1),...,y(m) if the basering has n variables and the map is
@expansion{} // F[1],...,F[m].
@expansion{} // It contains the ideal ker, the kernel of the given map y(i) --> F[i].
@expansion{} // To access to the ring and see ker you must give the ring a name,
@expansion{} // e.g.:
@expansion{}      def S = l[2]; setring S; ker;
@expansion{} 	
l[1];
@expansion{} 0
def S = l[2]; setring S;
ker;
@expansion{} ker[1]=y(2)^3-y(1)^2+y(3)
@c end example is_injective d2t_singular/algebra_lib.doc:334
@end smallexample
@c ---end content is_injective---

@c ------------------- is_surjective -------------
@node is_surjective, is_bijective, is_injective, algebra_lib
@subsubsection is_surjective
@cindex is_surjective
@c ---content is_surjective---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
is_surjective(phi); phi map to basering, or ideal defining it

@item @strong{Return:}
an integer, 1 if phi is surjective, 0 if not

@item @strong{Note:}
The algorithm returns 1 iff all the variables of the basering are
contained in the polynomial subalgebra generated by the polynomials
defining phi. Hence, if the basering has local or mixed ordering
or if the preimage ring is a quotient ring (in which case the map
may not be well defined) then the return value 1 means
@*"surjectivity" in this sense.

@end table
@strong{Example:}
@smallexample
@c computed example is_surjective d2t_singular/algebra_lib.doc:378 
LIB "algebra.lib";
ring R = 0,(x,y,z),dp;
ideal i = x, y, x2-y3;
map phi = R,i;                    // a map from R to itself, z->x2-y3
is_surjective(phi);
@expansion{} 0
qring Q = std(ideal(z-x37));
map psi = R, x,y,x2-y3;           // the same map to the quotient ring
is_surjective(psi);
@expansion{} 1
ring S = 0,(a,b,c),dp;
map psi = R,ideal(a,a+b,c-a2+b3); // a map from R to S,
is_surjective(psi);               // x->a, y->a+b, z->c-a2+b3
@expansion{} 1
@c end example is_surjective d2t_singular/algebra_lib.doc:378
@end smallexample
@c ---end content is_surjective---

@c ------------------- is_bijective -------------
@node is_bijective, noetherNormal, is_surjective, algebra_lib
@subsubsection is_bijective
@cindex is_bijective
@c ---content is_bijective---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
is_bijective(phi,pr); phi map to basering, pr preimage ring

@item @strong{Return:}
an integer, 1 if phi is bijective, 0 if not

@item @strong{Note:}
The algorithm checks first injectivity and then surjectivity
To interpret this for local/mixed orderings, or for quotient rings
type help is_surjective; and help is_injective;

@item @strong{Display:}
A comment if printlevel >= voice-1 (default)

@end table
@strong{Example:}
@smallexample
@c computed example is_bijective d2t_singular/algebra_lib.doc:419 
LIB "algebra.lib";
int p = printlevel;  printlevel = 1;
ring R = 0,(x,y,z),dp;
ideal i = x, y, x2-y3;
map phi = R,i;                      // a map from R to itself, z->x2-y3
is_bijective(phi,R);
@expansion{} // map not injective
@expansion{} 0
qring Q = std(z-x2+y3);
is_bijective(ideal(x,y,x2-y3),Q);
@expansion{} 1
ring S = 0,(a,b,c,d),dp;
map psi = R,ideal(a,a+b,c-a2+b3,0); // a map from R to S,
is_bijective(psi,R);                // x->a, y->a+b, z->c-a2+b3
@expansion{} // map injective, but not surjective
@expansion{} 0
qring T = std(d,c-a2+b3);
@expansion{} // ** _ is no standardbasis
map chi = Q,a,b,a2-b3;              // amap between two quotient rings
is_bijective(chi,Q);
@expansion{} 1
printlevel = p;
@c end example is_bijective d2t_singular/algebra_lib.doc:419
@end smallexample
@c ---end content is_bijective---

@c ------------------- noetherNormal -------------
@node noetherNormal, mapIsFinite, is_bijective, algebra_lib
@subsubsection noetherNormal
@cindex noetherNormal
@c ---content noetherNormal---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
noetherNormal(id[,p]); id ideal, p integer

@item @strong{Return:}
@format	
         a list l two ideals, say I,J:
         - I is generated by a subset of the variables with size(I) = dim(id)
         - J defines a map (coordinate change in the basering), such that:
           if we define  map phi=basering,J;
           then k[var(1),...,var(n)]/phi(id) is finite over k[I].
         If p is given, 0<=p<=100, a sparse coordinate change with p percent
         of the matrix entries being 0 (default: p=0 i.e. dense)
@end format

@item @strong{Note:}
Designed for characteristic 0.It works also in char k > 0 if it
terminates,but may result in an infinite loop in small characteristic

@end table
@strong{Example:}
@smallexample
@c computed example noetherNormal d2t_singular/algebra_lib.doc:468 
LIB "algebra.lib";
ring r=0,(x,y,z),dp;
ideal i= xy,xz;
noetherNormal(i);
@expansion{} [1]:
@expansion{}    _[1]=x
@expansion{}    _[2]=2x+y
@expansion{}    _[3]=3x+4y+z
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{}    _[2]=z
@c end example noetherNormal d2t_singular/algebra_lib.doc:468
@end smallexample
@c ---end content noetherNormal---

@c ------------------- mapIsFinite -------------
@node mapIsFinite, finitenessTest, noetherNormal, algebra_lib
@subsubsection mapIsFinite
@cindex mapIsFinite
@c ---content mapIsFinite---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
mapIsFinite(phi,R[,J]); R a ring, phi: R ---> basering a map
J an ideal in the basering, J = 0 if not given

@item @strong{Return:}
1 if R ---> basering/J is finite and 0 else

@end table
@strong{Example:}
@smallexample
@c computed example mapIsFinite d2t_singular/algebra_lib.doc:495 
LIB "algebra.lib";
ring r = 0,(a,b,c),dp;
ring s = 0,(x,y,z),dp;
ideal i= xy;
map phi= r,(xy)^3+x2+z,y2-1,z3;
mapIsFinite(phi,r,i);
@expansion{} 1
@c end example mapIsFinite d2t_singular/algebra_lib.doc:495
@end smallexample
@c ---end content mapIsFinite---

@c ------------------- finitenessTest -------------
@node finitenessTest,, mapIsFinite, algebra_lib
@subsubsection finitenessTest
@cindex finitenessTest
@c ---content finitenessTest---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
finitenessTest(J[,v]); J ideal, v intvec (say v1,...,vr with vi>0)

@item @strong{Return:}
@format
         a list l with l[1] integer, l[2], l[3], l[4] ideals
         - l[1] = 1 if var(v1),...,var(vr) are in l[2] and 0 else
         - l[2] (resp. l[3]) contains those variables which occur,
           (resp. occur not) as pure power in the leading term of one of the
           generators of J,
         - l[4] contains those J[i] for which the leading term is a pure power
           of a variable (which is then in l[2])
         (default: v = [1,2,..,nvars(basering)])
@end format

@item @strong{Theory:}
If J is a standard basis of an ideal generated by x_1 - f_1(y),...,
x_n - f_n with y_j ordered lexicographically and y_j >> x_i, then,
if y_i appears as pure power in the leading term of J[k]. J[k] defines
an integral relation for y_i over the y_(i+1),... and the f's.
Moreover, in this situation, if l[2] = y_1,...,y_r, then K[y_1,...y_r]
is finite over K[f_1..f_n]. If J contains furthermore polynomials
h_j(y), then K[y_1,...y_z]/<h_j> is finite over K[f_1..f_n].

@end table
@strong{Example:}
@smallexample
@c computed example finitenessTest d2t_singular/algebra_lib.doc:541 
LIB "algebra.lib";
ring s = 0,(x,y,z,a,b,c),(lp(3),dp);
ideal i= a -(xy)^3+x2-z, b -y2-1, c -z3;
ideal j = a -(xy)^3+x2-z, b -y2-1, c -z3, xy;
finitenessTest(std(i),1..3);
@expansion{} [1]:
@expansion{}    0
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{}    _[2]=z
@expansion{} [3]:
@expansion{}    _[1]=x
@expansion{}    _[2]=a
@expansion{}    _[3]=b
@expansion{}    _[4]=c
@expansion{} [4]:
@expansion{}    _[1]=z3-c
@expansion{}    _[2]=y2-b+1
finitenessTest(std(j),1..3);
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    _[1]=x
@expansion{}    _[2]=y
@expansion{}    _[3]=z
@expansion{} [3]:
@expansion{}    _[1]=a
@expansion{}    _[2]=b
@expansion{}    _[3]=c
@expansion{} [4]:
@expansion{}    _[1]=z3-c
@expansion{}    _[2]=y2-b+1
@expansion{}    _[3]=x2-z+a
@c end example finitenessTest d2t_singular/algebra_lib.doc:541
@end smallexample
@c ---end content finitenessTest---
