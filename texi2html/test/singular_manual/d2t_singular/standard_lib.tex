@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/standard_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/standard_lib.doc INSTEAD
@c library version: (1.58.2.9,2003/06/16)
@c library file: ../Singular/LIB/standard.lib
@cindex standard.lib
@cindex standard_lib
@table @asis
@item @strong{Library:}
standard.lib
@item @strong{Purpose:}
   Procedures which are always loaded at Start-up

@end table

@strong{Procedures:}
@menu
* stdfglm:: standard basis of ideal via fglm [and ordering ord]
* stdhilb:: standard basis of ideal using the Hilbert function
* groebner:: standard basis using a heuristically chosen method
* quot:: quotient using heuristically chosen method
* res:: free resolution of ideal or module
* sprintf:: returns formatted string
* fprintf:: writes formatted string to link
* printf:: displays formatted string
@end menu
@c ---end content LibInfo---

@c ------------------- stdfglm -------------
@node stdfglm, stdhilb,, standard_lib
@subsubsection stdfglm
@cindex stdfglm
@c ---content stdfglm---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{stdfglm (} ideal_expression @code{)} @*
@code{stdfglm (} ideal_expression@code{,} string_expression @code{)}

@item @strong{Type:}
ideal

@item @strong{Purpose:}
computes the standard basis of the ideal in the basering
via @code{fglm} (from the ordering given as the second argument
to the ordering of the basering).@*
If no second argument is given, "dp" is used.

@cindex fglm
@end table
@strong{Example:}
@smallexample
@c reused example stdfglm d2t_singular/standard_lib.doc:52 
   ring r=0,(x,y,z),lp;
ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
ideal i1=stdfglm(i);         //uses fglm from "dp" to "lp"
i1;
@expansion{} i1[1]=z12
@expansion{} i1[2]=yz4-z8
@expansion{} i1[3]=y2+y-z8-z4
@expansion{} i1[4]=xy-xz4-y+z4
@expansion{} i1[5]=x2+y-z4
ideal i2=stdfglm(i,"Dp");    //uses fglm from "Dp" to "lp"
i2;
@expansion{} i2[1]=z12
@expansion{} i2[2]=yz4-z8
@expansion{} i2[3]=y2+y-z8-z4
@expansion{} i2[4]=xy-xz4-y+z4
@expansion{} i2[5]=x2+y-z4
@c end example stdfglm d2t_singular/standard_lib.doc:52
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:61
@ifinfo
@menu
See also:
* fglm::
* groebner::
* std::
* stdhilb::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{fglm};
@ref{groebner};
@ref{std};
@ref{stdhilb}.
@end iftex
@c end inserted refs from d2t_singular/standard_lib.doc:61

@c ---end content stdfglm---

@c ------------------- stdhilb -------------
@node stdhilb, groebner, stdfglm, standard_lib
@subsubsection stdhilb
@cindex stdhilb
@c ---content stdhilb---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{stdhilb (} ideal_expression @code{)} @*
@code{stdhilb (} ideal_expression@code{,} intvec_expression @code{)}

@item @strong{Type:}
ideal

@item @strong{Purpose:}
computes the standard basis of the homogeneous ideal in the basering,
via a Hilbert driven standard basis computation.@*
An optional second argument will be used as 1st Hilbert function.

@item @strong{Assume:}
The optional second argument is the first Hilbert series as computed
by @code{hilb}.

@cindex Hilbert function
@end table
@strong{Example:}
@smallexample
@c reused example stdhilb d2t_singular/standard_lib.doc:95 
   ring  r=0,(x,y,z),dp;
ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
ideal i1=stdhilb(i); i1;
@expansion{} i1[1]=y3+x2
@expansion{} i1[2]=x2y+x2
@expansion{} i1[3]=x3-x2
@expansion{} i1[4]=z4-x2-y
// the latter computation is equivalent to:
intvec v=hilb(i,1);
@expansion{} // ** i is no standardbasis
ideal i2=stdhilb(i,v); i2;
@expansion{} i2[1]=y3+x2
@expansion{} i2[2]=x2y+x2
@expansion{} i2[3]=x3-x2
@expansion{} i2[4]=z4-x2-y
@c end example stdhilb d2t_singular/standard_lib.doc:95
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:104
@ifinfo
@menu
See also:
* groebner::
* std::
* stdfglm::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{groebner};
@ref{std};
@ref{stdfglm}.
@end iftex
@c end inserted refs from d2t_singular/standard_lib.doc:104

@c ---end content stdhilb---

@c ------------------- groebner -------------
@node groebner, quot, stdhilb, standard_lib
@subsubsection groebner
@cindex groebner
@c ---content groebner---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{groebner (} ideal_expression @code{)} @*
@code{groebner (} module_expression @code{)} @*
@code{groebner (} ideal_expression@code{,} int_expression @code{)} @*
@code{groebner (} module_expression@code{,} int_expression @code{)}

@item @strong{Type:}
type of the first argument

@item @strong{Purpose:}
computes the standard basis of the first argument @code{I}
(ideal or module), by a heuristically chosen method: if the
ordering of the current ring is a local ordering, or if it is a
non-block ordering and the current ring has no parameters, then
@code{std(I)} is returned. Otherwise, @code{I} is mapped into a
ring with no parameters and ordering dp, where its Hilbert series
is computed. This is followed by a Hilbert-series based std
computation in the original ring.

@item @strong{Note:}
If a 2nd argument @code{wait} is given, then the computation proceeds
at most @code{wait} seconds. That is, if no result could be computed in
@code{wait} seconds, then the computation is interrupted, 0 is returned,
a warning message is displayed, and the global variable
@code{groebner_error} is defined.

@cindex time limit on computations
@cindex MP, groebner basis computations
@end table
@strong{Example:}
@smallexample
@c reused example groebner d2t_singular/standard_lib.doc:149 
  ring r=0,(a,b,c,d),lp;
option(prot);
ideal i=a+b+c+d,ab+ad+bc+cd,abc+abd+acd+bcd,abcd-1; // cyclic 4
groebner(i);
@expansion{} std in (0),(a,b,c,d,@@t),(dp,C)
@expansion{} [63:1]1(3)s2(2)s3s4-s5ss6-s7--
@expansion{} product criterion:8 chain criterion:5
@expansion{} std with hilb in  (0),(a,b,c,d,@@t),(lp(4),C)
@expansion{} [63:1]1(3)s2(2)s3s4-s5ss6shhhh8shh
@expansion{} product criterion:9 chain criterion:8
@expansion{} hilbert series criterion:6
@expansion{} dehomogenization
@expansion{} imap to original ring
@expansion{} simplification
@expansion{} _[1]=c2d6-c2d2-d4+1
@expansion{} _[2]=c3d2+c2d3-c-d
@expansion{} _[3]=bd4-b+d5-d
@expansion{} _[4]=bc-bd5+c2d4+cd-d6-d2
@expansion{} _[5]=b2+2bd+d2
@expansion{} _[6]=a+b+c+d
ring rp=(0,a,b),(c,d), lp;
ideal i=imap(r,i);
ideal j=groebner(i);
@expansion{} std in 0,(c,d,a,b,@@t),(dp,C)
@expansion{} [63:1]1(3)s2(2)s3s4-s5ss6-s7--
@expansion{} product criterion:8 chain criterion:5
@expansion{} std with hilb in  (0),(c,d,a,b,@@t),(lp(2),C, dp(3))
@expansion{} [63:3]1(3)s2(2)s3s4-s5ss6shhhh8shh
@expansion{} product criterion:9 chain criterion:8
@expansion{} hilbert series criterion:6
@expansion{} dehomogenization
@expansion{} imap to original ring
@expansion{} simplification
option(noprot);
j; simplify(j,1); std(i);
@expansion{} j[1]=(a3b2+a2b3-a-b)
@expansion{} _[1]=1
@expansion{} _[1]=1
if (system("with","MP")) @{groebner(i,0);@}
@expansion{} // ** groebner did not finish
@expansion{} _[1]=0
defined(groebner_error);
@expansion{} 1
@c end example groebner d2t_singular/standard_lib.doc:149
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:163
@ifinfo
@menu
See also:
* std::
* stdfglm::
* stdhilb::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{std};
@ref{stdfglm};
@ref{stdhilb}.
@end iftex
@c end inserted refs from d2t_singular/standard_lib.doc:163

@c ---end content groebner---

@c ------------------- quot -------------
@node quot, res, groebner, standard_lib
@subsubsection quot
@cindex quot
@c ---content quot---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{quot (} module_expression@code{,} module_expression @code{)}
@*@code{quot (} module_expression@code{,} module_expression@code{,}
int_expression @code{)}
@*@code{quot (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{quot (} ideal_expression@code{,} ideal_expression@code{,}
int_expression @code{)}

@item @strong{Type:}
ideal

@item @strong{Syntax:}
@code{quot (} module_expression@code{,} ideal_expression @code{)}

@item @strong{Type:}
module

@item @strong{Purpose:}
computes the quotient of the 1st and the 2nd argument.
If a 3rd argument 'n' is given the n-th method is used
(n=1...5).

@end table
@strong{Example:}
@smallexample
@c reused example quot d2t_singular/standard_lib.doc:202 
  ring r=181,(x,y,z),(c,ls);
ideal id1=maxideal(4);
ideal id2=x2+xyz,y2-z3y,z3+y5xz;
option(prot);
ideal id3=quotient(id1,id2);
@expansion{} [1023:1]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
@expansion{} product criterion:12 chain criterion:0
@expansion{} @{3@}[1023:3]8(2)s(4)s(5)s9s.s.s.s.s.s
@expansion{} product criterion:0 chain criterion:39
id3;
@expansion{} id3[1]=z2
@expansion{} id3[2]=yz
@expansion{} id3[3]=y2
@expansion{} id3[4]=xz
@expansion{} id3[5]=xy
@expansion{} id3[6]=x2
ideal id4=quot(id1,id2,1);
@expansion{} [1023:2]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:0
@expansion{} (S:3)rtrtrt
@expansion{} @{1@}[1023:3]4(2)s(4)s(5)s5s.s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:39
@expansion{} @{1@}[1023:3]4(5)s(4)s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:9
@expansion{} [255:3]3(11)s(10)sss(9)s(10)s(8)ss(7)s(8)s(6)s(7)s4(5)-----
@expansion{} product criterion:12 chain criterion:9
@expansion{} @{1@}[1023:3]4(2)sss
@expansion{} product criterion:0 chain criterion:12
@expansion{} [255:3]2(8)s(7)s(6)s3(5)ssssss4-----
@expansion{} product criterion:15 chain criterion:3
id4;
@expansion{} id4[1]=z2
@expansion{} id4[2]=yz
@expansion{} id4[3]=xz
@expansion{} id4[4]=y2
@expansion{} id4[5]=xy
@expansion{} id4[6]=x2
ideal id5=quot(id1,id2,2);
@expansion{} [1023:2]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:0
@expansion{} (S:3)rtrtrt
@expansion{} @{1@}[1023:3]4(2)sss
@expansion{} product criterion:0 chain criterion:12
@expansion{} @{1@}[1023:3]4(5)s(4)s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:9
@expansion{} [255:3]2(8)s(7)s(6)s3(5)s(4)s(3)s(2)sss
@expansion{} product criterion:15 chain criterion:0
id5;
@expansion{} id5[1]=z2
@expansion{} id5[2]=yz
@expansion{} id5[3]=xz
@expansion{} id5[4]=y2
@expansion{} id5[5]=xy
@expansion{} id5[6]=x2
@c end example quot d2t_singular/standard_lib.doc:202
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:215
@ifinfo
@menu
See also:
* quotient::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{quotient}.
@end iftex
@c end inserted refs from d2t_singular/standard_lib.doc:215

@c ---end content quot---

@c ------------------- res -------------
@node res, sprintf, quot, standard_lib
@subsubsection res
@cindex res
@c ---content res---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@c we do texinfo here:
@cindex resolution, computation of
@table @code
@item @strong{Syntax:}
@code{res (} ideal_expression@code{,} int_expression @code{[,} any_expression @code{])}
@*@code{res (} module_expression@code{,} int_expression @code{[,} any_expression @code{])}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a (possibly minimal) free resolution of an ideal or module using
a heuristically chosen method.
@* The second (int) argument (say, @code{k}) specifies the length of
the resolution. If it is not positive then @code{k} is assumed to be the
number of variables of the basering.
@* If a third argument is given, the returned resolution is minimized.

Depending on the input, the returned resolution is computed using the
following methods:
@table @asis
@item @strong{quotient rings:}
@code{nres} (classical method using syzygies) , see @ref{nres}.

@item @strong{homogeneous ideals and k=0:}
@code{lres} (La'Scala's method), see @ref{lres}.

@item @strong{not minimized resolution and (homogeneous input with k not 0, or local rings):}
@code{sres} (Schreyer's method), see @ref{sres}.

@item @strong{all other inputs:}
@code{mres} (classical method), see @ref{mres}.
@end table
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@end table
@c inserted refs from d2t_singular/standard_lib.doc:263
@ifinfo
@menu
See also
* betti::
* hres::
* ideal::
* lres::
* minres::
* module::
* mres::
* nres::
* resolution::
* sres::
@end menu
@end ifinfo
@iftex
See also
@ref{betti};
@ref{hres};
@ref{ideal};
@ref{lres};
@ref{minres};
@ref{module};
@ref{mres};
@ref{nres};
@ref{resolution};
@ref{sres}.
@end iftex
@c end inserted refs from d2t_singular/standard_lib.doc:263

@strong{Example:}
@smallexample
@c reused example res d2t_singular/standard_lib.doc:279 
  ring r=0,(x,y,z),dp;
ideal i=xz,yz,x3-y3;
def l=res(i,0); // homogeneous ideal: uses lres
l;
@expansion{}  1      3      2      
@expansion{} r <--  r <--  r
@expansion{} 
@expansion{} 0      1      2      
@expansion{} resolution not minimized yet
@expansion{} 
print(betti(l), "betti"); // input to betti may be of type resolution
@expansion{}            0     1     2
@expansion{} ------------------------
@expansion{}     0:     1     -     -
@expansion{}     1:     -     2     1
@expansion{}     2:     -     1     1
@expansion{} ------------------------
@expansion{} total:     1     3     2
l[2];         // element access may take some time
@expansion{} _[1]=-x*gen(1)+y*gen(2)
@expansion{} _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)
i=i,x+1;
l=res(i,0);   // inhomogeneous ideal: uses mres
l;
@expansion{}  1      3      3      1      
@expansion{} r <--  r <--  r <--  r
@expansion{} 
@expansion{} 0      1      2      3      
@expansion{} resolution not minimized yet
@expansion{} 
ring rs=0,(x,y,z),ds;
ideal i=imap(r,i);
def l=res(i,0); // local ring not minimized: uses sres
l;
@expansion{}   1       1       
@expansion{} rs <--  rs
@expansion{} 
@expansion{} 0       1       
@expansion{} resolution not minimized yet
@expansion{} 
res(i,0,0);     // local ring and minimized: uses mres
@expansion{}   1       1       
@expansion{} rs <--  rs
@expansion{} 
@expansion{} 0       1       
@expansion{} 
@c end example res d2t_singular/standard_lib.doc:279
@end smallexample
@c ---end content res---

@c ------------------- sprintf -------------
@node sprintf, fprintf, res, standard_lib
@subsubsection sprintf
@cindex sprintf
@c ---content sprintf---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{sprintf (} string_expression @code{[,} any_expressions
@code{] )}

@item @strong{Return:}
string

@item @strong{Purpose:}
@code{sprintf(fmt,...);} performs output formatting. The first
argument is a format control string. Additional arguments may be
required, depending on the content of the control string. A series
of output characters is generated as directed by the control string;
these characters are returned as a string. @*
The control string @code{fmt} is simply text to be copied,
except that the string may contain conversion specifications.@*
Do @code{help print;} for a listing of valid conversion
specifications. As an addition to the conversions of @code{print},
the @code{%n} and @code{%2} conversion specification does not
consume an additional argument, but simply generates a newline
character.

@item @strong{Note:}
If one of the additional arguments is a list, then it should be
enclosed once more into a @code{list()} command, since passing a list
as an argument flattens the list by one level.

@end table
@strong{Example:}
@smallexample
@c reused example sprintf d2t_singular/standard_lib.doc:335 
  ring r=0,(x,y,z),dp;
module m=[1,y],[0,x+z];
intmat M=betti(mres(m,0));
list l = r, m, M;
string s = sprintf("s:%s,%n l:%l", 1, 2); s;
@expansion{} s:1,
@expansion{}  l:int(2)
s = sprintf("s:%n%s", l); s;
@expansion{} s:
@expansion{} (0),(x,y,z),(dp(3),C)
s = sprintf("s:%2%s", list(l)); s;
@expansion{} s:
@expansion{} (0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
s = sprintf("2l:%n%2l", list(l)); s;
@expansion{} 2l:
@expansion{} list("(0),(x,y,z),(dp(3),C)",
@expansion{} module(y*gen(2)+gen(1),
@expansion{} x*gen(2)+z*gen(2)),
@expansion{} intmat(intvec(1,1 ),1,2))
@expansion{} 
s = sprintf("%p", list(l)); s;
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
s = sprintf("%;", list(l)); s;
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
s = sprintf("%b", M); s;
@expansion{}            0     1
@expansion{} ------------------
@expansion{}     0:     1     1
@expansion{} ------------------
@expansion{} total:     1     1
@expansion{} 
@c end example sprintf d2t_singular/standard_lib.doc:335
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:349
@ifinfo
@menu
See also:
* fprintf::
* print::
* printf::
* string::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{fprintf};
@ref{print};
@ref{printf};
@ref{string}.
@end iftex
@c end inserted refs from d2t_singular/standard_lib.doc:349

@c ---end content sprintf---

@c ------------------- fprintf -------------
@node fprintf, printf, sprintf, standard_lib
@subsubsection fprintf
@cindex fprintf
@c ---content fprintf---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{fprintf (} link_expression@code{,} string_expression @code{[,}
any_expressions@code{] )}

@item @strong{Return:}
none

@item @strong{Purpose:}
@code{fprintf(l,fmt,...);} performs output formatting.
The second argument is a format control string. Additional
arguments may be required, depending on the content of the
control string. A series of output characters is generated as
directed by the control string; these characters are
written to the link l.
The control string @code{fmt} is simply text to be copied, except
that the string may contain conversion specifications.@*
Do @code{help print;} for a listing of valid conversion
specifications. As an addition to the conversions of @code{print},
the @code{%n} and @code{%2} conversion specification does not
consume an additional argument, but simply generates a newline
character.

@item @strong{Note:}
If one of the additional arguments is a list, then it should be
enclosed once more into a @code{list()} command, since passing
a list as an argument flattens the list by one level.

@end table
@strong{Example:}
@smallexample
@c reused example fprintf d2t_singular/standard_lib.doc:393 
  ring r=0,(x,y,z),dp;
module m=[1,y],[0,x+z];
intmat M=betti(mres(m,0));
list l=r,m,M;
link li="";   // link to stdout
fprintf(li,"s:%s,l:%l",1,2);
@expansion{} s:1,l:int(2)
fprintf(li,"s:%s",l);
@expansion{} s:(0),(x,y,z),(dp(3),C)
fprintf(li,"s:%s",list(l));
@expansion{} s:(0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
fprintf(li,"2l:%2l",list(l));
@expansion{} 2l:list("(0),(x,y,z),(dp(3),C)",
@expansion{} module(y*gen(2)+gen(1),
@expansion{} x*gen(2)+z*gen(2)),
@expansion{} intmat(intvec(1,1 ),1,2))
@expansion{} 
fprintf(li,"%p",list(l));
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
fprintf(li,"%;",list(l));
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
fprintf(li,"%b",M);
@expansion{}            0     1
@expansion{} ------------------
@expansion{}     0:     1     1
@expansion{} ------------------
@expansion{} total:     1     1
@expansion{} 
@c end example fprintf d2t_singular/standard_lib.doc:393
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:408
@ifinfo
@menu
See also:
* print::
* printf::
* sprintf::
* string::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{print};
@ref{printf};
@ref{sprintf};
@ref{string}.
@end iftex
@c end inserted refs from d2t_singular/standard_lib.doc:408

@c ---end content fprintf---

@c ------------------- printf -------------
@node printf,, fprintf, standard_lib
@subsubsection printf
@cindex printf
@c ---content printf---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{printf (} string_expression @code{[,} any_expressions@code{] )}

@item @strong{Return:}
none

@item @strong{Purpose:}
@code{printf(fmt,...);} performs output formatting. The first
argument is a format control string. Additional arguments may be
required, depending on the content of the control string. A series
of output characters is generated as directed by the control string;
these characters are displayed (i.e., printed to standard out). @*
The control string @code{fmt} is simply text to be copied, except
that the string may contain conversion specifications. @*
Do @code{help print;} for a listing of valid conversion
specifications. As an addition to the conversions of @code{print},
the @code{%n} and @code{%2} conversion specification does not
consume an additional argument, but simply generates a newline
character.

@item @strong{Note:}
If one of the additional arguments is a list, then it should be
enclosed once more into a @code{list()} command, since passing a
list as an argument flattens the list by one level.

@end table
@strong{Example:}
@smallexample
@c reused example printf d2t_singular/standard_lib.doc:450 
  ring r=0,(x,y,z),dp;
module m=[1,y],[0,x+z];
intmat M=betti(mres(m,0));
list l=r,m,M;
printf("s:%s,l:%l",1,2);
@expansion{} s:1,l:int(2)
printf("s:%s",l);
@expansion{} s:(0),(x,y,z),(dp(3),C)
printf("s:%s",list(l));
@expansion{} s:(0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
printf("2l:%2l",list(l));
@expansion{} 2l:list("(0),(x,y,z),(dp(3),C)",
@expansion{} module(y*gen(2)+gen(1),
@expansion{} x*gen(2)+z*gen(2)),
@expansion{} intmat(intvec(1,1 ),1,2))
@expansion{} 
printf("%p",list(l));
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
printf("%;",list(l));
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
printf("%b",M);
@expansion{}            0     1
@expansion{} ------------------
@expansion{}     0:     1     1
@expansion{} ------------------
@expansion{} total:     1     1
@expansion{} 
@c end example printf d2t_singular/standard_lib.doc:450
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:464
@ifinfo
@menu
See also:
* fprintf::
* print::
* sprintf::
* string::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{fprintf};
@ref{print};
@ref{sprintf};
@ref{string}.
@end iftex
@c end inserted refs from d2t_singular/standard_lib.doc:464

@c ---end content printf---
