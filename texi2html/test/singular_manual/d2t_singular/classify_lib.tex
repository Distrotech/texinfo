@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/classify_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/classify_lib.doc INSTEAD
@c library version: (1.48.2.4,2002/04/11)
@c library file: ../Singular/LIB/classify.lib
@cindex classify.lib
@cindex classify_lib
@table @asis
@item @strong{Library:}
classify.lib
@item @strong{Purpose:}
  Arnold Classifier of Singularities
@item @strong{Authors:}
Kai Krueger, krueger@@mathematik.uni-kl.de
@*Corina Baciu, baciu@@mathematik.uni-kl.de

@item @strong{Overview:}
A library for classifying isolated hypersurface singularities w.r.t. right
equivalence, based on the determinator of singularities by V.I. Arnold.

@end table

@strong{Procedures:}
@menu
* basicinvariants:: computes Milnor number, determinacy-bound and corank of
* classify:: normal form of poly f determined with Arnold's method
* corank:: computes the corank of f (i.e. of the Hessian of f)
* Hcode:: coding of intvec v according to the number repetitions
* init_debug:: print trace and debugging information depending on int n
* internalfunctions:: display names of internal procedures of this library
* milnorcode:: Hilbert poly of [e-th] Milnor algebra coded with Hcode
* morsesplit:: residual part of f after applying the splitting lemma
* quickclass:: normal form of f determined by invariants (milnorcode)
* singularity:: normal form of singularity given by its name s and index
* swap:: returns b,a
* A_L:: shortcut for quickclass(f) or normalform(s)
* normalform:: normal form of singularity given by its name s
* debug_log:: print trace and debugging information w.r.t level>@@DeBug
@end menu
@c ---end content LibInfo---

@c ------------------- basicinvariants -------------
@node basicinvariants, classify,, classify_lib
@subsubsection basicinvariants
@cindex basicinvariants
@c ---content basicinvariants---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
basicinvariants(f); f = poly

@item @strong{Compute:}
Compute basic invariants of f: an upper bound d for the
determinacy, the milnor number mu and the corank c of f

@item @strong{Return:}
intvec: d, mu, c

@end table
@strong{Example:}
@smallexample
@c computed example basicinvariants d2t_singular/classify_lib.doc:61 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
basicinvariants((x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3);
@expansion{} 5,4,2
@c end example basicinvariants d2t_singular/classify_lib.doc:61
@end smallexample
@c ---end content basicinvariants---

@c ------------------- classify -------------
@node classify, corank, basicinvariants, classify_lib
@subsubsection classify
@cindex classify
@c ---content classify---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
classify(f); f=poly

@item @strong{Compute:}
normal form and singularity type of f with respect to right
equivalence, as given in the book "Singularities of differentiable
maps, Volume I" by V.I. Arnold, S.M. Gusein-Zade, A.N. Varchenko

@item @strong{Return:}
normal form of f, of type poly

@item @strong{Remark:}
This version of classify is only beta. Please send bugs and
comments to: "Kai Krueger" <krueger@@mathematik.uni-kl.de> @*
Be sure to have at least Singular version 1.0.1. Updates can be
found at: @*
URL=http://www.mathematik.uni-kl.de/~krueger/Singular/

@item @strong{Note:}
type init_debug(n); (0 <= n <= 10) in order to get intermediate
information, higher values of n give more information.
@*The proc creates several global objects with names all starting
with @@, hence there should be no name conflicts

@end table
@strong{Example:}
@smallexample
@c computed example classify d2t_singular/classify_lib.doc:104 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
classify(f);
@expansion{} About the singularity :
@expansion{}           Milnor number(f)   = 4
@expansion{}           Corank(f)          = 2
@expansion{}           Determinacy       <= 5
@expansion{} Guessing type via Milnorcode:   D[k]=D[4]
@expansion{} 
@expansion{} Computing normal form ...
@expansion{} I have to apply the splitting lemma. This will take some time....:-)
@expansion{}    Arnold step number 4
@expansion{} The singularity
@expansion{}    -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
@expansion{} is R-equivalent to D[4].
@expansion{}    Milnor number = 4
@expansion{}    modality      = 0
@expansion{} 2z2+x2y+y3
init_debug(3);
@expansion{} Debugging level change from  0  to  3
classify(f);
@expansion{} Computing Basicinvariants of f ...
@expansion{} About the singularity :
@expansion{}           Milnor number(f)   = 4
@expansion{}           Corank(f)          = 2
@expansion{}           Determinacy       <= 5
@expansion{} Hcode: 1,2,1,0,0
@expansion{} Milnor code :  1,1,1
@expansion{} Debug:(2):  entering HKclass3_teil_1 1,1,1
@expansion{} Debug:(2):  finishing HKclass3_teil_1
@expansion{} Guessing type via Milnorcode:   D[k]=D[4]
@expansion{} 
@expansion{} Computing normal form ...
@expansion{} I have to apply the splitting lemma. This will take some time....:-)
@expansion{} Debug:(3):  Split the polynomial below using determinacy:  5
@expansion{} Debug:(3):  9y2-12yz+4z2-x3+6x2y-4x2z+xyz+x4+3x2y3
@expansion{} Debug:(2):  Permutations: 3,2,1
@expansion{} Debug:(2):  Permutations: 3,2,1
@expansion{} Debug:(2):  rank determined with Morse rg= 1
@expansion{} Residual singularity f= -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
@expansion{} Step 3
@expansion{}    Arnold step number 4
@expansion{} The singularity
@expansion{}    -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
@expansion{} is R-equivalent to D[4].
@expansion{}    Milnor number = 4
@expansion{}    modality      = 0
@expansion{} Debug:(2):  Decode:
@expansion{} Debug:(2):  S_in= D[4]   s_in= D[4]                          
@expansion{} Debug:(2):  Looking for Normalform of  D[k] with (k,r,s) = ( 4 , 0 , 0 )
@expansion{} Debug:(2):  Opening Singalarity-database:  
@expansion{}  DBM: NFlist
@expansion{} Debug:(2):  DBMread( D[k] )= x2y+y^(k-1) .
@expansion{} Debug:(2):  S= f = x2y+y^(k-1);  Tp= x2y+y^(k-1) Key= I_D[k]
@expansion{} Polynom f= x2y+y3   crk= 2   Mu= 4  MlnCd= 1,1,1
@expansion{} Debug:(2):  Info= x2y+y3
@expansion{} Debug:(2):  Normal form NF(f)= 2*x(3)^2+x(1)^2*x(2)+x(2)^3
@expansion{} 2z2+x2y+y3
@c end example classify d2t_singular/classify_lib.doc:104
@end smallexample
@c ---end content classify---

@c ------------------- corank -------------
@node corank, Hcode, classify, classify_lib
@subsubsection corank
@cindex corank
@c ---content corank---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
corank(f); f=poly

@item @strong{Return:}
the corank of the Hessian matrix of f, of type int

@item @strong{Remark:}
corank(f) is the number of variables occurring in the residual
singularity after applying 'morsesplit' to f

@end table
@strong{Example:}
@smallexample
@c computed example corank d2t_singular/classify_lib.doc:136 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
corank(f);
@expansion{} 2
@c end example corank d2t_singular/classify_lib.doc:136
@end smallexample
@c ---end content corank---

@c ------------------- Hcode -------------
@node Hcode, init_debug, corank, classify_lib
@subsubsection Hcode
@cindex Hcode
@c ---content Hcode---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
Hcode(v); v=intvec

@item @strong{Return:}
intvec, coding v according to the number of successive
repetitions of an entry

@end table
@strong{Example:}
@smallexample
@c computed example Hcode d2t_singular/classify_lib.doc:163 
LIB "classify.lib";
intvec v1 = 1,3,5,5,2;
Hcode(v1);
@expansion{} 1,0,1,0,2,0,0,1,0
intvec v2 = 1,2,3,4,4,4,4,4,4,4,3,2,1;
Hcode(v2);
@expansion{} 1,1,1,7,1,1,1
@c end example Hcode d2t_singular/classify_lib.doc:163
@end smallexample
@c ---end content Hcode---

@c ------------------- init_debug -------------
@node init_debug, internalfunctions, Hcode, classify_lib
@subsubsection init_debug
@cindex init_debug
@c ---content init_debug---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
init_debug([level]); level=int

@item @strong{Compute:}
Set the global variable @@DeBug to level. The variable @@DeBug is
used by the function debug_log(level, list of strings) to know
when to print the list of strings. init_debug() reports only
changes of @@DeBug.

@item @strong{Note:}
The procedure init_debug(n); is useful as trace-mode. n may
range from 0 to 10, higher values of n give more information.

@end table
@strong{Example:}
@smallexample
@c computed example init_debug d2t_singular/classify_lib.doc:197 
LIB "classify.lib";
init_debug();
debug_log(1,"no trace information printed");
init_debug(1);
@expansion{} Debugging level change from  0  to  1
debug_log(1,"some trace information");
@expansion{} some trace information
init_debug(2);
@expansion{} Debugging level change from  1  to  2
debug_log(2,"nice for debugging scripts");
@expansion{} Debug:(2):  nice for debugging scripts
init_debug(0);
@expansion{} Debugging switched off.
@c end example init_debug d2t_singular/classify_lib.doc:197
@end smallexample
@c ---end content init_debug---

@c ------------------- internalfunctions -------------
@node internalfunctions, milnorcode, init_debug, classify_lib
@subsubsection internalfunctions
@cindex internalfunctions
@c ---content internalfunctions---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
internalfunctions();

@item @strong{Return:}
nothing, display names of internal procedures of classify.lib

@end table
@strong{Example:}
@smallexample
@c computed example internalfunctions d2t_singular/classify_lib.doc:227 
LIB "classify.lib";
internalfunctions();
@expansion{}    Internal functions for the classification using Arnold's method,
@expansion{}    the function numbers correspond to numbers in Arnold's classifier:
@expansion{} Klassifiziere(poly f);      //determine the type of the singularity f
@expansion{}   Funktion1bis (poly f, list cstn)
@expansion{}   Funktion3 (poly f, list cstn)
@expansion{}   Funktion6 (poly f, list cstn)
@expansion{}   Funktion13 (poly f, list cstn)
@expansion{}   Funktion17 (poly f, list cstn)
@expansion{}   Funktion25 (poly f, list cstn)
@expansion{}   Funktion40 (poly f, list cstn, int k)
@expansion{}   Funktion47 (poly f, list cstn)
@expansion{}   Funktion50 (poly f, list cstn)
@expansion{}   Funktion58 (poly fin, list cstn)
@expansion{}   Funktion59 (poly f, list cstn)
@expansion{}   Funktion66 (poly f, list cstn)
@expansion{}   Funktion82 (poly f, list cstn)
@expansion{}   Funktion83 (poly f, list cstn)
@expansion{}   Funktion91 (poly f, list cstn, int k)
@expansion{}   Funktion92 (poly f, list cstn, int k)
@expansion{}   Funktion93 (poly f, list cstn, int k)
@expansion{}   Funktion94 (poly f, list cstn, int k)
@expansion{}   Funktion95 (poly f, list cstn, int k)
@expansion{}   Funktion96 (poly f, list cstn, int k)
@expansion{}   Funktion97 (poly f, list cstn)
@expansion{}   Isomorphie_s82_x (poly f, poly fk, int k)
@expansion{}   Isomorphie_s82_z (poly f, poly fk, int k)
@expansion{}   Isomorphie_s17 (poly f, poly fk, int k, int ct)
@expansion{}   printresult (string f,string typ,int Mu,int m,int corank,int K)
@expansion{}   
@expansion{}    Internal functions for the classifcation by invariants:
@expansion{}   Cubic (poly f)
@expansion{}   parity (int e)             //return the parity of e
@expansion{}   HKclass (intvec i)
@expansion{}   HKclass3( intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass3_teil_1 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass5 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass5_teil_1 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass5_teil_2 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass7 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass7_teil_1 (intvec i, string SG_Typ, int cnt)
@expansion{}   
@expansion{}    Internal functions for the Morse-splitting lemma:
@expansion{}   Morse(poly fi, int K, int corank)  //splitting lemma itself
@expansion{}   Coeffs (list #)
@expansion{}   Coeff
@expansion{}   
@expansion{}    Internal functions providing tools:
@expansion{}   ReOrder(poly f)
@expansion{}   Singularitaet(string typ,int k,int r,int s,poly a,poly b,poly c,poly d)
@expansion{}   RandomPolyK
@expansion{}   Faktorisiere(poly f, poly g, int p, int k)   compute g = (ax+by^k)^p
@expansion{}   Teile(poly f, poly g);             //divides f by g
@expansion{}   GetRf(poly f, int n);
@expansion{}   Show(poly f);
@expansion{}   checkring();
@expansion{}   DecodeNormalFormString(string s);
@expansion{}   Setring(int n, string ringname);
@expansion{}   
@c end example internalfunctions d2t_singular/classify_lib.doc:227
@end smallexample
@c ---end content internalfunctions---

@c ------------------- milnorcode -------------
@node milnorcode, morsesplit, internalfunctions, classify_lib
@subsubsection milnorcode
@cindex milnorcode
@c ---content milnorcode---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
milnorcode(f[,e]); f=poly, e=int

@item @strong{Return:}
intvec, coding the Hilbert function of the e-th Milnor algebra
of f, i.e. of basering/(jacob(f)^e) (default e=1), according
to proc Hcode

@end table
@strong{Example:}
@smallexample
@c computed example milnorcode d2t_singular/classify_lib.doc:253 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
poly f=x2y+y3+z2;
milnorcode(f);
@expansion{} 1,1,1
milnorcode(f,2);  // a big second argument may result in memory overflow
@expansion{} 1,0,1,0,2,0,0,1,0
@c end example milnorcode d2t_singular/classify_lib.doc:253
@end smallexample
@c ---end content milnorcode---

@c ------------------- morsesplit -------------
@node morsesplit, quickclass, milnorcode, classify_lib
@subsubsection morsesplit
@cindex morsesplit
@c ---content morsesplit---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
morsesplit(f); f=poly

@item @strong{Return:}
Normal form of f in M^3 after application of the splitting lemma

@item @strong{Compute:}
apply the splitting lemma (generalized Morse lemma) to f

@end table
@strong{Example:}
@smallexample
@c computed example morsesplit d2t_singular/classify_lib.doc:283 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
export r;
@expansion{} // ** `r` is already global
init_debug(1);
@expansion{} Debugging level is set to  1
poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
poly g=morsesplit(f);
@expansion{} Residual singularity f= -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
g;
@expansion{} -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
@c end example morsesplit d2t_singular/classify_lib.doc:283
@end smallexample
@c ---end content morsesplit---

@c ------------------- quickclass -------------
@node quickclass, singularity, morsesplit, classify_lib
@subsubsection quickclass
@cindex quickclass
@c ---content quickclass---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
quickclass(f); f=poly

@item @strong{Return:}
Normal form of f in Arnold's list

@item @strong{Remark:}
try to determine the normal form of f by invariants, mainly by
computing the Hilbert function of the Milnor algebra,
no coordinate change is needed (see also proc 'milnorcode').

@end table
@strong{Example:}
@smallexample
@c computed example quickclass d2t_singular/classify_lib.doc:317 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
quickclass(f);
@expansion{} Singularity R-equivalent to :  D[k]=D[4]
@expansion{} normal form : z2+x2y+y3
@expansion{} z2+x2y+y3
@c end example quickclass d2t_singular/classify_lib.doc:317
@end smallexample
@c ---end content quickclass---

@c ------------------- singularity -------------
@node singularity, swap, quickclass, classify_lib
@subsubsection singularity
@cindex singularity
@c ---content singularity---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
singularity(t, l); t=string (name of singularity),
@*l=list of integers/polynomials (indices/parameters of singularity)

@item @strong{Compute:}
get the singularity named by type t from the database.
list l is as follows: @*
l= k [,r [,s [,a [,b [,c [,d]..]: k,r,s=int a,b,c,d=poly. @*
The name of the dbm-database file is: NFlist.[dir,pag].
The file is found in the current directory. If it does not
exist, please run the script MakeDBM first.

@item @strong{Return:}
Normal form and corank of the singularity named by type t and its
index (indices) l.

@end table
@strong{Example:}
@smallexample
@c computed example singularity d2t_singular/classify_lib.doc:353 
LIB "classify.lib";
ring r=0,(x,y,z),(c,ds);
init_debug(0);
singularity("E[6k]",6);
@expansion{} [1]:
@expansion{}    x3+xy13+y19
@expansion{} [2]:
@expansion{}    2
singularity("T[k,r,s]", 3, 7, 5);
@expansion{} [1]:
@expansion{}    x3+xyz+z5+y7
@expansion{} [2]:
@expansion{}    3
poly f=y;
singularity("J[k,r]", 4, 0, 0, f);
@expansion{} [1]:
@expansion{}    x3+x2y4+y13
@expansion{} [2]:
@expansion{}    2
@c end example singularity d2t_singular/classify_lib.doc:353
@end smallexample
@c ---end content singularity---

@c ------------------- swap -------------
@node swap, A_L, singularity, classify_lib
@subsubsection swap
@cindex swap
@c ---content swap---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
swap(a,b);

@item @strong{Return:}
b,a if b,a is the input (any type)

@end table
@strong{Example:}
@smallexample
@c computed example swap d2t_singular/classify_lib.doc:382 
LIB "classify.lib";
swap("variable1","variable2");
@expansion{} variable2 variable1
@c end example swap d2t_singular/classify_lib.doc:382
@end smallexample
@c ---end content swap---

@c ------------------- A_L -------------
@node A_L, normalform, swap, classify_lib
@subsubsection A_L
@cindex A_L
@c ---content A_L---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
A_L(f); f poly
@*A_L(s); s string, the name of the singularity

@item @strong{Compute:}
the normal form of f in Arnold's list of singularities in case 1,
in case 2 nothing has to be computed.

@item @strong{Return:}
A_L(f): compute via 'milnorcode' the class of f and return the normal
form of f found in the database.
@*A_L("name"): get the normal form from the database for the
singularity given by its name.

@end table
@strong{Example:}
@smallexample
@c computed example A_L d2t_singular/classify_lib.doc:414 
LIB "classify.lib";
ring r=0,(a,b,c),ds;
poly f=A_L("E[13]");
f;
@expansion{} c2+a3+ab5+b8
A_L(f);
@expansion{} Singularity R-equivalent to :  E[6k+1]=E[13]
@expansion{} normal form : c2+a3+ab5+b8
@expansion{} c2+a3+ab5+b8
@c end example A_L d2t_singular/classify_lib.doc:414
@end smallexample
@c ---end content A_L---

@c ------------------- normalform -------------
@node normalform, debug_log, A_L, classify_lib
@subsubsection normalform
@cindex normalform
@c ---content normalform---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
normalform(s); s=string

@item @strong{Return:}
Arnold's normal form of singularity with name s

@end table
@strong{Example:}
@smallexample
@c computed example normalform d2t_singular/classify_lib.doc:441 
LIB "classify.lib";
ring r=0,(a,b,c),ds;
normalform("E[13]");
@expansion{} c2+a3+ab5+b8
@c end example normalform d2t_singular/classify_lib.doc:441
@end smallexample
@c ---end content normalform---

@c ------------------- debug_log -------------
@node debug_log,, normalform, classify_lib
@subsubsection debug_log
@cindex debug_log
@c ---content debug_log---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
debug_log(level,li); level=int, li=comma separated "message" list

@item @strong{Compute:}
print "messages" if level>=@@DeBug.
@*useful for user-defined trace messages.

@end table
@strong{Example:}
@smallexample
@c computed example debug_log d2t_singular/classify_lib.doc:467 
LIB "classify.lib";
example init_debug;
@expansion{} // proc init_debug from lib classify.lib
@expansion{} EXAMPLE:
@expansion{}   init_debug();
@expansion{}   debug_log(1,"no trace information printed");
@expansion{}   init_debug(1);
@expansion{} Debugging level change from  0  to  1
@expansion{}   debug_log(1,"some trace information");
@expansion{} some trace information
@expansion{}   init_debug(2);
@expansion{} Debugging level change from  1  to  2
@expansion{}   debug_log(2,"nice for debugging scripts");
@expansion{} Debug:(2):  nice for debugging scripts
@expansion{}   init_debug(0);
@expansion{} Debugging switched off.
@expansion{} 
@c end example debug_log d2t_singular/classify_lib.doc:467
@end smallexample
@c inserted refs from d2t_singular/classify_lib.doc:472
@ifinfo
@menu
See also:
* init_debug::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{init_debug}.
@end iftex
@c end inserted refs from d2t_singular/classify_lib.doc:472

@c ---end content debug_log---
