@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/hnoether_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/hnoether_lib.doc INSTEAD
@c library version: (1.29.2.14,2002/10/21)
@c library file: ../Singular/LIB/hnoether.lib
@cindex hnoether.lib
@cindex hnoether_lib
@table @asis
@item @strong{Library:}
hnoether.lib
@item @strong{Purpose:}
   Hamburger-Noether (Puiseux) Development
@item @strong{Author:}
Martin Lamm, lamm@@mathematik.uni-kl.de

@item @strong{Overview:}
A library for computing the Hamburger-Noether, resp. Puiseux, development
of a plane curve singularity following [Campillo, A.: Algebroid curves
in positive characteristic, Springer LNM 813 (1980)]. @*
The library contains also procedures for computing the (topological)
numerical invariants of plane curve singularities.

@end table

@strong{Main procedures:}
@menu
* hnexpansion:: Hamburger-Noether (H-N) development of f
* sethnering:: changes to the hnering created by hnexpansion
* develop:: H-N development of irreducible curves
* extdevelop:: extension of the H-N development hne of f
* parametrisation:: a parametrization of f
* displayHNE:: display H-N development as an ideal
* invariants:: invariants of f, e.g. the characteristic exponents
* displayInvariants:: display invariants of f
* multsequence:: sequence of multiplicities
* displayMultsequence:: display sequence of multiplicities
* intersection:: intersection multiplicity of two curves
* stripHNE:: reduce amount of memory consumed by hne
* is_irred:: test if f is irreducible
* delta:: delta invariant of f
* newtonpoly:: (local) Newton polygon of f
* is_NND:: test if f is Newton non-degenerate
@end menu
@strong{Auxiliary procedures:}
@menu
* puiseux2generators:: convert Puiseux pairs to generators of semigroup
* separateHNE:: number of quadratic transf. needed for separation
* squarefree:: a squarefree divisor of the poly f
* allsquarefree:: the maximal squarefree divisor of the poly f
* further_hn_proc:: show further procedures useful for interactive use
@end menu
@cindex Hamburger-Noether expansion
@cindex Puiseux expansion
@cindex curve singularities
@c ---end content LibInfo---

@c ------------------- hnexpansion -------------
@node hnexpansion, sethnering,, hnoether_lib
@subsubsection hnexpansion
@cindex hnexpansion
@c ---content hnexpansion---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
hnexpansion(f); or hnexpansion(f,"ess"); f poly

@item @strong{Usage:}
hnexpansion(f); f poly

@item @strong{Assume:}
f is a bivariate polynomial (in the first 2 ring variables)

@item @strong{Create:}
ring with variables @code{x,y} and ordering @code{ls} over a
field extension of the current basering's ground field, 
since the Hamburger-Noether development usually does not exist
in the originally given basering. The field extension is chosen
minimally.@*
Moreover, in the ring a list @code{hne} of lists @code{hne[i]} is
created (corresponding to the output of @code{develop(f[i])},
f[i] a branch of f, but the last entry being omitted).

@table @asis
@item @code{hne[i][1]}; matrix:
         Each row contains the coefficients of the corresponding line of the
         Hamburger-Noether expansion (HNE) for f[i]. The end of the line is
         marked in the matrix by the first ring variable (usually x).
@item @code{hne[i][2]}; intvec:
         indicating the length of lines of the HNE
@item @code{hne[i][3]}; int:
         0  if the 1st ring variable was transversal (with respect to f[i]), @*
         1  if the variables were changed at the beginning of the
            computation, @*
        -1  if an error has occurred.
@item @code{hne[i][4]}; poly:
         the transformed polynomial of f[i] to make it possible to extend the
         Hamburger-Noether development a posteriori without having to do
         all the previous calculation once again (0 if not needed)
@end table

@item @strong{Return:}
a list, say @code{hn}, containing the created ring

@item @strong{Note:}
to use the ring type: @code{def HNEring=hn[i]; setring HNEring;}.
@*
If f is known to be irreducible as a power series, @code{develop(f)}
could be chosen instead to avoid the change of basering. @*
Increasing @code{printlevel} leads to more and more comments.

@item @strong{Usage:}
hnexpansion(f,"ess"); f poly

@item @strong{Assume:}
f is a bivariate polynomial (in the first 2 ring variables)

@item @strong{Create:}
ring with variables @code{x,y} and ordering @code{ls} over a
field extension of the current basering's ground field, 
since the Hamburger-Noether development usually does not exist
in the originally given basering. The field extension is chosen
minimally.
@*
Moreover, in the ring a list @code{hne} of lists @code{hne[i]} is
created (corresponding to the output of @code{develop(f[i])}, f[i] an
"essential" branch of f, but the last entry being omitted). See
@code{hnexpansion} above for more details.

@item @strong{Return:}
a list, say @code{hn}, containing the created ring

@item @strong{Note:}
to use the ring type: @code{def hnering=hn[i]; setring hnering;}.
@*
Alternatively you may use the procedure sethnering and type:
@code{sethnering(hn);}
@*
If the HNE needs a field extension, some of the branches will be
conjugate. In this case @code{hnexpansion(f,"ess")} reduces the
computation to one representative for each group of conjugate
branches.@*
Note that the degree of each branch is in general less than the degree
of the field extension in which all HNEs can be put.@*
Use @code{hnexpansion(f)} to compute a complete HNE, i.e., a HNE for
all branches.@*
Increasing @code{printlevel} leads to more and more comments.

@end table
@strong{Example:}
@smallexample
@c computed example hnexpansion d2t_singular/hnoether_lib.doc:150 
LIB "hnoether.lib";
ring r=0,(x,y),ls;
list hn=hnexpansion(x4-y6);
show(hn);
@expansion{} // list, 1 element(s):
@expansion{} [1]:
@expansion{}    // ring: (0),(x,y),(ls(2),C);
@expansion{}    // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // hne                  [0]  list, size: 2
def hnering=hn[1];
setring hnering;
size(hne);           // number of branches
@expansion{} 2
print(hne[1][1]);    // HN-matrix of 1st branch
@expansion{} 0,x,0,
@expansion{} 0,1,x 
parametrisation(hne);    // parametrization of the two branches
@expansion{} [1]:
@expansion{}    _[1]=x3
@expansion{}    _[2]=x2
@expansion{} [2]:
@expansion{}    _[1]=-x3
@expansion{}    _[2]=-x2
/////////////////////////////////////////////////////////
ring s=2,(x,y),ls;
poly f=(x4+x2y+y2)*(x3+xy2+y3);
// --------- compute all branches: ---------
hn=hnexpansion(f);
@expansion{} // new minimal polynomial: a6+a5+a3+a2+1
hnering=hn[1];
setring hnering;
displayHNE(hne[1]);   // HN-matrix of 1st branch
@expansion{} HNE[1]=y+(a^4+a+1)*z(0)
@expansion{} HNE[2]=x+z(0)
displayHNE(hne[4]);   // HN-matrix of 4th branch
@expansion{} HNE[1]=y+(a^4+a^2+a+1)*z(0)^2
@expansion{} HNE[2]=x+z(0)
setring s;
// --- compute only one of conjugate branches: ---
hn=hnexpansion(f,"ess");
@expansion{} // new minimal polynomial: a6+a5+a3+a2+1
hnering=hn[1];
setring hnering;
displayHNE(hne);
@expansion{} // Hamburger-Noether development of branch nr.1:
@expansion{} HNE[1]=y+(a^4+a^2)*z(0)
@expansion{} HNE[2]=x+z(0)
@expansion{} 
@expansion{} // Hamburger-Noether development of branch nr.2:
@expansion{} HNE[1]=y+(a^4+a^2+a)*z(0)^2
@expansion{} HNE[2]=x+z(0)
@expansion{} 
// no. 1 of hnexpansion(f,"ess") represents no. 1 - 3 of hnexpansion(f) and
// no. 2 of hnexpansion(f,"ess") represents no. 4 + 5 of hnexpansion(f)
@c end example hnexpansion d2t_singular/hnoether_lib.doc:150
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:179
@ifinfo
@menu
See also:
* develop::
* displayHNE::
* extdevelop::
* parametrisation::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{displayHNE};
@ref{extdevelop};
@ref{parametrisation}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:179

@c ---end content hnexpansion---

@c ------------------- sethnering -------------
@node sethnering, develop, hnexpansion, hnoether_lib
@subsubsection sethnering
@cindex sethnering
@c ---content sethnering---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
sethnering(L[,s]); L list, s string (optional)

@item @strong{Assume:}
L is a list containing a ring (e.g. the output of @code{hnexpansion}).

@item @strong{Create:}
The procedure creates a ring with name given by the optional parameter
s resp. with name hnering, if no optional parameter is given, and
changes your ring to this ring. The new ring will be the ring given
as the first entry in the list L.

@item @strong{Return:}
nothing.

@end table
@strong{Example:}
@smallexample
@c computed example sethnering d2t_singular/hnoether_lib.doc:211 
LIB "hnoether.lib";
// -------- prepare for example ---------
if (defined(hnering))
@{
def rette@@ring=hnering;
if (nameof(basering)=="hnering")
@{
int wechsel=1;
@}
else
@{
int wechsel;
@}
kill hnering;
@}
// ------ the example starts here -------
ring r=0,(x,y),ls;
nameof(basering);
@expansion{} r
sethnering(hnexpansion(x4-y6)); // Creates hnering and changes to it!
nameof(basering);
@expansion{} hnering
// --- restore HNEring if previously defined ---
kill hnering;
if (defined(rette@@ring)) @{
def hnering=rette@@ring;
export hnering;
if (wechsel==1)
@{
setring hnering;
@}
@}
@c end example sethnering d2t_singular/hnoether_lib.doc:211
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:244
@ifinfo
@menu
See also:
* hnexpansion::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{hnexpansion}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:244

@c ---end content sethnering---

@c ------------------- develop -------------
@node develop, extdevelop, sethnering, hnoether_lib
@subsubsection develop
@cindex develop
@c ---content develop---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
develop(f [,n]); f poly, n int

@item @strong{Assume:}
f is a bivariate polynomial (in the first 2 ring variables) and
irreducible as power series (for reducible f use @code{hnexpansion}).

@item @strong{Return:}
list @code{L} with:

@table @asis
@item @code{L[1]}; matrix:
         Each row contains the coefficients of the corresponding line of the
         Hamburger-Noether expansion (HNE). The end of the line is marked in
         the matrix by the first ring variable (usually x).
@item @code{L[2]}; intvec:
         indicating the length of lines of the HNE
@item @code{L[3]}; int:
         0  if the 1st ring variable was transversal (with respect to f), @*
         1  if the variables were changed at the beginning of the
            computation, @*
        -1  if an error has occurred.
@item @code{L[4]}; poly:
         the transformed polynomial of f to make it possible to extend the
         Hamburger-Noether development a posteriori without having to do
         all the previous calculation once again (0 if not needed)
@item @code{L[5]}; int:
         1  if the curve has exactly one branch (i.e., is irreducible), @*
         0  else (i.e., the curve has more than one HNE, or f is not valid).
@end table

@item @strong{Display:}
The (non zero) elements of the HNE (if not called by another proc).

@item @strong{Note:}
The optional parameter @code{n} affects only the computation of
the LAST line of the HNE. If it is given, the HN-matrix @code{L[1]}
will have at least @code{n} columns. @*
Otherwise, the number of columns will be chosen minimal such that the
matrix contains all necessary information (i.e., all lines of the HNE
but the last (which is in general infinite) have place). @*
If @code{n} is negative, the algorithm is stopped as soon as the
computed information is sufficient for @code{invariants(L)}, but the
HN-matrix @code{L[1]} may still contain undetermined elements, which
are marked with the 2nd variable (of the basering). @*
For time critical computations it is recommended to use
@code{ring ...,(x,y),ls} as basering - it increases the algorithm's
speed. @*
If @code{printlevel>=0} comments are displayed (default is
@code{printlevel=0}).

@end table
@strong{Example:}
@smallexample
@c computed example develop d2t_singular/hnoether_lib.doc:312 
LIB "hnoether.lib";
ring exring = 7,(x,y),ds;
list hne=develop(4x98+2x49y7+x11y14+2y14);
print(hne[1]);
@expansion{} 0,0, 0,0,0,0,3,x,
@expansion{} 0,x, 0,0,0,0,0,0,
@expansion{} 0,0, 0,x,0,0,0,0,
@expansion{} 0,x, 0,0,0,0,0,0,
@expansion{} 0,-1,0,0,0,0,0,0 
// therefore the HNE is:
// z(-1)= 3*z(0)^7 + z(0)^7*z(1),
// z(0) = z(1)*z(2),       (there is 1 zero in the 2nd row before x)
// z(1) = z(2)^3*z(3),     (there are 3 zeroes in the 3rd row)
// z(2) = z(3)*z(4),
// z(3) = -z(4)^2 + 0*z(4)^3 +...+ 0*z(4)^8 + ?*z(4)^9 + ...
// (the missing x in the last line indicates that it is not complete.)
hne[2];
@expansion{} 7,1,3,1,-1
parametrisation(hne);
@expansion{} [1]:
@expansion{}    _[1]=-x14
@expansion{}    _[2]=-3x98-x109
// parametrization:   x(t)= -t^14+O(t^21),  y(t)= -3t^98+O(t^105)
// (the term -t^109 in y may have a wrong coefficient)
displayHNE(hne);
@expansion{} HNE[1]=-y+3*z(0)^7+z(0)^7*z(1)
@expansion{} HNE[2]=-x+z(1)*z(2)
@expansion{} HNE[3]=z(2)^3*z(3)
@expansion{} HNE[4]=z(3)*z(4)
@expansion{} HNE[5]=-z(4)^2
@c end example develop d2t_singular/hnoether_lib.doc:312
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:331
@ifinfo
@menu
See also:
* displayHNE::
* extdevelop::
* hnexpansion::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{displayHNE};
@ref{extdevelop};
@ref{hnexpansion}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:331

@c ---end content develop---

@c ------------------- extdevelop -------------
@node extdevelop, parametrisation, develop, hnoether_lib
@subsubsection extdevelop
@cindex extdevelop
@c ---content extdevelop---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
extdevelop(L,N); list L, int N

@item @strong{Assume:}
L is the output of @code{develop(f)}, or of @code{extdevelop(l,n)},
or one entry in the list @code{hne} in the ring created by
@code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
an extension of the Hamburger-Noether development of f as a list
in the same format as L has (up to the last entry in the output
of @code{develop(f)}).@*
Type @code{help develop;}, resp. @code{help hnexpansion;} for more
details.

@item @strong{Note:}
The new HN-matrix will have at least N columns (if the HNE is not
finite). In particular, if f is irreducible then (in most cases)
@code{extdevelop(develop(f),N)} will produce the same result as
@code{develop(f,N)}.@*
If the matrix M of L has n columns then, compared with
@code{parametrisation(L)}, @code{paramametrize(extdevelop(L,N))} will increase the
exactness by at least (N-n) more significant monomials.

@end table
@strong{Example:}
@smallexample
@c computed example extdevelop d2t_singular/hnoether_lib.doc:372 
LIB "hnoether.lib";
if (defined(HNEring))
@{
def save_r_i_n_g=HNEring;
kill HNEring;
@}
// ------ the example starts here -------
ring exring=0,(x,y),dp;
list hn=hnexpansion(x14-3y2x11-y3x10-y2x9+3y4x8+y5x7+3y4x6+x5*(-y6+y5)
-3y6x3-y7x2+y8);
def HNEring=hn[1];
setring HNEring;  
export(HNEring);  
@expansion{} // ** `HNEring` is already global
print(hne[1][1]);    // HNE of 1st branch is finite
@expansion{} 0,x,0,
@expansion{} 0,1,x 
print(extdevelop(hne[1],5)[1]);
@expansion{}  No extension is possible
@expansion{} 0,x,0,
@expansion{} 0,1,x 
print(hne[2][1]);    // HNE of 2nd branch can be extended
@expansion{} 0,x,0,
@expansion{} 0,1,x,
@expansion{} 0,1,-1
list ehne=extdevelop(hne[2],5);
print(ehne[1]);      // new HN-matrix has 5 columns
@expansion{} 0,x,0, 0,0,
@expansion{} 0,1,x, 0,0,
@expansion{} 0,1,-1,1,-1
parametrisation(hne[2]);
@expansion{} [1]:
@expansion{}    _[1]=x4-x5-x6+x7
@expansion{}    _[2]=x6-2x7+2x9-x10
parametrisation(ehne);
@expansion{} [1]:
@expansion{}    _[1]=x4-x5+x6-x7-x8+x9-x10+x11
@expansion{}    _[2]=x6-2x7+3x8-4x9+2x10-2x12+4x13-3x14+2x15-x16
if (defined(save_r_i_n_g))
@{
kill HNEring;
def HNEring=save_r_i_n_g;
@}
@c end example extdevelop d2t_singular/hnoether_lib.doc:372
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:400
@ifinfo
@menu
See also:
* develop::
* hnexpansion::
* parametrisation::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{hnexpansion};
@ref{parametrisation}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:400

@c ---end content extdevelop---

@c ------------------- parametrisation -------------
@node parametrisation, displayHNE, extdevelop, hnoether_lib
@subsubsection parametrisation
@cindex parametrisation
@c ---content parametrisation---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
parametrisation(INPUT [,x]); INPUT list or poly, x int (optional)

@item @strong{Assume:}
INPUT is either a bivariate polynomial f defining a plane curve
singularity, or it is the output of @code{hnexpansion(f[,"ess"])},
or of @code{develop(f)}, or of @code{extdevelop(develop(f),n)},
or the list @@@{hne@} in the ring created by @code{hnexpansion(f)}
respectively one entry thereof.

@item @strong{Return:}
a list L containing a parametrization L[i] for each branch f[i] of f
in the following format: @*
- if only the list INPUT is given, L[i] is an ideal of two polynomials
p[1],p[2]: if the HNE of was finite then f[i](p[1],p[2])=0; if not,
the "real" parametrization will be two power series and p[1],p[2] are
truncations of these series.@*
- if the optional parameter x is given, L[i] is itself a list:
L[i][1] is the parametrization ideal as above and L[i][2] is an intvec
with two entries indicating the highest degree up to which the
coefficients of the monomials in L[i][1] are exact (entry -1 means that
the corresponding parametrization is exact).

@item @strong{Note:}
If the basering has only 2 variables, the first variable is chosen
as indefinite. Otherwise, the 3rd variable is chosen. @*
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@cindex parametrization
@end table
@strong{Example:}
@smallexample
@c computed example parametrisation d2t_singular/hnoether_lib.doc:449 
LIB "hnoether.lib";
ring exring=0,(x,y,t),ds;
// 1st Example: input is a polynomial
poly g=(x2-y3)*(x3-y5);
parametrisation(g);
@expansion{} [1]:
@expansion{}    _[1]=t3
@expansion{}    _[2]=t2
@expansion{} [2]:
@expansion{}    _[1]=t5
@expansion{}    _[2]=t3
// 2nd Example: input is the ring of a Hamburger-Noether expansion
poly h=x2-y2-y3;
list hn=hnexpansion(h);
parametrisation(h,1);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=t
@expansion{}       _[2]=t-1/2t2
@expansion{}    [2]:
@expansion{}       -1,2
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=t
@expansion{}       _[2]=-t-1/2t2
@expansion{}    [2]:
@expansion{}       -1,2
// 3rd Example: input is a Hamburger-Noether expansion
poly f=x3+2xy2+y2;
list hne=develop(f);
list hne_extended=extdevelop(hne,10);
//   compare the matrices ...
print(hne[1]);
@expansion{} 0,x,
@expansion{} 0,-1
print(hne_extended[1]);
@expansion{} 0,x, 0,0,0,0, 0,0,0,0, 
@expansion{} 0,-1,0,2,0,-4,0,8,0,-16
// ... and the resulting parametrizations:
parametrisation(hne);
@expansion{} [1]:
@expansion{}    _[1]=-t2
@expansion{}    _[2]=-t3
parametrisation(hne_extended);
@expansion{} [1]:
@expansion{}    _[1]=-t2+2t4-4t6+8t8-16t10
@expansion{}    _[2]=-t3+2t5-4t7+8t9-16t11
parametrisation(hne_extended,0);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=-t2+2t4-4t6+8t8-16t10
@expansion{}       _[2]=-t3+2t5-4t7+8t9-16t11
@expansion{}    [2]:
@expansion{}       10,11
@c end example parametrisation d2t_singular/hnoether_lib.doc:449
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:472
@ifinfo
@menu
See also:
* develop::
* extdevelop::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{extdevelop}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:472

@c ---end content parametrisation---

@c ------------------- displayHNE -------------
@node displayHNE, invariants, parametrisation, hnoether_lib
@subsubsection displayHNE
@cindex displayHNE
@c ---content displayHNE---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
displayHNE(L[,n]); L list, n int

@item @strong{Assume:}
L is the output of @code{develop(f)}, or of @code{exdevelop(f,n)},
or of @code{hnexpansion(f[,"ess"])}, or (one entry in) the list
@code{hne} in the ring created by @code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
- if only one argument is given, no return value, but
display an ideal HNE of the following form:
@smallexample
     HNE[1]=-y+[]*z(0)^1+[]*z(0)^2+...+z(0)^<>*z(1)
     HNE[2]=-x+          []*z(1)^2+...+z(1)^<>*z(2)
     HNE[3]=             []*z(2)^2+...+z(2)^<>*z(3)
     .......             ..........................
     HNE[r+1]=           []*z(r)^2+[]*z(r)^3+......
@end smallexample
where @code{x},@code{y} are the first 2 variables of the basering.
The values of @code{[]} are the coefficients of the Hamburger-Noether
matrix, the values of @code{<>} are represented by @code{x} in the
HN-matrix.@*
- if a second argument is given, create and export a new ring with
name @code{displayring} containing an ideal @code{HNE} as described
above.@*
- if L corresponds to the output of @code{hnexpansion(f[,"ess"])}
or to the list @code{hne} in the ring created by @code{hnexpansion(f[,"ess"])},
@code{displayHNE(L[,n])} shows the HNE's of all branches of f in the form
described above. The optional parameter is then ignored.

@item @strong{Note:}
The 1st line of the above ideal (i.e., @code{HNE[1]}) means that
@code{y=[]*z(0)^1+...}, the 2nd line (@code{HNE[2]}) means that
@code{x=[]*z(1)^2+...}, so you can see which indeterminate
corresponds to which line (it's also possible that @code{x} corresponds
to the 1st line and @code{y} to the 2nd).

@end table
@strong{Example:}
@smallexample
@c computed example displayHNE d2t_singular/hnoether_lib.doc:526 
LIB "hnoether.lib";
ring r=0,(x,y),dp;
poly f=x3+2xy2+y2;
list hn=develop(f);
displayHNE(hn);
@expansion{} HNE[1]=-y+z(0)*z(1)
@expansion{} HNE[2]=-x-z(1)^2
@c end example displayHNE d2t_singular/hnoether_lib.doc:526
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:534
@ifinfo
@menu
See also:
* develop::
* hnexpansion::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{hnexpansion}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:534

@c ---end content displayHNE---

@c ------------------- invariants -------------
@node invariants, displayInvariants, displayHNE, hnoether_lib
@subsubsection invariants
@cindex invariants
@c ---content invariants---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
invariants(INPUT); INPUT list or poly

@item @strong{Assume:}
INPUT is the output of @code{develop(f)}, or of
@code{extdevelop(develop(f),n)}, or one entry in the list @code{hne}
of the HNEring created by @code{hnexpansion}.

@item @strong{Return:}
list, if INPUT contains a valid HNE:
@format
    invariants(INPUT)[1]:  intvec    (characteristic exponents)
    invariants(INPUT)[2]:  intvec    (generators of the semigroup)
    invariants(INPUT)[3]:  intvec    (Puiseux pairs, 1st components)
    invariants(INPUT)[4]:  intvec    (Puiseux pairs, 2nd components)
    invariants(INPUT)[5]:  int       (degree of the conductor)
    invariants(INPUT)[6]:  intvec    (sequence of multiplicities)
@end format
an empty list, if INPUT contains no valid HNE.

@item @strong{Assume:}
INPUT is bivariate polynomial f or the output of @code{hnexpansion(f[,"ess"])},
or the list @code{hne} in the HNEring created by @code{hnexpansion}.

@item @strong{Return:}
list INV, such that INV[i] is the output of @code{invariants(develop(f[i]))}
as above, where f[i] is the ith branch of the curve f, and the last
entry contains further invariants of f in the format:
@format
    INV[i][1]    : intvec    (characteristic exponents)
    INV[i][2]    : intvec    (generators of the semigroup)
    INV[i][3]    : intvec    (Puiseux pairs, 1st components)
    INV[i][4]    : intvec    (Puiseux pairs, 2nd components)
    INV[i][5]    : int       (degree of the conductor)
    INV[i][6]    : intvec    (sequence of multiplicities)
    INV[last][1] : intmat    (contact matrix of the branches)
    INV[last][2] : intmat    (intersection multiplicities of the branches)
    INV[last][3] : int       (delta invariant of f)
@end format

@item @strong{Note:}
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@cindex characteristic exponents
@cindex semigroup of values
@cindex Puiseux pairs
@cindex conductor, degree
@cindex multiplicities, sequence of
@end table
@strong{Example:}
@smallexample
@c computed example invariants d2t_singular/hnoether_lib.doc:602 
LIB "hnoether.lib";
ring exring=0,(x,y),dp;
list hne=develop(y4+2x3y2+x6+x5y);
list INV=invariants(hne);
INV[1];                   // the characteristic exponents
@expansion{} 4,6,7
INV[2];                   // the generators of the semigroup of values
@expansion{} 4,6,13
INV[3],INV[4];            // the Puiseux pairs in packed form
@expansion{} 3,7 2,2
INV[5] / 2;               // the delta-invariant
@expansion{} 8
INV[6];                   // the sequence of multiplicities
@expansion{} 4,2,2,1,1
// To display the invariants more 'nicely':
displayInvariants(hne);
@expansion{}  characteristic exponents  : 4,6,7
@expansion{}  generators of semigroup   : 4,6,13
@expansion{}  Puiseux pairs             : (3,2)(7,2)
@expansion{}  degree of the conductor   : 16
@expansion{}  delta invariant           : 8
@expansion{}  sequence of multiplicities: 4,2,2,1,1
/////////////////////////////
INV=invariants((x2-y3)*(x3-y5));
INV[1][1];                // the characteristic exponents of the first branch
@expansion{} 2,3
INV[2][6];                // the sequence of multiplicities of the second branch
@expansion{} 3,2,1,1
print(INV[size(INV)][1]);         // the contact matrix of the branches
@expansion{}      0     3
@expansion{}      3     0
print(INV[size(INV)][2]);         // the intersection numbers of the branches
@expansion{}      0     9
@expansion{}      9     0
INV[size(INV)][3];                // the delta invariant of the curve
@expansion{} 14
@c end example invariants d2t_singular/hnoether_lib.doc:602
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:623
@ifinfo
@menu
See also:
* develop::
* displayInvariants::
* intersection::
* multsequence::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{displayInvariants};
@ref{intersection};
@ref{multsequence}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:623

@c ---end content invariants---

@c ------------------- displayInvariants -------------
@node displayInvariants, multsequence, invariants, hnoether_lib
@subsubsection displayInvariants
@cindex displayInvariants
@c ---content displayInvariants---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
displayInvariants(INPUT); INPUT list or poly

@item @strong{Assume:}
INPUT is a bivariate polynomial, or the output of @code{develop(f)}, or of
@code{extdevelop(develop(f),n)}, or (one entry of) the list @code{hne}
in the ring created by @code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
none

@item @strong{Display:}
invariants of the corresponding branch, resp. of all branches,
in a better readable form.

@item @strong{Note:}
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@end table
@strong{Example:}
@smallexample
@c computed example displayInvariants d2t_singular/hnoether_lib.doc:661 
LIB "hnoether.lib";
ring exring=0,(x,y),dp;
list hne=develop(y4+2x3y2+x6+x5y);
displayInvariants(hne);
@expansion{}  characteristic exponents  : 4,6,7
@expansion{}  generators of semigroup   : 4,6,13
@expansion{}  Puiseux pairs             : (3,2)(7,2)
@expansion{}  degree of the conductor   : 16
@expansion{}  delta invariant           : 8
@expansion{}  sequence of multiplicities: 4,2,2,1,1
@c end example displayInvariants d2t_singular/hnoether_lib.doc:661
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:668
@ifinfo
@menu
See also:
* develop::
* hnexpansion::
* intersection::
* invariants::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{hnexpansion};
@ref{intersection};
@ref{invariants}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:668

@c ---end content displayInvariants---

@c ------------------- multsequence -------------
@node multsequence, displayMultsequence, displayInvariants, hnoether_lib
@subsubsection multsequence
@cindex multsequence
@c ---content multsequence---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
multsequence(INPUT); INPUT list or poly

@item @strong{Assume:}
INPUT is the output of @code{develop(f)}, or of @code{extdevelop(develop(f),n)},
or one entry in the list @code{hne} of the ring created by @code{hnexpansion(f)}.

@item @strong{Return:}
intvec corresponding to the multiplicity sequence of (a branch)
of the curve (the same as @code{invariants(INPUT)[6]}).

@item @strong{Assume:}
INPUT is a bivariate polynomial, or the output of @code{hnexpansion(f)},
or the list @code{hne} in the ring created by @code{hnexpansion(f)}.

@item @strong{Return:}
list of two integer matrices:

@table @asis
@item  @code{multsequence(INPUT)[1][i,*]}
   contains the multiplicities of the branches at their infinitely near point
   of 0 in its (i-1) order neighbourhood (i.e., i=1: multiplicity of the
   branches themselves, i=2: multiplicity of their 1st quadratic transformed,
   etc., @*
   Hence, @code{multsequence(INPUT)[1][*,j]} is the multiplicity sequence
   of branch j.
@item  @code{multsequence(INPUT)[2][i,*]}:
   contains the information which of these infinitely near points coincide.
@end table

@item @strong{Note:}
The order of elements of the list @code{hne} obtained from @code{hnexpansion(f[,"ess")}
must not be changed (because then the coincident infinitely near points
couldn't be grouped together, cf. meaning of 2nd intmat in example).
Hence, it is not wise to compute the HNE of several polynomials
separately, put them into a list INPUT and call @code{multsequence(INPUT)}. @*
Use @code{displayMultsequence} to produce a better readable output for
reducible curves on the screen. @*
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@cindex multiplicity sequence
@end table
@strong{Example:}
@smallexample
@c computed example multsequence d2t_singular/hnoether_lib.doc:729 
LIB "hnoether.lib";
// -------- prepare for example ---------
if (nameof(basering)=="HNEring") @{
def rettering=HNEring;
kill HNEring;
@}
// ------ the example starts here -------
ring r=0,(x,y),dp;
list hn=hnexpansion((x6-y10)*(x+y2-y3)*(x+y2+y3));   // 4 branches
def HNEring=hn[1];
setring HNEring;
multsequence(hne[1]),"  |  ",multsequence(hne[2]),"  |  ",
multsequence(hne[3]),"  |  ",multsequence(hne[4]);
@expansion{} 3,2,1,1   |   3,2,1,1   |   1   |   1
multsequence(hne);
@expansion{} [1]:
@expansion{}    3,3,1,1,
@expansion{}    2,2,1,1,
@expansion{}    1,1,1,1,
@expansion{}    1,1,1,1,
@expansion{}    1,1,1,1 
@expansion{} [2]:
@expansion{}    4,0,0,0,
@expansion{}    4,0,0,0,
@expansion{}    2,2,0,0,
@expansion{}    2,1,1,0,
@expansion{}    1,1,1,1 
// The meaning of the entries of the 2nd matrix is as follows:
displayMultsequence(hne);
@expansion{} [(3,3,1,1)],
@expansion{} [(2,2,1,1)],
@expansion{} [(1,1),(1,1)],
@expansion{} [(1,1),(1),(1)],
@expansion{} [(1),(1),(1),(1)]
// --- restore HNEring if previously defined ---
kill HNEring,r;
if (defined(rettering)) @{
setring rettering;
def HNEring=rettering;
export HNEring;
@}
@c end example multsequence d2t_singular/hnoether_lib.doc:729
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:755
@ifinfo
@menu
See also:
* develop::
* displayMultsequence::
* hnexpansion::
* separateHNE::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{displayMultsequence};
@ref{hnexpansion};
@ref{separateHNE}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:755

@c ---end content multsequence---

@c ------------------- displayMultsequence -------------
@node displayMultsequence, intersection, multsequence, hnoether_lib
@subsubsection displayMultsequence
@cindex displayMultsequence
@c ---content displayMultsequence---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
displayMultsequence(INPUT); INPUT list or poly

@item @strong{Assume:}
INPUT is a bivariate polynomial, or the output of @code{develop(f)},
or of @code{extdevelop(develop(f),n)}, or of of @code{hnexpansion(f[,"ess"])},
or (one entry in) the list @code{hne} of the ring created by @code{hnexpansion(f[,"ess "])}.

@item @strong{Return:}
nothing

@item @strong{Display:}
the sequence of multiplicities:
@format
 - if @code{INPUT=develop(f)} or @code{INPUT=extdevelop(develop(f),n)} or @code{INPUT=hne[i]}:
                      @code{a , b , c , ....... , 1}
 - if @code{INPUT=f} or @code{INPUT=hnexpansion(f[,"ess"])} or @code{INPUT=hne}:
                      @code{[(a_1, .... , b_1 , .... , c_1)],}
                      @code{[(a_2, ... ), ... , (... , c_2)],}
                      @code{ ........................................ ,}
                      @code{[(a_n),(b_n), ....., (c_n)]}
     with:
       @code{a_1 , ... , a_n} the sequence of multiplicities of the 1st branch,
       @code{[...]} the multiplicities of the j-th transformed of all branches,
       @code{(...)} indicating branches meeting in an infinitely near point.
@end format

@item @strong{Note:}
The same restrictions for INPUT as in @code{multsequence} apply.@*
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@end table
@strong{Example:}
@smallexample
@c computed example displayMultsequence d2t_singular/hnoether_lib.doc:806 
LIB "hnoether.lib";
// ------ the example starts here -------
ring r=0,(x,y),dp;
//// Example 1: Input = output of develop
displayMultsequence(develop(x3-y5));
@expansion{} The sequence of multiplicities is   3,2,1,1
//// Example 2: Input = bivariate polynomial
displayMultsequence((x6-y10)*(x+y2-y3)*(x+y2+y3));
@expansion{} [(3,3,1,1)],
@expansion{} [(2,2,1,1)],
@expansion{} [(1,1),(1,1)],
@expansion{} [(1,1),(1),(1)],
@expansion{} [(1),(1),(1),(1)]
@c end example displayMultsequence d2t_singular/hnoether_lib.doc:806
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:816
@ifinfo
@menu
See also:
* develop::
* hnexpansion::
* multsequence::
* separateHNE::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{hnexpansion};
@ref{multsequence};
@ref{separateHNE}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:816

@c ---end content displayMultsequence---

@c ------------------- intersection -------------
@node intersection, stripHNE, displayMultsequence, hnoether_lib
@subsubsection intersection
@cindex intersection
@c ---content intersection---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
intersection(hne1,hne2); hne1, hne2 lists

@item @strong{Assume:}
hne1, hne2 represent a HNE (i.e., are the output of
@code{develop(f)}, or of @code{extdevelop(develop(f),n)}, or
one entry of the list @code{hne} in the ring created by
@code{hnexpansion(f[,"ess"])}).

@item @strong{Return:}
int, the intersection multiplicity of the branches corresponding to
hne1 and hne2.

@cindex intersection multiplicity
@end table
@strong{Example:}
@smallexample
@c computed example intersection d2t_singular/hnoether_lib.doc:847 
LIB "hnoether.lib";
// ------ the example starts here -------
ring r=0,(x,y),dp;
list hn=hnexpansion((x2-y3)*(x2+y3));
def HNEring=hn[1];
setring HNEring;
intersection(hne[1],hne[2]);
@expansion{} 6
@c end example intersection d2t_singular/hnoether_lib.doc:847
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:857
@ifinfo
@menu
See also:
* displayInvariants::
* hnexpansion::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{displayInvariants};
@ref{hnexpansion}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:857

@c ---end content intersection---

@c ------------------- stripHNE -------------
@node stripHNE, is_irred, intersection, hnoether_lib
@subsubsection stripHNE
@cindex stripHNE
@c ---content stripHNE---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
stripHNE(L); L list

@item @strong{Assume:}
L is the output of @code{develop(f)}, or of
@code{extdevelop(develop(f),n)}, or (one entry of) the list
@code{hne} in the ring created by @code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
list in the same format as L, but all polynomials L[4], resp.
L[i][4], are set to zero.

@item @strong{Note:}
The purpose of this procedure is to remove huge amounts of data
no longer needed. It is useful, if one or more of the polynomials
in L consume much memory. It is still possible to compute invariants,
parametrizations etc. with the stripped HNE(s), but it is not possible
to use @code{extdevelop} with them.

@end table
@strong{Example:}
@smallexample
@c computed example stripHNE d2t_singular/hnoether_lib.doc:893 
LIB "hnoether.lib";
ring r=0,(x,y),dp;
list hne=develop(x2+y3+y4);
hne;
@expansion{} [1]:
@expansion{}    _[1,1]=0
@expansion{}    _[1,2]=x
@expansion{}    _[2,1]=0
@expansion{}    _[2,2]=-1
@expansion{} [2]:
@expansion{}    1,-1
@expansion{} [3]:
@expansion{}    1
@expansion{} [4]:
@expansion{}    x4-2x2y+y2+y
@expansion{} [5]:
@expansion{}    1
stripHNE(hne);
@expansion{} [1]:
@expansion{}    _[1,1]=0
@expansion{}    _[1,2]=x
@expansion{}    _[2,1]=0
@expansion{}    _[2,2]=-1
@expansion{} [2]:
@expansion{}    1,-1
@expansion{} [3]:
@expansion{}    1
@expansion{} [4]:
@expansion{}    0
@expansion{} [5]:
@expansion{}    1
@c end example stripHNE d2t_singular/hnoether_lib.doc:893
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:901
@ifinfo
@menu
See also:
* develop::
* extdevelop::
* hnexpansion::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{extdevelop};
@ref{hnexpansion}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:901

@c ---end content stripHNE---

@c ------------------- is_irred -------------
@node is_irred, delta, stripHNE, hnoether_lib
@subsubsection is_irred
@cindex is_irred
@c ---content is_irred---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
is_irred(f); f poly

@item @strong{Assume:}
f is a squarefree bivariate polynomial (in the first 2 ring
variables).

@item @strong{Return:}
int (0 or 1): @*
- @code{is_irred(f)=1} if f is irreducible as a formal power
series over the algebraic closure of its coefficient field (f
defines an analytically irreducible curve at zero), @*
- @code{is_irred(f)=0} otherwise.

@item @strong{Note:}
0 and units in the ring of formal power series are considered to be
not irreducible.

@cindex irreducible power series
@end table
@strong{Example:}
@smallexample
@c computed example is_irred d2t_singular/hnoether_lib.doc:937 
LIB "hnoether.lib";
ring exring=0,(x,y),ls;
is_irred(x2+y3);
@expansion{} 1
is_irred(x2+y2);
@expansion{} 0
is_irred(x2+y3+1);
@expansion{} 0
@c end example is_irred d2t_singular/hnoether_lib.doc:937
@end smallexample
@c ---end content is_irred---

@c ------------------- delta -------------
@node delta, newtonpoly, is_irred, hnoether_lib
@subsubsection delta
@cindex delta
@c ---content delta---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
delta(INPUT); INPUT a polynomial defining an isolated plane curve
singularity at 0, or the Hamburger-Noether expansion thereof, i.e.
the output of @code{develop(f)}, or the output of @code{hnexpansion(f[,"ess"])},
or (one of the entries of) the list @code{hne} in the ring created
by @code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
the delta invariant of the singularity at 0, the vector space
dimension of R~/R, where R~ is the normalization of the
singularity R=basering/f

@item @strong{Note:}
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@cindex delta invariant
@end table
@strong{Example:}
@smallexample
@c computed example delta d2t_singular/hnoether_lib.doc:977 
LIB "hnoether.lib";
ring r = 32003,(x,y),ds;
poly f = x25+x24-4x23-1x22y+4x22+8x21y-2x21-12x20y-4x19y2+4x20+10x19y
+12x18y2-24x18y-20x17y2-4x16y3+x18+60x16y2+20x15y3-9x16y
-80x14y3-10x13y4+36x14y2+60x12y4+2x11y5-84x12y3-24x10y5
+126x10y4+4x8y6-126x8y5+84x6y6-36x4y7+9x2y8-1y9;
delta(f);
@expansion{} 96
@c end example delta d2t_singular/hnoether_lib.doc:977
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:987
@ifinfo
@menu
See also:
* deltaLoc::
* invariants::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{deltaLoc};
@ref{invariants}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:987

@c ---end content delta---

@c ------------------- newtonpoly -------------
@node newtonpoly, is_NND, delta, hnoether_lib
@subsubsection newtonpoly
@cindex newtonpoly
@c ---content newtonpoly---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
newtonpoly(f); f poly

@item @strong{Assume:}
basering has exactly two variables; @*
f is convenient, that is, f(x,0) != 0 != f(0,y).

@item @strong{Return:}
list of intvecs (= coordinates x,y of the Newton polygon of f).

@item @strong{Note:}
Procedure uses @code{execute}; this can be avoided by calling
@code{newtonpoly(f,1)} if the ordering of the basering is @code{ls}.

@cindex Newton polygon
@end table
@strong{Example:}
@smallexample
@c computed example newtonpoly d2t_singular/hnoether_lib.doc:1019 
LIB "hnoether.lib";
ring r=0,(x,y),ls;
poly f=x5+2x3y-x2y2+3xy5+y6-y7;
newtonpoly(f);
@expansion{} [1]:
@expansion{}    0,6
@expansion{} [2]:
@expansion{}    2,2
@expansion{} [3]:
@expansion{}    3,1
@expansion{} [4]:
@expansion{}    5,0
@c end example newtonpoly d2t_singular/hnoether_lib.doc:1019
@end smallexample
@c ---end content newtonpoly---

@c ------------------- is_NND -------------
@node is_NND, puiseux2generators, newtonpoly, hnoether_lib
@subsubsection is_NND
@cindex is_NND
@c ---content is_NND---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
is_NND(f[,mu,NP]); f poly, mu int, NP list of intvecs

@item @strong{Assume:}
f is convenient, that is, f(x,0) != 0 != f(0,y);@*
mu (optional) is Milnor number of f.@*
NP (optional) is output of @code{newtonpoly(f)}.

@item @strong{Return:}
int: 1 if f in Newton non-degenerate, 0 otherwise.

@cindex Newton non-degenerate
@cindex Newton polygon
@end table
@strong{Example:}
@smallexample
@c computed example is_NND d2t_singular/hnoether_lib.doc:1052 
LIB "hnoether.lib";
ring r=0,(x,y),ls;
poly f=x5+y3;
is_NND(f);
@expansion{} 1
poly g=(x-y)^5+3xy5+y6-y7;
is_NND(g);
@expansion{} 0
// if already computed, one should give the Minor number and Newton polygon
// as second and third input: 
int mu=milnor(g);
list NP=newtonpoly(g);
is_NND(g,mu,NP);
@expansion{} 0
@c end example is_NND d2t_singular/hnoether_lib.doc:1052
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1066
@ifinfo
@menu
See also:
* newtonpoly::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{newtonpoly}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:1066

@c ---end content is_NND---

@c ------------------- puiseux2generators -------------
@node puiseux2generators, separateHNE, is_NND, hnoether_lib
@subsubsection puiseux2generators
@cindex puiseux2generators
@c ---content puiseux2generators---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
puiseux2generators(m,n); m,n intvec

@item @strong{Assume:}
m, resp. n, represent the 1st, resp. 2nd, components of Puiseux pairs
(e.g., @code{m=invariants(L)[3]}, @code{n=invariants(L)[4]}).

@item @strong{Return:}
intvec of the generators of the semigroup of values.

@end table
@strong{Example:}
@smallexample
@c computed example puiseux2generators d2t_singular/hnoether_lib.doc:1093 
LIB "hnoether.lib";
// take (3,2),(7,2),(15,2),(31,2),(63,2),(127,2) as Puiseux pairs:
puiseux2generators(intvec(3,7,15,31,63,127),intvec(2,2,2,2,2,2));
@expansion{} 64,96,208,424,852,1706,3413
@c end example puiseux2generators d2t_singular/hnoether_lib.doc:1093
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1099
@ifinfo
@menu
See also:
* invariants::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{invariants}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:1099

@c ---end content puiseux2generators---

@c ------------------- separateHNE -------------
@node separateHNE, squarefree, puiseux2generators, hnoether_lib
@subsubsection separateHNE
@cindex separateHNE
@c ---content separateHNE---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
separateHNE(hne1,hne2); hne1, hne2 lists

@item @strong{Assume:}
hne1, hne2 are HNEs (=output of
@code{develop(f)}, @code{extdevelop(develop(f),n)}, or
one entry in the list @code{hne} in the ring created by
@code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
number of quadratic transformations needed to separate both curves
(branches).

@end table
@strong{Example:}
@smallexample
@c computed example separateHNE d2t_singular/hnoether_lib.doc:1129 
LIB "hnoether.lib";
int p=printlevel; printlevel=-1;
ring r=0,(x,y),dp;
list hne1=develop(x);
list hne2=develop(x+y);
list hne3=develop(x+y2);
separateHNE(hne1,hne2);  // two transversal lines
@expansion{} 1
separateHNE(hne1,hne3);  // one quadratic transform. gives 1st example
@expansion{} 2
printlevel=p;
@c end example separateHNE d2t_singular/hnoether_lib.doc:1129
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1141
@ifinfo
@menu
See also:
* develop::
* displayMultsequence::
* hnexpansion::
* multsequence::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{develop};
@ref{displayMultsequence};
@ref{hnexpansion};
@ref{multsequence}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:1141

@c ---end content separateHNE---

@c ------------------- squarefree -------------
@node squarefree, allsquarefree, separateHNE, hnoether_lib
@subsubsection squarefree
@cindex squarefree
@c ---content squarefree---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
squarefree(f); f poly

@item @strong{Assume:}
f is a bivariate polynomial (in the first 2 ring variables).

@item @strong{Return:}
poly, a squarefree divisor of f.

@item @strong{Note:}
Usually, the return value is the greatest squarefree divisor, but
there is one exception: factors with a p-th root, p the
characteristic of the basering, are lost.

@end table
@strong{Example:}
@smallexample
@c computed example squarefree d2t_singular/hnoether_lib.doc:1172 
LIB "hnoether.lib";
ring exring=3,(x,y),dp;
squarefree((x3+y)^2);
@expansion{} x3+y
squarefree((x+y)^3*(x-y)^2); // Warning: (x+y)^3 is lost
@expansion{} x-y
squarefree((x+y)^4*(x-y)^2); // result is (x+y)*(x-y)
@expansion{} x2-y2
@c end example squarefree d2t_singular/hnoether_lib.doc:1172
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1180
@ifinfo
@menu
See also:
* allsquarefree::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{allsquarefree}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:1180

@c ---end content squarefree---

@c ------------------- allsquarefree -------------
@node allsquarefree, further_hn_proc, squarefree, hnoether_lib
@subsubsection allsquarefree
@cindex allsquarefree
@c ---content allsquarefree---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage :}
allsquarefree(f,g); f,g poly

@item @strong{Assume:}
g is the output of @code{squarefree(f)}.

@item @strong{Return:}
the greatest squarefree divisor of f.

@item @strong{Note  :}
This proc uses factorize to get the missing factors of f not in g and,
therefore, may be slow.

@end table
@strong{Example:}
@smallexample
@c computed example allsquarefree d2t_singular/hnoether_lib.doc:1210 
LIB "hnoether.lib";
ring exring=7,(x,y),dp;
poly f=(x+y)^7*(x-y)^8;
poly g=squarefree(f);
g;                      // factor x+y lost, since characteristic=7
@expansion{} x-y
allsquarefree(f,g);     // all factors (x+y)*(x-y) found
@expansion{} x2-y2
@c end example allsquarefree d2t_singular/hnoether_lib.doc:1210
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1219
@ifinfo
@menu
See also:
* squarefree::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{squarefree}.
@end iftex
@c end inserted refs from d2t_singular/hnoether_lib.doc:1219

@c ---end content allsquarefree---

@c ------------------- further_hn_proc -------------
@node further_hn_proc,, allsquarefree, hnoether_lib
@subsubsection further_hn_proc
@cindex further_hn_proc
@c ---content further_hn_proc---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
further_hn_proc();

@item @strong{Note:}
The library @code{hnoether.lib} contains some more procedures which
are not shown when typing @code{help hnoether.lib;}. They may be useful
for interactive use (e.g. if you want to do the calculation of an HN
development "by hand" to see the intermediate results), and they
can be enumerated by calling @code{further_hn_proc()}. @*
Use @code{help <procedure>;} for detailed information about each of
them.

@end table
@strong{Example:}
@smallexample
@c computed example further_hn_proc d2t_singular/hnoether_lib.doc:1248 
LIB "hnoether.lib";
further_hn_proc();
@expansion{} 
@expansion{}  The following procedures are also part of `hnoether.lib':
@expansion{} 
@expansion{}  getnm(f);           intersection pts. of Newton polygon with axes
@expansion{}  T_Transform(f,Q,N); returns f(y,xy^Q)/y^NQ (f: poly, Q,N: int)
@expansion{}  T1_Transform(f,d,M); returns f(x,y+d*x^M)  (f: poly,d:number,M:int)
@expansion{}  T2_Transform(f,d,M,N,ref);   a composition of T1 & T
@expansion{}  koeff(f,I,J);       gets coefficient of indicated monomial of poly f
@expansion{}  redleit(f,S,E);     restriction of monomials of f to line (S-E)
@expansion{}  leit(f,n,m);        special case of redleit (for irred. polynomials)
@expansion{}  testreducible(f,n,m); tests whether f is reducible
@expansion{}  charPoly(f,M,N);    characteristic polynomial of f
@expansion{}  find_in_list(L,p);  find int p in list L
@expansion{}  get_last_divisor(M,N); last divisor in Euclid's algorithm
@expansion{}  factorfirst(f,M,N); try to factor f without `factorize'
@expansion{}  factorlist(L);      factorize a list L of polynomials
@expansion{}  referencepoly(D);   a polynomial f s.t. D is the Newton diagram of f
@c end example further_hn_proc d2t_singular/hnoether_lib.doc:1248
@end smallexample
@c ---end content further_hn_proc---
