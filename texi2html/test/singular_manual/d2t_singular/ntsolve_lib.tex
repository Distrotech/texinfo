@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/ntsolve_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/ntsolve_lib.doc INSTEAD
@c library version: (1.12.2.1,2002/04/12)
@c library file: ../Singular/LIB/ntsolve.lib
@cindex ntsolve.lib
@cindex ntsolve_lib
@table @asis
@item @strong{Library:}
ntsolve.lib
@item @strong{Purpose:}
     Real Newton Solving of Polynomial Systems
@item @strong{Authors:}
Wilfred Pohl, email: pohl@@mathematik.uni-kl.de
@*Dietmar Hillebrand

@end table

@strong{Procedures:}
@menu
* nt_solve:: find one real root of 0-dimensional ideal G
* triMNewton:: find one real root for 0-dim triangular system G
@end menu
@c ---end content LibInfo---

@c ------------------- nt_solve -------------
@node nt_solve, triMNewton,, ntsolve_lib
@subsubsection nt_solve
@cindex nt_solve
@c ---content nt_solve---
Procedure from library @code{ntsolve.lib} (@pxref{ntsolve_lib}).

@table @asis
@item @strong{Usage:}
nt_solve(gls,ini[,ipar]); gls,ini= ideals, ipar=list/intvec,@*
gls: contains the equations, for which a solution will be computed
ini: ideal of initial values (approximate solutions to start with),@*
ipar: control integers (default: ipar = 100,10)
  @format
 ipar[1]: max. number of iterations
 ipar[2]: accuracy (we have the l_2-norm ||.||): accept solution @code{sol}
          if ||gls(sol)|| < eps0*(0.1^ipar[2])
          where eps0 = ||gls(ini)|| is the initial error
  @end format

@item @strong{Assume:}
gls is a zerodimensional ideal with nvars(basering) = size(gls) (>1)

@item @strong{Return:}
ideal, coordinates of one solution (if found), 0 else

@item @strong{Note:}
if printlevel >0: displays comments (default =0)

@end table
@strong{Example:}
@smallexample
@c computed example nt_solve d2t_singular/ntsolve_lib.doc:56 
LIB "ntsolve.lib";
ring rsq = (real,40),(x,y,z,w),lp;
ideal gls =  x2+y2+z2-10, y2+z3+w-8, xy+yz+xz+w5 - 1,w3+y;
ideal ini = 3.1,2.9,1.1,0.5;
intvec ipar = 200,0;
ideal sol = nt_solve(gls,ini,ipar);
sol;
@expansion{} sol[1]=0.8698104581550055082008024750939710335537
@expansion{} sol[2]=2.8215774457503246008496262517717182369409
@expansion{} sol[3]=1.1323120084664179900060940157112668717318
@expansion{} sol[4]=-1.413071026406678849397999475590194239628
@c end example nt_solve d2t_singular/ntsolve_lib.doc:56
@end smallexample
@c ---end content nt_solve---

@c ------------------- triMNewton -------------
@node triMNewton,, nt_solve, ntsolve_lib
@subsubsection triMNewton
@cindex triMNewton
@c ---content triMNewton---
Procedure from library @code{ntsolve.lib} (@pxref{ntsolve_lib}).

@table @asis
@item @strong{Usage:}
triMNewton(G,a[,ipar]); G,a= ideals, ipar=list/intvec

@item @strong{Assume:}
G: g1,..,gn, a triangular system of n equations in n vars, i.e.
gi=gi(var(n-i+1),..,var(n)),@*
a: ideal of numbers, coordinates of an approximation of a common
zero of G to start with (with a[i] to be substituted in var(i)),@*
ipar: control integer vector (default: ipar = 100,10)
  @format
  ipar[1]: max. number of iterations
  ipar[2]: accuracy (we have as norm |.| absolute value ):
           accept solution @code{sol} if |G(sol)| < |G(a)|*(0.1^ipar[2]).
  @end format

@item @strong{Return:}
an ideal, coordinates of a better approximation of a zero of G

@end table
@strong{Example:}
@smallexample
@c computed example triMNewton d2t_singular/ntsolve_lib.doc:97 
LIB "ntsolve.lib";
ring r = (real,30),(z,y,x),(lp);
ideal i = x^2-1,y^2+x4-3,z2-y4+x-1;
ideal a = 2,3,4;
intvec e = 20,10;
ideal l = triMNewton(i,a,e);
l;
@expansion{} l[1]=-2.000000000042265738880279143423
@expansion{} l[2]=1.41421356237309504880168872421
@expansion{} l[3]=1
@c end example triMNewton d2t_singular/ntsolve_lib.doc:97
@end smallexample
@c ---end content triMNewton---
