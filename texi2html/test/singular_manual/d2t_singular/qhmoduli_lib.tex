@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/qhmoduli_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/qhmoduli_lib.doc INSTEAD
@c library version: (1.0,2000/12/12)
@c library file: ../Singular/LIB/qhmoduli.lib
@cindex qhmoduli.lib
@cindex qhmoduli_lib
@table @asis
@item @strong{Library:}
qhmoduli.lib
@item @strong{Purpose:}
    Moduli Spaces of Semi-Quasihomogeneous Singularities
@item @strong{Author:}
Thomas Bayer, email: bayert@@in.tum.de

@end table

@strong{Procedures:}
@menu
* ArnoldAction:: Induced action of G_f on T_.
* ModEqn:: Equations of the moduli space for principal part f
* QuotientEquations:: Equations of Variety(I)/G w.r.t. action 'A'
* StabEqn:: Equations of the stabilizer of f.
* StabEqnId:: Equations of the stabilizer of the qhom. ideal I.
* StabOrder:: Order of the stabilizer of f.
* UpperMonomials:: Upper basis of the Milnor algebra of f.
* Max:: maximal integer contained in 'data'
* Min:: minimal integer contained in 'data'
* Table:: list, i-th entry is cmd(i), lb <= i <= ub
@end menu
@c ---end content LibInfo---

@c ------------------- ArnoldAction -------------
@node ArnoldAction, ModEqn,, qhmoduli_lib
@subsubsection ArnoldAction
@cindex ArnoldAction
@c ---content ArnoldAction---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
ArnoldAction(f, [Gf, B]); poly f; list Gf, B;
@*'Gf' is a list of two rings (coming from 'StabEqn')

@item @strong{Purpose:}
compute the induced action of the stabilizer G of f on T_, where
T_ is given by the upper monomials B of the Milnor algebra of f.

@item @strong{Assume:}
f is quasihomogeneous

@item @strong{Return:}
polynomial ring over the same ground field, containing the ideals
'actionid' and 'stabid'.
@*- 'actionid' is the ideal defining the induced action of Gf on T_ @*
- 'stabid' is the ideal of the stabilizer Gf in the new ring

@end table
@strong{Example:}
@smallexample
@c computed example ArnoldAction d2t_singular/qhmoduli_lib.doc:59 
LIB "qhmoduli.lib";
ring B   = 0,(x,y,z), ls;
poly f = -z5+y5+x2z+x2y;
def R = ArnoldAction(f);
setring R;
actionid;
@expansion{} actionid[1]=-s(2)*t(1)+s(3)*t(1)
@expansion{} actionid[2]=-s(2)^2*t(2)+2*s(2)^2*t(3)^2+s(3)^2*t(2)
@expansion{} actionid[3]=s(2)*t(3)+s(3)*t(3)
stabid;
@expansion{} stabid[1]=s(2)*s(3)
@expansion{} stabid[2]=s(1)^2*s(2)+s(1)^2*s(3)-1
@expansion{} stabid[3]=s(1)^2*s(3)^2-s(3)
@expansion{} stabid[4]=s(1)^2+s(2)^4-s(3)^4
@expansion{} stabid[5]=s(1)^4+s(2)^3-s(3)^3
@expansion{} stabid[6]=-s(1)^2*s(3)+s(3)^5
@c end example ArnoldAction d2t_singular/qhmoduli_lib.doc:59
@end smallexample
@c ---end content ArnoldAction---

@c ------------------- ModEqn -------------
@node ModEqn, QuotientEquations, ArnoldAction, qhmoduli_lib
@subsubsection ModEqn
@cindex ModEqn
@c ---content ModEqn---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
ModEqn(f [, opt]); poly f; int opt;

@item @strong{Purpose:}
compute equations of the moduli space of semiquasihomogeneous hypersurface singularity with principal part f w.r.t. right equivalence

@item @strong{Assume:}
f quasihomogeneous polynomial with an isolated singularity at 0

@item @strong{Return:}
polynomial ring, possibly a simple extension of the ground field of
the basering, containing the ideal 'modid'
@*- 'modid' is the ideal of the moduli space if opt is even (> 0).
otherwise it contains generators of the coordinate ring R of the
moduli space (note : Spec(R) is the moduli space)

@item @strong{Options:}
1 compute equations of the mod. space,
@*2 use a primary decomposition
@*4 compute E_f0, i.e., the image of G_f0
@*To combine options, add their value, default: opt =7

@end table
@strong{Example:}
@smallexample
@c computed example ModEqn d2t_singular/qhmoduli_lib.doc:104 
LIB "qhmoduli.lib";
ring B   = 0,(x,y), ls;
poly f = -x4 + xy5;
def R = ModEqn(f);
setring R;
modid;
@expansion{} modid[1]=Y(5)^2-Y(4)*Y(6)
@expansion{} modid[2]=Y(4)*Y(5)-Y(3)*Y(6)
@expansion{} modid[3]=Y(3)*Y(5)-Y(2)*Y(6)
@expansion{} modid[4]=Y(2)*Y(5)-Y(1)*Y(6)
@expansion{} modid[5]=Y(4)^2-Y(2)*Y(6)
@expansion{} modid[6]=Y(3)*Y(4)-Y(1)*Y(6)
@expansion{} modid[7]=Y(2)*Y(4)-Y(1)*Y(5)
@expansion{} modid[8]=Y(3)^2-Y(1)*Y(5)
@expansion{} modid[9]=Y(2)*Y(3)-Y(1)*Y(4)
@expansion{} modid[10]=Y(2)^2-Y(1)*Y(3)
@c end example ModEqn d2t_singular/qhmoduli_lib.doc:104
@end smallexample
@c ---end content ModEqn---

@c ------------------- QuotientEquations -------------
@node QuotientEquations, StabEqn, ModEqn, qhmoduli_lib
@subsubsection QuotientEquations
@cindex QuotientEquations
@c ---content QuotientEquations---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
QuotientEquations(G,action,emb [, opt]); ideal G,action,emb;int opt

@item @strong{Purpose:}
compute the quotient of the variety given by the parameterization
'emb' by the linear action 'action' of the algebraic group G.

@item @strong{Assume:}
'action' is linear, G must be finite if the Reynolds operator is
needed (i.e., NullCone(G,action) returns some non-invariant polys)

@item @strong{Return:}
polynomial ring over a simple extension of the ground field of the
basering, containing the ideals 'id' and 'embedid'.
@*- 'id' contains the equations of the quotient, if opt = 1;
if opt = 0, 2, 'id' contains generators of the coordinate ring R
of the quotient (Spec(R) is the quotient)
@*- 'embedid' = 0, if opt = 1;
@*if opt = 0, 2, it is the ideal defining the equivariant embedding

@item @strong{Options:}
1 compute equations of the quotient,
@*2 use a primary decomposition when computing the Reynolds operator @*
To combine options, add their value, default: opt =3.

@end table
@c ---end content QuotientEquations---

@c ------------------- StabEqn -------------
@node StabEqn, StabEqnId, QuotientEquations, qhmoduli_lib
@subsubsection StabEqn
@cindex StabEqn
@c ---content StabEqn---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
StabEqn(f); f polynomial

@item @strong{Purpose:}
compute the equations of the isometry group of f.

@item @strong{Assume:}
f semiquasihomogeneous polynomial with an isolated singularity at 0

@item @strong{Return:}
list of two ring 'S1', 'S2'
@*- 'S1' contains the equations of the stabilizer (ideal 'stabid') @*
- 'S2' contains the action of the stabilizer (ideal 'actionid')

@item @strong{Global:}
varSubsList, contains the index j s.t. x(i) -> x(i)t(j) ...

@end table
@strong{Example:}
@smallexample
@c computed example StabEqn d2t_singular/qhmoduli_lib.doc:179 
LIB "qhmoduli.lib";
ring B = 0,(x,y,z), ls;
poly f = -z5+y5+x2z+x2y;
list stab = StabEqn(f);
def S1 = stab[1]; setring S1;  stabid;
@expansion{} stabid[1]=s(2)*s(3)
@expansion{} stabid[2]=s(1)^2*s(2)+s(1)^2*s(3)-1
@expansion{} stabid[3]=s(1)^2*s(3)^2-s(3)
@expansion{} stabid[4]=s(2)^4-s(3)^4+s(1)^2
@expansion{} stabid[5]=s(1)^4+s(2)^3-s(3)^3
@expansion{} stabid[6]=s(3)^5-s(1)^2*s(3)
def S2 = stab[2]; setring S2;  actionid;
@expansion{} actionid[1]=s(1)*x
@expansion{} actionid[2]=s(3)*y+s(2)*z
@expansion{} actionid[3]=s(2)*y+s(3)*z
@c end example StabEqn d2t_singular/qhmoduli_lib.doc:179
@end smallexample
@c ---end content StabEqn---

@c ------------------- StabEqnId -------------
@node StabEqnId, StabOrder, StabEqn, qhmoduli_lib
@subsubsection StabEqnId
@cindex StabEqnId
@c ---content StabEqnId---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
StabEqn(I, w); I ideal, w intvec

@item @strong{Purpose:}
compute the equations of the isometry group of the ideal I
each generator of I is fixed by the stabilizer.

@item @strong{Assume:}
I semiquasihomogeneous ideal wrt 'w' with an isolated singularity at 0

@item @strong{Return:}
list of two ring 'S1', 'S2'
@*- 'S1' contains the equations of the stabilizer (ideal 'stabid') @*
- 'S2' contains the action of the stabilizer (ideal 'actionid')

@item @strong{Global:}
varSubsList, contains the index j s.t. t(i) -> t(i)t(j) ...

@end table
@strong{Example:}
@smallexample
@c computed example StabEqnId d2t_singular/qhmoduli_lib.doc:219 
LIB "qhmoduli.lib";
ring B   = 0,(x,y,z), ls;
ideal I = x2,y3,z6;
intvec w = 3,2,1;
list stab = StabEqnId(I, w);
@expansion{} // ** redefining d **
@expansion{} // ** redefining newcoMx **
@expansion{} // ** redefining coMx **
@expansion{} // ** redefining d **
@expansion{} // ** redefining newcoMx **
@expansion{} // ** redefining coMx **
def S1 = stab[1]; setring S1;  stabid;
@expansion{} stabid[1]=s(1)^2-1
@expansion{} stabid[2]=s(2)^3-1
@expansion{} stabid[3]=s(3)^6-1
def S2 = stab[2]; setring S2;  actionid;
@expansion{} actionid[1]=s(1)*x
@expansion{} actionid[2]=s(2)*y
@expansion{} actionid[3]=s(3)*z
@c end example StabEqnId d2t_singular/qhmoduli_lib.doc:219
@end smallexample
@c ---end content StabEqnId---

@c ------------------- StabOrder -------------
@node StabOrder, UpperMonomials, StabEqnId, qhmoduli_lib
@subsubsection StabOrder
@cindex StabOrder
@c ---content StabOrder---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
StabOrder(f); poly f;

@item @strong{Purpose:}
compute the order of the stabilizer group of f.

@item @strong{Assume:}
f quasihomogeneous polynomial with an isolated singularity at 0

@item @strong{Return:}
int

@item @strong{Global:}
varSubsList

@end table
@c ---end content StabOrder---

@c ------------------- UpperMonomials -------------
@node UpperMonomials, Max, StabOrder, qhmoduli_lib
@subsubsection UpperMonomials
@cindex UpperMonomials
@c ---content UpperMonomials---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
UpperMonomials(poly f, [intvec w])

@item @strong{Purpose:}
compute the upper monomials of the milnor algebra of f.

@item @strong{Assume:}
f is quasihomogeneous (w.r.t. w)

@item @strong{Return:}
ideal

@end table
@strong{Example:}
@smallexample
@c computed example UpperMonomials d2t_singular/qhmoduli_lib.doc:280 
LIB "qhmoduli.lib";
ring B   = 0,(x,y,z), ls;
poly f = -z5+y5+x2z+x2y;
UpperMonomials(f);
@expansion{} _[1]=y3z3
@expansion{} _[2]=x2y3
@expansion{} _[3]=x2y2
@c end example UpperMonomials d2t_singular/qhmoduli_lib.doc:280
@end smallexample
@c ---end content UpperMonomials---

@c ------------------- Max -------------
@node Max, Min, UpperMonomials, qhmoduli_lib
@subsubsection Max
@cindex Max
@c ---content Max---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
Max(data); intvec/list of integers data

@item @strong{Purpose:}
find the maximal integer contained in 'data'

@item @strong{Return:}
list

@item @strong{Assume:}
'data' contains only integers and is not empty

@end table
@c ---end content Max---

@c ------------------- Min -------------
@node Min, Table, Max, qhmoduli_lib
@subsubsection Min
@cindex Min
@c ---content Min---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
Min(data); intvec/list of integers data

@item @strong{Purpose:}
find the minimal integer contained in 'data'

@item @strong{Return:}
list

@item @strong{Assume:}
'data' contains only integers and is not empty

@end table
@c ---end content Min---

@c ------------------- Table -------------
@node Table,, Min, qhmoduli_lib
@subsubsection Table
@cindex Table
@c ---content Table---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
Table(cmd,i, lb, ub); string cmd, i; int lb, ub

@item @strong{Purpose:}
generate a list of size ub - lb + 1 s.t. _[i] = cmd(i)

@item @strong{Return:}
list

@end table
@c ---end content Table---
