@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/solve_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/solve_lib.doc INSTEAD
@c library version: (1.21.2.14,2003/05/16)
@c library file: ../Singular/LIB/solve.lib
@cindex solve.lib
@cindex solve_lib
@table @asis
@item @strong{Library:}
solve.lib
@item @strong{Purpose:}
     Complex Solving of Polynomial Systems
@item @strong{Author:}
Moritz Wenk, email: wenk@@mathematik.uni-kl.de
@*Wilfred Pohl, email: pohl@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* laguerre_solve:: find all roots of univariate polynomial p
* solve:: all roots of 0-dim. ideal i using triangular sets
* ures_solve:: find all roots of 0-dimensional ideal i with resultants
* mp_res_mat:: multipolynomial resultant matrix of ideal i
* interpolate:: interpolate poly from evaluation points i and results j
* fglm_solve:: find roots of 0-dim. ideal using FGLM and lex_solve
* lex_solve:: find roots of reduced lexicographic standard basis
* simplexOut:: prints solution of simplex in nice format
* triangLf_solve:: find roots using triangular sys. (factorizing Lazard)
* triangM_solve:: find roots of given triangular system (Moeller)
* triangL_solve:: find roots using triangular system (Lazard)
* triang_solve:: find roots of given triangular system
@end menu
@c ---end content LibInfo---

@c ------------------- laguerre_solve -------------
@node laguerre_solve, solve,, solve_lib
@subsubsection laguerre_solve
@cindex laguerre_solve
@c ---content laguerre_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
laguerre_solve(f [, m, l, n, s] ); f = polynomial,@*
m, l, n, s = integers (control parameters of the method)
@format
 m: precision of output in digits ( 4 <= m), if basering is not ring of 
      complex numbers;
 l: precision of internal computation in decimal digits ( l >=8 )
      only if the basering is not complex or complex with smaller precision;
 n: control of multiplicity of roots or of splitting of f into
      squarefree factors
      n < 0, no split of f (good, if all roots are simple)
      n >= 0, try to split
      n = 0, return only different roots
      n > 0, find all roots (with multiplicity)
 s: s != 0, returns ERROR if  | f(root) | > 0.1^m (when computing in the 
      current ring)
 ( default: m, l, n, s = 8, 30, 1, 0 )
@end format

@item @strong{Assume:}
f is a univariate polynomial;@*
basering has characteristic 0 and is either complex or without
parameters.

@item @strong{Return:}
list of (complex) roots of the polynomial f, depending on n. The
result is of type
@format
 string: if the basering is not complex,
 number: otherwise.
@end format

@item @strong{Note:}
If printlevel >0: displays comments ( default = 0 ).
@*If s != 0 and if the procedure stops with ERROR, try a higher
internal precision m.

@end table
@strong{Example:}
@smallexample
@c reused example laguerre_solve d2t_singular/solve_lib.doc:82 
LIB "solve.lib";
// Find all roots of an univariate polynomial using Laguerre's method:
ring rs1= 0,(x,y),lp;
poly f = 15x5 + x3 + x2 - 10;
// 10 digits precision
laguerre_solve(f,10);
@expansion{} [1]:
@expansion{}    (0.2930464644-i*0.9003002396)
@expansion{} [2]:
@expansion{}    (0.2930464644+i*0.9003002396)
@expansion{} [3]:
@expansion{}    (-0.7392783383-i*0.5355190078)
@expansion{} [4]:
@expansion{}    (-0.7392783383+i*0.5355190078)
@expansion{} [5]:
@expansion{}    0.8924637479
// Now with complex coefficients,
// internal precision is 30 digits (default)
printlevel=2;
ring rsc= (real,10,i),x,lp;
poly f = (15.4+i*5)*x^5 + (25.0e-2+i*2)*x^3 + x2 - 10*i;
list l = laguerre_solve(f);
@expansion{} //BEGIN laguerre_solve
@expansion{} //control: complex ring with precision 30
@expansion{} //working in:  ring lagc=(complex,30,30),x,lp;
@expansion{} //         polynomial has complex coefficients
@expansion{} //split in working ring:
@expansion{} // split without result
@expansion{} //END laguerre_solve
l;
@expansion{} [1]:
@expansion{}    (0.04588498039+i*0.9133296179)
@expansion{} [2]:
@expansion{}    (0.5037408279-i*0.8058051828)
@expansion{} [3]:
@expansion{}    (-0.5462895588-i*0.6796668873)
@expansion{} [4]:
@expansion{}    (0.8524014357+i*0.2163760334)
@expansion{} [5]:
@expansion{}    (-0.8557376852+i*0.3557664188)
// check result, value of substituted poly should be near to zero
// remember that l contains a list of strings
// in the case of a different ring
subst(f,x,l[1]);
@expansion{} 0
subst(f,x,l[2]);
@expansion{} 0
@c end example laguerre_solve d2t_singular/solve_lib.doc:82
@end smallexample
@c ---end content laguerre_solve---

@c ------------------- solve -------------
@node solve, ures_solve, laguerre_solve, solve_lib
@subsubsection solve
@cindex solve
@c ---content solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Assume:}
the ideal is 0-dimensional;@*
basering has characteristic 0 and is either complex or
without parameters;

@item @strong{Return:}
list of solutions of the ideal G, depending on n; one solution is a
list of complex numbers in the generated output ring (the new
basering).
@format
 The result is a list L
    n  = 0: a list of all different solutions (L[i]),
    n != 0: a list of two elements,
            L[i][1] contains all different solutions with the same multiplicity
            L[i][2] the multiplicity
 L is ordered w.r.t. multiplicity (the smallest first).
@end format

@item @strong{Note:}
If the problem is not 0-dim. the procedure stops with ERROR, if the
ideal G is not a lex. standard basis, it is generated with internal
computation (Hilbert driven), if the input-ring (with char 0) has
the name "<A>", the lexicographical and complex output-ring has the
name "<A>C".

@end table
@strong{Example:}
@smallexample
@c reused example solve d2t_singular/solve_lib.doc:141 
LIB "solve.lib";
// Find all roots of a multivariate ideal using triangular sets:
int d=4;// with these 3 parameters you may construct
int t=3;// very hard problems for 'solve'
int s=2;
int i;
ring A=0,(x(1..d)),dp;
poly p=-1;
for(i=d;i>0;i--)@{p=p+x(i)^s;@}
ideal I=x(d)^t-x(d)^s+p;
for(i=d-1;i>0;i--)@{I=x(i)^t-x(i)^s+p,I;@}
I;
@expansion{} I[1]=x(1)^3+x(2)^2+x(3)^2+x(4)^2-1
@expansion{} I[2]=x(2)^3+x(1)^2+x(3)^2+x(4)^2-1
@expansion{} I[3]=x(3)^3+x(1)^2+x(2)^2+x(4)^2-1
@expansion{} I[4]=x(4)^3+x(1)^2+x(2)^2+x(3)^2-1
// the mutiplicity is
vdim(std(I));
@expansion{} 81
list l1=solve(I,6,0);
@expansion{} // name of new current ring: AC
// the current ring is
AC;
@expansion{} //   characteristic : 0 (complex:6 digits, additional 6 digits)
@expansion{} //   1 parameter    : i 
@expansion{} //   minpoly        : (i^2+1)
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering lp
@expansion{} //                  : names    x(1) x(2) x(3) x(4) 
@expansion{} //        block   2 : ordering C
// you must start with char. 0
setring A;
list l2=solve(I,6,1);
@expansion{} // name of current ring: AC
// the number of different solutions is
size(l1);
@expansion{} 37
// this is equal to
size(l2[1][1])+size(l2[2][1]);
@expansion{} 37
// the number of solutions with multiplicity is
size(l2[1][1])*l2[1][2]+size(l2[2][1])*l2[2][2];
@expansion{} 81
// the solutions with multiplicity
l2[2][2];
@expansion{} 12
// are
l2[2][1];
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       0
@expansion{}    [2]:
@expansion{}       0
@expansion{}    [3]:
@expansion{}       1
@expansion{}    [4]:
@expansion{}       0
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       0
@expansion{}    [2]:
@expansion{}       1
@expansion{}    [3]:
@expansion{}       0
@expansion{}    [4]:
@expansion{}       0
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       0
@expansion{}    [3]:
@expansion{}       0
@expansion{}    [4]:
@expansion{}       0
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       0
@expansion{}    [2]:
@expansion{}       0
@expansion{}    [3]:
@expansion{}       0
@expansion{}    [4]:
@expansion{}       1
@c end example solve d2t_singular/solve_lib.doc:141
@end smallexample
@c ---end content solve---

@c ------------------- ures_solve -------------
@node ures_solve, mp_res_mat, solve, solve_lib
@subsubsection ures_solve
@cindex ures_solve
@c ---content ures_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
ures_solve(i [, k, p] ); i = ideal, k, p = integers
@format
   k=0: use sparse resultant matrix of Gelfand, Kapranov and Zelevinsky,
   k=1: use resultant matrix of Macaulay which works only for
          homogeneous ideals,
   p>0: defines precision of the long floats for internal computation
          if the basering is not complex (in decimal digits),
   (default: k=0, p=30)
@end format

@item @strong{Assume:}
i is a zerodimensional ideal with
@*nvars(basering) = ncols(i) = number of vars
@*actually occurring in i,

@item @strong{Return:}
list of all (complex) roots of the polynomial system i = 0; the
result is of type
@format
   string: if the basering is not complex,
   number: otherwise.
@end format

@end table
@strong{Example:}
@smallexample
@c reused example ures_solve d2t_singular/solve_lib.doc:211 
LIB "solve.lib";
// compute the intersection points of two curves
ring rsq = 0,(x,y),lp;
ideal gls=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
ures_solve(gls,0,16);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       2.82842712474619
@expansion{}    [2]:
@expansion{}       1.414213562373095
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -2.82842712474619
@expansion{}    [2]:
@expansion{}       -1.414213562373095
// result is a list (x,y)-coordinates as strings
// now with complex coefficient field, precision is 20 digits
ring rsc= (real,20,I),(x,y),lp;
ideal i = (2+3*I)*x2 + (0.35+I*45.0e-2)*y2 - 8, x2 + xy + (42.7)*y2;
list l= ures_solve(i,0,10);
// result is a list of (x,y)-coordinates of complex numbers
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       (-1.315392899374542198+I*0.70468233142752928117)
@expansion{}    [2]:
@expansion{}       (0.12292646536251281054+I*0.19245727404407015049)
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       (1.315392899374542198-I*0.70468233142752928117)
@expansion{}    [2]:
@expansion{}       (-0.12292646536251281054-I*0.19245727404407015049)
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       (1.31584587549391830705-I*0.70396753310002259573)
@expansion{}    [2]:
@expansion{}       (0.092006639590217681983+I*0.20902112035965287775)
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       (-1.31584587549391830705+I*0.70396753310002259573)
@expansion{}    [2]:
@expansion{}       (-0.092006639590217681983-I*0.20902112035965287775)
// check the result
subst(subst(i[1],x,l[1][1]),y,l[1][2]);
@expansion{} 0
@c end example ures_solve d2t_singular/solve_lib.doc:211
@end smallexample
@c ---end content ures_solve---

@c ------------------- mp_res_mat -------------
@node mp_res_mat, interpolate, ures_solve, solve_lib
@subsubsection mp_res_mat
@cindex mp_res_mat
@c ---content mp_res_mat---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
mp_res_mat(i [, k] ); i ideal, k integer,
@format
    k=0: sparse resultant matrix of Gelfand, Kapranov and Zelevinsky,
    k=1: resultant matrix of Macaulay (k=0 is default)
@end format

@item @strong{Assume:}
The number of elements in the input system must be the number of
variables in the basering plus one;
@*if k=1 then i must be homogeneous.

@item @strong{Return:}
module representing the multipolynomial resultant matrix

@end table
@strong{Example:}
@smallexample
@c reused example mp_res_mat d2t_singular/solve_lib.doc:256 
LIB "solve.lib";
// compute resultant matrix in ring with parameters (sparse resultant matrix)
ring rsq= (0,u0,u1,u2),(x1,x2),lp;
ideal i= u0+u1*x1+u2*x2,x1^2 + x2^2 - 10,x1^2 + x1*x2 + 2*x2^2 - 16;
module m = mp_res_mat(i);
print(m);
@expansion{} -16,0,  -10,0,  (u0),0,   0,  0,   0,   0,  
@expansion{} 0,  -16,0,  -10,(u2),(u0),0,  0,   0,   0,  
@expansion{} 2,  0,  1,  0,  0,   (u2),0,  0,   0,   0,  
@expansion{} 0,  2,  0,  1,  0,   0,   0,  0,   0,   0,  
@expansion{} 0,  0,  0,  0,  (u1),0,   -10,(u0),0,   -16,
@expansion{} 1,  0,  0,  0,  0,   (u1),0,  (u2),(u0),0,  
@expansion{} 0,  1,  0,  0,  0,   0,   1,  0,   (u2),2,  
@expansion{} 1,  0,  1,  0,  0,   0,   0,  (u1),0,   0,  
@expansion{} 0,  1,  0,  1,  0,   0,   0,  0,   (u1),1,  
@expansion{} 0,  0,  0,  0,  0,   0,   1,  0,   0,   1   
// computing sparse resultant
det(m);
@expansion{} (-2*u0^4+18*u0^2*u1^2+4*u0^2*u1*u2+22*u0^2*u2^2-16*u1^4+80*u1^3*u2-52*u1^\
   2*u2^2-120*u1*u2^3-36*u2^4)
// compute resultant matrix (Macaulay resultant matrix)
ring rdq= (0,u0,u1,u2),(x0,x1,x2),lp;
ideal h=  homog(imap(rsq,i),x0);
h;
@expansion{} h[1]=(u0)*x0+(u1)*x1+(u2)*x2
@expansion{} h[2]=-10*x0^2+x1^2+x2^2
@expansion{} h[3]=-16*x0^2+x1^2+x1*x2+2*x2^2
module m = mp_res_mat(h,1);
print(m);
@expansion{} x0, x1, x2, 0, 0, 0, 0,0, 0, 0,
@expansion{} 0,  x0, 0,  x1,x2,0, 0,0, 0, 0,
@expansion{} 0,  0,  x0, 0, x1,x2,0,0, 0, 0,
@expansion{} -10,0,  0,  1, 0, 1, 0,0, 0, 0,
@expansion{} 0,  0,  0,  0, x0,0, 0,x1,x2,0,
@expansion{} -16,0,  0,  1, 1, 2, 0,0, 0, 0,
@expansion{} 0,  -10,0,  0, 0, 0, 1,0, 1, 0,
@expansion{} 0,  0,  -10,0, 0, 0, 0,1, 0, 1,
@expansion{} 0,  -16,0,  0, 0, 0, 1,1, 2, 0,
@expansion{} 0,  0,  -16,0, 0, 0, 0,1, 1, 2 
// computing Macaulay resultant (should be the same as above!)
det(m);
@expansion{} 2*x0^4-18*x0^2*x1^2-4*x0^2*x1*x2-22*x0^2*x2^2+16*x1^4-80*x1^3*x2+52*x1^2*\
   x2^2+120*x1*x2^3+36*x2^4
// compute numerical sparse resultant matrix
setring rsq;
ideal ir= 15+2*x1+5*x2,x1^2 + x2^2 - 10,x1^2 + x1*x2 + 2*x2^2 - 16;
module mn = mp_res_mat(ir);
print(mn);
@expansion{} 15,0, -10,0,  0, 0, 0,  -16,0,  0,  
@expansion{} 5, 15,0,  -10,0, 0, 0,  0,  -16,0,  
@expansion{} 0, 5, 1,  0,  0, 0, 0,  2,  0,  0,  
@expansion{} 0, 0, 0,  1,  0, 0, 0,  0,  2,  0,  
@expansion{} 2, 0, 0,  0,  15,0, -10,0,  0,  -16,
@expansion{} 0, 2, 0,  0,  5, 15,0,  1,  0,  0,  
@expansion{} 0, 0, 0,  0,  0, 5, 1,  0,  1,  2,  
@expansion{} 0, 0, 1,  0,  2, 0, 0,  1,  0,  0,  
@expansion{} 0, 0, 0,  1,  0, 2, 0,  0,  1,  1,  
@expansion{} 0, 0, 0,  0,  0, 0, 1,  0,  0,  1   
// computing sparse resultant
det(mn);
@expansion{} -7056
@c end example mp_res_mat d2t_singular/solve_lib.doc:256
@end smallexample
@c ---end content mp_res_mat---

@c ------------------- interpolate -------------
@node interpolate, fglm_solve, mp_res_mat, solve_lib
@subsubsection interpolate
@cindex interpolate
@c ---content interpolate---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
interpolate(p,v,d); p,v=ideals of numbers, d=integer

@item @strong{Assume:}
Ground field K is the field of rational numbers, p and v are lists
of elements of the ground field K with p[j] != -1,0,1, size(p) = n
(= number of vars) and size(v)=N=(d+1)^n.

@item @strong{Return:}
poly f, the unique polynomial f of degree n*d with prescribed values
v[i] at the points p(i)=(p[1]^(i-1),..,p[n]^(i-1)), i=1,..,N.

@item @strong{Note:}
mainly useful when n=1, i.e. f is satisfying f(p^(i-1)) = v[i],
i=1..d+1.

@end table
@strong{Example:}
@smallexample
@c reused example interpolate d2t_singular/solve_lib.doc:311 
LIB "solve.lib";
ring r1 = 0,(x),lp;
// determine f with deg(f) = 4 and
// v = values of f at points 3^0, 3^1, 3^2, 3^3, 3^4
ideal v=16,0,11376,1046880,85949136;
interpolate( 3, v, 4 );
@expansion{} 2x4-22x2+36
@c end example interpolate d2t_singular/solve_lib.doc:311
@end smallexample
@c inserted refs from d2t_singular/solve_lib.doc:320
@ifinfo
@menu
See also:
* vandermonde::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{vandermonde}.
@end iftex
@c end inserted refs from d2t_singular/solve_lib.doc:320

@c ---end content interpolate---

@c ------------------- fglm_solve -------------
@node fglm_solve, lex_solve, interpolate, solve_lib
@subsubsection fglm_solve
@cindex fglm_solve
@c ---content fglm_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
fglm_solve(i [, p] ); i ideal, p integer

@item @strong{Assume:}
the ground field has char 0.

@item @strong{Return:}
a list of numbers, the complex roots of i;
@*p>0: gives precision of complex numbers in decimal digits (default:
p=30).

@item @strong{Note:}
The procedure uses a standard basis of i to determine all complex
roots of i.
@*It creates a ring rC with the same number of variables but with
complex coefficients (and precision p).

@end table
@strong{Example:}
@smallexample
@c reused example fglm_solve d2t_singular/solve_lib.doc:354 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
fglm_solve(s,10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@c end example fglm_solve d2t_singular/solve_lib.doc:354
@end smallexample
@c ---end content fglm_solve---

@c ------------------- lex_solve -------------
@node lex_solve, simplexOut, fglm_solve, solve_lib
@subsubsection lex_solve
@cindex lex_solve
@c ---content lex_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
lex_solve( i[,p] ); i=ideal, p=integer,
 @format
  p>0: gives precision of complex numbers in decimal digits (default: p=30).
 @end format

@item @strong{Assume:}
i is a reduced lexicographical Groebner bases of a zero-dimensional
ideal, sorted by increasing leading terms.

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a complec ring with the same variables but
with complex coefficients (and precision p).
@*In this ring a list rlist of numbers is created, in which the complex
roots of i are stored.

@end table
@strong{Example:}
@smallexample
@c reused example lex_solve d2t_singular/solve_lib.doc:395 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
lex_solve(stdfglm(s),10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@c end example lex_solve d2t_singular/solve_lib.doc:395
@end smallexample
@c ---end content lex_solve---

@c ------------------- simplexOut -------------
@node simplexOut, triangLf_solve, lex_solve, solve_lib
@subsubsection simplexOut
@cindex simplexOut
@c ---content simplexOut---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
simplexOut(l); l list

@item @strong{Assume:}
l is the output of simplex.

@item @strong{Return:}
nothing. The procedure prints the computed solution of simplex
(as strings) in a nice format.

@end table
@strong{Example:}
@smallexample
@c reused example simplexOut d2t_singular/solve_lib.doc:427 
LIB "solve.lib";
ring r = (real,10),(x),lp;
// consider the max. problem:
//
//    maximize  x(1) + x(2) + 3*x(3) - 0.5*x(4)
//
//  with constraints:   x(1) +          2*x(3)          <= 740
//                             2*x(2)          - 7*x(4) <=   0
//                               x(2) -   x(3) + 2*x(4) >=   0.5
//                      x(1) +   x(2) +   x(3) +   x(4)  =   9
//
matrix sm[5][5]=   0, 1, 1, 3,-0.5,
740,-1, 0,-2, 0,
0, 0,-2, 0, 7,
0.5, 0,-1, 1,-2,
9,-1,-1,-1,-1;
int n = 4;  // number of constraints
int m = 4;  // number of variables
int m1= 2;  // number of <= constraints
int m2= 1;  // number of >= constraints
int m3= 1;  // number of == constraints
list sol=simplex(sm, n, m, m1, m2, m3);
simplexOut(sol);
@expansion{} z = 17.025
@expansion{} x2 = 3.325
@expansion{} x4 = 0.95
@expansion{} x3 = 4.725
@c end example simplexOut d2t_singular/solve_lib.doc:427
@end smallexample
@c inserted refs from d2t_singular/solve_lib.doc:453
@ifinfo
@menu
See also:
* simplex::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{simplex}.
@end iftex
@c end inserted refs from d2t_singular/solve_lib.doc:453

@c ---end content simplexOut---

@c ------------------- triangLf_solve -------------
@node triangLf_solve, triangM_solve, simplexOut, solve_lib
@subsubsection triangLf_solve
@cindex triangLf_solve
@c ---content triangLf_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
triangLf_solve(i [, p] ); i ideal, p integer,
@*p>0: gives precision of complex numbers in digits (default: p=30).

@item @strong{Assume:}
the ground field has char 0; i is a zero-dimensional ideal

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a ring rC with the same number of variables but
with complex coefficients (and precision p).@*
In rC a list rlist of numbers is created, in which the complex
roots of i are stored.@*
The proc uses a triangular system (Lazard's Algorithm with
factorization) computed from a standard basis to determine recursively
all complex roots with Laguerre's algorithm of input ideal i.

@end table
@strong{Example:}
@smallexample
@c reused example triangLf_solve d2t_singular/solve_lib.doc:489 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
triangLf_solve(s,10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@c end example triangLf_solve d2t_singular/solve_lib.doc:489
@end smallexample
@c ---end content triangLf_solve---

@c ------------------- triangM_solve -------------
@node triangM_solve, triangL_solve, triangLf_solve, solve_lib
@subsubsection triangM_solve
@cindex triangM_solve
@c ---content triangM_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
triangM_solve(i [, p ] ); i=ideal, p=integer,
@*p>0: gives precision of complex numbers in digits (default: p=30).

@item @strong{Assume:}
the ground field has char 0;@*
i zero-dimensional ideal

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a ring rC with the same number of variables but
with complex coefficients (and precision p).@*
In rC a list rlist of numbers is created, in which the complex
roots of i are stored.@*
The proc uses a triangular system (Moellers Algorithm) computed from a
standard basis to determine recursively all complex roots with
Laguerre's algorithm of input ideal i.

@end table
@strong{Example:}
@smallexample
@c reused example triangM_solve d2t_singular/solve_lib.doc:531 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
triangM_solve(s,10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@c end example triangM_solve d2t_singular/solve_lib.doc:531
@end smallexample
@c ---end content triangM_solve---

@c ------------------- triangL_solve -------------
@node triangL_solve, triang_solve, triangM_solve, solve_lib
@subsubsection triangL_solve
@cindex triangL_solve
@c ---content triangL_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
triangL_solve(i [, p] ); i=ideal, p=integer,@*
p>0: gives precision of complex numbers in digits (default: p=30).

@item @strong{Assume:}
the ground field has char 0; i is a zero-dimensional ideal.

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a ring rC with the same number of variables but
with complex coefficients (and precision p).@*
In rC a list rlist of numbers is created, in which the complex
roots of i are stored.@*
The proc uses a triangular system (Lazard's Algorithm) computed from
a standard basis to determine recursively all complex roots with
Laguerre's algorithm of input ideal i.

@end table
@strong{Example:}
@smallexample
@c reused example triangL_solve d2t_singular/solve_lib.doc:572 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
triangL_solve(s,10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@c end example triangL_solve d2t_singular/solve_lib.doc:572
@end smallexample
@c ---end content triangL_solve---

@c ------------------- triang_solve -------------
@node triang_solve,, triangL_solve, solve_lib
@subsubsection triang_solve
@cindex triang_solve
@c ---content triang_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
triang_solve(l,p [, d] ); l=list, p,d=integers,@*
l a list of finitely many triangular systems, such that the union of
their varieties equals the variety of the initial ideal.@*
p>0: gives precision of complex numbers in digits,@*
d>0: gives precision (1<d<p) for near-zero-determination,@*
(default: d=1/2*p).

@item @strong{Assume:}
the ground field has char 0;@*
l was computed using Algorithm of Lazard or Algorithm of Moeller
(see triang.lib).

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a ring rC with the same number of variables but
with complex coefficients (and precision p).@*
In rC a list rlist of numbers is created, in which the complex
roots of i are stored.@*

@end table
@strong{Example:}
@smallexample
@c reused example triang_solve d2t_singular/solve_lib.doc:616 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
triang_solve(triangLfak(stdfglm(s)),10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@c end example triang_solve d2t_singular/solve_lib.doc:616
@end smallexample
@c ---end content triang_solve---
