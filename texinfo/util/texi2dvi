#! /bin/sh
# texi2dvi --- produce DVI (or PDF) files from Texinfo (or LaTeX) sources.
# $Id: texi2dvi,v 1.55 2005-06-22 13:08:39 karl Exp $
#
# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001,
# 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, you can either send email to this
# program's maintainer or write to: The Free Software Foundation,
# Inc.; 51 Franklin Street, Fifth Floor; Boston, MA 02110-1301, USA.
#
# Original author: Noah Friedman.
#
# Please send bug reports, etc. to bug-texinfo@gnu.org.
# If possible, please send a copy of the output of the script called with
# the `--debug' option when making a bug report.

test -f /bin/ksh && test -z "$RUNNING_KSH" \
  && { UNAMES=`uname -s`; test "x$UNAMES" = xULTRIX; } 2>/dev/null \
  && { RUNNING_KSH=true; export RUNNING_KSH; exec /bin/ksh $0 ${1+"$@"}; }
unset RUNNING_KSH

# This string is expanded by rcs automatically when this file is checked out.
rcs_revision='$Revision: 1.55 $'
rcs_version=`set - $rcs_revision; echo $2`
program=`echo $0 | sed -e 's!.*/!!'`
version="texi2dvi (GNU Texinfo 4.8) $rcs_version

Copyright (C) 2005 Free Software Foundation, Inc.
There is NO warranty.  You may redistribute this software
under the terms of the GNU General Public License.
For more information about these matters, see the files named COPYING."

build_mode=${TEXI2DVI_BUILD_MODE:-local}

usage="Usage: $program [OPTION]... FILE...

Run each Texinfo or LaTeX FILE through TeX in turn until all
cross-references are resolved, building all indices.  The directory
containing each FILE is searched for included files.  The suffix of FILE
is used to determine its language (LaTeX or Texinfo).

Makeinfo is used to perform Texinfo macro expansion before running TeX
when needed.

Operation modes:
  -b, --batch         no interaction
  -D, --debug         turn on shell debugging (set -x)
  -h, --help          display this help and exit successfully
  -o, --output=OFILE  leave output in OFILE (implies --clean);
                      Only one input FILE may be specified in this case
  -q, --quiet         no output unless errors (implies --batch)
  -s, --silent        same as --quiet
  -v, --version       display version information and exit successfully
  -V, --verbose       report on what is done

TeX tuning:
  -@                   use @input instead of \input; for preloaded Texinfo
  -e, -E, --expand     force macro expansion using makeinfo
  -I DIR               search DIR for Texinfo files
  -l, --language=LANG  specify the LANG of FILE (LaTeX or Texinfo)
  -p, --pdf            use pdftex or pdflatex for processing
  -r, --recode         call recode before TeX to translate input characters
  -t, --command=CMD    insert CMD in copy of input file
   or --texinfo=CMD    multiple values accumulate

Build modes:
  --build=MODE  specify the treatment of auxiliary files [$build_mode]
      --tidy    same as --build=tidy
  -c, --clean   same as --build=clean

The MODE specifies where the TeX compilation takes place, and, as a
consequence, how auxiliary files are treated.  The build mode
can also be set using the environment variable TEXI2DVI_BUILD_MODE.

Valid MODEs are:
  \`local'  compile in the current directory, leaving all the auxiliary
             files around.
  \`tidy'   compile in a local *.t2d directory, where the auxiliary files
             are left.  Output files are copied back to the original file.
  \`clean'  same as \`tidy', but remove the auxiliary directory afterwards.
             Every compilation therefore requires the full cycle.

Using the \`tidy' mode brings several advantages:
  - the output file is updated after every succesful TeX run, for
    sake of concurrent visualization of the output.  In a \`local' build
    the viewer stops during the whole TeX run.
  - if the compilation fails, the previous state of the output file
    is preserved.
  - PDF and DVI compilation are kept in separate subdirectories
    preventing any possibility of auxiliary file incompatibility.

On the other, because \`tidy' compilation takes place in another
directory, occasionally TeX won't be able to find some files (e.g., when
using \\graphicspath): in that case use -I to specify the additional
directories to consider.

The values of the BIBTEX, LATEX (or PDFLATEX), MAKEINDEX, MAKEINFO,
TEX (or PDFTEX), TEXINDEX, and THUMBPDF environment variables are used
to run those commands, if they are set.  Any CMD strings are added
after @setfilename for Texinfo input, in the first line for LaTeX input.

Email bug reports to <bug-texinfo@gnu.org>,
general questions and discussion to <help-texinfo@gnu.org>.
Texinfo home page: http://www.gnu.org/software/texinfo/"

# Initialize variables for option overriding and otherwise.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
batch=false     # true for batch mode
debug=false
escape="\\"
expand=         # t for expansion via makeinfo
miincludes=     # makeinfo include path
oformat=dvi
oname=          # --output
quiet=          # by default let the tools' message be displayed
recode=false
set_language=
textra=         # Extra TeX commands to insert in the input file.
textra_cmd=     # sed command to insert TEXTRA where appropriate
txincludes=     # TEXINPUTS extensions, with trailing colon
txiprereq=19990129 # minimum texinfo.tex version with macro expansion
verb=false      # echo for verbose mode

orig_pwd=`pwd`

# Systems which define $COMSPEC or $ComSpec use semicolons to separate
# directories in TEXINPUTS -- except for Cygwin, where COMSPEC might be
# inherited, but : is used.
if test -n "$COMSPEC$ComSpec" && uname | grep -iv cygwin >/dev/null; then
  path_sep=";"
else
  path_sep=":"
fi

# Pacify verbose cds.
CDPATH=${ZSH_VERSION+.}$path_sep

# In case someone crazy insists on using grep -E.
: ${EGREP=egrep}


## --------------------- ##
## Auxiliary functions.  ##
## --------------------- ##

# return true if program $1 is somewhere in PATH, else false.
#
findprog ()
{
  foundprog=false

  saveIFS=$IFS
  IFS=$path_sep  # break path components at the path separator
  for dir in $PATH; do
    IFS=$saveIFS
    # The basic test for an executable is `test -f $f && test -x $f'.
    # (`test -x' is not enough, because it can also be true for directories.)
    # We have to try this both for $1 and $1.exe.
    #
    # Note: On Cygwin and DJGPP, `test -x' also looks for .exe.  On Cygwin,
    # also `test -f' has this enhancement, bot not on DJGPP.  (Both are
    # design decisions, so there is little chance to make them consistent.)
    # Thusly, it seems to be difficult to make use of these enhancements.
    #
    if  { test -f "$dir/$1"	&& test -x "$dir/$1"; } ||
	{ test -f "$dir/$1.exe"	&& test -x "$dir/$1.exe"; }; then
      foundprog=true
      break
    fi
  done
  $foundprog
}

# report LINE1 LINE2...
# ---------------------
# Report some information on stderr.
report ()
{
  for i in "$@"
  do
    echo >&2 "$0: $i"
  done
}

# Report some verbose information.
verbose ()
{
  $verb >&2 "$0: $@"
}

# fatal EXIT_STATUS LINE1 LINE2...
# --------------------------------
# Report an error and exit with failure.
fatal ()
{
  s=$1
  shift
  report "$@"
  exit $s
}

# ensure_dir DIR1 DIR2...
# -----------------------
# Make sure the directories exist.
ensure_dir ()
{
  for dir
  do
    test -d "$dir" \
      || mkdir "$dir" \
      || fatal 1 "cannot create directory: $dir"
  done
}


## ------------------------- ##
## TeX auxiliary functions.  ##
## ------------------------- ##

# Save TEXINPUTS so we can construct a new TEXINPUTS path for each file.
# Likewise for bibtex and makeindex.
tex_envvars="BIBINPUTS BSTINPUTS INDEXSTYLE TEXINPUTS"
for var in $tex_envvars; do
  eval ${var}_orig=\$$var
  export $var
done


# get_xref_files FILENAME-NOEXT
# -----------------------------
# Compute the list of xref files (indexes, tables and lists).
get_xref_files ()
{
  if $tidy; then
    # In a tidy build, all the files around as actual outputs.
    ls * 2>/dev/null
  else
    # Find all files having root filename with a two-letter extension,
    # saves the ones that are really Texinfo-related files.
    # - .?o?
    #   .toc, .log, LaTeX tables and lists, FiXme's .lox, maybe more.
    # - bu[0-9]*.aux
    #   Sub bibliography when using the LaTeX bibunits package.
    ls "$1".?o? "$1".aux bu[0-9]*.aux "$1".?? "$1".idx 2>/dev/null
  fi |
  while read file; do
    # If the file is not suitable to be an index or xref file, don't
    # process it.  It's suitable if the first character is a
    # backslash or right quote or at, as long as the first line isn't
    # \input texinfo.
    case `sed '1q' $file` in
      "\\input texinfo"*) ;;
      [\\''@]*) echo "./$file";;
    esac
  done
}


# get_index_files FILE1 FILE2...
# ------------------------------
# Select the files that are indexes to run texindex/makeindex onto.
get_index_files ()
{
  for file
  do
    case `sed '1q' $file` in
      "\\entry{"*|"\\indexentry{"*) echo "$file";;
    esac
  done
}


# Convert relative paths to absolute paths, so we can run in another
# directory (e.g., in tidy build mode, or during the macro-support
# detection).
#
# Empty path components are meaningful to tex.  We rewrite them
# as `EMPTY' so they don't get lost when we split on $path_sep.
# Hopefully no one will have an actual directory named EMPTY.
absolute_filenames ()
{
  replace_empty="-e 's/^$path_sep/EMPTY$path_sep/g' \
                 -e 's/$path_sep\$/${path_sep}EMPTY/g' \
                 -e 's/$path_sep$path_sep/${path_sep}EMPTY:/g'"
  _res=`echo "$1" | eval sed $replace_empty`
  save_IFS=$IFS
  IFS=$path_sep
  set x $_res; shift
  _res=.
  for dir
  do
    case $dir in
      EMPTY)
        _res=$_res$path_sep
        ;;
      [\\/]* | ?:[\\/]*)        # Absolute paths don't need to be expanded.
        test -d $dir && _res=$_res$path_sep$dir
        ;;
      *)
        test -d $dir && abs=`cd "$dir" && pwd` && _res=$_res$path_sep$abs
        ;;
    esac
  done
  echo "$_res"
}


## ----------------------- ##
## Running the TeX suite.  ##
## ----------------------- ##

# run_tex ()
# ----------
# Run TeX as "$tex $tex_args $filename_input", taking care of errors
# and logs.
run_tex ()
{
  # Note that this will be used via an eval: quote properly.
  cmd=$tex

  # If possible, make TeX report error locations in GNU format.
  tex_args=
  case $tex_help in
    *file-line-error*) cmd="$cmd --file-line-error";;
  esac

  # Tell TeX to be batch if requested.
  if $batch; then
    # \batchmode does not show terminal output at all, so we don't
    # want that.  And even in batch mode, TeX insists on having input
    # from the user.  Close its stdin to make it impossible.
    cmd="$cmd </dev/null '${escape}nonstopmode' '${escape}input'"
  fi

  cmd="$cmd '$filename_input'"

  verbose "Running $cmd ..."
  if eval "$cmd" >&5; then
    # Update the actual output.
    case $tidy:$oname in
      true:)  dest=$orig_pwd;;
      false:) dest=;;
      *:*)    dest=$oname;;
    esac
    if test -n "$dest"; then
      verbose "Copying $oformat file from `pwd` to $dest"
      cp -p "./$filename_noext.$oformat" "$dest"
    fi
  else
    $tidy &&
      cp "$filename_noext.log" "$orig_pwd"
    fatal 1 "$tex exited with bad status, quitting." \
            "see $filename_noext.log for errors."
  fi
}

# run_bibtex ()
# -------------
# Run bibtex on current file.
# - If its input (AUX) exists.
# - If some citations are missing (LOG contains `Citation').
#   or the LOG complains of a missing .bbl
#
# We run bibtex first, because I can see reasons for the indexes
# to change after bibtex is run, but I see no reason for the
# converse.
#
# Don't try to be too smart:
#
# 1. Running bibtex only if the bbl file exists and is older than
# the LaTeX file is wrong, since the document might include files
# that have changed.
#
# 3. Because there can be several AUX (if there are \include's),
# but a single LOG, looking for missing citations in LOG is
# easier, though we take the risk to match false messages.
run_bibtex ()
{
  if test -n "$bibtex" \
     && test -r "$filename_noext.aux" \
     && test -r "$filename_noext.log" \
     && (grep 'Warning:.*Citation.*undefined' "$filename_noext.log" \
          || grep 'No file .*\.bbl\.' "$filename_noext.log") \
        >&6 2>&1; \
  then
    # If using the bibunits package, we might have to run bibtex
    # on subfiles.
    for f in "$filename_noext".aux bu[0-9]*.aux
    do
      if test -s "$f" && \
         (grep '^\\bibstyle[{]' "$f"   \
          && grep '^\\bibdata[{]' "$f" \
          && grep '^\\citation[{]' "$f") >&6 2>&1; then
        verbose "Running $bibtex $f ..."
        $bibtex "$f" >&5 ||
          fatal 1 "$bibtex exited with bad status, quitting."
      fi
    done
  fi
}

# run_index ()
# ------------
# Run texindex (or makeindex) on current index files.  If they already
# exist, and after running TeX a first time the index files don't
# change, then there's no reason to run TeX again.  But we won't know
# that if the index files are out of date or nonexistent.
run_index ()
{
  index_files=`get_index_files $orig_xref_files`
  if test -n "$texindex" && test -n "$index_files"; then
    verbose "Running $texindex $index_files ..."
    $texindex $index_files 2>&5 1>&2 ||
       fatal 1 "$texindex exited with bad status, quitting."
  fi
}


# run_thumbpdf ()
# ---------------
run_thumbpdf ()
{
  if test $oformat = pdf \
     && test -r "$filename_noext.log" \
     && grep 'thumbpdf\.sty'  "$filename_noext.log" >&6 2>&1; \
  then
    thumbpdf=${THUMBPDF:-thumbpdf}
    verbose "Running $thumbpdf $filename_noext ..."
    if $thumbpdf "$filename_noext" >&5; then
      run_tex
    else
      report "$thumbpdf exited with bad status." \
	     "Ignoring its output."
    fi
  fi
}


## -------------------------------- ##
## TeX processing auxiliary tools.  ##
## -------------------------------- ##


# A sed script that preprocesses Texinfo sources in order to keep the
# iftex sections only.  We want to remove non TeX sections, and comment
# (with `@c texi2dvi') TeX sections so that makeinfo does not try to
# parse them.  Nevertheless, while commenting TeX sections, don't
# comment @macro/@end macro so that makeinfo does propagate them.
# Unfortunately makeinfo --iftex --no-ifinfo doesn't work well enough
# (yet), makeinfo can't parse the TeX commands, so work around with sed.
#
comment_iftex=\
'/^@tex/,/^@end tex/{
  s/^/@c texi2dvi/
}
/^@iftex/,/^@end iftex/{
  s/^/@c texi2dvi/
  /^@c texi2dvi@macro/,/^@c texi2dvi@end macro/{
    s/^@c texi2dvi//
  }
}
/^@ifnottex/,/^@end ifnottex/{
  s/^/@c (texi2dvi)/
}
/^@ifinfo/,/^@end ifinfo/{
  /^@node/p
  /^@menu/,/^@end menu/p
  t
  s/^/@c (texi2dvi)/
}
s/^@ifnotinfo/@c texi2dvi@ifnotinfo/
s/^@end ifnotinfo/@c texi2dvi@end ifnotinfo/'

# Uncommenting is simple: Remove any leading `@c texi2dvi'.
uncomment_iftex='s/^@c texi2dvi//'


# run_makeinfo ()
# ---------------
# Expand macro commands in the original source file using Makeinfo.
# Always use `end' footnote style, since the `separate' style
# generates different output (arguably this is a bug in -E).  Discard
# main info output, the user asked to run TeX, not makeinfo.
run_makeinfo ()
{
  if test -n "$makeinfo"; then
    # filename_src: the file with macros expanded.
    # Use the same basename to generate the same aux file names.
    work_src=$workdir/src
    ensure_dir "$work_src"
    filename_src=$work_src/$filename_noext.$ext

    verbose "Macro-expanding $command_line_filename to $filename_src ..."
    sed "$comment_iftex" "$command_line_filename" \
      | $makeinfo --footnote-style=end -I "$filename_dir" $miincludes \
        -o /dev/null --macro-expand=- \
      | sed "$uncomment_iftex" >"$filename_src"
    # Continue only if everything succeeded.
    if test $? -ne 0 \
       || test ! -r "$filename_src"; then
      verbose "Expansion failed, ignored...";
    else
      filename_input=$filename_src
    fi
  fi
}

# insert_commands ()
# ------------------
# Used most commonly for @finalout, @smallbook, etc.
insert_commands ()
{
  if test -n "$textra"; then
    # _xtr.  The file with the user's extra commands.
    work_xtr=$workdir/xtr
    filename_xtr=$work_xtr/$filename_noext.$ext
    ensure_dir $work_xtr
    verbose "Inserting extra commands: $textra"
    sed "$textra_cmd\\
$textra" "$filename_input" >"$filename_xtr"
    filename_input=$filename_xtr
  fi
}

# run_recode ()
# -------------
# If this is a Texinfo file with a specified input encoding, and
# recode is available, then recode to plain 7 bit Texinfo.
run_recode ()
{
  if test $language = texinfo; then
    pgm='s/^ *@documentencoding  *\([^ ][^ ]*\) *$/\1/
	t found
	d
	:found
	q'
    encoding=`sed -e "$pgm" "$filename_input"`
    if $recode && test -n "$encoding" && findprog recode; then
      verbose "Recoding from $encoding to Texinfo."
      # _rcd.  The Texinfo file recoded in 7bit.
      work_rcd=$workdir/rcd
      filename_rcd=$work_rcd/$filename_noext.$ext
      ensure_dir $work_rcd
      if recode "$encoding"..texinfo <"$filename_input" >"$filename_rcd" \
         && test -s "$filename_rcd"; then
        filename_input=$filename_rcd
      else
        verbose "Recoding failed, using original input."
      fi
    fi
  fi
}

## ---------------------- ##
## Command line parsing.  ##
## ---------------------- ##

# Push a token among the arguments that will be used to notice when we
# ended options/arguments parsing.
# Use "set dummy ...; shift" rather than 'set - ..." because on
# Solaris set - turns off set -x (but keeps set -e).
# Use ${1+"$@"} rather than "$@" because Digital Unix and Ultrix 4.3
# still expand "$@" to a single argument (the empty string) rather
# than nothing at all.
arg_sep="$$--$$"
set dummy ${1+"$@"} "$arg_sep"; shift

# 
# Parse command line arguments.
while test x"$1" != x"$arg_sep"; do

  # Handle --option=value by splitting apart and putting back on argv.
  case "$1" in
    --*=*)
      opt=`echo "$1" | sed -e 's/=.*//'`
      val=`echo "$1" | sed -e 's/[^=]*=//'`
      shift
      set dummy "$opt" "$val" ${1+"$@"}; shift
      ;;
  esac

  # This recognizes --quark as --quiet.  So what.
  case "$1" in
    -@ ) escape=@;;
    # Silently and without documentation accept -b and --b[atch] as synonyms.
    -b | --b*) batch=true;;
    -c | --c*) build_mode=clean;;
    -D | --d*) debug=true;;
    -e | -E | --e*) expand=t;;
    -h | --h*) echo "$usage"; exit 0;;
    -I | --I*)
      shift
      miincludes="$miincludes -I $1"
      txincludes="$txincludes$1$path_sep"
      ;;
    -l | --l*) shift; set_language=$1;;
    -o | --o*)
      shift
      # Make it absolute, just in case we also have --clean, or whatever.
      case "$1" in
        /* | ?:/*) oname=$1;;
                *) oname="$orig_pwd/$1";;
      esac;;
    -p | --p*) oformat=pdf;;
    -q | -s | --q* | --s*) quiet=t; batch=true;;
    -r | --r*) recode=true;;
    -t | --tex* | --com* ) shift; textra="$textra\\
"`echo "$1" | sed 's/\\\\/\\\\\\\\/g'`;;
    --tidy) build_mode=tidy;;
    -v | --vers*) echo "$version"; exit 0;;
    -V | --verb*) verb=echo;;
    --) # What remains are not options.
      shift
      while test x"$1" != x"$arg_sep"; do
        set dummy ${1+"$@"} "$1"; shift
        shift
      done
      break;;
    -*)
      fatal 1 "Unknown or ambiguous option \`$1'." \
              "Try \`--help' for more information."
      ;;
    *) set dummy ${1+"$@"} "$1"; shift;;
   esac
   shift
done
# Pop the token
shift

case $build_mode in
  local) clean=true;  tidy=false;;
  tidy)  clean=false; tidy=true;;
  clean) clean=true;  tidy=true;;
      *) fatal 1 "invalid build mode: $build_mode";;
esac

# Interpret remaining command line args as filenames.
case $# in
 0)
  fatal 2 "Missing file arguments." "Try \`--help' for more information."
  ;;
 1) ;;
 *)
  if test -n "$oname"; then
    fatal 2 "Can't use option \`--output' with more than one argument."
  fi
  ;;
esac


# We can't do much without tex.
#
if findprog ${TEX:-tex}; then :; else cat <<EOM
You don't have a working TeX binary (${TEX:-tex}) installed anywhere in
your PATH, and texi2dvi cannot proceed without one.  If you want to use
this script, you'll need to install TeX (if you don't have it) or change
your PATH or TEX environment variable (if you do).  See the --help
output for more details.

For information about obtaining TeX, please see http://www.tug.org.  If
you happen to be using Debian, you can get it with this command:
  apt-get install tetex-bin
EOM
  exit 1
fi


# We want to use etex (or pdftex) if they are available, and the user
# didn't explicitly specify.  We don't check for elatex and pdfelatex
# because (as of 2003), the LaTeX team has asked that new distributions
# use etex by default anyway.
#
# End up with the TEX and PDFTEX variables set to what we are going to use.
if test -z "$TEX"; then
  if findprog etex; then TEX=etex; else TEX=tex; fi
fi
#
if test -z "$PDFTEX"; then
  if findprog pdfetex; then PDFTEX=pdfetex; else PDFTEX=pdftex; fi
fi


# File descriptor usage:
# 0 standard input
# 1 standard output (--verbose messages)
# 2 standard error
# 3 some systems may open it to /dev/tty
# 4 used on the Kubota Titan
# 5 tools output (turned off by --quiet)
# 6 tracing/debugging (set -x output, etc.)


# Main tools' output (TeX, etc.) that TeX users are used to seeing.
#
# If quiet, discard, else redirect to the message flow.
if test "$quiet" = t; then
  exec 5>/dev/null
else
  exec 5>&1
fi


# Enable tracing, and auxiliary tools output.
#
# Should be used where you'd typically use /dev/null to throw output
# away.  But sometimes it is convenient to see that output (e.g., from
# a grep) to aid debugging.  Especially debugging at distance, via the
# user.
if $debug; then
  exec 6>&1
  set -x
else
  exec 6>/dev/null
fi

# 

## -------------- ##
## TeXify files.  ##
## -------------- ##

for command_line_filename in ${1+"$@"}; do
  verbose "Processing $command_line_filename ..."

  # If the COMMAND_LINE_FILENAME is not absolute (e.g., --debug.tex),
  # prepend `./' in order to avoid that the tools take it as an option.
  echo "$command_line_filename" | $EGREP '^(/|[A-z]:/)' >&6 \
  || command_line_filename="./$command_line_filename"

  # See if the file exists.  If it doesn't we're in trouble since, even
  # though the user may be able to reenter a valid filename at the tex
  # prompt (assuming they're attending the terminal), this script won't
  # be able to find the right xref files and so forth.
  if test ! -r "$command_line_filename"; then
    report "Could not read $command_line_filename, skipping."
    continue
  fi

  # Get the name of the current directory.  We want the full path
  # because in clean build mode we are in tmp, in which case a relative
  # path has no meaning.
  filename_dir=`echo $command_line_filename | sed 's!/[^/]*$!!;s!^$!.!'`
  filename_dir=`cd "$filename_dir" >&6 && pwd`

  # Strip directory part but leave extension.
  filename_ext=`basename "$command_line_filename"`
  # Strip extension.
  filename_noext=`echo "$filename_ext" | sed 's/\.[^.]*$//'`
  ext=`echo "$filename_ext" | sed 's/^.*\.//'`

  # The normalized file name to compile.  Must always point to the
  # file to actually compile (in case of recoding, macro-expansion etc.).
  filename_input=$filename_dir/$filename_ext

  # An auxiliary directory used for all the auxiliary tasks involved
  # in compiling this document.
  t2ddir=`$clean && echo ${TMPDIR:-/tmp}/`$filename_noext.t2d
  # Remove it at exit if clean mode.
  $clean &&
    trap "cd / && rm -rf $t2ddir" 0 1 2 15

  ensure_dir "$t2ddir"

  # We will change directory, better work with an absolute path...
  t2ddir=`cd "$t2ddir" && pwd`
  # Sometimes there are incompatibilities between auxiliary files for
  # DVI and PDF.  The contents can also change whether we work on PDF
  # and/or DVI.  So keep separate spaces for each.
  workdir=$t2ddir/$oformat
  ensure_dir "$workdir"

  # _build.  In a tidy build, where the auxiliary files are output.
  if $tidy; then
    work_build=$workdir/build
  else
    work_build=.
  fi

  # _bak.  Copies of the previous auxiliary files (another round is
  # run if they differ from the new ones).
  work_bak=$workdir/bak

  # Make those directories.
  ensure_dir $work_build $work_bak

  # Source file might include additional sources.
  # We want `.:$orig_pwd' before anything else.  (We'll add `.:' later
  # after all other directories have been turned into absolute paths.)
  # `.' goes first to ensure that any old .aux, .cps,
  # etc. files in ${directory} don't get used in preference to fresher
  # files in `.'.  Include orig_pwd in case we are in clean build mode, where
  # we've cd'd to a temp directory.
  common="$orig_pwd$path_sep$filename_dir$path_sep$txincludes"
  for var in $tex_envvars; do
    eval val="\$common\$${var}_orig"
    # Convert relative paths to absolute paths, so we can run in another
    # directory (e.g., in clean build mode, or during the macro-support
    # detection).
    val=`absolute_filenames "$val"`
    eval export $var=$val
    eval verbose "$var=\'\$${var}\'"
  done

  # If the user explicitly specified the language, use that.
  # Otherwise, if the first line is \input texinfo, assume it's texinfo.
  # Otherwise, guess from the file extension.
  if test -n "$set_language"; then
    language=$set_language
  elif sed 1q "$command_line_filename" | grep 'input texinfo' >&6; then
    language=texinfo
  else
    language=
  fi

  # Get the type of the file (latex or texinfo) from the given language
  # we just guessed, or from the file extension if not set yet.
  case ${language:-$filename_ext} in
    [lL]a[tT]e[xX] | *.ltx | *.tex | *.drv | *.dtx)
      # Assume a LaTeX file.  LaTeX needs bibtex and uses latex for
      # compilation.  No makeinfo.
      language=latex
      bibtex=${BIBTEX:-bibtex}
      makeinfo= # no point in running makeinfo on latex source.
      texindex=${MAKEINDEX:-makeindex}
      textra_cmd=1i
      if test $oformat = dvi; then
        tex=${LATEX:-latex}
      else
        tex=${PDFLATEX:-pdflatex}
      fi
      ;;

    *)
      # Assume a Texinfo file.  Texinfo files need makeinfo, texindex and tex.
      language=texinfo
      bibtex=
      texindex=${TEXINDEX:-texindex}
      textra_cmd='/^@setfilename/a'
      if test $oformat = dvi; then
        # MetaPost also uses the TEX environment variable.  If the user
        # has set TEX=latex for that reason, don't bomb out.
        if echo $TEX | grep 'latex$' >&6; then
          tex=tex  # don't bother trying to find etex
        else
          tex=$TEX
        fi
      else
        tex=$PDFTEX
      fi
      # Unless required by the user, makeinfo expansion is wanted only
      # if texinfo.tex is too old.
      if test "$expand" = t; then
        makeinfo=${MAKEINFO:-makeinfo}
      else
        # Check if texinfo.tex performs macro expansion by looking for
        # its version.  The version is a date of the form YEAR-MO-DA.
        # We don't need to use [0-9] to match the digits since anyway
        # the comparison with $txiprereq, a number, will fail with non
        # digits.
        # Run in a temporary directory to avoid leaving files.
	version_test_dir=$t2ddir/version_test
	ensure_dir $version_test_dir
	(
           cd $version_test_dir
	   echo '\input texinfo.tex @bye' >txiversion.tex
	   # Be sure that if tex wants to fail, it is not interactive:
	   # close stdin.
           $tex txiversion.tex </dev/null >txiversion.out 2>txiversion.err
	)
	if test $? != 0; then
	  cat $version_test_dir/txiversion.out
	  cat $version_test_dir/txiversion.err >&2
	  fatal 1 "texinfo.tex appears to be broken, quitting."
        fi
	eval `sed -n 's/^.*\[\(.*\)version \(....\)-\(..\)-\(..\).*$/txiformat=\1 txiversion="\2\3\4"/p' $version_test_dir/txiversion.out`
        verbose "texinfo.tex preloaded as \`$txiformat', version is \`$txiversion' ..."
        if test "$txiprereq" -le "$txiversion" >&6 2>&1; then
          makeinfo=
        else
          makeinfo=${MAKEINFO:-makeinfo}
        fi
        # As long as we had to run TeX, offer the user this convenience:
        test "$txiformat" = Texinfo && escape=@
      fi
      ;;
  esac

  # Go to a temporary directory to try --help, since old versions that
  # don't accept --help will generate a texput.log.
  tex_help_dir=$t2ddir/tex_help
  ensure_dir $tex_help_dir
  tex_help=`cd $tex_help_dir >&6 && $tex --help </dev/null 2>&1`

  # --expand
  run_makeinfo

  # --command, --texinfo
  insert_commands

  # --recode
  run_recode

  # Count the number of cycles.
  cycle=0

  # Move to the working directory.
  if $tidy; then
    verbose "cd $work_build"
    cd "$work_build" || exit 1
  fi

  while :; do # will break out of loop below
    cycle=`expr $cycle + 1`
    verbose "Cycle $cycle for $command_line_filename"

    # Save copies of auxiliary files for later comparison.
    orig_xref_files=`get_xref_files  "$filename_noext"`
    if test -n "$orig_xref_files"; then
      verbose "Backing up xref files: $orig_xref_files"
      cp $orig_xref_files $work_bak
    fi

    run_bibtex
    run_index
    run_tex

    # LaTeX (and the package changebar) report in the LOG file if it
    # should be rerun.  This is needed for files included from
    # subdirs, since texi2dvi does not try to compare xref files in
    # subdirs.  Performing xref files test is still good since LaTeX
    # does not report changes in xref files.
    grep "Rerun to get" "$filename_noext.log" >&6 2>&1 &&
      continue

    # If old and new lists don't at least have the same file list,
    # then one file or another has definitely changed.
    new_xref_files=`get_xref_files  "$filename_noext"`
    verbose "Original xref files = $orig_xref_files"
    verbose "New xref files      = $new_xref_files"
    test "x$orig_xref_files" != "x$new_xref_files" &&
      continue

    # Compare each file until we find a difference.
    for this_file in $new_xref_files; do
      verbose "Comparing xref file `echo $this_file | sed 's|\./||g'` ..."
      # cmp -s returns nonzero exit status if files differ.
      if cmp -s "$this_file" "$work_bak/$this_file"; then :; else
        verbose "xref file `echo $this_file | sed 's|\./||g'` differed ..."
        $debug && diff -u "$work_bak/$this_file" "$this_file"
        continue 2
      fi
    done

    # We're done.
    break
  done # while :;

  # If we were using thumbpdf and producing PDF, then run thumbpdf
  # and TeX one last time.
  run_thumbpdf

  # Return to the original directory so that
  # - the next file is processed in correct conditions
  # - the temporary file can be removed
  cd / # in case $orig_pwd is on a different drive (for DOS)
  cd $orig_pwd || exit 1

  # Remove temporary files.
  if $clean; then
    verbose "Removing $t2ddir"
    cd /
    rm -rf "$t2ddir"
  fi
done

verbose "done."
exit 0 # exit successfully, not however we ended the loop.
