@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/poly_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/poly_lib.doc INSTEAD
@c library version: (1.33.2.6,2003/02/10)
@c library file: ../Singular/LIB/poly.lib
@cindex poly.lib
@cindex poly_lib
@table @asis
@item @strong{Library:}
poly.lib
@item @strong{Purpose:}
      Procedures for Manipulating Polys, Ideals, Modules
@item @strong{Authors:}
O. Bachmann, G.-M: Greuel, A. Fruehbis

@end table

@strong{Procedures:}
@menu
* cyclic:: ideal of cyclic n-roots
* katsura:: katsura [i] ideal
* freerank:: rank of coker(input) if coker is free else -1
* is_homog:: int, =1 resp. =0 if input is homogeneous resp. not
* is_zero:: int, =1 resp. =0 if coker(input) is 0 resp. not
* lcm:: lcm of given generators of ideal
* maxcoef:: maximal length of coefficient occurring in poly/...
* maxdeg:: int/intmat = degree/s of terms of maximal order
* maxdeg1:: int = [weighted] maximal degree of input
* mindeg:: int/intmat = degree/s of terms of minimal order
* mindeg1:: int = [weighted] minimal degree of input
* normalize:: normalize poly/... such that leading coefficient is 1
* rad_con:: check radical containment of poly p in ideal I
* content:: content of polynomial/vector f
* numerator:: numerator of number n
* denominator:: denominator of number n
* mod2id:: conversion of a module M to an ideal
* id2mod:: conversion inverse to mod2id
* substitute:: substitute in I variables by polynomials
* subrInterred:: interred w.r.t. a subset of variables
* hilbPoly:: Hilbert polynomial of basering/I
@end menu
@c ---end content LibInfo---

@c ------------------- cyclic -------------
@node cyclic, katsura,, poly_lib
@subsubsection cyclic
@cindex cyclic
@c ---content cyclic---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
cyclic(n); n integer

@item @strong{Return:}
ideal of cyclic n-roots from 1-st n variables of basering

@end table
@strong{Example:}
@smallexample
@c computed example cyclic d2t_singular/poly_lib.doc:59 
LIB "poly.lib";
ring r=0,(u,v,w,x,y,z),lp;
cyclic(nvars(basering));
@expansion{} _[1]=u+v+w+x+y+z
@expansion{} _[2]=uv+uz+vw+wx+xy+yz
@expansion{} _[3]=uvw+uvz+uyz+vwx+wxy+xyz
@expansion{} _[4]=uvwx+uvwz+uvyz+uxyz+vwxy+wxyz
@expansion{} _[5]=uvwxy+uvwxz+uvwyz+uvxyz+uwxyz+vwxyz
@expansion{} _[6]=uvwxyz-1
homog(cyclic(5),z);
@expansion{} _[1]=u+v+w+x+y
@expansion{} _[2]=uv+uy+vw+wx+xy
@expansion{} _[3]=uvw+uvy+uxy+vwx+wxy
@expansion{} _[4]=uvwx+uvwy+uvxy+uwxy+vwxy
@expansion{} _[5]=uvwxy-z5
@c end example cyclic d2t_singular/poly_lib.doc:59
@end smallexample
@c ---end content cyclic---

@c ------------------- katsura -------------
@node katsura, freerank, cyclic, poly_lib
@subsubsection katsura
@cindex katsura
@c ---content katsura---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
katsura([n]): n integer

@item @strong{Return:}
katsura(n) : n-th katsura ideal of
@*(1) newly created and set ring (32003, x(0..n), dp), if
nvars(basering) < n
@*(2) basering, if nvars(basering) >= n
@*katsura() : katsura ideal of basering

@end table
@strong{Example:}
@smallexample
@c computed example katsura d2t_singular/poly_lib.doc:89 
LIB "poly.lib";
ring r; basering;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
katsura();
@expansion{} _[1]=x+2y+2z-1
@expansion{} _[2]=x2+2y2+2z2-x
@expansion{} _[3]=2xy+2yz-y
katsura(4); basering;
@expansion{} _[1]=x(0)+2*x(1)+2*x(2)+2*x(3)-1
@expansion{} _[2]=x(0)^2+2*x(1)^2+2*x(2)^2+2*x(3)^2-x(0)
@expansion{} _[3]=2*x(0)*x(1)+2*x(1)*x(2)+2*x(2)*x(3)-x(1)
@expansion{} _[4]=x(1)^2+2*x(0)*x(2)+2*x(1)*x(3)-x(2)
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x(0) x(1) x(2) x(3) x(4) 
@expansion{} //        block   2 : ordering C
@c end example katsura d2t_singular/poly_lib.doc:89
@end smallexample
@c ---end content katsura---

@c ------------------- freerank -------------
@node freerank, is_homog, katsura, poly_lib
@subsubsection freerank
@cindex freerank
@c ---content freerank---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
freerank(M[,any]); M=poly/ideal/vector/module/matrix

@item @strong{Compute:}
rank of module presented by M in case it is free.
@*By definition this is vdim(coker(M)/m*coker(M)) if coker(M)
is free, where m = maximal ideal of the variables of the
basering and M is considered as matrix.
@*(the 0-module is free of rank 0)

@item @strong{Return:}
rank of coker(M) if coker(M) is free and -1 else;
@*in case of a second argument return a list:
@*L[1] = rank of coker(M) or -1
@*L[2] = minbase(M)

@item @strong{Note:}
freerank(syz(M)); computes the rank of M if M is free (and -1 else)

@end table
@strong{Example:}
@smallexample
@c computed example freerank d2t_singular/poly_lib.doc:128 
LIB "poly.lib";
ring r;
ideal i=x;
module M=[x,0,1],[-x,0,-1];
freerank(M);          // should be 2, coker(M) is not free
@expansion{} 2
freerank(syz (M),"");
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    _[1]=gen(2)+gen(1)
// [1] should be 1, coker(syz(M))=M is free of rank 1
// [2] should be gen(2)+gen(1) (minimal relation of M)
freerank(i);
@expansion{} -1
freerank(syz(i));     // should be 1, coker(syz(i))=i is free of rank 1
@expansion{} 1
@c end example freerank d2t_singular/poly_lib.doc:128
@end smallexample
@c ---end content freerank---

@c ------------------- is_homog -------------
@node is_homog, is_zero, freerank, poly_lib
@subsubsection is_homog
@cindex is_homog
@c ---content is_homog---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
is_homog(id); id poly/ideal/vector/module/matrix

@item @strong{Return:}
integer which is 1 if input is homogeneous (resp. weighted homogeneous
if the monomial ordering consists of one block of type ws,Ws,wp or Wp,
assuming that all weights are positive) and 0 otherwise

@item @strong{Note:}
A vector is homogeneous, if the components are homogeneous of same
degree, a module/matrix is homogeneous if all column vectors are
homogeneous
@*//*** ergaenzen, wenn Matrizen-Spalten Gewichte haben

@end table
@strong{Example:}
@smallexample
@c computed example is_homog d2t_singular/poly_lib.doc:168 
LIB "poly.lib";
ring r = 0,(x,y,z),wp(1,2,3);
is_homog(x5-yz+y3);
@expansion{} 0
ideal i = x6+y3+z2, x9-z3;
is_homog(i);
@expansion{} 1
ring s = 0,(a,b,c),ds;
vector v = [a2,0,ac+bc];
vector w = [a3,b3,c4];
is_homog(v);
@expansion{} 1
is_homog(w);
@expansion{} 0
@c end example is_homog d2t_singular/poly_lib.doc:168
@end smallexample
@c ---end content is_homog---

@c ------------------- is_zero -------------
@node is_zero, lcm, is_homog, poly_lib
@subsubsection is_zero
@cindex is_zero
@c ---content is_zero---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
is_zero(M[,any]); M=poly/ideal/vector/module/matrix

@item @strong{Return:}
integer, 1 if coker(M)=0 resp. 0 if coker(M)!=0, where M is
considered as matrix.
@*If a second argument is given, return a list:
@*L[1] = 1 if coker(M)=0 resp. 0 if coker(M)!=0
@*L[2] = dim(M)

@end table
@strong{Example:}
@smallexample
@c computed example is_zero d2t_singular/poly_lib.doc:204 
LIB "poly.lib";
ring r;
module m = [x],[y],[1,z];
is_zero(m,1);
@expansion{} [1]:
@expansion{}    0
@expansion{} [2]:
@expansion{}    2
qring q = std(ideal(x2+y3+z2));
ideal j = x2+y3+z2-37;
is_zero(j);
@expansion{} 1
@c end example is_zero d2t_singular/poly_lib.doc:204
@end smallexample
@c ---end content is_zero---

@c ------------------- lcm -------------
@node lcm, maxcoef, is_zero, poly_lib
@subsubsection lcm
@cindex lcm
@c ---content lcm---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
lcm(p[,q]); p int/intvec q a list of integers or
@*p poly/ideal q a list of polynomials

@item @strong{Return:}
the least common multiple of the common entries of p and q:
@* - of type int if p is an int/intvec
@* - of type poly if p is a poly/ideal

@end table
@strong{Example:}
@smallexample
@c computed example lcm d2t_singular/poly_lib.doc:236 
LIB "poly.lib";
ring  r = 0,(x,y,z),lp;
poly  p = (x+y)*(y+z);
poly  q = (z4+2)*(y+z);
lcm(p,q);
@expansion{} xyz4+2xy+xz5+2xz+y2z4+2y2+yz5+2yz
ideal i=p,q,y+z;
lcm(i,p);
@expansion{} xyz4+2xy+xz5+2xz+y2z4+2y2+yz5+2yz
lcm(2,3,6);
@expansion{} 6
lcm(2..6);
@expansion{} 60
@c end example lcm d2t_singular/poly_lib.doc:236
@end smallexample
@c ---end content lcm---

@c ------------------- maxcoef -------------
@node maxcoef, maxdeg, lcm, poly_lib
@subsubsection maxcoef
@cindex maxcoef
@c ---content maxcoef---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
maxcoef(f); f poly/ideal/vector/module/matrix

@item @strong{Return:}
maximal length of coefficient of f of type int (by counting the
length of the string of each coefficient)

@end table
@strong{Example:}
@smallexample
@c computed example maxcoef d2t_singular/poly_lib.doc:268 
LIB "poly.lib";
ring r= 0,(x,y,z),ds;
poly g = 345x2-1234567890y+7/4z;
maxcoef(g);
@expansion{} 10
ideal i = g,10/1234567890;
maxcoef(i);
@expansion{} 11
// since i[2]=1/123456789
@c end example maxcoef d2t_singular/poly_lib.doc:268
@end smallexample
@c ---end content maxcoef---

@c ------------------- maxdeg -------------
@node maxdeg, maxdeg1, maxcoef, poly_lib
@subsubsection maxdeg
@cindex maxdeg
@c ---content maxdeg---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
maxdeg(id); id poly/ideal/vector/module/matrix

@item @strong{Return:}
int/intmat, each component equals maximal degree of monomials in the
corresponding component of id, independent of ring ordering
(maxdeg of each var is 1).
@*Of type int if id is of type poly, of type intmat else

@item @strong{Note:}
proc maxdeg1 returns 1 integer, the absolute maximum; moreover, it has
an option for computing weighted degrees

@end table
@strong{Example:}
@smallexample
@c computed example maxdeg d2t_singular/poly_lib.doc:304 
LIB "poly.lib";
ring r = 0,(x,y,z),wp(1,2,3);
poly f = x+y2+z3;
deg(f);             //deg; returns weighted degree (in case of 1 block)!
@expansion{} 9
maxdeg(f);
@expansion{} 3
matrix m[2][2]=f+x10,1,0,f^2;
maxdeg(m);
@expansion{} 10,0,
@expansion{} -1,6 
@c end example maxdeg d2t_singular/poly_lib.doc:304
@end smallexample
@c ---end content maxdeg---

@c ------------------- maxdeg1 -------------
@node maxdeg1, mindeg, maxdeg, poly_lib
@subsubsection maxdeg1
@cindex maxdeg1
@c ---content maxdeg1---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
maxdeg1(id[,v]); id=poly/ideal/vector/module/matrix, v=intvec

@item @strong{Return:}
integer, maximal [weighted] degree of monomials of id independent of
ring ordering, maxdeg1 of i-th variable is v[i] (default: v=1..1).

@item @strong{Note:}
This proc returns one integer while maxdeg returns, in general,
a matrix of integers. For one polynomial and if no intvec v is given
maxdeg is faster

@end table
@strong{Example:}
@smallexample
@c computed example maxdeg1 d2t_singular/poly_lib.doc:339 
LIB "poly.lib";
ring r = 0,(x,y,z),wp(1,2,3);
poly f = x+y2+z3;
deg(f);            //deg returns weighted degree (in case of 1 block)!
@expansion{} 9
maxdeg1(f);
@expansion{} 3
intvec v = ringweights(r);
maxdeg1(f,v);                        //weighted maximal degree
@expansion{} 9
matrix m[2][2]=f+x10,1,0,f^2;
maxdeg1(m,v);                        //absolute weighted maximal degree
@expansion{} 18
@c end example maxdeg1 d2t_singular/poly_lib.doc:339
@end smallexample
@c ---end content maxdeg1---

@c ------------------- mindeg -------------
@node mindeg, mindeg1, maxdeg1, poly_lib
@subsubsection mindeg
@cindex mindeg
@c ---content mindeg---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
mindeg(id); id poly/ideal/vector/module/matrix

@item @strong{Return:}
minimal degree/s of monomials of id, independent of ring ordering
(mindeg of each variable is 1) of type int if id of type poly, else
of type intmat.

@item @strong{Note:}
proc mindeg1 returns one integer, the absolute minimum; moreover it
has an option for computing weighted degrees.

@end table
@strong{Example:}
@smallexample
@c computed example mindeg d2t_singular/poly_lib.doc:376 
LIB "poly.lib";
ring r = 0,(x,y,z),ls;
poly f = x5+y2+z3;
ord(f);                  // ord returns weighted order of leading term!
@expansion{} 3
mindeg(f);               // computes minimal degree
@expansion{} 2
matrix m[2][2]=x10,1,0,f^2;
mindeg(m);               // computes matrix of minimum degrees
@expansion{} 10,0,
@expansion{} -1,4 
@c end example mindeg d2t_singular/poly_lib.doc:376
@end smallexample
@c ---end content mindeg---

@c ------------------- mindeg1 -------------
@node mindeg1, normalize, mindeg, poly_lib
@subsubsection mindeg1
@cindex mindeg1
@c ---content mindeg1---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
mindeg1(id[,v]); id=poly/ideal/vector/module/matrix, v=intvec

@item @strong{Return:}
integer, minimal [weighted] degree of monomials of id independent of
ring ordering, mindeg1 of i-th variable is v[i] (default v=1..1).

@item @strong{Note:}
This proc returns one integer while mindeg returns, in general,
a matrix of integers. For one polynomial and if no intvec v is given
mindeg is faster.

@end table
@strong{Example:}
@smallexample
@c computed example mindeg1 d2t_singular/poly_lib.doc:411 
LIB "poly.lib";
ring r = 0,(x,y,z),ls;
poly f = x5+y2+z3;
ord(f);                  // ord returns weighted order of leading term!
@expansion{} 3
intvec v = 1,-3,2;
mindeg1(f,v);            // computes minimal weighted degree
@expansion{} -6
matrix m[2][2]=x10,1,0,f^2;
mindeg1(m,1..3);         // computes absolute minimum of weighted degrees
@expansion{} -1
@c end example mindeg1 d2t_singular/poly_lib.doc:411
@end smallexample
@c ---end content mindeg1---

@c ------------------- normalize -------------
@node normalize, rad_con, mindeg1, poly_lib
@subsubsection normalize
@cindex normalize
@c ---content normalize---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
normalize(id); id=poly/vector/ideal/module

@item @strong{Return:}
object of same type with leading coefficient equal to 1

@end table
@strong{Example:}
@smallexample
@c computed example normalize d2t_singular/poly_lib.doc:441 
LIB "poly.lib";
ring r = 0,(x,y,z),ls;
poly f = 2x5+3y2+4z3;
normalize(f);
@expansion{} z3+3/4y2+1/2x5
module m=[9xy,0,3z3],[4z,6y,2x];
normalize(m);
@expansion{} _[1]=z3*gen(3)+3xy*gen(1)
@expansion{} _[2]=z*gen(1)+3/2y*gen(2)+1/2x*gen(3)
ring s = 0,(x,y,z),(c,ls);
module m=[9xy,0,3z3],[4z,6y,2x];
normalize(m);
@expansion{} _[1]=[xy,0,1/3z3]
@expansion{} _[2]=[z,3/2y,1/2x]
@c end example normalize d2t_singular/poly_lib.doc:441
@end smallexample
@c ---end content normalize---

@c ------------------- rad_con -------------
@node rad_con, content, normalize, poly_lib
@subsubsection rad_con
@cindex rad_con
@c ---content rad_con---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
rad_con(g,I); g polynomial, I ideal

@item @strong{Return:}
1 (TRUE) (type int) if g is contained in the radical of I
@* 0 (FALSE) (type int) otherwise

@end table
@strong{Example:}
@smallexample
@c computed example rad_con d2t_singular/poly_lib.doc:473 
LIB "poly.lib";
ring R=0,(x,y,z),dp;
ideal I=x2+y2,z2;
poly f=x4+y4;
rad_con(f,I);
@expansion{} 0
ideal J=x2+y2,z2,x4+y4;
poly g=z;
rad_con(g,I);
@expansion{} 1
@c end example rad_con d2t_singular/poly_lib.doc:473
@end smallexample
@c ---end content rad_con---

@c ------------------- content -------------
@node content, numerator, rad_con, poly_lib
@subsubsection content
@cindex content
@c ---content content---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
content(f); f polynomial/vector

@item @strong{Return:}
number, the content (greatest common factor of coefficients)
of the polynomial/vector f

@end table
@strong{Example:}
@smallexample
@c computed example content d2t_singular/poly_lib.doc:504 
LIB "poly.lib";
ring r=0,(x,y,z),(c,lp);
content(3x2+18xy-27xyz);
@expansion{} 3
vector v=[3x2+18xy-27xyz,15x2+12y4,3];
content(v);
@expansion{} 3
@c end example content d2t_singular/poly_lib.doc:504
@end smallexample
@c ---end content content---

@c ------------------- numerator -------------
@node numerator, denominator, content, poly_lib
@subsubsection numerator
@cindex numerator
@c ---content numerator---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
numerator(n); n number

@item @strong{Return:}
number, the numerator of n

@end table
@strong{Example:}
@smallexample
@c computed example numerator d2t_singular/poly_lib.doc:531 
LIB "poly.lib";
ring r = 0,x, dp;
number n = 3/2;
numerator(n);
@expansion{} 3
@c end example numerator d2t_singular/poly_lib.doc:531
@end smallexample
@c inserted refs from d2t_singular/poly_lib.doc:538
@ifinfo
@menu
See also:
* cleardenom::
* content::
* denominator::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{cleardenom};
@ref{content};
@ref{denominator}.
@end iftex
@c end inserted refs from d2t_singular/poly_lib.doc:538

@c ---end content numerator---

@c ------------------- denominator -------------
@node denominator, mod2id, numerator, poly_lib
@subsubsection denominator
@cindex denominator
@c ---content denominator---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
denominator(n); n number

@item @strong{Return:}
number, the denominator of n

@end table
@strong{Example:}
@smallexample
@c computed example denominator d2t_singular/poly_lib.doc:561 
LIB "poly.lib";
ring r = 0,x, dp;
number n = 3/2;
denominator(n);
@expansion{} 2
@c end example denominator d2t_singular/poly_lib.doc:561
@end smallexample
@c inserted refs from d2t_singular/poly_lib.doc:568
@ifinfo
@menu
See also:
* cleardenom::
* content::
* denominator::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{cleardenom};
@ref{content};
@ref{denominator}.
@end iftex
@c end inserted refs from d2t_singular/poly_lib.doc:568

@c ---end content denominator---

@c ------------------- mod2id -------------
@node mod2id, id2mod, denominator, poly_lib
@subsubsection mod2id
@cindex mod2id
@c ---content mod2id---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
mod2id(M,vpos); M matrix, vpos intvec

@item @strong{Assume:}
vpos is an integer vector such that gen(i) corresponds
to var(vpos[i]).
@*The basering contains variables var(vpos[i]) which do not occur
in M.

@item @strong{Return:}
ideal I in which each gen(i) from the module is replaced by
var(vpos[i]) and all monomials var(vpos[i])*var(vpos[j]) have
been added to the generating set of I.

@item @strong{Note:}
This procedure should be used in the following situation:
one wants to pass to a ring with new variables, say e(1),..,e(s),
which correspond to the components gen(1),..,gen(s) of the
module M such that e(i)*e(j)=0 for all i,j.
@*The new ring should already exist and be the current ring

@end table
@strong{Example:}
@smallexample
@c computed example mod2id d2t_singular/poly_lib.doc:606 
LIB "poly.lib";
ring r=0,(e(1),e(2),x,y,z),(dp(2),ds(3));
module mo=x*gen(1)+y*gen(2);
intvec iv=2,1;
mod2id(mo,iv);
@expansion{} _[1]=e(2)^2
@expansion{} _[2]=e(1)*e(2)
@expansion{} _[3]=e(1)^2
@expansion{} _[4]=e(1)*y+e(2)*x
@c end example mod2id d2t_singular/poly_lib.doc:606
@end smallexample
@c ---end content mod2id---

@c ------------------- id2mod -------------
@node id2mod, substitute, mod2id, poly_lib
@subsubsection id2mod
@cindex id2mod
@c ---content id2mod---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
id2mod(I,vpos); I ideal, vpos intvec

@item @strong{Return:}
module corresponding to the ideal by replacing var(vpos[i]) by
gen(i) and omitting all generators var(vpos[i])*var(vpos[j])

@item @strong{Note:}
* This procedure only makes sense if the ideal contains
all var(vpos[i])*var(vpos[j]) as monomial generators and
all other generators of I are linear combinations of the
var(vpos[i]) over the ring in the other variables.
@** This is the inverse procedure to mod2id and should be applied
only to ideals created by mod2id using the same intvec vpos
(possibly after a standard basis computation)

@end table
@strong{Example:}
@smallexample
@c computed example id2mod d2t_singular/poly_lib.doc:643 
LIB "poly.lib";
ring r=0,(e(1),e(2),x,y,z),(dp(2),ds(3));
ideal i=e(2)^2,e(1)*e(2),e(1)^2,e(1)*y+e(2)*x;
intvec iv=2,1;
id2mod(i,iv);
@expansion{} _[1]=x*gen(1)+y*gen(2)
@c end example id2mod d2t_singular/poly_lib.doc:643
@end smallexample
@c ---end content id2mod---

@c ------------------- substitute -------------
@node substitute, subrInterred, id2mod, poly_lib
@subsubsection substitute
@cindex substitute
@c ---content substitute---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
- case 1: typeof(#[1])==poly:
@*substitute (I,v,f[,v1,f1,v2,f2,...]); I object of basering which
can be mapped, v,v1,v2,.. ring variables, f,f1,f2,... poly
@* - case 2: typeof(#[1])==ideal:
substitute1 (I,v,f); I object of basering which can be mapped,
v ideal of ring variables, f ideal

@item @strong{Return:}
object of same type as I,
@* - case 1: ring variable v,v1,v2,... substituted by polynomials
f,f1,f2,..., in this order
@* - case 2: ring variables in v substituted by polynomials in f:
v[i] is substituted by f[i], i=1,...,i=min(size(v),ncols(f))

@item @strong{Note:}
this procedure extends the built-in command subst which substitutes
ring variables only by monomials

@end table
@strong{Example:}
@smallexample
@c computed example substitute d2t_singular/poly_lib.doc:683 
LIB "poly.lib";
ring r = 0,(b,c,t),dp;
ideal I = -bc+4b2c2t,bc2t-5b2c;
substitute(I,c,b+c,t,0,b,b-1);
@expansion{} _[1]=-b2-bc+2b+c-1
@expansion{} _[2]=-5b3-5b2c+15b2+10bc-15b-5c+5
ideal v = c,t,b;
ideal f = b+c,0,b-1;
substitute(I,v,f);
@expansion{} _[1]=-b2-bc+2b+c-1
@expansion{} _[2]=-5b3-5b2c+15b2+10bc-15b-5c+5
@c end example substitute d2t_singular/poly_lib.doc:683
@end smallexample
@c ---end content substitute---

@c ------------------- subrInterred -------------
@node subrInterred, hilbPoly, substitute, poly_lib
@subsubsection subrInterred
@cindex subrInterred
@c ---content subrInterred---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
subrInterred(mon,sm,iv);
@*sm: ideal in a ring r with n + s variables,
@*e.g. x_1,..,x_n and t_1,..,t_s
@*mon: ideal with monomial generators (not divisible by
any of the t_i) such that sm is contained in the module
k[t_1,..,t_s]*mon[1]+..+k[t_1,..,t_s]*mon[size(mon)]
@*iv: intvec listing the variables which are supposed to be used
as x_i

@item @strong{Return:}
list l:
@*l[1]=the monomials from mon in the order used
@*l[2]=their coefficients after interreduction
@*l[3]=l[1]*l[2]

@item @strong{Purpose:}
Do interred only w.r.t. a subset of variables.
@*The procedure returns an interreduced system of generators of
sm considered as a k[t_1,..,t_s]-submodule of the free module
k[t_1,..,t_s]*mon[1]+..+k[t_1,..,t_s]*mon[size(mon)]).

@end table
@strong{Example:}
@smallexample
@c computed example subrInterred d2t_singular/poly_lib.doc:728 
LIB "poly.lib";
ring r=0,(x,y,z),dp;
ideal i=x^2+x*y^2,x*y+x^2*y,z;
ideal j=x^2+x*y^2,x*y,z;
ideal mon=x^2,z,x*y;
intvec iv=1,3;
subrInterred(mon,i,iv);
@expansion{} [1]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=xy
@expansion{}    _[1,3]=x2
@expansion{} [2]:
@expansion{}    _[1]=gen(1)
@expansion{}    _[2]=y2*gen(2)-gen(2)
@expansion{}    _[3]=y*gen(2)+gen(3)
@expansion{} [3]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=xy3-xy
@expansion{}    _[1,3]=xy2+x2
subrInterred(mon,j,iv);
@expansion{} [1]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=xy
@expansion{}    _[1,3]=x2
@expansion{} [2]:
@expansion{}    _[1]=gen(1)
@expansion{}    _[2]=gen(2)
@expansion{}    _[3]=gen(3)
@expansion{} [3]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=xy
@expansion{}    _[1,3]=x2
@c end example subrInterred d2t_singular/poly_lib.doc:728
@end smallexample
@c ---end content subrInterred---

@c ------------------- hilbPoly -------------
@node hilbPoly,, subrInterred, poly_lib
@subsubsection hilbPoly
@cindex hilbPoly
@c ---content hilbPoly---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
hilbPoly(I) I a homogeneous ideal

@item @strong{Return:}
the Hilbert polynomial of basering/I as an intvec v=v_0,...,v_r
such that the Hilbert polynomial is (v_0+v_1*t+...v_r*t^r)/r!

@end table
@strong{Example:}
@smallexample
@c computed example hilbPoly d2t_singular/poly_lib.doc:759 
LIB "poly.lib";
ring r = 0,(b,c,t,h),dp;
ideal I=
bct-t2h+2th2+h3,
bt3-ct3-t4+b2th+c2th-2bt2h+2ct2h+2t3h-bch2-2bth2+2cth2+2th3,
b2c2+bt2h-ct2h-t3h+b2h2+2bch2+c2h2-2bth2+2cth2+t2h2-2bh3+2ch3+2th3+3h4,
c2t3+ct4-c3th-2c2t2h-2ct3h-t4h+bc2h2-2c2th2-bt2h2+4t3h2+2bth3-2cth3-t2h3
+bh4-6th4-2h5;
hilbPoly(I);
@expansion{} -11,10
@c end example hilbPoly d2t_singular/poly_lib.doc:759
@end smallexample
@c ---end content hilbPoly---
