@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/presolve_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/presolve_lib.doc INSTEAD
@c library version: (1.17.2.7,2003/06/12)
@c library file: ../Singular/LIB/presolve.lib
@cindex presolve.lib
@cindex presolve_lib
@table @asis
@item @strong{Library:}
presolve.lib
@item @strong{Purpose:}
     Pre-Solving of Polynomial Equations
@item @strong{Author:}
Gert-Martin Greuel, email: greuel@@mathematik.uni-kl.de,

@end table

@strong{Procedures:}
@menu
* degreepart:: elements of id of total degree >= d1 and <= d2
* elimlinearpart:: linear part eliminated from id
* elimpart:: partial elimination of vars [among first n vars]
* elimpartanyr:: factors of p partially eliminated from i in any ring
* fastelim:: fast elimination of factors of p from i [options]
* findvars:: ideal of variables occurring in id [more information]
* hilbvec:: intvec of Hilbert-series of id [in char c and ord o]
* linearpart:: elements of id of total degree <=1
* tolessvars:: maps id to new basering having only vars occurring in id
* solvelinearpart:: reduced std-basis of linear part of id
* sortandmap:: map to new basering with vars sorted w.r.t. complexity
* sortvars:: sort vars w.r.t. complexity in id [different blocks]
* shortid:: generators of id having <= n terms
* valvars:: valuation of vars w.r.t. to their complexity in id
* idealSimplify:: eliminates variables which are linear in id
* idealSplit:: intersection of the ideals has the same radical as id
@end menu
@c ---end content LibInfo---

@c ------------------- degreepart -------------
@node degreepart, elimlinearpart,, presolve_lib
@subsubsection degreepart
@cindex degreepart
@c ---content degreepart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
degreepart(id,d1,d2[,v]); id=ideal/module, d1,d1=integers, v=intvec

@item @strong{Return:}
generators of id of [v-weighted] total degree >= d1 and <= d2
(default: v = 1,...,1)

@end table
@strong{Example:}
@smallexample
@c reused example degreepart d2t_singular/presolve_lib.doc:55 
LIB "presolve.lib";
ring r=0,(x,y,z),dp;
ideal i=1+x+x2+x3+x4,3,xz+y3+z8;
degreepart(i,0,4);
@expansion{} _[1]=x4+x3+x2+x+1
@expansion{} _[2]=3
module m=[x,y,z],x*[x3,y2,z],[1,x2,z3,0,1];
intvec v=2,3,6;
show(degreepart(m,8,8,v));
@expansion{} // module, 1 generator(s)
@expansion{} [x4,xy2,xz]
@c end example degreepart d2t_singular/presolve_lib.doc:55
@end smallexample
@c ---end content degreepart---

@c ------------------- elimlinearpart -------------
@node elimlinearpart, elimpart, degreepart, presolve_lib
@subsubsection elimlinearpart
@cindex elimlinearpart
@c ---content elimlinearpart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
elimlinearpart(i[,n]); i=ideal, n=integer,@*
default: n=nvars(basering)

@item @strong{Return:}
list L with 5 entries:
  @format
  L[1]: (interreduced) ideal obtained from i by substituing
        from the first n variables those, which appear in a linear part
        of i, by putting this part into triangular form
  L[2]: ideal of variables which have been substituted
  L[3]: ideal, j-th element defines substitution of j-th var in [2]
  L[4]: ideal of variables of basering, eliminated ones are set to 0
  L[5]: ideal, describing the map from the basering to itself such that
        L[1] is the image of i
  @end format

@item @strong{Note:}
the procedure does always interreduce the ideal i internally w.r.t.
ordering dp.

@end table
@strong{Example:}
@smallexample
@c reused example elimlinearpart d2t_singular/presolve_lib.doc:99 
LIB "presolve.lib";
ring s=0,(x,y,z),dp;
ideal i = x3+y2+z,x2y2+z3,y+z+1;
elimlinearpart(i);
@expansion{} [1]:
@expansion{}    _[1]=x3+z2+3z+1
@expansion{}    _[2]=x2z2+2x2z+z3+x2
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{} [3]:
@expansion{}    _[1]=y+z+1
@expansion{} [4]:
@expansion{}    _[1]=x
@expansion{}    _[2]=0
@expansion{}    _[3]=z
@expansion{} [5]:
@expansion{}    _[1]=x
@expansion{}    _[2]=-z-1
@expansion{}    _[3]=z
@c end example elimlinearpart d2t_singular/presolve_lib.doc:99
@end smallexample
@c ---end content elimlinearpart---

@c ------------------- elimpart -------------
@node elimpart, elimpartanyr, elimlinearpart, presolve_lib
@subsubsection elimpart
@cindex elimpart
@c ---content elimpart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
elimpart(i [,n,e] ); i=ideal, n,e=integers
@*n : only the first n vars are considered for substitution,@*
e =0: substitute from linear part of i (same as elimlinearpart)@*
e!=0: eliminate also by direct substitution@*
(default: n = nvars(basering), e = 1)

@item @strong{Return:}
list of 5 objects:
  @format
  [1]: ideal obtained by substituting from the first n variables those
       from i, which appear in the linear part of i (or, if e!=0, which
       can be expressed directly in the remaining vars)
  [2]: ideal, variables which have been substituted
  [3]: ideal, i-th element defines substitution of i-th var in [2]
  [4]: ideal of variables of basering, substituted ones are set to 0
  [5]: ideal, describing the map from the basering, say k[x(1..m)], to
       itself onto k[..variables fom [4]..] and [1] is the image of i
  @end format
The ideal i is generated by [1] and [3] in k[x(1..m)], the map [5]
maps [3] to 0, hence induces an isomorphism
  @format
            k[x(1..m)]/i -> k[..variables fom [4]..]/[1]
  @end format

@item @strong{Note:}
If the basering has ordering (c,dp), this is faster for big ideals,
since it avoids internal ring change and mapping.

@end table
@strong{Example:}
@smallexample
@c reused example elimpart d2t_singular/presolve_lib.doc:148 
LIB "presolve.lib";
ring s=0,(x,y,z),dp;
ideal i =x2+y2,x2+y+1;
elimpart(i,3,0);
@expansion{} [1]:
@expansion{}    _[1]=y2-y-1
@expansion{}    _[2]=x2+y+1
@expansion{} [2]:
@expansion{}    _[1]=0
@expansion{} [3]:
@expansion{}    _[1]=0
@expansion{} [4]:
@expansion{}    _[1]=x
@expansion{}    _[2]=y
@expansion{}    _[3]=z
@expansion{} [5]:
@expansion{}    _[1]=x
@expansion{}    _[2]=y
@expansion{}    _[3]=z
elimpart(i,3,1);
@expansion{} [1]:
@expansion{}    _[1]=x4+3x2+1
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{} [3]:
@expansion{}    _[1]=x2+y+1
@expansion{} [4]:
@expansion{}    _[1]=x
@expansion{}    _[2]=0
@expansion{}    _[3]=z
@expansion{} [5]:
@expansion{}    _[1]=x
@expansion{}    _[2]=-x2-1
@expansion{}    _[3]=z
@c end example elimpart d2t_singular/presolve_lib.doc:148
@end smallexample
@c ---end content elimpart---

@c ------------------- elimpartanyr -------------
@node elimpartanyr, fastelim, elimpart, presolve_lib
@subsubsection elimpartanyr
@cindex elimpartanyr
@c ---content elimpartanyr---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
elimpartanyr(i [,p,e] ); i=ideal, p=polynomial, e=integer@*
p: product of vars to be eliminated,@*
e =0: substitute from linear part of i (same as elimlinearpart)@*
e!=0: eliminate also by direct substitution@*
(default: p=product of all vars, e=1)

@item @strong{Return:}
list of 6 objects:
  @format
  [1]: (interreduced) ideal obtained by substituting from i those vars
       appearing in p, which occur in the linear part of i (or which can
       be expressed directly in the remaining variables, if e!=0)
  [2]: ideal, variables which have been substituted
  [3]: ideal, i-th element defines substitution of i-th var in [2]
  [4]: ideal of variables of basering, substituted ones are set to 0
  [5]: ideal, describing the map from the basering, say k[x(1..m)], to
       itself onto k[..variables fom [4]..] and [1] is the image of i
  [6]: int, # of vars considered for substitution (= # of factors of p)
  @end format
The ideal i is generated by [1] and [3] in k[x(1..m)], the map [5]
maps [3] to 0, hence induces an isomorphism
  @format
            k[x(1..m)]/i -> k[..variables fom [4]..]/[1]
  @end format

@item @strong{Note:}
the proc uses @code{execute} to create a ring with ordering dp and vars
placed correctly and then applies @code{elimpart}.

@end table
@strong{Example:}
@smallexample
@c reused example elimpartanyr d2t_singular/presolve_lib.doc:199 
LIB "presolve.lib";
ring s=0,(x,y,z),dp;
ideal i = x3+y2+z,x2y2+z3,y+z+1;
elimpartanyr(i,z);
@expansion{} [1]:
@expansion{}    _[1]=x3+y2-y-1
@expansion{}    _[2]=x2y2-y3-3y2-3y-1
@expansion{} [2]:
@expansion{}    _[1]=z
@expansion{} [3]:
@expansion{}    _[1]=y+z+1
@expansion{} [4]:
@expansion{}    _[1]=0
@expansion{}    _[2]=x
@expansion{}    _[3]=y
@expansion{} [5]:
@expansion{}    _[1]=-y-1
@expansion{}    _[2]=x
@expansion{}    _[3]=y
@expansion{} [6]:
@expansion{}    1
@c end example elimpartanyr d2t_singular/presolve_lib.doc:199
@end smallexample
@c ---end content elimpartanyr---

@c ------------------- fastelim -------------
@node fastelim, findvars, elimpartanyr, presolve_lib
@subsubsection fastelim
@cindex fastelim
@c ---content fastelim---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
fastelim(i,p[h,o,a,b,e,m]); i=ideal, p=polynomial; h,o,a,b,e=integers
p: product of variables to be eliminated;@*
Optional parameters:
  @format
  - h !=0: use Hilbert-series driven std-basis computation
  - o !=0: use proc @code{valvars} for a - hopefully - optimal ordering of vars
  - a !=0: order vars to be eliminated w.r.t. increasing complexity
  - b !=0: order vars not to be eliminated w.r.t. increasing complexity
  - e !=0: use @code{elimpart} first to eliminate easy part
  - m !=0: compute a minimal system of generators
  @end format
(default: h,o,a,b,e,m = 0,1,0,0,0,0)

@item @strong{Return:}
ideal obtained from i by eliminating those variables, which occur in p

@end table
@strong{Example:}
@smallexample
@c reused example fastelim d2t_singular/presolve_lib.doc:236 
LIB "presolve.lib";
ring s=31991,(e,f,x,y,z,t,u,v,w,a,b,c,d),dp;
ideal i = w2+f2-1, x2+t2+a2-1,  y2+u2+b2-1, z2+v2+c2-1,
d2+e2-1, f4+2u, wa+tf, xy+tu+ab;
fastelim(i,xytua,1,1);       //with hilb,valvars
@expansion{} _[1]=f2+w2-1
@expansion{} _[2]=z2+v2+c2-1
@expansion{} _[3]=e2+d2-1
fastelim(i,xytua,1,0,1);     //with hilb,minbase
@expansion{} _[1]=z2+v2+c2-1
@expansion{} _[2]=f2+w2-1
@expansion{} _[3]=e2+d2-1
@c end example fastelim d2t_singular/presolve_lib.doc:236
@end smallexample
@c ---end content fastelim---

@c ------------------- findvars -------------
@node findvars, hilbvec, fastelim, presolve_lib
@subsubsection findvars
@cindex findvars
@c ---content findvars---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
findvars(id [,any] ); id=poly/ideal/vector/module/matrix, any=any type

@item @strong{Return:}
if no second argument is present: ideal of variables occurring in id,@*
if a second argument is given (of any type): list L with 4 entries:
  @format
  L[1]: ideal of variables occurring in id
  L[2]: intvec of variables occurring in id
  L[3]: ideal of variables not occurring in id
  L[4]: intvec of variables not occurring in id
  @end format

@end table
@strong{Example:}
@smallexample
@c reused example findvars d2t_singular/presolve_lib.doc:271 
LIB "presolve.lib";
ring s  = 0,(e,f,x,y,t,u,v,w,a,d),dp;
ideal i = w2+f2-1, x2+t2+a2-1;
findvars(i);
@expansion{} _[1]=f
@expansion{} _[2]=x
@expansion{} _[3]=t
@expansion{} _[4]=w
@expansion{} _[5]=a
findvars(i,1);
@expansion{} [1]:
@expansion{}    _[1]=f
@expansion{}    _[2]=x
@expansion{}    _[3]=t
@expansion{}    _[4]=w
@expansion{}    _[5]=a
@expansion{} [2]:
@expansion{}    2,3,5,8,9
@expansion{} [3]:
@expansion{}    _[1]=e
@expansion{}    _[2]=y
@expansion{}    _[3]=u
@expansion{}    _[4]=v
@expansion{}    _[5]=d
@expansion{} [4]:
@expansion{}    1,4,6,7,10
@c end example findvars d2t_singular/presolve_lib.doc:271
@end smallexample
@c ---end content findvars---

@c ------------------- hilbvec -------------
@node hilbvec, linearpart, findvars, presolve_lib
@subsubsection hilbvec
@cindex hilbvec
@c ---content hilbvec---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
hilbvec(id[,c,o]); id=poly/ideal/vector/module/matrix, c,o=strings,@*
c=char, o=ordering used by @code{hilb}@*
(default: c="32003", o="dp")

@item @strong{Return:}
intvec of 1-st Hilbert-series of id, computed in char c and ordering o

@item @strong{Note:}
id must be homogeneous (i.e. all vars have weight 1)

@end table
@strong{Example:}
@smallexample
@c reused example hilbvec d2t_singular/presolve_lib.doc:303 
LIB "presolve.lib";
ring s   = 0,(e,f,x,y,z,t,u,v,w,a,b,c,d,H),dp;
ideal id = w2+f2-1, x2+t2+a2-1,  y2+u2+b2-1, z2+v2+c2-1,
d2+e2-1, f4+2u, wa+tf, xy+tu+ab;
id = homog(id,H);
hilbvec(id);
@expansion{} 1,0,-7,0,20,0,-28,0,14,0,14,0,-28,0,20,0,-7,0,1,0
@c end example hilbvec d2t_singular/presolve_lib.doc:303
@end smallexample
@c ---end content hilbvec---

@c ------------------- linearpart -------------
@node linearpart, tolessvars, hilbvec, presolve_lib
@subsubsection linearpart
@cindex linearpart
@c ---content linearpart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
linearpart(id); id=ideal/module

@item @strong{Return:}
generators of id of total degree <= 1

@end table
@strong{Example:}
@smallexample
@c reused example linearpart d2t_singular/presolve_lib.doc:331 
LIB "presolve.lib";
ring r=0,(x,y,z),dp;
ideal i=1+x+x2+x3,3,x+3y+5z;
linearpart(i);
@expansion{} _[1]=3
@expansion{} _[2]=x+3y+5z
module m=[x,y,z],x*[x3,y2,z],[1,x2,z3,0,1];
show(linearpart(m));
@expansion{} // module, 1 generator(s)
@expansion{} [x,y,z]
@c end example linearpart d2t_singular/presolve_lib.doc:331
@end smallexample
@c ---end content linearpart---

@c ------------------- tolessvars -------------
@node tolessvars, solvelinearpart, linearpart, presolve_lib
@subsubsection tolessvars
@cindex tolessvars
@c ---content tolessvars---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
tolessvars(id [,s1,s2] ); id poly/ideal/vector/module/matrix,
s1,s2=strings@*
s1: name of new ring,@*
s2: new ordering@*
(default: s1="R(n)" where n is the # of vars in the new ring,
s2="dp" or "ds" depending whether the first block of the old
ordering is a p- resp. an s-ordering)

@item @strong{Create:}
nothing, if id contains all vars of the basering.@*
Else, create a ring with same char as the basering, but possibly less
variables (only those variables which actually occur in id) and map
id to the new ring, which will be the basering after the proc has
finished.

@item @strong{Display:}
If printlevel >=0, display ideal of vars, which have been omitted from
the old ring

@item @strong{Return:}
the original ideal id (see NOTE)

@item @strong{Note:}
You must not type, say, 'ideal id=tolessvars(id);' since the ring
to which 'id' would belong will only be defined by the r.h.s.. But you
may type 'def id=tolessvars(id);' or 'list id=tolessvars(id);'
since then 'id' does not a priory belong to a ring, its type will
be defined by the right hand side. Moreover, do not use a name which
occurs in the old ring, for the same reason.

@end table
@strong{Example:}
@smallexample
@c reused example tolessvars d2t_singular/presolve_lib.doc:384 
LIB "presolve.lib";
ring r  = 0,(x,y,z),dp;
ideal i = y2-x3,x-3,y-2x;
def j   = tolessvars(i,"R_r","lp");
@expansion{} 
@expansion{} // variables which did not occur:
@expansion{} z
@expansion{} // basering is now R_r
show(basering);
@expansion{} // ring: (0),(x,y),(lp(2),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // j                    [0]  ideal, 3 generator(s)
j;
@expansion{} j[1]=-x3+y2
@expansion{} j[2]=x-3
@expansion{} j[3]=-2x+y
kill R_r;
@c end example tolessvars d2t_singular/presolve_lib.doc:384
@end smallexample
@c ---end content tolessvars---

@c ------------------- solvelinearpart -------------
@node solvelinearpart, sortandmap, tolessvars, presolve_lib
@subsubsection solvelinearpart
@cindex solvelinearpart
@c ---content solvelinearpart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
solvelinearpart(id [,n] ); id=ideal/module, n=integer,@*
(default: n=0)

@item @strong{Return:}
(interreduced) generators of id of degree <=1 in reduced triangular
form if n=0 [non-reduced triangular form if n!=0]

@item @strong{Assume:}
monomial ordering is a global ordering (p-ordering)

@item @strong{Note:}
may be used to solve a system of linear equations
see proc @code{gauss_row} from 'matrix.lib' for a different method

@item @strong{Warning:}
the result is very likely to be false for 'real' coefficients, use
char 0 instead!

@end table
@strong{Example:}
@smallexample
@c reused example solvelinearpart d2t_singular/presolve_lib.doc:426 
LIB "presolve.lib";
// Solve the system of linear equations:
//         3x +   y +  z -  u = 2
//         3x +  8y + 6z - 7u = 1
//        14x + 10y + 6z - 7u = 0
//         7x +  4y + 3z - 3u = 3
ring r = 0,(x,y,z,u),lp;
ideal i= 3x +   y +  z -  u,
13x +  8y + 6z - 7u,
14x + 10y + 6z - 7u,
7x +  4y + 3z - 3u;
ideal j= 2,1,0,3;
j = i-j;                        // difference of 1x4 matrices
// compute reduced triangular form, setting
solvelinearpart(j);             // the RHS equal 0 gives the solutions!
@expansion{} _[1]=u-4
@expansion{} _[2]=z-4
@expansion{} _[3]=y+1
@expansion{} _[4]=x-1
solvelinearpart(j,1); "";       // triangular form, not reduced
@expansion{} _[1]=u-4
@expansion{} _[2]=3z-8u+20
@expansion{} _[3]=18y-6z+7u+14
@expansion{} _[4]=13x+8y+6z-7u-1
@expansion{} 
@c end example solvelinearpart d2t_singular/presolve_lib.doc:426
@end smallexample
@c ---end content solvelinearpart---

@c ------------------- sortandmap -------------
@node sortandmap, sortvars, solvelinearpart, presolve_lib
@subsubsection sortandmap
@cindex sortandmap
@c ---content sortandmap---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
sortandmap(id,s1,s2[,n1,p1,n2,p2...,o1,m1,o2,m2...]);@*
id=poly/ideal/vector/module,@*
s1,s2 = strings (names for new ring and mapped id),@*
p1,p2,...= polynomials (product of variables),@*
n1,n2,...= integers,@*
o1,o2,...= strings,@*
m1,m2,...= integers@*
(default: p1=product of all vars, n1=0, o1="dp",m1=0)
@*the last pi (containing the remaining vars) may be omitted

@item @strong{Create:}
a new ring and map id into it, the new ring has same char as basering
but with new ordering and vars sorted in the following manner:
  @format
  - each block of vars occurring in pi is sorted w.r.t. its complexity in id,
  - ni controls the sorting in i-th block (= vars occurring in pi):
    ni=0 (resp.!=0) means that less (resp. more) complex vars come first
  - oi and mi define the monomial ordering of the i-th block:
    if mi =0, oi=ordstr(i-th block)
    if mi!=0, the ordering of the i-th block itself is a blockordering,
      each subblock having ordstr=oi, such that vars of same complexity are
      in one block
  @end format
Note that only simple ordstrings oi are allowed:
@*"lp","dp","Dp","ls","ds","Ds".

@item @strong{Return:}
nothing

@item @strong{Note:}
We define a variable x to be more complex than y (with respect to id)
if val(x) > val(y) lexicographically, where val(x) denotes the
valuation vector of x:@*
consider id as list of polynomials in x with coefficients in the
remaining variables. Then:@*
val(x) = (maximal occurring power of x, # of all monomials in leading
coefficient, # of all monomials in coefficient of next smaller power
of x,...).

@end table
@strong{Example:}
@smallexample
@c reused example sortandmap d2t_singular/presolve_lib.doc:498 
LIB "presolve.lib";
ring s = 32003,(x,y,z),dp;
ideal i=x3+y2,xz+z2;
sortandmap(i,"R_r","i");
// i is now an ideal in the new basering R_r
show(R_r);
@expansion{} // ring: (32003),(y,z,x),(dp(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // i                    [0]  ideal, 2 generator(s)
kill R_r; setring s;
sortandmap(i,"R_r","i",1,xy,0,z,0,"ds",0,"lp",0);
show(R_r);
@expansion{} // ring: (32003),(x,y,z),(ds(2),lp(1),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // i                    [0]  ideal, 2 generator(s)
kill R_r;
@c end example sortandmap d2t_singular/presolve_lib.doc:498
@end smallexample
@c ---end content sortandmap---

@c ------------------- sortvars -------------
@node sortvars, shortid, sortandmap, presolve_lib
@subsubsection sortvars
@cindex sortvars
@c ---content sortvars---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
sortvars(id[,n1,p1,n2,p2,...]);@*
id=poly/ideal/vector/module,@*
p1,p2,...= polynomials (product of vars),@*
n1,n2,...=integers@*
(default: p1=product of all vars, n1=0)
@*the last pi (containing the remaining vars) may be omitted

@item @strong{Compute:}
sort variables with respect to their complexity in id

@item @strong{Return:}
list of two elements, an ideal and a list:
  @format
  [1]: ideal, variables of basering sorted w.r.t their complexity in id
       ni controls the ordering in i-th block (= vars occurring in pi):
       ni=0 (resp.!=0) means that less (resp. more) complex vars come first
  [2]: a list with 4 entries for each pi:
       ideal ai : vars of pi in correct order,
       intvec vi: permutation vector describing the ordering in ai,
       intmat Mi: valuation matrix of ai, the columns of Mi being the
                  valuation vectors of the vars in ai
       intvec wi: size of 1-st, 2-nd,... block of identical columns of Mi
                  (vars with same valuation)
  @end format

@item @strong{Note:}
We define a variable x to be more complex than y (with respect to id)
if val(x) > val(y) lexicographically, where val(x) denotes the
valuation vector of x:@*
consider id as list of polynomials in x with coefficients in the
remaining variables. Then:@*
val(x) = (maximal occurring power of x, # of all monomials in leading
coefficient, # of all monomials in coefficient of next smaller power
of x,...).

@end table
@strong{Example:}
@smallexample
@c reused example sortvars d2t_singular/presolve_lib.doc:560 
LIB "presolve.lib";
ring s=0,(x,y,z,w),dp;
ideal i = x3+y2+yw2,xz+z2,xyz-w2;
sortvars(i,0,xy,1,zw);
@expansion{} [1]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x
@expansion{}    _[3]=w
@expansion{}    _[4]=z
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=y
@expansion{}       _[2]=x
@expansion{}    [2]:
@expansion{}       2,1
@expansion{}    [3]:
@expansion{}       2,3,
@expansion{}       1,1,
@expansion{}       2,0,
@expansion{}       0,2 
@expansion{}    [4]:
@expansion{}       1,1
@expansion{}    [5]:
@expansion{}       _[1]=w
@expansion{}       _[2]=z
@expansion{}    [6]:
@expansion{}       2,1
@expansion{}    [7]:
@expansion{}       2,2,
@expansion{}       2,1,
@expansion{}       0,2 
@expansion{}    [8]:
@expansion{}       1,1
@c end example sortvars d2t_singular/presolve_lib.doc:560
@end smallexample
@c ---end content sortvars---

@c ------------------- shortid -------------
@node shortid, valvars, sortvars, presolve_lib
@subsubsection shortid
@cindex shortid
@c ---content shortid---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
shortid(id,n[,e]); id= ideal/module, n,e=integers

@item @strong{Return:}
- if called with two arguments or e=0:
@* same type as id, containing generators of id having <= n terms.
@* - if called with three arguments and e!=0:
@* a list L:
@* L[1]: same type as id, containing generators of id having <= n terms.
@* L[2]: number of corresponding generator of id

@item @strong{Note:}
May be used to compute partial standard basis in case id is to hard

@end table
@strong{Example:}
@smallexample
@c reused example shortid d2t_singular/presolve_lib.doc:594 
LIB "presolve.lib";
ring s=0,(x,y,z,w),dp;
ideal i = (x3+y2+yw2)^2,(xz+z2)^2,xyz-w2-xzw; 
shortid(i,3);
@expansion{} _[1]=x2z2+2xz3+z4
@expansion{} _[2]=xyz-xzw-w2
@c end example shortid d2t_singular/presolve_lib.doc:594
@end smallexample
@c ---end content shortid---

@c ------------------- valvars -------------
@node valvars, idealSimplify, shortid, presolve_lib
@subsubsection valvars
@cindex valvars
@c ---content valvars---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
valvars(id[,n1,p1,n2,p2,...]);@*
id=poly/ideal/vector/module,@*
p1,p2,...= polynomials (product of vars),@*
n1,n2,...= integers,

ni controls the ordering of vars occurring in pi: ni=0 (resp.!=0) means
that less (resp. more) complex vars come first@*
(default: p1=product of all vars, n1=0)
@*the last pi (containing the remaining vars) may be omitted

@item @strong{Compute:}
valuation (complexity) of variables with respect to id.@*
ni controls the ordering of vars occurring in pi:@*
ni=0 (resp.!=0) means that less (resp. more) complex vars come first.

@item @strong{Return:}
list with 3 entries:
  @format
  [1]: intvec, say v, describing the permutation such that the permuted
       ringvariables are ordered with respect to their complexity in id
  [2]: list of intvecs, i-th intvec, say v(i) describing permutation
       of vars in a(i) such that v=v(1),v(2),...
  [3]: list of ideals and intmat's, say a(i) and M(i), where
       a(i): factors of pi,
       M(i): valuation matrix of a(i), such that the j-th column of M(i)
             is the valuation vector of j-th generator of a(i)
         @end format

@item @strong{Note:}
Use @code{sortvars} in order to actually sort the variables!
We define a variable x to be more complex than y (with respect to id)
if val(x) > val(y) lexicographically, where val(x) denotes the
valuation vector of x:@*
consider id as list of polynomials in x with coefficients in the
remaining variables. Then:@*
val(x) = (maximal occurring power of x, # of all monomials in leading
coefficient, # of all monomials in coefficient of next smaller power
of x,...).

@end table
@strong{Example:}
@smallexample
@c reused example valvars d2t_singular/presolve_lib.doc:654 
LIB "presolve.lib";
ring s=0,(x,y,z,a,b),dp;
ideal i=ax2+ay3-b2x,abz+by2;
valvars (i,0,xyz);
@expansion{} [1]:
@expansion{}    3,1,2,4,5
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       3,1,2
@expansion{}    [2]:
@expansion{}       1,2
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=x
@expansion{}       _[2]=y
@expansion{}       _[3]=z
@expansion{}    [2]:
@expansion{}       2,3,1,
@expansion{}       1,1,1,
@expansion{}       1,1,0 
@expansion{}    [3]:
@expansion{}       _[1]=a
@expansion{}       _[2]=b
@expansion{}    [4]:
@expansion{}       1,2,
@expansion{}       3,1,
@expansion{}       0,2 
@c end example valvars d2t_singular/presolve_lib.doc:654
@end smallexample
@c ---end content valvars---

@c ------------------- idealSimplify -------------
@node idealSimplify, idealSplit, valvars, presolve_lib
@subsubsection idealSimplify
@cindex idealSimplify
@c ---content idealSimplify---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
idealSimplify(id); id ideal

@item @strong{Return:}
ideal I = eliminate(Id,m) m is a product of variables
which are only linearly involved in the generators of id

@end table
@strong{Example:}
@smallexample
@c reused example idealSimplify d2t_singular/presolve_lib.doc:681 
LIB "presolve.lib";
ring r=0,(x,y,z,w,t),dp;
ideal i=
t,
x3+y2+2z,
x2+3y,
x2+y2+z2,
w2+z;
ideal j=idealSimplify(i);
ideal k=eliminate(i,zyt);
reduce(k,std(j));
@expansion{} _[1]=0
@expansion{} _[2]=0
reduce(j,std(k));
@expansion{} _[1]=0
@expansion{} _[2]=0
@c end example idealSimplify d2t_singular/presolve_lib.doc:681
@end smallexample
@c ---end content idealSimplify---

@c ------------------- idealSplit -------------
@node idealSplit,, idealSimplify, presolve_lib
@subsubsection idealSplit
@cindex idealSplit
@c ---content idealSplit---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
idealSplit(id,timeF,timeS); id ideal and optional
@*timeF ,timeS integers to bound the time which can be used
for factorization resp. standard basis computation

@item @strong{Return:}
a list of ideals such that their intersection
@*has the same radical as id

@end table
@strong{Example:}
@smallexample
@c reused example idealSplit d2t_singular/presolve_lib.doc:718 
LIB "presolve.lib";
ring r=32003,(b,s,t,u,v,w,x,y,z),dp;
ideal i=
bv+su,
bw+tu,
sw+tv,
by+sx,
bz+tx,
sz+ty,
uy+vx,
uz+wx,
vz+wy,
bvz;
idealSplit(i);
@expansion{} [1]:
@expansion{}    _[1]=x
@expansion{}    _[2]=u
@expansion{}    _[3]=t
@expansion{}    _[4]=s
@expansion{}    _[5]=b
@expansion{}    _[6]=wy+vz
@expansion{} [2]:
@expansion{}    _[1]=z
@expansion{}    _[2]=w
@expansion{}    _[3]=t
@expansion{}    _[4]=s
@expansion{}    _[5]=b
@expansion{}    _[6]=vx+uy
@expansion{} [3]:
@expansion{}    _[1]=z
@expansion{}    _[2]=x
@expansion{}    _[3]=w
@expansion{}    _[4]=u
@expansion{}    _[5]=t
@expansion{}    _[6]=b
@expansion{} [4]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=t
@expansion{}    _[5]=s
@expansion{}    _[6]=b
@expansion{} [5]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=u
@expansion{}    _[5]=b
@expansion{}    _[6]=tv+sw
@expansion{} [6]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=w
@expansion{}    _[5]=t
@expansion{}    _[6]=su+bv
@expansion{} [7]:
@expansion{}    _[1]=w
@expansion{}    _[2]=v
@expansion{}    _[3]=u
@expansion{}    _[4]=t
@expansion{}    _[5]=s
@expansion{}    _[6]=b
@expansion{} [8]:
@expansion{}    _[1]=x
@expansion{}    _[2]=w
@expansion{}    _[3]=v
@expansion{}    _[4]=u
@expansion{}    _[5]=b
@expansion{}    _[6]=ty+sz
@expansion{} [9]:
@expansion{}    _[1]=z
@expansion{}    _[2]=w
@expansion{}    _[3]=v
@expansion{}    _[4]=u
@expansion{}    _[5]=t
@expansion{}    _[6]=sx+by
@expansion{} [10]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=w
@expansion{}    _[5]=v
@expansion{}    _[6]=u
@expansion{} [11]:
@expansion{}    _[1]=y
@expansion{}    _[2]=v
@expansion{}    _[3]=t
@expansion{}    _[4]=s
@expansion{}    _[5]=b
@expansion{}    _[6]=wx+uz
@expansion{} [12]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x
@expansion{}    _[3]=v
@expansion{}    _[4]=u
@expansion{}    _[5]=s
@expansion{}    _[6]=b
@expansion{} [13]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=v
@expansion{}    _[5]=s
@expansion{}    _[6]=tu+bw
@expansion{} [14]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=w
@expansion{}    _[4]=v
@expansion{}    _[5]=t
@expansion{}    _[6]=s
@expansion{} [15]:
@expansion{}    _[1]=y
@expansion{}    _[2]=w
@expansion{}    _[3]=v
@expansion{}    _[4]=u
@expansion{}    _[5]=s
@expansion{}    _[6]=tx+bz
@c end example idealSplit d2t_singular/presolve_lib.doc:718
@end smallexample
@c ---end content idealSplit---
