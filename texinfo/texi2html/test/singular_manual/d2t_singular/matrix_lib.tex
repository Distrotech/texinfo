@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/matrix_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/matrix_lib.doc INSTEAD
@c library version: (1.26.2.3,2003/05/14)
@c library file: ../Singular/LIB/matrix.lib
@cindex matrix.lib
@cindex matrix_lib
@table @asis
@item @strong{Library:}
matrix.lib
@item @strong{Purpose:}
    Elementary Matrix Operations

@end table

@strong{Procedures:}
@menu
* compress:: matrix, zero columns from A deleted
* concat:: matrix, concatenation of matrices A1,A2,...
* diag:: matrix, nxn diagonal matrix with entries poly p
* dsum:: matrix, direct sum of matrices A1,A2,...
* flatten:: ideal, generated by entries of matrix A
* genericmat:: generic nxm matrix [entries from id]
* is_complex:: 1 if list c is a complex, 0 if not
* outer:: matrix, outer product of matrices A and B
* power:: matrix/intmat, n-th power of matrix/intmat A
* skewmat:: generic skew-symmetric nxn matrix [entries from id]
* submat:: submatrix of A with rows/cols specified by intvec r/c
* symmat:: generic symmetric nxn matrix [entries from id]
* tensor:: matrix, tensor product of matrices A nd B
* unitmat:: unit square matrix of size n
* gauss_col:: transform a matrix into col-reduced Gauss normal form
* gauss_row:: transform a matrix into row-reduced Gauss normal form
* addcol:: add p*(c1-th col) to c2-th column of matrix A, p poly
* addrow:: add p*(r1-th row) to r2-th row of matrix A, p poly
* multcol:: multiply c-th column of A with poly p
* multrow:: multiply r-th row of A with poly p
* permcol:: permute i-th and j-th columns
* permrow:: permute i-th and j-th rows
* rowred:: reduction of matrix A with elementary row-operations
* colred:: reduction of matrix A with elementary col-operations
* rm_unitrow:: remove unit rows and associated columns of A
* rm_unitcol:: remove unit columns and associated rows of A
* headStand:: A[n-i+1,m-j+1]=headStand(A[i,j])
@end menu
@c ---end content LibInfo---

@c ------------------- compress -------------
@node compress, concat,, matrix_lib
@subsubsection compress
@cindex compress
@c ---content compress---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
compress(A); A matrix/ideal/module/intmat/intvec

@item @strong{Return:}
same type, zero columns/generators from A deleted
@*(if A=intvec, zero elements are deleted)

@end table
@strong{Example:}
@smallexample
@c reused example compress d2t_singular/matrix_lib.doc:64 
LIB "matrix.lib";
ring r=0,(x,y,z),ds;
matrix A[3][4]=1,0,3,0,x,0,z,0,x2,0,z2,0;
print(A);
@expansion{} 1, 0,3, 0,
@expansion{} x, 0,z, 0,
@expansion{} x2,0,z2,0 
print(compress(A));
@expansion{} 1, 3,
@expansion{} x, z,
@expansion{} x2,z2
module m=module(A); show(m);
@expansion{} // module, 4 generator(s)
@expansion{} [1,x,x2]
@expansion{} [0]
@expansion{} [3,z,z2]
@expansion{} [0]
show(compress(m));
@expansion{} // module, 2 generator(s)
@expansion{} [1,x,x2]
@expansion{} [3,z,z2]
intmat B[3][4]=1,0,3,0,4,0,5,0,6,0,7,0;
compress(B);
@expansion{} 1,3,
@expansion{} 4,5,
@expansion{} 6,7 
intvec C=0,0,1,2,0,3;
compress(C);
@expansion{} 1,2,3
@c end example compress d2t_singular/matrix_lib.doc:64
@end smallexample
@c ---end content compress---

@c ------------------- concat -------------
@node concat, diag, compress, matrix_lib
@subsubsection concat
@cindex concat
@c ---content concat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
concat(A1,A2,..); A1,A2,... matrices

@item @strong{Return:}
matrix, concatenation of A1,A2,.... Number of rows of result matrix
is max(nrows(A1),nrows(A2),...)

@end table
@strong{Example:}
@smallexample
@c reused example concat d2t_singular/matrix_lib.doc:98 
LIB "matrix.lib";
ring r=0,(x,y,z),ds;
matrix A[3][3]=1,2,3,x,y,z,x2,y2,z2;
matrix B[2][2]=1,0,2,0; matrix C[1][4]=4,5,x,y;
print(A);
@expansion{} 1, 2, 3,
@expansion{} x, y, z,
@expansion{} x2,y2,z2
print(B);
@expansion{} 1,0,
@expansion{} 2,0 
print(C);
@expansion{} 4,5,x,y
print(concat(A,B,C));
@expansion{} 1, 2, 3, 1,0,4,5,x,y,
@expansion{} x, y, z, 2,0,0,0,0,0,
@expansion{} x2,y2,z2,0,0,0,0,0,0 
@c end example concat d2t_singular/matrix_lib.doc:98
@end smallexample
@c ---end content concat---

@c ------------------- diag -------------
@node diag, dsum, concat, matrix_lib
@subsubsection diag
@cindex diag
@c ---content diag---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
diag(p,n); p poly, n integer
@*diag(A); A matrix

@item @strong{Return:}
diag(p,n): diagonal matrix, p times unit matrix of size n.
@* diag(A) : n*m x n*m diagonal matrix with entries all the entries of
the nxm matrix A, taken from the 1st row, 2nd row etc of A

@end table
@strong{Example:}
@smallexample
@c reused example diag d2t_singular/matrix_lib.doc:131 
LIB "matrix.lib";
ring r = 0,(x,y,z),ds;
print(diag(xy,4));
@expansion{} xy,0, 0, 0,
@expansion{} 0, xy,0, 0,
@expansion{} 0, 0, xy,0,
@expansion{} 0, 0, 0, xy
matrix A[3][2] = 1,2,3,4,5,6;
print(A);
@expansion{} 1,2,
@expansion{} 3,4,
@expansion{} 5,6 
print(diag(A));
@expansion{} 1,0,0,0,0,0,
@expansion{} 0,2,0,0,0,0,
@expansion{} 0,0,3,0,0,0,
@expansion{} 0,0,0,4,0,0,
@expansion{} 0,0,0,0,5,0,
@expansion{} 0,0,0,0,0,6 
@c end example diag d2t_singular/matrix_lib.doc:131
@end smallexample
@c ---end content diag---

@c ------------------- dsum -------------
@node dsum, flatten, diag, matrix_lib
@subsubsection dsum
@cindex dsum
@c ---content dsum---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
dsum(A1,A2,..); A1,A2,... matrices

@item @strong{Return:}
matrix, direct sum of A1,A2,...

@end table
@strong{Example:}
@smallexample
@c reused example dsum d2t_singular/matrix_lib.doc:159 
LIB "matrix.lib";
ring r = 0,(x,y,z),ds;
matrix A[3][3] = 1,2,3,4,5,6,7,8,9;
matrix B[2][2] = 1,x,y,z;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(B);
@expansion{} 1,x,
@expansion{} y,z 
print(dsum(A,B));
@expansion{} 1,2,3,0,0,
@expansion{} 4,5,6,0,0,
@expansion{} 7,8,9,0,0,
@expansion{} 0,0,0,1,x,
@expansion{} 0,0,0,y,z 
@c end example dsum d2t_singular/matrix_lib.doc:159
@end smallexample
@c ---end content dsum---

@c ------------------- flatten -------------
@node flatten, genericmat, dsum, matrix_lib
@subsubsection flatten
@cindex flatten
@c ---content flatten---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
flatten(A); A matrix

@item @strong{Return:}
ideal, generated by all entries from A

@end table
@strong{Example:}
@smallexample
@c reused example flatten d2t_singular/matrix_lib.doc:188 
LIB "matrix.lib";
ring r = 0,(x,y,z),ds;
matrix A[2][3] = 1,2,x,y,z,7;
print(A);
@expansion{} 1,2,x,
@expansion{} y,z,7 
flatten(A);
@expansion{} _[1]=1
@expansion{} _[2]=2
@expansion{} _[3]=x
@expansion{} _[4]=y
@expansion{} _[5]=z
@expansion{} _[6]=7
@c end example flatten d2t_singular/matrix_lib.doc:188
@end smallexample
@c ---end content flatten---

@c ------------------- genericmat -------------
@node genericmat, is_complex, flatten, matrix_lib
@subsubsection genericmat
@cindex genericmat
@c ---content genericmat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
genericmat(n,m[,id]); n,m=integers, id=ideal

@item @strong{Return:}
nxm matrix, with entries from id.

@item @strong{Note:}
if id has less than nxm elements, the matrix is filled with 0's,
(default: id=maxideal(1)).
@*genericmat(n,m); creates the generic nxm matrix

@end table
@strong{Example:}
@smallexample
@c reused example genericmat d2t_singular/matrix_lib.doc:220 
LIB "matrix.lib";
ring R = 0,x(1..16),lp;
print(genericmat(3,3));      // the generic 3x3 matrix
@expansion{} x(1),x(2),x(3),
@expansion{} x(4),x(5),x(6),
@expansion{} x(7),x(8),x(9) 
ring R1 = 0,(a,b,c,d),dp;
matrix A = genericmat(3,4,maxideal(1)^3);
print(A);
@expansion{} a3, a2b,a2c,a2d,
@expansion{} ab2,abc,abd,ac2,
@expansion{} acd,ad2,b3, b2c 
int n,m = 3,2;
ideal i = ideal(randommat(1,n*m,maxideal(1),9));
print(genericmat(n,m,i));    // matrix of generic linear forms
@expansion{} 4a-8b-2c-3d,-a+b-4c+5d,
@expansion{} -8a-9b+c+7d,a-9b+9c+4d,
@expansion{} 6a-5b+9c,   2a+8c+d    
@c end example genericmat d2t_singular/matrix_lib.doc:220
@end smallexample
@c ---end content genericmat---

@c ------------------- is_complex -------------
@node is_complex, outer, genericmat, matrix_lib
@subsubsection is_complex
@cindex is_complex
@c ---content is_complex---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
is_complex(c); c = list of size-compatible modules or matrices

@item @strong{Return:}
1 if c[i]*c[i+1]=0 for all i, 0 if not, hence checking whether the
list of matrices forms a complex.

@item @strong{Note:}
Ideals are treated internally as 1-line matrices.
@*If printlevel > 0, the position where c is not a complex is shown.

@end table
@strong{Example:}
@smallexample
@c reused example is_complex d2t_singular/matrix_lib.doc:256 
LIB "matrix.lib";
ring r  = 32003,(x,y,z),ds;
ideal i = x4+y5+z6,xyz,yx2+xz2+zy7;
list L  = nres(i,0);
is_complex(L);
@expansion{} 1
L[4]    = matrix(i);
is_complex(L);
@expansion{} 0
@c end example is_complex d2t_singular/matrix_lib.doc:256
@end smallexample
@c ---end content is_complex---

@c ------------------- outer -------------
@node outer, power, is_complex, matrix_lib
@subsubsection outer
@cindex outer
@c ---content outer---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
outer(A,B); A,B matrices

@item @strong{Return:}
matrix, outer (tensor) product of A and B

@end table
@strong{Example:}
@smallexample
@c reused example outer d2t_singular/matrix_lib.doc:285 
LIB "matrix.lib";
ring r=32003,(x,y,z),ds;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix B[2][2]=x,y,0,z;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(B);
@expansion{} x,y,
@expansion{} 0,z 
print(outer(A,B));
@expansion{} x, y, 2x,2y,3x,3y,
@expansion{} 0, z, 0, 2z,0, 3z,
@expansion{} 4x,4y,5x,5y,6x,6y,
@expansion{} 0, 4z,0, 5z,0, 6z,
@expansion{} 7x,7y,8x,8y,9x,9y,
@expansion{} 0, 7z,0, 8z,0, 9z 
@c end example outer d2t_singular/matrix_lib.doc:285
@end smallexample
@c ---end content outer---

@c ------------------- power -------------
@node power, skewmat, outer, matrix_lib
@subsubsection power
@cindex power
@c ---content power---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
power(A,n); A a square-matrix of type intmat or matrix, n=integer

@item @strong{Return:}
intmat resp. matrix, the n-th power of A

@item @strong{Note:}
for A=intmat and big n the result may be wrong because of int overflow

@end table
@strong{Example:}
@smallexample
@c reused example power d2t_singular/matrix_lib.doc:317 
LIB "matrix.lib";
intmat A[3][3]=1,2,3,4,5,6,7,8,9;
print(power(A,3));"";
@expansion{}    468   576   684
@expansion{}   1062  1305  1548
@expansion{}   1656  2034  2412
@expansion{} 
ring r=0,(x,y,z),dp;
matrix B[3][3]=0,x,y,z,0,0,y,z,0;
print(power(B,3));"";
@expansion{} yz2,    xy2+x2z,y3+xyz,
@expansion{} y2z+xz2,yz2,    0,     
@expansion{} y3+xyz, y2z+xz2,yz2    
@expansion{} 
@c end example power d2t_singular/matrix_lib.doc:317
@end smallexample
@c ---end content power---

@c ------------------- skewmat -------------
@node skewmat, submat, power, matrix_lib
@subsubsection skewmat
@cindex skewmat
@c ---content skewmat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
skewmat(n[,id]); n integer, id ideal

@item @strong{Return:}
skew-symmetric nxn matrix, with entries from id
@*(default: id=maxideal(1))
@*skewmat(n); creates the generic skew-symmetric matrix

@item @strong{Note:}
if id has less than n*(n-1)/2 elements, the matrix is
@*filled with 0's,

@end table
@strong{Example:}
@smallexample
@c reused example skewmat d2t_singular/matrix_lib.doc:351 
LIB "matrix.lib";
ring R=0,x(1..5),lp;
print(skewmat(4));    // the generic skew-symmetric matrix
@expansion{} 0,    x(1), x(2),x(3),
@expansion{} -x(1),0,    x(4),x(5),
@expansion{} -x(2),-x(4),0,   0,   
@expansion{} -x(3),-x(5),0,   0    
ring R1 = 0,(a,b,c),dp;
matrix A=skewmat(4,maxideal(1)^2);
print(A);
@expansion{} 0,  a2, ab, ac,
@expansion{} -a2,0,  b2, bc,
@expansion{} -ab,-b2,0,  c2,
@expansion{} -ac,-bc,-c2,0  
int n=3;
ideal i = ideal(randommat(1,n*(n-1) div 2,maxideal(1),9));
print(skewmat(n,i));  // skew matrix of generic linear forms
@expansion{} 0,       4a+b-8c, -a+6b+c,  
@expansion{} -4a-b+8c,0,       -8a+2b-9c,
@expansion{} a-6b-c,  8a-2b+9c,0         
kill R1;
@c end example skewmat d2t_singular/matrix_lib.doc:351
@end smallexample
@c ---end content skewmat---

@c ------------------- submat -------------
@node submat, symmat, skewmat, matrix_lib
@subsubsection submat
@cindex submat
@c ---content submat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
submat(A,r,c); A=matrix, r,c=intvec

@item @strong{Return:}
matrix, submatrix of A with rows specified by intvec r
and columns specified by intvec c.

@end table
@strong{Example:}
@smallexample
@c reused example submat d2t_singular/matrix_lib.doc:384 
LIB "matrix.lib";
ring R=32003,(x,y,z),lp;
matrix A[4][4]=x,y,z,0,1,2,3,4,5,6,7,8,9,x2,y2,z2;
print(A);
@expansion{} x,y, z, 0,
@expansion{} 1,2, 3, 4,
@expansion{} 5,6, 7, 8,
@expansion{} 9,x2,y2,z2
intvec v=1,3,4;
matrix B=submat(A,v,1..3);
print(B);
@expansion{} x,y, z,
@expansion{} 5,6, 7,
@expansion{} 9,x2,y2
@c end example submat d2t_singular/matrix_lib.doc:384
@end smallexample
@c ---end content submat---

@c ------------------- symmat -------------
@node symmat, tensor, submat, matrix_lib
@subsubsection symmat
@cindex symmat
@c ---content symmat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
symmat(n[,id]); n integer, id ideal

@item @strong{Return:}
symmetric nxn matrix, with entries from id (default: id=maxideal(1))

@item @strong{Note:}
if id has less than n*(n+1)/2 elements, the matrix is filled with 0's,
symmat(n); creates the generic symmetric matrix

@end table
@strong{Example:}
@smallexample
@c reused example symmat d2t_singular/matrix_lib.doc:417 
LIB "matrix.lib";
ring R=0,x(1..10),lp;
print(symmat(4));    // the generic symmetric matrix
@expansion{} x(1),x(2),x(3),x(4),
@expansion{} x(2),x(5),x(6),x(7),
@expansion{} x(3),x(6),x(8),x(9),
@expansion{} x(4),x(7),x(9),x(10)
ring R1 = 0,(a,b,c),dp;
matrix A=symmat(4,maxideal(1)^3);
print(A);
@expansion{} a3, a2b,a2c,ab2,
@expansion{} a2b,abc,ac2,b3, 
@expansion{} a2c,ac2,b2c,bc2,
@expansion{} ab2,b3, bc2,c3  
int n=3;
ideal i = ideal(randommat(1,n*(n+1) div 2,maxideal(1),9));
print(symmat(n,i));  // symmetric matrix of generic linear forms
@expansion{} 4a-8b-2c,-a+b-4c, -8a-9b+c,
@expansion{} -a+b-4c, a-9b+9c, 6a-5b+9c,
@expansion{} -8a-9b+c,6a-5b+9c,2a+8c    
kill R1;
@c end example symmat d2t_singular/matrix_lib.doc:417
@end smallexample
@c ---end content symmat---

@c ------------------- tensor -------------
@node tensor, unitmat, symmat, matrix_lib
@subsubsection tensor
@cindex tensor
@c ---content tensor---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
tensor(A,B); A,B matrices

@item @strong{Return:}
matrix, tensor product of A and B

@end table
@strong{Example:}
@smallexample
@c reused example tensor d2t_singular/matrix_lib.doc:449 
LIB "matrix.lib";
ring r=32003,(x,y,z),(c,ds);
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix B[2][2]=x,y,0,z;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(B);
@expansion{} x,y,
@expansion{} 0,z 
print(tensor(A,B));
@expansion{} x, y, 2x,2y,3x,3y,
@expansion{} 0, z, 0, 2z,0, 3z,
@expansion{} 4x,4y,5x,5y,6x,6y,
@expansion{} 0, 4z,0, 5z,0, 6z,
@expansion{} 7x,7y,8x,8y,9x,9y,
@expansion{} 0, 7z,0, 8z,0, 9z 
@c end example tensor d2t_singular/matrix_lib.doc:449
@end smallexample
@c ---end content tensor---

@c ------------------- unitmat -------------
@node unitmat, gauss_col, tensor, matrix_lib
@subsubsection unitmat
@cindex unitmat
@c ---content unitmat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
unitmat(n); n integer >= 0

@item @strong{Return:}
nxn unit matrix

@item @strong{Note:}
needs a basering, diagonal entries are numbers (=1) in the basering

@end table
@strong{Example:}
@smallexample
@c reused example unitmat d2t_singular/matrix_lib.doc:481 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
print(xyz*unitmat(4));
@expansion{} xyz,0,  0,  0, 
@expansion{} 0,  xyz,0,  0, 
@expansion{} 0,  0,  xyz,0, 
@expansion{} 0,  0,  0,  xyz
print(unitmat(5));
@expansion{} 1,0,0,0,0,
@expansion{} 0,1,0,0,0,
@expansion{} 0,0,1,0,0,
@expansion{} 0,0,0,1,0,
@expansion{} 0,0,0,0,1 
@c end example unitmat d2t_singular/matrix_lib.doc:481
@end smallexample
@c ---end content unitmat---

@c ------------------- gauss_col -------------
@node gauss_col, gauss_row, unitmat, matrix_lib
@subsubsection gauss_col
@cindex gauss_col
@c ---content gauss_col---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
gauss_col(A[,e]); A a matrix, e any type

@item @strong{Return:}
- a matrix B, if called with one argument; B is the complete column-
reduced upper-triangular normal form of A if A is constant,
(resp. as far as this is possible if A is a polynomial matrix;
no division by polynomials).
@* - a list L of two matrices, if called with two arguments;
L satisfies L[1] = A * L[2] with L[1] the column-reduced form of A
and L[2] the transformation matrix.

@item @strong{Note:}
* The procedure just applies interred to A with ordering (C,dp).
The transformation matrix is obtained by applying 'lift'.
This should be faster than the procedure colred.
@* * It should only be used with exact coefficient field (there is no
pivoting and rounding error treatment).
@* * Parameters are allowed. Hence, if the entries of A are parameters,
B is the column-reduced form of A over the rational function field.

@end table
@strong{Example:}
@smallexample
@c reused example gauss_col d2t_singular/matrix_lib.doc:522 
LIB "matrix.lib";
ring r=(0,a,b),(A,B,C),dp;
matrix m[8][6]=
0,    2*C, 0,    0,  0,   0,
0,    -4*C,a*A,  0,  0,   0,
b*B,  -A,  0,    0,  0,   0,
-A,   B,   0,    0,  0,   0,
-4*C, 0,   B,    2,  0,   0,
2*A,  B,   0,    0,  0,   0,
0,    3*B, 0,    0,  2b,  0,
0,    AB,  0,    2*A,A,   2a;"";
@expansion{} 
list L=gauss_col(m,1);
print(L[1]);
@expansion{} 0,0,2*C, 0,       0,0,
@expansion{} A,0,-4*C,0,       0,0,
@expansion{} 0,0,-A,  (1/2b)*B,0,0,
@expansion{} 0,0,B,   -1/2*A,  0,0,
@expansion{} 0,1,0,   0,       0,0,
@expansion{} 0,0,B,   A,       0,0,
@expansion{} 0,0,0,   0,       1,0,
@expansion{} 0,0,0,   0,       0,1 
print(L[2]);
@expansion{} 0,         0,        0,               1/2,      0,         0,    
@expansion{} 0,         0,        1,               0,        0,         0,    
@expansion{} 1/(a),     0,        0,               0,        0,         0,    
@expansion{} -1/(2a)*B, 1/2,      0,               C,        0,         0,    
@expansion{} 0,         0,        -3/(2b)*B,       0,        1/(2b),    0,    
@expansion{} 1/(2a2)*AB,-1/(2a)*A,(-2b+3)/(4ab)*AB,-1/(a)*AC,-1/(4ab)*A,1/(2a)
ring S=0,x,(c,dp);
matrix A[5][4] =
3, 1, 1, 1,
13, 8, 6,-7,
14,10, 6,-7,
7, 4, 3,-3,
2, 1, 0, 3;
print(gauss_col(A));
@expansion{} 8/9,-5/9,-1/3,7/9,
@expansion{} 1,  0,   0,   0,  
@expansion{} 0,  1,   0,   0,  
@expansion{} 0,  0,   1,   0,  
@expansion{} 0,  0,   0,   1   
@c end example gauss_col d2t_singular/matrix_lib.doc:522
@end smallexample
@c inserted refs from d2t_singular/matrix_lib.doc:547
@ifinfo
@menu
See also:
* colred::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{colred}.
@end iftex
@c end inserted refs from d2t_singular/matrix_lib.doc:547

@c ---end content gauss_col---

@c ------------------- gauss_row -------------
@node gauss_row, addcol, gauss_col, matrix_lib
@subsubsection gauss_row
@cindex gauss_row
@c ---content gauss_row---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
gauss_row(A [,e]); A matrix, e any type

@item @strong{Return:}
- a matrix B, if called with one argument; B is the complete row-
reduced lower-triangular normal form of A if A is constant,
(resp. as far as this is possible if A is a polynomial matrix;
no division by polynomials).
@* - a list L of two matrices, if called with two arguments;
L satisfies L[1] = L[2] * A with L[1] the row-reduced form of A
and L[2] the transformation matrix.

@item @strong{Note:}
* This procedure just applies gauss_col to the transposed matrix.
The transformation matrix is obtained by applying lift.
This should be faster than the procedure rowred.
@* * It should only be used with exact coefficient field (there is no
pivoting and rounding error treatment).
@* * Parameters are allowed. Hence, if the entries of A are parameters,
B is the row-reduced form of A over the rational function field.

@end table
@strong{Example:}
@smallexample
@c reused example gauss_row d2t_singular/matrix_lib.doc:585 
LIB "matrix.lib";
ring r=(0,a,b),(A,B,C),dp;
matrix m[6][8]=
0, 0,  b*B, -A,-4C,2A,0, 0,
2C,-4C,-A,B, 0,  B, 3B,AB,
0,a*A,  0, 0, B,  0, 0, 0,
0, 0,  0, 0, 2,  0, 0, 2A,
0, 0,  0, 0, 0,  0, 2b, A,
0, 0,  0, 0, 0,  0, 0, 2a;"";
@expansion{} 
print(gauss_row(m));"";
@expansion{} 0,  A,   0,       0,     0,0,0,0,
@expansion{} 0,  0,   0,       0,     1,0,0,0,
@expansion{} 2*C,-4*C,-A,      B,     0,B,0,0,
@expansion{} 0,  0,   (1/2b)*B,-1/2*A,0,A,0,0,
@expansion{} 0,  0,   0,       0,     0,0,1,0,
@expansion{} 0,  0,   0,       0,     0,0,0,1 
@expansion{} 
ring S=0,x,dp;
matrix A[4][5] =  3, 1,1,-1,2,
13, 8,6,-7,1,
14,10,6,-7,1,
7, 4,3,-3,3;
list L=gauss_row(A,1);
print(L[1]);
@expansion{} 1/2,-7/3,-19/6,5/6,
@expansion{} 1,  0,   0,    0,  
@expansion{} 0,  1,   0,    0,  
@expansion{} 0,  0,   1,    0,  
@expansion{} 0,  0,   0,    1   
print(L[2]);
@expansion{} 0,   -6,  -5,  1,   
@expansion{} -1/2,2/3, -1/6,-1/6,
@expansion{} 1/2, -5/3,-5/6,1/6, 
@expansion{} 0,   13/3,11/3,-1/3 
@c end example gauss_row d2t_singular/matrix_lib.doc:585
@end smallexample
@c inserted refs from d2t_singular/matrix_lib.doc:606
@ifinfo
@menu
See also:
* rowred::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{rowred}.
@end iftex
@c end inserted refs from d2t_singular/matrix_lib.doc:606

@c ---end content gauss_row---

@c ------------------- addcol -------------
@node addcol, addrow, gauss_row, matrix_lib
@subsubsection addcol
@cindex addcol
@c ---content addcol---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
addcol(A,c1,p,c2); A matrix, p poly, c1, c2 positive integers

@item @strong{Return:}
matrix, A being modified by adding p times column c1 to column c2

@end table
@strong{Example:}
@smallexample
@c reused example addcol d2t_singular/matrix_lib.doc:629 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(addcol(A,1,xy,2));
@expansion{} 1,xy+2, 3,
@expansion{} 4,4xy+5,6,
@expansion{} 7,7xy+8,9 
@c end example addcol d2t_singular/matrix_lib.doc:629
@end smallexample
@c ---end content addcol---

@c ------------------- addrow -------------
@node addrow, multcol, addcol, matrix_lib
@subsubsection addrow
@cindex addrow
@c ---content addrow---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
addcol(A,r1,p,r2); A matrix, p poly, r1, r2 positive integers

@item @strong{Return:}
matrix, A being modified by adding p times row r1 to row r2

@end table
@strong{Example:}
@smallexample
@c reused example addrow d2t_singular/matrix_lib.doc:656 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(addrow(A,1,xy,3));
@expansion{} 1,   2,    3,   
@expansion{} 4,   5,    6,   
@expansion{} xy+7,2xy+8,3xy+9
@c end example addrow d2t_singular/matrix_lib.doc:656
@end smallexample
@c ---end content addrow---

@c ------------------- multcol -------------
@node multcol, multrow, addrow, matrix_lib
@subsubsection multcol
@cindex multcol
@c ---content multcol---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
addcol(A,c,p); A matrix, p poly, c positive integer

@item @strong{Return:}
matrix, A being modified by multiplying column c with p

@end table
@strong{Example:}
@smallexample
@c reused example multcol d2t_singular/matrix_lib.doc:683 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(multcol(A,2,xy));
@expansion{} 1,2xy,3,
@expansion{} 4,5xy,6,
@expansion{} 7,8xy,9 
@c end example multcol d2t_singular/matrix_lib.doc:683
@end smallexample
@c ---end content multcol---

@c ------------------- multrow -------------
@node multrow, permcol, multcol, matrix_lib
@subsubsection multrow
@cindex multrow
@c ---content multrow---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
multrow(A,r,p); A matrix, p poly, r positive integer

@item @strong{Return:}
matrix, A being modified by multiplying row r with p

@end table
@strong{Example:}
@smallexample
@c reused example multrow d2t_singular/matrix_lib.doc:710 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(multrow(A,2,xy));
@expansion{} 1,  2,  3,  
@expansion{} 4xy,5xy,6xy,
@expansion{} 7,  8,  9   
@c end example multrow d2t_singular/matrix_lib.doc:710
@end smallexample
@c ---end content multrow---

@c ------------------- permcol -------------
@node permcol, permrow, multrow, matrix_lib
@subsubsection permcol
@cindex permcol
@c ---content permcol---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
permcol(A,c1,c2); A matrix, c1,c2 positive integers

@item @strong{Return:}
matrix, A being modified by permuting column c1 and c2

@end table
@strong{Example:}
@smallexample
@c reused example permcol d2t_singular/matrix_lib.doc:737 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,x,3,4,y,6,7,z,9;
print(A);
@expansion{} 1,x,3,
@expansion{} 4,y,6,
@expansion{} 7,z,9 
print(permcol(A,2,3));
@expansion{} 1,3,x,
@expansion{} 4,6,y,
@expansion{} 7,9,z 
@c end example permcol d2t_singular/matrix_lib.doc:737
@end smallexample
@c ---end content permcol---

@c ------------------- permrow -------------
@node permrow, rowred, permcol, matrix_lib
@subsubsection permrow
@cindex permrow
@c ---content permrow---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
permrow(A,r1,r2); A matrix, r1,r2 positive integers

@item @strong{Return:}
matrix, A being modified by permuting row r1 and r2

@end table
@strong{Example:}
@smallexample
@c reused example permrow d2t_singular/matrix_lib.doc:764 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,x,y,z,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} x,y,z,
@expansion{} 7,8,9 
print(permrow(A,2,1));
@expansion{} x,y,z,
@expansion{} 1,2,3,
@expansion{} 7,8,9 
@c end example permrow d2t_singular/matrix_lib.doc:764
@end smallexample
@c ---end content permrow---

@c ------------------- rowred -------------
@node rowred, colred, permrow, matrix_lib
@subsubsection rowred
@cindex rowred
@c ---content rowred---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
rowred(A[,e]); A matrix, e any type

@item @strong{Return:}
- a matrix B, being the row reduced form of A, if rowred is called
with one argument.
@*(as far as this is possible over the polynomial ring; no division
by polynomials)
@* - a list L of two matrices, such that L[1] = L[2] * A with L[1]
the row-reduced form of A and L[2] the transformation matrix
(if rowred is called with two arguments).

@item @strong{Note:}
* This procedure is designed for teaching purposes mainly.
@* * The straight forward Gaussian algorithm is implemented in the
library (no standard basis computation).
@*The transformation matrix is obtained by concatenating a unit
matrix to A. proc gauss_row should be faster.
@* * It should only be used with exact coefficient field (there is no
pivoting) over the polynomial ring (ordering lp or dp).
@* * Parameters are allowed. Hence, if the entries of A are parameters
the computation takes place over the field of rational functions.

@end table
@strong{Example:}
@smallexample
@c reused example rowred d2t_singular/matrix_lib.doc:808 
LIB "matrix.lib";
ring r=(0,a,b),(A,B,C),dp;
matrix m[6][8]=
0, 0,  b*B, -A,-4C,2A,0, 0,
2C,-4C,-A,B, 0,  B, 3B,AB,
0,a*A,  0, 0, B,  0, 0, 0,
0, 0,  0, 0, 2,  0, 0, 2A,
0, 0,  0, 0, 0,  0, 2b, A,
0, 0,  0, 0, 0,  0, 0, 2a;"";
@expansion{} 
print(rowred(m));"";
@expansion{} 0,  0,    0,    0, 1,0,  0,0,
@expansion{} 0,  0,    0,    0, 0,0,  1,0,
@expansion{} 0,  0,    0,    0, 0,0,  0,1,
@expansion{} 0,  0,    (b)*B,-A,0,2*A,0,0,
@expansion{} 2*C,-4*C, -A,   B, 0,B,  0,0,
@expansion{} 0,  (a)*A,0,    0, 0,0,  0,0 
@expansion{} 
list L=rowred(m,1);
print(L[1]);
@expansion{} 0,  0,    0,    0, 1,0,  0,0,
@expansion{} 0,  0,    0,    0, 0,0,  1,0,
@expansion{} 0,  0,    0,    0, 0,0,  0,1,
@expansion{} 0,  0,    (b)*B,-A,0,2*A,0,0,
@expansion{} 2*C,-4*C, -A,   B, 0,B,  0,0,
@expansion{} 0,  (a)*A,0,    0, 0,0,  0,0 
print(L[2]);
@expansion{} 0,0,0,1/2,   0,        -1/(2a)*A,       
@expansion{} 0,0,0,0,     1/(2b),   -1/(4ab)*A,      
@expansion{} 0,0,0,0,     0,        1/(2a),          
@expansion{} 1,0,0,2*C,   0,        -2/(a)*AC,       
@expansion{} 0,1,0,0,     -3/(2b)*B,(-2b+3)/(4ab)*AB,
@expansion{} 0,0,1,-1/2*B,0,        1/(2a)*AB        
@c end example rowred d2t_singular/matrix_lib.doc:808
@end smallexample
@c inserted refs from d2t_singular/matrix_lib.doc:824
@ifinfo
@menu
See also:
* gauss_row::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{gauss_row}.
@end iftex
@c end inserted refs from d2t_singular/matrix_lib.doc:824

@c ---end content rowred---

@c ------------------- colred -------------
@node colred, rm_unitrow, rowred, matrix_lib
@subsubsection colred
@cindex colred
@c ---content colred---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
colred(A[,e]); A matrix, e any type

@item @strong{Return:}
- a matrix B, being the column reduced form of A, if colred is
called with one argument.
@*(as far as this is possible over the polynomial ring;
no division by polynomials)
@* - a list L of two matrices, such that L[1] = A * L[2] with L[1]
the column-reduced form of A and L[2] the transformation matrix
(if colred is called with two arguments).

@item @strong{Note:}
* This procedure is designed for teaching purposes mainly.
@* * It applies rowred to the transposed matrix.
proc gauss_col should be faster.
@* * It should only be used with exact coefficient field (there is no
pivoting) over the polynomial ring (ordering lp or dp).
@* * Parameters are allowed. Hence, if the entries of A are parameters
the computation takes place over the field of rational functions.

@end table
@strong{Example:}
@smallexample
@c reused example colred d2t_singular/matrix_lib.doc:862 
LIB "matrix.lib";
ring r=(0,a,b),(A,B,C),dp;
matrix m[8][6]=
0,    2*C, 0,    0,  0,   0,
0,    -4*C,a*A,  0,  0,   0,
b*B,  -A,  0,    0,  0,   0,
-A,   B,   0,    0,  0,   0,
-4*C, 0,   B,    2,  0,   0,
2*A,  B,   0,    0,  0,   0,
0,    3*B, 0,    0,  2b,  0,
0,    AB,  0,    2*A,A,   2a;"";
@expansion{} 
print(colred(m));"";
@expansion{} 0,0,0,0,    2*C, 0,    
@expansion{} 0,0,0,0,    -4*C,(a)*A,
@expansion{} 0,0,0,(b)*B,-A,  0,    
@expansion{} 0,0,0,-A,   B,   0,    
@expansion{} 1,0,0,0,    0,   0,    
@expansion{} 0,0,0,2*A,  B,   0,    
@expansion{} 0,1,0,0,    0,   0,    
@expansion{} 0,0,1,0,    0,   0     
@expansion{} 
list L=colred(m,1);
print(L[1]);
@expansion{} 0,0,0,0,    2*C, 0,    
@expansion{} 0,0,0,0,    -4*C,(a)*A,
@expansion{} 0,0,0,(b)*B,-A,  0,    
@expansion{} 0,0,0,-A,   B,   0,    
@expansion{} 1,0,0,0,    0,   0,    
@expansion{} 0,0,0,2*A,  B,   0,    
@expansion{} 0,1,0,0,    0,   0,    
@expansion{} 0,0,1,0,    0,   0     
print(L[2]);
@expansion{} 0,        0,         0,     1,        0,               0,       
@expansion{} 0,        0,         0,     0,        1,               0,       
@expansion{} 0,        0,         0,     0,        0,               1,       
@expansion{} 1/2,      0,         0,     2*C,      0,               -1/2*B,  
@expansion{} 0,        1/(2b),    0,     0,        -3/(2b)*B,       0,       
@expansion{} -1/(2a)*A,-1/(4ab)*A,1/(2a),-2/(a)*AC,(-2b+3)/(4ab)*AB,1/(2a)*AB
@c end example colred d2t_singular/matrix_lib.doc:862
@end smallexample
@c inserted refs from d2t_singular/matrix_lib.doc:880
@ifinfo
@menu
See also:
* gauss_col::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{gauss_col}.
@end iftex
@c end inserted refs from d2t_singular/matrix_lib.doc:880

@c ---end content colred---

@c ------------------- rm_unitrow -------------
@node rm_unitrow, rm_unitcol, colred, matrix_lib
@subsubsection rm_unitrow
@cindex rm_unitrow
@c ---content rm_unitrow---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
rm_unitrow(A); A matrix (being col-reduced)

@item @strong{Return:}
matrix, obtained from A by deleting unit rows (having just one 1
and else 0 as entries) and associated columns

@end table
@strong{Example:}
@smallexample
@c reused example rm_unitrow d2t_singular/matrix_lib.doc:904 
LIB "matrix.lib";
ring r=0,(A,B,C),dp;
matrix m[8][6]=
0,0,  0,   0, 2C, 0,
0,0,  0,   0, -4C,A,
A,-C2,0,   B, -A, 0,
0,0,  1/2B,-A,B,  0,
1,0,  0,   0, 0,  0,
0,0,  0,   2A,B,  0,
0,1,  0,   0, 0,  0,
0,0,  1,   0, 0,  0;
print(rm_unitrow(m));
@expansion{} 0, 2C, 0,
@expansion{} 0, -4C,A,
@expansion{} B, -A, 0,
@expansion{} -A,B,  0,
@expansion{} 2A,B,  0 
@c end example rm_unitrow d2t_singular/matrix_lib.doc:904
@end smallexample
@c ---end content rm_unitrow---

@c ------------------- rm_unitcol -------------
@node rm_unitcol, headStand, rm_unitrow, matrix_lib
@subsubsection rm_unitcol
@cindex rm_unitcol
@c ---content rm_unitcol---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
rm_unitcol(A); A matrix (being row-reduced)

@item @strong{Return:}
matrix, obtained from A by deleting unit columns (having just one 1
and else 0 as entries) and associated rows

@end table
@strong{Example:}
@smallexample
@c reused example rm_unitcol d2t_singular/matrix_lib.doc:939 
LIB "matrix.lib";
ring r=0,(A,B,C),dp;
matrix m[6][8]=
0,  0,    A,   0, 1,0,  0,0,
0,  0,  -C2,   0, 0,0,  1,0,
0,  0,    0,1/2B, 0,0,  0,1,
0,  0,    B,  -A, 0,2A, 0,0,
2C,-4C,  -A,   B, 0,B,  0,0,
0,  A,    0,   0, 0,0,  0,0;
print(rm_unitcol(m));
@expansion{} 0, 0,  B, -A,2A,
@expansion{} 2C,-4C,-A,B, B, 
@expansion{} 0, A,  0, 0, 0  
@c end example rm_unitcol d2t_singular/matrix_lib.doc:939
@end smallexample
@c ---end content rm_unitcol---

@c ------------------- headStand -------------
@node headStand,, rm_unitcol, matrix_lib
@subsubsection headStand
@cindex headStand
@c ---content headStand---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@end table
@c ---end content headStand---
