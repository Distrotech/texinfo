@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/rinvar_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/rinvar_lib.doc INSTEAD
@c library version: (1.7.2.3,2002/02/20)
@c library file: ../Singular/LIB/rinvar.lib
@cindex rinvar.lib
@cindex rinvar_lib
@table @asis
@item @strong{Library:}
rinvar.lib
@item @strong{Purpose:}
      Invariant Rings of Reductive Groups
@item @strong{Author:}
Thomas Bayer, tbayer@@in.tum.de
@*http://wwwmayr.informatik.tu-muenchen.de/personen/bayert/
Current Adress: Institut fuer Informatik, TU Muenchen

@item @strong{Overview:}
Implementation based on Derksen's algorithm. Written in the frame of the
diploma thesis (advisor: Prof. Gert-Martin Greuel) 'Computations of moduli
spaces of semiquasihomogeneous singularities and an implementation in Singular'

@end table

@strong{Procedures:}
@menu
* HilbertSeries:: Hilbert series of the ideal I w.r.t. weight w
* HilbertWeights:: weighted degrees of the generators of I
* ImageVariety:: ideal of the image variety F(variety(I))
* ImageGroup:: ideal of G w.r.t. the induced representation
* InvariantRing:: generators of the invariant ring of G
* InvariantQ:: decide if f is invariant w.r.t. G
* LinearizeAction:: linearization of the action 'Gaction' of G
* LinearActionQ:: decide if action is linear in var(s..nvars)
* LinearCombinationQ:: decide if f is in the linear hull of 'base'
* MinimalDecomposition:: minimal decomposition of f (like coef)
* NullCone:: ideal of the null cone of the action 'act' of G
* ReynoldsImage:: image of f under the Reynolds operator 'RO'
* ReynoldsOperator:: Reynolds operator of the group G
* SimplifyIdeal:: simplify the ideal I (try to reduce variables)
* TransferIdeal:: transfer the ideal 'name' from R to basering
@end menu
@c inserted refs from d2t_singular/rinvar_lib.doc:41
@ifinfo
@menu
See also:
* qhmoduli_lib::
* zeroset_lib::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{qhmoduli_lib};
@ref{zeroset_lib}.
@end iftex
@c end inserted refs from d2t_singular/rinvar_lib.doc:41

@c ---end content LibInfo---

@c ------------------- HilbertSeries -------------
@node HilbertSeries, HilbertWeights,, rinvar_lib
@subsubsection HilbertSeries
@cindex HilbertSeries
@c ---content HilbertSeries---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
HilbertSeries(I, w); ideal I, intvec wt

@item @strong{Purpose:}
compute the polynomial p of the Hilbert Series,represented by p/q, of
the ring K[t_1,...,t_m,y_1,...,y_r]/I1 where 'w' are the weights of
the variables, computed, e.g., by 'HilbertWeights', 'I1' is of the
form I[1] - y_1,...,I[r] - y_r and is quasihomogeneous w.r.t. 'w'

@item @strong{Return:}
intvec

@item @strong{Note:}
the leading 0 of the result does not belong to p, but is needed in
the hilbert-driven 'std'.

@end table
@c ---end content HilbertSeries---

@c ------------------- HilbertWeights -------------
@node HilbertWeights, ImageVariety, HilbertSeries, rinvar_lib
@subsubsection HilbertWeights
@cindex HilbertWeights
@c ---content HilbertWeights---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Purpose:}
compute the weights of the "slack" variables needed for the
computation of the algebraic relations of the generators of 'I' s.t.
the Hilbert driven 'std' can be used.

@item @strong{Return:}
intvec

@item @strong{Assume:}
basering = K[t_1,...,t_m,...], 'I' is quasihomogeneous w.r.t. 'w' and
contains only polynomials in t_1,...,t_m

@end table
@c ---end content HilbertWeights---

@c ------------------- ImageVariety -------------
@node ImageVariety, ImageGroup, HilbertWeights, rinvar_lib
@subsubsection ImageVariety
@cindex ImageVariety
@c ---content ImageVariety---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
ImageVariety(ideal I, F [, w]);ideal I; F is a list/ideal, intvec w.

@item @strong{Purpose:}
compute the Zariski closure of the image of the variety of I under
the morphism F.

@item @strong{Note:}
if 'I' and 'F' are quasihomogeneous w.r.t. 'w' then the Hilbert-driven
'std' is used.

@item @strong{Return:}
polynomial ring over the same ground field, containing the ideal
'imageid'. The variables are Y(1),...,Y(k) where k = size(F)
- 'imageid' is the ideal of the Zariski closure of F(X) where
X is the variety of I.

@end table
@strong{Example:}
@smallexample
@c computed example ImageVariety d2t_singular/rinvar_lib.doc:125 
LIB "rinvar.lib";
ring B   = 0,(x,y),dp;
ideal I  = x4 - y4;
ideal F  = x2, y2, x*y;
def R = ImageVariety(I, F);
setring R;
imageid;
@expansion{} imageid[1]=Y(1)*Y(2)-Y(3)^2
@expansion{} imageid[2]=Y(1)^2-Y(2)^2
@expansion{} imageid[3]=Y(2)^3-Y(1)*Y(3)^2
@c end example ImageVariety d2t_singular/rinvar_lib.doc:125
@end smallexample
@c ---end content ImageVariety---

@c ------------------- ImageGroup -------------
@node ImageGroup, InvariantRing, ImageVariety, rinvar_lib
@subsubsection ImageGroup
@cindex ImageGroup
@c ---content ImageGroup---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
ImageGroup(G, action); ideal G, action;

@item @strong{Purpose:}
compute the ideal of the image of G in GL(m,K) induced by the linear
action 'action', where G is an algebraic group and 'action' defines
an action of G on K^m (size(action) = m).

@item @strong{Return:}
ring, a polynomial ring over the same ground field as the basering,
containing the ideals 'groupid' and 'actionid'.
@*- 'groupid' is the ideal of the image of G (order <= order of G)
- 'actionid' defines the linear action of 'groupid' on K^m.

@item @strong{Note:}
'action' and 'actionid' have the same orbits
@*all variables which give only rise to 0's in the m x m matrices of G
have been omitted.

@item @strong{Assume:}
basering K[s(1..r),t(1..m)] has r + m variables, G is the ideal of an
algebraic group and F is an action of G on K^m. G contains only the
variables s(1)...s(r). The action 'action' is given by polynomials
f_1,...,f_m in basering, s.t. on the ring level we have
K[t_1,...,t_m] --> K[s_1,...,s_r,t_1,...,t_m]/G
@*t_i --> f_i(s_1,...,s_r,t_1,...,t_m)

@end table
@strong{Example:}
@smallexample
@c computed example ImageGroup d2t_singular/rinvar_lib.doc:175 
LIB "rinvar.lib";
ring B   = 0,(s(1..2), t(1..2)),dp;
ideal G = s(1)^3-1, s(2)^10-1;
ideal action = s(1)*s(2)^8*t(1), s(1)*s(2)^7*t(2);
def R = ImageGroup(G, action);
setring R;
groupid;
@expansion{} groupid[1]=-s(1)+s(2)^4
@expansion{} groupid[2]=s(1)^8-s(2)^2
@expansion{} groupid[3]=s(1)^7*s(2)^2-1
actionid;
@expansion{} actionid[1]=s(1)*t(1)
@expansion{} actionid[2]=s(2)*t(2)
@c end example ImageGroup d2t_singular/rinvar_lib.doc:175
@end smallexample
@c ---end content ImageGroup---

@c ------------------- InvariantRing -------------
@node InvariantRing, InvariantQ, ImageGroup, rinvar_lib
@subsubsection InvariantRing
@cindex InvariantRing
@c ---content InvariantRing---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
InvariantRing(G, Gact [, opt]); ideal G, Gact; int opt

@item @strong{Purpose:}
compute generators of the invariant ring of G w.r.t. the action 'Gact'

@item @strong{Assume:}
G is a finite group and 'Gact' is a linear action.

@item @strong{Return:}
polynomial ring over a simple extension of the ground field of the
basering (the extension might be trivial), containing the ideals
'invars' and 'groupid' and the poly 'newA'
@*- 'invars' contains the algebra-generators of the invariant ring
- 'groupid' is the ideal of G in the new ring
@*- 'newA' if the minpoly changes this is the new representation of the
algebraic number, otherwise it is set to 'a'.

@item @strong{Note:}
the delivered ring might have a different minimal polynomial

@end table
@strong{Example:}
@smallexample
@c computed example InvariantRing d2t_singular/rinvar_lib.doc:220 
LIB "rinvar.lib";
ring B = 0, (s(1..2), t(1..2)), dp;
ideal G = -s(1)+s(2)^3, s(1)^4-1;
ideal action = s(1)*t(1), s(2)*t(2);
def R = InvariantRing(std(G), action);
setring R;
invars;
@expansion{} invars[1]=t(1)^4
@expansion{} invars[2]=t(1)^3*t(2)^3
@expansion{} invars[3]=t(1)^2*t(2)^6
@expansion{} invars[4]=t(1)*t(2)^9
@expansion{} invars[5]=t(2)^12
@c end example InvariantRing d2t_singular/rinvar_lib.doc:220
@end smallexample
@c ---end content InvariantRing---

@c ------------------- InvariantQ -------------
@node InvariantQ, LinearizeAction, InvariantRing, rinvar_lib
@subsubsection InvariantQ
@cindex InvariantQ
@c ---content InvariantQ---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
InvariantQ(f, G, action); poly f; ideal G, action

@item @strong{Purpose:}
check if the polynomial f is invariant w.r.t. G where G acts via
'action' on K^m.

@item @strong{Assume:}
basering = K[s_1,...,s_m,t_1,...,t_m] where K = Q of K = Q(a) and
minpoly != 0, f contains only t_1,...,t_m, G is the ideal of an
algebraic group and a standard basis.

@item @strong{Return:}
int;
@*0 if f is not invariant,
@*1 if f is invariant

@item @strong{Note:}
G need not be finite

@end table
@c ---end content InvariantQ---

@c ------------------- LinearizeAction -------------
@node LinearizeAction, LinearActionQ, InvariantQ, rinvar_lib
@subsubsection LinearizeAction
@cindex LinearizeAction
@c ---content LinearizeAction---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
LinearizeAction(G,action,r); ideal G, action; int r

@item @strong{Purpose:}
linearize the group action 'action' and find an equivariant embedding
of K^m where m = size(action).

@item @strong{Assume:}
G contains only variables var(1..r) (r = nrs)
@*basering = K[s(1..r),t(1..m)], K = Q or K = Q(a) and minpoly != 0.

@item @strong{Return:}
polynomial ring containing the ideals 'actionid', 'embedid', 'groupid'
- 'actionid' is the ideal defining the linearized action of G
- 'embedid' is a parameterization of an equivariant embedding (closed)
- 'groupid' is the ideal of G in the new ring

@item @strong{Note:}
set printlevel > 0 to see a trace

@end table
@strong{Example:}
@smallexample
@c computed example LinearizeAction d2t_singular/rinvar_lib.doc:294 
LIB "rinvar.lib";
ring B   = 0,(s(1..5), t(1..3)),dp;
ideal G =  s(3)-s(4), s(2)-s(5), s(4)*s(5), s(1)^2*s(4)+s(1)^2*s(5)-1, s(1)^2*s(5)^2-s(5), s(4)^4-s(5)^4+s(1)^2, s(1)^4+s(4)^3-s(5)^3, s(5)^5-s(1)^2*s(5);
ideal action = -s(4)*t(1)+s(5)*t(1), -s(4)^2*t(2)+2*s(4)^2*t(3)^2+s(5)^2*t(2), s(4)*t(3)+s(5)*t(3);
LinearActionQ(action, 5);
@expansion{} 0
def R = LinearizeAction(G, action, 5);
setring R;
R;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 9
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    s(1) s(2) s(3) s(4) s(5) t(1) t(2) t(3) t(\
   4) 
@expansion{} //        block   2 : ordering C
actionid;
@expansion{} actionid[1]=-s(4)*t(1)+s(5)*t(1)
@expansion{} actionid[2]=-s(4)^2*t(2)+s(5)^2*t(2)+2*s(4)^2*t(4)
@expansion{} actionid[3]=s(4)*t(3)+s(5)*t(3)
@expansion{} actionid[4]=s(4)^2*t(4)+s(5)^2*t(4)
embedid;
@expansion{} embedid[1]=t(1)
@expansion{} embedid[2]=t(2)
@expansion{} embedid[3]=t(3)
@expansion{} embedid[4]=t(3)^2
groupid;
@expansion{} groupid[1]=s(3)-s(4)
@expansion{} groupid[2]=s(2)-s(5)
@expansion{} groupid[3]=s(4)*s(5)
@expansion{} groupid[4]=s(1)^2*s(4)+s(1)^2*s(5)-1
@expansion{} groupid[5]=s(1)^2*s(5)^2-s(5)
@expansion{} groupid[6]=s(4)^4-s(5)^4+s(1)^2
@expansion{} groupid[7]=s(1)^4+s(4)^3-s(5)^3
@expansion{} groupid[8]=s(5)^5-s(1)^2*s(5)
LinearActionQ(actionid, 5);
@expansion{} 1
@c end example LinearizeAction d2t_singular/rinvar_lib.doc:294
@end smallexample
@c ---end content LinearizeAction---

@c ------------------- LinearActionQ -------------
@node LinearActionQ, LinearCombinationQ, LinearizeAction, rinvar_lib
@subsubsection LinearActionQ
@cindex LinearActionQ
@c ---content LinearActionQ---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
LinearActionQ(action,nrs,nrt); ideal action, int nrs

@item @strong{Purpose:}
check if the action defined by 'action' is linear w.r.t. the variables
var(nrs + 1...nvars(basering)).

@item @strong{Return:}
0 action not linear
@*1 action is linear

@end table
@strong{Example:}
@smallexample
@c computed example LinearActionQ d2t_singular/rinvar_lib.doc:333 
LIB "rinvar.lib";
ring R   = 0,(s(1..5), t(1..3)),dp;
ideal G =  s(3)-s(4), s(2)-s(5), s(4)*s(5), s(1)^2*s(4)+s(1)^2*s(5)-1, s(1)^2*s(5)^2-s(5), s(4)^4-s(5)^4+s(1)^2, s(1)^4+s(4)^3-s(5)^3, s(5)^5-s(1)^2*s(5);
ideal Gaction = -s(4)*t(1)+s(5)*t(1), -s(4)^2*t(2)+2*s(4)^2*t(3)^2+s(5)^2*t(2), s(4)*t(3)+s(5)*t(3);
LinearActionQ(Gaction, 5, 3);
@expansion{} // ** too many arguments for LinearActionQ
@expansion{} 0
@c end example LinearActionQ d2t_singular/rinvar_lib.doc:333
@end smallexample
@c ---end content LinearActionQ---

@c ------------------- LinearCombinationQ -------------
@node LinearCombinationQ, MinimalDecomposition, LinearActionQ, rinvar_lib
@subsubsection LinearCombinationQ
@cindex LinearCombinationQ
@c ---content LinearCombinationQ---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
LinearCombination(I, f); ideal I, poly f

@item @strong{Purpose:}
test if f can be written as a linear combination of the generators of I.

@item @strong{Return:}
0 f is not a linear combination
@*1 f is a linear combination

@end table
@c ---end content LinearCombinationQ---

@c ------------------- MinimalDecomposition -------------
@node MinimalDecomposition, NullCone, LinearCombinationQ, rinvar_lib
@subsubsection MinimalDecomposition
@cindex MinimalDecomposition
@c ---content MinimalDecomposition---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
MinimalDecomposition(f,a,b); poly f; int a, b.

@item @strong{Purpose:}
decompose f as a sum M[1,1]*M[2,1] + ... + M[1,r]*M[2,r] where M[1,i]
contains only s(1..a), M[2,i] contains only t(1...b) s.t. r is minimal

@item @strong{Assume:}
f polynomial in K[s(1..a),t(1..b)], K = Q or K = Q(a) and minpoly != 0

@item @strong{Return:}
2 x r matrix M s.t. f = M[1,1]*M[2,1] + ... + M[1,r]*M[2,r]

@end table
@strong{Example:}
@smallexample
@c computed example MinimalDecomposition d2t_singular/rinvar_lib.doc:388 
LIB "rinvar.lib";
ring R = 0, (s(1..2), t(1..2)), dp;
poly h = s(1)*(t(1) + t(1)^2) +  (t(2) + t(2)^2)*(s(1)^2 + s(2));
matrix M = MinimalDecomposition(h, 2, 2);
M;
@expansion{} M[1,1]=s(1)^2+s(2)
@expansion{} M[1,2]=s(1)
@expansion{} M[2,1]=t(2)^2+t(2)
@expansion{} M[2,2]=t(1)^2+t(1)
M[1,1]*M[2,1] + M[1,2]*M[2,2] - h;
@expansion{} 0
@c end example MinimalDecomposition d2t_singular/rinvar_lib.doc:388
@end smallexample
@c ---end content MinimalDecomposition---

@c ------------------- NullCone -------------
@node NullCone, ReynoldsImage, MinimalDecomposition, rinvar_lib
@subsubsection NullCone
@cindex NullCone
@c ---content NullCone---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
NullCone(G, action); ideal G, action

@item @strong{Purpose:}
compute the ideal of the null cone of the linear action of G on K^n,
given by 'action', by means of Derksen's algorithm

@item @strong{Assume:}
basering = K[s(1..r),t(1..n)], K = Q or K = Q(a) and minpoly != 0,
G is an ideal of a reductive algebraic group in K[s(1..r)],
'action' is a linear group action of G on K^n (n = ncols(action))

@item @strong{Return:}
ideal of the null cone of G.

@item @strong{Note:}
the generators of the null cone are homogeneous, but i.g. not invariant

@end table
@strong{Example:}
@smallexample
@c computed example NullCone d2t_singular/rinvar_lib.doc:428 
LIB "rinvar.lib";
ring R = 0, (s(1..2), x, y), dp;
ideal G = -s(1)+s(2)^3, s(1)^4-1;
ideal action = s(1)*x, s(2)*y;
ideal inv = NullCone(G, action);
inv;
@expansion{} inv[1]=x^4
@expansion{} inv[2]=x^3*y^3
@expansion{} inv[3]=x^2*y^6
@expansion{} inv[4]=x*y^9
@expansion{} inv[5]=y^12
@c end example NullCone d2t_singular/rinvar_lib.doc:428
@end smallexample
@c ---end content NullCone---

@c ------------------- ReynoldsImage -------------
@node ReynoldsImage, ReynoldsOperator, NullCone, rinvar_lib
@subsubsection ReynoldsImage
@cindex ReynoldsImage
@c ---content ReynoldsImage---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
ReynoldsImage(RO, f); list RO, poly f

@item @strong{Purpose:}
compute the Reynolds image of the polynomial f where RO represents
the Reynolds operator

@item @strong{Return:}
poly

@end table
@c ---end content ReynoldsImage---

@c ------------------- ReynoldsOperator -------------
@node ReynoldsOperator, SimplifyIdeal, ReynoldsImage, rinvar_lib
@subsubsection ReynoldsOperator
@cindex ReynoldsOperator
@c ---content ReynoldsOperator---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
ReynoldsOperator(G, action [, opt); ideal G, action; int opt

@item @strong{Purpose:}
compute the Reynolds operator of the group G which act via 'action'

@item @strong{Return:}
polynomial ring R over a simple extension of the ground field of the
basering (the extension might be trivial), containing a list
'ROelements', the ideals 'id', 'actionid' and the polynomial 'newA'.
R = K(a)[s(1..r),t(1..n)].
@*- 'ROelements' is a list of ideal, each ideal represents a
substitution map F : R -> R according to the zero-set of G
- 'id' is the ideal of G in the new ring
@*- 'newA' is the new representation of a' in terms of a. If the
basering does not contain a parameter then 'newA' = 'a'.

@item @strong{Assume:}
basering = K[s(1..r),t(1..n)], K = Q or K = Q(a') and minpoly != 0,
G is the ideal of a finite group in K[s(1..r)], 'action' is a linear
group action of G

@end table
@c ---end content ReynoldsOperator---

@c ------------------- SimplifyIdeal -------------
@node SimplifyIdeal, TransferIdeal, ReynoldsOperator, rinvar_lib
@subsubsection SimplifyIdeal
@cindex SimplifyIdeal
@c ---content SimplifyIdeal---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Purpose:}
simplify ideal I to the ideal I', do not change the names of the
first m variables, new ideal I' might contain less variables.
I' contains variables var(1..m)

@item @strong{Return:}
list
@*_[1] ideal I'
@*_[2] ideal representing a map phi to a ring with probably less vars. s.t.
phi(I) = I'
@*_[3] list of variables
@*_[4] list from 'elimpart'

@end table
@c ---end content SimplifyIdeal---

@c ------------------- TransferIdeal -------------
@node TransferIdeal,, SimplifyIdeal, rinvar_lib
@subsubsection TransferIdeal
@cindex TransferIdeal
@c ---content TransferIdeal---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@end table
@c ---end content TransferIdeal---
