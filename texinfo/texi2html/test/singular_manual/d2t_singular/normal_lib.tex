@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/normal_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/normal_lib.doc INSTEAD
@c library version: (1.34.2.17,2002/10/21)
@c library file: ../Singular/LIB/normal.lib
@cindex normal.lib
@cindex normal_lib
@table @asis
@item @strong{Library:}
normal.lib
@item @strong{Purpose:}
     Normalization of Affine Rings
@item @strong{Authors:}
G.-M. Greuel, greuel@@mathematik.uni-kl.de,
@* G. Pfister, pfister@@mathematik.uni-kl.de

@end table

@strong{Main procedures:}
@menu
* normal:: computes the normalization of basering/I, resp. computes the normalization of basering/I and the delta invariant
* HomJJ:: presentation of End_R(J) as affine ring, L a list
* genus:: computes genus of the projective curve defined by I
@end menu
@strong{Auxiliary procedure:}
@menu
* deltaLoc:: (sum of) delta invariant(s) at conjugated singular points
@end menu
@c ---end content LibInfo---

@c ------------------- normal -------------
@node normal, HomJJ,, normal_lib
@subsubsection normal
@cindex normal
@c ---content normal---
Procedure from library @code{normal.lib} (@pxref{normal_lib}).

@table @asis
@item @strong{Usage:}
normal(i [,choose]); i a radical ideal, choose empty, 1 or "wd"
if choose=1 the normalization of the associated primes is computed
(which is sometimes more efficient);
if @code{choose="wd"} the delta invariant is computed
simultaneously; this may take much more time in the reducible case,
since the factorizing standard basis algorithm cannot be used.

@item @strong{Assume:}
The ideal must be radical, for non-radical ideals the output may
be wrong (i=radical(i); makes i radical)

@item @strong{Return:}
a list of rings, say nor and in case of @code{choose="wd"} an
integer at the end of the list.
Each ring @code{nor[i]} contains two ideals with given names
@code{norid} and @code{normap} such that@*
- the direct sum of the rings @code{nor[i]/norid} is the
normalization of basering/id;@*
- @code{normap} gives the normalization map from basering/id to
@code{nor[i]/norid} (for each i).

@item @strong{Note:}
to use the i-th ring type: @code{def R=nor[i]; setring R;}.
@* Increasing printlevel displays more comments (default: printlevel=0).
@* Not implemented for local or mixed orderings.
@* If the input ideal i is weighted homogeneous a weighted ordering may
be used (qhweight(i); computes weights).

@cindex normalization
@cindex delta invariant.
@end table
@strong{Example:}
@smallexample
@c computed example normal d2t_singular/normal_lib.doc:71 
LIB "normal.lib";
ring r=32003,(x,y,z),wp(2,1,2);
ideal i=z3-xy4;
list nor=normal(i);
@expansion{} 
@expansion{} // 'normal' created a list of 1 ring(s).
@expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
show(nor);
@expansion{} // list, 1 element(s):
@expansion{} [1]:
@expansion{}    // ring: (32003),(T(1),T(2),T(3)),(a(2,1,1),dp(3),C);
@expansion{}    // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // normap               [0]  ideal, 3 generator(s)
@expansion{} // norid                [0]  ideal, 1 generator(s)
def r1=nor[1];
setring r1;
norid;
@expansion{} norid[1]=T(3)3-T(1)T(2)
normap;
@expansion{} normap[1]=T(1)
@expansion{} normap[2]=T(2)
@expansion{} normap[3]=T(2)T(3)
ring s=0,(x,y),dp;
ideal i=(x-y^2)^2 - y*x^3;
nor=normal(i,"wd");
@expansion{} 
@expansion{} // 'normal' created a list of 1 ring(s).
@expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
//the delta-invariant
nor[size(nor)];
@expansion{} 3
@c end example normal d2t_singular/normal_lib.doc:71
@end smallexample
@c ---end content normal---

@c ------------------- HomJJ -------------
@node HomJJ, genus, normal, normal_lib
@subsubsection HomJJ
@cindex HomJJ
@c ---content HomJJ---
Procedure from library @code{normal.lib} (@pxref{normal_lib}).

@table @asis
@item @strong{Usage:}
HomJJ (Li); Li = list: ideal SBid, ideal id, ideal J, poly p

@item @strong{Assume:}
R = P/id, P = basering, a polynomial ring, id an ideal of P,
@* SBid = standard basis of id,
@* J = ideal of P containing the polynomial p,
@* p = nonzero divisor of R

@item @strong{Compute:}
Endomorphism ring End_R(J)=Hom_R(J,J) with its ring structure as
affine ring, together with the canonical map R --> Hom_R(J,J),
where R is the quotient ring of P modulo the standard basis SBid.

@item @strong{Return:}
a list l of two objects
@format
         l[1] : a polynomial ring, containing two ideals, 'endid' and 'endphi'
               such that l[1]/endid = Hom_R(J,J) and
               endphi describes the canonical map R -> Hom_R(J,J)
         l[2] : an integer which is 1 if phi is an isomorphism, 0 if not
         l[3] : an integer, the contribution to delta
@end format

@item @strong{Note:}
printlevel >=1: display comments (default: printlevel=0)

@end table
@strong{Example:}
@smallexample
@c computed example HomJJ d2t_singular/normal_lib.doc:128 
LIB "normal.lib";
ring r   = 0,(x,y),wp(2,3);
ideal id = y^2-x^3;
ideal J  = x,y;
poly p   = x;
list Li = std(id),id,J,p;
list L   = HomJJ(Li);
def end = L[1];    // defines ring L[1], containing ideals endid, endphi
setring end;       // makes end the basering
end;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 1
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    T(1) 
@expansion{} //        block   2 : ordering C
endid;             // end/endid is isomorphic to End(r/id) as ring
@expansion{} endid[1]=0
map psi = r,endphi;// defines the canonical map r/id -> End(r/id)
psi;
@expansion{} psi[1]=T(1)^2
@expansion{} psi[2]=T(1)^3
@c end example HomJJ d2t_singular/normal_lib.doc:128
@end smallexample
@c ---end content HomJJ---

@c ------------------- genus -------------
@node genus, deltaLoc, HomJJ, normal_lib
@subsubsection genus
@cindex genus
@c ---content genus---
Procedure from library @code{normal.lib} (@pxref{normal_lib}).

@table @asis
@item @strong{Usage:}
genus(I) or genus(i,1); I a 1-dimensional ideal

@item @strong{Return:}
an integer, the geometric genus p_g = p_a - delta of the projective
curve defined by I, where p_a is the arithmetic genus.

@item @strong{Note:}
delta is the sum of all local delta-invariants of the singularities,
i.e. dim(R'/R), R' the normalization of the local ring R of the
singularity.
@*genus(i,1) uses the normalization to compute delta. Usually this
is slow but sometimes not.

@end table
@strong{Example:}
@smallexample
@c computed example genus d2t_singular/normal_lib.doc:171 
LIB "normal.lib";
ring r=0,(x,y),dp;
ideal i=y^9 - x^2*(x - 1)^9;
genus(i);
@expansion{} 0
@c end example genus d2t_singular/normal_lib.doc:171
@end smallexample
@c ---end content genus---

@c ------------------- deltaLoc -------------
@node deltaLoc,, genus, normal_lib
@subsubsection deltaLoc
@cindex deltaLoc
@c ---content deltaLoc---
Procedure from library @code{normal.lib} (@pxref{normal_lib}).

@table @asis
@item @strong{Usage:}
deltaLoc(f,J); f poly, J ideal

@item @strong{Assume:}
f is reduced bivariate polynomial; basering has exactly two variables;
J is irreducible prime component of the singular locus of f (e.g., one
entry of the output of @code{minAssGTZ(I);}, I = <f,jacob(f)>).

@item @strong{Return:}
list L:

@table @asis
@item @code{L[1]}; int:
         the sum of (local) delta invariants of f at the (conjugated) singular
         points given by J.
@item @code{L[2]}; int:
         the sum of (local) Tjurina numbers of f at the (conjugated) singular
         points given by J.
@item @code{L[3]}; int:
         the sum of (local) number of branches of f at the (conjugated) 
         singular points given by J.
@end table

@item @strong{Note:}
procedure makes use of @code{execute}; increasing printlevel displays
more comments (default: printlevel=0).

@cindex delta invariant
@cindex Tjurina number
@end table
@strong{Example:}
@smallexample
@c computed example deltaLoc d2t_singular/normal_lib.doc:220 
LIB "normal.lib";
ring r=0,(x,y),dp;
poly f=(x2+y^2-1)^3 +27x2y2;
ideal I=f,jacob(f);
I=std(I);
list qr=minAssGTZ(I);
size(qr);
@expansion{} 6
// each component of the singular locus either describes a cusp or a pair
// of conjugated nodes:
deltaLoc(f,qr[1]); 
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
deltaLoc(f,qr[2]); 
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
deltaLoc(f,qr[3]); 
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
deltaLoc(f,qr[4]); 
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
deltaLoc(f,qr[5]); 
@expansion{} [1]:
@expansion{}    2
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    4
deltaLoc(f,qr[6]);
@expansion{} [1]:
@expansion{}    2
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    4
@c end example deltaLoc d2t_singular/normal_lib.doc:220
@end smallexample
@c inserted refs from d2t_singular/normal_lib.doc:238
@ifinfo
@menu
See also:
* delta::
* tjurina::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{delta};
@ref{tjurina}.
@end iftex
@c end inserted refs from d2t_singular/normal_lib.doc:238

@c ---end content deltaLoc---
