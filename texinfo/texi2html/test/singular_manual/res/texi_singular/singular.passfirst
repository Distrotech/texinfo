singular.texi(,2) @comment Id: singular.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
singular.texi(,3) @comment This file was generated by doc2tex.pl from singular.doc
singular.texi(,4) @comment DO NOT EDIT DIRECTLY, BUT EDIT singular.doc INSTEAD
singular.texi(,5) @comment this file contains the main structure of the manual
singular.texi(,6) 
singular.texi(,7) 
singular.texi(,8) @c ------------------------
singular.texi(,9) @c %**start of header
singular.texi(,10) @c ------------------------
version.texi(,1) @c DO not edit this file. 
version.texi(,2) 
version.texi(,3) @set VERSION 2-0-4
version.texi(,4) @set VERSION_DATE October 2002
version.texi(,5) @set SHORT_VERSION 2-0
version.texi(,6) @set RPM_VERSION 2.0.4
singular.texi(,12) @setfilename singular.hlp
singular.texi(,13) @settitle Singular 2-0-4 Manual
singular.texi(,14) @c @setchapternewpage odd
singular.texi(,15) @paragraphindent 0
singular.texi(,16) @c ------------------------
singular.texi(,17) @c %**end of header
singular.texi(,18) @c ------------------------
singular.texi(,19) 
singular.texi(,20) @c --------------------- general settings --------------------
singular.texi(,26) 
singular.texi(,27) @set singularmanual 1
singular.texi(,28) @c @set namespaces 1
uname.texi(,1) @c DO not edit this file. 
uname.texi(,2) 
uname.texi(,3) @set _UNAME ix86-Linux
uname.texi(,4) @set ix86-Linux
singular.texi(,30) @c --------------------- end general setting --------------------
singular.texi(,31) 
singular.texi(,32) 
singular.texi(,33) @c --------------------- invisible Info header ------------------------
singular.texi(,37) @c --------------------- end Info invisible header --------------------
singular.texi(,38) 
singular.texi(,39) 
singular.texi(,40) @c --------------------- tex titlepage --------------------
singular.texi(,64) 
singular.texi(,65) @c print short table of contents in tex right after titlepage
singular.texi(,66) @c Detailed ToC is printed at the end of the manual
singular.texi(,67) @shortcontents
singular.texi(,68) 
singular.texi(,69) @c -----------------------Top node-----------------------------------
singular.texi(,70) @node Top, Preface, (dir), (dir)
singular.texi(,71) 
singular.texi(,80) 
singular.texi(,82) @html
singular.texi(,83) <CENTER>
singular.texi(,84) <A HREF="http://www.singular.uni-kl.de">
singular.texi(,85) <IMG SRC="singular.jpg"></A><br>
singular.texi(,86) <h3> A Computer Algebra System for Polynomial Computations </h3>
singular.texi(,87) <p></p>
singular.texi(,88) <h4>HTML User Manual for Singular Version
singular.texi(,89) @end html
singular.texi(,90) 2-0-4, October 2002
singular.texi(,91) @html
singular.texi(,92) </h4>
singular.texi(,93) </center>
singular.texi(,94) <CENTER><A HREF="http://www.uni-kl.de/"><I>University of Kaiserslautern</I></A></CENTER>
singular.texi(,95) <CENTER><A HREF="http://www.mathematik.uni-kl.de/"><I>Department of Mathematics</I></A></CENTER>
singular.texi(,96) <CENTER><A HREF="http://www.mathematik.uni-kl.de/~zca/">
singular.texi(,97) <I>Centre for Computer Algebra</I></A></CENTER><p></p>
singular.texi(,98) @end html
singular.texi(,100) 
singular.texi(,101) @menu
singular.texi(,102) * Preface::
singular.texi(,103) * Introduction::
singular.texi(,104) * General concepts::
singular.texi(,105) * Data types::
singular.texi(,106) * Functions and system variables::
singular.texi(,107) * Tricks and pitfalls::
singular.texi(,108) * Examples::
singular.texi(,109) * Polynomial data::
singular.texi(,110) * Mathematical background::
singular.texi(,111) * SINGULAR libraries::
singular.texi(,112) * Release Notes::
singular.texi(,113) * Index::
singular.texi(,114) @end menu
singular.texi(,115) 
singular.texi(,116) @c ----------------------------------------------------------------------------
singular.texi(,117) @node Preface, Introduction, Top, Top
singular.texi(,118) @chapter Preface
singular.texi(,119) @cindex Preface
COPYING.texi(,1) @comment -*-texinfo-*-
COPYING.texi(,2) @comment Id: COPYING.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
COPYING.texi(,3) @comment this file contains the copyright notice on Singular
COPYING.texi(,7) 
COPYING.texi(,8) @cindex copyright
COPYING.texi(,9) @cindex factory
COPYING.texi(,10) @cindex GMP
COPYING.texi(,11) @cindex MP
COPYING.texi(,12) @cindex readline
COPYING.texi(,13) @cindex libfac
COPYING.texi(,14) 
COPYING.texi(,15) @center @sc{Singular} version 2-0-4
COPYING.texi(,16) @center @uref{http://www.uni-kl.de/,,University of Kaiserslautern}
COPYING.texi(,17) @center @uref{http://www.mathematik.uni-kl.de/,,Department of Mathematics} and  @uref{http://www.mathematik.uni-kl.de/~zca/,,Centre for Computer Algebra}
COPYING.texi(,18) @center Authors: @uref{http://www.mathematik.uni-kl.de/~greuel,,G.-M. Greuel}, @uref{http://www.mathematik.uni-kl.de/~pfister,,G. Pfister}, @uref{http://www.mathematik.uni-kl.de/~hannes,,H. Schoenemann}
COPYING.texi(,19) 
COPYING.texi(,20) @center Copyright @copyright{} 1986-2003
COPYING.texi(,21) @sp 2
COPYING.texi(,22) @center @strong{NOTICE}
COPYING.texi(,23) 
COPYING.texi(,24) This program is free software; you can redistribute it and/or modify
COPYING.texi(,25) it under the terms of the GNU General Public License as published by
COPYING.texi(,26) the Free Software Foundation ( version 2 of the License );
COPYING.texi(,27) with the following additional restrictions (which override any conflicting
COPYING.texi(,28) restrictions in the GPL):
COPYING.texi(,29) 
COPYING.texi(,30) The following software used with @sc{Singular} have their own copyright:
COPYING.texi(,31) the omalloc library, the readline library,
COPYING.texi(,32) the Gnu Multiple Precision Library (GMP),
COPYING.texi(,33) NTL: A Library for doing Number Theory (NTL),
COPYING.texi(,34) the Multi Protocol library (MP), the
COPYING.texi(,35) Singular-Factory library, the Singular-libfac library, and,
COPYING.texi(,36) for the Windows distributions the Cygwin DLL and the Cygwin tools (Cygwin), and the
COPYING.texi(,37) XEmacs editor (XEmacs).
COPYING.texi(,38) 
COPYING.texi(,39) Their copyrights and licenses can be found in the accompanying files
COPYING.texi(,40) which are distributed along with these packages.
COPYING.texi(,41) 
COPYING.texi(,42) This program is distributed in the hope that it will be useful,
COPYING.texi(,43) but WITHOUT ANY WARRANTY; without even the implied warranty of
COPYING.texi(,44) MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
COPYING.texi(,45) GNU General Public License for more details.
COPYING.texi(,46) 
COPYING.texi(,47) You should have received a copy of the GNU General Public License
COPYING.texi(,48) along with this program; if not, write to the Free Software
COPYING.texi(,49) Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
COPYING.texi(,50) (see @uref{http://www.gnu.org/copyleft/gpl.html,,GPL})
COPYING.texi(,51) 
COPYING.texi(,52) Please send any comments or bug reports to
COPYING.texi(,53) @email{singular@@mathematik.uni-kl.de}.
COPYING.texi(,54) 
COPYING.texi(,55) Please register yourself as a @sc{Singular} user by using the
COPYING.texi(,56) registration form on the @sc{Singular} homepage
COPYING.texi(,57)               @uref{http://www.singular.uni-kl.de}.
COPYING.texi(,58) If for some reason you cannot access the registration form, you
COPYING.texi(,59) can also register by sending an email to
COPYING.texi(,60)               @email{singular@@mathematik.uni-kl.de}
COPYING.texi(,61) with subject line @code{register} and body containing the following data:
COPYING.texi(,62)      your name, email address, organisation, country and platform(s).
COPYING.texi(,63) 
COPYING.texi(,64) 
COPYING.texi(,65) If you use Singular or parts thereof in a project and/or publish
COPYING.texi(,66) results that were partly obtained using @sc{Singular}, we ask you to
COPYING.texi(,67) cite @sc{Singular} and inform us thereof -- see
COPYING.texi(,68) @uref{http://www.singular.uni-kl.de/how_to_cite.html},
COPYING.texi(,69) for information on how to cite Singular.
COPYING.texi(,70) 
COPYING.texi(,71) @heading Availability
COPYING.texi(,72) 
COPYING.texi(,73) The latest information about @sc{Singular} is always available from
COPYING.texi(,74) @uref{http://www.singular.uni-kl.de}.
COPYING.texi(,76) The program @sc{Singular} and the above mentioned parts are available via
COPYING.texi(,77) anonymous ftp through the following addresses:
COPYING.texi(,78) @table @asis
COPYING.texi(,79) @item GMP, libreadline
COPYING.texi(,80) @copyright{} Free Software Foundation
COPYING.texi(,81) @* @uref{ftp://ftp.gnu.ai.mit.edu} or its mirrors
COPYING.texi(,82) @item MP
COPYING.texi(,83) @copyright{} Gray/Kajler/Wang, Kent State University
COPYING.texi(,84) @* @uref{http://www.symbolicnet.org/areas/protocols/mp.html}
COPYING.texi(,85) @item NTL
COPYING.texi(,86) @copyright{} Victor Shoup
COPYING.texi(,87) @* @uref{ftp://www.shoup.net}
COPYING.texi(,88) @item Singular-Factory
COPYING.texi(,89) @copyright{} Greuel/Stobbe, University of Kaiserslautern:
COPYING.texi(,90) @* @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/Factory}
COPYING.texi(,91) @item Singular-libfac
COPYING.texi(,92) @copyright{}  Messollen, University of Saarbr@"ucken:
COPYING.texi(,93) @* @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/Libfac}
COPYING.texi(,94) @item @sc{Singular} binaries and sources
COPYING.texi(,95) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/} or via a
COPYING.texi(,96) WWW brow@-ser from
COPYING.texi(,97) @uref{http://www.mathematik.uni-kl.de/ftp/pub/Math/Singular/}
COPYING.texi(,98) @item Cygwin
COPYING.texi(,99) @uref{http://www.cygwin.com/}
COPYING.texi(,100) @item Xemacs
COPYING.texi(,101) @uref{http://www.xemacs.org}
COPYING.texi(,102) @end table
COPYING.texi(,104) 
COPYING.texi(,105) @heading Acknowledgements
COPYING.texi(,106) 
COPYING.texi(,107) The development of @sc{Singular} is directed and coordinated by
COPYING.texi(,108) Gert-Martin Greuel, Gerhard Pfister, and Hans
COPYING.texi(,109) Sch@"onemann.
COPYING.texi(,110) 
COPYING.texi(,111) @cindex  Greuel, Gert-Martin
COPYING.texi(,112) @cindex  Pfister, Gerhard
COPYING.texi(,113) @cindex Sch@"onemann, Hans
COPYING.texi(,114) 
COPYING.texi(,115) Currently, the @sc{Singular} team has the following members:
COPYING.texi(,116) Olaf Bachmann,
COPYING.texi(,117) Anne Fr@"ubis-Kr@"uger,
COPYING.texi(,118) Thomas Keilen,
COPYING.texi(,119) Kai Kr@"uger,
COPYING.texi(,120) Christoph Lossen,
COPYING.texi(,121) Viktor Levandovskyy,
COPYING.texi(,122) Wilfred Pohl,
COPYING.texi(,123) Mathias Schulze,
COPYING.texi(,124) Eric Westenberger,
COPYING.texi(,125) and
COPYING.texi(,126) Tim Wichmann.
COPYING.texi(,127) @cindex Bachmann, Olaf
COPYING.texi(,128) @cindex Fr@"ubis-Kr@"uger, Anne
COPYING.texi(,129) @cindex Keilen, Thomas
COPYING.texi(,130) @cindex Kr@"uger, Kai
COPYING.texi(,131) @cindex Lossen, Christoph
COPYING.texi(,132) @cindex Levandovskyy, Viktor
COPYING.texi(,133) @cindex Pohl, Wilfred
COPYING.texi(,134) @cindex Schulze, Mathias
COPYING.texi(,135) @cindex Westenberger, Eric
COPYING.texi(,136) @cindex Wichmann, Tim
COPYING.texi(,137) 
COPYING.texi(,138) Past members of the @sc{Singular} team are:
COPYING.texi(,139) Hubert Grassmann,
COPYING.texi(,140) Wolfgang Neumann,
COPYING.texi(,141) Jens Schmidt,
COPYING.texi(,142) R@"udiger Stobbe.
COPYING.texi(,143) @cindex Grassmann, Hubert
COPYING.texi(,144) @cindex Neumann, Wolfgang
COPYING.texi(,145) @cindex Schmidt, Jens
COPYING.texi(,146) @cindex Stobbe, R@"udiger
COPYING.texi(,147) 
COPYING.texi(,148) Further contributions to @sc{Singular} were made by:
COPYING.texi(,149) Thomas Bayer,
COPYING.texi(,150) Isabelle Bermejo,
COPYING.texi(,151) Stephan Endra@ss{},
COPYING.texi(,152) Jose Ignacio Farran Martin,
COPYING.texi(,153) Wolfram Decker,
COPYING.texi(,154) Philippe Gimenez,
COPYING.texi(,155) Christian Gorzel,
COPYING.texi(,156) Agnes Heydtmann,
COPYING.texi(,157) Dietmar Hillebrand,
COPYING.texi(,158) Tobias Hirsch,
COPYING.texi(,159) Martin Lamm,
COPYING.texi(,160) Bernd Martin,
COPYING.texi(,161) Michael Me@ss{}ollen,
COPYING.texi(,162) Thomas N@"u@ss{}ler,
COPYING.texi(,163) Moritz Wenk.
COPYING.texi(,164) 
COPYING.texi(,165) 
COPYING.texi(,166) We should like to acknowledge the financial support given by
COPYING.texi(,167) the Volkswagen-Stiftung,
COPYING.texi(,168) the Deutsche Forschungsgemeinschaft
COPYING.texi(,169) and the Stiftung f@"ur Innovation des Landes Rheinland-Pfalz
COPYING.texi(,170) to the @sc{Singular} project.
COPYING.texi(,171) 
singular.texi(,121) 
singular.texi(,122) @c ----------------------------------------------------------------------------
singular.texi(,123) @node Introduction, General concepts, Preface, Top
singular.texi(,124) @chapter Introduction
singular.texi(,125) @cindex Introduction
singular.texi(,126) 
start.tex(,1) @comment -*-texinfo-*-
start.tex(,2) @comment This file was generated by doc2tex.pl from start.doc
start.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT start.doc INSTEAD
start.tex(,4) @comment Id: start.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
start.tex(,5) @comment this file contains the "Introduction" chapter.
start.tex(,6) @c * wichmann: + added changes by GMG.
start.tex(,7) 
start.tex(,8) @c The following directives are necessary for proper compilation
start.tex(,9) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
start.tex(,10) @c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
start.tex(,11) @c `makeinfo' but is a great help in editing this file (emacs
start.tex(,12) @c ignores the `@ignore').
start.tex(,25) 
start.tex(,26) 
start.tex(,28) @menu
start.tex(,29) * Background::
start.tex(,30) * How to use this manual::
start.tex(,31) * Getting started::
start.tex(,32) @end menu
start.tex(,41) 
start.tex(,42) @c ------------------------------------------------------------------
start.tex(,44) @node Background, How to use this manual, Introduction, Introduction
start.tex(,49) @section Background
start.tex(,50) @cindex Background
start.tex(,51) 
start.tex(,52) @sc{Singular} is a Computer Algebra system for polynomial
start.tex(,53) computations with emphasis on the special needs of commutative
start.tex(,54) algebra, algebraic geometry, and singularity theory.
start.tex(,55) 
start.tex(,56) @sc{Singular}'s main computational objects are ideals and
start.tex(,57) modules over a large variety of baserings. The baserings are polynomial
start.tex(,58) rings or localizations thereof over a field (e.g., finite fields, the
start.tex(,59) rationals, floats, algebraic extensions, transcendental extensions) or
start.tex(,60) quotient rings with respect to an ideal.
start.tex(,61) 
start.tex(,62) @sc{Singular} features one of the fastest and most general
start.tex(,63) implementations of various algorithms for computing Groebner
start.tex(,64) resp.@: standard bases. The implementation includes Buchberger's algorithm
start.tex(,65) (if the ordering is a well ordering) and Mora's algorithm (if the
start.tex(,66) ordering is a tangent cone ordering) as special cases.  Furthermore, it
start.tex(,67) provides polynomial factorizations, resultant, characteristic set and
start.tex(,68) gcd computations, syzygy and free-resolution computations, and many more
start.tex(,69) related functionalities.
start.tex(,70) 
start.tex(,71) Based on an easy-to-use interactive shell and a C-like programming
start.tex(,72) language, @sc{Singular}'s internal functionality is augmented and
start.tex(,73) user-extendible by libraries written in the @sc{Singular} programming
start.tex(,74) language. A general and efficient implementation of communication links
start.tex(,75) allows @sc{Singular} to make its functionality available to other
start.tex(,76) programs.
start.tex(,77) 
start.tex(,78) @sc{Singular}'s development started in 1984 with an implementation of
start.tex(,79) Mora's Tangent Cone algorithm in Modula-2 on an Atari computer (K.P.
start.tex(,80) Neuendorf, G. Pfister,
start.tex(,87)  zu Berlin).  The need for a new system arose from the investigation of
start.tex(,88) mathematical problems coming from singularity theory which none of the
start.tex(,89) existing systems was able to compute.
start.tex(,90) 
start.tex(,91) In the early 1990s @sc{Singular}'s "home-town" moved to
start.tex(,92) Kaiserslautern, a general standard basis algorithm was implemented in C
start.tex(,93) and @sc{Singular} was ported to Unix, MS-DOS, Windows NT, and MacOS.
start.tex(,94) 
start.tex(,95) Continuous extensions (like polynomial factorization, gcd computations,
start.tex(,96) links) and refinements led in 1997 to the release of @sc{Singular}
start.tex(,97) version 1.0 and in 1998 to the release of version 1.2
start.tex(,98) (much faster standard and Groebner bases computations based on Hilbert series
start.tex(,99) and on improved implementations of the algorithms,
start.tex(,100) libraries for primary decomposition, ring normalization, etc.)
start.tex(,101) 
start.tex(,102) For the highlights of the new @sc{Singular} version 2-0-4 see @ref{News and changes}.
start.tex(,103) 
start.tex(,104) @c Thus, we hope to offer a useful system
start.tex(,105) @c for dealing with local and global computational aspects
start.tex(,106) @c of systems of polynomial equations.
start.tex(,107) 
start.tex(,108) @c ------------------------------------------------------------------
start.tex(,110) @node How to use this manual, Getting started, Background, Introduction
start.tex(,111) @section How to use this manual
start.tex(,112) @cindex How to use this manual
start.tex(,119) 
start.tex(,121) @subsubheading For the impatient user
start.tex(,123) In @ref{Getting started}, some simple examples explain how to use
start.tex(,124) @sc{Singular}  in a step-by-step manner.
start.tex(,125) 
start.tex(,126) @ref{Examples} should come next for real learning-by-doing or to quickly
start.tex(,127) solve some given mathematical problems without dwelling too deeply into
start.tex(,128) @sc{Singular}.
start.tex(,130) This chapter contains a lot of real-life examples and
start.tex(,131) detailed instructions and explanations on how to solve mathematical
start.tex(,132) problems using @sc{Singular}.
start.tex(,134) 
start.tex(,135) @c ------------------------------------------------------------------------
start.tex(,137) @subsubheading For the systematic user
start.tex(,138) In @ref{General concepts}, all basic concepts which are important to use
start.tex(,139) and to understand @sc{Singular} are developed.  But even for users
start.tex(,140) preferring the systematic approach it will be helpful to have a look at
start.tex(,141) the examples in @ref{Getting started}, every now and then. The topics in
start.tex(,142) the chapter are organized more or less in the order the novice user has
start.tex(,143) to deal with them.
start.tex(,144) 
start.tex(,145) @itemize @bullet
start.tex(,146) @item
start.tex(,147) In @ref{Interactive use}, and its subsections there are some words on
start.tex(,148) entering and exiting @sc{Singular}, followed by a number of other
start.tex(,149) aspects concerning the interactive user-interface.
start.tex(,150) 
start.tex(,151) @item
start.tex(,152) To do anything more than trivial integer computations, one needs to
start.tex(,153) define a basering in @sc{Singular}.  This is explained in detail in
start.tex(,154) @ref{Rings and orderings}.
start.tex(,155) 
start.tex(,156) @item
start.tex(,157) An overview of the algorithms implemented in the kernel of @sc{Singular}
start.tex(,158) is given in @ref{Implemented algorithms}.
start.tex(,159) 
start.tex(,160) @item
start.tex(,161) In @ref{The SINGULAR language}, language specific concepts are
start.tex(,162) introduced such as the notions of names and objects, data types and
start.tex(,163) conversion between them, etc.
start.tex(,164) 
start.tex(,165) @item
start.tex(,166) In @ref{Input and output}, @sc{Singular}'s mechanisms to store and
start.tex(,167) retrieve data are discussed.
start.tex(,168) 
start.tex(,169) @item
start.tex(,170) The more complex concepts of procedures and libraries as
start.tex(,171) well as tools to debug them are considered in the following sections:
start.tex(,172) @ref{Procedures}, @ref{Libraries}, and @ref{Debugging tools}.
start.tex(,173) 
start.tex(,174) @end itemize
start.tex(,175) 
start.tex(,176) @ref{Data types}, is a complete treatment for @sc{Singular}'s data types
start.tex(,177) where each section corresponds to one data type, alphabetically sorted.
start.tex(,178) For each data type, its purpose is explained, the syntax of its
start.tex(,179) declaration is given, and related operations and functions are
start.tex(,180) listed. Examples illustrate its usage.
start.tex(,181) 
start.tex(,182) @ref{Functions and system variables}, is an alphabetically ordered
start.tex(,183) reference list of all of @sc{Singular}'s functions, control structures,
start.tex(,184) and system variables.  Each entry includes a description of the syntax
start.tex(,185) and semantics of the item being explained as well as one or more
start.tex(,186) examples on how to use it.
start.tex(,187) 
start.tex(,188) @subsubheading Miscellaneous
start.tex(,189) @ref{Tricks and pitfalls}, is a loose collection of limitations and
start.tex(,190) features which may be unexpected by those who expect the
start.tex(,191) @sc{Singular} language to be an exact copy of the C programming language or of
start.tex(,192) some Computer Algebra system's languages.  But some mathematical hints are
start.tex(,193) collected there, as well.
start.tex(,194) 
start.tex(,195) @ref{Mathematical background}, introduces some of the mathematical
start.tex(,196) notions and definitions used throughout this manual.  For example, if in
start.tex(,197) doubt what exactly @sc{Singular} means by a ``negative degree reverse
start.tex(,198) lexicographical ordering'' one should refer to this chapter.
start.tex(,199) 
start.tex(,200) @ref{SINGULAR libraries}, lists the
start.tex(,201) libraries which come with @sc{Singular} and the functions contained in
start.tex(,202) them, respectively.
start.tex(,204) @c ------------------------------------------------------------------------
start.tex(,205) 
start.tex(,206) @subsubheading Typographical conventions
start.tex(,207) Throughout this manual, the following typographical conventions are
start.tex(,208) adopted:
start.tex(,209) 
start.tex(,210) @itemize @bullet
start.tex(,211) @item
start.tex(,212) text in @code{typewriter} denotes @sc{Singular} input and output as well
start.tex(,213) as reserved names:
start.tex(,214) 
start.tex(,215) @itemize @asis
start.tex(,216) @item The basering can be set using the command @code{setring}.
start.tex(,217) @end itemize
start.tex(,218) 
start.tex(,219) @item
start.tex(,220) the arrow @expansion{} denotes @sc{Singular} output:
start.tex(,221) 
start.tex(,222) @itemize @asis
start.tex(,223) @item @code{poly p=x+y+z;}
start.tex(,224) @item @code{p*p;}
start.tex(,225) @item @code{@expansion{} x2+2xy+y2+2xz+2yz+z2}
start.tex(,226) @end itemize
start.tex(,227) 
start.tex(,228) @item
start.tex(,229) square brackets are used to denote parts of syntax descriptions which
start.tex(,230) are optional:
start.tex(,231) 
start.tex(,232) @itemize @asis
start.tex(,233) [optional_text] required_text
start.tex(,234) @end itemize
start.tex(,235) 
start.tex(,236) @item
start.tex(,237) keys are denoted using typewriter, for example:
start.tex(,238) 
start.tex(,239) @itemize @asis
start.tex(,240) @item @code{N} (press the key @code{N} to get to the next node in help
start.tex(,241) mode)
start.tex(,242) @item @code{RETURN} (press @code{RETURN} to finish an input line)
start.tex(,243) @item @code{CTRL-P} (press control key together with the key @code{P} to
start.tex(,244) get the previous input line)
start.tex(,245) @end itemize
start.tex(,246) 
start.tex(,247) @end itemize
start.tex(,248) 
start.tex(,249) @c ------------------------------------------------------------------
start.tex(,251) @node Getting started,  , How to use this manual, Introduction
start.tex(,252) @section Getting started
start.tex(,258) @cindex Getting started
start.tex(,259) 
start.tex(,260) @sc{Singular} is a special purpose system for polynomial
start.tex(,261) computations. Hence, most of the powerful computations in @sc{Singular}
start.tex(,262) require the prior definition of a ring. Most important rings are
start.tex(,263) polynomial rings over a field, localizations hereof, or quotient rings of
start.tex(,264) such rings modulo an ideal. However, some simple computations with
start.tex(,265) integers (machine integers of limited size) and manipulations of strings
start.tex(,266) are available without a ring.
start.tex(,267) 
start.tex(,268) @menu
start.tex(,269) * First steps::
start.tex(,270) * Rings and standard bases::
start.tex(,271) * Procedures and libraries::
start.tex(,272) * Change of rings::
start.tex(,273) * Modules and their annihilator::
start.tex(,274) * Resolution::
start.tex(,275) @end menu
start.tex(,276) 
start.tex(,277) @c ------------------------------------------------------------------
start.tex(,278) @node First steps, Rings and standard bases, Getting started, Getting started
start.tex(,280) @subsection First steps
start.tex(,285) @cindex First steps
start.tex(,286) 
start.tex(,287) Once @sc{Singular} is started, it awaits an input after the prompt
start.tex(,288) @code{>}.  Every statement has to be terminated by @code{;} .
start.tex(,289) 
start.tex(,290) @smallexample
start.tex(,291) 37+5;
start.tex(,292) @expansion{} 42
start.tex(,293) @end smallexample
start.tex(,294) 
start.tex(,295) All objects have a type, e.g., integer variables are defined by
start.tex(,296) the word @code{int}. An assignment is done by the symbol @code{=} .
start.tex(,297) 
start.tex(,298) @smallexample
start.tex(,299) int k = 2;
start.tex(,300) @end smallexample
start.tex(,301) 
start.tex(,302) @noindent Test for equality resp.@: inequality is done using @code{==}
start.tex(,303) resp.@: @code{!=} (or @code{<>}), where @code{0} represents the boolean
start.tex(,304) value FALSE, any other value represents TRUE.
start.tex(,305) 
start.tex(,306) @smallexample
start.tex(,307) k == 2;
start.tex(,308) @expansion{} 1
start.tex(,309) k != 2;
start.tex(,310) @expansion{} 0
start.tex(,311) @end smallexample
start.tex(,312) 
start.tex(,313) @noindent The value of an object is displayed by simply typing its name.
start.tex(,314) 
start.tex(,315) @smallexample
start.tex(,316) k;
start.tex(,317) @expansion{} 2
start.tex(,318) @end smallexample
start.tex(,319) 
start.tex(,320) @noindent On the other hand the output is suppressed if an assignment
start.tex(,321) is made.
start.tex(,322) 
start.tex(,323) @smallexample
start.tex(,324) int j;
start.tex(,325) j = k+1;
start.tex(,326) @end smallexample
start.tex(,327) 
start.tex(,328) @noindent The last displayed (!) result is always available
start.tex(,329) with the special symbol @code{_} .
start.tex(,330) 
start.tex(,331) @smallexample
start.tex(,332) 2*_;   // the value from k displayed above
start.tex(,333) @expansion{} 4
start.tex(,334) @end smallexample
start.tex(,335) 
start.tex(,336) Text starting with @code{//} denotes a comment and is ignored in
start.tex(,337) calculations, as seen in the previous example. Furthermore @sc{Singular}
start.tex(,338) maintains a history of the previous lines of input, which may be accessed by
start.tex(,339) @code{CTRL-P} (previous) and @code{CTRL-N} (next) or the arrows on the
start.tex(,340) keyboard. Note that the history is not available on Macintosh systems.
start.tex(,341) 
start.tex(,342) The whole manual is available online by typing the command @code{help;} .
start.tex(,343) Explanation on single topics, e.g., on @code{intmat}, which defines a
start.tex(,344) matrix of integers, are obtained by
start.tex(,345) 
start.tex(,346) @smallexample
start.tex(,347) help intmat;
start.tex(,348) @end smallexample
start.tex(,349) 
start.tex(,351) @noindent This shows the text of @ref{intmat}, in the printed manual.
start.tex(,356) 
start.tex(,357) Next, we define a
start.tex(,364)  matrix of integers and initialize it with some values, row by row
start.tex(,365) from left to right:
start.tex(,366) 
start.tex(,367) @smallexample
start.tex(,368) intmat m[3][3] = 1,2,3,4,5,6,7,8,9;
start.tex(,369) @end smallexample
start.tex(,370) 
start.tex(,371) @noindent A single matrix entry may be selected and changed using
start.tex(,372) square brackets @code{[} and @code{]}.
start.tex(,373) 
start.tex(,374) @smallexample
start.tex(,375) m[1,2]=0;
start.tex(,376) m;
start.tex(,377) @expansion{} 1,0,3,
start.tex(,378) @expansion{} 4,5,6,
start.tex(,379) @expansion{} 7,8,9
start.tex(,380) @end smallexample
start.tex(,381) 
start.tex(,382) To calculate the trace of this matrix, we use a @code{for} loop. The
start.tex(,383) curly brackets @code{@{} and @code{@}} denote the beginning resp.@:
start.tex(,384) end of a block. If you define a variable without giving an initial
start.tex(,385) value, as the variable @code{tr} in the example below, @sc{Singular}
start.tex(,386) assigns a default value for the specific type. In this case, the default
start.tex(,387) value for integers is @code{0}. Note that the integer variable @code{j}
start.tex(,388) has already been defined above.
start.tex(,389) 
start.tex(,390) @smallexample
start.tex(,391) int tr;
start.tex(,392) for ( j=1; j <= 3; j++ ) @{ tr=tr + m[j,j]; @}
start.tex(,393) tr;
start.tex(,394) @expansion{} 15
start.tex(,395) @end smallexample
start.tex(,396) 
start.tex(,397) Variables of type string can also be defined and used without a ring
start.tex(,398) being active. Strings are delimited by @code{"} (double quotes). They
start.tex(,399) may be used to comment the output of a computation or to give it a nice
start.tex(,400) format. If a string contains valid @sc{Singular} commands, it can be
start.tex(,401) executed using the function @code{execute}. The result is the same as if
start.tex(,402) the commands would have been written on the command line. This feature
start.tex(,403) is especially useful to define new rings inside procedures.
start.tex(,404) 
start.tex(,405) @smallexample
start.tex(,406) "example for strings:";
start.tex(,407) @expansion{} example for strings:
start.tex(,408) string s="The element of m ";
start.tex(,409) s = s + "at position [2,3] is:";  // concatenation of strings by +
start.tex(,410) s , m[2,3] , ".";
start.tex(,411) @expansion{} The element of m at position [2,3] is: 6 .
start.tex(,412) s="m[2,1]=0; m;";
start.tex(,413) execute(s);
start.tex(,414) @expansion{} 1,0,3,
start.tex(,415) @expansion{} 0,5,6,
start.tex(,416) @expansion{} 7,8,9
start.tex(,417) @end smallexample
start.tex(,418) 
start.tex(,419) This example shows that expressions can be separated by @code{,} (comma)
start.tex(,420) giving a list of expressions. @sc{Singular} evaluates each expression in
start.tex(,421) this list and prints all results separated by spaces.
start.tex(,422) 
start.tex(,423) @c ------------------------------------------------------------------
start.tex(,424) @node Rings and standard bases, Procedures and libraries, First steps, Getting started
start.tex(,426) @subsection Rings and standard bases
start.tex(,431) @cindex Rings and standard bases
start.tex(,432) 
start.tex(,433) To calculate with objects as ideals, matrices, modules, and polynomial
start.tex(,434) vectors, a ring has to be defined first.
start.tex(,435) 
start.tex(,436) @smallexample
start.tex(,437) ring r = 0,(x,y,z),dp;
start.tex(,438) @end smallexample
start.tex(,439) 
start.tex(,440) The definition of a ring consists of three parts: the first part
start.tex(,441) determines the ground field, the second part determines the names of the
start.tex(,442) ring variables, and the third part determines the monomial ordering to
start.tex(,443) be used. So the example above declares a polynomial ring called @code{r}
start.tex(,444) with a ground field of characteristic 
start.tex(,451)  (i.e., the rational
start.tex(,452) numbers) and ring variables called @code{x}, @code{y}, and @code{z}. The
start.tex(,453) @code{dp} at the end means that the degree reverse lexicographical
start.tex(,454) ordering should be used.
start.tex(,455) 
start.tex(,456) Other ring declarations:
start.tex(,457) 
start.tex(,458) @table @code
start.tex(,459) @item ring r1=32003,(x,y,z),dp;
start.tex(,460) characteristic 32003, variables @code{x}, @code{y}, and @code{z} and
start.tex(,461) ordering @code{dp}.
start.tex(,462) 
start.tex(,463) @item ring r2=32003,(a,b,c,d),lp;
start.tex(,464) characteristic 32003, variable names @code{a}, @code{b}, @code{c},
start.tex(,465) @code{d} and lexicographical ordering.
start.tex(,466) 
start.tex(,467) @item ring r3=7,(x(1..10)),ds;
start.tex(,468) characteristic 7, variable names @code{x(1)},@dots{},@code{x(10)}, negative
start.tex(,469) degree reverse lexicographical ordering (@code{ds}).
start.tex(,470) 
start.tex(,471) @item ring r4=(0,a),(mu,nu),lp;
start.tex(,472) transcendental extension of 
start.tex(,479)  by 
start.tex(,486) , variable names
start.tex(,487) @code{mu} and @code{nu}.
start.tex(,488) 
start.tex(,489) @item ring r5=real,(a,b),lp;
start.tex(,490) floating point numbers (single machine precision),
start.tex(,491) variable names @code{a} and @code{b}.
start.tex(,492) 
start.tex(,493) @item ring r6=(real,50),(a,b),lp;
start.tex(,494) floating point numbers with extended precision of 50 digits,
start.tex(,495) variable names @code{a} and @code{b}.
start.tex(,496) 
start.tex(,497) @item ring r7=(complex,50,i),(a,b),lp;
start.tex(,498) complex floating point numbers with extended precision of 50 digits
start.tex(,499) and imaginary unit @code{i},
start.tex(,500) variable names @code{a} and @code{b}.
start.tex(,501) @end table
start.tex(,502) 
start.tex(,503) @c Another valid characteristic would be, for example, a prime number less
start.tex(,504) @c or equal to 32003. The name of the ring variables may be any
start.tex(,505) @c valid @sc{Singular} name. Even indexed names are allowed, so
start.tex(,506) @c @code{x(1..10)} specifies the ring variables @code{x(1)}, @dots{},
start.tex(,507) @c @code{x(10)}. @sc{Singular} offers the possibility to calculate with any
start.tex(,508) @c monomial ordering, some orderings are predefined with special names like
start.tex(,509) @c @code{dp} in the example above. Another important example is the
start.tex(,510) @c lexicographical ordering called @code{lp}.
start.tex(,511) @c
start.tex(,512) Typing the name of a ring prints its definition. The example below
start.tex(,513) shows that the default ring in @sc{Singular} is 
start.tex(,520) 
start.tex(,521) with degree reverse lexicographical ordering:
start.tex(,522) 
start.tex(,523) @smallexample
start.tex(,524) @c computed example Rings_and_standard_bases start.doc:494 
start.tex(,525) ring r8;
start.tex(,526) r8;
start.tex(,527) @expansion{} //   characteristic : 32003
start.tex(,528) @expansion{} //   number of vars : 3
start.tex(,529) @expansion{} //        block   1 : ordering dp
start.tex(,530) @expansion{} //                  : names    x y z 
start.tex(,531) @expansion{} //        block   2 : ordering C
start.tex(,532) @c end example Rings_and_standard_bases start.doc:494
start.tex(,533) @end smallexample
start.tex(,534) 
start.tex(,535) Defining a ring makes this ring the current active basering, so each
start.tex(,536) ring definition above switches to a new basering. The concept of rings
start.tex(,537) in @sc{Singular} is discussed in detail in
start.tex(,539) @ref{Rings and orderings}.
start.tex(,544) 
start.tex(,545) The basering is now @code{r8}. Since we want to calculate in the ring
start.tex(,546) @code{r}, which we defined first, we have to switch back to it. This can
start.tex(,547) be done using the function @code{setring}:
start.tex(,548) 
start.tex(,549) @smallexample
start.tex(,550) setring r;
start.tex(,551) @end smallexample
start.tex(,552) 
start.tex(,553) Once a ring is active, we can define polynomials. A monomial, say
start.tex(,560) may be entered in two ways: either using the power operator @code{^},
start.tex(,561) saying @code{x^3}, or in short-hand notation without operator, saying
start.tex(,562) @code{x3}. Note that the short-hand notation is forbidden if the name
start.tex(,563) of the ring variable consists of more than one character. Note, that
start.tex(,564) @sc{Singular} always expands brackets and automatically sorts the terms
start.tex(,565) with respect to the monomial ordering of the basering.
start.tex(,566) 
start.tex(,567) @smallexample
start.tex(,568) poly f =  x3+y3+(x-y)*x2y2+z2;
start.tex(,569) f;
start.tex(,570) @expansion{} x3y2-x2y3+x3+y3+z2
start.tex(,571) @end smallexample
start.tex(,572) 
start.tex(,573) The command @code{size} determines in general the number of ''single
start.tex(,574) entries`` in an object. In particular, for polynomials, @code{size}
start.tex(,575) determines the number of monomials.
start.tex(,576) 
start.tex(,577) @smallexample
start.tex(,578) size(f);
start.tex(,579) @expansion{} 5
start.tex(,580) @end smallexample
start.tex(,581) 
start.tex(,582) A natural question is to ask if a point, e.g., @code{(x,y,z)=(1,2,0)}, lies
start.tex(,583) on the variety defined by the polynomials @code{f} and @code{g}. For
start.tex(,584) this we define an ideal generated by both polynomials, substitute the
start.tex(,585) coordinates of the point for the ring variables, and check if the result
start.tex(,586) is zero:
start.tex(,587) 
start.tex(,588) @smallexample
start.tex(,589) poly g =  f^2 *(2x-y);
start.tex(,590) ideal I = f,g;
start.tex(,591) ideal J = subst(I,var(1),1);
start.tex(,592) J = subst(J,var(2),2);
start.tex(,593) J = subst(J,var(3),0);
start.tex(,594) J;
start.tex(,595) @expansion{} J[1]=5
start.tex(,596) @expansion{} J[2]=0
start.tex(,597) @end smallexample
start.tex(,598) 
start.tex(,599) @noindent Since the result is not zero, the point @code{(1,2,0)} does
start.tex(,600) not lie on the variety @code{V(f,g)}.
start.tex(,601) 
start.tex(,602) Another question is to decide whether some function vanishes on a
start.tex(,603) variety, or in algebraic terms if a polynomial is contained in a given
start.tex(,604) ideal. For this we calculate a standard basis using the command
start.tex(,605) @code{groebner} and afterwards reduce the polynomial with respect to
start.tex(,606) this standard basis.
start.tex(,607) 
start.tex(,608) @smallexample
start.tex(,609) ideal sI = groebner(f);
start.tex(,610) reduce(g,sI);
start.tex(,611) @expansion{} 0
start.tex(,612) @end smallexample
start.tex(,613) 
start.tex(,614) @noindent As the result is @code{0} the polynomial @code{g} belongs to the
start.tex(,615) ideal defined by @code{f}.
start.tex(,616) 
start.tex(,617) The function @code{groebner}, like many other functions in
start.tex(,618) @sc{Singular}, prints a protocol during calculations, if desired. The
start.tex(,619) command @code{option(prot);} enables protocolling whereas
start.tex(,620) @code{option(noprot);} turns it off.
start.tex(,622) @ref{option}, explains the meaning
start.tex(,623) of the different symbols printed during calculations.
start.tex(,625) 
start.tex(,626) The command @code{kbase} calculates a basis of the polynomial ring
start.tex(,627) modulo an ideal, if the quotient ring is finite dimensional.
start.tex(,628) As an example we calculate the Milnor number of a
start.tex(,629) hypersurface singularity in the global and local case. This is the
start.tex(,630) vector space dimension of the polynomial ring modulo the Jacobian ideal
start.tex(,631) in the global case resp.@: of the power series ring modulo the Jacobian
start.tex(,632) ideal in the local case. @xref{Critical points}, for a detailed
start.tex(,633) explanation.
start.tex(,634) 
start.tex(,635) The Jacobian ideal is obtained with the command @code{jacob}.
start.tex(,636) 
start.tex(,637) @smallexample
start.tex(,638) ideal J = jacob(f);
start.tex(,639) @expansion{} // ** redefining J **
start.tex(,640) J;
start.tex(,641) @expansion{} J[1]=3x2y2-2xy3+3x2
start.tex(,642) @expansion{} J[2]=2x3y-3x2y2+3y2
start.tex(,643) @expansion{} J[3]=2z
start.tex(,644) @end smallexample
start.tex(,645) 
start.tex(,646) @noindent @sc{Singular} prints the line @code{// ** redefining J
start.tex(,647) **}. This indicates that we have previously defined a variable with name
start.tex(,648) @code{J} of type ideal (see above).
start.tex(,649) 
start.tex(,650) To obtain a representing set of the quotient vector space we first
start.tex(,651) calculate a standard basis, then we apply the function @code{kbase} to
start.tex(,652) this standard basis.
start.tex(,653) 
start.tex(,654) @smallexample
start.tex(,655) J = groebner(J);
start.tex(,656) ideal K = kbase(J);
start.tex(,657) K;
start.tex(,658) @expansion{} K[1]=y4
start.tex(,659) @expansion{} K[2]=xy3
start.tex(,660) @expansion{} K[3]=y3
start.tex(,661) @expansion{} K[4]=xy2
start.tex(,662) @expansion{} K[5]=y2
start.tex(,663) @expansion{} K[6]=x2y
start.tex(,664) @expansion{} K[7]=xy
start.tex(,665) @expansion{} K[8]=y
start.tex(,666) @expansion{} K[9]=x3
start.tex(,667) @expansion{} K[10]=x2
start.tex(,668) @expansion{} K[11]=x
start.tex(,669) @expansion{} K[12]=1
start.tex(,670) @end smallexample
start.tex(,671) 
start.tex(,672) @noindent Then
start.tex(,673) 
start.tex(,674) @smallexample
start.tex(,675) size(K);
start.tex(,676) @expansion{} 12
start.tex(,677) @end smallexample
start.tex(,678) 
start.tex(,679) @noindent gives the desired vector space dimension
start.tex(,686) As in @sc{Singular} the functions may take the input directly from
start.tex(,687) earlier calculations, the whole sequence of commands may be written
start.tex(,688) in one single statement.
start.tex(,689) 
start.tex(,690) @smallexample
start.tex(,691) size(kbase(groebner(jacob(f))));
start.tex(,692) @expansion{} 12
start.tex(,693) @end smallexample
start.tex(,694) 
start.tex(,695) When we are not interested in a basis of the quotient vector space, but
start.tex(,696) only in the resulting dimension we may even use the command @code{vdim}
start.tex(,697) and write:
start.tex(,698) 
start.tex(,699) @smallexample
start.tex(,700) vdim(groebner(jacob(f)));
start.tex(,701) @expansion{} 12
start.tex(,702) @end smallexample
start.tex(,703) 
start.tex(,704) @c ------------------------------------------------------------------
start.tex(,705) @node Procedures and libraries, Change of rings, Rings and standard bases, Getting started
start.tex(,707) @subsection Procedures and libraries
start.tex(,712) @cindex Procedures and libraries
start.tex(,713) 
start.tex(,714) @sc{Singular} offers a comfortable programming language, with a syntax
start.tex(,715) close to C. So it is possible to define procedures which collect several
start.tex(,716) commands to a new one. Procedures are defined with the keyword
start.tex(,717) @code{proc} followed by a name and an optional parameter list with
start.tex(,718) specified types.  Finally, a procedure may return values using the
start.tex(,719) command @code{return}.
start.tex(,720) 
start.tex(,721) Define the following procedure called @code{Milnor}:
start.tex(,722) 
start.tex(,723) @smallexample
start.tex(,724) proc Milnor (poly h)
start.tex(,725) @{
start.tex(,726)   return(vdim(groebner(jacob(h))));
start.tex(,727) @}
start.tex(,728) @end smallexample
start.tex(,729) 
start.tex(,730) Note: if you have entered the first line of the procedure and pressed
start.tex(,731) @code{RETURN}, @sc{Singular} prints the prompt @code{.} (dot) instead of
start.tex(,732) the usual prompt @code{>} . This shows that the input is incomplete and
start.tex(,733) @sc{Singular} expects more lines. After typing the closing curly
start.tex(,734) bracket, @sc{Singular} prints the usual prompt indicating that the input
start.tex(,735) is now complete.
start.tex(,736) 
start.tex(,737) @noindent Then call the procedure:
start.tex(,738) 
start.tex(,739) @smallexample
start.tex(,740) Milnor(f);
start.tex(,741) @expansion{} 12
start.tex(,742) @end smallexample
start.tex(,743) 
start.tex(,744) @noindent Note that the result may depend on the basering as we will
start.tex(,745) see in the next chapter.
start.tex(,746) 
start.tex(,747) The distribution of  @sc{Singular} contains  several libraries, each of
start.tex(,748) which is a collection of useful
start.tex(,749) procedures based on the kernel commands, which extend the functionality
start.tex(,750) of @sc{Singular}. The command @code{help "all.lib";} lists all libraries
start.tex(,751) together with a one-line explanation.
start.tex(,752) @c The command @code{help}
start.tex(,753) @c library_name@code{;} lists all procedures of the library, @code{help}
start.tex(,754) @c proc_name@code{;} shows an explanation of the procedure after the
start.tex(,755) @c library has been loaded. The command @code{LIB "all.lib";} loads all
start.tex(,756) @c libraries.
start.tex(,757) 
start.tex(,758) One of these libraries is @code{sing.lib} which already contains a
start.tex(,759) procedure called @code{milnor} to calculate the Milnor number not only
start.tex(,760) for hypersurfaces but more generally for complete intersection
start.tex(,761) singularities.
start.tex(,762) 
start.tex(,763) Libraries are loaded with the command @code{LIB}. Some additional
start.tex(,764) information during the process of loading is displayed on the screen,
start.tex(,765) which we omit here.
start.tex(,766) 
start.tex(,767) @smallexample
start.tex(,768) LIB "sing.lib";
start.tex(,769) @end smallexample
start.tex(,770) 
start.tex(,771) As all input in @sc{Singular} is case sensitive, there is no conflict with
start.tex(,772) the previously  defined procedure @code{Milnor}, but the result is the same.
start.tex(,773) 
start.tex(,774) @smallexample
start.tex(,775) milnor(f);
start.tex(,776) @expansion{} 12
start.tex(,777) @end smallexample
start.tex(,778) 
start.tex(,779) The procedures in a library have a help part
start.tex(,780) which is displayed by typing
start.tex(,781) 
start.tex(,782) @smallexample
start.tex(,783) help milnor;
start.tex(,784) @c @expansion{} // proc milnor from lib sing.lib
start.tex(,785) @c @expansion{} proc milnor (ideal i)
start.tex(,786) @c @expansion{} USAGE:   milnor(i); i ideal or poly
start.tex(,787) @c @expansion{} RETURN:  Milnor number of i, if i is ICIS (isolated complete intersection
start.tex(,788) @c @expansion{}          singularity) in generic form, resp. -1 if not
start.tex(,789) @c @expansion{} NOTE:    use proc nf_icis to put generators in generic form
start.tex(,790) @c @expansion{}          printlevel >=0: display comments (default)
start.tex(,791) @c @expansion{} EXAMPLE: example milnor; shows an example
start.tex(,792) @c @expansion{}
start.tex(,793) @end smallexample
start.tex(,794) 
start.tex(,795) @noindent as well as some examples, which are executed by
start.tex(,796) 
start.tex(,797) @smallexample
start.tex(,798) example milnor;
start.tex(,799) @c @expansion{} // proc milnor from lib sing.lib
start.tex(,800) @c @expansion{} EXAMPLE:
start.tex(,801) @c @expansion{}    int p      = printlevel;
start.tex(,802) @c @expansion{}    printlevel = 1;
start.tex(,803) @c @expansion{}    ring r     = 32003,(x,y,z),ds;
start.tex(,804) @c @expansion{}    ideal j    = x5+y6+z6,x2+2y2+3z2,xyz+yx;
start.tex(,805) @c @expansion{}    milnor(j);
start.tex(,806) @c @expansion{} //sequence of discriminant numbers: 100,149,70
start.tex(,807) @c @expansion{} 21
start.tex(,808) @c @expansion{}    poly f     = x7+y7+(x-y)^2*x2y2+z2;
start.tex(,809) @c @expansion{}    milnor(f);
start.tex(,810) @c @expansion{} 28
start.tex(,811) @c @expansion{}    printlevel = p;
start.tex(,812) @c @expansion{}
start.tex(,813) @end smallexample
start.tex(,814) 
start.tex(,815) @noindent Likewise, the library itself has a help part, to show a list of
start.tex(,816) all the functions
start.tex(,817) available for the user which are contained in the library.
start.tex(,818) 
start.tex(,819) @smallexample
start.tex(,820) help sing.lib;
start.tex(,821) @end smallexample
start.tex(,822) 
start.tex(,823) @noindent The output of the help commands is omitted here.
start.tex(,824) 
start.tex(,825) @c ------------------------------------------------------------------
start.tex(,826) @node Change of rings, Modules and their annihilator, Procedures and libraries, Getting started
start.tex(,828) @subsection Change of rings
start.tex(,833) @cindex Change of rings
start.tex(,834) 
start.tex(,835) To calculate the local Milnor number we have to do the calculation with the
start.tex(,836) same commands in a ring with local ordering.
start.tex(,838) Define the localization of the polynomial ring at the origin
start.tex(,839) (@pxref{Polynomial data}, and @ref{Mathematical background}).
start.tex(,844) 
start.tex(,845) @smallexample
start.tex(,846) ring rl = 0,(x,y,z),ds;
start.tex(,847) @end smallexample
start.tex(,848) 
start.tex(,849) This ordering determines the standard basis which will be calculated.
start.tex(,850) Fetch the polynomial defined in the ring @code{r} into this new ring,
start.tex(,851) thus avoiding retyping the input.
start.tex(,852) 
start.tex(,853) @smallexample
start.tex(,854) poly f = fetch(r,f);
start.tex(,855) f;
start.tex(,856) @expansion{} z2+x3+y3+x3y2-x2y3
start.tex(,857) @end smallexample
start.tex(,858) 
start.tex(,859) @noindent Instead of @code{fetch} we can use the function @code{imap}
start.tex(,860) which is more general but less efficient.
start.tex(,862) The most general way to fetch data from one ring to another is to use maps,
start.tex(,863) this will be explained in @ref{map}.
start.tex(,868) 
start.tex(,869) In this ring the terms are ordered by increasing exponents. The local Milnor
start.tex(,870) number is now
start.tex(,871) 
start.tex(,872) @smallexample
start.tex(,873) Milnor(f);
start.tex(,874) @expansion{} 4
start.tex(,875) @end smallexample
start.tex(,876) 
start.tex(,877) This shows that @code{f} has outside the origin in affine 3-space
start.tex(,878) singularities with local Milnor number adding up to
start.tex(,885) Using global and local orderings as above is a convenient way to check
start.tex(,886) whether a variety has singularities outside the origin.
start.tex(,887) 
start.tex(,888) The command @code{jacob} applied twice gives the Hessian of @code{f}, a
start.tex(,889) 3x3 - matrix.
start.tex(,890) 
start.tex(,891) @smallexample
start.tex(,892) matrix H = jacob(jacob(f));
start.tex(,893) H;
start.tex(,894) @expansion{} H[1,1]=6x+6xy2-2y3
start.tex(,895) @expansion{} H[1,2]=6x2y-6xy2
start.tex(,896) @expansion{} H[1,3]=0
start.tex(,897) @expansion{} H[2,1]=6x2y-6xy2
start.tex(,898) @expansion{} H[2,2]=6y+2x3-6x2y
start.tex(,899) @expansion{} H[2,3]=0
start.tex(,900) @expansion{} H[3,1]=0
start.tex(,901) @expansion{} H[3,2]=0
start.tex(,902) @expansion{} H[3,3]=2
start.tex(,903) @end smallexample
start.tex(,904) 
start.tex(,905) The @code{print} command displays the matrix in a nicer form.
start.tex(,906) 
start.tex(,907) @smallexample
start.tex(,908) print(H);
start.tex(,909) @expansion{} 6x+6xy2-2y3,6x2y-6xy2,  0,
start.tex(,910) @expansion{} 6x2y-6xy2,  6y+2x3-6x2y,0,
start.tex(,911) @expansion{} 0,          0,          2
start.tex(,912) @end smallexample
start.tex(,913) 
start.tex(,914) We may calculate the determinant and (the ideal generated by all) minors of
start.tex(,915) a given size.
start.tex(,916) 
start.tex(,917) @smallexample
start.tex(,918) det(H);
start.tex(,919) @expansion{} 72xy+24x4-72x3y+72xy3-24y4-48x4y2+64x3y3-48x2y4
start.tex(,920) minor(H,1);  // the 1x1 - minors
start.tex(,921) @expansion{} _[1]=2
start.tex(,922) @expansion{} _[2]=6y+2x3-6x2y
start.tex(,923) @expansion{} _[3]=6x2y-6xy2
start.tex(,924) @expansion{} _[4]=6x2y-6xy2
start.tex(,925) @expansion{} _[5]=6x+6xy2-2y3
start.tex(,926) @end smallexample
start.tex(,927) 
start.tex(,928) The algorithm of the standard basis computations may be
start.tex(,929) affected by the command @code{option}. For example, a reduced standard
start.tex(,930) basis of the ideal generated by the
start.tex(,937)  of H  is obtained in the following way:
start.tex(,938) @smallexample
start.tex(,939) option(redSB);
start.tex(,940) groebner(minor(H,1));
start.tex(,941) @expansion{} _[1]=1
start.tex(,942) @end smallexample
start.tex(,943) 
start.tex(,944) This shows that 1 is contained in the ideal of the
start.tex(,951) hence the corresponding variety is empty.
start.tex(,952) @c Coming back to some mathematical considerations, we study the problem how
start.tex(,953) @c to calculate some ....
start.tex(,954) 
start.tex(,955) @c ------------------------------------------------------------------
start.tex(,956) @c REMEMBER TO EDIT NEXT AND PREVIOUS NODE IF YOU UNCOMMENT THIS NODE!
start.tex(,957) @c @node Maps and elimination, Modules and their annihilator, Change of rings, Getting started
start.tex(,958) @c @subsection Maps and elimination
start.tex(,959) @c @cindex Maps and elimination
start.tex(,960) 
start.tex(,961) @c ------------------------------------------------------------------
start.tex(,962) @node Modules and their annihilator, Resolution, Change of rings, Getting started
start.tex(,964) @subsection Modules and their annihilator
start.tex(,969) @cindex Modules and and their annihilator
start.tex(,970) 
start.tex(,971) Now we shall give three more advanced examples.
start.tex(,972) 
start.tex(,973) @sc{Singular} is able to handle modules over all the rings,
start.tex(,974) which can be defined as a basering. A free module of rank @code{n}
start.tex(,975) is defined as follows:
start.tex(,976) 
start.tex(,977) @smallexample
start.tex(,978) ring rr;
start.tex(,979) int n = 4;
start.tex(,980) freemodule(4);
start.tex(,981) @expansion{} _[1]=gen(1)
start.tex(,982) @expansion{} _[2]=gen(2)
start.tex(,983) @expansion{} _[3]=gen(3)
start.tex(,984) @expansion{} _[4]=gen(4)
start.tex(,985) typeof(_);
start.tex(,986) @expansion{} module
start.tex(,987) print(freemodule(4));
start.tex(,988) @expansion{} 1,0,0,0,
start.tex(,989) @expansion{} 0,1,0,0,
start.tex(,990) @expansion{} 0,0,1,0,
start.tex(,991) @expansion{} 0,0,0,1
start.tex(,992) @end smallexample
start.tex(,993) 
start.tex(,994) To define a module, we give a list of vectors generating a submodule of
start.tex(,995) a free module. Then this set of vectors may be identified with the
start.tex(,996) columns of a matrix.  For that reason in @sc{Singular} matrices and
start.tex(,997) modules may be interchanged. However, the representation is different
start.tex(,998) (modules may be considered as sparse represented matrices).
start.tex(,999) 
start.tex(,1000) @smallexample
start.tex(,1001) ring r =0,(x,y,z),dp;
start.tex(,1002) module MD = [x,0,x],[y,z,-y],[0,z,-2y];
start.tex(,1003) matrix MM = MD;
start.tex(,1004) print(MM);
start.tex(,1005) @expansion{} x,y,0,
start.tex(,1006) @expansion{} 0,z,z,
start.tex(,1007) @expansion{} x,-y,-2y
start.tex(,1008) @end smallexample
start.tex(,1009) 
start.tex(,1010) However the submodule 
start.tex(,1017)  may also be considered as the module
start.tex(,1018) of relations of the factor module
start.tex(,1025) In this way, @sc{Singular} can treat arbitrary finitely generated modules
start.tex(,1026) over the
start.tex(,1028) basering (@pxref{Representation of mathematical objects}).
start.tex(,1033) 
start.tex(,1034) In order to get the module of relations of 
start.tex(,1041) ,
start.tex(,1042) we use the command @code{syz}.
start.tex(,1043) 
start.tex(,1044) @smallexample
start.tex(,1045) syz(MD);
start.tex(,1046) @expansion{} _[1]=x*gen(3)-x*gen(2)+y*gen(1)
start.tex(,1047) @end smallexample
start.tex(,1048) 
start.tex(,1049) We want to calculate, as an application, the annihilator of a given module.
start.tex(,1050) Let
start.tex(,1057) where U is our defining module of relations for the module
start.tex(,1064) 
start.tex(,1065) @smallexample
start.tex(,1066) module U = [z3,xy2,x3],[yz2,1,xy5z+z3],[y2z,0,x3],[xyz+x2,y2,0],[xyz,x2y,1];
start.tex(,1067) @end smallexample
start.tex(,1068) 
start.tex(,1069) Then, by definition, the annihilator of M is the ideal
start.tex(,1076) which is by the description of M the same as
start.tex(,1083) Hence we have to calculate the quotient
start.tex(,1090) The rank of the free module is determined by the choice of U and is the
start.tex(,1091) number of rows of the corresponding matrix. This may be determined by
start.tex(,1092) the function @code{nrows}. All we have to do now is the following:
start.tex(,1093) 
start.tex(,1094) @smallexample
start.tex(,1095) quotient(U,freemodule(nrows(U)));
start.tex(,1096) @end smallexample
start.tex(,1097) 
start.tex(,1098) @noindent The result is too big to be shown here.
start.tex(,1099) 
start.tex(,1100) @c ------------------------------------------------------------------
start.tex(,1101) @node Resolution,  , Modules and their annihilator, Getting started
start.tex(,1103) @subsection Resolution
start.tex(,1108) @cindex Resolution
start.tex(,1109) 
start.tex(,1110) There are several commands in @sc{Singular} for computing free resolutions.
start.tex(,1111) The most general command is @code{res(... ,n)} which determines heuristically
start.tex(,1112) what method to use for the given problem. It computes the free resolution
start.tex(,1113) up to the length 
start.tex(,1120) , where 
start.tex(,1127)  corresponds to the full resolution.
start.tex(,1128) 
start.tex(,1129) Here we use the possibility to inspect the calculation process using the
start.tex(,1130) option @code{prot}.
start.tex(,1131) 
start.tex(,1132) @smallexample
start.tex(,1133) ring R;      // the default ring in char 32003
start.tex(,1134) R;
start.tex(,1135) @expansion{} //   characteristic : 32003
start.tex(,1136) @expansion{} //   number of vars : 3
start.tex(,1137) @expansion{} //        block   1 : ordering dp
start.tex(,1138) @expansion{} //                  : names    x y z
start.tex(,1139) @expansion{} //        block   2 : ordering C
start.tex(,1140) ideal I = x4+x3y+x2yz,x2y2+xy2z+y2z2,x2z2+2xz3,2x2z2+xyz2;
start.tex(,1141) option(prot);
start.tex(,1142) resolution rs = res(I,0);
start.tex(,1143) @expansion{} using lres
start.tex(,1144) @expansion{} 4(m0)4(m1).5(m1)g.g6(m1)...6(m2)..
start.tex(,1145) @end smallexample
start.tex(,1146) 
start.tex(,1147) @noindent Disable this protocol with
start.tex(,1148) 
start.tex(,1149) @smallexample
start.tex(,1150) option(noprot);
start.tex(,1151) @end smallexample
start.tex(,1152) 
start.tex(,1153) When we enter the name of the calculated resolution, we get a pictorial
start.tex(,1154) description of the minimized resolution where the exponents denote the rank of the
start.tex(,1155) free modules. Note that the calculated resolution itself may not yet be minimal.
start.tex(,1156) 
start.tex(,1157) @smallexample
start.tex(,1158) rs;
start.tex(,1159) @expansion{} 1      4      5      2      0
start.tex(,1160) @expansion{}R  <-- R  <-- R  <-- R  <-- R
start.tex(,1161) @expansion{}
start.tex(,1162) @expansion{}0      1      2      3      4
start.tex(,1163) print(betti(rs),"betti");
start.tex(,1164) @expansion{}            0     1     2     3
start.tex(,1165) @expansion{} ------------------------------
start.tex(,1166) @expansion{}     0:     1     -     -     -
start.tex(,1167) @expansion{}     1:     -     -     -     -
start.tex(,1168) @expansion{}     2:     -     -     -     -
start.tex(,1169) @expansion{}     3:     -     4     1     -
start.tex(,1170) @expansion{}     4:     -     -     1     -
start.tex(,1171) @expansion{}     5:     -     -     3     2
start.tex(,1172) @expansion{} ------------------------------
start.tex(,1173) @expansion{} total:     1     4     5     2
start.tex(,1174) @end smallexample
start.tex(,1175) 
start.tex(,1176) In order to minimize the resolution, that is to calculate the maps of the minimal 
start.tex(,1177) free resolution, we use the command @code{minres}:
start.tex(,1178) 
start.tex(,1179) @smallexample
start.tex(,1180) rs=minres(rs);
start.tex(,1181) @end smallexample
start.tex(,1182) 
start.tex(,1183) A single module in this resolution is obtained (as usual) with the
start.tex(,1184) brackets @code{[} and @code{]}. The @code{print} command can be used to
start.tex(,1185) display a module in a more readable format:
start.tex(,1186) 
start.tex(,1187) @smallexample
start.tex(,1188) print(rs[3]);
start.tex(,1189) @expansion{} z3,   -xyz-y2z-4xz2+16z3,
start.tex(,1190) @expansion{} 0,    -y2,
start.tex(,1191) @expansion{} -y+4z,48z, 
start.tex(,1192) @expansion{} x+2z, 48z, 
start.tex(,1193) @expansion{} 0,    x+y-z  
start.tex(,1194) @end smallexample
start.tex(,1195) 
start.tex(,1196) In this case, the output is to be interpreted as follows: the 3rd syzygy
start.tex(,1197) module of R/I, @code{rs[3]}, is the rank-2-submodule of
start.tex(,1204) generated by the vectors
start.tex(,1211) 
singular.texi(,128) @c ----------------------------------------------------------------------------
singular.texi(,129) @node General concepts, Data types, Introduction, Top
singular.texi(,130) @chapter General concepts
singular.texi(,131) @cindex General concepts
general.tex(,1) @comment -*-texinfo-*-
general.tex(,2) @comment This file was generated by doc2tex.pl from general.doc
general.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT general.doc INSTEAD
general.tex(,4) @comment Id: general.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
general.tex(,5) @comment this file contains the general information about Singular
general.tex(,6) 
general.tex(,7) @c The following directives are necessary for proper compilation
general.tex(,8) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
general.tex(,9) @c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
general.tex(,10) @c `makeinfo' but is a great help in editing this file (emacs
general.tex(,11) @c ignores the `@ignore').
general.tex(,24) 
general.tex(,25) @menu
general.tex(,26) * Interactive use::
general.tex(,27) * Emacs user interface::
general.tex(,28) * Rings and orderings::
general.tex(,29) * Implemented algorithms::
general.tex(,30) * The SINGULAR language::
general.tex(,31) * Input and output::
general.tex(,32) * Procedures::
general.tex(,33) * Libraries::
general.tex(,34) * Guidelines for writing a library::
general.tex(,35) * Debugging tools::
general.tex(,36) @end menu
general.tex(,37) 
general.tex(,38) 
general.tex(,39) @c ---------------------------------------------------------------------------
general.tex(,40) @node Interactive use, Emacs user interface, General concepts, General concepts
general.tex(,41) @section Interactive use
general.tex(,42) @cindex Interactive use
general.tex(,43) 
general.tex(,44) In this section, aspects of interactive use are discussed.  This
general.tex(,45) includes how to enter and exit @sc{Singular}, how to interpret its
general.tex(,46) prompt, how to get the online help, and so on.
general.tex(,47) 
general.tex(,48) There are a few important notes which one should not forget:
general.tex(,49) @itemize @bullet
general.tex(,50) @item
general.tex(,51) every command has to be terminated by a @code{;} (semicolon) followed
general.tex(,52) by a @key{RETURN}
general.tex(,53) @item
general.tex(,54) the online help is accessible by means of the @code{help} function
general.tex(,55) @end itemize
general.tex(,56) 
general.tex(,57) @menu
general.tex(,58) * How to enter and exit::
general.tex(,59) * The SINGULAR prompt::
general.tex(,60) * The online help system::
general.tex(,61) * Interrupting SINGULAR::
general.tex(,62) * Editing input::
general.tex(,63) * Command line options::
general.tex(,64) * Startup sequence::
general.tex(,65) @end menu
general.tex(,66) 
general.tex(,67) @c --------------------------------------------------------------------------
general.tex(,68) @node How to enter and exit, The SINGULAR prompt, Interactive use, Interactive use
general.tex(,69) @subsection How to enter and exit
general.tex(,70) @cindex How to enter and exit
general.tex(,71) 
general.tex(,72) @sc{Singular} can either be run in ASCII-terminal or within Emacs.
general.tex(,73) 
general.tex(,74) To start @sc{Singular} in its ASCII-terminal user interface,  enter
general.tex(,75) @code{Singular} at the system prompt. The
general.tex(,76) @sc{Singular} banner appears which, among others, reports the version
general.tex(,77) and the compilation date.
general.tex(,78) 
general.tex(,79) To start @sc{Singular} in its Emacs user interface, either enter
general.tex(,80) @code{ESingular} at the system prompt, or type @code{M-x singular}
general.tex(,81) within a running Emacs (provided you have loaded the file
general.tex(,82) @code{singular.el} in your running Emacs, see @ref{Running SINGULAR
general.tex(,83) under Emacs} for details).
general.tex(,84) 
general.tex(,85) Generally, we recommend to use @sc{Singular} in its Emacs interface,
general.tex(,86) since this offers many more features and is more convenient to
general.tex(,87) use than the ASCII-terminal interface (@pxref{Emacs user interface}).
general.tex(,88) 
general.tex(,89) To exit @sc{Singular} type @code{quit;}, @code{exit;} or @code{$} (or,
general.tex(,90) when running within Emacs preferably type @code{C-c $}).
general.tex(,91) 
general.tex(,92) @sc{Singular} and @code{ESingular} may also be started with command line
general.tex(,93) options and with
general.tex(,94) filenames as arguments. More generally, the synopsis of @sc{Singular} is
general.tex(,95) @smallexample
general.tex(,96) Singular  [options] [file1 [file2 @dots{}]]
general.tex(,97) ESingular  [options] [file1 [file2 @dots{}]]
general.tex(,98) @end smallexample
general.tex(,99) 
general.tex(,100) @xref{Command line options}, @ref{Startup sequence}, @ref{Running SINGULAR
general.tex(,101) under Emacs}.
general.tex(,102) 
general.tex(,103) 
general.tex(,104) @c --------------------------------------------------------------------------
general.tex(,105) @node The SINGULAR prompt,The online help system,How to enter and exit, Interactive use
general.tex(,106) @subsection The SINGULAR prompt
general.tex(,107) @cindex prompt
general.tex(,108) @cindex error recovery
general.tex(,109) The @sc{Singular} prompt @code{>} (larger than) asks the user for input
general.tex(,110) of commands.  The ``continuation'' prompt @code{.} (period) asks the
general.tex(,111) user for input of missing parts of a command (remember the semicolon at
general.tex(,112) the end of every command).
general.tex(,113) 
general.tex(,114) @sc{Singular} does not interpret the semicolon as the end of a command
general.tex(,115) if it occurs inside a string.  Also, @sc{Singular} waits for blocks
general.tex(,116) (sequences of commands enclosed in curly brackets) to be closed before
general.tex(,117) prompting with @code{>} for more commands.  Thus, if @sc{Singular} does
general.tex(,118) not respond with its regular prompt after typing a semicolon it may wait
general.tex(,119) for a @code{"} or a @code{@}} first.
general.tex(,120) 
general.tex(,121) Additional semicolons will not harm @sc{Singular} since they are
general.tex(,122) interpreted as empty statements.
general.tex(,123) 
general.tex(,124) @c --------------------------------------------------------------------------
general.tex(,125) @node The online help system,Interrupting SINGULAR, The SINGULAR prompt,Interactive use
general.tex(,126) @subsection The online help system
general.tex(,127) @cindex The online help system
general.tex(,128) @cindex online help
general.tex(,129) @cindex help, online help system
general.tex(,130) 
general.tex(,131) The online help system is invoked with the @code{help} command.
general.tex(,132) @code{?} may be used as a synonym for @code{help}.  Simply typing
general.tex(,133) @code{help;} displays the ``top'' of the help system (i.e., the title
general.tex(,134) page of the @sc{Singular} manual) which offers a
general.tex(,135) short table of contents.  Typing @code{help} topic@code{;} shows the
general.tex(,136) available documentation on topic.  Here, topic may be either a function
general.tex(,137) name or, more generally, any index entry of the @sc{Singular}
general.tex(,138) manual. Furthermore, topic may contain wildcard characters.
general.tex(,139) @xref{help}, for more information.
general.tex(,140) 
general.tex(,141) @cindex browsers
general.tex(,142) @cindex help browsers
general.tex(,143) Online help information can be displayed in various help browsers. The
general.tex(,144) following table lists a summary of the supported browsers. See below for
general.tex(,145) more details about particular browsers.
general.tex(,146) 
general.tex(,147) @multitable @columnfractions .2 .2 .6
general.tex(,148) @item @strong{Browser} @tab @strong{Platform}
general.tex(,149) @tab @strong{Description}
general.tex(,150) 
general.tex(,151) @item html
general.tex(,152) @cindex help browsers, html
general.tex(,153) @cindex html, default help
general.tex(,154) @tab Windows
general.tex(,155) @tab displays html version of manual in your default html browser
general.tex(,156) 
general.tex(,157) @item winhlp
general.tex(,158) @cindex help browsers, winhlp
general.tex(,159) @cindex html, default help
general.tex(,160) @tab Windows
general.tex(,161) @tab displays Windows help (.hlp) version of manual
general.tex(,162) 
general.tex(,163) @item netscape
general.tex(,164) @cindex netscape
general.tex(,165) @cindex help browsers, netscape
general.tex(,166) @tab Unix, Windows
general.tex(,167) @tab uses @code{netscape} to display html version of manual
general.tex(,168) 
general.tex(,169) @item tkinfo
general.tex(,170) @cindex tkinfo
general.tex(,171) @cindex help browsers, tkinfo
general.tex(,172) @tab Unix
general.tex(,173) @tab uses the @code{tkinfo} program to display texinfo version of manual
general.tex(,174) 
general.tex(,175) @item xinfo
general.tex(,176) @cindex xinfo
general.tex(,177) @cindex help browsers, xinfo
general.tex(,178) @tab Unix, Windows
general.tex(,179) @tab uses the @code{info} program to display texinfo version of manual in an
general.tex(,180) extra @code{xterm}
general.tex(,181) 
general.tex(,182) @item info
general.tex(,183) @cindex info
general.tex(,184) @cindex help browsers, info
general.tex(,185) @tab Unix, Windows
general.tex(,186) @tab uses the @code{info} program to display texinfo version of manual
general.tex(,187) 
general.tex(,188) @item builtin
general.tex(,189) @cindex help browsers, dummy
general.tex(,190) @tab all
general.tex(,191) @tab simply outputs the help information in plain ASCII format
general.tex(,192) 
general.tex(,193) @item emacs
general.tex(,194) @cindex help browsers, emacs
general.tex(,195) @tab Unix, Windows
general.tex(,196) @tab when running @sc{Singular} within (X)emacs, display help in
general.tex(,197) (X)emacs info buffer.
general.tex(,198) 
general.tex(,199) @item dummy
general.tex(,200) @tab all
general.tex(,201) @cindex help browsers, dummy
general.tex(,202) @tab displays error message about no available help browser
general.tex(,203) @end multitable
general.tex(,204) 
general.tex(,205) The browser which is used to display the help information, can be either
general.tex(,206) set at startup time with the command line option  (@pxref{Command line
general.tex(,207) options})
general.tex(,208) @smallexample
general.tex(,209) --brower=<browser>
general.tex(,210) @end smallexample
general.tex(,211) or with the @sc{Singular} command (@pxref{system})
general.tex(,212) @smallexample
general.tex(,213) system("--browser", <browser>);
general.tex(,214) @end smallexample
general.tex(,215) The  @sc{Singular} command
general.tex(,216) @smallexample
general.tex(,217) system("browsers");
general.tex(,218) @end smallexample
general.tex(,219) lists all available browsers and the command
general.tex(,220) @smallexample
general.tex(,221) system("--browser");
general.tex(,222) @end smallexample
general.tex(,223) returns the currently used browser.
general.tex(,224) 
general.tex(,225) If no browser is explicitly set by the user, then the first (w.r.t. the
general.tex(,226) order of the browsers in the table above) available browser is
general.tex(,227) chosen. In other words, the default browser is @code{netscape} for Unix
general.tex(,228) platforms, and @code{html} for Windows, unless
general.tex(,229) your local set-up does not allow to run it.
general.tex(,230) 
general.tex(,231) The @code{.singularrc} (@pxref{Startup sequence}) file is a good place
general.tex(,232) to set your default browser. Recall that if a file
general.tex(,233) @code{$HOME/.singularrc} exists on your system, then the content of this
general.tex(,234) file is executed before the first user input. Hence, putting
general.tex(,235) @smallexample
general.tex(,236) if (system("version") >= 1306) // keep backwards-compatibility
general.tex(,237) @{
general.tex(,238)   if (! system("--emacs")
general.tex(,239)   @{
general.tex(,240)     // only set help browser if not running within emacs
general.tex(,241)     system("--browser", "info");
general.tex(,242)   @}
general.tex(,243)   // if help browser is later on set to netscape,
general.tex(,244)   // allow it to fetch HTML pages from the net
general.tex(,245)   system("--allow-net", 1);
general.tex(,246) @}; // the last semicolon is important: otherwise no ">", but "." prompt
general.tex(,247) @end smallexample
general.tex(,248) in your file @code{$HOME/.singularrc} sets your default browser to
general.tex(,249) @code{info}, unless @sc{Singular} is run within emacs (in which case the
general.tex(,250) default browser is set automatically to @code{emacs}).
general.tex(,251) 
general.tex(,252) 
general.tex(,253) Obviously, certain external files and programs are required for the
general.tex(,254) @sc{Singular} help system to work correctly. If something is not available
general.tex(,255) or goes wrong, here are some tips for troubleshooting the help system:
general.tex(,256) 
general.tex(,257) @itemize @bullet
general.tex(,258) @item
general.tex(,259) @cindex DISPLAY environment variable
general.tex(,260) @cindex environment variable, DISPLAY
general.tex(,261) Under Unix, the environment variable @code{DISPLAY} has to be set for
general.tex(,262) the browsers @code{netscape}, @code{tkinfo}, and @code{xinfo} to work.
general.tex(,263) 
general.tex(,264) @item
general.tex(,265) @cindex NETSCAPE environment variable
general.tex(,266) @cindex XINFO environment variable
general.tex(,267) @cindex XTERM environment variable
general.tex(,268) @cindex INFO environment variable
general.tex(,269) @cindex help browsers, setting command to use
general.tex(,270) The help browsers @code{netscape}, @code{tkinfo}, @code{xinfo}, and
general.tex(,271) @code{info} are only available if the respective programs are installed
general.tex(,272) on your system (for @code{xinfo}, the programs @code{xterm} and
general.tex(,273) @code{info} are necessary). You can explicitly specify which program to
general.tex(,274) use, by setting appropriate environment variables (whose names
general.tex(,275) are the names of the respective programs in all up-case letters).
general.tex(,276) @*For example,
general.tex(,277) to use the program @code{navigator} with a private colormap as
general.tex(,278) @code{netscape} help browser, set the environment variable
general.tex(,279) @code{NETSCAPE} to the value
general.tex(,280) @code{"navigator -install"}.
general.tex(,281) @c TBC (@xref{Setting environment variables}).
general.tex(,282) 
general.tex(,283) @item
general.tex(,284) If the help browser @code{netscape} can not find the local html
general.tex(,285) pages of the @sc{Singular} manual (which it looks for at
general.tex(,286) @code{$RootDir/html} -- see @ref{Loading of a library} for more info on
general.tex(,287) @code{$RootDir}) @emph{and} the (command-line) option @code{--allow-net}
general.tex(,288) has @emph{explicitly} been set (see @ref{Command line options} and
general.tex(,289) @ref{system} for more info on
general.tex(,290) setting values of command-line options), then it dispatches the html
general.tex(,291) pages from
general.tex(,292) @url{http://www.singular.uni-kl.de/Manual} (note that
general.tex(,293) the non-local net-access of HTML pages is disabled, by default).
general.tex(,294) @*An
general.tex(,295) alternative location of a local directory where the html pages reside
general.tex(,296) can be specified by setting the environment variable
general.tex(,297) @code{SINGULAR_HTML_DIR}.
general.tex(,298) @c TBC (@xref{Setting environment variables}).
general.tex(,299) 
general.tex(,300) @item
general.tex(,301) The help browsers @code{tkinfo}, @code{xinfo}, @code{info}, and
general.tex(,302) @code{builtin} need the (info) file @code{singular.hlp} which it looks
general.tex(,303) for at @code{$RootDir/info/singular.hlp} (see @ref{Loading of a library}
general.tex(,304) for more info on @code{$RootDir}).  An alternative
general.tex(,305) location of the info file of the manual can be specified by setting the
general.tex(,306) environment variable @code{SINGULAR_INFO_FILE}.
general.tex(,307) @c TBC (@xref{Setting environment variables}).
general.tex(,308) @end itemize
general.tex(,309) 
general.tex(,310) @c inserted refs from general.doc:308
general.tex(,327) @c end inserted refs from general.doc:308
general.tex(,328) 
general.tex(,329) @subsubheading Info help browsers
general.tex(,330) @cindex info
general.tex(,331) 
general.tex(,332) The help browsers @code{tkinfo}, @code{xinfo} and @code{info} (so-called
general.tex(,333) info help browsers) are based on the
general.tex(,334) @code{info} program from the Gnu @code{texinfo} package.  @xref{Top, An
general.tex(,335) Introduction to Info, Getting started, info, The Info Manual}, for more
general.tex(,336) information.
general.tex(,337) 
general.tex(,338) For info help browsers, the online manual is decomposed into ``nodes''
general.tex(,339) of information, closely
general.tex(,340) related to the division of the printed manual into sections and
general.tex(,341) subsections.  A node contains text describing a specific topic at a
general.tex(,342) specific level of detail.  The top line of a node is its ``header''.
general.tex(,343) The node's header tells the name of the current node (@code{Node:}), the
general.tex(,344) name of the next node (@code{Next:}), the name of the previous node
general.tex(,345) (@code{Prev:}), and the name of the upper node (@code{Up:}).
general.tex(,346) 
general.tex(,347) To move within info, type commands consisting of single characters.  Do
general.tex(,348) not type @code{RETURN}.  Do not use cursor keys, either.  Using some of
general.tex(,349) the cursor keys by accident might pop to some totally different node.
general.tex(,350) Type @code{l} to return to the original node.  Some of the @code{info}
general.tex(,351) commands read input from the command line at the bottom line.  The
general.tex(,352) @code{TAB} key may be used to complete partially entered input.
general.tex(,353) 
general.tex(,354) The most important commands are:
general.tex(,355) @table @asis
general.tex(,356) @item @code{q}
general.tex(,357) leaves the online help system
general.tex(,358) @item @code{n}
general.tex(,359) goes to the next node
general.tex(,360) @item @code{p}
general.tex(,361) goes to the previous node
general.tex(,362) @item @code{u}
general.tex(,363) goes to the upper node
general.tex(,364) @item @code{m}
general.tex(,365) picks a menu item specified by name
general.tex(,366) @item @code{f}
general.tex(,367) follows a cross reference
general.tex(,368) @item @code{l}
general.tex(,369) goes to the previously visited node
general.tex(,370) @item @code{b}
general.tex(,371) goes to the beginning of the current node
general.tex(,372) @item @code{e}
general.tex(,373) goes to the end of the current node
general.tex(,374) @item @code{SPACE}
general.tex(,375) scrolls forward a page
general.tex(,376) @item @code{DEL}
general.tex(,377) scrolls backward a page
general.tex(,378) @item @code{h}
general.tex(,379) invokes info tutorial (use @code{l} to return to the manual or
general.tex(,380) @code{CTRL-X 0} to remove extra window)
general.tex(,381) @item @code{CTRL-H}
general.tex(,382) shows a short overview on the online help system (use @code{l} to return
general.tex(,383) to the manual or @code{CTRL-X 0} to remove extra window)
general.tex(,384) @item @code{s}
general.tex(,385) searches through the manual for a specified string, and selects the node in
general.tex(,386) which the next occurrence is found
general.tex(,387) @item @code{1}, @dots{}, @code{9}
general.tex(,388) picks i-th subtopic from a menu
general.tex(,389) @end table
general.tex(,390) 
general.tex(,391) @c --------------------------------------------------------------------------
general.tex(,392) @node Interrupting SINGULAR,Editing input,The online help system,Interactive use
general.tex(,393) @subsection Interrupting SINGULAR
general.tex(,394) @cindex Interrupting SINGULAR
general.tex(,395) 
general.tex(,396) On Unix-like operating systems and on Windows NT, typing @code{CTRL-C}
general.tex(,397) (or, alternatively @code{C-c C-c}, when running within Emacs),
general.tex(,398) interrupts @sc{Singular}.  @sc{Singular} prints the current command and
general.tex(,399) the current line and prompts for further action.  The following choices
general.tex(,400) are available:
general.tex(,401) @table @code
general.tex(,402) @item a
general.tex(,403) returns to the top level after finishing the current (kernel) command. Notice
general.tex(,404) that commands of the @sc{Singular} kernel (like @code{std}) can not be
general.tex(,405) aborted, i.e. (@code{a})bort only happens whenever the interpreter is active.
general.tex(,406) @item c
general.tex(,407) continues
general.tex(,408) @item q
general.tex(,409) quits  @sc{Singular}
general.tex(,410) @end table
general.tex(,411) 
general.tex(,412) @c --------------------------------------------------------------------------
general.tex(,413) @node Editing input,Command line options,Interrupting SINGULAR,Interactive use
general.tex(,414) @subsection Editing input
general.tex(,415) @cindex Editing input
general.tex(,416) @cindex SINGULARHIST
general.tex(,417) 
general.tex(,418) @c This section describes only a subset of the key bindings of
general.tex(,419) @c @sc{Singular} binaries built with the GNU Readline library.
general.tex(,420) @c @xref{Command Line Editing, GNU Readline Library, Command Line Editing,
general.tex(,421) @c readline, The GNU Readline Library Manual}, for more information.
general.tex(,422) 
general.tex(,423) The following keys can be used for editing the input and retrieving
general.tex(,424) previous input lines:
general.tex(,425) @table @code
general.tex(,426) @item TAB
general.tex(,427) provides command line completion for function names and file names
general.tex(,428) @item CTRL-B
general.tex(,429) moves cursor left
general.tex(,430) @item CTRL-F
general.tex(,431) moves cursor right
general.tex(,432) @item CTRL-A
general.tex(,433) moves cursor to beginning of line
general.tex(,434) @item CTRL-E
general.tex(,435) moves cursor to end of line
general.tex(,436) @item CTRL-D
general.tex(,437) deletes character under cursor
general.tex(,438) @* Warning: on an empty line, @code{CTRL-D} is interpreted as the
general.tex(,439) @code{EOF} character which immediately terminates @sc{Singular}.
general.tex(,440) @item BACKSPACE
general.tex(,441) @itemx DELETE
general.tex(,442) @itemx CTRL-H
general.tex(,443) deletes character before cursor
general.tex(,444) @item CTRL-K
general.tex(,445) kills from cursor to end of line
general.tex(,446) @item CTRL-U
general.tex(,447) kills from cursor to beginning of line
general.tex(,448) @item CTRL-N
general.tex(,449) saves current line on history and gives next line
general.tex(,450) @item CTRL-P
general.tex(,451) saves current line on history and gives previous line
general.tex(,452) @item RETURN
general.tex(,453) saves the current line to the history and
general.tex(,454) sends it to the @sc{Singular} parser for interpretation
general.tex(,455) @end table
general.tex(,456) 
general.tex(,457) When run under a Unix-like operating system and in its ASCII-terminal
general.tex(,458) user interface,   @sc{Singular} tries to dynamically link at runtime
general.tex(,459) with the GNU Readline library. @xref{Command Line Editing, GNU Readline
general.tex(,460) Library, Command Line Editing, readline, The GNU Readline Library
general.tex(,461) Manual}, for more information. If a shared version of this library can
general.tex(,462) be found on your machine, then additional command-line editing
general.tex(,463) features like  history completion are available.
general.tex(,464) In particular, if @sc{Singular} is able to load that library and
general.tex(,465) if the environment
general.tex(,466) variable @code{SINGULARHIST} is set and has a name of a file as value,
general.tex(,467) then the input history is stored across sessions using this
general.tex(,468) file. Otherwise, i.e., if the environment variable @code{SINGULARHIST}
general.tex(,469) is not set, then the history of the last inputs is only available for
general.tex(,470) the commands of the current session.
general.tex(,471) 
general.tex(,472) @c --------------------------------------------------------------------------
general.tex(,473) @node Command line options, Startup sequence, Editing input, Interactive use
general.tex(,474) @subsection Command line options
general.tex(,475) @cindex Command line options
general.tex(,476) 
general.tex(,477) The synopsis of @sc{Singular} is
general.tex(,478) @smallexample
general.tex(,479) Singular  [options] [file1 [file2 @dots{}]]
general.tex(,480) ESingular  [options] [file1 [file2 @dots{}]]
general.tex(,481) @end smallexample
general.tex(,482) Options can be given in both, their long and short format. The following
general.tex(,483) options control the general behavior of @sc{Singular}:
general.tex(,484) @table @asis
general.tex(,485) 
general.tex(,486) @item @code{-d}, @code{--sdb}
general.tex(,487) @cindex -d
general.tex(,488) @cindex --sdb
general.tex(,489) @cindex Source code debugger, invocation
general.tex(,490) Enable the use of the source code debugger.
general.tex(,491) @xref{Source code debugger}.
general.tex(,492) 
general.tex(,493) @item @code{-e}, @code{--echo[=VAL]}
general.tex(,494) @cindex -e
general.tex(,495) @cindex --echo
general.tex(,496) Set value of variable @code{echo} to @code{VAL} (integer in the range
general.tex(,497) 0, @dots{}, 9). Without an argument, @code{echo} is set to 1, which echoes
general.tex(,498) all input coming from a file. By default, the value of @code{echo} is
general.tex(,499) 0. @xref{echo}.
general.tex(,500) 
general.tex(,501) @item @code{-h}, @code{--help}
general.tex(,502) @cindex -h
general.tex(,503) @cindex --help
general.tex(,504) @cindex command-line options, short help
general.tex(,505) Print a one-line description of each command line option and exit.
general.tex(,506) 
general.tex(,507) @item @code{--allow-net}
general.tex(,508) @cindex --allow-net
general.tex(,509) @cindex net access
general.tex(,510) @cindex allowing net access
general.tex(,511) @cindex help, accessing over the net
general.tex(,512) Allow the @code{netscape} and @code{html} help browser to fetch HTML manual pages over
general.tex(,513) the net from the WWW home-site of @sc{Singular}. @xref{The online help
general.tex(,514) system}, for more info.
general.tex(,515) 
general.tex(,516) @item @code{--browser=VAL}
general.tex(,517) @cindex --browser
general.tex(,518) @cindex browser, command line option
general.tex(,519) Use @code{VAL} as browser for the @sc{Singular} online manual.
general.tex(,520) @*@code{VAL} may be one of @code{html} (Windows only), @code{netscape}, @code{xinfo},
general.tex(,521) @code{tkinfo}, @code{info}, @code{builtin}, or @code{emacs}. Depending
general.tex(,522) on your platform and local
general.tex(,523) installation, only some browsers might be available. The default browser
general.tex(,524) is @code{html} for Windows and @code{netscape} for Unix
general.tex(,525) platforms. @xref{The online help system}, for more info.
general.tex(,526) 
general.tex(,527) @item @code{--no-rc}
general.tex(,528) @cindex --no-rc
general.tex(,529) @cindex .singularrc file, no loading
general.tex(,530) Do not execute the @code{.singularrc} file on start-up.  By default,
general.tex(,531) this file is executed on start-up.  @xref{Startup sequence}.
general.tex(,532) 
general.tex(,533) @item @code{--no-stdlib}
general.tex(,534) @cindex --no-stdlib
general.tex(,535) Do not load the library @code{standard.lib} on start-up. By default,
general.tex(,536) this library is loaded on start-up.  @xref{Startup sequence}.
general.tex(,537) 
general.tex(,538) @item @code{--no-warn}
general.tex(,539) @cindex --no-warn
general.tex(,540) Do not display warning messages.
general.tex(,541) 
general.tex(,542) @item @code{--no-out}
general.tex(,543) @cindex --no-out
general.tex(,544) Suppress display of all output.
general.tex(,545) 
general.tex(,546) @item @code{-t}, @code{--no-tty}
general.tex(,547) @cindex --no-tty
general.tex(,548) Do not redefine the terminal characteristics.  This option should be
general.tex(,549) used for batch processes.
general.tex(,550) 
general.tex(,551) @item @code{-q}, @code{--quiet}
general.tex(,552) @cindex -q
general.tex(,553) @cindex --quiet
general.tex(,554) Do not print the start-up banner and messages when loading
general.tex(,555) libraries. Furthermore, redirect @code{stderr}
general.tex(,556) (all error messages) to @code{stdout} (normal output channel).  This
general.tex(,557) option should be used if @sc{Singular}'s output is redirected to a file.
general.tex(,558) 
general.tex(,559) @item @code{-v}, @code{--verbose}
general.tex(,560) @cindex --verbose
general.tex(,561) @cindex -v
general.tex(,562) Print extended information about the version and configuration of
general.tex(,563) @sc{Singular}  (used optional parts, compilation date, start of random
general.tex(,564) generator etc.). This information should be included if a user reports
general.tex(,565) an error to the authors.
general.tex(,566) @end table
general.tex(,567) 
general.tex(,568) The following command line options allow manipulations of the timer and
general.tex(,569) the pseudo random generator and enable the passing of commands and strings
general.tex(,570) to @sc{Singular}:
general.tex(,571) 
general.tex(,572) @table @asis
general.tex(,573) @item @code{-c}, @code{--execute=STRING}
general.tex(,574) @cindex -c
general.tex(,575) @cindex --execute
general.tex(,576) Execute @code{STRING} as (a sequence of) @sc{Singular} commands on
general.tex(,577) start-up after the @code{.singularrc} file is executed, but prior to
general.tex(,578) executing the files given on the command line.  E.g., @code{Singular -c
general.tex(,579) "help all.lib; quit;"} shows the help for the library @code{all.lib} and
general.tex(,580) exits.
general.tex(,581) 
general.tex(,582) @item @code{-u}, @code{--user-option=STRING}
general.tex(,583) @cindex -u
general.tex(,584) @cindex --user-option
general.tex(,585) Returns @code{STRING} on @code{system("--user-option")}. This is useful
general.tex(,586) for passing arbitrary arguments from the command line to the
general.tex(,587) @sc{Singular} interpreter.  E.g.,
general.tex(,588) @*@code{Singular -u "xxx.dump" -c 'getdump(system("--user-option"))'}
general.tex(,589) reads the file @code{xxx.dump} at
general.tex(,590) start-up and allows the user to start working with all the objects
general.tex(,591) defined in a previous session.
general.tex(,592) 
general.tex(,593) @item @code{-r}, @code{--random=SEED}
general.tex(,594) @cindex -r
general.tex(,595) @cindex --random
general.tex(,596) Seed (i.e., set the initial value of) the pseudo random generator with
general.tex(,597) integer @code{SEED}.  If this option is not given, then the random
general.tex(,598) generator is seeded with a time-based @code{SEED} (the number of
general.tex(,599) seconds since January, 1, 1970, on Unix-like operating systems, to be
general.tex(,600) precise).
general.tex(,601) 
general.tex(,602) @item @code{--min-time=SECS}
general.tex(,603) @cindex --min-time
general.tex(,604) If the @code{timer} (@pxref{timer}), resp.@:  @code{rtimer}
general.tex(,605) (@pxref{rtimer}) , variable is
general.tex(,606) set, report only
general.tex(,607) times larger than @code{SECS} seconds (@code{SECS} needs to be a
general.tex(,608) floating point number greater than 0).  By default, this value is set to
general.tex(,609) 0.5 (i.e., half a second).  E.g., the option @code{--min-time=0.01}
general.tex(,610) forces @sc{Singular} to report all times larger than 1/100 of a
general.tex(,611) second.
general.tex(,612) 
general.tex(,613) @item @code{--ticks-per-sec=TICKS}
general.tex(,614) @cindex --ticks-per-sec
general.tex(,615) Set unit of timer to @code{TICKS} ticks per second (i.e., the value
general.tex(,616) reported by the @code{timer} and @code{rtimer} variable divided by
general.tex(,617) @code{TICKS} gives the time in seconds).  By default, this value is 1.
general.tex(,618) 
general.tex(,619) @end table
general.tex(,620) 
general.tex(,621) The next three options are of interest for the use with MP links:
general.tex(,622) @table @asis
general.tex(,623) @item @code{-b}, @code{--batch}
general.tex(,624) @cindex -b
general.tex(,625) @cindex --batch
general.tex(,626) Run in MP batch mode. Opens a TCP/IP connection with host specified by
general.tex(,627) @code{--MPhost} at the port specified by @code{--MPport}. Input is read
general.tex(,628) from and output is written to this connection in the MP format.
general.tex(,629) @xref{MPtcp links}.
general.tex(,630) 
general.tex(,631) @item @code{--MPport=PORT}
general.tex(,632) @cindex --MPport
general.tex(,633) Use @code{PORT} as default port number for MP connections (whenever not
general.tex(,634) further specified). This option is mandatory when the @code{--batch}
general.tex(,635) option is given.  @xref{MPtcp links}.
general.tex(,636) 
general.tex(,637) @item @code{--MPhost=HOST}
general.tex(,638) @cindex --MPhost
general.tex(,639) Use @code{HOST} as default host for MP connections (whenever not
general.tex(,640) further specified).  This option is mandatory when the @code{--batch}
general.tex(,641) option is given.  @xref{MPtcp links}.
general.tex(,642) @end table
general.tex(,643) 
general.tex(,644) Finally, the following options are only available when running
general.tex(,645) @code{ESingular} (see @ref{Running SINGULAR under Emacs} for details).
general.tex(,646) 
general.tex(,647) @table @code
general.tex(,648) 
general.tex(,649) @item --emacs=EMACS
general.tex(,650) @cindex --emacs
general.tex(,651) Use @code{EMACS} as Emacs program to run the @sc{Singular} Emacs
general.tex(,652) interface, where @code{EMACS} may e.g. be emacs ore xemacs.
general.tex(,653) 
general.tex(,654) @item --emacs-dir=DIR
general.tex(,655) @cindex --emacs-dir
general.tex(,656) Set the singular-emacs-home-directory, which is the directory where
general.tex(,657) singular.el can be found, to @code{DIR}.
general.tex(,658) 
general.tex(,659) @item --emacs-load=FILE
general.tex(,660) @cindex --emacs-load
general.tex(,661) Load @code{FILE} on Emacs start-up, instead of the default load file.
general.tex(,662) 
general.tex(,663) @item --singular=PROG
general.tex(,664) @cindex --singular
general.tex(,665) Start @code{PROG} as @sc{Singular} program within Emacs
general.tex(,666) @end table
general.tex(,667) 
general.tex(,668) The value of options given to @sc{Singular} (resp.@: their default values,
general.tex(,669) if an option was not given), can be checked with the command
general.tex(,670) @code{system("--}long_option_name@code{")}.  @xref{system}.
general.tex(,671) @smallexample
general.tex(,672) @c computed example Command_line_options general.doc:658 
general.tex(,673)   system("--quiet");    // if ``quiet'' 1, otherwise 0
general.tex(,674) @expansion{} 1
general.tex(,675)   system("--min-time"); // minimal reported time
general.tex(,676) @expansion{} 0.5
general.tex(,677)   system("--random");   // seed of the random generator
general.tex(,678) @expansion{} 12345678
general.tex(,679) @c end example Command_line_options general.doc:658
general.tex(,680) @end smallexample
general.tex(,681) 
general.tex(,682) Furthermore, the value of options (e.g., @code{--browser}) can be
general.tex(,683) re-set while @sc{Singular} is running with the command
general.tex(,684) @code{system("--}long_option_name_string @code{",}expression@code{)}. @xref{system}.
general.tex(,685) @smallexample
general.tex(,686)   system("--browser", "builtin");  // sets browser to 'builtin'
general.tex(,687)   system("--ticks-per-sec", 100);  // sets timer resolution to 100
general.tex(,688) @end smallexample
general.tex(,689) 
general.tex(,690) 
general.tex(,691) @c --------------------------------------------------------------------------
general.tex(,692) 
general.tex(,693) @node Startup sequence, , Command line options, Interactive use
general.tex(,694) @subsection Startup sequence
general.tex(,695) @cindex Startup sequence
general.tex(,696) 
general.tex(,697) On start-up, @sc{Singular}
general.tex(,698) @enumerate
general.tex(,699) @item
general.tex(,700) loads the library @code{standard.lib} (provided the @code{--no-stdlib}
general.tex(,701) option was not given),
general.tex(,702) 
general.tex(,703) @item
general.tex(,704) @cindex file, .singularrc
general.tex(,705) @cindex .singularrc file
general.tex(,706) @cindex singularrc
general.tex(,707) searches the current directory and then the
general.tex(,708) home directory of the user, and then all directories contained in the
general.tex(,709) library @code{SearchPath} (see @ref{Loading of a library} for more info
general.tex(,710) on @code{SearchPath}) for a file named @code{.singularrc} and
general.tex(,711) executes it, if found (provided the @code{--no-rc} option was not
general.tex(,712) given),
general.tex(,713) 
general.tex(,714) @item
general.tex(,715) executes the string specified with the @code{--execute} command line
general.tex(,716) option,
general.tex(,717) 
general.tex(,718) @item
general.tex(,719) executes the files @code{file1}, @code{file2} @dots{}  (given on the command
general.tex(,720) line) in that order.
general.tex(,721) @end enumerate
general.tex(,722) 
general.tex(,723) @strong{Note:} @code{.singularrc} file(s) are an appropriate place for
general.tex(,724) setting some default values of (command-line) options.
general.tex(,725) 
general.tex(,726) For example, a system administrator might remove the locally installed
general.tex(,727) HTML version of the manual and put a @code{.singularrc} file
general.tex(,728) with the following content
general.tex(,729) @smallexample
general.tex(,730) if (system("version") >= 1306) // assure backwards-compatibility
general.tex(,731) @{
general.tex(,732)   system("--allow-net", 1);
general.tex(,733) @}; // the last semicolon is important: otherwise no ">", but "." prompt
general.tex(,734) @end smallexample
general.tex(,735) in the directory containing the @sc{Singular} libraries, thereby
general.tex(,736) allowing to fetch the HTML on-line help from the WWW home-site of
general.tex(,737) @sc{Singular}.
general.tex(,738) 
general.tex(,739) On the other hand, a single user might put a @code{.singularrc} with the
general.tex(,740) following content
general.tex(,741) @smallexample
general.tex(,742) if (system("version") >= 1306) // assure backwards-compatibility
general.tex(,743) @{
general.tex(,744)   if (! system("--emacs"))
general.tex(,745)   @{
general.tex(,746)     // set default browser to info, unless we run within emacs
general.tex(,747)     system("--browser", "info");
general.tex(,748)   @}
general.tex(,749) @}; // the last semicolon is important: otherwise no ">", but "." prompt
general.tex(,750) @end smallexample
general.tex(,751) in his home directory, which sets the default help browser to
general.tex(,752) @code{info} (unless @sc{Singular} is run within emacs) and thereby
general.tex(,753) prevents the execution of the"global"
general.tex(,754) @code{.singularrc} file installed by the system administrator (since the
general.tex(,755) @code{.singularrc} file of the user is found before the "global"
general.tex(,756) @code{.singularrc} file installed by the system administrator).
general.tex(,757) 
general.tex(,758) @c ---------------------------------------------------------------------------
general.tex(,759) @node Emacs user interface, Rings and orderings, Interactive use, General concepts
general.tex(,760) @section Emacs user interface
general.tex(,761) @cindex Emacs, user interface
general.tex(,762) @cindex Emacs
general.tex(,763) @cindex interface, Emacs
general.tex(,764) @cindex user interface, Emacs
general.tex(,765) 
general.tex(,766) Besides running @sc{Singular} in an ASCII-terminal, @sc{Singular} might
general.tex(,767) also be run within Emacs. Emacs (or, XEmacs which is very similar) is a
general.tex(,768) powerful and freely available text editor, which, among others,
general.tex(,769) provides a framework for the implementation of interactive user
general.tex(,770) interfaces. Starting from version 1.3.6, @sc{Singular} provides such an
general.tex(,771) implementation, the so-called @sc{Singular} Emacs mode, or Emacs user
general.tex(,772) interface.
general.tex(,773) 
general.tex(,774) Generally, we recommend to use the Emacs interface,
general.tex(,775) instead of the ASCII-terminal interface: The Emacs interface does not
general.tex(,776) only provide everything the ASCII-terminal interface provides, but
general.tex(,777) offers much more. Among others, it offers
general.tex(,778) @itemize @bullet
general.tex(,779) @item
general.tex(,780) color-highlighting
general.tex(,781) @item
general.tex(,782) truncation of long lines
general.tex(,783) @item
general.tex(,784) folding of input and output
general.tex(,785) @item
general.tex(,786) TAB-completion for help topics
general.tex(,787) @item
general.tex(,788) highlighting of matching parentheses
general.tex(,789) @item
general.tex(,790) key-bindings and interactive menus for most user interface commands and
general.tex(,791) for basic @sc{Singular} commands (such as loading of libraries and files)
general.tex(,792) @item
general.tex(,793) a mode for running interactive @sc{Singular} demonstrations
general.tex(,794) @item
general.tex(,795) convenient ways to edit @sc{Singular} input files
general.tex(,796) @item
general.tex(,797) interactive customization of nearly all aspects of the user-interface.
general.tex(,798) @end itemize
general.tex(,799) 
general.tex(,800) To use the @sc{Singular}-Emacs interface you need to have Emacs version
general.tex(,801) 20 or higher, or XEmacs
general.tex(,802) version 20.3 or higher installed on your system. These
general.tex(,803) editors can be downloaded for most hard- and software platforms
general.tex(,804) (including Windows
general.tex(,805) 95/98/NT, but excluding the Macintosh), from either
general.tex(,806) @uref{http://www.fsf.org/software/emacs/emacs.html} (Emacs), from
general.tex(,807) @uref{http://www.xemacs.org} (XEmacs), or from our ftp site at
general.tex(,808) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils/}. The
general.tex(,809) differences between Emacs and XEmacs w.r.t. the  @sc{Singular}-Emacs
general.tex(,810) interface are marginal -- which editor to use is mainly a matter of personal
general.tex(,811) preferences.
general.tex(,812) 
general.tex(,813) The simplest way to start-up @sc{Singular} in its Emacs interface is by
general.tex(,814) running the program @code{ESingular} which is contained in the Singular
general.tex(,815) distribution. Alternatively, @sc{Singular} can be started within an
general.tex(,816) already running Emacs -- see @ref{Running SINGULAR under Emacs} for
general.tex(,817) details.
general.tex(,818) 
general.tex(,819) The next section gives  a tutorial-like introduction to Emacs. This
general.tex(,820) introductory section is
general.tex(,821) followed by sections which explain the functionality of various aspects
general.tex(,822) of the Emacs user interface in more detail: how to start/restart/kill
general.tex(,823) @sc{Singular} within Emacs, how to run an interactive demonstration, how
general.tex(,824) to customize the Emacs user interface, etc. Finally, the 20 most
general.tex(,825) important commands of the Emacs interface together with their key
general.tex(,826) bindings are listed.
general.tex(,827) 
general.tex(,828) @menu
general.tex(,829) * A quick guide to Emacs::
general.tex(,830) * Running SINGULAR under Emacs::
general.tex(,831) * Demo mode::
general.tex(,832) * Customization of the Emacs interface::
general.tex(,833) * Editing SINGULAR input files with Emacs::
general.tex(,834) * Top 20 Emacs commands::
general.tex(,835) @end menu
general.tex(,836) 
general.tex(,837) @c --------------------------------------------------------------------------
general.tex(,838) @node A quick guide to Emacs, Running SINGULAR under Emacs, Emacs user interface, Emacs user interface
general.tex(,839) @subsection A quick guide to Emacs
general.tex(,840) @cindex Emacs, overview
general.tex(,841) @cindex Emacs, a quick guide
general.tex(,842) 
general.tex(,843) This section gives a tutorial-like introduction to Emacs. Especially to
general.tex(,844) users who are not familiar with Emacs, we recommend that they go through
general.tex(,845) this section and try out the described features.
general.tex(,846) 
general.tex(,847) Emacs commands generally involve the @code{CONTROL} key (sometimes
general.tex(,848) labeled @code{CTRL} or @code{CTL}) or the @code{META} key.  On some
general.tex(,849) keyboards, the @code{META} key is labeled @code{ALT} or @code{EDIT} or
general.tex(,850) something else (for example, on Sun keyboards, the diamond key to the
general.tex(,851) left of the space-bar is @code{META}).  If there is no @code{META} key,
general.tex(,852) the @code{ESC} key can be used, instead.  Rather than writing out
general.tex(,853) @code{META} or
general.tex(,854) @code{CONTROL} each time we want to prefix a character, we will use the
general.tex(,855) following abbreviations:
general.tex(,856) 
general.tex(,857) @multitable @columnfractions .2 .8
general.tex(,858) @item @code{C-<chr>}
general.tex(,859) @tab means hold the @code{CONTROL} key while typing the character
general.tex(,860) @code{<chr>}. Thus, @code{C-f} would be: hold the @code{CONTROL} key and
general.tex(,861) type @code{f}.
general.tex(,862) @item @code{M-<chr>}
general.tex(,863) @tab means hold the @code{META} key down while typing @code{<chr>}.  If there
general.tex(,864) is no @code{META} key, type @key{ESC}, release it, then type the
general.tex(,865) character @code{<chr>}.
general.tex(,866) @end multitable
general.tex(,867) 
general.tex(,868) For user new to Emacs, we highly recommend that they go through the
general.tex(,869) interactive Emacs tutorial: type @code{C-h t} to start it.
general.tex(,870) 
general.tex(,871) For others, it is important to understand the following Emacs concepts:
general.tex(,872) @table @asis
general.tex(,873) @item window
general.tex(,874) In Emacs terminology, a window refers to separate panes within the same
general.tex(,875) window of the window system, and not to overlapping, separate
general.tex(,876) windows. When using @sc{Singular} within Emacs, extra windows may appear
general.tex(,877) which display help or output from certain commands. The most important
general.tex(,878) window commands are:
general.tex(,879) @multitable @columnfractions 2. .3 .5
general.tex(,880) @item @code{C-x 1}
general.tex(,881) @tab @code{File->Un-Split}
general.tex(,882) @tab Un-Split window (i.e., kill other windows)
general.tex(,883) @item @code{C-x o}
general.tex(,884) @tab
general.tex(,885) @tab Goto other window, i.e. move cursor into other window.
general.tex(,886) @end multitable
general.tex(,887) 
general.tex(,888) @item cursor and point
general.tex(,889) The location of the cursor in the text is also called "point".  To
general.tex(,890) paraphrase, the cursor shows on the screen where point is located in
general.tex(,891) the text. Here is a summary of simple cursor-moving operations:
general.tex(,892) @multitable @columnfractions .2 .8
general.tex(,893) @item @code{C-f} @tab   Move forward a character
general.tex(,894) @item @code{C-b} @tab   Move backward a character
general.tex(,895) @item @code{M-f} @tab   Move forward a word
general.tex(,896) @item @code{M-b} @tab   Move backward a word
general.tex(,897) @item @code{C-a} @tab   Move to the beginning of line
general.tex(,898) @item @code{C-e} @tab   Move to the end of line
general.tex(,899) @end multitable
general.tex(,900) 
general.tex(,901) @item buffer
general.tex(,902) Any text you see in an Emacs window is always part of some buffer. For
general.tex(,903) example, each file you are editing with Emacs is stored inside a buffer,
general.tex(,904) but also @sc{Singular} is running inside an Emacs buffer. Each buffer
general.tex(,905) has a name: for example, the buffer of a file you edit usually has the
general.tex(,906) same name as the file, @sc{Singular} is running in a buffer which has
general.tex(,907) the name @code{*singular*} (or, @code{*singular<2>*},
general.tex(,908) @code{*singular<3>*}, etc., if you have multiple @sc{Singular}
general.tex(,909) sessions within the same Emacs).
general.tex(,910) 
general.tex(,911) When you are asked for input to an Emacs command, the cursor
general.tex(,912) moves to the bottom line of Emacs, i.e., to a special buffer, called the
general.tex(,913) "minibuffer". Typing @key{RETURN} within the minibuffer, ends the
general.tex(,914) input, typing @key{SPACE} within the minibuffer, lists all possible
general.tex(,915) input values to the interactive Emacs command.
general.tex(,916) 
general.tex(,917) The most important buffer commands are
general.tex(,918) @multitable @columnfractions .2 .8
general.tex(,919) @item @code{C-x b} @tab Switch buffer
general.tex(,920) @item @code{C-x k} @tab Kill current buffer
general.tex(,921) @end multitable
general.tex(,922) Alternatively, you can switch to or kill buffers using the @code{Buffer}
general.tex(,923) menu.
general.tex(,924) 
general.tex(,925) @item Executing commands
general.tex(,926) Emacs commands are executed by typing @code{M-x <command-name>}
general.tex(,927) (remember that @key{SPACE} completes partial
general.tex(,928) command names). Important and frequently used commands have short-cuts
general.tex(,929) for their execution: Key bindings or even menu entries. For example, a
general.tex(,930) file can be loaded with @code{M-x load-file}, or @code{C-x C-f}, or with
general.tex(,931) the @code{File->Open} menu.
general.tex(,932) 
general.tex(,933) @item How to exit
general.tex(,934) To end the Emacs (and, @sc{Singular}) session,
general.tex(,935) type @code{C-x C-c} (two characters), or use the @code{File -> Exit}
general.tex(,936) menu.
general.tex(,937) 
general.tex(,938) @item When Emacs is hung
general.tex(,939) If Emacs stops responding to your commands, you can stop it safely by
general.tex(,940) typing @code{C-g}, or, if this fails, by typing @code{C-]}.
general.tex(,941) 
general.tex(,942) @item More help
general.tex(,943) Nearly all aspects of Emacs are very well documented: type
general.tex(,944) @code{C-h}  and then a character saying what kind of help you want.
general.tex(,945) For example, typing @code{C-h i} enters the @code{Info} documentation
general.tex(,946) browser.
general.tex(,947) 
general.tex(,948) @item Using the mouse
general.tex(,949) Emacs is fully integrated with the mouse. In particular, clicking the
general.tex(,950) right mouse button brings up a pop-up menu which usually contains a few
general.tex(,951) commonly used commands.
general.tex(,952) @end table
general.tex(,953) 
general.tex(,954) @c --------------------------------------------------------------------------
general.tex(,955) @node Running SINGULAR under Emacs, Demo mode, A quick guide to Emacs, Emacs user interface
general.tex(,956) @subsection Running SINGULAR under Emacs
general.tex(,957) @cindex Emacs, running Singular under
general.tex(,958) @cindex Singular, running within Emacs
general.tex(,959) @cindex Running SINGULAR under Emacs
general.tex(,960) 
general.tex(,961) There are two ways to start the @sc{Singular} Emacs interface: Typing
general.tex(,962) @code{ESingular} instead of @code{Singular} on the command shell
general.tex(,963) launches a new Emacs process, initializes the interface and runs
general.tex(,964) @sc{Singular} within Emacs. The other way is to start the interface in
general.tex(,965) an already running Emacs, by typing @code{M-x singular} inside
general.tex(,966) Emacs. This initializes the interface and runs @sc{Singular} within
general.tex(,967) Emacs. Both ways are described in more detail below.
general.tex(,968) 
general.tex(,969) Note: To properly run the Emacs interface, several files are needed
general.tex(,970) which usually reside in the @code{emacs} subdirectory of your
general.tex(,971) @sc{Singular} distribution. This directory is called
general.tex(,972) singular-emacs-home-directory in the following.
general.tex(,973) 
general.tex(,974) @subheading Starting the interface using ESingular
general.tex(,975) 
general.tex(,976) As mentioned above, @code{ESingular} is an "out-of-the-box" solution:
general.tex(,977) You don't have to add special things to your @code{.emacs} startup file
general.tex(,978) to initialize the interface; everything is done for you in a special
general.tex(,979) file called @code{.emacs-singular} (which comes along with the
general.tex(,980) @sc{Singular} distribution and resides in the
general.tex(,981) singular-emacs-home-directory) which is automatically loaded on Emacs
general.tex(,982) startup (and the loading of the @code{.emacs} file is automatically
general.tex(,983) suppressed).
general.tex(,984) 
general.tex(,985) The customizable variables of the @sc{Singular} Emacs interface are set
general.tex(,986) to defaults which give the novice user a very shell like
general.tex(,987) feeling of the interface. Nevertheless, these default settings can be
general.tex(,988) changed, see @ref{Customization of the Emacs interface}. Besides other
general.tex(,989) Emacs initializations, such as fontification or blinking parentheses, a
general.tex(,990) new menu item called @code{Singular} is added to the main menu,
general.tex(,991) providing menu items for starting @sc{Singular}. On XEmacs, a button
general.tex(,992) starting @sc{Singular} is added to the main toolbar.
general.tex(,993) 
general.tex(,994) The @sc{Singular} interface is started automatically; once you see a
general.tex(,995) buffer called @code{*singular*} and the @sc{Singular} prompt you are
general.tex(,996) ready to start your @sc{Singular} session.
general.tex(,997) 
general.tex(,998) @code{ESingular} inherits all @code{Singular} options. For a description
general.tex(,999) off all these options, see @ref{Command line options}. Additionally
general.tex(,1000) there are the following options which are special to @code{ESingular}:
general.tex(,1001) 
general.tex(,1002) @multitable @columnfractions .3 .7
general.tex(,1003) 
general.tex(,1004) @item command-line option /
general.tex(,1005) @*environment variable
general.tex(,1006) @tab functionality
general.tex(,1007) 
general.tex(,1008) @item @code{--emacs=EMACS}
general.tex(,1009) @*@code{ESINGULAR_EMACS}
general.tex(,1010) @tab Use @code{EMACS} as Emacs program to run the @sc{Singular} Emacs
general.tex(,1011) interface, where @code{EMACS} may e.g. be emacs or xemacs.
general.tex(,1012) 
general.tex(,1013) @item @code{--emacs-dir=DIR}
general.tex(,1014) @*@code{ESINGULAR_EMACS_DIR}
general.tex(,1015) @tab Set the singular-emacs-home-directory, which is the directory where
general.tex(,1016) singular.el can be found,  to @code{DIR}.
general.tex(,1017) 
general.tex(,1018) @item @code{--emacs-load=FILE}
general.tex(,1019) @*@code{ESINGULAR_EMACS_LOAD}
general.tex(,1020) @tab Load @code{FILE} on Emacs start-up, instead of the default load file.
general.tex(,1021) 
general.tex(,1022) @item @code{--singular=PROG}
general.tex(,1023) @*@code{ESINGULAR_SINGULAR}
general.tex(,1024) @tab Start @code{PROG} as @sc{Singular} program within Emacs
general.tex(,1025) 
general.tex(,1026) @end multitable
general.tex(,1027) 
general.tex(,1028) Notice that values of these options can also be given by setting the
general.tex(,1029) above mentioned environment variables (where values  given as
general.tex(,1030) command-line arguments take priority over values given by environment
general.tex(,1031) variables).
general.tex(,1032) 
general.tex(,1033) @subheading Starting the interface within a running Emacs
general.tex(,1034) 
general.tex(,1035) If you are a more experienced Emacs user and you already have your own
general.tex(,1036) local @code{.emacs} startup file, you might want to start the interface
general.tex(,1037) out of your running Emacs without using @code{ESingular}. For this, you
general.tex(,1038) should add the following lisp code to your @code{.emacs} file:
general.tex(,1039) 
general.tex(,1040) @smallexample
general.tex(,1041) (setq load-path (cons "<singular-emacs-home-directory>" load-path))
general.tex(,1042) (autoload 'singular "singular"
general.tex(,1043)   "Start Singular using default values." t)
general.tex(,1044) (autoload 'singular-other "singular"
general.tex(,1045)   "Ask for arguments and start Singular." t)
general.tex(,1046) @end smallexample
general.tex(,1047) 
general.tex(,1048) Then typing @code{M-x singular} in a running Emacs session initializes
general.tex(,1049) the interface in a new buffer and launches a @sc{Singular} process. The
general.tex(,1050) @sc{Singular} prompt comes up and you are ready to start your
general.tex(,1051) @sc{Singular} session.
general.tex(,1052) 
general.tex(,1053) It is a good idea to take a look at the (well documented) file
general.tex(,1054) @code{.emacs-singular} in the singular-emacs-home-directory, which comes
general.tex(,1055) along with the distribution. In it you find some useful initializations
general.tex(,1056) of the @sc{Singular} interface as well as some lisp code, which, for
general.tex(,1057) example, adds a button to the XEmacs toolbar. Some of this code might be
general.tex(,1058) useful for your @code{.emacs} file, too. And if you are a Emacs wizard,
general.tex(,1059) it is of course a good idea to take a look at @code{singular.el} in the
general.tex(,1060) singular-emacs-home-directory.
general.tex(,1061) 
general.tex(,1062) @subheading Starting, interrupting and stopping SINGULAR
general.tex(,1063) 
general.tex(,1064) There are the following commands to start and stop @sc{Singular}:
general.tex(,1065) 
general.tex(,1066) @itemize @bullet
general.tex(,1067) @item @code{singular-other} (or menu @code{Singular}, item
general.tex(,1068) @code{Start...})
general.tex(,1069) 
general.tex(,1070) Starts a @sc{Singular} process and asks for the following four
general.tex(,1071) parameters in the minibuffer area:
general.tex(,1072) 
general.tex(,1073) @enumerate
general.tex(,1074) @item
general.tex(,1075) The Singular executable. This can either be a file name with complete
general.tex(,1076) path, e.g., @code{/local/bin/Singular}. Then exactly this executable is
general.tex(,1077) started. The path may contain the character @code{~} denoting your home
general.tex(,1078) directory. Or it can be the name of a command without path, e.g.,
general.tex(,1079) @code{Singular}. Then the executable is searched for in your
general.tex(,1080) @code{$PATH} environment variable.
general.tex(,1081) 
general.tex(,1082) @item
general.tex(,1083) The default working directory. This is the path to an existing
general.tex(,1084) directory, e.g., @code{~/work}. The current directory is set to this
general.tex(,1085) directory before @sc{Singular} is started.
general.tex(,1086) 
general.tex(,1087) @item
general.tex(,1088) Command line options. You can set any @sc{Singular} command line
general.tex(,1089) option (see @ref{Command line options}).
general.tex(,1090) 
general.tex(,1091) @item
general.tex(,1092) The buffer name. You can specify the name of the buffer the interface is
general.tex(,1093) running in.
general.tex(,1094) 
general.tex(,1095) @end enumerate
general.tex(,1096) 
general.tex(,1097) @item @code{singular} (or menu @code{Singular}, item @code{Start
general.tex(,1098) default})
general.tex(,1099) 
general.tex(,1100) Starts @sc{Singular} with default settings for the executable, the
general.tex(,1101) working directory, command line switches, and the buffer name. You can
general.tex(,1102) customize this default settings, see
general.tex(,1103) @ref{Customization of the Emacs interface}.
general.tex(,1104) 
general.tex(,1105) @item @code{singular-exit-singular} (bound to @code{C-c $} or menu
general.tex(,1106) @code{Singular}, item @code{Exit})
general.tex(,1107) 
general.tex(,1108) Kills the running @sc{Singular} process of the current
general.tex(,1109) buffer (but does not kill the buffer). Once you have killed a
general.tex(,1110) @sc{Singular} process you can start a new one in the same buffer with
general.tex(,1111) the command @code{singular} (or select the item @code{Start default} of
general.tex(,1112) the @code{Singular} menu).
general.tex(,1113) 
general.tex(,1114) @item @code{singular-restart} (bound to @code{C-c C-r} or menu
general.tex(,1115) @code{Singular}, item @code{Restart})
general.tex(,1116) 
general.tex(,1117) Kills the running @sc{Singular} process of the current buffer and starts
general.tex(,1118) a new process in the same buffer with exactly the same command line
general.tex(,1119) arguments as before.
general.tex(,1120) 
general.tex(,1121) @item @code{singular-control-c} (bound to @code{C-c C-c} or menu @code{Singular}, item @code{Interrupt})
general.tex(,1122) 
general.tex(,1123) Interrupt the Singular process running in the current buffer. Asks
general.tex(,1124) whether to (@code{a})bort the current @sc{Singular} command,
general.tex(,1125) (@code{q})uit or (@code{r})estart the current @sc{Singular} process, or
general.tex(,1126) (@code{c})ontinue without doing anything (default).
general.tex(,1127) @end itemize
general.tex(,1128) 
general.tex(,1129) Whenever a @sc{Singular} process is started within the Emacs interface,
general.tex(,1130) the contents of a special startup file (by default
general.tex(,1131) @code{~/.emacs-singularrc}) is pasted as input to @sc{Singular} at the
general.tex(,1132) very end of the usual startup sequence (see @ref{Startup sequence}). The
general.tex(,1133) name of the startup file can be changed, see
general.tex(,1134) @ref{Customization of the Emacs interface}.
general.tex(,1135) 
general.tex(,1136) 
general.tex(,1137) @c --------------------------------------------------------------------------
general.tex(,1138) @node Demo mode, Customization of the Emacs interface, Running SINGULAR under Emacs, Emacs user interface
general.tex(,1139) @subsection Demo mode
general.tex(,1140) @cindex Emacs, Singular demo mode
general.tex(,1141) @cindex Singular, demo mode
general.tex(,1142) @cindex Demo mode
general.tex(,1143) 
general.tex(,1144) The Emacs interface can be used to run interactive @sc{Singular}
general.tex(,1145) demonstrations. A demonstration is started by loading a so-called
general.tex(,1146) @sc{Singular} demo file with the Emacs command
general.tex(,1147) @code{singular-demo-load}, bound to
general.tex(,1148) @code{C-c C-d}, or with the menu @code{Commands->Load Demo}.
general.tex(,1149) 
general.tex(,1150) A @sc{Singular} demo file should consist of @sc{Singular} commands
general.tex(,1151) separated by blank lines. When running a demo, the input up to the next
general.tex(,1152) blank line is echoed to the screen. Hitting @key{RETURN} executes the
general.tex(,1153) echoed commands and shows their output. Hitting @key{RETURN} again,
general.tex(,1154) echos the next commands to the screen, and so on, until all commands of
general.tex(,1155) the demo file are executed. While running a demo, you can
general.tex(,1156) execute other commands on the @sc{Singular} prompt: the next input of
general.tex(,1157) from the demo file is then echoed again, if you hit @key{RETURN} on
general.tex(,1158) an empty input line.
general.tex(,1159) 
general.tex(,1160) A @sc{Singular} demo can prematurely be exited by either starting
general.tex(,1161) another demo, or by executing the Emacs command
general.tex(,1162) @code{singular-demo-exit} (menu: @code{Commands->Exit Demo}).
general.tex(,1163) 
general.tex(,1164) Some aspects of running @sc{Singular} demos can be customized.
general.tex(,1165) @xref{Customization of the Emacs interface}, for more info.
general.tex(,1166) 
general.tex(,1167) 
general.tex(,1168) @c --------------------------------------------------------------------------
general.tex(,1169) @node Customization of the Emacs interface, Editing SINGULAR input files with Emacs, Demo mode, Emacs user interface
general.tex(,1170) @subsection Customization of the Emacs interface
general.tex(,1171) @cindex Emacs, customization of Singular mode
general.tex(,1172) @cindex Singular, customization of Emacs user interface
general.tex(,1173) @cindex Customization of the Emacs interface
general.tex(,1174) 
general.tex(,1175) Emacs provides a convenient interface to customize the behavior of
general.tex(,1176) Emacs and the SINGULAR Emacs interface for your own needs. You enter the
general.tex(,1177) customize environment by either calling @code{M-x customize} (on XEmacs
general.tex(,1178) you afterwards have to enter @code{emacs} in the minibuffer area) or by
general.tex(,1179) selecting the menu item @code{Options->Customize->Emacs...} for XEmacs,
general.tex(,1180) and the menu item @code{Help->Customize->Toplevel Customization Group}
general.tex(,1181) for Emacs, resp. A brief introduction to the customization mode comes up
general.tex(,1182) with the customization buffer. All customizable parameters are
general.tex(,1183) hierarchically grouped and you can browse through all these groups and
general.tex(,1184) change the values of the parameters using the mouse. At the end you can
general.tex(,1185) safe the settings to a special file making your changes permanent.
general.tex(,1186) 
general.tex(,1187) To change the settings of the @sc{Singular} Emacs interface you can
general.tex(,1188) either select the item @code{Preferences} of the @code{Singular} menu,
general.tex(,1189) call @code{M-x customize-group} and give the argument
general.tex(,1190) @code{singular-interactive} in the minibuffer area, or browse from the
general.tex(,1191) top-level customization group through the path
general.tex(,1192) @code{External->Singular->Singular interactive}.
general.tex(,1193) 
general.tex(,1194) The @sc{Singular} interface customization buffer is divided into four
general.tex(,1195) groups:
general.tex(,1196) 
general.tex(,1197) @itemize @bullet
general.tex(,1198) @item Singular Faces
general.tex(,1199) 
general.tex(,1200) Here you can specify various faces used if font-lock-mode is enabled
general.tex(,1201) (which it is, by default).
general.tex(,1202) 
general.tex(,1203) @item Singular Sections And Foldings
general.tex(,1204) 
general.tex(,1205) Here you can specify special faces for @sc{Singular} input and output
general.tex(,1206) and change the text used as replacement for folded sections.
general.tex(,1207) 
general.tex(,1208) For doing this, you also might
general.tex(,1209) find handy the function @code{customize-face-at-point},
general.tex(,1210) which let's you customize the face at the current position of
general.tex(,1211) point. This function is automatically defined if you run
general.tex(,1212) @code{ESingular}). Otherwise, you should add its definition (see below)
general.tex(,1213) to your personal @code{.emacs} file.
general.tex(,1214) 
general.tex(,1215) @item Singular Interactive Miscellaneous
general.tex(,1216) 
general.tex(,1217) Here you can specify various different things such as the behavior of
general.tex(,1218) the cursor keys, the name of the special @sc{Singular} startup file, the
general.tex(,1219) appearance of the help window, or the default values for the
general.tex(,1220) @code{singular} command.
general.tex(,1221) @c Time: I find this sentence rather confusing
general.tex(,1222) @c For a first look at customization of the
general.tex(,1223) @c interface, this is probably the best group.
general.tex(,1224) 
general.tex(,1225) 
general.tex(,1226) @item Singular Demo Mode
general.tex(,1227) 
general.tex(,1228) Here you can specify how chunks of the demo file are divided, or specify
general.tex(,1229) a default directory for demo files.
general.tex(,1230) @end itemize
general.tex(,1231) 
general.tex(,1232) When you run @code{ESingular}, the settings of customized variables are
general.tex(,1233) saved in the file @code{$HOME/.emacs-singular-cust}. Otherwise, the
general.tex(,1234) settings are appended to your @code{.emacs} file. Among others, this
general.tex(,1235) means that the customized settings of @code{ESingular} are not
general.tex(,1236) automatically  taken over by a "normal" Emacs, and vice versa.
general.tex(,1237) 
general.tex(,1238) 
general.tex(,1239) @c --------------------------------------------------------------------------
general.tex(,1240) @node Editing SINGULAR input files with Emacs, Top 20 Emacs commands, Customization of the Emacs interface, Emacs user interface
general.tex(,1241) @subsection Editing SINGULAR input files with Emacs
general.tex(,1242) @cindex Emacs, editing Singular input files
general.tex(,1243) @cindex Singular, editing input files with Emacs
general.tex(,1244) @cindex Editing SINGULAR input files with Emacs
general.tex(,1245) 
general.tex(,1246) Since @sc{Singular}'s programming language is similar to C, you
general.tex(,1247) should use the Emacs C/C++-mode to edit @sc{Singular} input files and
general.tex(,1248) @sc{Singular} libraries. Among others, this Emacs mode provides
general.tex(,1249) automatic indentation, line-breaking and keyword highlighting.
general.tex(,1250) 
general.tex(,1251) When running @code{ESingular}, the C/C++-mode is automatically turned on
general.tex(,1252) whenever a file with the suffix @code{.sing}, or @code{.lib} is loaded.
general.tex(,1253) 
general.tex(,1254) For Emacs sessions which were not started by @code{ESingular},  you
general.tex(,1255) should add the following to your @code{.emacs} file:
general.tex(,1256) @smallexample
general.tex(,1257) ;; turn on c++-mode for files ending in ".sing" and ".lib"
general.tex(,1258) (setq auto-mode-alist (cons '("\\.sing\\'" . c++-mode) auto-mode-alist))
general.tex(,1259) (setq auto-mode-alist (cons '("\\.lib\\'" .  c++-mode) auto-mode-alist))
general.tex(,1260) ;; turn-on fontification for c++-mode
general.tex(,1261) (add-hook 'c++-mode-hook
general.tex(,1262)          (function (lambda () (font-lock-mode 1))))
general.tex(,1263) ;; turn on aut-new line and hungry-delete
general.tex(,1264) (add-hook 'c++-mode-hook
general.tex(,1265)           (function (lambda () (c-toggle-auto-hungry-state 1))))
general.tex(,1266) ;; a handy function for customization
general.tex(,1267) (defun customize-face-at-point ()
general.tex(,1268)   "Customize face which point is at."
general.tex(,1269)   (interactive)
general.tex(,1270)   (let ((face (get-text-property (point) 'face)))
general.tex(,1271)     (if face
general.tex(,1272)         (customize-face face)
general.tex(,1273)       (message "No face defined at point"))))
general.tex(,1274) 
general.tex(,1275) @end smallexample
general.tex(,1276) 
general.tex(,1277) Notice that you can change the default settings for source-code
general.tex(,1278) highlighting (colors, fonts, etc.) by customizing the respective faces
general.tex(,1279) using the @code{Customize} feature of Emacs. For doing this, you might
general.tex(,1280) find handy the above given function @code{customize-face-at-point},
general.tex(,1281) which lets you customize the face of the current position of point (this
general.tex(,1282) function is automatically defined if you run @code{ESingular}).
general.tex(,1283) 
general.tex(,1284) @c --------------------------------------------------------------------------
general.tex(,1285) @node Top 20 Emacs commands,,Editing SINGULAR input files with Emacs, Emacs user interface
general.tex(,1286) @subsection Top 20 Emacs commands
general.tex(,1287) @cindex Emacs, important commands
general.tex(,1288) @cindex Singular, important commands of Emacs interface
general.tex(,1289) @cindex Top 20 Emacs commands
general.tex(,1290) 
general.tex(,1291) Here is a list of the 20 probably most useful commands when using the
general.tex(,1292) @sc{Singular} Emacs interface.
general.tex(,1293) 
general.tex(,1294) Starting and stopping of @sc{Singular}:
general.tex(,1295) 
general.tex(,1296) @itemize @bullet
general.tex(,1297) 
general.tex(,1298) @item @code{singular} (menu @code{Singular->Start Default...}): starts
general.tex(,1299) @sc{Singular} using default arguments.
general.tex(,1300) 
general.tex(,1301) @item @code{singular-other} (menu @code{Singular->Start}): starts
general.tex(,1302) @sc{Singular} asking for several arguments in the minibuffer area.
general.tex(,1303) 
general.tex(,1304) @item @code{singular-exit} (key @code{C-c $} or menu
general.tex(,1305) @code{Singular->Exit}): kills the @sc{Singular} process running in the
general.tex(,1306) current buffer (but does not kill the buffer).
general.tex(,1307) 
general.tex(,1308) @item @code{singular-restart} (key @code{C-c C-r} or menu
general.tex(,1309) @code{Singular->Restart}): kills the @sc{Singular} process running in
general.tex(,1310) the current buffer and starts a new @sc{Singular} process with exactly
general.tex(,1311) the same arguments as before.
general.tex(,1312) 
general.tex(,1313) @end itemize
general.tex(,1314) 
general.tex(,1315) Editing input and output:
general.tex(,1316) 
general.tex(,1317) @itemize @bullet
general.tex(,1318) 
general.tex(,1319) @item @code{singular-beginning-of-line} (key @code{C-a}): moves point to
general.tex(,1320) beginning of line, then skip past the @sc{Singular} prompt, if any.
general.tex(,1321) 
general.tex(,1322) @item @code{singular-toggle-truncate-lines} (key @code{C-c C-t} or menu
general.tex(,1323) @code{Commands->Truncate lines}): toggles whether long lines should be
general.tex(,1324) truncated or not. If lines are not truncated, the commands
general.tex(,1325) @code{singular-scroll-left} and @code{singular-scroll-right} are useful
general.tex(,1326) to scroll left and right, resp.
general.tex(,1327) 
general.tex(,1328) @item @code{singular-dynamic-complete} (key @code{TAB}): performs
general.tex(,1329) context specific completion. If point is inside a string, file name
general.tex(,1330) completion is done. If point is at the end of a help command (i.e.,
general.tex(,1331) @code{help} or @code{?}), completion on @sc{Singular} help topics is
general.tex(,1332) done. If point is at the end of an example command (i.e.,
general.tex(,1333) @code{example}), completion is done on @sc{Singular} examples. In all
general.tex(,1334) other cases, completion on @sc{Singular} commands is done.
general.tex(,1335) 
general.tex(,1336) @c note: add space between Fold/ Unfold to avoid overfull line
general.tex(,1337) @item @code{singular-folding-toggle-fold-latest-output} (key @code{C-c
general.tex(,1338) C-o} or menu @code{Commands->Fold/ Unfold Latest Output}): toggles
general.tex(,1339) folding of the latest output section. If your last @sc{Singular} command
general.tex(,1340) produced a huge output, simply type @code{C-c C-o} and it will be
general.tex(,1341) replaced by a single line.
general.tex(,1342) 
general.tex(,1343) @item @code{singular-folding-toggle-fold-at-point} (key @code{C-c C-f}
general.tex(,1344) or menu @code{Commands->Fold/Unfold At Point}): toggles folding of the
general.tex(,1345) section the point currently is in.
general.tex(,1346) 
general.tex(,1347) @item @code{singular-folding-fold-all-output} (menu @code{Commands->Fold
general.tex(,1348) All Output}): folds all @sc{Singular} output, replacing each output
general.tex(,1349) section by a single line.
general.tex(,1350) 
general.tex(,1351) @item @code{singular-folding-unfold-all-output} (menu
general.tex(,1352) @code{Commands->Unfold All Output}): unfolds all @sc{Singular} output
general.tex(,1353) sections showing their true contents.
general.tex(,1354) 
general.tex(,1355) @end itemize
general.tex(,1356) 
general.tex(,1357) Loading of files and @sc{Singular} demo mode:
general.tex(,1358) 
general.tex(,1359) @itemize @bullet
general.tex(,1360) 
general.tex(,1361) @item @code{singular-load-library} (key @code{C-c C-l} or menu
general.tex(,1362) @code{Commands->Libraries->other...}): asks for a standard library name
general.tex(,1363) or a library file in the minibuffer (hit @code{TAB} for completion) and
general.tex(,1364) loads the library into @sc{Singular}. The submenu @code{Libraries} of
general.tex(,1365) the @code{Commands} menu also provides a separate menu item for each
general.tex(,1366) standard library.
general.tex(,1367) 
general.tex(,1368) @item @code{singular-load-file} (key @code{C-c <} or menu
general.tex(,1369) @code{Commands->Load File...}): asks for a file name in the minibuffer
general.tex(,1370) (which is expanded using @code{expand-file-name} if given a prefix
general.tex(,1371) argument) and loads the file into @sc{Singular}.
general.tex(,1372) 
general.tex(,1373) @item @code{singular-demo-load} (key @code{C-c C-d} or menu
general.tex(,1374) @code{Commands->Load Demo...}): asks for a file name of a @sc{Singular}
general.tex(,1375) demo file in the minibuffer area (hit @code{SPACE} for completion) and
general.tex(,1376) enters the @sc{Singular} demo mode showing the first chunk of the demo.
general.tex(,1377) 
general.tex(,1378) @item @code{singular-demo-exit} (menu @code{Commands->Exit Demo}):
general.tex(,1379) exits from @sc{Singular} demo mode and cleans up everything that is
general.tex(,1380) left from the demo.
general.tex(,1381) 
general.tex(,1382) @end itemize
general.tex(,1383) 
general.tex(,1384) Help and Customization:
general.tex(,1385) 
general.tex(,1386) @itemize @bullet
general.tex(,1387) 
general.tex(,1388) @item @code{singular-help} (key @code{C-h C-s} or menu
general.tex(,1389) @code{Singular->Singular Help}): asks for a @sc{Singular} help topic in
general.tex(,1390) the minibuffer (hit @code{TAB} for completion) and shows the help text
general.tex(,1391) in a separate buffer.
general.tex(,1392) 
general.tex(,1393) @item @code{singular-example} (key @code{C-c C-e} or menu
general.tex(,1394) @code{Singular->Singular Example}): asks for a @sc{Singular} command in
general.tex(,1395) the minibuffer (hit @code{TAB} for completion) and executes the example
general.tex(,1396) of this command in the current @sc{Singular} buffer.
general.tex(,1397) 
general.tex(,1398) @item @code{customize-group} (menu @code{Singular->Preferences}): enters
general.tex(,1399) the customization group of the @sc{Singular} Emacs interface. (If called
general.tex(,1400) via @code{M-x customize-group} give argument @code{singular-interactive}
general.tex(,1401) in the minibuffer area.)
general.tex(,1402) 
general.tex(,1403) @end itemize
general.tex(,1404) 
general.tex(,1405) 
general.tex(,1406) @c ---------------------------------------------------------------------------
general.tex(,1407) @c ---------------------------------------------------------------------------
general.tex(,1408) @node Rings and orderings, Implemented algorithms, Emacs user interface, General concepts
general.tex(,1409) @section Rings and orderings
general.tex(,1410) @cindex Rings and orderings
general.tex(,1411) 
general.tex(,1412) All non-trivial algorithms in @sc{Singular} require the prior definition of
general.tex(,1413) a ring. Such a ring can be
general.tex(,1414) 
general.tex(,1415) @enumerate
general.tex(,1416) @item
general.tex(,1417) a polynomial ring over a field,
general.tex(,1418) @item
general.tex(,1419) a localization of a polynomial ring,
general.tex(,1420) @item
general.tex(,1421) a quotient ring by an ideal of one of 1.@: or 2.,
general.tex(,1422) @item
general.tex(,1423) a tensor product of one of 1.@: or 2.
general.tex(,1424) @end enumerate
general.tex(,1425) 
general.tex(,1426) Except for quotient rings, all of these rings are realized by choosing a
general.tex(,1427) coefficient field, ring variables, and an appropriate global or local
general.tex(,1428) monomial ordering on the ring variables.  @xref{Term orderings},
general.tex(,1429) @ref{Mathematical background}.
general.tex(,1430) 
general.tex(,1431) The coefficient field of the rings may be
general.tex(,1432) 
general.tex(,1433) @cindex real
general.tex(,1434) @cindex complex
general.tex(,1435) @enumerate
general.tex(,1436) @item
general.tex(,1437) the field of rational numbers 
general.tex(,1444) ,
general.tex(,1445) @item
general.tex(,1452) @item
general.tex(,1459) @item
general.tex(,1460) transcendental extension of 
general.tex(,1467)  or 
general.tex(,1474) ,
general.tex(,1475) @item
general.tex(,1476) simple algebraic extension of 
general.tex(,1483)  or 
general.tex(,1490) ,
general.tex(,1491) @item
general.tex(,1492) the field of real numbers represented by floating point
general.tex(,1493) numbers of a user defined precision.
general.tex(,1494) @item
general.tex(,1495) the field of complex numbers represented by (pairs of) floating point
general.tex(,1496) numbers of a user defined precision.
general.tex(,1497) @end enumerate
general.tex(,1498) 
general.tex(,1499) Throughout this manual, the current active ring in @sc{Singular} is
general.tex(,1500) called basering.  The reserved name @code{basering} in @sc{Singular} is
general.tex(,1501) an alias for the current active ring.  The basering can be set by
general.tex(,1502) declaring a new ring as described in the following subsections or with
general.tex(,1503) the commands @code{setring} and @code{keepring}.  @xref{keepring},
general.tex(,1504) @ref{setring}.
general.tex(,1505) 
general.tex(,1506) Objects of ring dependent types are local to a ring. To access them
general.tex(,1507) after a change of the basering they have to be mapped using @code{map} or by
general.tex(,1508) the functions @code{imap} or @code{fetch}.  @xref{Objects}, @ref{fetch},
general.tex(,1509) @ref{imap}, @ref{map}.
general.tex(,1510) 
general.tex(,1511) All changes of the basering in a procedure are local to this procedure
general.tex(,1512) unless a @code{keepring} command is used as the last statement of the
general.tex(,1513) procedure.  @xref{Procedures}, @ref{keepring}.
general.tex(,1514) 
general.tex(,1515) @menu
general.tex(,1516) * Examples of ring declarations::
general.tex(,1517) * General syntax of a ring declaration::
general.tex(,1518) * Term orderings::
general.tex(,1519) @end menu
general.tex(,1520) 
general.tex(,1521) @c --------------------------------------
general.tex(,1522) @node Examples of ring declarations, General syntax of a ring declaration, Rings and orderings, Rings and orderings
general.tex(,1523) @subsection Examples of ring declarations
general.tex(,1524) @cindex Examples of ring declarations
general.tex(,1525) 
general.tex(,1526) The exact syntax of a ring declaration is given in the next two
general.tex(,1527) subsections; this subsection lists some examples first. Note that the
general.tex(,1528) ordering has to be chosen such that the unit-elements of the
general.tex(,1529) ring are precisely those elements with leading monomial 1.  For more
general.tex(,1530) information, see @ref{Monomial orderings}.
general.tex(,1531) 
general.tex(,1532) Every floating point number in a ring consists of two parts, which may be
general.tex(,1533) chosen from the user. The leading part represents the number and the rest
general.tex(,1534) is for the numerical stability. Two numbers with a difference only in the
general.tex(,1535) rest are equal.
general.tex(,1536) 
general.tex(,1537) @itemize @bullet
general.tex(,1538) @item
general.tex(,1539) the ring 
general.tex(,1546)  with degree reverse lexicographical
general.tex(,1547) ordering.  The exact ring declaration may be omitted in the first
general.tex(,1548) example since this is the default ring:
general.tex(,1549) 
general.tex(,1550) @smallexample
general.tex(,1551) ring r;
general.tex(,1552) ring r = 32003,(x,y,z),dp;
general.tex(,1553) @end smallexample
general.tex(,1554) 
general.tex(,1555) @item
general.tex(,1556) the ring 
general.tex(,1563)  with lexicographical ordering:
general.tex(,1564) 
general.tex(,1565) @smallexample
general.tex(,1566) ring r = 0,(a,b,c,d),lp;
general.tex(,1567) @end smallexample
general.tex(,1568) 
general.tex(,1569) @item
general.tex(,1570) the ring 
general.tex(,1577)  with local degree reverse lexicographical
general.tex(,1578) ordering.  The non-prime 10 is converted to the next lower prime in the
general.tex(,1579) second example:
general.tex(,1580) 
general.tex(,1581) @smallexample
general.tex(,1582) ring r = 7,(x,y,z),ds;
general.tex(,1583) ring r = 10,(x,y,z),ds;
general.tex(,1584) @end smallexample
general.tex(,1585) 
general.tex(,1586) @item
general.tex(,1587) the ring
general.tex(,1594) with lexicographical ordering for
general.tex(,1601) and degree reverse lexicographical ordering for
general.tex(,1608) 
general.tex(,1609) @smallexample
general.tex(,1610) ring r = 7,(x(1..6)),(lp(3),dp);
general.tex(,1611) @end smallexample
general.tex(,1612) 
general.tex(,1613) @item
general.tex(,1614) the localization of 
general.tex(,1621)  at the maximal ideal
general.tex(,1622) 
general.tex(,1629) :
general.tex(,1630) 
general.tex(,1631) @smallexample
general.tex(,1632) ring r = 0,(x,y,z,a,b,c),(ds(3), dp(3));
general.tex(,1633) @end smallexample
general.tex(,1634) 
general.tex(,1635) @item
general.tex(,1636) the ring 
general.tex(,1643)  with weighted reverse lexicographical ordering.
general.tex(,1644) The variables 
general.tex(,1651) , 
general.tex(,1658) , and 
general.tex(,1665)  have the weights 2, 1,
general.tex(,1666) and 3, respectively, and  vectors are first ordered by components (in
general.tex(,1667) descending order) and then by monomials:
general.tex(,1668) @smallexample
general.tex(,1669) ring r = 0,(x,y,z),(c,wp(2,1,3));
general.tex(,1670) @end smallexample
general.tex(,1671) For ascending component order, the component ordering @code{C} has to be
general.tex(,1672) used.
general.tex(,1673) 
general.tex(,1674) @item
general.tex(,1675) the ring 
general.tex(,1682) , where 
general.tex(,1689)  denotes the transcendental
general.tex(,1690) extension of 
general.tex(,1697)  by 
general.tex(,1704) , 
general.tex(,1711)  and 
general.tex(,1718)  with degree
general.tex(,1719) lexicographical ordering:
general.tex(,1720) 
general.tex(,1721) @smallexample
general.tex(,1722) ring r = (7,a,b,c),(x,y,z),Dp;
general.tex(,1723) @end smallexample
general.tex(,1724) 
general.tex(,1725) @item
general.tex(,1726) the ring 
general.tex(,1733) , where 
general.tex(,1740)  denotes the algebraic extension of
general.tex(,1741) degree 2 of 
general.tex(,1748)  by 
general.tex(,1755)  In other words, 
general.tex(,1762)  is the finite field with
general.tex(,1763) 49 elements.  In the first case, 
general.tex(,1770)  denotes an algebraic
general.tex(,1771) element over 
general.tex(,1778)  with minimal polynomial
general.tex(,1785) in the second case, 
general.tex(,1792) 
general.tex(,1793) refers to some generator of the cyclic group of units of 
general.tex(,1800) :
general.tex(,1801) 
general.tex(,1802) @smallexample
general.tex(,1803) ring r = (7,a),(x,y,z),dp; minpoly = a^2+a+3;
general.tex(,1804) ring r = (7^2,a),(x,y,z),dp;
general.tex(,1805) @end smallexample
general.tex(,1806) 
general.tex(,1807) @item
general.tex(,1808) the ring 
general.tex(,1815) , where 
general.tex(,1822)  denotes the field of real
general.tex(,1823) numbers represented by simple precision floating point numbers. This is
general.tex(,1824) a special case:
general.tex(,1825) 
general.tex(,1826) @smallexample
general.tex(,1827) ring r = real,(x,y,z),dp;
general.tex(,1828) @end smallexample
general.tex(,1829) 
general.tex(,1830) @item
general.tex(,1831) the ring 
general.tex(,1838) , where 
general.tex(,1845)  denotes the field of real
general.tex(,1846) numbers represented by floating point numbers of 50 valid decimal digits
general.tex(,1847) and the same number of digits for the rest:
general.tex(,1848) 
general.tex(,1849) @smallexample
general.tex(,1850) ring r = (real,50),(x,y,z),dp;
general.tex(,1851) @end smallexample
general.tex(,1852) 
general.tex(,1853) @item
general.tex(,1854) the ring 
general.tex(,1861) , where 
general.tex(,1868)  denotes the field of real
general.tex(,1869) numbers represented by floating point numbers of 10 valid decimal digits
general.tex(,1870) and with 50 digits for the rest:
general.tex(,1871) 
general.tex(,1872) @smallexample
general.tex(,1873) ring r = (real,10,50),(x,y,z),dp;
general.tex(,1874) @end smallexample
general.tex(,1875) 
general.tex(,1876) @item
general.tex(,1877) the ring 
general.tex(,1884) , where 
general.tex(,1891)  denotes the field of real
general.tex(,1892) numbers represented by floating point numbers of 30 valid decimal digits
general.tex(,1893) and the same number for the rest. 
general.tex(,1900)  denotes the imaginary unit.
general.tex(,1901) 
general.tex(,1902) @smallexample
general.tex(,1903) ring r = (complex,30,j),(x,y,z),dp;
general.tex(,1904) @end smallexample
general.tex(,1905) 
general.tex(,1906) @item
general.tex(,1907) the ring 
general.tex(,1914) , where 
general.tex(,1921)  denotes the field of real
general.tex(,1922) numbers represented by floating point numbers of 6 valid decimal digits
general.tex(,1923) and the same number for the rest. 
general.tex(,1930)  is the default for the imaginary unit.
general.tex(,1931) 
general.tex(,1932) @smallexample
general.tex(,1933) ring r = complex,(x,y,z),dp;
general.tex(,1934) @end smallexample
general.tex(,1935) 
general.tex(,1936) @item
general.tex(,1937) the quotient ring 
general.tex(,1944)  modulo the square of the maximal
general.tex(,1945) ideal 
general.tex(,1952) :
general.tex(,1953) 
general.tex(,1954) @smallexample
general.tex(,1955) ring R = 7,(x,y,z), dp;
general.tex(,1956) qring r = std(maxideal(2));
general.tex(,1957) @end smallexample
general.tex(,1958) @end itemize
general.tex(,1959) 
general.tex(,1960) @c ---------------------------------------------------------------------------
general.tex(,1961) @node General syntax of a ring declaration, Term orderings, Examples of ring declarations, Rings and orderings
general.tex(,1962) @subsection General syntax of a ring declaration
general.tex(,1963) @cindex General syntax of a ring declaration
general.tex(,1964) 
general.tex(,1965) @subsubheading Rings
general.tex(,1966) @c ------------------------------------------------------------
general.tex(,1967) @c   This piece of text (partially) exists also in the
general.tex(,1968) @c   file types.doc, chapter "ring declarations".
general.tex(,1969) @c   If you change something here, change it there, too!
general.tex(,1970) @c ------------------------------------------------------------
general.tex(,1971) @table @strong
general.tex(,1972) @item Syntax:
general.tex(,1973) @code{ring} name @code{=} @code{(}coefficient_field@code{),}
general.tex(,1974)   @code{(} names_of_ring_variables @code{),}
general.tex(,1975)   @code{(} ordering @code{);}
general.tex(,1976) @item Default:
general.tex(,1977) @code{32003,(x,y,z),(dp,C);}
general.tex(,1978) @item Purpose:
general.tex(,1979) declares a ring and sets it as the current basering.
general.tex(,1980) @end table
general.tex(,1981) 
general.tex(,1982) The coefficient_field is given by one of the following:
general.tex(,1983) @enumerate
general.tex(,1984) @item
general.tex(,1985) a non-negative int_expression less or equal 32003.
general.tex(,1986) @* The int_expression should either be 0, specifying the field of
general.tex(,1987) rational numbers Q, or a prime number p, specifying the finite field
general.tex(,1988) with p elements.  If it is not a prime number, int_expression is
general.tex(,1989) converted to the next lower prime number.
general.tex(,1990) 
general.tex(,1991) @item
general.tex(,1992) an expression_list of an int_expression and one or more names.
general.tex(,1993) @* The int_expression specifies the characteristic of the coefficient
general.tex(,1994) field as described above. The names are used as parameters in
general.tex(,1995) transcendental or algebraic extensions of the coefficient
general.tex(,1996) field. Algebraic extensions are implemented for one parameter only. In
general.tex(,1997) this case, a minimal polynomial has to be defined by assignment to
general.tex(,1998) @code{minpoly}. @xref{minpoly}.
general.tex(,1999) 
general.tex(,2000) @item
general.tex(,2001) an expression_list of an int_expression and a name.
general.tex(,2002) @* The int_expression has to be a prime number p to the power of a
general.tex(,2003) positive integer n. This defines the Galois field
general.tex(,2010) The given name refers to a primitive element of
general.tex(,2017) generating the multiplicative group.  Due to a different internal
general.tex(,2018) representation, the arithmetic operations in these coefficient fields
general.tex(,2019) are faster than arithmetic operations in algebraic extensions as
general.tex(,2020) described above.
general.tex(,2021) 
general.tex(,2022) @item
general.tex(,2023) an expression_list of the name @code{real} and two optional int_expression
general.tex(,2024) giving the precision in decimal digits and
general.tex(,2025) the size for the stabilizing rest. The default for the rest is the same size
general.tex(,2026) as for the representation.
general.tex(,2027) An exception is the name @code{real} without any integers.
general.tex(,2028) These numbers are implemented as machine floating point numbers
general.tex(,2029) of single precision.
general.tex(,2030) Note that computations over all these fields are not exact.
general.tex(,2031) 
general.tex(,2032) @item
general.tex(,2033) an expression_list of the name @code{complex},
general.tex(,2034) two optional int_expression and a name.
general.tex(,2035) This specifies the field of complex numbers represented with floating point
general.tex(,2036) numbers with a precision similar to @code{real}. An expression_list
general.tex(,2037) without int_expression defines a precision and rest with length 6.
general.tex(,2038) The name of the imaginary unit is given by the last parameter.
general.tex(,2039) Note that computations over these fields are not exact.
general.tex(,2040) @end enumerate
general.tex(,2041) 
general.tex(,2042) 'names_of_ring_variables' is a list of names or indexed names.
general.tex(,2043) 
general.tex(,2044) 'ordering' is a list of block orderings where each block ordering is either
general.tex(,2045) 
general.tex(,2046) @enumerate
general.tex(,2047) @item
general.tex(,2048) @code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, or @code{Ds}
general.tex(,2049) optionally followed by a size parameter in parentheses.
general.tex(,2050) 
general.tex(,2051) @item
general.tex(,2052) @code{wp}, @code{Wp}, @code{ws}, @code{Ws}, or @code{a} followed by a
general.tex(,2053) weight vector given as an intvec_expression in parentheses.
general.tex(,2054) 
general.tex(,2055) @item
general.tex(,2056) @code{M} followed by an intmat_expression in parentheses.
general.tex(,2057) 
general.tex(,2058) @item
general.tex(,2059) @code{c} or @code{C}.
general.tex(,2060) @end enumerate
general.tex(,2061) 
general.tex(,2062) For the definition of the orderings, see @ref{Monomial orderings}.
general.tex(,2063) 
general.tex(,2064) If one of coefficient_field, names_of_ring_variables, and ordering
general.tex(,2065) consists of only one entry, the parentheses around this entry may be
general.tex(,2066) omitted.
general.tex(,2067) @c ------------------------------------------------------------
general.tex(,2068) @c   End of duplicate piece of text.
general.tex(,2069) @c ------------------------------------------------------------
general.tex(,2070) 
general.tex(,2071) @subsubheading Quotient rings
general.tex(,2072) @c ------------------------------------------------------------
general.tex(,2073) @c   This piece of text (partially) exists also in the
general.tex(,2074) @c   file types.doc, chapter "qring declarations", and in
general.tex(,2075) @c   singular.doc, chapter "Miscellaneous oddities".
general.tex(,2076) @c   If you change something here, change it there, too!
general.tex(,2077) @c ------------------------------------------------------------
general.tex(,2078) @table @strong
general.tex(,2079) @item Syntax:
general.tex(,2080) @code{qring} name @code{=} ideal_expression @code{;}
general.tex(,2081) @item Default:
general.tex(,2082) none
general.tex(,2083) @item Purpose:
general.tex(,2084) declares a quotient ring as the basering modulo ideal_expression.  Sets
general.tex(,2085) it as current basering.
general.tex(,2086) @end table
general.tex(,2087) 
general.tex(,2088) ideal_expression has to be represented by a standard basis.
general.tex(,2089) 
general.tex(,2090) The most convenient way to map objects from a ring to its quotient ring
general.tex(,2091) and vice versa is to use the @code{fetch} function (@pxref{fetch}).
general.tex(,2092) 
general.tex(,2093) @sc{Singular} computes in a quotient ring as long as possible with the
general.tex(,2094) given representative of a polynomial, say, @code{f}.  I.e., it usually
general.tex(,2095) does not reduce @code{f} w.r.t. the quotient ideal.  This is only done
general.tex(,2096) when necessary
general.tex(,2097) during standard bases computations or by an explicit reduction using
general.tex(,2098) the command @code{reduce(f, std(0))} (@pxref{reduce}).
general.tex(,2099) 
general.tex(,2100) @strong{Example:}
general.tex(,2101) @smallexample
general.tex(,2102) @c computed example Quotient_rings general.doc:1784 
general.tex(,2103)   ring r=32003,(x,y),dp;
general.tex(,2104)   poly f=x3+yx2+3y+4;
general.tex(,2105)   qring q=std(maxideal(2));
general.tex(,2106)   basering;
general.tex(,2107) @expansion{} //   characteristic : 32003
general.tex(,2108) @expansion{} //   number of vars : 2
general.tex(,2109) @expansion{} //        block   1 : ordering dp
general.tex(,2110) @expansion{} //                  : names    x y 
general.tex(,2111) @expansion{} //        block   2 : ordering C
general.tex(,2112) @expansion{} // quotient ring from ideal
general.tex(,2113) @expansion{} _[1]=y2
general.tex(,2114) @expansion{} _[2]=xy
general.tex(,2115) @expansion{} _[3]=x2
general.tex(,2116)   poly g=fetch(r, f);
general.tex(,2117)   g;
general.tex(,2118) @expansion{} x3+x2y+3y+4
general.tex(,2119)   reduce(g,std(0));
general.tex(,2120) @expansion{} 3y+4
general.tex(,2121) @c end example Quotient_rings general.doc:1784
general.tex(,2122) @end smallexample
general.tex(,2123) 
general.tex(,2124) @c ------------------------------------------------------------
general.tex(,2125) @c   End of duplicate piece of text.
general.tex(,2126) @c ------------------------------------------------------------
general.tex(,2127) 
general.tex(,2128) @c ---------------------------------------------------------------------------
general.tex(,2129) @node Term orderings,  , General syntax of a ring declaration, Rings and orderings
general.tex(,2130) @subsection Term orderings
general.tex(,2131) @cindex Monomial orderings, Term orderings
general.tex(,2132) 
general.tex(,2133) Any polynomial (resp.@: vector) in @sc{Singular} is ordered w.r.t. a
general.tex(,2134) term ordering (or, monomial ordering), which has to be specified
general.tex(,2135) together with the declaration of a ring. @sc{Singular} stores and
general.tex(,2136) displays a polynomial (resp.@: vector) w.r.t. this ordering, i.e., the
general.tex(,2137) greatest monomial (also called the leading monomial) is the first one
general.tex(,2138) appearing in the output polynomial, and the smallest monomial is the last one.
general.tex(,2139) 
general.tex(,2140) @strong{Remark:} The novice user should generally use the ordering
general.tex(,2141) @code{dp} for computations in the polynomial ring
general.tex(,2148) resp.@:  @code{ds} for computations in the localization
general.tex(,2155) For more details, see @ref{Polynomial data}.
general.tex(,2156) 
general.tex(,2157) In a ring declaration, @sc{Singular} offers the following orderings:
general.tex(,2158) @enumerate
general.tex(,2159) @item Global orderings
general.tex(,2160) @table @asis
general.tex(,2161) @item @code{lp}
general.tex(,2162) lexicographical ordering
general.tex(,2163) 
general.tex(,2164) @item @code{dp}
general.tex(,2165) degree reverse lexicographical ordering
general.tex(,2166) 
general.tex(,2167) @item @code{Dp}
general.tex(,2168) degree lexicographical ordering
general.tex(,2169) 
general.tex(,2170) @item @code{wp(} intvec_expression @code{)}
general.tex(,2171) weighted reverse lexicographical ordering; the weight vector may
general.tex(,2172) consist of positive integers only.
general.tex(,2173) 
general.tex(,2174) @item @code{Wp(} intvec_expression @code{)}
general.tex(,2175) weighted lexicographical ordering; the weight vector may consist of
general.tex(,2176) positive integers only.
general.tex(,2177) @end table
general.tex(,2178) 
general.tex(,2179) Global orderings are well-orderings, i.e., 
general.tex(,2186)  for each ring
general.tex(,2187) variable 
general.tex(,2194) . They are denoted by a @code{p} as the second
general.tex(,2195) character in their name.
general.tex(,2196) 
general.tex(,2197) @item Local orderings
general.tex(,2198) @table @asis
general.tex(,2199) @item @code{ls}
general.tex(,2200) negative lexicographical ordering
general.tex(,2201) 
general.tex(,2202) @item @code{ds}
general.tex(,2203) negative degree reverse lexicographical ordering
general.tex(,2204) 
general.tex(,2205) @item @code{Ds}
general.tex(,2206) negative degree lexicographical ordering
general.tex(,2207) 
general.tex(,2208) @item @code{ws(} intvec_expression @code{)}
general.tex(,2209) (general) weighted reverse lexicographical ordering; the first element
general.tex(,2210) of the weight vector has to be non-zero.
general.tex(,2211) 
general.tex(,2212) @item @code{Ws(} intvec_expression @code{)}
general.tex(,2213) (general) weighted lexicographical ordering; the first element
general.tex(,2214) of the weight vector has to be non-zero.
general.tex(,2215) @end table
general.tex(,2216) 
general.tex(,2217) Local orderings are not well-orderings. They are denoted by an @code{s}
general.tex(,2218) as the second character in their name.
general.tex(,2219) 
general.tex(,2220) @item Matrix orderings
general.tex(,2221) @table @asis
general.tex(,2222) @item @code{M(} intmat_expression @code{)}
general.tex(,2223) intmat_expression has to be an invertible square matrix
general.tex(,2224) @end table
general.tex(,2225) 
general.tex(,2226) Using matrix orderings, @sc{Singular} can compute standard bases
general.tex(,2227) w.r.t.@: any monomial ordering that is compatible with the natural
general.tex(,2228) semi-group structure on the monomials. In practice, the predefined global
general.tex(,2229) and local orderings together with the block orderings should be
general.tex(,2230) sufficient in most cases. These orderings are faster than their
general.tex(,2231) corresponding matrix orderings since evaluation of a matrix ordering is
general.tex(,2232) time consuming.
general.tex(,2233) 
general.tex(,2234) @item Extra weight vector
general.tex(,2235) @table @asis
general.tex(,2236) @item @code{a(} intvec_expression @code{)}
general.tex(,2237) an extra weight vector @code{a(} intvec_expression @code{)} may precede
general.tex(,2238) any monomial ordering
general.tex(,2239) @end table
general.tex(,2240) 
general.tex(,2241) @item Product ordering
general.tex(,2242) @table @asis
general.tex(,2243) @item @code{(} ordering [ @code{(} int_expression @code{)} ]@code{,} @dots{} @code{)}
general.tex(,2244) any of the above orderings and the extra weight vector may be combined
general.tex(,2245) to yield product or block orderings
general.tex(,2246) @end table
general.tex(,2247) 
general.tex(,2248) The orderings @code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, and
general.tex(,2249) @code{Ds} may be followed by an int_expression in parentheses giving the
general.tex(,2250) size of the block. For the last block the size is calculated
general.tex(,2251) automatically. For the weighted orderings the size of the block is given
general.tex(,2252) by the size of the weight vector. The same holds analogously for matrix
general.tex(,2253) orderings.
general.tex(,2254) 
general.tex(,2255) @item Module orderings
general.tex(,2256) @table @asis
general.tex(,2257) @itemx @code{(} ordering@code{,} @dots{}@code{, C )}
general.tex(,2258) @item @code{(} ordering@code{,} @dots{}@code{, c )}
general.tex(,2259) sort polynomial vectors by the monomial ordering first, then by
general.tex(,2260) components
general.tex(,2261) 
general.tex(,2262) @itemx @code{( C,} ordering@code{,} @dots{} @code{)}
general.tex(,2263) @item @code{( c,} ordering@code{,} @dots{} @code{)}
general.tex(,2264) sort polynomial vectors by components first, then by the monomial
general.tex(,2265) ordering
general.tex(,2266) @end table
general.tex(,2267) 
general.tex(,2268) Here a capital @code{C} sorts generators in ascending order, i.e.,
general.tex(,2269) @code{gen(1)} < @code{gen(2)} < @enddots{} A small @code{c} sorts in
general.tex(,2270) descending order, i.e., @code{gen(1)} > @code{gen(2)} > @enddots{} It is
general.tex(,2271) not necessary to specify the module ordering explicitly since @code{(}
general.tex(,2272) ordering@code{,} @dots{}@code{, C )} is the default.
general.tex(,2273) 
general.tex(,2274) In fact, @code{c} or @code{C} may be specified anywhere in a product
general.tex(,2275) ordering specification, not only at its beginning or end.  All monomial
general.tex(,2276) block orderings preceding the component ordering have higher precedence,
general.tex(,2277) all monomial block orderings following after it have lower precedence.
general.tex(,2278) @end enumerate
general.tex(,2279) 
general.tex(,2280) For a mathematical description of these orderings, see
general.tex(,2281) @ref{Polynomial data}.
general.tex(,2282) 
general.tex(,2283) @c ---------------------------------------------------------------------------
general.tex(,2284) @node Implemented algorithms, The SINGULAR language, Rings and orderings, General concepts
general.tex(,2285) @section Implemented algorithms
general.tex(,2286) @cindex Implemented algorithms
general.tex(,2287) 
general.tex(,2288) The basic algorithm in @sc{Singular} is a general standard basis algorithm for
general.tex(,2289) any monomial ordering which is compatible with the natural semi-group
general.tex(,2290) structure of the exponents. This includes well-orderings
general.tex(,2291) (Buchberger algorithm to compute a Groebner basis)
general.tex(,2292) and tangent cone orderings (Mora algorithm) as special cases.
general.tex(,2293) 
general.tex(,2294) Nonetheless, there are a lot of other important algorithms:
general.tex(,2295) @itemize @bullet
general.tex(,2296) 
general.tex(,2297) @item
general.tex(,2298) Algorithms to compute the standard operations on ideals and modules:
general.tex(,2299) intersection, ideal quotient, elimination, etc.
general.tex(,2300) 
general.tex(,2301) @item
general.tex(,2302) Different Syzygy algorithms and algorithms to compute free resolutions
general.tex(,2303) of modules.
general.tex(,2304) 
general.tex(,2305) @item
general.tex(,2306) Combinatorial algorithms to compute dimensions, Hilbert series,
general.tex(,2307) multiplicities, etc.
general.tex(,2308) 
general.tex(,2309) @item
general.tex(,2310) Algorithms for univariate and multivariate polynomial factorization,
general.tex(,2311) resultant and gcd computations.
general.tex(,2312) @end itemize
general.tex(,2313) 
general.tex(,2314) @c ----------------------------------------------------------------------
general.tex(,2315) @subheading Commands to compute standard bases
general.tex(,2316) @table @code
general.tex(,2317) @item facstd
general.tex(,2318) @ref{facstd}
general.tex(,2319) @*computes a list of Groebner bases via the Factorizing Groebner Basis
general.tex(,2320) Algorithm, i.e., their intersection has the same radical as the original ideal. It need not
general.tex(,2321) be a Groebner basis of the given ideal.
general.tex(,2322) 
general.tex(,2323) The intersection of the zero-sets is the zero-set of the given ideal.
general.tex(,2324) @item fglm
general.tex(,2325) @ref{fglm}
general.tex(,2326) @*computes a Groebner basis provided that a reduced Groebner basis
general.tex(,2327) w.r.t.@: another ordering is given.
general.tex(,2328) 
general.tex(,2329) Implements the so-called FGLM (Faugere, Gianni, Lazard, Mora) algorithm.
general.tex(,2330) The given ideal must be zero-dimensional.
general.tex(,2331) @item groebner
general.tex(,2332) @ref{groebner}@*
general.tex(,2333) computes a standard resp.@: Groebner bases using a heuristically chosen
general.tex(,2334) method.
general.tex(,2335) 
general.tex(,2336) This is the preferred method to compute a standard resp.@: Groebner
general.tex(,2337) bases.
general.tex(,2338) @item mstd
general.tex(,2339) @ref{mstd}
general.tex(,2340) @*computes a standard basis and a minimal set of generators.
general.tex(,2341) @item std
general.tex(,2342) @ref{std}
general.tex(,2343) @*computes a standard resp.@: Groebner basis.
general.tex(,2344) @item stdfglm
general.tex(,2345) @ref{stdfglm}
general.tex(,2346) @*computes a Groebner basis in a ring with a ``difficult'' ordering
general.tex(,2347) (e.g., lexicographical) via @code{std} w.r.t.@: a ``simple'' ordering and
general.tex(,2348) @code{fglm}.
general.tex(,2349) 
general.tex(,2350) The given ideal must be zero-dimensional.
general.tex(,2351) @item stdhilb
general.tex(,2352) @ref{stdhilb}@*
general.tex(,2353) computes a Groebner basis in a ring with a ``difficult'' ordering
general.tex(,2354) (e.g., lexicographical) via @code{std} w.r.t.@: a ``simple'' ordering
general.tex(,2355) and a @code{std} computation guided by the Hilbert series.
general.tex(,2356) @end table
general.tex(,2357) 
general.tex(,2358) @c ----------------------------------------------------------------------
general.tex(,2359) @subheading Further processing of standard bases
general.tex(,2360) The next commands require the input to be a standard basis.
general.tex(,2361) 
general.tex(,2362) @table @code
general.tex(,2363) @item degree
general.tex(,2364) @ref{degree}
general.tex(,2365) @*computes the (Krull) dimension, codimension and the multiplicity.
general.tex(,2366) 
general.tex(,2367) The result is only displayed on the screen.
general.tex(,2368) @item dim
general.tex(,2369) @ref{dim}@*
general.tex(,2370) computes the dimension of the ideal resp.@: module.
general.tex(,2371) @item highcorner
general.tex(,2372) @ref{highcorner}@*
general.tex(,2373) computes the smallest monomial not contained in the ideal resp.@: module.
general.tex(,2374) The ideal resp.@: module has to be finite dimensional as a vector space
general.tex(,2375) over the ground field.
general.tex(,2376) @item hilb
general.tex(,2377) @ref{hilb}@*
general.tex(,2378) computes the first, and resp.@: or, second Hilbert series of an ideal
general.tex(,2379) resp.@: module.
general.tex(,2380) @item kbase
general.tex(,2381) @ref{kbase}@* computes a vector space basis (consisting of monomials) of
general.tex(,2382) the quotient of a ring by an ideal resp.@: of a free module by a
general.tex(,2383) submodule.
general.tex(,2384) 
general.tex(,2385) The ideal resp.@: module has to be finite dimensional as a vector space
general.tex(,2386) over the ground field and has to be represented by a standard basis w.r.t.@:
general.tex(,2387) the ring ordering.
general.tex(,2388) @item mult
general.tex(,2389) @ref{mult}@*
general.tex(,2390) computes the degree of the monomial ideal resp.@: module generated by
general.tex(,2391) the leading monomials of the input.
general.tex(,2392) @item reduce
general.tex(,2393) @ref{reduce}@*
general.tex(,2394) reduces a polynomial, vector, ideal or module to its normal form with
general.tex(,2395) respect to an ideal or module represented by a standard basis.
general.tex(,2396) @item vdim
general.tex(,2397) @ref{vdim}@*
general.tex(,2398) computes the vector space dimension of a ring (resp.@: free module)
general.tex(,2399) modulo an ideal (resp.@: module).
general.tex(,2400) @end table
general.tex(,2401) 
general.tex(,2402) @c ----------------------------------------------------------------------
general.tex(,2403) @subheading Commands to compute resolutions
general.tex(,2404) @table @code
general.tex(,2405) @item res
general.tex(,2406) @ref{res}@*
general.tex(,2407) computes a free resolution of an ideal or module using a heuristically
general.tex(,2408) chosen method.
general.tex(,2409) This is the preferred method to compute free resolutions of ideals or
general.tex(,2410) modules.
general.tex(,2411) @item lres
general.tex(,2412) @ref{lres}@*
general.tex(,2413) computes a free resolution of an ideal or module with La Scala's
general.tex(,2414) method. The input needs to be homogeneous.
general.tex(,2415) @item mres
general.tex(,2416) @ref{mres}@*
general.tex(,2417) computes a minimal free resolution of an ideal or module with the Syzygy
general.tex(,2418) method.
general.tex(,2419) @item sres
general.tex(,2420) @ref{sres}@*
general.tex(,2421) computes a free resolution of an ideal or module with Schreyer's
general.tex(,2422) method. The input has to be a standard basis.
general.tex(,2423) @item nres
general.tex(,2424) @ref{nres}@*
general.tex(,2425) computes a free resolution of an ideal or module with the standard basis
general.tex(,2426) method.
general.tex(,2427) @item syz
general.tex(,2428) @ref{syz}@*
general.tex(,2429) computes the first Syzygy (i.e., the module of relations of the
general.tex(,2430) given generators).
general.tex(,2431) @end table
general.tex(,2432) 
general.tex(,2433) @c ----------------------------------------------------------------------
general.tex(,2434) @subheading Further processing of resolutions
general.tex(,2435) @table @code
general.tex(,2436) @item betti
general.tex(,2437) @ref{betti}@*
general.tex(,2438) computes the graded Betti numbers of a module from a free resolution.
general.tex(,2439) @item minres
general.tex(,2440) @ref{minres}@*
general.tex(,2441) minimizes a free resolution of an ideal or module.
general.tex(,2442) @item regularity
general.tex(,2443) @ref{regularity}@*
general.tex(,2444) computes the regularity of a homogeneous ideal resp.@: module from a given
general.tex(,2445) minimal free resolution.
general.tex(,2446) @end table
general.tex(,2447) 
general.tex(,2448) @c ----------------------------------------------------------------------
general.tex(,2449) @subheading Processing of polynomials
general.tex(,2450) @table @code
general.tex(,2451) @item char_series
general.tex(,2452) @ref{char_series}@*
general.tex(,2453) computes characteristic sets of polynomial ideals.
general.tex(,2454) @item extgcd
general.tex(,2455) @ref{extgcd}@*
general.tex(,2456) computes the extended gcd of two polynomials.
general.tex(,2457) 
general.tex(,2458) Implemented as extended Euclidean Algorithm.  Applicable for univariate
general.tex(,2459) polynomials only.
general.tex(,2460) @item factorize
general.tex(,2461) @ref{factorize}@*
general.tex(,2462) computes factorization of univariate and multivariate polynomials into
general.tex(,2463) irreducible factors.
general.tex(,2464) 
general.tex(,2465) The most basic algorithm is univariate factorization in prime
general.tex(,2466) characteristic.  The Cantor-Zassenhaus Algorithm is used in this case.
general.tex(,2467) For characteristic 0, a univariate Hensel-lifting is done to lift from
general.tex(,2468) prime characteristic to characteristic 0.  For multivariate
general.tex(,2469) factorization in any characteristic, the problem is reduced to the
general.tex(,2470) univariate case first, then a multivariate Hensel-lifting is used to
general.tex(,2471) lift the univariate factorization.
general.tex(,2472) 
general.tex(,2473) Note that there is no factorization of polynomials over algebraic
general.tex(,2474) extensions of Q.
general.tex(,2475) @item gcd
general.tex(,2476) @ref{gcd}@*
general.tex(,2477) computes greatest common divisors of univariate and multivariate polynomials.
general.tex(,2478) 
general.tex(,2479) For prime characteristic, a subresultant gcd is used.  In characteristic 0, a
general.tex(,2480) modular algorithm is used for the univariate case.  For the multivariate case,
general.tex(,2481) the EZGCD is used.
general.tex(,2482) 
general.tex(,2483) Note that there is no gcd calculation for polynomials over algebraic
general.tex(,2484) extensions of Q.
general.tex(,2485) @item resultant
general.tex(,2486) @ref{resultant}@*
general.tex(,2487) computes the resultant of two univariate polynomials using the subresultant
general.tex(,2488) algorithm.
general.tex(,2489) 
general.tex(,2490) Multivariate polynomials are considered as univariate polynomials in the
general.tex(,2491) main variable (which has to be specified by the user).
general.tex(,2492) @item vandermonde
general.tex(,2493) @ref{vandermonde}@*
general.tex(,2494) interpolates a polynomial from its values at several points
general.tex(,2495) @end table
general.tex(,2496) 
general.tex(,2497) @c ----------------------------------------------------------------------
general.tex(,2498) @subheading Matrix computations
general.tex(,2499) @table @code
general.tex(,2500) @item bareiss
general.tex(,2501) @ref{bareiss}@*
general.tex(,2502) implements sparse Gauss-Bareiss method for elimination (matrix
general.tex(,2503) triangularization) in arbitrary integral domains.
general.tex(,2504) @item det
general.tex(,2505) @ref{det}@*
general.tex(,2506) computes the determinant of a square matrix.
general.tex(,2507) 
general.tex(,2508) For matrices with integer entries a modular algorithm is used.  For
general.tex(,2509) other domains the Gauss-Bareiss method is used.
general.tex(,2510) @item minor
general.tex(,2511) @ref{minor}@*
general.tex(,2512) computes all minors (=subdeterminants) of a given size for a matrix.
general.tex(,2513) @end table
general.tex(,2514) 
general.tex(,2515) @c ----------------------------------------------------------------------
general.tex(,2516) @subheading Numeric computations
general.tex(,2517) @table @code
general.tex(,2518) @item laguerre
general.tex(,2519) @ref{laguerre}@*
general.tex(,2520) computes all (complex) roots of a univariate polynomial
general.tex(,2521) @item uressolve
general.tex(,2522) @ref{uressolve}@*
general.tex(,2523) find all roots of 0-dimensional ideal i with multivariate resultants
general.tex(,2524) @end table
general.tex(,2525) 
general.tex(,2526) @c ----------------------------------------------------------------------
general.tex(,2527) @subheading Controlling computations
general.tex(,2528) @table @code
general.tex(,2529) @item option
general.tex(,2530) @ref{option}@*
general.tex(,2531) allows setting of options for manipulating the behavior of computations
general.tex(,2532) (such as reduction strategies) and for showing protocol information indicating
general.tex(,2533) the progress of a computation.
general.tex(,2534) @end table
general.tex(,2535) 
general.tex(,2536) @c ---------------------------------------------------------------------------
general.tex(,2537) @node The SINGULAR language, Input and output, Implemented algorithms, General concepts
general.tex(,2538) @section The SINGULAR language
general.tex(,2539) @cindex The SINGULAR language
general.tex(,2540) 
general.tex(,2541) @sc{Singular} interprets commands given interactively on the command
general.tex(,2542) line as well as given in the context of user-defined procedures.  In
general.tex(,2543) fact, @sc{Singular} makes no distinction between these two cases.
general.tex(,2544) Thus, @sc{Singular} offers a powerful programming language as well as
general.tex(,2545) an easy-to-use command line interface without differences in syntax or
general.tex(,2546) semantics.
general.tex(,2547) 
general.tex(,2548) In the following, the basic language concepts such as commands,
general.tex(,2549) expressions, names, objects, etc., are discussed.  @xref{Procedures},
general.tex(,2550) and @ref{Libraries},
general.tex(,2551) for the concepts of procedures
general.tex(,2552) and libraries.
general.tex(,2553) 
general.tex(,2554) In many aspects, the @sc{Singular} language is similar to the C
general.tex(,2555) programming language.  For a description of some of the subtle
general.tex(,2556) differences, see @ref{Major differences to the C programming language}.
general.tex(,2557) 
general.tex(,2558) @subsubheading Elements of the language
general.tex(,2559) 
general.tex(,2560) The major building blocks of the @sc{Singular} language  are
general.tex(,2561) expressions, commands, and control structures.  The notion of expressions
general.tex(,2562) in the @sc{Singular} and the C programming language are identical,
general.tex(,2563) whereas the notion of commands and control structures only roughly
general.tex(,2564) corresponds to the C statements.
general.tex(,2565) 
general.tex(,2566) @itemize @bullet
general.tex(,2567) 
general.tex(,2568) @item
general.tex(,2569) An ``expression'' is a sequence of operators, functions, and operands
general.tex(,2570) that specifies a computation.  An expression always results in a
general.tex(,2571) value of a specific type.  @xref{Data types}, and its subsections (e.g.,
general.tex(,2572) @ref{poly expressions}), for information on how to build expressions.
general.tex(,2573) 
general.tex(,2574) @item
general.tex(,2575) A ``command'' is either a declaration, an assignment, a call to a
general.tex(,2576) function without return value, or a print command.  For detailed
general.tex(,2577) information, see @ref{General command syntax}.
general.tex(,2578) 
general.tex(,2579) @item
general.tex(,2580) ``Control structures'' determine the execution sequence of commands.
general.tex(,2581) @sc{Singular} provides control structures for conditional execution
general.tex(,2582) (@code{if} @dots{} @code{else}) and iteration (@code{for} and
general.tex(,2583) @code{while}).  Commands may be grouped in pairs of @code{@{} @code{@}}
general.tex(,2584) (curly brackets) to form blocks.  @xref{Control structures}, for
general.tex(,2585) more information.
general.tex(,2586) @end itemize
general.tex(,2587) 
general.tex(,2588) @subsubheading Other notational conventions
general.tex(,2589) For user-defined functions, the notion of ``procedure'' and
general.tex(,2590) ``function'' are synonymous.
general.tex(,2591) 
general.tex(,2592) As already mentioned above, functions without return values are called
general.tex(,2593) commands.  Furthermore, whenever convenient, the term ``command'' is
general.tex(,2594) used for a function, even if it does return a value.
general.tex(,2595) 
general.tex(,2596) @menu
general.tex(,2597) * General command syntax::
general.tex(,2598) * Special characters::
general.tex(,2599) * Names::
general.tex(,2600) * Objects::
general.tex(,2601) * Type conversion and casting::
general.tex(,2602) * Flow control::
general.tex(,2603) @end menu
general.tex(,2604) 
general.tex(,2605) @c ---------------------------------------------------------------------------
general.tex(,2606) @node General command syntax, Special characters, The SINGULAR language, The SINGULAR language
general.tex(,2607) @subsection General command syntax
general.tex(,2608) @cindex General command syntax
general.tex(,2609) 
general.tex(,2610) In @sc{Singular} a command is either a declaration, an assignment, a
general.tex(,2611) call to a function without return value, or a print command. The general
general.tex(,2612) form of a command is described in the following subsections.
general.tex(,2613) 
general.tex(,2614) @subsubheading Declaration
general.tex(,2615) @enumerate
general.tex(,2616) @item type name @code{=} expression @code{;}
general.tex(,2617) @* declares a variable with the given name of the given type and assigns
general.tex(,2618) the expression as initial value to it.  Expression is an expression of
general.tex(,2619) the specified type or one that can be converted to that type.
general.tex(,2620) @xref{Type conversion and casting}.
general.tex(,2621) 
general.tex(,2622) @item type name_list @code{=} expression_list @code{;}
general.tex(,2623) @* declares variables with the given names and assigns successively each
general.tex(,2624) expression of expression_list to the corresponding name of
general.tex(,2625) name_list.  Both lists must be of the same length.  Each expression in
general.tex(,2626) expression_list is an expression of the specified type or one that can
general.tex(,2627) be converted to that type.  @xref{Type conversion and casting}.
general.tex(,2628) 
general.tex(,2629) @item type name @code{;}
general.tex(,2630) @* declares a variable with the given name of the given type and assigns
general.tex(,2631) the default value of the specific type to it.
general.tex(,2632) @end enumerate
general.tex(,2633) 
general.tex(,2634) @xref{Names}, for more information on declarations.  @xref{Data types},
general.tex(,2635) for a description of all data types known to @sc{Singular}.
general.tex(,2636) 
general.tex(,2637) @smallexample
general.tex(,2638) ring r;                   // the default ring
general.tex(,2639) poly f,g = x^2+y^3,xy+z2; // the polynomials f=x^2+y^3 and g=x*y+z^2
general.tex(,2640) ideal I = f,g;            // the ideal generated by f and g
general.tex(,2641) matrix m[3][3];           // a 3 x 3 zero matrix
general.tex(,2642) int i=2;                  // the integer i=2
general.tex(,2643) @end smallexample
general.tex(,2644) 
general.tex(,2645) @subsubheading Assignment
general.tex(,2646) @enumerate 4
general.tex(,2647) @item
general.tex(,2648) name @code{=} expression @code{;}
general.tex(,2649) @* assigns expression to name.
general.tex(,2650) 
general.tex(,2651) @item
general.tex(,2652) name_list @code{=} expression_list @code{;}
general.tex(,2653) @* assigns successively each expression of expression_list to the
general.tex(,2654) corresponding name of name_list. Both lists must be of the same
general.tex(,2655) length.  This is not a simultaneous assignment.  Thus, @code{f, g = g, f;} does
general.tex(,2656) not swap the values of @code{f} and @code{g}, but rather assigns
general.tex(,2657) @code{g} to both @code{f} and @code{g}.
general.tex(,2658) @end enumerate
general.tex(,2659) 
general.tex(,2660) There must be a type conversion of the type of expression to the type of
general.tex(,2661) name. @xref{Type conversion and casting}.
general.tex(,2662) 
general.tex(,2663) An assignment itself does not yield a value. Hence, compound assignments
general.tex(,2664) like @code{i = j = k;} are not allowed and result in an error.
general.tex(,2665) 
general.tex(,2666) @smallexample
general.tex(,2667) f = x^2 + y^2 ;      // overwrites the old value of f
general.tex(,2668) I = jacob(f);
general.tex(,2669) f,g = I[1],x^2+y^2 ; // overwrites the old values of f and g
general.tex(,2670) @end smallexample
general.tex(,2671) 
general.tex(,2672) @subsubheading Function without return value
general.tex(,2673) @enumerate 6
general.tex(,2674) @item
general.tex(,2675) function_name [ @code{(} argument_list @code{)} ] @code{;}
general.tex(,2676) @* calls function function_name with arguments argument_list.
general.tex(,2677) @end enumerate
general.tex(,2678) 
general.tex(,2679) The function may have output (not to be confused with a return value of
general.tex(,2680) type string). @xref{Functions}. Functions without a return value are
general.tex(,2681) specified there to have a return type 'none'.
general.tex(,2682) 
general.tex(,2683) Some of these functions have to be called without parentheses, e.g.,
general.tex(,2684) @code{help}, @code{LIB}.
general.tex(,2685) 
general.tex(,2686) @smallexample
general.tex(,2687) @c computed example Function_without_return_value general.doc:2344 
general.tex(,2688)   ring r;
general.tex(,2689)   ideal i=x2+y2,x;
general.tex(,2690)   i=std(i);
general.tex(,2691)   degree(i);        // degree has no return value but prints output
general.tex(,2692) @expansion{} 2
general.tex(,2693) @c end example Function_without_return_value general.doc:2344
general.tex(,2694) @end smallexample
general.tex(,2695) 
general.tex(,2696) @subsubheading Print command
general.tex(,2697) @enumerate 7
general.tex(,2698) @item
general.tex(,2699) expression @code{;}
general.tex(,2700) @* prints the value of an expression, for example, of a variable.
general.tex(,2701) @end enumerate
general.tex(,2702) 
general.tex(,2703) Use the function @code{print} (or the procedure show from inout.lib)
general.tex(,2704) to get a pretty output of various data
general.tex(,2705) types, e.g., matrix or intmat. @xref{print}.
general.tex(,2706) 
general.tex(,2707) @smallexample
general.tex(,2708) @c computed example Print_command general.doc:2364 
general.tex(,2709)   int i=2;
general.tex(,2710)   i;
general.tex(,2711) @expansion{} 2
general.tex(,2712)   intmat m[2][2]=1,7,10,0;
general.tex(,2713)   print(m);
general.tex(,2714) @expansion{}      1     7
general.tex(,2715) @expansion{}     10     0
general.tex(,2716) @c end example Print_command general.doc:2364
general.tex(,2717) @end smallexample
general.tex(,2718) 
general.tex(,2719) @c ------------------------------------------------------------
general.tex(,2720) @node Special characters, Names, General command syntax, The SINGULAR language
general.tex(,2721) @subsection Special characters
general.tex(,2722) @cindex Special characters
general.tex(,2723) The following characters and operators have special meaning:
general.tex(,2724) @table @asis
general.tex(,2725) @item @code{=}
general.tex(,2726) @cindex =
general.tex(,2727) assignment
general.tex(,2728) @item @code{(}, @code{)}
general.tex(,2729) @cindex (
general.tex(,2730) @cindex )
general.tex(,2731) @cindex indexed names
general.tex(,2732) in expressions, for indexed names and for argument lists
general.tex(,2733) @item @code{[}, @code{]}
general.tex(,2734) @cindex [
general.tex(,2735) @cindex ]
general.tex(,2736) access operator for strings, integer vectors, ideals, matrices,
general.tex(,2737) polynomials, resolutions, and lists.  Used to build vectors of
general.tex(,2738) polynomials.  Example: @code{s[3]}, @code{m[1,3]}, @code{i[1..3]},
general.tex(,2739) @code{[f,g+x,0,0,1]}.
general.tex(,2740) @item @code{+}
general.tex(,2741) @cindex +
general.tex(,2742) addition operator
general.tex(,2743) @item @code{-}
general.tex(,2744) @cindex -
general.tex(,2745) subtraction operator
general.tex(,2746) @item @code{*}
general.tex(,2747) @cindex *
general.tex(,2748) multiplication operator
general.tex(,2749) @item @code{/}
general.tex(,2750) @cindex /
general.tex(,2751) division  operator.  @xref{Miscellaneous oddities}, for the difference
general.tex(,2752) between the division operators @code{/} and @code{div}.
general.tex(,2753) @item @code{%}
general.tex(,2754) @cindex %
general.tex(,2755) modulo operator
general.tex(,2756) @item @code{^} or @code{**}
general.tex(,2757) @cindex ^
general.tex(,2758) @cindex **
general.tex(,2759) exponentiation operator
general.tex(,2760) @item @code{==}
general.tex(,2761) @cindex ==
general.tex(,2762) comparison operator equal
general.tex(,2763) @item @code{!=} or @code{<>}
general.tex(,2764) @cindex !=
general.tex(,2765) @cindex <>
general.tex(,2766) comparison operator not equal
general.tex(,2767) @item @code{>=}
general.tex(,2768) @cindex >=
general.tex(,2769) comparison operator bigger or equal
general.tex(,2770) @item @code{>}
general.tex(,2771) @cindex >
general.tex(,2772) comparison operator bigger
general.tex(,2773) @item @code{<=}
general.tex(,2774) @cindex <=
general.tex(,2775) comparison operator smaller or equal
general.tex(,2776) @item @code{<}
general.tex(,2777) @cindex <
general.tex(,2778) comparison operator smaller.  Also used for file input.  @xref{filecmd}.
general.tex(,2779) @item @code{!}
general.tex(,2780) @cindex !
general.tex(,2781) boolean operator not
general.tex(,2782) @item @code{&&}
general.tex(,2783) @cindex &&
general.tex(,2784) boolean operator and
general.tex(,2785) @item @code{||}
general.tex(,2786) @cindex ||
general.tex(,2787) boolean operator or
general.tex(,2788) @item @code{"}
general.tex(,2789) @cindex "
general.tex(,2790) delimiter for string constants
general.tex(,2791) @item @code{`}
general.tex(,2792) @cindex `
general.tex(,2793) delimiter for name substitution
general.tex(,2794) @item @code{?}
general.tex(,2795) @cindex ?
general.tex(,2796) synonym for @code{help}
general.tex(,2797) @item @code{//}
general.tex(,2798) @cindex //
general.tex(,2799) comment delimiter.  Comment extends to end of line.
general.tex(,2800) @item @code{/*}
general.tex(,2801) @cindex //
general.tex(,2802) comment delimiter.  Starts a comment which ends with @code{*/}.
general.tex(,2803) @item @code{*/}
general.tex(,2804) @cindex //
general.tex(,2805) comment delimiter.  Ends a comment which starts with @code{/*}.
general.tex(,2806) @item @code{;}
general.tex(,2807) @cindex ;
general.tex(,2808) statement separator
general.tex(,2809) @item @code{,}
general.tex(,2810) separator for expression lists and function arguments
general.tex(,2811) @item @code{\}
general.tex(,2812) @cindex \
general.tex(,2813) escape character for @code{"} and @code{\} within strings
general.tex(,2814) @item @code{..}
general.tex(,2815) @cindex ..
general.tex(,2816) interval specifier returning intvec.
general.tex(,2817) E.g., @code{1..3} which is equivalent to the intvec @code{1, 2, 3}.
general.tex(,2818) @item @code{_}
general.tex(,2819) @cindex _
general.tex(,2820) value of expression last displayed
general.tex(,2821) @item @code{~}
general.tex(,2822) @cindex ~
general.tex(,2823) breakpoint in procedures
general.tex(,2824) @item @code{#}
general.tex(,2825) @cindex #
general.tex(,2826) list of parameters in procedures without explicit parameter list
general.tex(,2827) @item @code{$}
general.tex(,2828) @cindex $
general.tex(,2829) terminates @sc{Singular}
general.tex(,2830) @end table
general.tex(,2831) 
general.tex(,2832) @c ------------------------------------------------------------
general.tex(,2833) @node Names, Objects, Special characters, The SINGULAR language
general.tex(,2834) @subsection Names
general.tex(,2835) @cindex Names
general.tex(,2836) @cindex Identifiers, syntax of
general.tex(,2837) 
general.tex(,2838) @sc{Singular} is a strongly typed language.  This means that all names
general.tex(,2839) (= identifiers) have to be declared prior to their use.  For the general
general.tex(,2840) syntax of a declaration, see the description of declaration commands
general.tex(,2841) (@pxref{General command syntax}).
general.tex(,2842) 
general.tex(,2843) @xref{Data types}, for a description of @sc{Singular}'s data types.
general.tex(,2844) @xref{typeof}, for a short overview of possible types.  To get information
general.tex(,2845) on a name and the object named by it, the @code{type} command may be
general.tex(,2846) used (@pxref{type}).
general.tex(,2847) 
general.tex(,2848) It is possible to redefine an already existing name if doing so does not
general.tex(,2849) change its type. A redefinition first sets the variable to the default
general.tex(,2850) value and then computes the expression. The difference between
general.tex(,2851) redefining and overwriting a variable is shown in the following example:
general.tex(,2852) 
general.tex(,2853) @smallexample
general.tex(,2854) @c computed example Names general.doc:2507 
general.tex(,2855)   int i=3;
general.tex(,2856)   i=i+1;        // overwriting
general.tex(,2857)   i;
general.tex(,2858) @expansion{} 4
general.tex(,2859)   int i=i+1;    // redefinition
general.tex(,2860) @expansion{} // ** redefining i **
general.tex(,2861)   i;
general.tex(,2862) @expansion{} 1
general.tex(,2863) @c end example Names general.doc:2507
general.tex(,2864) @end smallexample
general.tex(,2865) 
general.tex(,2866) User defined names should start with a letter and consist of letters and
general.tex(,2867) digits only.  As an exception to this rule, the characters @code{@@},
general.tex(,2868) and @code{_} may
general.tex(,2869) be used as part of a name, too.  Capital and small letters are
general.tex(,2870) distinguished.  Indexed names are built as a name followed by an
general.tex(,2871) int_expression in parentheses.  A list of indexed names can be built as
general.tex(,2872) a name followed by an intvec_expression in parentheses.
general.tex(,2873) 
general.tex(,2874) @smallexample
general.tex(,2875) @c computed example Names_1 general.doc:2525 
general.tex(,2876)   ring R;
general.tex(,2877)   int n=3;
general.tex(,2878)   ideal j(3);
general.tex(,2879)   ideal j(n);     // is equivalent to the above
general.tex(,2880) @expansion{} // ** redefining j(3) **
general.tex(,2881)   ideal j(2)=x;
general.tex(,2882)   j(2..3);
general.tex(,2883) @expansion{} j(2)[1]=x j(3)[1]=0
general.tex(,2884) @c end example Names_1 general.doc:2525
general.tex(,2885) @end smallexample
general.tex(,2886) 
general.tex(,2887) Names may not coincide with reserved names (keywords).  Type
general.tex(,2888) @code{reservedName();} to get a list of the reserved names.
general.tex(,2889) @xref{reservedName}.  Names should not interfere with names of ring
general.tex(,2890) variables or, more generally, with monomials.  @xref{Identifier
general.tex(,2891) resolution}.
general.tex(,2892) @* The command @code{listvar} provides a list of the names in use
general.tex(,2893) (@pxref{listvar}).
general.tex(,2894) 
general.tex(,2895) The most recently printed expression is available
general.tex(,2896) under the special name @code{_}, e.g.,
general.tex(,2897) @smallexample
general.tex(,2898) @c computed example Names_2 general.doc:2546 
general.tex(,2899)   ring r;
general.tex(,2900)   ideal i=x2+y3,y3+z4;
general.tex(,2901)   std(i);
general.tex(,2902) @expansion{} _[1]=y3+x2
general.tex(,2903) @expansion{} _[2]=z4-x2
general.tex(,2904)   ideal k=_;
general.tex(,2905)   k*k+x;
general.tex(,2906) @expansion{} _[1]=y6+2x2y3+x4
general.tex(,2907) @expansion{} _[2]=y3z4+x2z4-x2y3-x4
general.tex(,2908) @expansion{} _[3]=z8-2x2z4+x4
general.tex(,2909) @expansion{} _[4]=x
general.tex(,2910)   size(_[3]);
general.tex(,2911) @expansion{} 3
general.tex(,2912) @c end example Names_2 general.doc:2546
general.tex(,2913) @end smallexample
general.tex(,2914) 
general.tex(,2915) A string_expression enclosed in @code{`}@dots{}@code{`} (back ticks)
general.tex(,2916) evaluates to the value of the variable named by the string_expression.
general.tex(,2917) This feature is referred to as name substitution.
general.tex(,2918) 
general.tex(,2919) @smallexample
general.tex(,2920) @c computed example Names_3 general.doc:2561 
general.tex(,2921)   int foo(1)=42;
general.tex(,2922)   string bar="foo";
general.tex(,2923)   `bar+"(1)"`;
general.tex(,2924) @expansion{} 42
general.tex(,2925) @c end example Names_3 general.doc:2561
general.tex(,2926) @end smallexample
general.tex(,2927) 
general.tex(,2928) @c ------------------------------------------------------------
general.tex(,2929) @node Objects, Type conversion and casting, Names, The SINGULAR language
general.tex(,2930) @subsection Objects
general.tex(,2931) @cindex Objects
general.tex(,2932) 
general.tex(,2933) Every object in @sc{Singular} has a type and a value.  In most cases it
general.tex(,2934) has also a name and in some cases an attribute list.  The value of an
general.tex(,2935) object may be examined simply by printing it with a print command:
general.tex(,2936) object@code{;}.  The type of an object may be determined by means of the
general.tex(,2937) @code{typeof} function, the attributes by means of the @code{attrib}
general.tex(,2938) function (@ref{typeof}, @ref{attrib}):
general.tex(,2939) 
general.tex(,2940) @smallexample
general.tex(,2941) @c computed example Objects general.doc:2581 
general.tex(,2942)   ring r=0,x,dp;
general.tex(,2943)   typeof(10);
general.tex(,2944) @expansion{} int
general.tex(,2945)   typeof(10000000000000000);
general.tex(,2946) @expansion{} number
general.tex(,2947)   typeof(r);
general.tex(,2948) @expansion{} ring
general.tex(,2949)   attrib(x);
general.tex(,2950) @expansion{} no attributes
general.tex(,2951)   attrib(std(ideal(x)));
general.tex(,2952) @expansion{} attr:isSB, type int
general.tex(,2953) @c end example Objects general.doc:2581
general.tex(,2954) @end smallexample
general.tex(,2955) 
general.tex(,2956) Each object of type
general.tex(,2957) @code{poly},
general.tex(,2958) @code{ideal},
general.tex(,2959) @code{vector},
general.tex(,2960) @code{module},
general.tex(,2961) @code{map},
general.tex(,2962) @code{matrix},
general.tex(,2963) @code{number}, or
general.tex(,2964) @code{resolution}
general.tex(,2965) belongs to a specific ring.  Also @code{list}, if at least one of the
general.tex(,2966) objects contained in the list belongs to a ring.  These objects are local
general.tex(,2967) to the ring.  Their names can be used for other objects in other rings.
general.tex(,2968) Objects from one ring can be mapped to another ring using maps or with the
general.tex(,2969) commands @code{fetch} or @code{imap}.  @xref{map}, @ref{fetch}, @ref{imap}.
general.tex(,2970) 
general.tex(,2971) All other types do not belong to a ring and can be accessed within every
general.tex(,2972) ring and across rings.  They can be declared even if there is no active
general.tex(,2973) basering.
general.tex(,2974) 
general.tex(,2975) @c ------------------------------------------------------------
general.tex(,2976) @node Type conversion and casting, Flow control, Objects, The SINGULAR language
general.tex(,2977) @subsection Type conversion and casting
general.tex(,2978) 
general.tex(,2979) @subsubheading Type conversion
general.tex(,2980) @cindex Type conversion
general.tex(,2981) Assignments convert the type of the right-hand side to the type of the
general.tex(,2982) left-hand side of the assignment, if possible.  Operators and functions
general.tex(,2983) which require certain types of operands can also implicitly convert the
general.tex(,2984) type of an expression.  It is, for example, possible to multiply a
general.tex(,2985) polynomial by an integer because the integer is automatically converted to
general.tex(,2986) a polynomial.  Type conversions do not act transitively.  Possible
general.tex(,2987) conversions are:
general.tex(,2988) 
general.tex(,2989) 
general.tex(,2990) @c ------------------------------------------------
general.tex(,2991) @c Do not delete the leading `@ ' for indentation of the whole table.  The
general.tex(,2992) @c table is indented since regular @tables are indented by a small amount,
general.tex(,2993) @c too.
general.tex(,2994) @c ------------------------------------------------
general.tex(,2995) @multitable @columnfractions .05 .18 .81
general.tex(,2996) @item
general.tex(,2997) @   1. @tab @code{int}  @tab @expansion{} @code{ideal}
general.tex(,2998) @item
general.tex(,2999) @   2. @tab @code{poly}  @tab @expansion{} @code{ideal}
general.tex(,3000) @item
general.tex(,3001) @   3. @tab @code{intvec}  @tab @expansion{} @code{intmat}
general.tex(,3002) @item
general.tex(,3003) @   4. @tab @code{int}  @tab @expansion{} @code{intvec}
general.tex(,3004) @item
general.tex(,3005) @   5. @tab @code{int}  @tab @expansion{} @code{intmat}
general.tex(,3006) @item
general.tex(,3007) @   6. @tab @code{string}  @tab @expansion{} @code{link}
general.tex(,3008) @item
general.tex(,3009) @   7. @tab @code{resolution} @tab @expansion{} @code{list}
general.tex(,3010) @item
general.tex(,3011) @   8. @tab @code{ideal}  @tab @expansion{} @code{matrix}
general.tex(,3012) @item
general.tex(,3013) @   9. @tab @code{int}  @tab @expansion{} @code{matrix}
general.tex(,3014) @item
general.tex(,3015) @  10. @tab @code{intmat}  @tab @expansion{} @code{matrix}
general.tex(,3016) @item
general.tex(,3017) @  11. @tab @code{intvec}  @tab @expansion{} @code{matrix}
general.tex(,3018) @item
general.tex(,3019) @  12. @tab @code{module}  @tab @expansion{} @code{matrix}
general.tex(,3020) @item
general.tex(,3021) @  13. @tab @code{number}  @tab @expansion{} @code{matrix}
general.tex(,3022) @item
general.tex(,3023) @  14. @tab @code{poly}  @tab @expansion{} @code{matrix}
general.tex(,3024) @item
general.tex(,3025) @  15. @tab @code{vector}  @tab @expansion{} @code{matrix}
general.tex(,3026) @item
general.tex(,3027) @  16. @tab @code{ideal}  @tab @expansion{} @code{module}
general.tex(,3028) @item
general.tex(,3029) @  17. @tab @code{matrix}  @tab @expansion{} @code{module}
general.tex(,3030) @item
general.tex(,3031) @  18. @tab @code{vector}  @tab @expansion{} @code{module}
general.tex(,3032) @item
general.tex(,3033) @  19. @tab @code{int}  @tab @expansion{} @code{number}
general.tex(,3034) @item
general.tex(,3035) @  20. @tab @code{int}  @tab @expansion{} @code{poly}
general.tex(,3036) @item
general.tex(,3037) @  21. @tab @code{number}  @tab @expansion{} @code{poly}
general.tex(,3038) @item
general.tex(,3039) @  22. @tab @code{string}  @tab @expansion{} @code{proc}
general.tex(,3040) @item
general.tex(,3041) @  23. @tab @code{list}  @tab @expansion{} @code{resolution}
general.tex(,3042) @item
general.tex(,3043) @  24. @tab @code{int}  @tab @expansion{} @code{vector}
general.tex(,3044)   (i @expansion{} i*@code{gen(1)})
general.tex(,3045) @item
general.tex(,3046) @  25. @tab @code{poly}  @tab @expansion{} @code{vector}
general.tex(,3047)   (p @expansion{} p*@code{gen(1)})
general.tex(,3048) @end multitable
general.tex(,3049) 
general.tex(,3050) @subsubheading Type casting
general.tex(,3051) @cindex Type casting
general.tex(,3052) An expression can be casted to another type by using a type cast
general.tex(,3053) expression:
general.tex(,3054) @* type @code{(} expression @code{)}.
general.tex(,3055) 
general.tex(,3056) Possible type casts are:
general.tex(,3057) 
general.tex(,3058) @c ------------------------------------------------
general.tex(,3059) @c Do not delete the leading `@ ' for indentation of the whole table.  The
general.tex(,3060) @c table is indented since regular @tables are indented by a small amount,
general.tex(,3061) @c too.
general.tex(,3062) @c ------------------------------------------------
general.tex(,3063) @multitable @columnfractions .05 .15 .83
general.tex(,3064) @item
general.tex(,3065) @    @tab to @tab from
general.tex(,3066) @item
general.tex(,3067) @    @tab  @code{ideal} @tab  expression lists of @code{int}, @code{number}, @code{poly}
general.tex(,3068) @item
general.tex(,3069) @    @tab  @code{ideal} @tab  @code{int}, @code{matrix}, @code{module}, @code{number}, @code{poly}, @code{vector}
general.tex(,3070) @item
general.tex(,3071) @    @tab  @code{int} @tab    @code{number}, @code{poly}
general.tex(,3072) @item
general.tex(,3073) @    @tab  @code{intvec} @tab expression lists of @code{int}, @code{intmat}
general.tex(,3074) @item
general.tex(,3075) @    @tab  @code{intmat} @tab @code{intvec} (@pxref{intmat type cast})
general.tex(,3076) @item
general.tex(,3077) @    @tab  @code{list} @tab   expression lists of any type
general.tex(,3078) @item
general.tex(,3079) @    @tab  @code{matrix} @tab @code{module}, @code{ideal},
general.tex(,3080) @code{vector}, @code{matrix}.
general.tex(,3081) @* There are two forms to convert something to a matrix: if @code{matrix(}
general.tex(,3082) expression @code{)} is used then the size of the matrix is determined
general.tex(,3083) by the size of expression.
general.tex(,3084) @* But @code{matrix(} expression @code{,} m @code{,} n @code{)} may also be
general.tex(,3085) used - the result is a
general.tex(,3092) matrix (@pxref{matrix type cast})
general.tex(,3093) @item
general.tex(,3094) @    @tab  @code{module} @tab expression lists of @code{int}, @code{number},
general.tex(,3095) @code{poly}, @code{vector}
general.tex(,3096) @item
general.tex(,3097) @    @tab  @code{module} @tab @code{ideal}, @code{matrix}, @code{vector}
general.tex(,3098) @item
general.tex(,3099) @    @tab  @code{number} @tab @code{poly}
general.tex(,3100) @item
general.tex(,3101) @   @tab  @code{poly} @tab   @code{int}, @code{number}
general.tex(,3102) @item
general.tex(,3103) @   @tab  @code{string} @tab   any type (@pxref{string type cast})
general.tex(,3104) @end multitable
general.tex(,3105) 
general.tex(,3106) @strong{Example:}
general.tex(,3107) @smallexample
general.tex(,3108) @c computed example Type_casting general.doc:2743 
general.tex(,3109)   ring r=0,x,(c,dp);
general.tex(,3110)   number(3x);
general.tex(,3111) @expansion{} 0
general.tex(,3112)   number(poly(3));
general.tex(,3113) @expansion{} 3
general.tex(,3114)   ideal i=1,2,3,4,5,6;
general.tex(,3115)   print(matrix(i));
general.tex(,3116) @expansion{} 1,2,3,4,5,6
general.tex(,3117)   print(matrix(i,3,2));
general.tex(,3118) @expansion{} 1,2,
general.tex(,3119) @expansion{} 3,4,
general.tex(,3120) @expansion{} 5,6 
general.tex(,3121)   vector v=[1,2];
general.tex(,3122)   print(matrix(v));
general.tex(,3123) @expansion{} 1,
general.tex(,3124) @expansion{} 2 
general.tex(,3125)   module(matrix(i,3,2));
general.tex(,3126) @expansion{} _[1]=[1,3,5]
general.tex(,3127) @expansion{} _[2]=[2,4,6]
general.tex(,3128) @c end example Type_casting general.doc:2743
general.tex(,3129) @end smallexample
general.tex(,3130) 
general.tex(,3131) 
general.tex(,3132) @c ------------------------------------------------------------
general.tex(,3133) @node Flow control, ,Type conversion and casting, The SINGULAR language
general.tex(,3134) @subsection Flow control
general.tex(,3135) @cindex Flow control
general.tex(,3136) @cindex block
general.tex(,3137) 
general.tex(,3138) A block is a sequence of commands surrounded by @{ and @}.
general.tex(,3139) @smallexample
general.tex(,3140) @{
general.tex(,3141)    command;
general.tex(,3142)    @dots{}
general.tex(,3143) @}
general.tex(,3144) @end smallexample
general.tex(,3145) Blocks are used whenever @sc{Singular} is used as a structured programming
general.tex(,3146) language. The @code{if} and @code{else} structures allow conditional
general.tex(,3147) execution of blocks (see @ref{if}, @ref{else}). @code{for} and @code{while}
general.tex(,3148) loops are available for repeated execution of blocks (see @ref{for},
general.tex(,3149) @ref{while}).
general.tex(,3150) In procedure definitions the main part and the example section are blocks
general.tex(,3151) as well(see @ref{proc}).
general.tex(,3152) @menu
general.tex(,3153) * break::
general.tex(,3154) * quit::
general.tex(,3155) * keepring::
general.tex(,3156) * export::
general.tex(,3157) * if::
general.tex(,3158) * else::
general.tex(,3159) * for::
general.tex(,3160) * while::
general.tex(,3161) * proc::
general.tex(,3162) * return::
general.tex(,3163) * continue::
general.tex(,3164) @end menu
general.tex(,3165) 
general.tex(,3166) 
general.tex(,3167) @c ----------------------------------------------------------------------
general.tex(,3168) @c ----------------------------------------------------------------------
general.tex(,3169) @node Input and output, Procedures, The SINGULAR language, General concepts
general.tex(,3170) @section Input and output
general.tex(,3171) @cindex input
general.tex(,3172) @cindex output
general.tex(,3173) 
general.tex(,3174) @sc{Singular}'s input and output (short, I/O) is realized using links.
general.tex(,3175) Links are the communication channels of @sc{Singular}, i.e., something
general.tex(,3176) @sc{Singular} can write to and read from.  In this section, a short
general.tex(,3177) overview of the usage of links and of the different link types is given.
general.tex(,3178) 
general.tex(,3179) For loading of libraries, see @ref{LIB}. For executing program scripts,
general.tex(,3180) see @ref{filecmd}.
general.tex(,3181) 
general.tex(,3182) @subheading Monitoring
general.tex(,3183) A special form of I/O is monitoring.  When monitoring is enabled,
general.tex(,3184) @sc{Singular} makes a typescript of everything printed on your terminal
general.tex(,3185) to a file.  This is
general.tex(,3186) useful to create a protocol of a @sc{Singular} session.  The
general.tex(,3187) @code{monitor} command enables and disables this feature
general.tex(,3188) (@pxref{monitor}).
general.tex(,3189) 
general.tex(,3190) 
general.tex(,3191) @subheading How to use links
general.tex(,3192) Recall that links are the communication channels of @sc{Singular}, i.e.,
general.tex(,3193) something @sc{Singular} can write to and read from using the functions
general.tex(,3194) @code{write} and @code{read}. There are furthermore
general.tex(,3195) the functions @code{dump} and @code{getdump} which store resp.@:
general.tex(,3196) retrieve the content of an entire @sc{Singular} session to, resp.@: from,
general.tex(,3197) a link.  The @code{dump} and @code{getdump} commands are not available
general.tex(,3198) for DBM links.
general.tex(,3199) 
general.tex(,3200) For more information, see @ref{write}, @ref{read}, @ref{dump},
general.tex(,3201) @ref{getdump}.
general.tex(,3202) 
general.tex(,3203) @strong{Example:}
general.tex(,3204) @smallexample
general.tex(,3205) @c computed example How_to_use_links general.doc:2830 
general.tex(,3206)   ring r; poly p = x+y;
general.tex(,3207)   dump("MPfile:w test.mp");   // dump the session to the file test.mp
general.tex(,3208)   kill r;                     // kill the basering
general.tex(,3209)   listvar();
general.tex(,3210) @expansion{} // LIB                  [0]  string standard.lib
general.tex(,3211)   getdump("MPfile:r test.mp");// read the dump from the file
general.tex(,3212)   listvar();
general.tex(,3213) @expansion{} // r                    [0]  *ring
general.tex(,3214) @expansion{} //      p                    [0]  poly
general.tex(,3215) @expansion{} // LIB                  [0]  string standard.lib
general.tex(,3216) @c end example How_to_use_links general.doc:2830
general.tex(,3217) @end smallexample
general.tex(,3218) 
general.tex(,3219) Specifying a link can be as easy as specifying a filename as a string.
general.tex(,3220) Except for MPtcp links, links even do not need to be explicitly opened
general.tex(,3221) or closed before, resp.@: after, they are used.  To explicitly open or
general.tex(,3222) close a link, the @code{open}, resp.@: @code{close}, commands may be
general.tex(,3223) used (see @ref{open}, @ref{close}).
general.tex(,3224) 
general.tex(,3225) Links have various properties which can be queried using the
general.tex(,3226) @code{status} function (@pxref{status}).
general.tex(,3227) 
general.tex(,3228) @strong{Example:}
general.tex(,3229) @smallexample
general.tex(,3230) @c computed example How_to_use_links_1 general.doc:2851 
general.tex(,3231)   link l = "MPtcp:fork";
general.tex(,3232)   l;
general.tex(,3233) @expansion{} // type : MPtcp
general.tex(,3234) @expansion{} // mode : fork
general.tex(,3235) @expansion{} // name : 
general.tex(,3236) @expansion{} // open : no
general.tex(,3237) @expansion{} // read : not ready
general.tex(,3238) @expansion{} // write: not ready
general.tex(,3239)   open(l);
general.tex(,3240)   status(l, "open");
general.tex(,3241) @expansion{} yes
general.tex(,3242)   close(l);
general.tex(,3243)   status(l, "open");
general.tex(,3244) @expansion{} no
general.tex(,3245) @c end example How_to_use_links_1 general.doc:2851
general.tex(,3246) @end smallexample
general.tex(,3247) 
general.tex(,3248) @subheading ASCII links
general.tex(,3249) Data that can be converted to a string that can be written into files for
general.tex(,3250) storage or communication with other programs. The data are written in
general.tex(,3251) plain ASCII format. Reading from an ASCII link returns a string ---
general.tex(,3252) conversion into other data is up to the user. This can be done, for
general.tex(,3253) example, using the command @code{execute} (@pxref{execute}).
general.tex(,3254) 
general.tex(,3255) ASCII links should primarily be used for storing small amounts of data,
general.tex(,3256) especially if it might become necessary to manually inspect or
general.tex(,3257) manipulate the data.
general.tex(,3258) 
general.tex(,3259) @xref{ASCII links}, for more information.
general.tex(,3260) 
general.tex(,3261) @strong{Example:}
general.tex(,3262) @smallexample
general.tex(,3263) @c computed example ASCII_links general.doc:2876 
general.tex(,3264)   // (over)write file test.ascii, link is specified as string
general.tex(,3265)   write(":w test.ascii", "int i =", 3, ";");
general.tex(,3266)   // reading simply returns the string
general.tex(,3267)   read("test.ascii");
general.tex(,3268) @expansion{} int i =
general.tex(,3269) @expansion{} 3
general.tex(,3270) @expansion{} ;
general.tex(,3271) @expansion{} 
general.tex(,3272)   // but now test.ascii is "executed"
general.tex(,3273)   execute(read("test.ascii"));
general.tex(,3274)   i;
general.tex(,3275) @expansion{} 3
general.tex(,3276) @c end example ASCII_links general.doc:2876
general.tex(,3277) @end smallexample
general.tex(,3278) 
general.tex(,3279) @subheading MPfile links
general.tex(,3280) Data is stored in the binary MP format.  Read and write access is very
general.tex(,3281) fast compared to ASCII links.  All data (including such data that cannot
general.tex(,3282) be converted to a string) can be written to an MPfile link.  Reading
general.tex(,3283) from an MPfile link returns the written expressions (i.e., not a string,
general.tex(,3284) in general).
general.tex(,3285) 
general.tex(,3286) MPfile links should primarily be used for storing large amounts of data
general.tex(,3287) (like dumps of the content of an entire @sc{Singular} session), and if
general.tex(,3288) the data to be stored cannot be easily converted from or to a string
general.tex(,3289) (like rings, or maps).
general.tex(,3290) 
general.tex(,3291) MPfile links are implemented on Unix-like operating systems only.
general.tex(,3292) 
general.tex(,3293) @xref{MPfile links}, for more information.
general.tex(,3294) 
general.tex(,3295) @strong{Example:}
general.tex(,3296) @smallexample
general.tex(,3297) @c computed example MPfile_links general.doc:2905 
general.tex(,3298)   ring r;
general.tex(,3299)   // (over)write MPfile test.mp, link is specified as string
general.tex(,3300)   write("MPfile:w test.mp", x+y);
general.tex(,3301)   kill r;
general.tex(,3302)   def p = read("MPfile:r test.mp");
general.tex(,3303)   typeof(p); p;
general.tex(,3304) @expansion{} poly
general.tex(,3305) @expansion{} x+y
general.tex(,3306) @c end example MPfile_links general.doc:2905
general.tex(,3307) @end smallexample
general.tex(,3308) 
general.tex(,3309) @subheading MPtcp links
general.tex(,3310) Data is communicated with other processes (e.g., @sc{Singular}
general.tex(,3311) processes) which may run on the same computer or on different ones.  Data
general.tex(,3312) exchange is accomplished using TCP/IP links in the binary MP format.
general.tex(,3313) Reading from an MPtcp link returns the written expressions (i.e., not a
general.tex(,3314) string, in general).
general.tex(,3315) 
general.tex(,3316) MPtcp links should primarily be used for communications with other
general.tex(,3317) programs or for parallel computations (see, for example,
general.tex(,3318) @ref{Parallelization with MPtcp links}).
general.tex(,3319) 
general.tex(,3320) MPtcp links are implemented on Unix-like operating systems only.
general.tex(,3321) 
general.tex(,3322) @xref{MPtcp links}, for more information.
general.tex(,3323) 
general.tex(,3324) @strong{Example:}
general.tex(,3325) @smallexample
general.tex(,3326) @c computed example MPtcp_links general.doc:2932 
general.tex(,3327)   ring r;
general.tex(,3328)   link l = "MPtcp:launch"; // declare a link explicitly
general.tex(,3329)   open(l);  // needs an open, launches another SINGULAR as a server
general.tex(,3330)   write(l, x+y);
general.tex(,3331)   kill r;
general.tex(,3332)   def p = read(l);
general.tex(,3333)   typeof(p); p;
general.tex(,3334) @expansion{} poly
general.tex(,3335) @expansion{} x+y
general.tex(,3336)   close(l); // shuts down SINGULAR server
general.tex(,3337) @c end example MPtcp_links general.doc:2932
general.tex(,3338) @end smallexample
general.tex(,3339) 
general.tex(,3340) @subheading DBM links
general.tex(,3341) Data is stored in and accessed from a data base.  Writing is
general.tex(,3342) accomplished by a key and a value and associates the value with the key
general.tex(,3343) in the specified data base.  Reading is accomplished w.r.t.@: a key,
general.tex(,3344) the value associated to it is returned.  Both the key and the value have to
general.tex(,3345) be specified as strings.  Hence, DBM links may be used only for data
general.tex(,3346) which may be converted to or from strings.
general.tex(,3347) 
general.tex(,3348) DBM links should primarily be used when data needs to be accessed not in a
general.tex(,3349) sequential way (like with files) but in an associative way (like with
general.tex(,3350) data bases).
general.tex(,3351) 
general.tex(,3352) @xref{DBM links}, for more information.
general.tex(,3353) 
general.tex(,3354) @strong{Example:}
general.tex(,3355) @smallexample
general.tex(,3356) @c computed example DBM_links general.doc:2960 
general.tex(,3357)   ring r;
general.tex(,3358)   // associate "x+y" with "mykey"
general.tex(,3359)   write("DBM:w test.dbm", "mykey", string(x+y));
general.tex(,3360)   // get from data base what is stored under "mykey"
general.tex(,3361)   execute(read("DBM: test.dbm", "mykey"));
general.tex(,3362) @expansion{} x+y
general.tex(,3363) @c end example DBM_links general.doc:2960
general.tex(,3364) @end smallexample
general.tex(,3365) 
general.tex(,3366) 
general.tex(,3367) @c ---------------------------------------------------------------------------
general.tex(,3368) @node Procedures, Libraries, Input and output, General concepts
general.tex(,3369) @section Procedures
general.tex(,3370) @cindex Procedures
general.tex(,3371) 
general.tex(,3372) Procedures contain sequences of commands of the @sc{Singular} language.
general.tex(,3373) They are used to extend
general.tex(,3374) the set of commands with user defined commands.  Procedures are defined
general.tex(,3375) by either typing them on the command line or by loading them from a
general.tex(,3376) so-called library file with the LIB command, see @ref{LIB}.  Procedures are
general.tex(,3377) invoked like normal built-in commands, i.e., by typing their name
general.tex(,3378) followed by the list of arguments in parentheses. The invocation then
general.tex(,3379) executes the sequence of commands stored in the specified procedure. All
general.tex(,3380) defined procedures can be displayed by the command @code{listvar(proc);}.
general.tex(,3381) 
general.tex(,3382) @menu
general.tex(,3383) * Procedure definition::
general.tex(,3384) * Names in procedures::
general.tex(,3385) * Parameter list::
general.tex(,3386) * Procedure commands::
general.tex(,3387) @end menu
general.tex(,3388) @c -------------------------------------------------
general.tex(,3389) @node Procedure definition, Names in procedures, Procedures, Procedures
general.tex(,3390) @subsection Procedure definition
general.tex(,3391) @cindex Procedure definition
general.tex(,3392) @cindex procedures, static
general.tex(,3393) @cindex static procedures
general.tex(,3394) @c ------------------------------------------------------------
general.tex(,3395) @c   This piece of text exists also in the file types.doc,
general.tex(,3396) @c   chapter "proc declaration".
general.tex(,3397) @c   If you change something here, change it there, too!
general.tex(,3398) @c ------------------------------------------------------------
general.tex(,3399) @table @strong
general.tex(,3400) @item Syntax:
general.tex(,3401) [@code{static}] @code{proc} proc_name [parameter_list]
general.tex(,3402) @*["help_text"]
general.tex(,3403) @*@code{@{}
general.tex(,3404) @*
general.tex(,3408)    procedure_body
general.tex(,3409) @*@code{@}}
general.tex(,3410) @*[@code{example}
general.tex(,3411) @*@code{@{}
general.tex(,3412) @*
general.tex(,3416)    sequence_of_commands;
general.tex(,3417) @*@code{@}}]
general.tex(,3418) @item Purpose:
general.tex(,3419) defines a new function, the @code{proc} proc_name, with the additional
general.tex(,3420) information help_text, which is copied to the screen by
general.tex(,3421) @code{help proc_name;} and the @code{example} section
general.tex(,3422) which is executed by @code{example proc_name;}.
general.tex(,3423) @* The help_text, the parameter_list, and the example section are optional.
general.tex(,3424) The default for a parameter_list is @code{(list #)}, see @ref{Parameter list}.
general.tex(,3425) The help and example sections are ignored if the procedure is defined
general.tex(,3430) interactively, i.e., if it was not loaded from a file by a LIB command
general.tex(,3431) (@ref{LIB}).
general.tex(,3433) @* Specifying @code{static} in front of the proc-definition (in a library file)
general.tex(,3434) makes this procedure local to the library, i.e., accessible only for the other
general.tex(,3435) procedures in the same library, but not for the users. So there is no
general.tex(,3436) reason anymore to define a procedure within another one (it just makes
general.tex(,3437) debugging harder).
general.tex(,3438) @end table
general.tex(,3439) 
general.tex(,3440) @subsubheading Example of an interactive procedure definition
general.tex(,3441) @smallexample
general.tex(,3442) @c computed example Example_of_an_interactive_procedure_definition general.doc:3045 
general.tex(,3443)   proc milnor_number (poly p)
general.tex(,3444)   @{
general.tex(,3445)     ideal i= std(jacob(p));
general.tex(,3446)     int m_nr=vdim(i);
general.tex(,3447)     if (m_nr<0)
general.tex(,3448)     @{
general.tex(,3449)       "// not an isolated singularity";
general.tex(,3450)     @}
general.tex(,3451)     return(m_nr);         // the value of m_nr is returned
general.tex(,3452)   @}
general.tex(,3453)   ring r1=0,(x,y,z),ds;
general.tex(,3454)   poly p=x^2+y^2+z^5;
general.tex(,3455)   milnor_number(p);
general.tex(,3456) @expansion{} 4
general.tex(,3457) @c end example Example_of_an_interactive_procedure_definition general.doc:3045
general.tex(,3458) @end smallexample
general.tex(,3459) 
general.tex(,3460) @subsubheading Example of a procedure definition in a library
general.tex(,3461) First, the library definition:
general.tex(,3462) @smallexample
general.tex(,3463) @c begin included file sample.lib from general.doc:3065
general.tex(,3464) // Example of a user accessible procedure
general.tex(,3465) proc tab (int n)
general.tex(,3466) "USAGE:    tab(n);  (n integer)
general.tex(,3467) RETURNS:  string of n space tabs
general.tex(,3468) EXAMPLE:  example tab; shows an example"
general.tex(,3469) @{ return(internal_tab(n)); @}
general.tex(,3470) example
general.tex(,3471) @{
general.tex(,3472)   "EXAMPLE:"; echo=2;
general.tex(,3473)   for(int n=0; n<=4; n=n+1)
general.tex(,3474)   @{ tab(4-n)+"*"+tab(n)+"+"+tab(n)+"*"; @}
general.tex(,3475) @}
general.tex(,3476) 
general.tex(,3477) // Example of a static procedure
general.tex(,3478) static proc internal_tab (int n)
general.tex(,3479) @{ return(" "[1,n]); @}
general.tex(,3480) @c end included file from general.doc:3065
general.tex(,3481) @end smallexample
general.tex(,3482) 
general.tex(,3483) Now, we load the library and execute the procedures defined there:
general.tex(,3484) @smallexample
general.tex(,3485) @c computed example Example_of_a_procedure_definition_in_a_library general.doc:3070 
general.tex(,3486)   LIB "sample.lib";        // load the library sample.lib
general.tex(,3487)   example tab;             // show an example
general.tex(,3488) @expansion{} // proc tab from lib sample.lib
general.tex(,3489) @expansion{} EXAMPLE:
general.tex(,3490) @expansion{}   for(int n=0; n<=4; n=n+1)
general.tex(,3491) @expansion{}   @{ tab(4-n)+"*"+tab(n)+"+"+tab(n)+"*"; @}
general.tex(,3492) @expansion{}     *+*
general.tex(,3493) @expansion{}    * + *
general.tex(,3494) @expansion{}   *  +  *
general.tex(,3495) @expansion{}  *   +   *
general.tex(,3496) @expansion{} *    +    *
general.tex(,3497) @expansion{} 
general.tex(,3498)   "*"+tab(3)+"*";          // use the procedure tab
general.tex(,3499) @expansion{} *   *
general.tex(,3500)   // the static procedure internal_tab is not accessible
general.tex(,3501)   "*"+internal_tab(3)+"*";
general.tex(,3502) @expansion{}    ? 'sample.lib::internal_tab()' is a local procedure and cannot be acce\
general.tex(,3503)    ssed by an user.
general.tex(,3504) @expansion{}    ? error occurred in line 5: `  "*"+internal_tab(3)+"*";`
general.tex(,3505)   // show the help section for tab
general.tex(,3506)   help tab;
general.tex(,3507) @expansion{} // ** Could not get IdxFile. 
general.tex(,3508) @expansion{} // ** Either set environment variable SINGULAR_IDX_FILE to IdxFile,
general.tex(,3509) @expansion{} // ** or make sure that IdxFile is at /home/hannes/singular/2-0/doc/singu\
general.tex(,3510)    lar.idx
general.tex(,3511) @expansion{} // proc tab from lib sample.lib
general.tex(,3512) @expansion{} proc tab (int n)
general.tex(,3513) @expansion{} USAGE:    tab(n);  (n integer)
general.tex(,3514) @expansion{} RETURNS:  string of n space tabs
general.tex(,3515) @expansion{} EXAMPLE:  example tab; shows an example
general.tex(,3516) @c end example Example_of_a_procedure_definition_in_a_library general.doc:3070
general.tex(,3517) @end smallexample
general.tex(,3518) 
general.tex(,3519) @subsubheading Guidelines for the help text of a procedure
general.tex(,3520) There are no enforced rules on the format of the help section of a
general.tex(,3521) procedure.
general.tex(,3522) 
general.tex(,3523) Nevertheless, we recommend that the help text of a procedure should
general.tex(,3524) contain information about the usage,
general.tex(,3525) purpose, return values and generated objects. Particular assumptions or
general.tex(,3526) limitations should be listed. It should also be mentioned if global
general.tex(,3527) objects are generated or manipulated.
general.tex(,3528) 
general.tex(,3529) The help text of procedures contained in libraries of the
general.tex(,3530) @sc{Singular} distribution
general.tex(,3531) should furthermore comply with  certain rules as explained in
general.tex(,3532) @ref{The help string of procedures}.
general.tex(,3533) 
general.tex(,3534) @c ---------------------------------------
general.tex(,3535) @node Names in procedures, Parameter list, Procedure definition, Procedures
general.tex(,3536) @subsection Names in procedures
general.tex(,3537) @cindex Names in procedures
general.tex(,3538) @cindex local names
general.tex(,3539) 
general.tex(,3540) All variables are local to the procedure they are defined in.
general.tex(,3541) Locally defined variables cannot interfere with names in other
general.tex(,3542) procedures and are automatically deleted after leaving
general.tex(,3543) the procedure.
general.tex(,3544) 
general.tex(,3545) Internally, local variables are stored using the nesting level. A variable
general.tex(,3546) is said to have nesting level 1, if it is local to a procedure that was
general.tex(,3547) called interactively, nesting level 2, if it is local to a procedure that
general.tex(,3548) was called by a procedure of nesting level 1 etc. @code{listvar()} also
general.tex(,3549) displays the nesting level, nesting level 0 is used for global objects
general.tex(,3550) (see @ref{listvar}). A ring may be 'moved up' by one nesting level
general.tex(,3551) with @code{keepring} (see @ref{keepring}). All variables living in that
general.tex(,3552) ring are moved together with that ring.
general.tex(,3553) 
general.tex(,3554) To keep local variables after leaving the procedure, they have to be
general.tex(,3555) exported (i.e. made known) to some higher level by the @code{export}
general.tex(,3556) command (@pxref{export}).
general.tex(,3557) 
general.tex(,3558) @strong{Example:}
general.tex(,3559) @smallexample
general.tex(,3560) @c computed example Names_in_procedures general.doc:3122 
general.tex(,3561) proc xxx
general.tex(,3562) @{
general.tex(,3563)   int k=4;        //defines a local variable k
general.tex(,3564)   int result=k+2;
general.tex(,3565)   export(result);  //defines the global variable "result".
general.tex(,3566) @}
general.tex(,3567) xxx();
general.tex(,3568) listvar(all);
general.tex(,3569) @expansion{} // result               [0]  int 6
general.tex(,3570) @expansion{} // LIB                  [0]  string standard.lib
general.tex(,3571) @c end example Names_in_procedures general.doc:3122
general.tex(,3572) @end smallexample
general.tex(,3573) Note that the variable @code{result} became a global variable after the
general.tex(,3574) execution of @code{xxx}.
general.tex(,3575) 
general.tex(,3576) @c ---------------------------------------
general.tex(,3577) @node Parameter list, Procedure commands, Names in procedures, Procedures
general.tex(,3578) @subsection Parameter list
general.tex(,3579) @cindex Parameter list
general.tex(,3580) @table @code
general.tex(,3581) @item @strong{Syntax:}
general.tex(,3582) @code{( )}
general.tex(,3583) @*@code{(} parameter_definition @code{)}
general.tex(,3584) @item @strong{Purpose:}
general.tex(,3585) defines the number, type and names of the
general.tex(,3586) arguments to a @code{proc}.
general.tex(,3587) @*The parameter_list is optional.
general.tex(,3588) The default for a parameter_list is @code{(list #)}
general.tex(,3589) which means the arguments are referenced by @code{#[1], #[2]}, etc.
general.tex(,3590) @item @strong{Example:}
general.tex(,3591) @smallexample
general.tex(,3592) proc x0
general.tex(,3593) @{
general.tex(,3594)     // can be called with
general.tex(,3595) ... // any number of arguments of any type: #[1], #[2],...
general.tex(,3596)     // number of arguments: size(#)
general.tex(,3597) @}
general.tex(,3598) 
general.tex(,3599) proc x1 ()
general.tex(,3600) @{
general.tex(,3601) ... // can only be called without arguments
general.tex(,3602) @}
general.tex(,3603) 
general.tex(,3604) proc x2 (ideal i, int j)
general.tex(,3605) @{
general.tex(,3606) ... // can only be called with 2 arguments,
general.tex(,3607)     // which can be converted to ideal resp. int
general.tex(,3608) @}
general.tex(,3609) 
general.tex(,3610) proc x3 (i,j)
general.tex(,3611) @{
general.tex(,3612) ... // can only be called with 2 arguments
general.tex(,3613)     // of any type
general.tex(,3614)     // (i,j) is the same as (def i,def j)
general.tex(,3615) @}
general.tex(,3616) 
general.tex(,3617) proc x5 (i,list #)
general.tex(,3618) @{
general.tex(,3619) ... // can only be called with at least 1 argument
general.tex(,3620)     // number of arguments: size(#)+1
general.tex(,3621) @}
general.tex(,3622) 
general.tex(,3623) @end smallexample
general.tex(,3624) @item @strong{Note:}
general.tex(,3625) @* The parameter_list may stretch across multiple lines.
general.tex(,3626) @* A parameter may have any type (including the types @code{proc}
general.tex(,3627)    and @code{ring}). If a parameter is of type ring, then it
general.tex(,3628)    can only be specified by name, but not with a type, e.g.
general.tex(,3629) @smallexample
general.tex(,3630) proc x6 (r)
general.tex(,3631) @{
general.tex(,3632) ... // this is correct even if the parameter is a ring
general.tex(,3633) @}
general.tex(,3634) 
general.tex(,3635) proc x7 (ring r)
general.tex(,3636) @{
general.tex(,3637) ... // this is NOT CORRECT
general.tex(,3638) @}
general.tex(,3639) @end smallexample
general.tex(,3640) @end table
general.tex(,3641) 
general.tex(,3642) @c --------------------------------------- ----------
general.tex(,3643) @node Procedure commands, , Parameter list, Procedures
general.tex(,3644) @subsection Procedure commands
general.tex(,3645) @cindex Procedure commands
general.tex(,3646) 
general.tex(,3647) Some commands only make sense inside a procedure, since they make
general.tex(,3648) objects known to the nesting level from which the procedure was called
general.tex(,3649) or to all nesting levels.
general.tex(,3650) 
general.tex(,3651) @c inserted refs from general.doc:3211
general.tex(,3666) @c end inserted refs from general.doc:3211
general.tex(,3667) 
general.tex(,3668) @c ----------------------------------------------------------------------
general.tex(,3669) @node Libraries, Guidelines for writing a library, Procedures, General concepts
general.tex(,3670) @section Libraries
general.tex(,3671) @cindex Libraries
general.tex(,3672) 
general.tex(,3673) A library is a collection of @sc{Singular}
general.tex(,3674) procedures in a file.
general.tex(,3675) @*@sc{Singular} reads a library with the command
general.tex(,3676) @code{LIB}. General information about the library is displayed by the command
general.tex(,3677) @code{help libname_lib}. After loading the library, its procedures can be used
general.tex(,3678) like the built-in @sc{Singular} functions.
general.tex(,3679) 
general.tex(,3680) To have the full functionality of a built-in function libraries have to
general.tex(,3681) comply with the few syntax rules described below.
general.tex(,3682) 
general.tex(,3683) Furthermore, libraries which are to be included in the @sc{Singular}
general.tex(,3684) distribution, have to comply with certain rules as explained in
general.tex(,3685) @ref{Guidelines for writing a library}.
general.tex(,3686) 
general.tex(,3687) @menu
general.tex(,3688) * Loading of a library::
general.tex(,3689) * Format of a library::
general.tex(,3690) @end menu
general.tex(,3691) 
general.tex(,3692) @c ---------------------------------------
general.tex(,3693) @node Loading of a library, Format of a library,, Libraries
general.tex(,3694) @subsection Loading of a library
general.tex(,3695) @cindex Loading of a library
general.tex(,3696) @cindex path
general.tex(,3697) @cindex SearchPath
general.tex(,3698) @cindex RootDir
general.tex(,3699) @cindex BinDir
general.tex(,3700) @cindex DefaultDir
general.tex(,3701) @cindex SINGULARPATH
general.tex(,3702) 
general.tex(,3703) Libraries can be loaded with the @code{LIB} command:
general.tex(,3704) 
general.tex(,3705) @c ------------------------------------------------------------
general.tex(,3706) @c   This piece of text exists also in the file reference.doc,
general.tex(,3707) @c   chapter "LIB".
general.tex(,3708) @c   chapter "load".
general.tex(,3709) @c   If you change something here, change it there, too!
general.tex(,3710) @c ------------------------------------------------------------
general.tex(,3711) @table @code
general.tex(,3712) @item @strong{Syntax:}
general.tex(,3713) @code{LIB} string_expression @code{;}
general.tex(,3714) @item @strong{Type:}
general.tex(,3715) none
general.tex(,3716) @item @strong{Purpose:}
general.tex(,3717) reads a library of procedures from a file. If the given filename does
general.tex(,3718) not start with @kbd{.} or @kbd{/} and can not be located in the current
general.tex(,3719) directory, each directory contained in the library
general.tex(,3720) @code{SearchPath} is searched for file of this name.
general.tex(,3721) @item @strong{Note on SearchPath:}
general.tex(,3722) The the library @code{SearchPath} is constructed at @sc{Singular}
general.tex(,3723) start-up time as follows:
general.tex(,3724) @enumerate
general.tex(,3725) @item
general.tex(,3726) the directories contained in the environment variable
general.tex(,3727) @code{SINGULARPATH} are appended
general.tex(,3728) 
general.tex(,3729) @item
general.tex(,3730) the directories @code{$BinDir/LIB}, @code{$RootDir/LIB},
general.tex(,3731) @code{$RootDir/../LIB}, @code{$DefaultDir/LIB}, @code{$DefaultDir/../LIB}
general.tex(,3732) are appended, where
general.tex(,3733) @itemize @bullet
general.tex(,3734) @item @code{$BinDir}
general.tex(,3735) is the value of the environment variable
general.tex(,3736) @code{SINGULAR_BIN_DIR}, if set, or, if not set, the directory in which the
general.tex(,3737) @sc{Singular} program
general.tex(,3738) resides
general.tex(,3739) @item @code{$RootDir}
general.tex(,3740) is the value of the environment variable
general.tex(,3741) @code{SINGULAR_ROOT_DIR}, if set, or, if not set, @code{$BinDir/../}.
general.tex(,3742) @item @code{$DefaultDir}
general.tex(,3743) is the value of the environment variable
general.tex(,3744) @code{SINGULAR_DEFAULT_DIR}, if set, or @code{/usr/local/Singular/} on a
general.tex(,3745) Unix platform, @code{\Singular\} on a Windows 95/98/NT platform, and
general.tex(,3746) @code{::Singular:} on a Macintosh.
general.tex(,3747) @end itemize
general.tex(,3748) 
general.tex(,3749) @item
general.tex(,3750) all directories which do not exist are removed from the @code{SearchPath}.
general.tex(,3751) @end enumerate
general.tex(,3752) 
general.tex(,3753) For setting environment variables see @ref{system}, or consult the manual of
general.tex(,3754) your shell.
general.tex(,3755) 
general.tex(,3756) The library @code{SearchPath} can be examined  by starting up
general.tex(,3757) @sc{Singular} with the option @code{-v}, or by issuing the command
general.tex(,3758) @code{system("--version");}.
general.tex(,3759) 
general.tex(,3760) @item @strong{Note on standard.lib:}
general.tex(,3761) Unless  @sc{Singular} is started with the @code{--no-stdlib} option, the
general.tex(,3762) library @code{standard.lib} is automatically loaded at start-up time.
general.tex(,3763) 
general.tex(,3764) @end table
general.tex(,3765) 
general.tex(,3766) Only the names of the procedures in the library are loaded, the body of
general.tex(,3767) the procedures is read during the first call of this procedure. This minimizes
general.tex(,3768) memory consumption by unused procedures.  When @sc{Singular} is started
general.tex(,3769) with the @code{-q} or @code{--quiet} option, no message about the
general.tex(,3770) loading of a library is displayed.  More precisely, option @code{-q} (and
general.tex(,3771) likewise @code{--quiet}) unsets option @code{loadLib} to inhibit
general.tex(,3772) monitoring of library loading (@pxref{option}).
general.tex(,3773) 
general.tex(,3774) All loaded libraries are displayed by the @code{LIB;}
general.tex(,3775) command:
general.tex(,3776) @smallexample
general.tex(,3777) @c computed example Loading_of_a_library general.doc:3327 
general.tex(,3778)   option(loadLib);   // show loading of libraries;
general.tex(,3779)                      // standard.lib is loaded
general.tex(,3780)   LIB;
general.tex(,3781) @expansion{} standard.lib
general.tex(,3782)                      // the names of the procedures of inout.lib
general.tex(,3783)   LIB "inout.lib";   // are now known to Singular
general.tex(,3784) @expansion{} // ** loaded inout.lib (1.21.2.5,2002/06/12)
general.tex(,3785)   LIB;
general.tex(,3786) @expansion{} standard.lib,inout.lib
general.tex(,3787) @c end example Loading_of_a_library general.doc:3327
general.tex(,3788) @end smallexample
general.tex(,3789) 
general.tex(,3790) @c inserted refs from general.doc:3337
general.tex(,3815) @c end inserted refs from general.doc:3337
general.tex(,3816) 
general.tex(,3817) @c ---------------------------------------
general.tex(,3818) @node Format of a library,, Loading of a library, Libraries
general.tex(,3819) @subsection Format of a library
general.tex(,3820) @cindex Format of a library
general.tex(,3821) 
general.tex(,3822) A library file can contain comments, a category-, info- and version-string
general.tex(,3823) definition, @code{LIB} commands, @code{proc} commands
general.tex(,3824) and @code{proc} commands with @code{example} and @code{help} sections,
general.tex(,3825) i.e., the following keywords are allowed:
general.tex(,3826) @code{category},
general.tex(,3827) @code{info},
general.tex(,3828) @code{version},
general.tex(,3829) @code{LIB},
general.tex(,3830) @code{/* ... */},
general.tex(,3831) @code{//},
general.tex(,3832) @code{[static] proc}.
general.tex(,3833) Anything else is not recognized by the parser of @sc{Singular} and leads
general.tex(,3834) to an error message while loading the library.
general.tex(,3835) If an error occurs, loading is aborted and an error message is displayed,
general.tex(,3836) specifying the type of error and the line where it was detected.
general.tex(,3837) 
general.tex(,3838) The category-, info- and version-string are defined as follows:
general.tex(,3839) @cindex  info in a library
general.tex(,3840) @table @code
general.tex(,3841) @item @strong{Syntax:}
general.tex(,3842) @code{info} = string_constant @code{;}
general.tex(,3843) @item @strong{Purpose:}
general.tex(,3844) defines the general help for the library. This text is displayed on
general.tex(,3845) @code{help libname_lib;}.
general.tex(,3846) @item @strong{Example:}
general.tex(,3847) @smallexample
general.tex(,3848) info="
general.tex(,3849)       This could be the general help of a library.
general.tex(,3850)      Quotes must be escaped with a \ such as \"
general.tex(,3851) ";
general.tex(,3852) @end smallexample
general.tex(,3853) @item @strong{Note:}
general.tex(,3854) In the info-string the characters \ and " must be preceded by a \ (escaped).
general.tex(,3855) It is recommended that the info string is placed on the top of a
general.tex(,3856) library file and contains general information about the library as well
general.tex(,3857) as a listing of all procedures available to the users (with a one line
general.tex(,3858) description of each procedure).
general.tex(,3859) 
general.tex(,3860) Although there is no enforced format of the info string of a library, we
general.tex(,3861) recommend that you follow certain rules as explained in
general.tex(,3862) @ref{The help string of a library}.
general.tex(,3863) @end table
general.tex(,3864) 
general.tex(,3865) @cindex  version in a library
general.tex(,3866) @table @code
general.tex(,3867) @item @strong{Syntax:}
general.tex(,3868) @code{version} = string_constant @code{;}
general.tex(,3869) @item @strong{Purpose:}
general.tex(,3870) defines the version number for the library. It is displayed when the
general.tex(,3871) library is loaded.
general.tex(,3872) @item @strong{Example:}
general.tex(,3873) @smallexample
general.tex(,3874) version="$I@i{}@comment
general.tex(,3875) @comment !! Do not erase the @comment at the end of the previous line !!
general.tex(,3876) @comment !! It prevents cvs to substitute the id string                !!
general.tex(,3877) d: sample.lib,v 1.2 1998/05/07 singular Exp $";
general.tex(,3878) version="some version string";
general.tex(,3879) @end smallexample
general.tex(,3880) @item @strong{Note:}
general.tex(,3881) It is common practice to simply define the version string to be
general.tex(,3882) @code{"$I}@comment
general.tex(,3883) @comment !! Do not erase the @comment at the end of the previous line !!
general.tex(,3884) @comment !! It prevents cvs to substitute the id string                !!
general.tex(,3885) @code{d:$"} and let a version control system expand it.
general.tex(,3886) @end table
general.tex(,3887) 
general.tex(,3888) @cindex  category in a library
general.tex(,3889) @table @code
general.tex(,3890) @item @strong{Syntax:}
general.tex(,3891) @code{category} = string_constant @code{;}
general.tex(,3892) @item @strong{Purpose:}
general.tex(,3893) defines the category for the library.
general.tex(,3894) @item @strong{Example:}
general.tex(,3895) @smallexample
general.tex(,3896) category="Utilities";
general.tex(,3897) @end smallexample
general.tex(,3898) @item @strong{Note:}
general.tex(,3899) reserved for sorting the libraries into categories.
general.tex(,3900) @end table
general.tex(,3901) 
general.tex(,3902) @c ---------------------------------------
general.tex(,3903) @node Guidelines for writing a library, Debugging tools, Libraries, General concepts
general.tex(,3904) @section Guidelines for writing a library
general.tex(,3905) @cindex Guidelines for writing a library
general.tex(,3906) @cindex library, Guidelines for writing
general.tex(,3907) 
general.tex(,3908) Although there are very few enforced rules on how libraries are written
general.tex(,3909) (see @ref{Libraries}), it is recommended that the libraries comply with
general.tex(,3910) the guidelines explained in this section, so that debugging and
general.tex(,3911) understanding are made easier.
general.tex(,3912) 
general.tex(,3913) @strong{Note:} For libraries which are to be included in the @sc{Singular}
general.tex(,3914) distribution, the following guidelines are mandatory.
general.tex(,3915) 
general.tex(,3916) @menu
general.tex(,3917) * Procedures in a library::
general.tex(,3918) * Documentation of a library::
general.tex(,3919) * Typesetting of help strings::
general.tex(,3920) * The help string of a library::
general.tex(,3921) * The help string of procedures::
general.tex(,3922) * template_lib::
general.tex(,3923) @end menu
general.tex(,3924) 
general.tex(,3925) @c ---------------------------------------
general.tex(,3926) @node Procedures in a library, Documentation of a library,,Guidelines for writing a library
general.tex(,3927) 
general.tex(,3928) @subsection Procedures in a library
general.tex(,3929) @cindex Procedures in a library
general.tex(,3930) @cindex library, procedures
general.tex(,3931) 
general.tex(,3932) In this section we list miscellaneous recommendations on how procedures
general.tex(,3933) contained in a library should be implemented.
general.tex(,3934) @enumerate
general.tex(,3935) @item
general.tex(,3936) The info- and version-string should appear at the beginning of the
general.tex(,3937) library, before procedure definitions.
general.tex(,3938) 
general.tex(,3939) @item
general.tex(,3940) The info-string should have the format as explained in @ref{The help
general.tex(,3941) string of a library}.
general.tex(,3942) 
general.tex(,3943) @item
general.tex(,3944) Each procedure which should not be accessible by users should be
general.tex(,3945) declared @code{static}.
general.tex(,3946) 
general.tex(,3947) @item
general.tex(,3948) Each procedure which is not declared @code{static} should have a
general.tex(,3949) help and example section as explained in @ref{Procedure definition}.
general.tex(,3950) @*Such procedures should furthermore carefully check any assumptions
general.tex(,3951) made about their input (like the type of list elements), and, if
general.tex(,3952) necessary, omit an error using the  function @ref{ERROR}.
general.tex(,3953) 
general.tex(,3954) @item
general.tex(,3955) No procedures should be defined within the body of another procedure.
general.tex(,3956) 
general.tex(,3957) @item
general.tex(,3958) If the value of
general.tex(,3959) the reserved variable @code{printlevel} (@pxref{printlevel}) is greater
general.tex(,3960) than 0 then interactive user-input, i.e., the usage of functions like
general.tex(,3961) @code{pause("..")} or @code{read("");} (@pxref{read}), may be requested.
general.tex(,3962) 
general.tex(,3963) @item
general.tex(,3964) If the value of
general.tex(,3965) the reserved variable @code{printlevel} (@pxref{printlevel}) is 0
general.tex(,3966) then interactive user-input, i.e., the usage of functions like
general.tex(,3967) @code{pause("..")} or @code{read("");} (@pxref{read}), may @strong{not} be
general.tex(,3968) requested. Instead, an error (using the function
general.tex(,3969) @ref{ERROR}) should be reported together with the recommendation on
general.tex(,3970) increasing the value of the reserved variable @code{printlevel}.
general.tex(,3971) 
general.tex(,3972) @item
general.tex(,3973) It is often useful for a procedure to print out comments, either to
general.tex(,3974) explain results or to display intermediate computations. However,
general.tex(,3975) if this procedure is called by another procedure, such comments are
general.tex(,3976) confusing and disturbing in most cases.
general.tex(,3977) 
general.tex(,3978) @sc{Singular} offers an elegant solution, which requires the usage of
general.tex(,3979) the @sc{Singular} function @ref{dbprint} and the reserved variables
general.tex(,3980) @ref{printlevel}, and @ref{voice} (@code{voice} counts the nesting of
general.tex(,3981) procedures; It has the value 1 on the top level, 2 inside the first
general.tex(,3982) procedure etc.; @code{printlevel} has the value 0 by default, but can be
general.tex(,3983) set to any integer value by the user).
general.tex(,3984) 
general.tex(,3985) For example, if the following procedure @code{Test} is called
general.tex(,3986) directly from the top level then @samp{comment1} is displayed (i.e.,
general.tex(,3987) printed out) but not
general.tex(,3988) @samp{comment2}; and nothing is displayed if  @code{Test} is called
general.tex(,3989) from within any other procedure.
general.tex(,3990) However, if @code{printlevel} is set to  a value k with k>0, then
general.tex(,3991) @samp{comment1} (resp.@: @samp{comment2}) is displayed provided that
general.tex(,3992) @code{Test} is called from other procedures, with a nesting level up to
general.tex(,3993) k (resp.@: k-1).
general.tex(,3994) 
general.tex(,3995) Note furthermore, that the example part of a procedure
general.tex(,3996) behaves in this respect like a procedure (i.e., the value of @code{voice}
general.tex(,3997) is 1). Therefore, the command @code{printlevel=1;} is necessary for
general.tex(,3998) @samp{comment1} to be displayed on @code{ example Test;}. However,
general.tex(,3999) since printlevel is a global variable, it should be reset to the old
general.tex(,4000) value at the end of the example part.
general.tex(,4001) 
general.tex(,4002) @smallexample
general.tex(,4003) proc Test
general.tex(,4004) "USAGE:   ...
general.tex(,4005)          ...
general.tex(,4006) EXAMPLE: example Test; shows an example
general.tex(,4007) "
general.tex(,4008) @{   ...
general.tex(,4009)    int p = printlevel - voice + 3;
general.tex(,4010)     ...
general.tex(,4011)    dbprint(p,"comment1");
general.tex(,4012)    dbprint(p-1,"comment2");
general.tex(,4013)    // dbprint prints only if p > 0
general.tex(,4014)     ...
general.tex(,4015) @}
general.tex(,4016) example
general.tex(,4017) @{ "EXAMPLE:"; echo = 2;
general.tex(,4018)    int p = printlevel;   //store old value of printlevel
general.tex(,4019)    printlevel = 1;       //assign new value to printlevel
general.tex(,4020)     ...
general.tex(,4021)    Test();
general.tex(,4022)    printlevel = p;       //reset printlevel to old value
general.tex(,4023) @}
general.tex(,4024) @end smallexample
general.tex(,4025) 
general.tex(,4026) @end enumerate
general.tex(,4027) @c @end table
general.tex(,4028) 
general.tex(,4029) @c ---------------------------------------
general.tex(,4030) @node Documentation of a library, Typesetting of help strings, Procedures in a library, Guidelines for writing a library
general.tex(,4031) 
general.tex(,4032) @subsection Documentation of a library
general.tex(,4033) @cindex Documentation of a library
general.tex(,4034) @cindex library, documentation
general.tex(,4035) 
general.tex(,4036) The typesetting language in which the @sc{Singular} documentation is
general.tex(,4037) written is @code{texinfo}. Based on various tools, @code{info, dvi, ps,} and
general.tex(,4038) @code{html} versions of the @code{texinfo} documentation are generated.
general.tex(,4039) 
general.tex(,4040) 
general.tex(,4041) Starting with @sc{Singular} version 1-3, the @code{texinfo}
general.tex(,4042) documentation of all libraries of the @sc{Singular} distribution is
general.tex(,4043) generated automatically from their source code.
general.tex(,4044) 
general.tex(,4045) More precisely, for each library,
general.tex(,4046) @itemize @minus
general.tex(,4047) @item
general.tex(,4048) the info string of the library is parsed and typeset
general.tex(,4049) as explained in @ref{Typesetting of help strings}.
general.tex(,4050) 
general.tex(,4051) @item
general.tex(,4052) the help string of each procedure listed in the @code{PROCEDURE:}
general.tex(,4053) section of the library info string is parsed
general.tex(,4054) and typeset as explained in @ref{Typesetting of help strings}.
general.tex(,4055) 
general.tex(,4056) @item
general.tex(,4057) the example of each procedure listed in the @code{PROCEDURE:} section of
general.tex(,4058) the library info string is computed and its output is
general.tex(,4059) included into the documentation.
general.tex(,4060) @end itemize
general.tex(,4061) 
general.tex(,4062) For a uniform look-and-feel of the library documentation, library
general.tex(,4063) developers should
general.tex(,4064) @itemize @minus
general.tex(,4065) @item
general.tex(,4066) follow the recommendation of
general.tex(,4067) @ref{The help string of a library} and @ref{The help string of
general.tex(,4068) procedures}.
general.tex(,4069) 
general.tex(,4070) @item
general.tex(,4071) consult the source code of libraries like
general.tex(,4072) @code{template.lib} (@pxref{template_lib})
general.tex(,4073) for examples on how library documentations are
general.tex(,4074) written.
general.tex(,4075) 
general.tex(,4076) @item
general.tex(,4077) make sure that each procedure listed in the @code{PROCEDURE:}
general.tex(,4078) section of the library info string has a help string and an example
general.tex(,4079) section.
general.tex(,4080) 
general.tex(,4081) @item
general.tex(,4082) not use interactive functions like
general.tex(,4083) @code{pause("..")} or @code{read("");} (@pxref{read}) and should limit the
general.tex(,4084) length of input lines to 60 characters in the example section of
general.tex(,4085) procedures.
general.tex(,4086) 
general.tex(,4087) @item
general.tex(,4088) carefully check the generated
general.tex(,4089) documentation of their libraries in its various formats using the
general.tex(,4090) @code{lib2doc} (@pxref{lib2doc}) utility.
general.tex(,4091) @end itemize
general.tex(,4092) 
general.tex(,4093) @menu
general.tex(,4094) * lib2doc::
general.tex(,4095) @end menu
general.tex(,4096) 
general.tex(,4097) @node lib2doc,,,Documentation of a library
general.tex(,4098) @subsubsection lib2doc
general.tex(,4099) @cindex lib2doc
general.tex(,4100) 
lib2doc.texi(,4) 
lib2doc.texi(,5) @code{lib2doc} is a utility to generate the stand-alone documentation for 
lib2doc.texi(,6) a @sc{Singular} library in various formats. 
lib2doc.texi(,7) 
lib2doc.texi(,8) The @code{lib2doc} utility should be used by developers of @sc{Singular}
lib2doc.texi(,9) libraries to check the generation of the documentation of their
lib2doc.texi(,10) libraries.
lib2doc.texi(,11) 
lib2doc.texi(,12) @code{lib2doc} can be downloaded from @*
lib2doc.texi(,13) @url{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/misc/lib2doc.tar.gz}
lib2doc.texi(,14) 
lib2doc.texi(,15) 
lib2doc.texi(,16) @strong{Important:} 
lib2doc.texi(,17) @*To use @code{lib2doc}, you need 
lib2doc.texi(,18) to have @code{perl} (version 5 or
lib2doc.texi(,19) higher), @code{texinfo} (version 3.12 or higher)  and @code{Singular}
lib2doc.texi(,20) and @code{libparse} (version 1-3-4 or higher) installed on your system.
lib2doc.texi(,21) 
lib2doc.texi(,22) To generate the documentation for a library, follow these steps:
lib2doc.texi(,23) @enumerate
lib2doc.texi(,24) @item
lib2doc.texi(,25) Unpack lib2doc.tar.gz
lib2doc.texi(,26) @smallexample
lib2doc.texi(,27) gzip -dc  lib2doc.tar.gz | tar -pxf -
lib2doc.texi(,28) @end smallexample
lib2doc.texi(,29) and 
lib2doc.texi(,30) @smallexample
lib2doc.texi(,31) cd lib2doc
lib2doc.texi(,32) @end smallexample
lib2doc.texi(,33) 
lib2doc.texi(,34) @item 
lib2doc.texi(,35) Edit the beginning of the file @code{Makefile}, filling in the values for
lib2doc.texi(,36) @code{SINGULAR} and @code{LIBPARSE}. Check also the values of @code{PERL} 
lib2doc.texi(,37) and @code{LATEX2HTML}.
lib2doc.texi(,38) 
lib2doc.texi(,39) @item 
lib2doc.texi(,40) Copy your library to the current directory:
lib2doc.texi(,41) @smallexample
lib2doc.texi(,42) cp <path-where-your-lib-is>/mylib.lib .
lib2doc.texi(,43) @end smallexample
lib2doc.texi(,44) 
lib2doc.texi(,45) @item 
lib2doc.texi(,46) Now you can run the following commands:
lib2doc.texi(,47) @table @code
lib2doc.texi(,48) @item make mylib.hlp
lib2doc.texi(,49) Generates the file @code{mylib.hlp} -- the info file for the documentation
lib2doc.texi(,50) of @code{mylib.lib}. This file can be viewed with
lib2doc.texi(,51) @smallexample
lib2doc.texi(,52) info -f mylib.hlp
lib2doc.texi(,53) @end smallexample
lib2doc.texi(,54) @item make mylib.dvi
lib2doc.texi(,55) Generates the file @code{mylib.dvi} -- the dvi file for the documentation
lib2doc.texi(,56) of @code{mylib.lib}. This file can be viewed with
lib2doc.texi(,57) @smallexample
lib2doc.texi(,58) xdvi mylib.dvi
lib2doc.texi(,59) @end smallexample
lib2doc.texi(,60) @item make mylib.ps
lib2doc.texi(,61) Generates the file @code{mylib.ps} -- the PostScript file for the documentation
lib2doc.texi(,62) of @code{mylib.lib}. This file can be viewed with (for example)
lib2doc.texi(,63) @smallexample
lib2doc.texi(,64) ghostview mylib.dvi
lib2doc.texi(,65) @end smallexample
lib2doc.texi(,66) @item make mylib.html
lib2doc.texi(,67) Generates the file @code{mylib.html} -- the HTML file for the documentation
lib2doc.texi(,68) of @code{mylib.lib}. This file can be viewed with (for example)
lib2doc.texi(,69) @smallexample
lib2doc.texi(,70) netscape mylib.html
lib2doc.texi(,71) @end smallexample
lib2doc.texi(,72) @item make clean
lib2doc.texi(,73) Deletes all generated files.
lib2doc.texi(,74) @end table
lib2doc.texi(,75) 
lib2doc.texi(,76) 
lib2doc.texi(,77) Note that you can safely ignore messages complaining about undefined
lib2doc.texi(,78) references.  
lib2doc.texi(,79) 
lib2doc.texi(,80) @end enumerate
lib2doc.texi(,81) 
general.tex(,4102) 
general.tex(,4103) @c ----------------------------------------
general.tex(,4104) @node Typesetting of help strings, The help string of a library, Documentation of a library, Guidelines for writing a library
general.tex(,4105) @subsection Typesetting of help strings
general.tex(,4106) @cindex Typesetting of help strings
general.tex(,4107) @cindex library, typesetting of help strings
general.tex(,4108) 
general.tex(,4109) The help strings of procedures and info strings of libraries which are
general.tex(,4110) included in the
general.tex(,4111) distribution of @sc{Singular} are parsed and automatically converted
general.tex(,4112) into the texinfo format (the typesetting language in which the
general.tex(,4113) documentation  of @sc{Singular} is written).
general.tex(,4114) 
general.tex(,4115) For optimal typesetting results, the guidelines for writing libraries
general.tex(,4116) and procedures should be followed, and the following points should be
general.tex(,4117) kept in mind:
general.tex(,4118) 
general.tex(,4119) @itemize @bullet
general.tex(,4120) @item
general.tex(,4121) If a help string starts with an @code{@@} sign, then no parsing is done,
general.tex(,4122) and the help string is assumed to be already in the texinfo format.
general.tex(,4123) @item
general.tex(,4124) help strings are typeset within a @code{@@table @@asis} environment
general.tex(,4125) (which is similar to a latex @code{description} environment).
general.tex(,4126) @item
general.tex(,4127) If a line starts with  only uppercase words and contains a colon, then
general.tex(,4128) the text up
general.tex(,4129) to the colon is taken to be the description-string of an item and the
general.tex(,4130) text following the colon is taken to be the content of the item.
general.tex(,4131) @item
general.tex(,4132) If the description-string of an item matches
general.tex(,4133) @table @asis
general.tex(,4134) @item @code{EXAMPLE}
general.tex(,4135) then this item and its content is ignored.
general.tex(,4136) @item @code{SEE ALSO}
general.tex(,4137) then the
general.tex(,4138) content of the item is assumed to be comma-separated words which are
general.tex(,4139) valid references to other texinfo nodes of the manual. (e.g., all
general.tex(,4140) procedure and command names are also texinfo nodes).
general.tex(,4141) @item  @code{KEYWORDS} (or, @code{KEYPHRASES})
general.tex(,4142) then the content of the item is assumed to be a
general.tex(,4143) semicolon-separated list of phrases which are taken as keys for the
general.tex(,4144) index of the manual (N.B. the name of a procedure/library is
general.tex(,4145) automatically added to the index keys).
general.tex(,4146) @item @code{PROCEDURES}
general.tex(,4147) then the
general.tex(,4148) content of the item is assumed to be a summary description of the
general.tex(,4149) procedures contained in the library. Separate texinfo nodes (subsections
general.tex(,4150) in printed documents) are
general.tex(,4151) @strong{only} created out of the help strings of such procedures which
general.tex(,4152) appear in the summary description of a library.
general.tex(,4153) @item @code{LIBRARY}
general.tex(,4154) then the content of the item is assumed to be a one-line description of
general.tex(,4155) a library. If this one-line description consist of only uppercase
general.tex(,4156) characters, then it is typeset in all lowercase characters in the
general.tex(,4157) manual (otherwise it is left as is).
general.tex(,4158) @end table
general.tex(,4159) 
general.tex(,4160) @item
general.tex(,4161) For the content of an item, the following texinfo markup elements
general.tex(,4162) are recognized (and, their content not further manipulated):
general.tex(,4163) @table @asis
general.tex(,4164) @item @code{@@*}
general.tex(,4165) to enforce a line-break.
general.tex(,4166) @table @asis
general.tex(,4167) @item Example:
general.tex(,4168) @code{old line @@* new line}
general.tex(,4169) @* @expansion{}
general.tex(,4170) @* old line @* new line
general.tex(,4171) @end table
general.tex(,4172) 
general.tex(,4173) @item @code{@@ref@{...@}}
general.tex(,4174) References to other parts of the @sc{Singular} manual can be set using
general.tex(,4175) one of the following @code{@@ref@{node@}} constructs. Notice that
general.tex(,4176) @code{node} must be the name of a section of the @sc{Singular}
general.tex(,4177) manual. In particular, it may be a name of a function, library or library
general.tex(,4178) procedure.
general.tex(,4179) 
general.tex(,4180) @table @asis
general.tex(,4181) @item @code{@@xref@{node@}}
general.tex(,4182) for a reference to the node @code{node} at the beginning of a sentence.
general.tex(,4183) @item @code{@@ref@{node@}}
general.tex(,4184) for a reference to the node @code{node} at the end of a sentence.
general.tex(,4185) @item @code{@@pxref@{node@}}
general.tex(,4186) for a reference to the node @code{node} within parenthesis.
general.tex(,4187) 
general.tex(,4188) @item Example:
general.tex(,4189) @code{@@xref@{Tropical Storms@}, for more info.}
general.tex(,4190) @*@expansion{}*Note Hurricanes::, for more info.
general.tex(,4191) @*@expansion{}See Section 3.1 [Hurricanes], page 24, for more info.
general.tex(,4192) 
general.tex(,4193) @code{For more information, see @@ref@{Hurricanes@}.}
general.tex(,4194) @*@expansion{}For more information, see *Note Hurricanes::.
general.tex(,4195) @*@expansion{}For more information, see Section 3.1 [Hurricanes], page 24.
general.tex(,4196) 
general.tex(,4197) 
general.tex(,4198) @code{... storms cause flooding (@@pxref@{Hurricanes@}) ...}
general.tex(,4199) @*@expansion{}... storms cause flooding (*Note Hurricanes::) ...
general.tex(,4200) @*@expansion{}... storms cause flooding (see Section 3.1 [Hurricanes],
general.tex(,4201) page 24)
general.tex(,4202) @end table
general.tex(,4203) 
general.tex(,4204) @item @code{@@math@{..@}}
general.tex(,4205) for typesetting of small (i.e., which do not go over
general.tex(,4206) multiple lines) mathematical expressions  in LaTeX math-mode
general.tex(,4207) syntax.
general.tex(,4208) @table @asis
general.tex(,4209) @item Example:
general.tex(,4210) @code{@@math@{\alpha@}}
general.tex(,4211) @*@expansion{}
general.tex(,4212) @*
general.tex(,4219) 
general.tex(,4220) @item Note:
general.tex(,4221) Mathematical expressions inside @code{@@math@{..@}} may
general.tex(,4222) not contain curly parenthesis and the "at" sign, i.e., may not contain
general.tex(,4223) @code{@{,@},@@}.
general.tex(,4224) @end table
general.tex(,4225) 
general.tex(,4226) @item @code{@@code@{..@}}
general.tex(,4227) for typesetting of small (i.e., which do not go over
general.tex(,4228) multiple lines) strings in typewriter font.
general.tex(,4229) @table @asis
general.tex(,4230) @item Example:
general.tex(,4231) @code{@@code@{typewriter font@}}
general.tex(,4232) @*@expansion{}
general.tex(,4233) @*@code{typewriter font}
general.tex(,4234) @item Note:
general.tex(,4235) The string inside @code{@@code@{..@}} may
general.tex(,4236) not contain curly parenthesis and the "at" sign, i.e., may not contain
general.tex(,4237) @code{@{,@},@@}.
general.tex(,4238) @end table
general.tex(,4239) 
general.tex(,4240) @item @code{@@example}
general.tex(,4241)  @code{...}
general.tex(,4242) @item @code{@@end example}
general.tex(,4243) for pre-formatted text which is indented and typeset in typewriter
general.tex(,4244) font.
general.tex(,4245) @table @asis
general.tex(,4246) @item Example:
general.tex(,4247) @example
general.tex(,4248) before example
general.tex(,4249) @@example
general.tex(,4250) in              example
general.tex(,4251) notice extra identation and
general.tex(,4252) escape of special characters like @@@{,@@@},@@@@
general.tex(,4253) @@end example
general.tex(,4254) after example
general.tex(,4255) @end example
general.tex(,4256) @expansion{}
general.tex(,4257) @*before example
general.tex(,4258) @example
general.tex(,4259) in                example
general.tex(,4260) notice extra identation  and
general.tex(,4261) escape of special characters like @{,@},@@
general.tex(,4262) @end example
general.tex(,4263) after example
general.tex(,4264) @item Note:
general.tex(,4265) The characters @{,@},@@ have to be escaped by an @@ sign inside an
general.tex(,4266) @@example environment.
general.tex(,4267) @end table
general.tex(,4268) 
general.tex(,4269) @item @code{@@format}
general.tex(,4270)  @code{...}
general.tex(,4271) @item @code{@@end format}
general.tex(,4272) for pre-formatted text which is not indented and typeset in normal
general.tex(,4273) font.
general.tex(,4274) @table @asis
general.tex(,4275) @item Example:
general.tex(,4276) @example
general.tex(,4277) before format
general.tex(,4278) @@format
general.tex(,4279) in              format
general.tex(,4280) no extra identation but still
general.tex(,4281) escape of special characters like @@@{,@@@},@@@@
general.tex(,4282) @@end format
general.tex(,4283) after format
general.tex(,4284) @end example
general.tex(,4285) @expansion{}
general.tex(,4286) @*before format
general.tex(,4287) @format
general.tex(,4288) in              format
general.tex(,4289) no extra identation  but still
general.tex(,4290) escape of special characters like @{,@},@@
general.tex(,4291) @end format
general.tex(,4292) after format
general.tex(,4293) @item Note:
general.tex(,4294) The characters @{,@},@@ have to be escaped by an @@ sign inside an
general.tex(,4295) @@example environment.
general.tex(,4296) @end table
general.tex(,4297) 
general.tex(,4298) 
general.tex(,4299) @item @code{@@texinfo}
general.tex(,4300)  @code{...}
general.tex(,4301) @item @code{@@end texinfo}
general.tex(,4302) for text which is written in pure texinfo.
general.tex(,4303) @table @asis
general.tex(,4304) @item Example:
general.tex(,4305) @example
general.tex(,4306) @@texinfo
general.tex(,4307) Among others, within a texinfo environment
general.tex(,4308) one can use the tex environment to typeset
general.tex(,4309) more complex mathematical like
general.tex(,4310) @@tex
general.tex(,4311) $i_@{1,1@} $
general.tex(,4312) @@tex
general.tex(,4313) @@end texinfo
general.tex(,4314) @end example
general.tex(,4315) @*@expansion{}
general.tex(,4316) @*Among others, within a texinfo environment one can use the tex environment
general.tex(,4317) to typeset more complex mathematical like
general.tex(,4321) @end table
general.tex(,4322) 
general.tex(,4323) @end table
general.tex(,4324) 
general.tex(,4325) Furthermore, a line-break is inserted in front of each line
general.tex(,4326) whose previous line is shorter than 60
general.tex(,4327) characters and does not contain any of the above described recognized
general.tex(,4328) texinfo markup elements.
general.tex(,4329) @end itemize
general.tex(,4330) 
general.tex(,4331) See also @ref{template_lib} for an examples of the typesetting rules
general.tex(,4332) explained here.
general.tex(,4333) 
general.tex(,4334) @c ----------------------------------------
general.tex(,4335) @node The help string of a library, The help string of procedures, Typesetting of help strings, Guidelines for writing a library
general.tex(,4336) @subsection The help string of a library
general.tex(,4337) @cindex help string of a library
general.tex(,4338) @cindex library, help string
general.tex(,4339) @cindex library, info string
general.tex(,4340) @cindex info string of a library
general.tex(,4341) 
general.tex(,4342) The help (or, info) string of a library should have the following format:
general.tex(,4343) 
general.tex(,4344) @smallexample
general.tex(,4345) info="
general.tex(,4346) LIBRARY: <library_name> <one line description of the content>
general.tex(,4347) AUTHOR:  <name, and email address of author>
general.tex(,4348) [SEE ALSO: <comma-separated words of cross references>]
general.tex(,4349) [KEYWORDS: <semicolon-separated phrases of index keys>]
general.tex(,4350) PROCEDURES:
general.tex(,4351)   <procedure1>;     <one line description of the purpose>
general.tex(,4352)    .
general.tex(,4353)    .
general.tex(,4354)   <procedureN>;     <one line description of the purpose>
general.tex(,4355) ";
general.tex(,4356) @end smallexample
general.tex(,4357) Only such procedures should be listed in the @code{PROCEDURE} section
general.tex(,4358) which are not @code{static} and which
general.tex(,4359) have a help and example section.
general.tex(,4360) 
general.tex(,4361) The purpose of the one line procedure descriptions is not to give a short help
general.tex(,4362) for the procedure, but to help the user decide what procedure might be
general.tex(,4363) the right one for the job. Details can then be found in the help section
general.tex(,4364) of each procedure. Therefore parameters may be omitted or abbreviated if
general.tex(,4365) necessary. If this description consists of only upper-case characters,
general.tex(,4366) then it will be typeset in all lowercase characters in the manual.
general.tex(,4367) 
general.tex(,4368) For more information, see @ref{Typesetting of help strings}. For an
general.tex(,4369) example, see @ref{template_lib}.
general.tex(,4370) 
general.tex(,4371) 
general.tex(,4372) @c ----------------------------------------
general.tex(,4373) @node The help string of procedures, template_lib, The help string of a library, Guidelines for writing a library
general.tex(,4374) @subsection The help string of procedures
general.tex(,4375) @cindex help string of a procedure
general.tex(,4376) @cindex procedures, help string
general.tex(,4377) 
general.tex(,4378) The help string of a procedure should have the following format:
general.tex(,4379) 
general.tex(,4380) @smallexample
general.tex(,4381) USAGE:    <proc_name>(<parameters>);   <explanation of parameters>
general.tex(,4382) [CREATE:  <description of created objects which are not returned>]
general.tex(,4383) RETURN:   <description of the purpose and return value>
general.tex(,4384) [NOTE:    <particular assumptions or limitations, details>]
general.tex(,4385) [SEE ALSO: <comma-separated names of related procedures/cross references>]
general.tex(,4386) [KEYWORDS: <semicolon-separated phrases of index keys>]
general.tex(,4387) EXAMPLE:  example <proc_name>; shows an example
general.tex(,4388) @end smallexample
general.tex(,4389) 
general.tex(,4390) Further arbitrary items (like @code{THEORY:}, or @code{BACKGROUND:}) are
general.tex(,4391) recognized, as well, but should be used diligently.
general.tex(,4392) 
general.tex(,4393) Remember that help strings are formatted as explained in
general.tex(,4394) @ref{Typesetting of help strings}. In particular, descriptions may
general.tex(,4395) contain the texinfo markup elements @code{@@*, @@math@{..@},
general.tex(,4396) @@code@{..@}, @@example, @@format, @@texinfo} to better control their
general.tex(,4397) typesetting. See @ref{msum}, @ref{mdouble}, @ref{mtripple} for examples.
general.tex(,4398) 
general.tex(,4399) @c ----------------------------------------
general.tex(,4400) @node template_lib,, The help string of procedures, Guidelines for writing a library
general.tex(,4401) @subsection template_lib
general.tex(,4402) @cindex template_lib
general.tex(,4403) @cindex Template for writing a library
general.tex(,4404) @cindex library, template
general.tex(,4405) 
general.tex(,4406) First, we show the source-code of a template library:
general.tex(,4407) @smallexample
general.tex(,4408) @c begin included file template.lib from general.doc:3933
general.tex(,4409) ////////////////////////////////////////////////////////////////////
general.tex(,4410) // version string automatically expanded by CVS
general.tex(,4411) 
general.tex(,4412) version="Id: general.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $";
general.tex(,4413) category="Miscellaneous";
general.tex(,4414) // summary description of the library
general.tex(,4415) info="
general.tex(,4416) LIBRARY:   template.lib  A Template for a Singular Library
general.tex(,4417) AUTHOR:    Olaf Bachmann, email: obachman@@mathematik.uni-kl.de
general.tex(,4418) 
general.tex(,4419) SEE ALSO:  standard_lib, Guidelines for writing a library,
general.tex(,4420)            Typesetting of help strings
general.tex(,4421) 
general.tex(,4422) KEYWORDS: library, template.lib; template.lib; library, info string
general.tex(,4423) 
general.tex(,4424) PROCEDURES:
general.tex(,4425)   mdouble(int)           return double of int argument
general.tex(,4426)   mtripple(int)          return three times int argument
general.tex(,4427)   msum([int,..,int])     sum of int arguments
general.tex(,4428) ";
general.tex(,4429) ////////////////////////////////////////////////////////////////////
general.tex(,4430) proc mdouble(int i)
general.tex(,4431) "USAGE:    mdouble(i); i int
general.tex(,4432) RETURN:   int: i+i
general.tex(,4433) NOTE:     Help string is in pure ASCII
general.tex(,4434)           this line starts on a new line since previous line is short
general.tex(,4435)           mdouble(i): no new line
general.tex(,4436) SEE ALSO: msum, mtripple, Typesetting of help strings
general.tex(,4437) KEYWORDS: procedure, ASCII help
general.tex(,4438) EXAMPLE:  example mdouble; shows an example"
general.tex(,4439) @{
general.tex(,4440)   return (i + i);
general.tex(,4441) @}
general.tex(,4442) example
general.tex(,4443) @{ "EXAMPLE:"; echo = 2;
general.tex(,4444)   mdouble(0);
general.tex(,4445)   mdouble(-1);
general.tex(,4446) @}
general.tex(,4447) ////////////////////////////////////////////////////////////////////
general.tex(,4448) proc mtripple(int i)
general.tex(,4449) "@@c we do texinfo here
general.tex(,4450) @@table @@asis
general.tex(,4451) @@item @@strong@{Usage:@}
general.tex(,4452) @@code@{mtripple(i)@}; @@code@{i@} int
general.tex(,4453) 
general.tex(,4454) @@item @@strong@{Return:@}
general.tex(,4455) int: @@math@{i+i+i@}
general.tex(,4456) @@item @@strong@{Note:@}
general.tex(,4457) Help is in pure Texinfo
general.tex(,4458) @@*This help string is written in texinfo, which enables you to use,
general.tex(,4459) among others, the @@@@math command for mathematical typesetting (like
general.tex(,4460) @@math@{\alpha, \beta@}).
general.tex(,4461) @@*It also gives more control over the layout, but is, admittingly,
general.tex(,4462) more cumbersome to write.
general.tex(,4463) @@end table
general.tex(,4464) @@c use @@c ref contstuct for references
general.tex(,4465) @@cindex procedure, texinfo help
general.tex(,4466) @@c ref
general.tex(,4467) @@strong@{See also:@}
general.tex(,4468) @@ref@{mdouble@}, @@ref@{msum@}, @@ref@{Typesetting of help strings@}
general.tex(,4469) @@c ref
general.tex(,4470) "
general.tex(,4471) @{
general.tex(,4472)   return (i + i + i);
general.tex(,4473) @}
general.tex(,4474) example
general.tex(,4475) @{ "EXAMPLE:"; echo = 2;
general.tex(,4476)   mtripple(0);
general.tex(,4477)   mtripple(-1);
general.tex(,4478) @}
general.tex(,4479) ////////////////////////////////////////////////////////////////////
general.tex(,4480) proc msum(list #)
general.tex(,4481) "USAGE:  msum([i_1,..,i_n]); @@code@{i_1,..,i_n@} def
general.tex(,4482) RETURN:  Sum of int arguments
general.tex(,4483) NOTE:    This help string is written in a mixture of ASCII and texinfo
general.tex(,4484)          @@* Use a @@ref constructs for references (like @@pxref@{mtripple@})
general.tex(,4485)          @@* Use @@code  for typewriter font (like @@code@{i_1@})
general.tex(,4486)          @@* Use @@math  for simple math mode typesetting (like @@math@{i_1@}).
general.tex(,4487)          @@* Note: No parenthesis like @} are allowed inside @@math and @@code
general.tex(,4488)          @@* Use @@example for indented preformatted text typeset in typewriter
general.tex(,4489)          font like
general.tex(,4490) @@example
general.tex(,4491)          this  --> that
general.tex(,4492) @@end example
general.tex(,4493)         Use @@format  for preformatted text typeset in normal font
general.tex(,4494) @@format
general.tex(,4495)          this --> that
general.tex(,4496) @@end format
general.tex(,4497)         Use @@texinfo for text in pure texinfo
general.tex(,4498) @@texinfo
general.tex(,4499) @@expansion@{@}
general.tex(,4500) @@tex
general.tex(,4501) $i_@{1,1@}$
general.tex(,4502) @@end tex
general.tex(,4503) 
general.tex(,4504) @@end texinfo
general.tex(,4505)         Notice that
general.tex(,4506)         automatic linebreaking         is still in affect (like on this line).
general.tex(,4507) SEE ALSO: mdouble, mtripple, Typesetting of help strings
general.tex(,4508) KEYWORDS: procedure, ASCII/Texinfo help
general.tex(,4509) EXAMPLE: example msum; shows an example"
general.tex(,4510) @{
general.tex(,4511)   if (size(#) == 0) @{ return (0);@}
general.tex(,4512)   if (size(#) == 1) @{ return (#[1]);@}
general.tex(,4513)   int i;
general.tex(,4514)   def s = #[1];
general.tex(,4515)   for (i=2; i<=size(#); i++)
general.tex(,4516)   @{
general.tex(,4517)     s = s + #[i];
general.tex(,4518)   @}
general.tex(,4519)   return (s);
general.tex(,4520) @}
general.tex(,4521) example
general.tex(,4522) @{ "EXAMPLE:"; echo = 2;
general.tex(,4523)   msum();
general.tex(,4524)   msum(4);
general.tex(,4525)   msum(1,2,3,4);
general.tex(,4526) @}
general.tex(,4527) @c end included file from general.doc:3933
general.tex(,4528) @end smallexample
general.tex(,4529) 
general.tex(,4530) After typesetting, the library appears in the document as follows (with
general.tex(,4531) one subsection for each procedure):
general.tex(,4532) 
general.tex(,4533) @c include of docu for template.lib
template_lib.tex(,1) @c ---content LibInfo---
template_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/template_lib.doc
template_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/template_lib.doc INSTEAD
template_lib.tex(,4) @c library version: (1.10,2001/01/16)
template_lib.tex(,5) @c library file: ../Singular/LIB/template.lib
template_lib.tex(,6) @cindex template.lib
template_lib.tex(,7) @cindex template_lib
template_lib.tex(,8) @table @asis
template_lib.tex(,9) @item @strong{Library:}
template_lib.tex(,10) template.lib
template_lib.tex(,11) @item @strong{Purpose:}
template_lib.tex(,12)   A Template for a Singular Library
template_lib.tex(,13) @item @strong{Author:}
template_lib.tex(,14) Olaf Bachmann, email: obachman@@mathematik.uni-kl.de
template_lib.tex(,15) 
template_lib.tex(,16) @cindex library, template.lib
template_lib.tex(,17) @cindex template.lib
template_lib.tex(,18) @cindex library, info string
template_lib.tex(,19) @end table
template_lib.tex(,20) 
template_lib.tex(,21) @strong{Procedures:}
template_lib.tex(,22) @menu
template_lib.tex(,23) * mdouble:: return double of int argument
template_lib.tex(,24) * mtripple:: return three times int argument
template_lib.tex(,25) * msum:: sum of int arguments
template_lib.tex(,26) @end menu
template_lib.tex(,27) @c inserted refs from d2t_singular/template_lib.doc:25
template_lib.tex(,42) @c end inserted refs from d2t_singular/template_lib.doc:25
template_lib.tex(,43) 
template_lib.tex(,44) @c ---end content LibInfo---
template_lib.tex(,45) 
template_lib.tex(,46) @c ------------------- mdouble -------------
template_lib.tex(,47) @node mdouble, mtripple,, template_lib
template_lib.tex(,48) @subsubsection mdouble
template_lib.tex(,49) @cindex mdouble
template_lib.tex(,50) @c ---content mdouble---
template_lib.tex(,51) Procedure from library @code{template.lib} (@pxref{template_lib}).
template_lib.tex(,52) 
template_lib.tex(,53) @table @asis
template_lib.tex(,54) @item @strong{Usage:}
template_lib.tex(,55) mdouble(i); i int
template_lib.tex(,56) 
template_lib.tex(,57) @item @strong{Return:}
template_lib.tex(,58) int: i+i
template_lib.tex(,59) 
template_lib.tex(,60) @item @strong{Note:}
template_lib.tex(,61) Help string is in pure ASCII
template_lib.tex(,62) @*this line starts on a new line since previous line is short
template_lib.tex(,63) mdouble(i): no new line
template_lib.tex(,64) 
template_lib.tex(,65) @cindex procedure, ASCII help
template_lib.tex(,66) @end table
template_lib.tex(,67) @strong{Example:}
template_lib.tex(,68) @smallexample
template_lib.tex(,69) @c computed example mdouble d2t_singular/template_lib.doc:54 
template_lib.tex(,70) LIB "template.lib";
template_lib.tex(,71) mdouble(0);
template_lib.tex(,72) @expansion{} 0
template_lib.tex(,73) mdouble(-1);
template_lib.tex(,74) @expansion{} -2
template_lib.tex(,75) @c end example mdouble d2t_singular/template_lib.doc:54
template_lib.tex(,76) @end smallexample
template_lib.tex(,77) @c inserted refs from d2t_singular/template_lib.doc:60
template_lib.tex(,92) @c end inserted refs from d2t_singular/template_lib.doc:60
template_lib.tex(,93) 
template_lib.tex(,94) @c ---end content mdouble---
template_lib.tex(,95) 
template_lib.tex(,96) @c ------------------- mtripple -------------
template_lib.tex(,97) @node mtripple, msum, mdouble, template_lib
template_lib.tex(,98) @subsubsection mtripple
template_lib.tex(,99) @cindex mtripple
template_lib.tex(,100) @c ---content mtripple---
template_lib.tex(,101) Procedure from library @code{template.lib} (@pxref{template_lib}).
template_lib.tex(,102) 
template_lib.tex(,103) @c we do texinfo here
template_lib.tex(,104) @table @asis
template_lib.tex(,105) @item @strong{Usage:}
template_lib.tex(,106) @code{mtripple(i)}; @code{i} int
template_lib.tex(,107) 
template_lib.tex(,108) @item @strong{Return:}
template_lib.tex(,109) int: 
template_lib.tex(,116) 
template_lib.tex(,117) @item @strong{Note:}
template_lib.tex(,118) Help is in pure Texinfo
template_lib.tex(,119) @*This help string is written in texinfo, which enables you to use,
template_lib.tex(,120) among others, the @@math command for mathematical typesetting (like
template_lib.tex(,121) 
template_lib.tex(,128) ).
template_lib.tex(,129) @*It also gives more control over the layout, but is, admittingly,
template_lib.tex(,130) more cumbersome to write.
template_lib.tex(,131) @end table
template_lib.tex(,132) @c use @c ref contstuct for references
template_lib.tex(,133) @cindex procedure, texinfo help
template_lib.tex(,134) @c inserted refs from d2t_singular/template_lib.doc:90
template_lib.tex(,149) @c end inserted refs from d2t_singular/template_lib.doc:90
template_lib.tex(,150) 
template_lib.tex(,151) @strong{Example:}
template_lib.tex(,152) @smallexample
template_lib.tex(,153) @c computed example mtripple d2t_singular/template_lib.doc:97 
template_lib.tex(,154) LIB "template.lib";
template_lib.tex(,155) mtripple(0);
template_lib.tex(,156) @expansion{} 0
template_lib.tex(,157) mtripple(-1);
template_lib.tex(,158) @expansion{} -3
template_lib.tex(,159) @c end example mtripple d2t_singular/template_lib.doc:97
template_lib.tex(,160) @end smallexample
template_lib.tex(,161) @c ---end content mtripple---
template_lib.tex(,162) 
template_lib.tex(,163) @c ------------------- msum -------------
template_lib.tex(,164) @node msum,, mtripple, template_lib
template_lib.tex(,165) @subsubsection msum
template_lib.tex(,166) @cindex msum
template_lib.tex(,167) @c ---content msum---
template_lib.tex(,168) Procedure from library @code{template.lib} (@pxref{template_lib}).
template_lib.tex(,169) 
template_lib.tex(,170) @table @asis
template_lib.tex(,171) @item @strong{Usage:}
template_lib.tex(,172) msum([i_1,..,i_n]); @code{i_1,..,i_n} def
template_lib.tex(,173) 
template_lib.tex(,174) @item @strong{Return:}
template_lib.tex(,175) Sum of int arguments
template_lib.tex(,176) 
template_lib.tex(,177) @item @strong{Note:}
template_lib.tex(,178) This help string is written in a mixture of ASCII and texinfo
template_lib.tex(,179) @* Use a @@ref constructs for references (like @pxref{mtripple})
template_lib.tex(,180) @* Use @@code for typewriter font (like @code{i_1})
template_lib.tex(,181) @* Use @@math for simple math mode typesetting (like 
template_lib.tex(,188) ).
template_lib.tex(,189) @* Note: No parenthesis like @} are allowed inside @@math and @@code
template_lib.tex(,190) @* Use @@example for indented preformatted text typeset in typewriter
template_lib.tex(,191) font like
template_lib.tex(,192) @smallexample
template_lib.tex(,193)          this  --> that
template_lib.tex(,194) @end smallexample
template_lib.tex(,195) Use @@format for preformatted text typeset in normal font
template_lib.tex(,196) @format
template_lib.tex(,197)          this --> that
template_lib.tex(,198) @end format
template_lib.tex(,199) Use @@texinfo for text in pure texinfo
template_lib.tex(,200) 
template_lib.tex(,201) @expansion{}
template_lib.tex(,205) 
template_lib.tex(,206) 
template_lib.tex(,207) Notice that
template_lib.tex(,208) @*automatic linebreaking is still in affect (like on this line).
template_lib.tex(,209) 
template_lib.tex(,210) @cindex procedure, ASCII/Texinfo help
template_lib.tex(,211) @end table
template_lib.tex(,212) @strong{Example:}
template_lib.tex(,213) @smallexample
template_lib.tex(,214) @c computed example msum d2t_singular/template_lib.doc:149 
template_lib.tex(,215) LIB "template.lib";
template_lib.tex(,216) msum();
template_lib.tex(,217) @expansion{} 0
template_lib.tex(,218) msum(4);
template_lib.tex(,219) @expansion{} 4
template_lib.tex(,220) msum(1,2,3,4);
template_lib.tex(,221) @expansion{} 10
template_lib.tex(,222) @c end example msum d2t_singular/template_lib.doc:149
template_lib.tex(,223) @end smallexample
template_lib.tex(,224) @c inserted refs from d2t_singular/template_lib.doc:156
template_lib.tex(,239) @c end inserted refs from d2t_singular/template_lib.doc:156
template_lib.tex(,240) 
template_lib.tex(,241) @c ---end content msum---
general.tex(,4535) 
general.tex(,4536) @c ----------------------------------------------------------------------
general.tex(,4537) @node Debugging tools,  , Guidelines for writing a library, General concepts
general.tex(,4538) @section Debugging tools
general.tex(,4539) @cindex Debugging tools
general.tex(,4540) 
general.tex(,4541) If @sc{Singular} does not come back to the prompt while calling a user
general.tex(,4542) defined procedure, probably a bracket or a @code{"} is missing.  The
general.tex(,4543) easiest way to leave the procedure is to type some brackets or @code{"}
general.tex(,4544) and then @key{RETURN} .
general.tex(,4545) 
general.tex(,4546) @menu
general.tex(,4547) * Tracing of procedures::
general.tex(,4548) * Source code debugger::
general.tex(,4549) * Break points::
general.tex(,4550) * Printing of data::
general.tex(,4551) * libparse::
general.tex(,4552) @end menu
general.tex(,4553) 
general.tex(,4554) @c ---------------------------------------
general.tex(,4555) @node Tracing of procedures,Source code debugger,Debugging tools,Debugging tools
general.tex(,4556) @subsection Tracing of procedures
general.tex(,4557) Setting the @code{TRACE} variable to 1 (resp.@: 3) results in a listing of
general.tex(,4558) the called procedures (resp.@: together with line numbers).
general.tex(,4559) If @code{TRACE} is set to 4, @code{Singular}
general.tex(,4560) displays each line before its interpretation and waits for the @key{RETURN}
general.tex(,4561) key being pressed.
general.tex(,4562) @menu
general.tex(,4563) * TRACE var::
general.tex(,4564) @end menu
general.tex(,4568) 
general.tex(,4569) @strong{Example:}
general.tex(,4570) @smallexample
general.tex(,4571) @c computed example Tracing_of_procedures general.doc:3976 
general.tex(,4572)   proc t1
general.tex(,4573)   @{
general.tex(,4574)     int i=2;
general.tex(,4575)     while (i>0)
general.tex(,4576)     @{ i=i-1; @}
general.tex(,4577)   @}
general.tex(,4578)   TRACE=3;
general.tex(,4579)   t1();
general.tex(,4580) @expansion{} 
general.tex(,4581) @expansion{} entering t1 (level 0)
general.tex(,4582) @expansion{} @{1@}@{2@}@{3@}@{4@}@{5@}@{4@}@{5@}@{6@}@{7@}@{4@}@{5@}@{6@}@{7@}@{4@}@{6@}@{7@}@{8@}
general.tex(,4583) @expansion{} leaving  t1 (level 0)
general.tex(,4584) @c end example Tracing_of_procedures general.doc:3976
general.tex(,4585) @end smallexample
general.tex(,4586) 
general.tex(,4587) @c ---------------------------------------
general.tex(,4588) @node Source code debugger, Break points, Tracing of procedures, Debugging tools
general.tex(,4589) @subsection Source code debugger
general.tex(,4590) @cindex debugging library code
general.tex(,4591) @cindex source code debugger, sdb
general.tex(,4592) @cindex debugger
general.tex(,4593) @cindex sdb, source code debugger
general.tex(,4594) 
general.tex(,4595) 
general.tex(,4596) The source code debugger (sdb) is an experimental feature, it's
general.tex(,4597) interface may change in future versions of Singular.  @*To enable the
general.tex(,4598) use of the source code debugger @sc{Singular} has to be started with the
general.tex(,4599) option @code{-d} or @code{--sdb} (see @ref{Command line options}).
general.tex(,4600) 
general.tex(,4601) 
general.tex(,4602) @subsubheading sdb commands
general.tex(,4603) Each sdb command consist of one character which may be followed by
general.tex(,4604) a parameter.
general.tex(,4605) @table @asis
general.tex(,4606) @item @code{b}
general.tex(,4607) print backtrace of calling stack
general.tex(,4608) @item @code{c}
general.tex(,4609) continue
general.tex(,4610) @item @code{e}
general.tex(,4611) edit the current procedure and reload it (current call will be aborted)
general.tex(,4612) @* only available on UNIX systems
general.tex(,4613) @item @code{h},@code{?}
general.tex(,4614) display help screen
general.tex(,4615) @item @code{n}
general.tex(,4616) execute current line, sdb break at next line
general.tex(,4617) @item @code{p} <identifier>
general.tex(,4618) display type and value of the variable given by <identifier>
general.tex(,4619) @item @code{Q}
general.tex(,4620) quit this Singular session
general.tex(,4621) @item @code{q} <flags>
general.tex(,4622) quit debugger, set debugger flags(0,1,2)
general.tex(,4623) @* 0: continue, disable the debugger
general.tex(,4624) @* 1: continue
general.tex(,4625) @* 2: throw an error, return to toplevel
general.tex(,4626) @end table
general.tex(,4627) 
general.tex(,4628) 
general.tex(,4629) @subsubheading Syntactical errors in procedures
general.tex(,4630) If @sc{Singular} was started with the command line option @code{-d} or
general.tex(,4631) @code{--sdb} a syntactical error in a procedure will start the
general.tex(,4632) source code debugger instead of returning to the top level with an
general.tex(,4633) error message. The commands @code{q 1} and @code{q 2} are equivalent in this
general.tex(,4634) case.
general.tex(,4635) 
general.tex(,4636) @subsubheading SDB breakpoints in procedures
general.tex(,4637) @cindex SDB breakpoint
general.tex(,4638) @cindex SDB debugger
general.tex(,4639) Up to seven SDB breakpoints can be set.
general.tex(,4640) To set a breakpoint at a procedure use
general.tex(,4641) @code{breakpoint}. (See @ref{breakpoint}).
general.tex(,4642) @*These breakpoints can be cleared with the command @code{d breakpoint_no}
general.tex(,4643) from within the debugger or with
general.tex(,4644) @code{breakpoint(} proc_name @code{,-1);}.
general.tex(,4645) 
general.tex(,4646) 
general.tex(,4647) @c ---------------------------------------
general.tex(,4648) @node Break points, Printing of data, Source code debugger, Debugging tools
general.tex(,4649) @subsection Break points
general.tex(,4650) A break point can be put into a proc by inserting the command @code{~}.
general.tex(,4651) If @code{Singular} reaches a break point it asks for lines of commands
general.tex(,4652) (line-length must be less than 80 characters)
general.tex(,4653) from the user. It returns to normal execution if given an empty line.
general.tex(,4654) See @ref{~}.
general.tex(,4655) 
general.tex(,4656) 
general.tex(,4657) @strong{Example:}
general.tex(,4658) @smallexample
general.tex(,4659) proc t
general.tex(,4660) @{
general.tex(,4661)   int i=2;
general.tex(,4662)   ~;
general.tex(,4663)   return(i+1);
general.tex(,4664) @}
general.tex(,4665) t();
general.tex(,4666) @expansion{} -- break point in t --
general.tex(,4667) @expansion{} -- 0: called    from STDIN --
general.tex(,4668) i;               // here local variables of the procedure can be accessed
general.tex(,4669) @expansion{} 2
general.tex(,4670) @expansion{} -- break point in t --
general.tex(,4671) 
general.tex(,4672) @expansion{} 3
general.tex(,4673) @end smallexample
general.tex(,4674) @sp 2
general.tex(,4675) 
general.tex(,4676) @c ---------------------------------------
general.tex(,4677) @node Printing of data,libparse,Break points,Debugging tools
general.tex(,4678) @subsection Printing of data
general.tex(,4679) The procedure @code{dbprint} is useful for optional output of data:
general.tex(,4680) it takes 2 arguments and prints the second argument, if the first
general.tex(,4681) argument is positive; it does nothing otherwise.
general.tex(,4682) @menu
general.tex(,4683) * dbprint::
general.tex(,4684) * voice::
general.tex(,4685) @end menu
general.tex(,4691) 
general.tex(,4692) @c ---------------------------------------
general.tex(,4693) @node libparse,,Printing of data,Debugging tools
general.tex(,4694) @subsection libparse
general.tex(,4695) @cindex libparse
general.tex(,4696) 
general.tex(,4697) @code{libparse} is a stand-alone program contained in the @sc{Singular}
general.tex(,4698) distribution (at the place where the @sc{Singular} executable program
general.tex(,4699) resides), which cannot be called inside of @sc{Singular}. It is a
general.tex(,4700) debugging tool for libraries which performs exactly the same checks as
general.tex(,4705) the @code{LIB} command in @sc{Singular}, but generates more output during
general.tex(,4707) parsing.  @code{libparse} is useful if an error
general.tex(,4708) occurs while loading the library, but the whole block around the line
general.tex(,4709) specified seems to be correct. In these situations the real error might
general.tex(,4710) be hundreds of lines earlier in the library.
general.tex(,4711) 
general.tex(,4712) @strong{Usage:}
general.tex(,4713) @*@code{libparse [options] singular-library}
general.tex(,4714) @*@strong{Options:}
general.tex(,4715) @table @asis
general.tex(,4716) @item @code{-d} Debuglevel
general.tex(,4717) increases the amount of output during parsing, where Debuglevel is an integer
general.tex(,4718) between 0 and 4. Default is 0.
general.tex(,4719) @item @code{-s}
general.tex(,4720) turns on reporting about violations of unenforced syntax rules
general.tex(,4721) @end table
general.tex(,4722) 
general.tex(,4723) The following syntax checks are performed in any case:
general.tex(,4724) @itemize @bullet
general.tex(,4725) @item counting of pairs of brackets @{,@} , [,] and (,)
general.tex(,4726)     (number of @{ has to match number of @}, same for [,] and (,) ).
general.tex(,4727) @item counting of "
general.tex(,4728)     ( number of " must be even ).
general.tex(,4729) @item general library syntax
general.tex(,4730)     ( only LIB, static, proc (with parameters, help, body and example)
general.tex(,4731) and comments, i.e // and @code{/* ... */}, are allowed).
general.tex(,4732) @end itemize
general.tex(,4733) Its output lists all procedures that have been parsed successfully:
general.tex(,4734) 
general.tex(,4735) @smallexample
general.tex(,4736) $ libparse sample.lib
general.tex(,4737) Checking library 'sample.lib'
general.tex(,4738)   Library         function      line,start-eod line,body-eob  line,example-eoe
general.tex(,4739) Version:0.0.0;
general.tex(,4740) g Sample               tab line    9,  149-165   13,  271-298   14,  300-402
general.tex(,4741) l Sample      internal_tab line   24,  450-475   25,  476-496    0,    0-496
general.tex(,4742) @end smallexample
general.tex(,4743) 
general.tex(,4744) where the following abbreviations are used:
general.tex(,4745) @itemize @bullet
general.tex(,4746) @item g: global procedure (default)
general.tex(,4747) @item l: static procedure, i.e., local to the library.
general.tex(,4748) @end itemize
general.tex(,4749) 
general.tex(,4750) each of the following is the position of the byte in the library.
general.tex(,4751) @itemize @bullet
general.tex(,4752) @item start: begin of 'proc'
general.tex(,4753) @item eod: end of parameters
general.tex(,4754) @item body: start of procedure body '@{'
general.tex(,4755) @item eob:  end of procedure body '@}'
general.tex(,4756) @item example: position of 'example'
general.tex(,4757) @item eoe: end of example '@}'
general.tex(,4758) @end itemize
general.tex(,4759) 
general.tex(,4760) Hence in the above example, the first procedure of the library
general.tex(,4761) sample.lib is user-accessible and its name is tab. The procedure
general.tex(,4762) starts in line 9, at character 149. The head of the procedure
general.tex(,4763) ends at character 165, the body starts in line 13 at character 271
general.tex(,4764) and ends at character 298. The example section extends from line 14
general.tex(,4765) character 300 to character 402.
general.tex(,4766) 
general.tex(,4767) The following example shows the result of a missing close-bracket @} in
general.tex(,4768) line 26 of the library @code{sample.lib}.
general.tex(,4769) 
general.tex(,4770) @smallexample
general.tex(,4771) LIB "sample.lib";
general.tex(,4772) @expansion{}    ? Library sample.lib: ERROR occurred: in line 26, 497.
general.tex(,4773) @expansion{}    ? missing close bracket '@}' at end of library in line 26.
general.tex(,4774) @expansion{}    ? Cannot load library,... aborting.
general.tex(,4775) @expansion{}    ? error occurred in STDIN line 1: `LIB "sample.lib";`
general.tex(,4776) @end smallexample
singular.texi(,133) 
singular.texi(,134) @c ----------------------------------------------------------------------------
singular.texi(,135) @node Data types, Functions and system variables, General concepts, Top
singular.texi(,136) @chapter Data types
singular.texi(,137) @cindex Data types
types.tex(,1) @comment -*-texinfo-*-
types.tex(,2) @comment This file was generated by doc2tex.pl from types.doc
types.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT types.doc INSTEAD
types.tex(,4) @comment Id: types.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
types.tex(,5) @comment this file contains the type definitions
types.tex(,6) 
types.tex(,7) @c The following directives are necessary for proper compilation
types.tex(,8) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
types.tex(,9) @c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
types.tex(,10) @c `makeinfo' but is a great help in editing this file (emacs
types.tex(,11) @c ignores the conditionals).
types.tex(,12) 
types.tex(,26) 
types.tex(,27) @cindex expression list
types.tex(,28) This chapter explains all data types of @sc{Singular} in
types.tex(,29) alphabetical order. For every type, there is a description of the
types.tex(,30) declaration syntax as well as information about how to build expressions
types.tex(,31) of certain types.
types.tex(,32) 
types.tex(,33) The term expression list in @sc{Singular} refers to any comma separated
types.tex(,34) list of expressions.
types.tex(,35) 
types.tex(,36) For the general syntax of a declaration see @ref{General command syntax}.
types.tex(,37) 
types.tex(,38) @menu
types.tex(,39) * def::
types.tex(,40) * ideal::
types.tex(,41) * int::
types.tex(,42) * intmat::
types.tex(,43) * intvec::
types.tex(,44) * link::
types.tex(,45) * list::
types.tex(,46) * map::
types.tex(,47) * matrix::
types.tex(,48) * module::
types.tex(,49) * number::
types.tex(,50) * poly::
types.tex(,51) * proc::
types.tex(,52) * qring::
types.tex(,53) * resolution::
types.tex(,54) * ring::
types.tex(,55) * string::
types.tex(,56) * vector::
types.tex(,60) @end menu
types.tex(,61) 
types.tex(,62) @c ---------------------------------------
types.tex(,63) @node def, ideal, Data types, Data types
types.tex(,64) @section def
types.tex(,65) @cindex def
types.tex(,66) @cindex untyped definitions
types.tex(,67) 
types.tex(,68) Objects may be defined without a specific type: they get their
types.tex(,69) type from the first assignment to them.
types.tex(,70) E.g., @code{ideal i=x,y,z; def j=i^2;} defines the ideal @code{i^2}
types.tex(,71) with the name @code{j}.
types.tex(,72) 
types.tex(,73) @strong{Note:} Unlike other assignments a ring as an untyped object
types.tex(,74) is not a copy but another reference to the same (possibly unnamed) ring.
types.tex(,75) This means that entries in one of these rings appear also in the other ones.
types.tex(,76) The following defines a ring @code{s} which is just another reference (or name)
types.tex(,77) for the basering @code{r}.
types.tex(,78) 
types.tex(,79) @smallexample
types.tex(,80) @c reused example def types.doc:78 
types.tex(,81)   ring r=32003,(x,y,z),dp;
types.tex(,82)   poly f = x;
types.tex(,83)   def s=basering;
types.tex(,84)   setring s;
types.tex(,85)   nameof(basering);
types.tex(,86) @expansion{} s
types.tex(,87)   listvar();
types.tex(,88) @expansion{} // s                    [0]  *ring
types.tex(,89) @expansion{} //      f                    [0]  poly
types.tex(,90) @expansion{} // r                    [0]  ring
types.tex(,91) @expansion{} // LIB                  [0]  string standard.lib
types.tex(,92)   poly g = y;
types.tex(,93)   kill f;
types.tex(,94)   listvar(r);
types.tex(,95) @expansion{} // r                    [0]  ring
types.tex(,96) @expansion{} // g                    [0]  poly
types.tex(,97)   ring t=32003,(u,w),dp;
types.tex(,98)   def rt=r+t;
types.tex(,99)   rt;
types.tex(,100) @expansion{} //   characteristic : 32003
types.tex(,101) @expansion{} //   number of vars : 5
types.tex(,102) @expansion{} //        block   1 : ordering dp
types.tex(,103) @expansion{} //                  : names    x y z 
types.tex(,104) @expansion{} //        block   2 : ordering dp
types.tex(,105) @expansion{} //                  : names    u w 
types.tex(,106) @expansion{} //        block   3 : ordering C
types.tex(,107) @c end example def types.doc:78
types.tex(,108) @end smallexample
types.tex(,109) 
types.tex(,110) This reference to a ring with def is useful if the basering
types.tex(,111) is not local to the procedure (so it cannot be accessed by its name) but one
types.tex(,112) needs a name for it (e.g., for a use with @code{setring} or @code{map}).
types.tex(,113) @code{setring r;} does not work in this case, because
types.tex(,114) @code{r} may not be local to the procedure.
types.tex(,115) 
types.tex(,116) @menu
types.tex(,117) * def declarations::
types.tex(,118) @end menu
types.tex(,119) 
types.tex(,120) @c ------------------------------
types.tex(,121) @node def declarations,  , def, def
types.tex(,122) @subsection def declarations
types.tex(,123) @cindex def declarations
types.tex(,124) 
types.tex(,125) @table @strong
types.tex(,126) @item Syntax:
types.tex(,127) @code{def} name @code{=} expression @code{;}
types.tex(,128) 
types.tex(,129) @item Purpose:
types.tex(,130) defines an object of the same type as the right-hand side.
types.tex(,131) 
types.tex(,132) @item Default:
types.tex(,133) none
types.tex(,134) 
types.tex(,135) @item Note:
types.tex(,136) This is useful if the right-hand side may be of
types.tex(,137) variable type as a consequence of a computation (e.g., ideal or module or
types.tex(,138) matrix). It may also be used in procedures to give the basering a name which
types.tex(,139) is local to the procedure.
types.tex(,140) 
types.tex(,141) @item Example:
types.tex(,142) @smallexample
types.tex(,143) @c reused example def_declarations types.doc:127 
types.tex(,144)   def i=2;
types.tex(,145)   typeof(i);
types.tex(,146) @expansion{} int
types.tex(,147) @c end example def_declarations types.doc:127
types.tex(,148) @end smallexample
types.tex(,149) @end table
types.tex(,150) 
types.tex(,151) @c inserted refs from types.doc:134
types.tex(,162) @c end inserted refs from types.doc:134
types.tex(,163) 
types.tex(,164) @c ---------------------------------------
types.tex(,165) @node ideal, int, def, Data types
types.tex(,166) @section ideal
types.tex(,167) @cindex ideal
types.tex(,168) 
types.tex(,169) Ideals are represented as lists of polynomials which generate the ideal.
types.tex(,170) Like polynomials they
types.tex(,171) can only be defined or accessed with respect to a basering.
types.tex(,172) 
types.tex(,173) @strong{Note:} @code{size} counts only the non-zero generators of an ideal
types.tex(,174) whereas @code{ncols} counts all generators.
types.tex(,175) @menu
types.tex(,176) * ideal declarations::
types.tex(,177) * ideal expressions::
types.tex(,178) * ideal operations::
types.tex(,179) * ideal related functions::
types.tex(,180) @end menu
types.tex(,181) 
types.tex(,182) @c ---------------------------------------
types.tex(,183) @node ideal declarations, ideal expressions, ideal, ideal
types.tex(,184) @subsection ideal declarations
types.tex(,185) @cindex ideal declarations
types.tex(,186) 
types.tex(,187) @table @strong
types.tex(,188) @item Syntax:
types.tex(,189) @code{ideal} name @code{=} list_of_poly_and_ideal_expressions @code{;}
types.tex(,190) @*@code{ideal} name @code{=} ideal_expression @code{;}
types.tex(,191) 
types.tex(,192) @item Purpose:
types.tex(,193) defines an ideal.
types.tex(,194) 
types.tex(,195) @item Default:
types.tex(,196) 0
types.tex(,197) 
types.tex(,198) @item Example:
types.tex(,199) @smallexample
types.tex(,200) @c reused example ideal_declarations types.doc:175 
types.tex(,201)   ring r=0,(x,y,z),dp;
types.tex(,202)   poly s1 = x2;
types.tex(,203)   poly s2 = y3;
types.tex(,204)   poly s3 = z;
types.tex(,205)   ideal i =  s1, s2-s1, 0,s2*s3, s3^4;
types.tex(,206)   i;
types.tex(,207) @expansion{} i[1]=x2
types.tex(,208) @expansion{} i[2]=y3-x2
types.tex(,209) @expansion{} i[3]=0
types.tex(,210) @expansion{} i[4]=y3z
types.tex(,211) @expansion{} i[5]=z4
types.tex(,212)   size(i);
types.tex(,213) @expansion{} 4
types.tex(,214)   ncols(i);
types.tex(,215) @expansion{} 5
types.tex(,216) @c end example ideal_declarations types.doc:175
types.tex(,217) @end smallexample
types.tex(,218) @end table
types.tex(,219) 
types.tex(,220) @c ------------------------------
types.tex(,221) @node ideal expressions, ideal operations, ideal declarations, ideal
types.tex(,222) @subsection ideal expressions
types.tex(,223) @cindex ideal expressions
types.tex(,224) 
types.tex(,225) An ideal expression is:
types.tex(,226) @enumerate
types.tex(,227) @item
types.tex(,228) an identifier of type ideal
types.tex(,229) @item
types.tex(,230) a function returning ideal
types.tex(,231) @item
types.tex(,232) ideal expressions combined by the arithmetic operations
types.tex(,233) @code{+} or @code{*}
types.tex(,234) @item
types.tex(,235) a power of an ideal expression (operator @code{^} or @code{**})
types.tex(,236) @*Note that the computation of the product @code{i*i} involves
types.tex(,237) all products of generators of @code{i} while @code{i^2} involves
types.tex(,238) only the different ones, and is therefore faster.
types.tex(,239) @item
types.tex(,240) a type cast to ideal
types.tex(,241) @end enumerate
types.tex(,242) 
types.tex(,243) @*@strong{Example:}
types.tex(,244) @smallexample
types.tex(,245) @c reused example ideal_expressions types.doc:213 
types.tex(,246)   ring r=0,(x,y,z),dp;
types.tex(,247)   ideal m = maxideal(1);
types.tex(,248)   m;
types.tex(,249) @expansion{} m[1]=x
types.tex(,250) @expansion{} m[2]=y
types.tex(,251) @expansion{} m[3]=z
types.tex(,252)   poly f = x2;
types.tex(,253)   poly g = y3;
types.tex(,254)   ideal i = x*y*z , f-g, g*(x-y) + f^4 ,0, 2x-z2y;
types.tex(,255)   ideal M = i + maxideal(10);
types.tex(,256)   timer =0;
types.tex(,257)   i = M*M;
types.tex(,258)   timer;
types.tex(,259) @expansion{} 0
types.tex(,260)   ncols(i);
types.tex(,261) @expansion{} 505
types.tex(,262)   timer =0;
types.tex(,263)   i = M^2;
types.tex(,264)   ncols(i);
types.tex(,265) @expansion{} 505
types.tex(,266)   timer;
types.tex(,267) @expansion{} 0
types.tex(,268)   i[ncols(i)];
types.tex(,269) @expansion{} x20
types.tex(,270)   vector v = [x,y-z,x2,y-x,x2yz2-y];
types.tex(,271)   ideal j = ideal(v);
types.tex(,272) @c end example ideal_expressions types.doc:213
types.tex(,273) @end smallexample
types.tex(,274) 
types.tex(,275) @c ------------------------------
types.tex(,276) @node ideal operations, ideal related functions, ideal expressions, ideal
types.tex(,277) @subsection ideal operations
types.tex(,278) @cindex ideal operations
types.tex(,279) 
types.tex(,280) @table @asis
types.tex(,281) @item @code{+}
types.tex(,282) addition (concatenation of the generators and simplification)
types.tex(,283) 
types.tex(,284) @item @code{*}
types.tex(,285) multiplication (with ideal, poly, vector, module; simplification in case of
types.tex(,286) multiplication with ideal)
types.tex(,287) 
types.tex(,288) @item @code{^}
types.tex(,289) exponentiation (by a non-negative integer)
types.tex(,290) 
types.tex(,291) @item ideal_expression @code{[} intvec_expression @code{]}
types.tex(,292) are polynomial generators of the ideal, index 1 gives the first generator.
types.tex(,293) @end table
types.tex(,294) 
types.tex(,295) @strong{Note:} For simplification of an ideal, see also @ref{simplify}.
types.tex(,296) 
types.tex(,297) @*@strong{Example:}
types.tex(,298) @smallexample
types.tex(,299) @c reused example ideal_operations types.doc:259 
types.tex(,300)   ring r=0,(x,y,z),dp;
types.tex(,301)   ideal I = 0,x,0,1;
types.tex(,302)   I;
types.tex(,303) @expansion{} I[1]=0
types.tex(,304) @expansion{} I[2]=x
types.tex(,305) @expansion{} I[3]=0
types.tex(,306) @expansion{} I[4]=1
types.tex(,307)   I + 0;    // simplification
types.tex(,308) @expansion{} _[1]=1
types.tex(,309)   ideal J = I,0,x,x-z;;
types.tex(,310)   J;
types.tex(,311) @expansion{} J[1]=0
types.tex(,312) @expansion{} J[2]=x
types.tex(,313) @expansion{} J[3]=0
types.tex(,314) @expansion{} J[4]=1
types.tex(,315) @expansion{} J[5]=0
types.tex(,316) @expansion{} J[6]=x
types.tex(,317) @expansion{} J[7]=x-z
types.tex(,318)   I * J;   //  multiplication with simplification
types.tex(,319) @expansion{} _[1]=1
types.tex(,320)   I*x;
types.tex(,321) @expansion{} _[1]=0
types.tex(,322) @expansion{} _[2]=x2
types.tex(,323) @expansion{} _[3]=0
types.tex(,324) @expansion{} _[4]=x
types.tex(,325)   vector V = [x,y,z];
types.tex(,326)   print(V*I);
types.tex(,327) @expansion{} 0,x2,0,x,
types.tex(,328) @expansion{} 0,xy,0,y,
types.tex(,329) @expansion{} 0,xz,0,z 
types.tex(,330)   ideal m = maxideal(1);
types.tex(,331)   m^2;
types.tex(,332) @expansion{} _[1]=x2
types.tex(,333) @expansion{} _[2]=xy
types.tex(,334) @expansion{} _[3]=xz
types.tex(,335) @expansion{} _[4]=y2
types.tex(,336) @expansion{} _[5]=yz
types.tex(,337) @expansion{} _[6]=z2
types.tex(,338)   ideal II = I[2..4];
types.tex(,339)   II;
types.tex(,340) @expansion{} II[1]=x
types.tex(,341) @expansion{} II[2]=0
types.tex(,342) @expansion{} II[3]=1
types.tex(,343) @c end example ideal_operations types.doc:259
types.tex(,344) @end smallexample
types.tex(,345) 
types.tex(,346) @c ------------------------------
types.tex(,347) @node ideal related functions,  , ideal operations, ideal
types.tex(,348) @subsection ideal related functions
types.tex(,349) @cindex ideal related functions
types.tex(,350) 
types.tex(,351) @table @code
types.tex(,352) @item char_series
types.tex(,353) irreducible characteristic series (see @ref{char_series})
types.tex(,354) @item coeffs
types.tex(,355) matrix of coefficients (see @ref{coeffs})
types.tex(,356) @item contract
types.tex(,357) contraction by an ideal (see @ref{contract})
types.tex(,358) @item diff
types.tex(,359) partial derivative (see @ref{diff})
types.tex(,360) @item degree
types.tex(,361) multiplicity, dimension and codimension of the ideal of leading terms (see @ref{degree})
types.tex(,362) @item dim
types.tex(,363) Krull dimension of basering modulo the ideal of leading terms (see @ref{dim})
types.tex(,364) @item eliminate
types.tex(,365) elimination of variables (see @ref{eliminate})
types.tex(,366) @item facstd
types.tex(,367) factorizing Groebner basis algorithm (see @ref{facstd})
types.tex(,368) @item factorize
types.tex(,369) ideal of factors of a polynomial (see @ref{factorize})
types.tex(,370) @item fglm
types.tex(,371) Groebner basis computation from a Groebner basis w.r.t.@: a different
types.tex(,372) ordering (see @ref{fglm})
types.tex(,373) @item finduni
types.tex(,374) computation of univariate polynomials lying in a zero dimensional ideal
types.tex(,375) (see @ref{finduni})
types.tex(,376) @item groebner
types.tex(,377) Groebner basis computation (a wrapper around @code{std,stdhilb,stdfglm},...)
types.tex(,378) (see @ref{groebner})
types.tex(,379) @item highcorner
types.tex(,380) computes the smallest monomial not contained in the ideal.
types.tex(,381) The ideal has to be zero-dimensional.
types.tex(,382) (see @ref{highcorner})
types.tex(,383) @item homog
types.tex(,384) homogenization with respect to a variable (see @ref{homog})
types.tex(,385) @item hilb
types.tex(,386) Hilbert series of a standard basis (see @ref{hilb})
types.tex(,387) @item indepSet
types.tex(,388) sets of independent variables of an ideal (see @ref{indepSet})
types.tex(,389) @item interred
types.tex(,390) interreduction of an ideal (see @ref{interred})
types.tex(,391) @item intersect
types.tex(,392) ideal intersection (see @ref{intersect})
types.tex(,393) @item jacob
types.tex(,394) ideal of all partial derivatives resp.@: jacobian matrix (see @ref{jacob})
types.tex(,395) @item jet
types.tex(,396) Taylor series up to a given order (see @ref{jet})
types.tex(,397) @item kbase
types.tex(,398) vector space basis of basering modulo ideal of leading terms
types.tex(,399) (see @ref{kbase})
types.tex(,400) @item koszul
types.tex(,401) Koszul matrix (see @ref{koszul})
types.tex(,402) @item lead
types.tex(,403) leading terms of a set of generators (see @ref{lead})
types.tex(,404) @item lift
types.tex(,405) lift-matrix (see @ref{lift})
types.tex(,406) @item liftstd
types.tex(,407) standard basis and transformation matrix computation (see @ref{liftstd})
types.tex(,408) @item lres
types.tex(,409) free resolution for homogeneous ideals (see @ref{lres})
types.tex(,410) @item maxideal
types.tex(,411) power of the maximal ideal at 0 (see @ref{maxideal})
types.tex(,412) @item minbase
types.tex(,413) minimal generating set of a homogeneous ideal, resp.@: module, or an ideal, resp.@: module, in a local ring
types.tex(,414) (see @ref{minbase})
types.tex(,415) @item minor
types.tex(,416) set of minors of a matrix (see @ref{minor})
types.tex(,417) @item modulo
types.tex(,418) represents
types.tex(,425) (see @ref{modulo})
types.tex(,426) @item mres
types.tex(,427) minimal free resolution of an ideal resp.@: module w.r.t. a minimal set of generators of the given ideal resp.@: module
types.tex(,428) (see @ref{mres})
types.tex(,429) @item mstd
types.tex(,430) standard basis and minimal generating set of an ideal (see @ref{mstd})
types.tex(,431) @item mult
types.tex(,432) multiplicity, resp.@: degree, of the ideal of leading terms (see @ref{mult})
types.tex(,433) @item ncols
types.tex(,434) number of columns (see @ref{ncols})
types.tex(,435) @item preimage
types.tex(,436) preimage under a ring map (see @ref{preimage})
types.tex(,437) @item qhweight
types.tex(,438) quasihomogeneous weights of an ideal (see @ref{qhweight})
types.tex(,439) @item quotient
types.tex(,440) ideal quotient (see @ref{quotient})
types.tex(,441) @item reduce
types.tex(,442) normalform with respect to a standard basis (see @ref{reduce})
types.tex(,443) @item res
types.tex(,444) free resolution of an ideal resp.@: module but not changing the given ideal resp.@: module
types.tex(,445) (see @ref{res})
types.tex(,446) @item simplify
types.tex(,447) simplify a set of polynomials (see @ref{simplify})
types.tex(,448) @item size
types.tex(,449) number of non-zero generators (see @ref{size})
types.tex(,450) @item sortvec
types.tex(,451) permutation for sorting ideals resp@:. modules (see @ref{sortvec})
types.tex(,452) @item sres
types.tex(,453) free resolution of a standard basis (see @ref{sres})
types.tex(,454) @item std
types.tex(,455) standard basis computation (see @ref{std})
types.tex(,456) @item stdfglm
types.tex(,457) standard basis computation with fglm technique (see @ref{stdfglm})
types.tex(,458) @item stdhilb
types.tex(,459) Hilbert driven standard basis computation (see @ref{stdhilb}
types.tex(,460) @item subst
types.tex(,461) substitute a ring variable (see @ref{subst})
types.tex(,462) @item syz
types.tex(,463) computation of the first syzygy module (see @ref{syz})
types.tex(,464) @item vdim
types.tex(,465) vector space dimension of basering modulo ideal of leading terms
types.tex(,466) (see @ref{vdim})
types.tex(,467) @item weight
types.tex(,468) optimal weights (see @ref{weight})
types.tex(,469) @end table
types.tex(,470) 
types.tex(,471) @c ---------------------------------------
types.tex(,472) @node int, intmat, ideal, Data types
types.tex(,473) @section int
types.tex(,474) @cindex int
types.tex(,475) 
types.tex(,476) Variables of type int represent the machine integers and are, therefore,
types.tex(,477) limited  in their range (e.g., the range is between
types.tex(,478) -2147483647 and 2147483647 on 32-bit machines). They are mainly used
types.tex(,479) to count things (dimension, rank, etc.),
types.tex(,480) in loops (see @ref{for}), and
types.tex(,481) to represent boolean values
types.tex(,482) (FALSE is represented by 0, every other value means TRUE, see
types.tex(,483) @ref{boolean expressions}).
types.tex(,484) 
types.tex(,485) Integers consist of a sequence of digits, possibly preceded by a sign.
types.tex(,486) A space is considered as a separator, so it is not allowed between digits.
types.tex(,487) A sequence of digits outside the allowed range is converted to the type
types.tex(,488) @code{number} if possible.
types.tex(,489) 
types.tex(,490) @menu
types.tex(,491) * int declarations::
types.tex(,492) * int expressions::
types.tex(,493) * int operations::
types.tex(,494) * boolean expressions::
types.tex(,495) * boolean operations::
types.tex(,496) * int related functions::
types.tex(,497) @end menu
types.tex(,498) 
types.tex(,499) @c ---------------------------------------
types.tex(,500) @node int declarations, int expressions, int, int
types.tex(,501) @subsection int declarations
types.tex(,502) @cindex int declarations
types.tex(,503) 
types.tex(,504) @table @strong
types.tex(,505) @item Syntax:
types.tex(,506) @code{int} name @code{=} int_expression @code{;}
types.tex(,507) 
types.tex(,508) @item Purpose:
types.tex(,509) defines an integer variable.
types.tex(,510) 
types.tex(,511) @item Default:
types.tex(,512) 0
types.tex(,513) 
types.tex(,514) @item Example:
types.tex(,515) @smallexample
types.tex(,516) @c reused example int_declarations types.doc:447 
types.tex(,517)   int i = 42;
types.tex(,518)   int j = i + 3; j;
types.tex(,519) @expansion{} 45
types.tex(,520)   i = i * 3 - j; i;
types.tex(,521) @expansion{} 81
types.tex(,522)   int k;   // assigning the default value 0 to k
types.tex(,523)   k;
types.tex(,524) @expansion{} 0
types.tex(,525) @c end example int_declarations types.doc:447
types.tex(,526) @end smallexample
types.tex(,527) @end table
types.tex(,528) 
types.tex(,529) @c ------------------------------
types.tex(,530) @node int expressions, int operations, int declarations, int
types.tex(,531) @subsection int expressions
types.tex(,532) @cindex int expressions
types.tex(,533) 
types.tex(,534) An int expression is:
types.tex(,535) @enumerate
types.tex(,536) @item
types.tex(,537) a sequence of digits (if the number represented by this sequence is too
types.tex(,538) large to fit into the range of integers it is automatically
types.tex(,539) converted to the type number, if a basering is defined)
types.tex(,540) @item
types.tex(,541) an identifier of type int
types.tex(,542) @item
types.tex(,543) a function returning int
types.tex(,544) @item
types.tex(,545) int expressions combined by the arithmetic operations
types.tex(,546) @code{+}, @code{-}, @code{*}, @code{div}, @code{/},
types.tex(,547) @code{%} (@code{mod}), or @code{^}
types.tex(,548) @item a boolean expression
types.tex(,549) @item
types.tex(,550) a type cast to int
types.tex(,551) @end enumerate
types.tex(,552) 
types.tex(,553) @strong{Note:}
types.tex(,554) Variables of type int represent the compiler integers  and are, therefore,
types.tex(,555) limited  in their range (see @ref{Limitations}). If this range is too small
types.tex(,556) the expression must be converted to the type number over a ring with
types.tex(,557) characteristic 0.
types.tex(,558) 
types.tex(,559) @*@strong{Example:}
types.tex(,560) @smallexample
types.tex(,561) @c reused example int_expressions types.doc:489 
types.tex(,562) 12345678901; // too large
types.tex(,563) @expansion{}    ? `12345678901` greater than 2147483647(max. integer representation)
types.tex(,564) @expansion{}    ? error occurred in line 1: `12345678901; // too large`
types.tex(,565) typeof(_);
types.tex(,566) @expansion{} none
types.tex(,567) ring r=0,x,dp;
types.tex(,568) 12345678901;
types.tex(,569) @expansion{} 12345678901
types.tex(,570) typeof(_);
types.tex(,571) @expansion{} number
types.tex(,572) // Note: 11*13*17*100*200*2000*503*1111*222222
types.tex(,573) // returns a machine integer:
types.tex(,574) 11*13*17*100*200*2000*503*1111*222222;
types.tex(,575) @expansion{} // ** int overflow(*), result may be wrong
types.tex(,576) @expansion{} // ** int overflow(*), result may be wrong
types.tex(,577) @expansion{} // ** int overflow(*), result may be wrong
types.tex(,578) @expansion{} // ** int overflow(*), result may be wrong
types.tex(,579) @expansion{} -1875651584
types.tex(,580) // using the type cast number for a greater allowed range
types.tex(,581) number(11)*13*17*100*200*2000*503*1111*222222;
types.tex(,582) @expansion{} 12075748128684240000000
types.tex(,583) ring rp=32003,x,dp;
types.tex(,584) 12345678901;
types.tex(,585) @expansion{} 9603
types.tex(,586) typeof(_);
types.tex(,587) @expansion{} number
types.tex(,588) intmat m[2][2] = 1,2,3,4;
types.tex(,589) m;
types.tex(,590) @expansion{} 1,2,
types.tex(,591) @expansion{} 3,4 
types.tex(,592) m[2,2];
types.tex(,593) @expansion{} 4
types.tex(,594) typeof(_);
types.tex(,595) @expansion{} int
types.tex(,596) det(m);
types.tex(,597) @expansion{} -2
types.tex(,598) m[1,1] + m[2,1] == trace(m);
types.tex(,599) @expansion{} 0
types.tex(,600) ! 0;
types.tex(,601) @expansion{} 1
types.tex(,602) 1 and 2;
types.tex(,603) @expansion{} 1
types.tex(,604) intvec v = 1,2,3;
types.tex(,605) def d =transpose(v)*v;    // scalarproduct gives an 1x1 intvec
types.tex(,606) typeof(d);
types.tex(,607) @expansion{} intvec
types.tex(,608) int i = d[1];             // access the first (the only) entry in the intvec
types.tex(,609) ring rr=31,(x,y,z),dp;
types.tex(,610) poly f = 1;
types.tex(,611) i = int(f);               // cast to int
types.tex(,612) // Integers may be converted to constant  polynomials by an assignment,
types.tex(,613) poly g=37;
types.tex(,614) // define the constant polynomial g equal to the image of
types.tex(,615) // the integer 37 in the actual coefficient field, here it equals 6
types.tex(,616) g;
types.tex(,617) @expansion{} 6
types.tex(,618) @c end example int_expressions types.doc:489
types.tex(,619) @end smallexample
types.tex(,620) 
types.tex(,621) @c inserted refs from types.doc:526
types.tex(,634) @c end inserted refs from types.doc:526
types.tex(,635) 
types.tex(,636) @c ------------------------------
types.tex(,637) @node int operations, int related functions, int expressions, int
types.tex(,638) @subsection int operations
types.tex(,639) @cindex int operations
types.tex(,640) @cindex mod
types.tex(,641) @cindex div
types.tex(,642) 
types.tex(,643) @c remark: the following table should have style @asis, since the
types.tex(,644) @c   commas below should not by set in style @code.
types.tex(,645) @table @asis
types.tex(,646) @item @code{++}
types.tex(,647) changes its operand to its successor, is itself no int expression
types.tex(,648) @item @code{--}
types.tex(,649) changes its operand to its predecessor, is itself no int expression
types.tex(,650) @item @code{+}
types.tex(,651) addition
types.tex(,652) @item @code{-}
types.tex(,653) negation or subtraction
types.tex(,654) @item @code{*}
types.tex(,655) multiplication
types.tex(,656) @item @code{/}
types.tex(,657) integer division (omitting the remainder), rounding toward 0
types.tex(,658) @item @code{div}
types.tex(,659) integer division (omitting the remainder >= 0)
types.tex(,660) @item @code{%}
types.tex(,661) integer modulo (the remainder of the division @code{/})
types.tex(,662) @item @code{mod}
types.tex(,663) integer modulo (the remainder of the division @code{div}), always non-negative
types.tex(,664) @item @code{^}, @code{**}
types.tex(,665) exponentiation (exponent must be non-negative)
types.tex(,666) @item @code{<}, @code{>}, @code{<=}, @code{>=}, @code{==}, @code{<>}
types.tex(,667) comparison
types.tex(,668) @end table
types.tex(,669) 
types.tex(,670) @strong{Note:} An assignment @code{j=i++;} or @code{j=i--;} is not allowed,
types.tex(,671) in particular it does not change
types.tex(,672) the value of @code{j}, see @ref{Limitations}.
types.tex(,673) 
types.tex(,674) @c @strong{Note:} @code{/} might no longer be available in the future.
types.tex(,675) 
types.tex(,676) @*@strong{Example:}
types.tex(,677) @smallexample
types.tex(,678) @c reused example int_operations types.doc:574 
types.tex(,679)   int i=1;
types.tex(,680)   int j;
types.tex(,681)   i++; i;  i--; i;
types.tex(,682) @expansion{} 2
types.tex(,683) @expansion{} 1
types.tex(,684)   // ++ and -- do not return a value as in C, can not assign
types.tex(,685)   j = i++;
types.tex(,686) @expansion{} // ** right side is not a datum, assignment ignored
types.tex(,687)   // the value of j is unchanged
types.tex(,688)   j; i;
types.tex(,689) @expansion{} 0
types.tex(,690) @expansion{} 2
types.tex(,691)   i+2, 2-i, 5^2;
types.tex(,692) @expansion{} 4 0 25
types.tex(,693)   5 div 2, 8%3;
types.tex(,694) @expansion{} 2 2
types.tex(,695)   -5 div 2, -5 / 2, -5 mod 2, -5 % 2;
types.tex(,696) @expansion{} -3 -2 1 -1
types.tex(,697)   1<2, 2<=2;
types.tex(,698) @expansion{} 1 1
types.tex(,699) @c end example int_operations types.doc:574
types.tex(,700) @end smallexample
types.tex(,701) 
types.tex(,702) @c ------------------------------
types.tex(,703) @node int related functions, boolean expressions,int operations, int
types.tex(,704) @subsection int related functions
types.tex(,705) @cindex int related functions
types.tex(,706) 
types.tex(,707) @table @code
types.tex(,708) @item char
types.tex(,709) characteristic of the coefficient field of a ring (see @ref{char})
types.tex(,710) @item deg
types.tex(,711) degree of a poly resp.@: vector (see @ref{deg})
types.tex(,712) @item det
types.tex(,713) determinant (see @ref{det})
types.tex(,714) @item dim
types.tex(,715) Krull dimension of basering modulo ideal of leading terms, resp.@:
types.tex(,716) dimension of module of leading terms (see @ref{dim})
types.tex(,717) @item extgcd
types.tex(,718) Bezout representation of gcd (see @ref{extgcd})
types.tex(,719) @item find
types.tex(,720) position of a substring in a string (see @ref{find})
types.tex(,721) @item gcd
types.tex(,722) greatest common divisor (see @ref{gcd})
types.tex(,723) @item koszul
types.tex(,724) Koszul matrix (see @ref{koszul})
types.tex(,725) @item memory
types.tex(,726) memory usage (see @ref{memory})
types.tex(,727) @item mult
types.tex(,728) multiplicity of an ideal, resp.@: module, of leading terms (see @ref{mult})
types.tex(,729) @item ncols
types.tex(,730) number of columns (see @ref{ncols})
types.tex(,731) @item npars
types.tex(,732) number of ring parameters (see @ref{npars})
types.tex(,733) @item nrows
types.tex(,734) number of rows of a matrix, resp.@:
types.tex(,735) the rank of the free module where the vector or module lives
types.tex(,736) (see @ref{nrows})
types.tex(,737) @item nvars
types.tex(,738) number of ring variables (see @ref{nvars})
types.tex(,739) @item ord
types.tex(,740) degree of the leading term of a poly resp.@: vector (see @ref{ord})
types.tex(,741) @item par
types.tex(,742) n-th parameter of the basering (see @ref{par})
types.tex(,743) @item pardeg
types.tex(,744) degree of a number considered as a polynomial in the ring parameters (see @ref{pardeg})
types.tex(,745) @item prime
types.tex(,746) the next lower prime (see @ref{prime})
types.tex(,747) @item random
types.tex(,748) a pseudo random integer between the given limits (see @ref{random})
types.tex(,749) @item regularity
types.tex(,750) regularity of a resolution (see @ref{regularity})
types.tex(,751) @item rvar
types.tex(,752) test, if the given expression or string is a ring variable (see @ref{rvar})
types.tex(,753) @item size
types.tex(,754) number of elements in an object (see @ref{size})
types.tex(,755) @item trace
types.tex(,756) trace of an integer matrix (see @ref{trace})
types.tex(,757) @item var
types.tex(,758) n-th ring variable of the basering (see @ref{var})
types.tex(,759) @item vdim
types.tex(,760) vector space dimension of basering modulo ideal of leading terms,
types.tex(,761) resp.@: of freemodule modulo module of leading terms (see @ref{vdim})
types.tex(,762) @end table
types.tex(,763) 
types.tex(,764) @c ------------------------------
types.tex(,765) @node boolean expressions, boolean operations, int related functions, int
types.tex(,766) @subsection boolean expressions
types.tex(,767) @cindex boolean expressions
types.tex(,768) @cindex ==
types.tex(,769) @cindex !=
types.tex(,770) @cindex <>
types.tex(,771) @cindex <=
types.tex(,772) @cindex >=
types.tex(,773) 
types.tex(,774) A boolean expression is really an int expression used in a logical context:
types.tex(,775) 
types.tex(,776) @c item
types.tex(,777) @*An int expression (<> 0 evaluates to @emph{TRUE} (represented by 1),
types.tex(,778) 0 represents @emph{FALSE}).
types.tex(,779) 
types.tex(,780) The following is the list of available comparisons of objects of the same type.
types.tex(,781) 
types.tex(,782) @strong{Note:} There are no comparisons for ideals and modules, resolution
types.tex(,783) and maps.
types.tex(,784) 
types.tex(,785) @enumerate
types.tex(,786) @item
types.tex(,787) an integer comparison:
types.tex(,788) @smallexample
types.tex(,789)   i == j
types.tex(,790)   i != j    // or     i <> j
types.tex(,791)   i <= j
types.tex(,792)   i >= j
types.tex(,793)   i > j
types.tex(,794)   i < j
types.tex(,795) @end smallexample
types.tex(,796) @item
types.tex(,797) a number comparison:
types.tex(,798) @smallexample
types.tex(,799)   m == n
types.tex(,800)   m != n    // or     m <> n
types.tex(,801)   m < n
types.tex(,802)   m > n
types.tex(,803)   m <= n
types.tex(,804)   m >= n
types.tex(,805) @end smallexample
types.tex(,806) For numbers from Z/p or from field extensions not all operations are useful:
types.tex(,807) @* - 0 is always the smallest element,
types.tex(,808) @* - in Z/p the representatives in the range -(p-1)/2..(p-1)/2 when p>2 resp.
types.tex(,809)      0 and 1 for p=2 are used for comparisons,
types.tex(,810) @* - in field extensions the last two operations
types.tex(,811) (@code{>=,<=}) yield always TRUE (1) and
types.tex(,812) the @code{<} and @code{>} are equivalent to @code{!=}.
types.tex(,813) @item
types.tex(,814) a polynomial or vector comparison:
types.tex(,815) @smallexample
types.tex(,816)   f == g
types.tex(,817)   f != g    // or     f <> g
types.tex(,818)   f <= g    // comparing the leading term w.r.t. the monomial order
types.tex(,819)   f <  g
types.tex(,820)   f >= g
types.tex(,821)   f >  g
types.tex(,822) @end smallexample
types.tex(,823) @item
types.tex(,824) an intmat or matrix comparison:
types.tex(,825) @smallexample
types.tex(,826)   v == w
types.tex(,827)   v != w    // or     v <> w
types.tex(,828) @end smallexample
types.tex(,829) @item
types.tex(,830) an intvec or  string comparison:
types.tex(,831) @smallexample
types.tex(,832)   f == g
types.tex(,833)   f != g    // or     f <> g
types.tex(,834)   f <= g    // comparing lexicographically
types.tex(,835)   f >= g    // w.r.t. the order specified by ASCII
types.tex(,836)   f >  g
types.tex(,837)   f <  g
types.tex(,838) @end smallexample
types.tex(,839) @item
types.tex(,840) boolean expressions combined by boolean operations (@code{and},
types.tex(,841) @code{or}, @code{not})
types.tex(,842) @end enumerate
types.tex(,843) 
types.tex(,844) @strong{Note:}
types.tex(,845) @c ------------------------------------------------------------
types.tex(,846) @c   This piece of text exists also in the file singular.doc,
types.tex(,847) @c   chapter "Evaluation of logical expressions".
types.tex(,848) @c   If you change something here, change it there, too!
types.tex(,849) @c ------------------------------------------------------------
types.tex(,850) All arguments of a logical expression are first evaluated and
types.tex(,851) then the value of the logical expression is determined. For example, the
types.tex(,852) logical expression @code{(a || b)} is evaluated by first evaluating
types.tex(,853) @code{a} @emph{and} @code{b}, even though the value of @code{b} has no
types.tex(,854) influence on the value of @code{(a || b)}, if @code{a} evaluates to
types.tex(,855) true.
types.tex(,856) 
types.tex(,857) Note that this evaluation is different from the left-to-right, conditional
types.tex(,858) evaluation of logical expressions (as found in most programming
types.tex(,859) languages). For example, in these other languages, the value of @code{(1
types.tex(,860) || b)} is determined without ever evaluating @code{b}.
types.tex(,861) 
types.tex(,862) See @ref{Major differences to the C programming language}.
types.tex(,863) 
types.tex(,864) @c ------------------------------
types.tex(,865) @node boolean operations, , boolean expressions, int
types.tex(,866) @subsection boolean operations
types.tex(,867) @cindex boolean operations
types.tex(,868) @cindex and
types.tex(,869) @cindex &&
types.tex(,870) @cindex or
types.tex(,871) @cindex ||
types.tex(,872) @cindex not
types.tex(,873) 
types.tex(,874) @table @code
types.tex(,875) @item and
types.tex(,876) logical @code{and}, may also be written as @code{&&}
types.tex(,877) 
types.tex(,878) @item or
types.tex(,879) logical @code{or}, may also be written as @code{||}
types.tex(,880) 
types.tex(,881) @item not
types.tex(,882) logical @code{not}, may also be written as @code{!}
types.tex(,883) @end table
types.tex(,884) 
types.tex(,885) The precedence of the boolean operations is:
types.tex(,886) 
types.tex(,887) @enumerate
types.tex(,888) @item parentheses
types.tex(,889) @item comparisons
types.tex(,890) @item not
types.tex(,891) @item and
types.tex(,892) @item or
types.tex(,893) @end enumerate
types.tex(,894) 
types.tex(,895) @*@strong{Example:}
types.tex(,896) @smallexample
types.tex(,897) @c reused example boolean_operations types.doc:784 
types.tex(,898)   (1>2) and 3;
types.tex(,899) @expansion{} 0
types.tex(,900)   1 > 2 and 3;
types.tex(,901) @expansion{} 0
types.tex(,902)   ! 0 or 1;
types.tex(,903) @expansion{} 1
types.tex(,904)   !(0 or 1);
types.tex(,905) @expansion{} 0
types.tex(,906) @c end example boolean_operations types.doc:784
types.tex(,907) @end smallexample
types.tex(,908) 
types.tex(,909) @c ---------------------------------------
types.tex(,910) @node intmat, intvec, int, Data types
types.tex(,911) @section intmat
types.tex(,912) @cindex intmat
types.tex(,913) 
types.tex(,914) Integer matrices are matrices with integer entries. For the range of
types.tex(,915) integers see @ref{Limitations}. Integer matrices do not belong to a
types.tex(,916) ring, they may be defined without a basering being defined. An intmat
types.tex(,917) can be multiplied by and added to an int; in this case the int is
types.tex(,918) converted into an intmat of the right size with the integer on the
types.tex(,919) diagonal. The integer @code{1}, for example, is converted into the unit
types.tex(,920) matrix.
types.tex(,921) 
types.tex(,922) @menu
types.tex(,923) * intmat declarations::
types.tex(,924) * intmat expressions::
types.tex(,925) * intmat type cast::
types.tex(,926) * intmat operations::
types.tex(,927) * intmat related functions::
types.tex(,928) @end menu
types.tex(,929) 
types.tex(,930) @c ------------------------------
types.tex(,931) @node intmat declarations, intmat expressions, intmat, intmat
types.tex(,932) @subsection intmat declarations
types.tex(,933) @cindex intmat declarations
types.tex(,934) 
types.tex(,935) @table @strong
types.tex(,936) @item Syntax:
types.tex(,937) @code{intmat} name @code{=} intmat_expression @code{;}
types.tex(,938) @*@code{intmat} name @code{[} rows @code{] [} cols @code{] =} intmat_expression @code{;}
types.tex(,939) @*@code{intmat} name @code{[} rows @code{] [} cols @code{] =} list_of_int_and_intvec_and_intmat_expressions @code{;}
types.tex(,940) @*rows and cols must be positive int expressions.
types.tex(,941) 
types.tex(,942) @item Purpose:
types.tex(,943) defines an intmat variable.
types.tex(,944) @* Given a list of integers, the matrix is filled up with the first row
types.tex(,945) from the left to the right, then the second row and so on.
types.tex(,946) If the int_list contains less than rows*cols elements,
types.tex(,947) the matrix is filled up with zeros; if it contains more
types.tex(,948) elements, only the first rows*cols elements are used.
types.tex(,949) 
types.tex(,950) @item Default:
types.tex(,951) 0 (1 x 1 matrix)
types.tex(,952) 
types.tex(,953) @item Example:
types.tex(,954) @smallexample
types.tex(,955) @c reused example intmat_declarations types.doc:838 
types.tex(,956)   intmat im[3][5]=1,3,5,7,8,9,10,11,12,13;
types.tex(,957)   im;
types.tex(,958) @expansion{} 1,3,5,7,8,
types.tex(,959) @expansion{} 9,10,11,12,13,
types.tex(,960) @expansion{} 0,0,0,0,0 
types.tex(,961)   im[3,2];
types.tex(,962) @expansion{} 0
types.tex(,963)   intmat m[2][3] = im[1..2,3..5];  // defines a submatrix
types.tex(,964)   m;
types.tex(,965) @expansion{} 5,7,8,
types.tex(,966) @expansion{} 11,12,13 
types.tex(,967) @c end example intmat_declarations types.doc:838
types.tex(,968) @end smallexample
types.tex(,969) @end table
types.tex(,970) 
types.tex(,971) @c ------------------------------
types.tex(,972) @node intmat expressions, intmat type cast, intmat declarations, intmat
types.tex(,973) @subsection intmat expressions
types.tex(,974) @cindex intmat expressions
types.tex(,975) 
types.tex(,976) An intmat expression is:
types.tex(,977) @enumerate
types.tex(,978) @item
types.tex(,979) an identifier of type intmat
types.tex(,980) @item
types.tex(,981) a function returning intmat
types.tex(,982) @item
types.tex(,983) intmat operations with int (@code{+}, @code{-}, @code{*}, @code{div}, @code{%})
types.tex(,984) @item
types.tex(,985) intmat operations (@code{+}, @code{-}, @code{*})
types.tex(,986) @item
types.tex(,987) a type cast to intmat (@pxref{intmat type cast})
types.tex(,988) @end enumerate
types.tex(,989) 
types.tex(,990) @*@strong{Example:}
types.tex(,991) @smallexample
types.tex(,992) @c reused example intmat_expressions types.doc:869 
types.tex(,993)   intmat Idm[2][2];
types.tex(,994)   Idm +1;          // add the unit intmat
types.tex(,995) @expansion{} 1,0,
types.tex(,996) @expansion{} 0,1 
types.tex(,997)   intmat m1[3][2] = _,1,-2;  // take entries from the last result
types.tex(,998)   m1;
types.tex(,999) @expansion{} 1,0,
types.tex(,1000) @expansion{} 0,1,
types.tex(,1001) @expansion{} 1,-2 
types.tex(,1002)   intmat m2[2][3]=1,0,2,4,5,1;
types.tex(,1003)   transpose(m2);
types.tex(,1004) @expansion{} 1,4,
types.tex(,1005) @expansion{} 0,5,
types.tex(,1006) @expansion{} 2,1 
types.tex(,1007)   intvec v1=1,2,4;
types.tex(,1008)   intvec v2=5,7,8;
types.tex(,1009)   m1=v1,v2;         // fill m1 with v1 and v2
types.tex(,1010)   m1;
types.tex(,1011) @expansion{} 1,2,
types.tex(,1012) @expansion{} 4,5,
types.tex(,1013) @expansion{} 7,8 
types.tex(,1014)   trace(m1*m2);
types.tex(,1015) @expansion{} 56
types.tex(,1016) @c end example intmat_expressions types.doc:869
types.tex(,1017) @end smallexample
types.tex(,1018) @c inserted refs from types.doc:883
types.tex(,1031) @c end inserted refs from types.doc:883
types.tex(,1032) 
types.tex(,1033) @c ------------------------------
types.tex(,1034) @node intmat type cast,  intmat operations, intmat expressions, intmat
types.tex(,1035) @subsection intmat type cast
types.tex(,1036) @cindex intmat type cast
types.tex(,1037) @table @code
types.tex(,1038) @item @strong{Syntax:}
types.tex(,1039) @code{intmat (} expression @code{)}
types.tex(,1040) @*@code{intmat (} expression, int_n, int_m  @code{)}
types.tex(,1041) @item @strong{Type:}
types.tex(,1042) intmat
types.tex(,1043) @item @strong{Purpose:}
types.tex(,1044) Converts expression to an intmat, where expression must be of type
types.tex(,1045) intvec, or intmat. If
types.tex(,1046) int_n and int_m are supplied, then they specify the dimension of the
types.tex(,1047) intmat. Otherwise, the size (resp.@: dimensions) of the intmat
types.tex(,1048) are determined  by the size (resp.@: dimensions) of the
types.tex(,1049) expression.
types.tex(,1050) @item @strong{Example:}
types.tex(,1051) @smallexample
types.tex(,1052) @c reused example intmat_type_cast types.doc:908 
types.tex(,1053)   intmat(intvec(1));
types.tex(,1054) @expansion{} 1 
types.tex(,1055)   intmat(intvec(1), 1, 2);
types.tex(,1056) @expansion{} 1,0 
types.tex(,1057)   intmat(intvec(1,2,3,4), 2, 2);
types.tex(,1058) @expansion{} 1,2,
types.tex(,1059) @expansion{} 3,4 
types.tex(,1060)   intmat(_, 2, 3);
types.tex(,1061) @expansion{} 1,2,3,
types.tex(,1062) @expansion{} 4,0,0 
types.tex(,1063)   intmat(_, 2, 1);
types.tex(,1064) @expansion{} 1,
types.tex(,1065) @expansion{} 2 
types.tex(,1066) @c end example intmat_type_cast types.doc:908
types.tex(,1067) @end smallexample
types.tex(,1068) @end table
types.tex(,1069) @c inserted refs from types.doc:917
types.tex(,1084) @c end inserted refs from types.doc:917
types.tex(,1085) @c ------------------------------
types.tex(,1086) @node intmat operations, intmat related functions, intmat type cast, intmat
types.tex(,1087) @subsection intmat operations
types.tex(,1088) @cindex intmat operations
types.tex(,1089) 
types.tex(,1090) @table @asis
types.tex(,1091) @item @code{+}
types.tex(,1092) addition with intmat or int; the int is converted into a diagonal intmat
types.tex(,1093) 
types.tex(,1094) @item @code{-}
types.tex(,1095) negation or subtraction with intmat or int; the int is converted into a
types.tex(,1096) diagonal intmat
types.tex(,1097) 
types.tex(,1098) @item @code{*}
types.tex(,1099) multiplication with intmat, intvec, or int; the int is converted into a
types.tex(,1100) diagonal intmat
types.tex(,1101) 
types.tex(,1102) @item @code{div,/}
types.tex(,1103) division of entries in the integers (omitting the remainder)
types.tex(,1104) @item @code{%, mod}
types.tex(,1105) entries modulo int (remainder of the division)
types.tex(,1106) @item @code{<>}, @code{==}
types.tex(,1107) comparison
types.tex(,1108) 
types.tex(,1109) @item intmat_expression @code{[} intvec_expression@code{,} intvec_expression @code{]}
types.tex(,1110) is an intmat entry, where the first index indicates the row and the
types.tex(,1111) second the column
types.tex(,1112) @end table
types.tex(,1113) 
types.tex(,1114) @*@strong{Example:}
types.tex(,1115) @smallexample
types.tex(,1116) @c reused example intmat_operations types.doc:954 
types.tex(,1117)   intmat m[2][4] = 1,0,2,4,0,1,-1,0,3,2,1,-2;
types.tex(,1118)   m;
types.tex(,1119) @expansion{} 1,0,2,4,
types.tex(,1120) @expansion{} 0,1,-1,0 
types.tex(,1121)   m[2,3];          // entry at row 2, col 3
types.tex(,1122) @expansion{} -1
types.tex(,1123)   size(m);         // number of entries
types.tex(,1124) @expansion{} 8
types.tex(,1125)   intvec v = 1,0,-1,2;
types.tex(,1126)   m * v;
types.tex(,1127) @expansion{} 7,1
types.tex(,1128)   typeof(_);
types.tex(,1129) @expansion{} intvec
types.tex(,1130)   intmat m1[4][3] = 0,1,2,3,v,1;
types.tex(,1131)   intmat m2 = m * m1;
types.tex(,1132)   m2;             //  2 x 3 intmat
types.tex(,1133) @expansion{} -2,5,4,
types.tex(,1134) @expansion{} 4,-1,-1 
types.tex(,1135)   m2*10;           // multiply each entry of m with 10;
types.tex(,1136) @expansion{} -20,50,40,
types.tex(,1137) @expansion{} 40,-10,-10 
types.tex(,1138)   -m2;
types.tex(,1139) @expansion{} 2,-5,-4,
types.tex(,1140) @expansion{} -4,1,1 
types.tex(,1141)   m2 % 2;
types.tex(,1142) @expansion{} 0,1,0,
types.tex(,1143) @expansion{} 0,1,1 
types.tex(,1144)   m2 div 2;
types.tex(,1145) @expansion{} -1,2,2,
types.tex(,1146) @expansion{} 2,-1,-1 
types.tex(,1147)   m2[2,1];          // entry at row 2, col 1
types.tex(,1148) @expansion{} 4
types.tex(,1149)   m1[2..3,2..3];   // submatrix
types.tex(,1150) @expansion{} 1 0 2 1
types.tex(,1151)   m2[nrows(m2),ncols(m2)];      // the last entry of intmat m2
types.tex(,1152) @expansion{} -1
types.tex(,1153) @c end example intmat_operations types.doc:954
types.tex(,1154) @end smallexample
types.tex(,1155) 
types.tex(,1156) @c ------------------------------
types.tex(,1157) @node intmat related functions,  , intmat operations, intmat
types.tex(,1158) @subsection intmat related functions
types.tex(,1159) @cindex intmat related functions
types.tex(,1160) 
types.tex(,1161) @table @code
types.tex(,1162) @item betti
types.tex(,1163) Betti numbers of a free resolution (see @ref{betti})
types.tex(,1164) @item det
types.tex(,1165) determinant (see @ref{det})
types.tex(,1166) @item ncols
types.tex(,1167) number of cols (see @ref{ncols})
types.tex(,1168) @item nrows
types.tex(,1169) number of rows (see @ref{nrows})
types.tex(,1170) @item random
types.tex(,1171) create a pseudo random intmat (see @ref{random})
types.tex(,1172) @item size
types.tex(,1173) total number of entries (see @ref{size})
types.tex(,1174) @item transpose
types.tex(,1175) transpose of an intmat (see @ref{transpose})
types.tex(,1176) @item trace
types.tex(,1177) trace of an intmat (see @ref{trace})
types.tex(,1178) @end table
types.tex(,1179) 
types.tex(,1180) @c ---------------------------------------
types.tex(,1181) @node intvec, link, intmat, Data types
types.tex(,1182) @section intvec
types.tex(,1183) @cindex intvec
types.tex(,1184) 
types.tex(,1185) Variables of type intvec are lists of integers.  For the range of
types.tex(,1186) integers see @ref{Limitations}. They may be used for simulating
types.tex(,1187) sets of integers (and other sets if the intvec is used as an index set
types.tex(,1188) for other objects). Addition and subtraction of an
types.tex(,1189) intvec with an int or an intvec is done element-wise.
types.tex(,1190) @c @example
types.tex(,1191) @c @c example
types.tex(,1192) @c   intvec iv=1,2,5,7;
types.tex(,1193) @c   iv;
types.tex(,1194) @c   iv[3];
types.tex(,1195) @c   iv[7]=1;
types.tex(,1196) @c   iv;
types.tex(,1197) @c @c example
types.tex(,1198) @c @end example
types.tex(,1199) 
types.tex(,1200) @menu
types.tex(,1201) * intvec declarations::
types.tex(,1202) * intvec expressions::
types.tex(,1203) * intvec operations::
types.tex(,1204) * intvec related functions::
types.tex(,1205) @end menu
types.tex(,1206) 
types.tex(,1207) @c ------------------------------
types.tex(,1208) @node intvec declarations, intvec expressions, intvec, intvec
types.tex(,1209) @subsection intvec declarations
types.tex(,1210) @cindex intvec declarations
types.tex(,1211) 
types.tex(,1212) @table @strong
types.tex(,1213) @item Syntax:
types.tex(,1214) @code{intvec} name @code{=} intvec_expression @code{;}
types.tex(,1215) @*@code{intvec} name @code{=} list_of_int_and_intvec_expressions @code{;}
types.tex(,1216) 
types.tex(,1217) @item Purpose:
types.tex(,1218) defines an intvec variable.
types.tex(,1219) @* An intvec consists of an ordered list of integers.
types.tex(,1220) 
types.tex(,1221) @item Default:
types.tex(,1222) 0
types.tex(,1223) 
types.tex(,1224) @item Example:
types.tex(,1225) @smallexample
types.tex(,1226) @c reused example intvec_declarations types.doc:1045 
types.tex(,1227)   intvec iv=1,3,5,7,8;
types.tex(,1228)   iv;
types.tex(,1229) @expansion{} 1,3,5,7,8
types.tex(,1230)   iv[4];
types.tex(,1231) @expansion{} 7
types.tex(,1232)   iv[3..size (iv)];
types.tex(,1233) @expansion{} 5 7 8
types.tex(,1234) @c end example intvec_declarations types.doc:1045
types.tex(,1235) @end smallexample
types.tex(,1236) @end table
types.tex(,1237) 
types.tex(,1238) @c ------------------------------
types.tex(,1239) @node intvec expressions, intvec operations, intvec declarations, intvec
types.tex(,1240) @subsection intvec expressions
types.tex(,1241) @cindex intvec expressions
types.tex(,1242) 
types.tex(,1243) An intvec expression is:
types.tex(,1244) @enumerate
types.tex(,1245) @item
types.tex(,1246) a range: int expression @code{..} int expression
types.tex(,1247) @item
types.tex(,1248) a function returning intvec
types.tex(,1249) @item
types.tex(,1250) intvec operations with int (@code{+}, @code{-}, @code{*}, @code{/}, @code{%})
types.tex(,1251) @item
types.tex(,1252) intvec operations (@code{+}, @code{-})
types.tex(,1253) @item
types.tex(,1254) intvec operation with intmat (@code{*})
types.tex(,1255) @item
types.tex(,1256) a type cast to intvec
types.tex(,1257) @end enumerate
types.tex(,1258) 
types.tex(,1259) @*@strong{Example:}
types.tex(,1260) @smallexample
types.tex(,1261) @c reused example intvec_expressions types.doc:1077 
types.tex(,1262)   intvec v=-1,2;
types.tex(,1263)   intvec w=v,v;         // concatenation
types.tex(,1264)   w;
types.tex(,1265) @expansion{} -1,2,-1,2
types.tex(,1266)   w = -2..2,v,1;
types.tex(,1267)   w;
types.tex(,1268) @expansion{} -2,-1,0,1,2,-1,2,1
types.tex(,1269)   intmat m[3][2] = 0,1,2,-2,3,1;
types.tex(,1270)   m*v;
types.tex(,1271) @expansion{} 2,-6,-1
types.tex(,1272)   typeof(_);
types.tex(,1273) @expansion{} intvec
types.tex(,1274)   v = intvec(m);
types.tex(,1275)   v;
types.tex(,1276) @expansion{} 0,1,2,-2,3,1
types.tex(,1277)   ring r;
types.tex(,1278)   poly f = x2z + 2xy-z;
types.tex(,1279)   f;
types.tex(,1280) @expansion{} x2z+2xy-z
types.tex(,1281)   v = leadexp(f);
types.tex(,1282)   v;
types.tex(,1283) @expansion{} 2,0,1
types.tex(,1284) @c end example intvec_expressions types.doc:1077
types.tex(,1285) @end smallexample
types.tex(,1286) 
types.tex(,1287) @c ------------------------------
types.tex(,1288) @node intvec operations, intvec related functions, intvec expressions, intvec
types.tex(,1289) @subsection intvec operations
types.tex(,1290) @cindex intvec operations
types.tex(,1291) 
types.tex(,1292) @table @asis
types.tex(,1293) @item @code{+}
types.tex(,1294) addition with intvec or int (component-wise)
types.tex(,1295) 
types.tex(,1296) @item @code{-}
types.tex(,1297) negation or subtraction with intvec or int (component-wise)
types.tex(,1298) 
types.tex(,1299) @item @code{*}
types.tex(,1300) multiplication with int (component-wise)
types.tex(,1301) 
types.tex(,1302) @item @code{/}, @code{div}
types.tex(,1303) division by int (component-wise)
types.tex(,1304) 
types.tex(,1305) @item  @code{%, mod}
types.tex(,1306) modulo (component-wise)
types.tex(,1307) 
types.tex(,1308) @item  @code{<>}, @code{==}, @code{<=}, @code{>=}, @code{>}, @code{<}
types.tex(,1309) comparison (done lexicographically)
types.tex(,1310) 
types.tex(,1311) @item intvec_expression @code{[} int_expression @code{]}
types.tex(,1312) is an element of the intvec; the first element has index one.
types.tex(,1313) @end table
types.tex(,1314) 
types.tex(,1315) @*@strong{Example:}
types.tex(,1316) @smallexample
types.tex(,1317) @c reused example intvec_operations types.doc:1126 
types.tex(,1318)   intvec iv =  1,3,5,7,8;
types.tex(,1319)   iv+1;               // add 1 to each entry
types.tex(,1320) @expansion{} 2,4,6,8,9
types.tex(,1321)   iv*2;
types.tex(,1322) @expansion{} 2,6,10,14,16
types.tex(,1323)   iv;
types.tex(,1324) @expansion{} 1,3,5,7,8
types.tex(,1325)   iv-10;
types.tex(,1326) @expansion{} -9,-7,-5,-3,-2
types.tex(,1327)   iv=iv,0;
types.tex(,1328)   iv;
types.tex(,1329) @expansion{} 1,3,5,7,8,0
types.tex(,1330)   iv div 2;
types.tex(,1331) @expansion{} 0,1,2,3,4,0
types.tex(,1332)   iv+iv;              // component-wise addition
types.tex(,1333) @expansion{} 2,6,10,14,16,0
types.tex(,1334)   iv[size(iv)-1];     // last-1 entry
types.tex(,1335) @expansion{} 8
types.tex(,1336)   intvec iw=2,3,4,0;
types.tex(,1337)   iv==iw;             // lexicographic comparison
types.tex(,1338) @expansion{} 0
types.tex(,1339)   iv < iw;
types.tex(,1340) @expansion{} 1
types.tex(,1341)   iv != iw;
types.tex(,1342) @expansion{} 1
types.tex(,1343)   iv[2];
types.tex(,1344) @expansion{} 3
types.tex(,1345)   iw = 4,1,2;
types.tex(,1346)   iv[iw];
types.tex(,1347) @expansion{} 7 1 3
types.tex(,1348) @c end example intvec_operations types.doc:1126
types.tex(,1349) @end smallexample
types.tex(,1350) 
types.tex(,1351) @c ------------------------------
types.tex(,1352) @node intvec related functions,  , intvec operations, intvec
types.tex(,1353) @subsection intvec related functions
types.tex(,1354) @cindex intvec related functions
types.tex(,1355) 
types.tex(,1356) @table @code
types.tex(,1357) @item hilb
types.tex(,1358) returns Hilbert series as intvec (see @ref{hilb})
types.tex(,1359) @item indepSet
types.tex(,1360) sets of independent variables of an ideal (see @ref{indepSet})
types.tex(,1361) @item leadexp
types.tex(,1362) the exponent vector of the leading monomial (see @ref{leadexp})
types.tex(,1363) @item nrows
types.tex(,1364) number of rows (see @ref{nrows})
types.tex(,1365) @item qhweight
types.tex(,1366) returns quasihomogeneous weights (see @ref{qhweight})
types.tex(,1367) @item size
types.tex(,1368) length of the intvec (see @ref{size})
types.tex(,1369) @item sortvec
types.tex(,1370) permutation for sorting ideals/modules (see @ref{sortvec})
types.tex(,1371) @item transpose
types.tex(,1372) transpose of an intvec, returns an intmat (see @ref{transpose})
types.tex(,1373) @item weight
types.tex(,1374) returns weights for the weighted ecart method (see @ref{weight})
types.tex(,1375) @end table
types.tex(,1376) 
types.tex(,1377) @c ---------------------------------------
types.tex(,1378) @node link, list, intvec, Data types
types.tex(,1379) @section link
types.tex(,1380) @cindex link
types.tex(,1381) 
types.tex(,1382) @c {{{ section link }}}
types.tex(,1383) Links are the communication channels of @sc{Singular}, i.e.,
types.tex(,1384) something @sc{Singular} can write to and/or read from. Currently,
types.tex(,1385) @sc{Singular} supports four different link types:
types.tex(,1386) @itemize @bullet
types.tex(,1387) @item ASCII links (see
types.tex(,1388) @ref{ASCII links})
types.tex(,1389) 
types.tex(,1390) @item MPfile links (see
types.tex(,1391) @ref{MPfile links})
types.tex(,1392) 
types.tex(,1393) @item MPtcp links (see
types.tex(,1394) @ref{MPtcp links})
types.tex(,1395) 
types.tex(,1396) @item DBM links (see
types.tex(,1397) @ref{DBM links})
types.tex(,1398) @end itemize
types.tex(,1399) 
types.tex(,1400) @menu
types.tex(,1401) * link declarations::
types.tex(,1402) * link expressions::
types.tex(,1403) * link related functions::
types.tex(,1404) * ASCII links::
types.tex(,1405) * MP links::
types.tex(,1406) * DBM links::
types.tex(,1407) @end menu
types.tex(,1408) 
types.tex(,1409) @c ------------------------------
types.tex(,1410) @node link declarations, link expressions, link, link
types.tex(,1411) @subsection link declarations
types.tex(,1412) @cindex link declarations
types.tex(,1413) 
types.tex(,1414) @table @strong
types.tex(,1415) @item Syntax:
types.tex(,1416) @code{link} name @code{=} string_expression @code{;}
types.tex(,1417) 
types.tex(,1418) @item Purpose:
types.tex(,1419) defines a new communication link.
types.tex(,1420) 
types.tex(,1421) @item Default:
types.tex(,1422) none
types.tex(,1423) 
types.tex(,1424) @item Example:
types.tex(,1425) @smallexample
types.tex(,1426) @c Tim: Let's only do the read here once, doing it twice without closing
types.tex(,1427) @c it first might be confusing
types.tex(,1428) @c reused example link_declarations types.doc:1224 
types.tex(,1429)   link l=":w example.txt";
types.tex(,1430)   int i=22;          // cf. ASCII links for explanation
types.tex(,1431)   string s="An int follows:";
types.tex(,1432)   write(l,s,i);
types.tex(,1433)   l;
types.tex(,1434) @expansion{} // type : ASCII
types.tex(,1435) @expansion{} // mode : w
types.tex(,1436) @expansion{} // name : example.txt
types.tex(,1437) @expansion{} // open : yes
types.tex(,1438) @expansion{} // read : not ready
types.tex(,1439) @expansion{} // write: ready
types.tex(,1440)   close(l);          //
types.tex(,1441)   read(l);
types.tex(,1442) @expansion{} An int follows:
types.tex(,1443) @expansion{} 22
types.tex(,1444) @expansion{} 
types.tex(,1445)   close(l);
types.tex(,1446) @c end example link_declarations types.doc:1224
types.tex(,1447) @end smallexample
types.tex(,1448) @end table
types.tex(,1449) 
types.tex(,1450) @c ------------------------------
types.tex(,1451) @node link expressions, link related functions, link declarations, link
types.tex(,1452) @subsection link expressions
types.tex(,1453) @cindex link expressions
types.tex(,1454) 
types.tex(,1455) A link expression is:
types.tex(,1456) @enumerate
types.tex(,1457) @item
types.tex(,1458) an identifier of type link
types.tex(,1459) @item
types.tex(,1460) a string describing the link
types.tex(,1461) @end enumerate
types.tex(,1462) 
types.tex(,1463) A link is described by a string which consists of two parts: a property
types.tex(,1464) string followed by a name string. The property string describes the type
types.tex(,1465) of the link (@code{ASCII}, @code{MPfile}, @code{MPtcp} or @code{DBM})
types.tex(,1466) and the mode of the link (e.g., open for read, write or append). The name
types.tex(,1467) string describes the filename of the link, resp.@: a network connection
types.tex(,1468) for MPtcp links.
types.tex(,1469) 
types.tex(,1470) For a detailed format description of the link describing string see:
types.tex(,1486) 
types.tex(,1487) @menu
types.tex(,1488) * ASCII links::
types.tex(,1489) * MPfile links::
types.tex(,1490) * MPtcp links::
types.tex(,1491) * DBM links::
types.tex(,1492) @end menu
types.tex(,1493) 
types.tex(,1494) @c ------------------------------
types.tex(,1495) @node link related functions, ASCII links, link expressions, link
types.tex(,1496) @subsection link related functions
types.tex(,1497) @cindex link related functions
types.tex(,1498) 
types.tex(,1499) @table @code
types.tex(,1500) @item close
types.tex(,1501) closes a link (see @ref{close})
types.tex(,1502) @item dump
types.tex(,1503) generates a dump of all variables and their values (see @ref{dump})
types.tex(,1504) @item getdump
types.tex(,1505) reads a dump (see @ref{getdump})
types.tex(,1506) @item open
types.tex(,1507) opens a link (see @ref{open})
types.tex(,1508) @item read
types.tex(,1509) reads from a link (see @ref{read})
types.tex(,1510) @item status
types.tex(,1511) gets the status of a link (see @ref{status})
types.tex(,1512) @item write
types.tex(,1513) writes to a link (see @ref{write})
types.tex(,1514) @item kill
types.tex(,1515) closes and kills a link (see @ref{kill})
types.tex(,1516) @end table
types.tex(,1517) 
types.tex(,1518) @c ------------------------------
types.tex(,1519) @node ASCII links, MP links, link related functions, link
types.tex(,1520) @subsection ASCII links
types.tex(,1521) @cindex ASCII links
types.tex(,1522) 
types.tex(,1523) Via ASCII links data that can be converted to a string can be written
types.tex(,1524) into files for storage or communication with other programs. The data is
types.tex(,1525) written in plain ASCII format. The output format of polynomials is done
types.tex(,1526) w.r.t@:. the value of the global variable @code{short} (see @ref{short}).
types.tex(,1527) Reading from an ASCII link returns a string --- conversion into other data
types.tex(,1528) is up to the user. This can be done, for example,
types.tex(,1529) using the command @code{execute}
types.tex(,1530) (see @ref{execute}).
types.tex(,1531) 
types.tex(,1532) The ASCII link describing string has to be one of the following:
types.tex(,1533) 
types.tex(,1534) @enumerate
types.tex(,1535) @item @code{"ASCII: "} + filename
types.tex(,1536) @*the mode (read or append) is set by the first @code{read} or
types.tex(,1537) @code{write} command.
types.tex(,1538) @item @code{"ASCII:r "} + filename
types.tex(,1539) @*opens the file for reading.
types.tex(,1540) @item @code{"ASCII:w "} + filename
types.tex(,1541) @*opens the file for overwriting.
types.tex(,1542) @item @code{"ASCII:a "} + filename
types.tex(,1543) @*opens the file for appending.
types.tex(,1544) @end enumerate
types.tex(,1545) 
types.tex(,1546) There are the following default values:
types.tex(,1547) @itemize @bullet
types.tex(,1548) @item the type @code{ASCII} may be omitted since ASCII links are the
types.tex(,1549) default links.
types.tex(,1550) 
types.tex(,1551) @item if non of @code{r}, @code{w}, or @code{a} is specified, the mode of
types.tex(,1552) the link is set by the first @code{read} or @code{write} command on the
types.tex(,1553) link. If the first command is @code{write}, the mode is set to @code{a}
types.tex(,1554) (append mode).
types.tex(,1555) 
types.tex(,1556) @item if the filename is omitted, @code{read} reads from stdin and
types.tex(,1557) @code{write} writes to stdout.
types.tex(,1558) @end itemize
types.tex(,1559) 
types.tex(,1560) Using these default rules, the string @code{":r temp"} describes a link
types.tex(,1561) which is equivalent to the link @code{"ASCII:r temp"}: an ASCII link to
types.tex(,1562) the file @code{temp} which is opened for reading. The string
types.tex(,1563) @code{"temp"} describes an ASCII link to the file @code{temp}, where the
types.tex(,1564) mode is set by the first @code{read} or @code{write} command. See also
types.tex(,1565) the example below.
types.tex(,1566) 
types.tex(,1567) Note that the filename may contain a path. On Microsoft Windows
types.tex(,1568) (resp.@: MS-DOS) platforms, names of a drive can precede the filename, but
types.tex(,1569) must be started with a @code{//} (as in @code{//c/temp/ex}. An ASCII
types.tex(,1570) link can be used either for reading or for writing, but not for both at
types.tex(,1571) the same time. A @code{close} command must be used before a change of
types.tex(,1572) I/O direction. Types without a conversion to @code{string} cannot be
types.tex(,1573) written.
types.tex(,1574) 
types.tex(,1575) @*@strong{Example:}
types.tex(,1576) @smallexample
types.tex(,1577) @c reused example ASCII_links types.doc:1364 
types.tex(,1578)   ring r=32003,(x,y,z),dp;
types.tex(,1579)   link l=":w example.txt";     // type is ASCII, mode is overwrite
types.tex(,1580)   l;
types.tex(,1581) @expansion{} // type : ASCII
types.tex(,1582) @expansion{} // mode : w
types.tex(,1583) @expansion{} // name : example.txt
types.tex(,1584) @expansion{} // open : no
types.tex(,1585) @expansion{} // read : not ready
types.tex(,1586) @expansion{} // write: not ready
types.tex(,1587)   status(l, "open", "yes");    // link is not yet opened
types.tex(,1588) @expansion{} 0
types.tex(,1589)   ideal i=x2,y2,z2;
types.tex(,1590)   write (l,1,";",2,";","ideal i=",i,";");
types.tex(,1591)   status(l, "open", "yes");    // now link is open
types.tex(,1592) @expansion{} 1
types.tex(,1593)   status(l, "mode");           // for writing
types.tex(,1594) @expansion{} w
types.tex(,1595)   close(l);                    // link is closed
types.tex(,1596)   write("example.txt","int j=5;");// data is appended to file
types.tex(,1597)   read("example.txt");         // data is returned as string
types.tex(,1598) @expansion{} 1
types.tex(,1599) @expansion{} ;
types.tex(,1600) @expansion{} 2
types.tex(,1601) @expansion{} ;
types.tex(,1602) @expansion{} ideal i=
types.tex(,1603) @expansion{} x2,y2,z2
types.tex(,1604) @expansion{} ;
types.tex(,1605) @expansion{} int j=5;
types.tex(,1606) @expansion{} 
types.tex(,1607)   execute(read(l));            // read string is executed
types.tex(,1608) @expansion{} 1
types.tex(,1609) @expansion{} 2
types.tex(,1610) @expansion{} // ** redefining i **
types.tex(,1611)   close(l);                    // link is closed
types.tex(,1612) @c end example ASCII_links types.doc:1364
types.tex(,1613) @c  // dump vars overwriting previous file content:
types.tex(,1614) @c  dump(":w example.txt");
types.tex(,1615) @end smallexample
types.tex(,1616) 
types.tex(,1617) @c ------------------------------
types.tex(,1618) @node MP links, DBM links, ASCII links, link
types.tex(,1619) @subsection MP links
types.tex(,1620) @cindex MP links
types.tex(,1621) 
types.tex(,1622) MP (Multi Protocol) links give the possibility to store and communicate
types.tex(,1623) data in the binary MP format: Read and write access is very fast
types.tex(,1624) compared to ASCII links. MP links can be established using files (link
types.tex(,1625) type is @code{MPfile}) or using TCP sockets (link type is
types.tex(,1626) @code{MPtcp}). All data (including such data that cannot be converted
types.tex(,1627) to a string) can be written to an MP link. For ring-dependent data, a
types.tex(,1628) ring description is written together with the data. Reading from an MP
types.tex(,1629) link returns an expression (not a string) which was evaluated after the
types.tex(,1630) read operation. If the expression read from an MP link is not from the
types.tex(,1631) same ring as the current ring, then a @code{read} changes the current
types.tex(,1632) ring.
types.tex(,1633) 
types.tex(,1634) Currently, MP links are only available on Unix platforms and data is
types.tex(,1635) written without attributes (which is likely to change in future
types.tex(,1636) versions). For a general description of MP, see
types.tex(,1637) @code{http://symbolicnet.mcs.kent.edu/areas/mp.html}.
types.tex(,1638) 
types.tex(,1639) @menu
types.tex(,1640) * MPfile links::
types.tex(,1641) * MPtcp links::
types.tex(,1642) @end menu
types.tex(,1643) 
types.tex(,1644) @c -------------------------------------------------------------
types.tex(,1645) @node MPfile links, MPtcp links, MP links, MP links
types.tex(,1646) @subsubsection MPfile links
types.tex(,1647) @cindex MPfile links
types.tex(,1648) 
types.tex(,1649) MPfile links provide the possibility to store data in a file using the
types.tex(,1650) binary MP format. Read and write operations are very fast compared to
types.tex(,1651) ASCII links. Therefore, for storing large amounts of data, MPfile links
types.tex(,1652) should be used instead of ASCII links. Unlike ASCII links, data read
types.tex(,1653) from MPfile links is returned as expressions one at a time, and not as a
types.tex(,1654) string containing the entire content of the file. Furthermore, ring-dependent
types.tex(,1655) data is stored together with a ring description. Therefore,
types.tex(,1656) reading ring-dependent data might change the current ring.
types.tex(,1657) 
types.tex(,1658) The MPfile link describing string has to be one of the following:
types.tex(,1659) 
types.tex(,1660) @enumerate
types.tex(,1661) @item @code{"MPfile: "} + filename
types.tex(,1662) @*the mode (read or append) is set by the first @code{read} or
types.tex(,1663) @code{write} command.
types.tex(,1664) @item @code{"MPfile:r "} + filename
types.tex(,1665) @*opens the file for reading.
types.tex(,1666) @item @code{"MPfile:w "} + filename
types.tex(,1667) @*opens the file for overwriting.
types.tex(,1668) @item @code{"MPfile:a "} + filename
types.tex(,1669) @*opens the file for appending.
types.tex(,1670) @end enumerate
types.tex(,1671) 
types.tex(,1672) There are the following default values:
types.tex(,1673) @itemize @bullet
types.tex(,1674) @item if none of @code{r}, @code{w}, or @code{a} is specified, the mode of
types.tex(,1675) the link is set by the first @code{read} or @code{write} command on the
types.tex(,1676) link. If the first command is @code{write}, the mode is set to @code{a}
types.tex(,1677) (append mode).
types.tex(,1678) @c Tim: You and I were right here: It is indeed append. Olaf
types.tex(,1679) @end itemize
types.tex(,1680) 
types.tex(,1681) Note that the filename may contain a path. An MPfile link can be used
types.tex(,1682) either for reading or for writing, but not for both at the same time. A
types.tex(,1683) @code{close} command must be used before a change of I/O direction.
types.tex(,1684) 
types.tex(,1685) @*@strong{Example:}
types.tex(,1686) @smallexample
types.tex(,1687) @c reused example MPfile_links types.doc:1453 
types.tex(,1688)   ring r;
types.tex(,1689)   link l="MPfile:w example.mp"; // type=MPfile, mode=overwrite
types.tex(,1690)   l;
types.tex(,1691) @expansion{} // type : MPfile
types.tex(,1692) @expansion{} // mode : w
types.tex(,1693) @expansion{} // name : example.mp
types.tex(,1694) @expansion{} // open : no
types.tex(,1695) @expansion{} // read : not ready
types.tex(,1696) @expansion{} // write: not ready
types.tex(,1697)   ideal i=x2,y2,z2;
types.tex(,1698)   write (l,1, i, "hello world");// write three expressions
types.tex(,1699)   write(l,4);                   // append one more expression
types.tex(,1700)   close(l);                     // link is closed
types.tex(,1701)   // open the file for reading now
types.tex(,1702)   read(l);                      // only first expression is read
types.tex(,1703) @expansion{} 1
types.tex(,1704)   kill r;                       // no basering active now
types.tex(,1705)   def i = read(l);              // second expression
types.tex(,1706)   // notice that current ring was set, the name was assigned
types.tex(,1707)   // automatically
types.tex(,1708)   listvar(ring);
types.tex(,1709) @expansion{} // mpsr_r0              [0]  *ring
types.tex(,1710)   def s = read(l);              // third expression
types.tex(,1711)   listvar();
types.tex(,1712) @expansion{} // s                    [0]  string hello world
types.tex(,1713) @expansion{} // mpsr_r0              [0]  *ring
types.tex(,1714) @expansion{} //      i                    [0]  ideal, 3 generator(s)
types.tex(,1715) @expansion{} // l                    [0]  link
types.tex(,1716) @expansion{} // LIB                  [0]  string standard.lib
types.tex(,1717)   close(l);                     // link is closed
types.tex(,1718)   dump("MPfile:w example.mp");  // dump everything to example.mp
types.tex(,1719)   kill i, s;                    // kill i and s
types.tex(,1720)   getdump("MPfile: example.mp");// get previous dump
types.tex(,1721)   listvar();                    // got all variables and values back
types.tex(,1722) @expansion{} // mpsr_r0              [0]  *ring
types.tex(,1723) @expansion{} //      i                    [0]  ideal, 3 generator(s)
types.tex(,1724) @expansion{} // s                    [0]  string hello world
types.tex(,1725) @expansion{} // l                    [0]  link
types.tex(,1726) @expansion{} // LIB                  [0]  string standard.lib
types.tex(,1727) @c end example MPfile_links types.doc:1453
types.tex(,1728) @end smallexample
types.tex(,1729) 
types.tex(,1730) @c -------------------------------------------------------------
types.tex(,1731) @node MPtcp links,  , MPfile links, MP links
types.tex(,1732) @subsubsection MPtcp links
types.tex(,1733) @cindex MPtcp links
types.tex(,1734) 
types.tex(,1735) MPtcp links give the possibility to exchange data in the binary MP
types.tex(,1736) format between two processes which may run on the same or on different
types.tex(,1737) computers. MPtcp links can be opened in four different modes:
types.tex(,1738) 
types.tex(,1739) @table @code
types.tex(,1740) @item listen
types.tex(,1741) @sc{Singular} acts as a server.
types.tex(,1742) 
types.tex(,1743) @item connect
types.tex(,1744) @sc{Singular} acts as a client.
types.tex(,1745) 
types.tex(,1746) @item launch
types.tex(,1747) @sc{Singular} acts as a client, launching an application as server.
types.tex(,1748) 
types.tex(,1749) @item fork
types.tex(,1750) @sc{Singular} acts as a client, forking another @sc{Singular} as
types.tex(,1751) server.
types.tex(,1752) @end table
types.tex(,1753) 
types.tex(,1754) The MPtcp link describing string has to be
types.tex(,1755) @itemize @bullet
types.tex(,1756) @item listen mode:
types.tex(,1757) @enumerate
types.tex(,1758) @item @code{"MPtcp:listen --MPport "} + portnumber
types.tex(,1759) @end enumerate
types.tex(,1760) @sc{Singular} becomes a server and waits at the port for a
types.tex(,1761) connect call.
types.tex(,1762) @item connect mode:
types.tex(,1763) @enumerate 2
types.tex(,1764) @item @code{"MPtcp:connect --MPport "} + portnumber
types.tex(,1765) @item @code{"MPtcp:connect --MPhost "} + hostname + @code{" --MPport "} +
types.tex(,1766) portnumber
types.tex(,1767) @end enumerate
types.tex(,1768) @sc{Singular} becomes a client and connects to a server waiting at
types.tex(,1769) the host and port.
types.tex(,1770) @item launch mode:
types.tex(,1771) @enumerate 4
types.tex(,1772) @item @code{"MPtcp:launch"}
types.tex(,1773) @item @code{"MPtcp:launch --MPrsh "} + rsh
types.tex(,1774) @item @code{"MPtcp:launch --MPrsh "} + rsh  + @code{" --MPhost "} +
types.tex(,1775) hostname
types.tex(,1776) @item @code{"MPtcp:launch --MPrsh "} + rsh  + @code{" --MPhost "} +
types.tex(,1777) hostname + @code{" --MPapplication "} + application
types.tex(,1778) @end enumerate
types.tex(,1779) @sc{Singular} becomes a client and starts (launches) the application
types.tex(,1780) using the specified remote shell command (default is
types.tex(,1781) @code{ssh}) on a (possibly) different host (default is @code{localhost}
types.tex(,1782) which then acts as a server.
types.tex(,1783) @item fork mode:
types.tex(,1784) @enumerate 8
types.tex(,1785) @item @code{"MPtcp:fork"}
types.tex(,1786) @end enumerate
types.tex(,1787) @sc{Singular} becomes a client and forks another @sc{Singular} on the
types.tex(,1788) same host which acts as a server.
types.tex(,1789) @end itemize
types.tex(,1790) 
types.tex(,1791) There are the following default values:
types.tex(,1792) @itemize @bullet
types.tex(,1793) @item if none of @code{listen}, @code{connect}, @code{launch} or
types.tex(,1794) @code{fork} is specified, the default mode is set to @code{fork}.
types.tex(,1795) 
types.tex(,1796) @item if no remote shell (rsh) command is specified, then the command
types.tex(,1797) @code{ssh} is used.
types.tex(,1798) 
types.tex(,1799) @item if no application is specified (in mode @code{launch}) the default
types.tex(,1800) application is the value of @code{system("Singular") + "-bq"}.
types.tex(,1801) (This evaluates to the absolute path of the @sc{Singular} currently running
types.tex(,1802) with the option @code{"-bq"} appended.)
types.tex(,1803) 
types.tex(,1804) @item if no hostname is specified the local host is used as default host.
types.tex(,1805) @end itemize
types.tex(,1806) 
types.tex(,1807) To open an MPtcp link in launch mode, the application to launch must
types.tex(,1808) either be given with an absolute pathname, or must be in a directory
types.tex(,1809) contained in the search path. The launched application acts as a server,
types.tex(,1810) whereas the @sc{Singular} that actually opened the link acts as a
types.tex(,1811) client. @sc{Singular} automatically appends the command line arguments
types.tex(,1812) "@code{--MPmode connect --MPhost} hostname @code{--MPport} portnumber"
types.tex(,1813) to the command line of the server application. Both hostname and
types.tex(,1814) portnumber are substituted by the values from the link
types.tex(,1815) specification. The client "listens" at the given port until the server
types.tex(,1816) application does a connect call. If @sc{Singular} is used as server
types.tex(,1817) application it has to be started with the command line option @code{-b}.
types.tex(,1818) Since launching is done using a remote shell command, the host on which
types.tex(,1819) the application should run must have an entry in the @code{.rhosts}
types.tex(,1820) file. Even the local machine must have an entry if applications are to
types.tex(,1821) be launched locally.
types.tex(,1822) 
types.tex(,1823) If the MPtcp link is opened in fork mode a child of the current
types.tex(,1824) @sc{Singular} is forked. All variables and their values are inherited by
types.tex(,1825) the child. The child acts as a server whereas the @sc{Singular} that
types.tex(,1826) actually opened the link acts as a client.
types.tex(,1827) 
types.tex(,1828) To arrange the evaluation of an expression by a server, the expression
types.tex(,1829) must be quoted using the command @code{quote} (see @ref{quote}), so that
types.tex(,1830) a local evaluation is prevented. Otherwise, the expression is evaluated
types.tex(,1831) first, and the result of the evaluation is written, instead of the
types.tex(,1832) expression which is to be evaluated.
types.tex(,1833) 
types.tex(,1834) If @sc{Singular} is in server mode, the value of the variable
types.tex(,1835) @code{mp_ll} is the MPtcp link connecting to the client and
types.tex(,1836) @sc{Singular} is in an infinite read-eval-write loop until the
types.tex(,1837) connection is closed from the client side (by closing its connecting
types.tex(,1838) link). Reading and writing is done to the link @code{mp_ll}: After an
types.tex(,1839) expression is read, it is evaluated and the result of the evaluation is
types.tex(,1840) written back.  That is, for each expression which was written to the
types.tex(,1841) server, there is exactly one expression written back. This might be an
types.tex(,1842) "empty" expression, if the evaluation on the server side does not return
types.tex(,1843) a value.
types.tex(,1844) 
types.tex(,1845) MPtcp links should explicitly be opened before being used. MPtcp links
types.tex(,1846) are bidirectional, i.e., can be be used for both, writing and
types.tex(,1847) reading. Reading from an MPtcp link blocks until data was written to
types.tex(,1848) that link. The @code{status} command can be used to check whether there
types.tex(,1849) is data to read.
types.tex(,1850) 
types.tex(,1851) @*@strong{Example:}
types.tex(,1852) @smallexample
types.tex(,1853) @c reused example MPtcp_links types.doc:1601 
types.tex(,1854)   LIB "general.lib"; // needed for "killall" command
types.tex(,1855)   link l="MPtcp:launch";
types.tex(,1856)   open(l); l;        // l is ready for writing but not for reading
types.tex(,1857) @expansion{} // type : MPtcp
types.tex(,1858) @expansion{} // mode : launch
types.tex(,1859) @expansion{} // name : 
types.tex(,1860) @expansion{} // open : yes
types.tex(,1861) @expansion{} // read : not ready
types.tex(,1862) @expansion{} // write: ready
types.tex(,1863) 
types.tex(,1864)   ring r; ideal i=x2+y,xyz+z,x2+y2;
types.tex(,1865) 
types.tex(,1866)   write (l,quote(std(eval(i))));   // std(i) is computed on server
types.tex(,1867)   def j = read(l);j; // result of computation on server is read
types.tex(,1868) @expansion{} j[1]=z
types.tex(,1869) @expansion{} j[2]=y2-y
types.tex(,1870) @expansion{} j[3]=x2+y2
types.tex(,1871) 
types.tex(,1872)   write(l, quote(getdump(mp_ll))); // server reads dump
types.tex(,1873)   dump(l);           //  dump is written to server (includes proc's)
types.tex(,1874)   read(l);           // result of previous write-command is read
types.tex(,1875)   killall("not", "link"); killall("proc"); // kills everything, but links
types.tex(,1876) @expansion{} // ** killing the basering for level 0
types.tex(,1877) 
types.tex(,1878)   write(l, quote(dump(mp_ll)));    // server writes dump
types.tex(,1879)   getdump(l);        // dump is read from server
types.tex(,1880)   read(l);           // result of previous write-command is read
types.tex(,1881) 
types.tex(,1882)   close(l);          // server is shut down
types.tex(,1883)   listvar(all);      // same state as we had before "killall()"
types.tex(,1884) @expansion{} // mpsr_r0              [0]  ring
types.tex(,1885) @expansion{} // r                    [0]  *ring
types.tex(,1886) @expansion{} //      j                    [0]  ideal, 3 generator(s)
types.tex(,1887) @expansion{} //      i                    [0]  ideal, 3 generator(s)
types.tex(,1888) @expansion{} // l                    [0]  link
types.tex(,1889) 
types.tex(,1890)   l = "MPtcp:";      // fork link declaration
types.tex(,1891)   open(l); l;        // Notice that name is "parent"
types.tex(,1892) @expansion{} // type : MPtcp
types.tex(,1893) @expansion{} // mode : fork
types.tex(,1894) @expansion{} // name : parent
types.tex(,1895) @expansion{} // open : yes
types.tex(,1896) @expansion{} // read : not ready
types.tex(,1897) @expansion{} // write: ready
types.tex(,1898) 
types.tex(,1899)   write(l, quote(status(mp_ll, "name")));
types.tex(,1900)   read(l);           // and name of forked link is "child"
types.tex(,1901) @expansion{} child
types.tex(,1902)   write(l,quote(i)); // Child inherited vars and their values
types.tex(,1903)   read(l);
types.tex(,1904) @expansion{} _[1]=x2+y
types.tex(,1905) @expansion{} _[2]=xyz+z
types.tex(,1906) @expansion{} _[3]=x2+y2
types.tex(,1907)   close(l);          // shut down forked child
types.tex(,1908) @c end example MPtcp_links types.doc:1601
types.tex(,1909) @end smallexample
types.tex(,1910) 
types.tex(,1911) @c ------------------------------
types.tex(,1912) @node DBM links,  , MP links, link
types.tex(,1913) @subsection DBM links
types.tex(,1914) @cindex DBM links
types.tex(,1915) 
types.tex(,1916) DBM links provide access to data stored in a data base.
types.tex(,1917) Each entry in the data base consists of a (key_string,
types.tex(,1918) value_string) pair. Such a pair can be inserted with the command
types.tex(,1919) @code{write(}link@code{,} key_string@code{,} value_string@code{)}.  By
types.tex(,1920) calling @code{write(}link@code{,} key_string@code{)}, the entry with key
types.tex(,1921) key_string is deleted from the data base. The value of an entry is
types.tex(,1922) returned by the command @code{read(}link@code{,}
types.tex(,1923) key_string@code{)}. With only one argument, @code{read(}link@code{)}
types.tex(,1924) returns the next key in the data base. Using this feature a
types.tex(,1925) data base can be scanned in order to access all entries of the data base.
types.tex(,1926) 
types.tex(,1927) If a data base with name @code{name} is opened for writing for the first
types.tex(,1928) time, two files (@code{name.pag} and @code{name.dir}), which contain the
types.tex(,1929) data base, are automatically created.
types.tex(,1930) 
types.tex(,1931) The DBM link describing string has to be one of the following:
types.tex(,1932) 
types.tex(,1933) @enumerate
types.tex(,1934) @item @code{"DBM: "} + name
types.tex(,1935) @*opens the data base for reading (default mode).
types.tex(,1936) 
types.tex(,1937) @item @code{"DBM:r "} + name
types.tex(,1938) @*opens the data base for reading.
types.tex(,1939) 
types.tex(,1940) @item @code{"DBM:rw "} + name
types.tex(,1941) @*opens the data base for reading and writing.
types.tex(,1942) @end enumerate
types.tex(,1943) 
types.tex(,1944) Note that @code{name} must be given without the suffix @code{.pag} or
types.tex(,1945) @code{.dir}. The name may contain an (absolute) path.
types.tex(,1946) 
types.tex(,1947) @*@strong{Example:}
types.tex(,1948) @smallexample
types.tex(,1949) @c reused example DBM_links types.doc:1672 
types.tex(,1950)   link l="DBM:rw example";
types.tex(,1951)   write(l,"1","abc");
types.tex(,1952)   write(l,"3","XYZ");
types.tex(,1953)   write(l,"2","ABC");
types.tex(,1954)   l;
types.tex(,1955) @expansion{} // type : DBM
types.tex(,1956) @expansion{} // mode : rw
types.tex(,1957) @expansion{} // name : example
types.tex(,1958) @expansion{} // open : yes
types.tex(,1959) @expansion{} // read : ready
types.tex(,1960) @expansion{} // write: ready
types.tex(,1961)   close(l);
types.tex(,1962)   // read all keys (till empty string):
types.tex(,1963)   read(l);
types.tex(,1964) @expansion{} 1
types.tex(,1965)   read(l);
types.tex(,1966) @expansion{} 3
types.tex(,1967)   read(l);
types.tex(,1968) @expansion{} 2
types.tex(,1969)   read(l);
types.tex(,1970) @expansion{} 
types.tex(,1971)   // read data corresponding to key "1"
types.tex(,1972)   read(l,"1");
types.tex(,1973) @expansion{} abc
types.tex(,1974)   // read all data:
types.tex(,1975)   read(l,read(l));
types.tex(,1976) @expansion{} abc
types.tex(,1977)   read(l,read(l));
types.tex(,1978) @expansion{} XYZ
types.tex(,1979)   read(l,read(l));
types.tex(,1980) @expansion{} ABC
types.tex(,1981)   // close
types.tex(,1982)   close(l);
types.tex(,1983) @c end example DBM_links types.doc:1672
types.tex(,1984) @end smallexample
types.tex(,1985) 
types.tex(,1986) @c ---------------------------------------
types.tex(,1987) @node list, map, link, Data types
types.tex(,1988) @section list
types.tex(,1989) @cindex list
types.tex(,1990) 
types.tex(,1991) Lists are arrays whose elements can be of any type (including ring and
types.tex(,1992) qring). If one element belongs to a ring the whole list belongs to that
types.tex(,1993) ring. This applies also to the special list @code{#}. The expression
types.tex(,1994) @code{list()} is the empty list.
types.tex(,1995) 
types.tex(,1996) Note that a list stores the objects itself and not the names.  Hence, if
types.tex(,1997) @code{L} is a list, @code{L[1]} for example has no name.  A name, say
types.tex(,1998) @code{R}, can be created for @code{L[1]} by @code{def R=L[1];}. To store
types.tex(,1999) also the name of an object, say @code{r}, it can be added to the list
types.tex(,2000) with @code{nameof(r);}. Rings and qrings may be objects of a list.
types.tex(,2001) 
types.tex(,2002) @strong{Note}: Unlike other assignments a ring as an element of a list
types.tex(,2003) is not a copy but another reference to the same ring.
types.tex(,2004) 
types.tex(,2005) @menu
types.tex(,2006) * list declarations::
types.tex(,2007) * list expressions::
types.tex(,2008) * list operations::
types.tex(,2009) * list related functions::
types.tex(,2010) @end menu
types.tex(,2011) 
types.tex(,2012) @c ------------------------------
types.tex(,2013) @node list declarations, list expressions, list, list
types.tex(,2014) @subsection list declarations
types.tex(,2015) @cindex list declarations
types.tex(,2016) 
types.tex(,2017) @table @strong
types.tex(,2018) @item Syntax:
types.tex(,2019) @code{list} name @code{=} expression_list@code{;}
types.tex(,2020) @*@code{list} name @code{=} list_expression@code{;}
types.tex(,2021) 
types.tex(,2022) @item Purpose:
types.tex(,2023) defines a list (of objects of possibly different types).
types.tex(,2024) 
types.tex(,2025) @item Default:
types.tex(,2026) empty list
types.tex(,2027) 
types.tex(,2028) @item Example:
types.tex(,2029) @smallexample
types.tex(,2030) @c reused example list_declarations types.doc:1739 
types.tex(,2031)   list l=1,"str";
types.tex(,2032)   l[1];
types.tex(,2033) @expansion{} 1
types.tex(,2034)   l[2];
types.tex(,2035) @expansion{} str
types.tex(,2036)   ring r;
types.tex(,2037)   listvar(r);
types.tex(,2038) @expansion{} // r                    [0]  *ring
types.tex(,2039)   ideal i = x^2, y^2 + z^3;
types.tex(,2040)   l[3] = i;
types.tex(,2041)   l;
types.tex(,2042) @expansion{} [1]:
types.tex(,2043) @expansion{}    1
types.tex(,2044) @expansion{} [2]:
types.tex(,2045) @expansion{}    str
types.tex(,2046) @expansion{} [3]:
types.tex(,2047) @expansion{}    _[1]=x2
types.tex(,2048) @expansion{}    _[2]=z3+y2
types.tex(,2049)   listvar(r);     // the list l belongs now to the ring r
types.tex(,2050) @expansion{} // r                    [0]  *ring
types.tex(,2051) @expansion{} // l                    [0]  list, size: 3
types.tex(,2052) @expansion{} // i                    [0]  ideal, 2 generator(s)
types.tex(,2053) @c end example list_declarations types.doc:1739
types.tex(,2054) @end smallexample
types.tex(,2055) @end table
types.tex(,2056) 
types.tex(,2057) @c ------------------------------
types.tex(,2058) @node list expressions, list operations, list declarations, list
types.tex(,2059) @subsection list expressions
types.tex(,2060) @cindex list expressions
types.tex(,2061) 
types.tex(,2062) A list expression is:
types.tex(,2063) @enumerate
types.tex(,2064) @item
types.tex(,2065) the empty list @code{list()}
types.tex(,2066) @item
types.tex(,2067) an identifier of type list
types.tex(,2068) @item
types.tex(,2069) a function returning list
types.tex(,2070) @item
types.tex(,2071) list expressions combined by the arithmetic operation @code{+}
types.tex(,2072) @item
types.tex(,2073) a type cast to list
types.tex(,2074) @end enumerate
types.tex(,2075) 
types.tex(,2076) @c inserted refs from types.doc:1772
types.tex(,2087) @c end inserted refs from types.doc:1772
types.tex(,2088) 
types.tex(,2089) @*@strong{Example:}
types.tex(,2090) @smallexample
types.tex(,2091) @c reused example list_expressions types.doc:1778 
types.tex(,2092)   list l = "hello",1;
types.tex(,2093)   l;
types.tex(,2094) @expansion{} [1]:
types.tex(,2095) @expansion{}    hello
types.tex(,2096) @expansion{} [2]:
types.tex(,2097) @expansion{}    1
types.tex(,2098)   l = list();
types.tex(,2099)   l;
types.tex(,2100) @expansion{} empty list
types.tex(,2101)   ring r =0,x,dp;
types.tex(,2102)   factorize((x+1)^2);
types.tex(,2103) @expansion{} [1]:
types.tex(,2104) @expansion{}    _[1]=1
types.tex(,2105) @expansion{}    _[2]=x+1
types.tex(,2106) @expansion{} [2]:
types.tex(,2107) @expansion{}    1,2
types.tex(,2108)   list(1,2,3);
types.tex(,2109) @expansion{} [1]:
types.tex(,2110) @expansion{}    1
types.tex(,2111) @expansion{} [2]:
types.tex(,2112) @expansion{}    2
types.tex(,2113) @expansion{} [3]:
types.tex(,2114) @expansion{}    3
types.tex(,2115) @c end example list_expressions types.doc:1778
types.tex(,2116) @end smallexample
types.tex(,2117) 
types.tex(,2118) @c ------------------------------
types.tex(,2119) @node list operations, list related functions, list expressions, list
types.tex(,2120) @subsection list operations
types.tex(,2121) @cindex list operations
types.tex(,2122) 
types.tex(,2123) @table @asis
types.tex(,2124) @item @code{+}
types.tex(,2125) concatenation
types.tex(,2126) @item @code{delete}
types.tex(,2127) deletes one element from list, returns new list
types.tex(,2128) @item @code{insert}
types.tex(,2129) inserts or appends a new element to list, returns a new list
types.tex(,2130) @item list_expression @code{[} int_expression @code{]}
types.tex(,2131) is a list entry; the index 1 gives the first element.
types.tex(,2132) @end table
types.tex(,2133) 
types.tex(,2134) @*@strong{Example:}
types.tex(,2135) @smallexample
types.tex(,2136) @c reused example list_operations types.doc:1807 
types.tex(,2137)   list l1 = 1,"hello",list(-1,1);
types.tex(,2138)   list l2 = list(1,2,3);
types.tex(,2139)   l1 + l2;          // one new list
types.tex(,2140) @expansion{} [1]:
types.tex(,2141) @expansion{}    1
types.tex(,2142) @expansion{} [2]:
types.tex(,2143) @expansion{}    hello
types.tex(,2144) @expansion{} [3]:
types.tex(,2145) @expansion{}    [1]:
types.tex(,2146) @expansion{}       -1
types.tex(,2147) @expansion{}    [2]:
types.tex(,2148) @expansion{}       1
types.tex(,2149) @expansion{} [4]:
types.tex(,2150) @expansion{}    1
types.tex(,2151) @expansion{} [5]:
types.tex(,2152) @expansion{}    2
types.tex(,2153) @expansion{} [6]:
types.tex(,2154) @expansion{}    3
types.tex(,2155)   list l3 =_;
types.tex(,2156)   l1,l2;            // two lists
types.tex(,2157) @expansion{} [1]:
types.tex(,2158) @expansion{}    1
types.tex(,2159) @expansion{} [2]:
types.tex(,2160) @expansion{}    hello
types.tex(,2161) @expansion{} [3]:
types.tex(,2162) @expansion{}    [1]:
types.tex(,2163) @expansion{}       -1
types.tex(,2164) @expansion{}    [2]:
types.tex(,2165) @expansion{}       1
types.tex(,2166) @expansion{} [1]:
types.tex(,2167) @expansion{}    1
types.tex(,2168) @expansion{} [2]:
types.tex(,2169) @expansion{}    2
types.tex(,2170) @expansion{} [3]:
types.tex(,2171) @expansion{}    3
types.tex(,2172)   l2[2];
types.tex(,2173) @expansion{} 2
types.tex(,2174) @c end example list_operations types.doc:1807
types.tex(,2175) @end smallexample
types.tex(,2176) 
types.tex(,2177) @c ------------------------------
types.tex(,2178) @node list related functions,  , list operations, list
types.tex(,2179) @subsection list related functions
types.tex(,2180) @cindex list related functions
types.tex(,2181) 
types.tex(,2182) @table @code
types.tex(,2183) @item bareiss
types.tex(,2184) returns a list of a matrix (lower triangular) and
types.tex(,2185) of an intvec (permutations of columns, see @ref{bareiss})
types.tex(,2186) @item betti
types.tex(,2187) Betti numbers of a resolution (see @ref{betti})
types.tex(,2188) @item delete
types.tex(,2189) deletes an element from a list (see @ref{delete})
types.tex(,2190) @item facstd
types.tex(,2191) factorizing Groebner basis algorithm (see @ref{facstd})
types.tex(,2192) @item factorize
types.tex(,2193) list of factors of a polynomial (see @ref{factorize})
types.tex(,2194) @item insert
types.tex(,2195) inserts or appends a new element to a list (see @ref{insert})
types.tex(,2196) @item lres
types.tex(,2197) free resolution (see @ref{lres})
types.tex(,2198) @item minres
types.tex(,2199) minimize a free resolution (see @ref{minres})
types.tex(,2200) @item mres
types.tex(,2201) minimal free resolution of an ideal, resp.@: module w.r.t.
types.tex(,2202) a minimal set of generators of the first module (see @ref{mres})
types.tex(,2203) @item names
types.tex(,2204) list of all user-defined variable names (see @ref{names})
types.tex(,2205) @item res
types.tex(,2206) free resolution of an ideal, resp.@: module (see @ref{res})
types.tex(,2207) @item size
types.tex(,2208) number of entries (see @ref{size})
types.tex(,2209) @item sres
types.tex(,2210) free resolution of an ideal, resp.@: module, given by a standard base (see @ref{sres})
types.tex(,2211) @end table
types.tex(,2212) 
types.tex(,2213) 
types.tex(,2214) @c ---------------------------------------
types.tex(,2215) @node map, matrix, list, Data types
types.tex(,2216) @section map
types.tex(,2217) @cindex map
types.tex(,2218) 
types.tex(,2219) Maps are ring maps from a preimage ring into the basering.
types.tex(,2220) 
types.tex(,2221) @strong{Note:}
types.tex(,2222) @itemize @bullet
types.tex(,2223) @item
types.tex(,2224) the target of a map is @strong{ALWAYS} the actual basering
types.tex(,2225) @item
types.tex(,2226) the preimage ring is stored "by name", that means, maps can only be
types.tex(,2227) used in such contexts, where the name of the preimage ring can be
types.tex(,2228) resolved (i.e., there might be problems for rings/maps defined in
types.tex(,2229) subprocedures). See also @ref{Identifier resolution}, @ref{Names in
types.tex(,2230) procedures}.
types.tex(,2231) @end itemize
types.tex(,2232) 
types.tex(,2233) Maps between rings with different coefficient fields are
types.tex(,2234) possible and listed below.
types.tex(,2235) 
types.tex(,2236) Canonically realized are
types.tex(,2237) @itemize @bullet
types.tex(,2238) @item
types.tex(,2245) 
types.tex(,2246) @item
types.tex(,2253) 
types.tex(,2254) @item
types.tex(,2261) 
types.tex(,2262) @item
types.tex(,2269) 
types.tex(,2270) @item
types.tex(,2277) 
types.tex(,2278) @item
types.tex(,2285) 
types.tex(,2286) @item
types.tex(,2293) @end itemize
types.tex(,2294) 
types.tex(,2295) Possible are furthermore
types.tex(,2296) @itemize @bullet
types.tex(,2297) @item
types.tex(,2308) @item
types.tex(,2318) @item
types.tex(,2325) @end itemize
types.tex(,2326) 
types.tex(,2327) Finally, in Singular we allow the mapping from rings
types.tex(,2328) with coefficient field Q to rings whose ground fields
types.tex(,2329) have finite characteristic:
types.tex(,2330) 
types.tex(,2331) @itemize @bullet
types.tex(,2332) @item
types.tex(,2339) 
types.tex(,2340) @item
types.tex(,2347) @end itemize
types.tex(,2348) In these cases the denominator and the numerator
types.tex(,2349) of a number are mapped separately by the usual
types.tex(,2350) map from Z to Z/p, and the image of the number
types.tex(,2351) is built again afterwards by division. It is thus
types.tex(,2352) not allowed to map numbers whose denominator is
types.tex(,2353) divisible by the characteristic of the target
types.tex(,2354) ground field, or objects containing such numbers.
types.tex(,2355) We, therefore, strongly recommend using such
types.tex(,2356) maps only to map objects with integer coefficients.
types.tex(,2357) 
types.tex(,2358) 
types.tex(,2359) @menu
types.tex(,2360) * map declarations::
types.tex(,2361) * map expressions::
types.tex(,2362) * map operations::
types.tex(,2363) * fetch::
types.tex(,2364) * imap::
types.tex(,2365) * subst::
types.tex(,2366) @end menu
types.tex(,2370) 
types.tex(,2371) @c ------------------------------
types.tex(,2372) @node map declarations, map expressions, map, map
types.tex(,2373) @subsection map declarations
types.tex(,2374) @cindex map declarations
types.tex(,2375) 
types.tex(,2376) @table @strong
types.tex(,2377) @item Syntax:
types.tex(,2378) @code{map} name @code{=} preimage_ring_name @code{,} ideal_expression @code{;}
types.tex(,2379) @*@code{map} name @code{=} preimage_ring_name @code{,} list_of_poly_and_ideal_expressions @code{;}
types.tex(,2380) @*@code{map} name @code{=} map_expression @code{;}
types.tex(,2381) 
types.tex(,2382) @item Purpose:
types.tex(,2383) defines a ring map from preimage_ring to basering.
types.tex(,2384) @* Maps the variables of the preimage ring to the generators of the ideal.
types.tex(,2385) If the ideal contains less elements than variables in the
types.tex(,2386) preimage_ring the remaining variables are mapped to 0, if the ideal contains
types.tex(,2387) more elements these are ignored.
types.tex(,2388) The image ring is always the actual basering.
types.tex(,2389) For the mapping of coefficients from different fields see @ref{map}.
types.tex(,2390) 
types.tex(,2391) @item Default:
types.tex(,2392) none
types.tex(,2393) 
types.tex(,2394) @item Note:
types.tex(,2395) There are standard mappings for maps which are close to the identity
types.tex(,2396) map: @code{fetch} and @code{imap}.
types.tex(,2397) 
types.tex(,2398) The name of a map serves as the function which maps objects from the
types.tex(,2399) preimage_ring into the basering.  These objects must be defined
types.tex(,2400) by names (no evaluation in the preimage ring is possible).
types.tex(,2401) 
types.tex(,2402) @item Example:
types.tex(,2403) @smallexample
types.tex(,2404) @c reused example map_declarations types.doc:2044 
types.tex(,2405)   ring r1=32003,(x,y,z),dp;
types.tex(,2406)   ideal i=x,y,z;
types.tex(,2407)   ring r2=32003,(a,b),dp;
types.tex(,2408)   map f=r1,a,b,a+b;
types.tex(,2409)   // maps from r1 to r2,
types.tex(,2410)   // x -> a
types.tex(,2411)   // y -> b
types.tex(,2412)   // z -> a+b
types.tex(,2413)   f(i);
types.tex(,2414) @expansion{} _[1]=a
types.tex(,2415) @expansion{} _[2]=b
types.tex(,2416) @expansion{} _[3]=a+b
types.tex(,2417)   // operations like f(i[1]) or f(i*i) are not allowed
types.tex(,2418)   ideal i=f(i);
types.tex(,2419)   // objects in different rings may have the same name
types.tex(,2420)   map g   = r2,a2,b2;
types.tex(,2421)   map phi = g(f);
types.tex(,2422)   // composition of map f and g
types.tex(,2423)   // maps from r1 to r2,
types.tex(,2424)   // x -> a2
types.tex(,2425)   // y -> b2
types.tex(,2426)   // z -> a2+b2
types.tex(,2427)   phi(i);
types.tex(,2428) @expansion{} _[1]=a2
types.tex(,2429) @expansion{} _[2]=b2
types.tex(,2430) @expansion{} _[3]=a2+b2
types.tex(,2431) @c end example map_declarations types.doc:2044
types.tex(,2432) @end smallexample
types.tex(,2433) @end table
types.tex(,2434) 
types.tex(,2435) @c inserted refs from types.doc:2069
types.tex(,2454) @c end inserted refs from types.doc:2069
types.tex(,2455) 
types.tex(,2456) @c ------------------------------
types.tex(,2457) @node map expressions, map operations, map declarations, map
types.tex(,2458) @subsection map expressions
types.tex(,2459) @cindex map expressions
types.tex(,2460) 
types.tex(,2461) A map expression is:
types.tex(,2462) @enumerate
types.tex(,2463) @item
types.tex(,2464) an identifier of type map
types.tex(,2465) @item
types.tex(,2466) a function returning map
types.tex(,2467) @item
types.tex(,2468) map expressions combined by composition using parentheses (@code{(}, @code{)})
types.tex(,2469) @end enumerate
types.tex(,2470) 
types.tex(,2471) @c ------------------------------
types.tex(,2472) @node map operations,  , map expressions, map
types.tex(,2473) @subsection map operations
types.tex(,2474) 
types.tex(,2475) @cindex map operations
types.tex(,2476) 
types.tex(,2477) @table @asis
types.tex(,2478) @item @code{( )}
types.tex(,2479) composition of maps. If, for example, @code{f} and @code{g} are maps,
types.tex(,2480) then @code{f(g)} is a map expression giving the composition of @code{f}
types.tex(,2481) and @code{g}.
types.tex(,2482) 
types.tex(,2483) @item map_expression @code{[} int_expressions @code{]}
types.tex(,2484) is a map entry (the image of the corresponding variable)
types.tex(,2485) @end table
types.tex(,2486) 
types.tex(,2487) @*@strong{Example:}
types.tex(,2488) @smallexample
types.tex(,2489) @c reused example map_operations types.doc:2107 
types.tex(,2490)   ring r=0,(x,y),dp;
types.tex(,2491)   map f=r,y,x;    // the map f permutes the variables
types.tex(,2492)   f;
types.tex(,2493) @expansion{} f[1]=y
types.tex(,2494) @expansion{} f[2]=x
types.tex(,2495)   poly p=x+2y3;
types.tex(,2496)   f(p);
types.tex(,2497) @expansion{} 2x3+y
types.tex(,2498)   map g=f(f);    // the map g defined as  f^2 is the identity
types.tex(,2499)   g;
types.tex(,2500) @expansion{} g[1]=x
types.tex(,2501) @expansion{} g[2]=y
types.tex(,2502)   g(p) == p;
types.tex(,2503) @expansion{} 1
types.tex(,2504) @c end example map_operations types.doc:2107
types.tex(,2505) @end smallexample
types.tex(,2506) 
types.tex(,2507) @c ---------------------------------------
types.tex(,2508) @node matrix, module, map, Data types
types.tex(,2509) @section matrix
types.tex(,2510) @cindex matrix
types.tex(,2511) 
types.tex(,2512) Objects of type matrix are matrices with polynomial entries.
types.tex(,2513) Like polynomials they can
types.tex(,2514) only be defined or accessed with respect to a basering. In order to
types.tex(,2515) compute with matrices having integer or rational entries define a ring
types.tex(,2516) with characteristic 0 and at least one variable.
types.tex(,2517) 
types.tex(,2518) A matrix can be multiplied by and added to a poly; in this case the
types.tex(,2519) poly is converted into a matrix of the right size with the poly on the
types.tex(,2520) diagonal.
types.tex(,2521) 
types.tex(,2522) If A is a matrix then the assignment @code{module M=A;} or @code{module
types.tex(,2523) M=module(A);} creates a module generated by the columns of A.  Note that
types.tex(,2524) the trailing zero columns of A may be deleted by module operations with
types.tex(,2525) M.
types.tex(,2526) 
types.tex(,2527) @menu
types.tex(,2528) * matrix declarations::
types.tex(,2529) * matrix expressions::
types.tex(,2530) * matrix type cast::
types.tex(,2531) * matrix operations::
types.tex(,2532) * matrix related functions::
types.tex(,2533) @end menu
types.tex(,2534) 
types.tex(,2535) @c ------------------------------
types.tex(,2536) @node matrix declarations, matrix expressions, matrix, matrix
types.tex(,2537) @subsection matrix declarations
types.tex(,2538) @cindex matrix declarations
types.tex(,2539) 
types.tex(,2540) @table @strong
types.tex(,2541) @item Syntax:
types.tex(,2542) @code{matrix} name@code{[}rows@code{][}cols@code{] =} list_of_poly_expressions @code{;}
types.tex(,2543) @*@code{matrix} name = matrix_expression @code{;}
types.tex(,2544) 
types.tex(,2545) @item Purpose:
types.tex(,2546) defines a matrix (of polynomials).
types.tex(,2547) 
types.tex(,2548) The given poly_list fills up the matrix beginning with the first row
types.tex(,2549) from the left to the right, then the second row and so on.
types.tex(,2550) If the poly_list contains less than rows*cols elements,
types.tex(,2551) the matrix is filled up with zeros; if it contains more
types.tex(,2552) elements, then only the first rows*cols elements are used.
types.tex(,2553) If the right-hand side is a matrix expression
types.tex(,2554) the matrix on the left-hand side gets the same size as the right-hand side,
types.tex(,2555) otherwise the size is determined by the left-hand side.
types.tex(,2556) If the size is omitted a 1x1 matrix is created.
types.tex(,2557) 
types.tex(,2558) @item Default:
types.tex(,2559) 0 (1 x 1 matrix)
types.tex(,2560) 
types.tex(,2561) @item Example:
types.tex(,2562) @smallexample
types.tex(,2563) @c reused example matrix_declarations types.doc:2175 
types.tex(,2564)   int ro = 3;
types.tex(,2565)   ring r = 32003,(x,y,z),dp;
types.tex(,2566)   poly f=xyz;
types.tex(,2567)   poly g=z*f;
types.tex(,2568)   ideal i=f,g,g^2;
types.tex(,2569)   matrix m[ro][3] = x3y4, 0, i, f ; // a 3 x 3 matrix
types.tex(,2570)   m;
types.tex(,2571) @expansion{} m[1,1]=x3y4
types.tex(,2572) @expansion{} m[1,2]=0
types.tex(,2573) @expansion{} m[1,3]=xyz
types.tex(,2574) @expansion{} m[2,1]=xyz2
types.tex(,2575) @expansion{} m[2,2]=x2y2z4
types.tex(,2576) @expansion{} m[2,3]=xyz
types.tex(,2577) @expansion{} m[3,1]=0
types.tex(,2578) @expansion{} m[3,2]=0
types.tex(,2579) @expansion{} m[3,3]=0
types.tex(,2580)   print(m);
types.tex(,2581) @expansion{} x3y4,0,     xyz,
types.tex(,2582) @expansion{} xyz2,x2y2z4,xyz,
types.tex(,2583) @expansion{} 0,   0,     0   
types.tex(,2584)   matrix A;   // the 1 x 1 zero matrix
types.tex(,2585)   matrix B[2][2] = m[1..2, 2..3]; //defines a submatrix
types.tex(,2586)   print(B);
types.tex(,2587) @expansion{} 0,     xyz,
types.tex(,2588) @expansion{} x2y2z4,xyz 
types.tex(,2589)   matrix C=m; // defines C as a 3 x 3 matrix equal to m
types.tex(,2590)   print(C);
types.tex(,2591) @expansion{} x3y4,0,     xyz,
types.tex(,2592) @expansion{} xyz2,x2y2z4,xyz,
types.tex(,2593) @expansion{} 0,   0,     0   
types.tex(,2594) @c end example matrix_declarations types.doc:2175
types.tex(,2595) @end smallexample
types.tex(,2596) @end table
types.tex(,2597) 
types.tex(,2598) @c ------------------------------
types.tex(,2599) @node matrix expressions, matrix type cast, matrix declarations, matrix
types.tex(,2600) @subsection matrix expressions
types.tex(,2601) @cindex matrix expressions
types.tex(,2602) 
types.tex(,2603) A matrix expression is:
types.tex(,2604) @enumerate
types.tex(,2605) @item
types.tex(,2606) an identifier of type matrix
types.tex(,2607) @item
types.tex(,2608) a function returning matrix
types.tex(,2609) @item
types.tex(,2610) matrix expressions combined by the arithmetic operations
types.tex(,2611) @code{+}, @code{-} or @code{*}
types.tex(,2612) @item
types.tex(,2613) a type cast to matrix (@pxref{matrix type cast})
types.tex(,2614) @end enumerate
types.tex(,2615) 
types.tex(,2616) @*@strong{Example:}
types.tex(,2617) @smallexample
types.tex(,2618) @c reused example matrix_expressions types.doc:2213 
types.tex(,2619)   ring r=0,(x,y),dp;
types.tex(,2620)   poly f= x3y2 + 2x2y2 +2;
types.tex(,2621)   matrix H = jacob(jacob(f));    // the Hessian of f
types.tex(,2622)   matrix mc = coef(f,y);
types.tex(,2623)   print(mc);
types.tex(,2624) @expansion{} y2,    1,
types.tex(,2625) @expansion{} x3+2x2,2 
types.tex(,2626)   module MD = [x+y,1,x],[x+y,0,y];
types.tex(,2627)   matrix M = MD;
types.tex(,2628)   print(M);
types.tex(,2629) @expansion{} x+y,x+y,
types.tex(,2630) @expansion{} 1,  0,  
types.tex(,2631) @expansion{} x,  y   
types.tex(,2632) @c end example matrix_expressions types.doc:2213
types.tex(,2633) @end smallexample
types.tex(,2634) 
types.tex(,2635) @c ------------------------------
types.tex(,2636) @node matrix type cast,  matrix operations, matrix expressions, matrix
types.tex(,2637) @subsection matrix type cast
types.tex(,2638) @cindex matrix type cast
types.tex(,2639) @table @code
types.tex(,2640) @item @strong{Syntax:}
types.tex(,2641) @code{matrix (} expression @code{)}
types.tex(,2642) @*@code{matrix (} expression, int_n, int_m  @code{)}
types.tex(,2643) @item @strong{Type:}
types.tex(,2644) matrix
types.tex(,2645) @item @strong{Purpose:}
types.tex(,2646) Converts expression to a matrix, where expression must be of type int,
types.tex(,2647) intmat, intvec, number, poly, ideal, vector, module, or matrix. If
types.tex(,2648) int_n and int_m are supplied, then they specify the dimension of the
types.tex(,2649) matrix. Otherwise, the size (resp.@: dimensions) of the matrix
types.tex(,2650) are determined  by the size (resp.@: dimensions) of the
types.tex(,2651) expression.
types.tex(,2652) @item @strong{Example:}
types.tex(,2653) @smallexample
types.tex(,2654) @c reused example matrix_type_cast types.doc:2244 
types.tex(,2655)   ring r=32003,(x,y,z),dp;
types.tex(,2656)   matrix(x);
types.tex(,2657) @expansion{} _[1,1]=x
types.tex(,2658)   matrix(x, 1, 2);
types.tex(,2659) @expansion{} _[1,1]=x
types.tex(,2660) @expansion{} _[1,2]=0
types.tex(,2661)   matrix(intmat(intvec(1,2,3,4), 2, 2));
types.tex(,2662) @expansion{} _[1,1]=1
types.tex(,2663) @expansion{} _[1,2]=2
types.tex(,2664) @expansion{} _[2,1]=3
types.tex(,2665) @expansion{} _[2,2]=4
types.tex(,2666)   matrix(_, 2, 3);
types.tex(,2667) @expansion{} _[1,1]=1
types.tex(,2668) @expansion{} _[1,2]=2
types.tex(,2669) @expansion{} _[1,3]=0
types.tex(,2670) @expansion{} _[2,1]=3
types.tex(,2671) @expansion{} _[2,2]=4
types.tex(,2672) @expansion{} _[2,3]=0
types.tex(,2673)   matrix(_, 2, 1);
types.tex(,2674) @expansion{} _[1,1]=1
types.tex(,2675) @expansion{} _[2,1]=3
types.tex(,2676) @c end example matrix_type_cast types.doc:2244
types.tex(,2677) @end smallexample
types.tex(,2678) @end table
types.tex(,2679) @c inserted refs from types.doc:2254
types.tex(,2694) @c end inserted refs from types.doc:2254
types.tex(,2695) @c ------------------------------
types.tex(,2696) @node matrix operations, matrix related functions, matrix type cast, matrix
types.tex(,2697) @subsection matrix operations
types.tex(,2698) @cindex matrix operations
types.tex(,2699) 
types.tex(,2700) @table @asis
types.tex(,2701) @item @code{+}
types.tex(,2702) addition with matrix or poly; the poly is converted into a diagonal
types.tex(,2703) matrix
types.tex(,2704) 
types.tex(,2705) @item @code{-}
types.tex(,2706) negation or subtraction with matrix or poly; the poly is converted into
types.tex(,2707) a diagonal matrix
types.tex(,2708) 
types.tex(,2709) @item @code{*}
types.tex(,2710) multiplication with matrix or poly; the poly is converted into a
types.tex(,2711) diagonal matrix
types.tex(,2712) 
types.tex(,2713) @item @code{/}
types.tex(,2714) division by poly
types.tex(,2715) 
types.tex(,2716) @item @code{==}, @code{<>}, @code{!=}
types.tex(,2717) comparison
types.tex(,2718) 
types.tex(,2719) @item matrix_expression @code{[} int_expression@code{,} int_expression @code{]}
types.tex(,2720) is a matrix entry, where the first index indicates the row and the
types.tex(,2721) second the column
types.tex(,2722) @end table
types.tex(,2723) 
types.tex(,2724) @*@strong{Example:}
types.tex(,2725) @smallexample
types.tex(,2726) @c reused example matrix_operations types.doc:2291 
types.tex(,2727)   ring r=32003,x,dp;
types.tex(,2728)   matrix A[3][3] = 1,3,2,5,0,3,2,4,5; // define a matrix
types.tex(,2729)   print(A); // nice printing of small matrices
types.tex(,2730) @expansion{} 1,3,2,
types.tex(,2731) @expansion{} 5,0,3,
types.tex(,2732) @expansion{} 2,4,5 
types.tex(,2733)   A[2,3];   // matrix entry
types.tex(,2734) @expansion{} 3
types.tex(,2735)   A[2,3] = A[2,3] + 1; // change entry
types.tex(,2736)   A[2,1..3] = 1,2,3;   // change 2nd row
types.tex(,2737)   print(A);
types.tex(,2738) @expansion{} 1,3,2,
types.tex(,2739) @expansion{} 1,2,3,
types.tex(,2740) @expansion{} 2,4,5 
types.tex(,2741)   matrix E[3][3]; E = E + 1;  // the unit matrix
types.tex(,2742)   matrix B =x*E - A;
types.tex(,2743)   print(B);
types.tex(,2744) @expansion{} x-1,-3, -2,
types.tex(,2745) @expansion{} -1, x-2,-3,
types.tex(,2746) @expansion{} -2, -4, x-5
types.tex(,2747)   det(B);        // the characteristic polynomial of A
types.tex(,2748) @expansion{} x3-8x2-2x-1
types.tex(,2749)   A*A*A - 8 * A*A - 2*A == E;  // Cayley-Hamilton
types.tex(,2750) @expansion{} 1
types.tex(,2751)   vector v =[x,-1,x2];
types.tex(,2752)   A*v; // multiplication of matrix and vector
types.tex(,2753) @expansion{} _[1,1]=2x2+x-3
types.tex(,2754) @expansion{} _[2,1]=3x2+x-2
types.tex(,2755) @expansion{} _[3,1]=5x2+2x-4
types.tex(,2756)   matrix m[2][2]=1,2,3;
types.tex(,2757)   print(m-transpose(m));
types.tex(,2758) @expansion{} 0,-1,
types.tex(,2759) @expansion{} 1,0  
types.tex(,2760) @c end example matrix_operations types.doc:2291
types.tex(,2761) @end smallexample
types.tex(,2762) 
types.tex(,2763) @c ------------------------------
types.tex(,2764) @node matrix related functions,  , matrix operations, matrix
types.tex(,2765) @subsection matrix related functions
types.tex(,2766) @cindex matrix related functions
types.tex(,2767) 
types.tex(,2768) @table @code
types.tex(,2769) @item bareiss
types.tex(,2770) Gauss-Bareiss algorithm (see @ref{bareiss})
types.tex(,2771) @item coef
types.tex(,2772) matrix of coefficients and monomials (see @ref{coef})
types.tex(,2773) @item coeffs
types.tex(,2774) matrix of coefficients (see @ref{coeffs})
types.tex(,2775) @item det
types.tex(,2776) determinant (see @ref{det})
types.tex(,2777) @item diff
types.tex(,2778) partial derivative (see @ref{diff})
types.tex(,2779) @item jacob
types.tex(,2780) Jacobi matrix (see @ref{jacob})
types.tex(,2781) @item koszul
types.tex(,2782) Koszul matrix (see @ref{koszul})
types.tex(,2783) @item lift
types.tex(,2784) lift-matrix (see @ref{lift})
types.tex(,2785) @item liftstd
types.tex(,2786) standard basis and transformation matrix computation (see @ref{liftstd})
types.tex(,2787) @item minor
types.tex(,2788) set of minors of a matrix (see @ref{minor})
types.tex(,2789) @item ncols
types.tex(,2790) number of columns (see @ref{ncols})
types.tex(,2791) @item nrows
types.tex(,2792) number of rows (see @ref{nrows})
types.tex(,2793) @item print
types.tex(,2794) nice print format (see @ref{print})
types.tex(,2795) @item size
types.tex(,2796) number of matrix entries (see @ref{size})
types.tex(,2797) @item subst
types.tex(,2798) substitute a ring variable (see @ref{subst})
types.tex(,2799) @item trace
types.tex(,2800) trace of a matrix (see @ref{trace})
types.tex(,2801) @item transpose
types.tex(,2802) transpose a matrix (see @ref{transpose})
types.tex(,2803) @item wedge
types.tex(,2804) wedge product (see @ref{wedge})
types.tex(,2805) @end table
types.tex(,2806) 
types.tex(,2807) See also the library @ref{matrix_lib}, which contains more
types.tex(,2808) matrix-related functions.
types.tex(,2809) 
types.tex(,2810) @c @*@strong{Example:}
types.tex(,2811) @c @example
types.tex(,2812) @c @end example
types.tex(,2813) 
types.tex(,2814) @c ---------------------------------------
types.tex(,2815) @node module, number, matrix, Data types
types.tex(,2816) @section module
types.tex(,2817) @cindex module
types.tex(,2818) 
types.tex(,2819) Modules are submodules of a free module over the basering with basis
types.tex(,2820) @code{gen(1)}, @code{gen(2)}, @dots{} .
types.tex(,2821) They are represented by lists of vectors which generate the submodule.
types.tex(,2822) Like vectors they
types.tex(,2823) can only be defined or accessed with respect to a basering.
types.tex(,2824) If 
types.tex(,2831)  is a submodule of
types.tex(,2838) 
types.tex(,2845)  the basering, generated by vectors
types.tex(,2852) may be considered as the generators of relations of
types.tex(,2859) between the canonical generators @code{gen(1)},@dots{},@code{gen(n)}.
types.tex(,2860) Hence any finitely generated 
types.tex(,2867) -module can be represented in @sc{Singular}
types.tex(,2868) by its module of relations. The assignments
types.tex(,2869) @code{module M=v1,...,vk; matrix A=M;}
types.tex(,2870) create the presentation matrix of size
types.tex(,2877)  for
types.tex(,2884) i.e., the columns of A are the vectors
types.tex(,2891) which generate M (cf. @ref{Representation of mathematical objects}).
types.tex(,2892) 
types.tex(,2893) @menu
types.tex(,2894) * module declarations::
types.tex(,2895) * module expressions::
types.tex(,2896) * module operations::
types.tex(,2897) * module related functions::
types.tex(,2898) @end menu
types.tex(,2899) 
types.tex(,2900) @c ------------------------------
types.tex(,2901) @node module declarations, module expressions, module, module
types.tex(,2902) @subsection module declarations
types.tex(,2903) @cindex module declarations
types.tex(,2904) 
types.tex(,2905) @table @strong
types.tex(,2906) @item Syntax:
types.tex(,2907) @code{module} name @code{=} list_of_vector_expressions @code{;}
types.tex(,2908) @*@code{module} name @code{=} module_expression @code{;}
types.tex(,2909) 
types.tex(,2910) @item Purpose:
types.tex(,2911) defines a module.
types.tex(,2912) 
types.tex(,2913) @item Default:
types.tex(,2914) [0]
types.tex(,2915) 
types.tex(,2916) @item Example:
types.tex(,2917) @smallexample
types.tex(,2918) @c reused example module_declarations types.doc:2445 
types.tex(,2919)   ring r=0,(x,y,z),(c,dp);
types.tex(,2920)   vector s1 = [x2,y3,z];
types.tex(,2921)   vector s2 = [xy,1,0];
types.tex(,2922)   vector s3 = [0,x2-y2,z];
types.tex(,2923)   poly   f  = xyz;
types.tex(,2924)   module m = s1, s2-s1,f*(s3-s1);
types.tex(,2925)   m;
types.tex(,2926) @expansion{} m[1]=[x2,y3,z]
types.tex(,2927) @expansion{} m[2]=[-x2+xy,-y3+1,-z]
types.tex(,2928) @expansion{} m[3]=[-x3yz,-xy4z+x3yz-xy3z]
types.tex(,2929)   // show m in matrix format (columns generate m)
types.tex(,2930)   print(m);
types.tex(,2931) @expansion{} x2,-x2+xy,-x3yz,          
types.tex(,2932) @expansion{} y3,-y3+1, -xy4z+x3yz-xy3z,
types.tex(,2933) @expansion{} z, -z,    0               
types.tex(,2934) @c end example module_declarations types.doc:2445
types.tex(,2935) @end smallexample
types.tex(,2936) @end table
types.tex(,2937) 
types.tex(,2938) @c ------------------------------
types.tex(,2939) @node module expressions, module operations, module declarations, module
types.tex(,2940) @subsection module expressions
types.tex(,2941) @cindex module expressions
types.tex(,2942) 
types.tex(,2943) A module expression is:
types.tex(,2944) @enumerate
types.tex(,2945) @item
types.tex(,2946) an identifier of type module
types.tex(,2947) @item
types.tex(,2948) a function returning module
types.tex(,2949) @item
types.tex(,2950) module expressions combined by the arithmetic operation @code{+}
types.tex(,2951) @item
types.tex(,2952) multiplication of a module expression with an ideal or a poly expression: @code{*}
types.tex(,2953) @item
types.tex(,2954) a type cast to module
types.tex(,2955) @end enumerate
types.tex(,2956) 
types.tex(,2957) @c inserted refs from types.doc:2478
types.tex(,2974) @c end inserted refs from types.doc:2478
types.tex(,2975) 
types.tex(,2976) @c @*@strong{Example:}
types.tex(,2977) @c @example
types.tex(,2978) @c @c example
types.tex(,2979) @c @c example
types.tex(,2980) @c @end example
types.tex(,2981) 
types.tex(,2982) @c ------------------------------
types.tex(,2983) @node module operations, module related functions, module expressions, module
types.tex(,2984) @subsection module operations
types.tex(,2985) @cindex module operations
types.tex(,2986) 
types.tex(,2987) @table @asis
types.tex(,2988) @item @code{+}
types.tex(,2989) addition (concatenation of the generators and simplification)
types.tex(,2990) 
types.tex(,2991) @item @code{*}
types.tex(,2992) multiplication with ideal or poly, but not `module` * `module`
types.tex(,2993) 
types.tex(,2994) @item module_expression @code{[} int_expression @code{,} int_expression @code{]}
types.tex(,2995) is a module entry, where the first index indicates the row and
types.tex(,2996) the second the column
types.tex(,2997) 
types.tex(,2998) @item module_expressions @code{[} int_expression @code{]}
types.tex(,2999) is a vector, where the index indicates the column
types.tex(,3000) @end table
types.tex(,3001) 
types.tex(,3002) @*@strong{Example:}
types.tex(,3003) @smallexample
types.tex(,3004) @c reused example module_operations types.doc:2514 
types.tex(,3005)   ring r=0,(x,y,z),dp;
types.tex(,3006)   module m=[x,y],[0,0,z];
types.tex(,3007)   print(m*(x+y));
types.tex(,3008) @expansion{} x2+xy,0,   
types.tex(,3009) @expansion{} xy+y2,0,   
types.tex(,3010) @expansion{} 0,    xz+yz
types.tex(,3011) @c end example module_operations types.doc:2514
types.tex(,3012) @end smallexample
types.tex(,3013) 
types.tex(,3014) @c ------------------------------
types.tex(,3015) @node module related functions,  , module operations, module
types.tex(,3016) @subsection module related functions
types.tex(,3017) @cindex module related functions
types.tex(,3018) 
types.tex(,3019) @table @code
types.tex(,3020) @item coeffs
types.tex(,3021) matrix of coefficients (see @ref{coeffs})
types.tex(,3022) @item degree
types.tex(,3023) multiplicity, dimension and codimension of the module of leading terms (see @ref{degree})
types.tex(,3024) @item diff
types.tex(,3025) partial derivative (see @ref{diff})
types.tex(,3026) @item dim
types.tex(,3027) Krull dimension of free module over the basering modulo the module of leading terms (see @ref{dim})
types.tex(,3028) @item eliminate
types.tex(,3029) elimination of variables (see @ref{eliminate})
types.tex(,3030) @item freemodule
types.tex(,3031) the free module of given rank (see @ref{freemodule})
types.tex(,3032) @item groebner
types.tex(,3033) Groebner basis computation (a wrapper around @code{std,stdhilb,stdfglm},...)
types.tex(,3034) (see @ref{groebner})
types.tex(,3035) @item hilb
types.tex(,3036) Hilbert function of a standard basis (see @ref{hilb})
types.tex(,3037) @item homog
types.tex(,3038) homogenization with respect to a variable (see @ref{homog})
types.tex(,3039) @item interred
types.tex(,3040) interreduction of a module (see @ref{interred})
types.tex(,3041) @item intersect
types.tex(,3042) module intersection (see @ref{intersect})
types.tex(,3043) @item jet
types.tex(,3044) Taylor series up to a given order (see @ref{jet})
types.tex(,3045) @item kbase
types.tex(,3046) vector space basis of free module over the basering modulo the module of
types.tex(,3047) leading terms (see @ref{kbase})
types.tex(,3048) @item lead
types.tex(,3049) initial module (see @ref{lead})
types.tex(,3050) @item lift
types.tex(,3051) lift-matrix (see @ref{lift})
types.tex(,3052) @item liftstd
types.tex(,3053) standard basis and transformation matrix computation (see @ref{liftstd})
types.tex(,3054) @item lres
types.tex(,3055) free resolution (see @ref{lres})
types.tex(,3056) @item minbase
types.tex(,3057) minimal generating set of a homogeneous ideal, resp.@: module, or an ideal, resp.@: module,
types.tex(,3058) over a local ring
types.tex(,3059) @item modulo
types.tex(,3060) represents
types.tex(,3067) (see @ref{modulo})
types.tex(,3068) @item mres
types.tex(,3069) minimal free resolution of an ideal resp.@: module w.r.t. a minimal set of generators of the given module
types.tex(,3070) (see @ref{mres})
types.tex(,3071) @item mult
types.tex(,3072) multiplicity, resp.@: degree, of the module of leading terms (see @ref{mult})
types.tex(,3073) @item ncols
types.tex(,3074) number of columns (see @ref{ncols})
types.tex(,3075) @item nrows
types.tex(,3076) number of rows (see @ref{nrows})
types.tex(,3077) @item print
types.tex(,3078) nice print format (see @ref{print})
types.tex(,3079) @item prune
types.tex(,3080) minimize the embedding into a free module (see @ref{prune})
types.tex(,3081) @item qhweight
types.tex(,3082) quasihomogeneous weights of an ideal, resp.@: module (see @ref{qhweight})
types.tex(,3083) @item quotient
types.tex(,3084) module quotient (see @ref{quotient})
types.tex(,3085) @item reduce
types.tex(,3086) normalform with respect to a standard basis (see @ref{reduce})
types.tex(,3087) @item res
types.tex(,3088) free resolution of an ideal, resp.@: module, but not changing the given ideal, resp.@: module
types.tex(,3089) (see @ref{res})
types.tex(,3090) @item simplify
types.tex(,3091) simplify a set of vectors (see @ref{simplify})
types.tex(,3092) @item size
types.tex(,3093) number of non-zero generators (see @ref{size})
types.tex(,3094) @item sortvec
types.tex(,3095) permutation for sorting ideals/modules (see @ref{sortvec})
types.tex(,3096) @item sres
types.tex(,3097) free resolution of a standard basis (see @ref{sres})
types.tex(,3098) @item std
types.tex(,3099) standard basis computation (see @ref{std}, @ref{liftstd})
types.tex(,3100) @item subst
types.tex(,3101) substitute a ring variable (see @ref{subst})
types.tex(,3102) @item syz
types.tex(,3103) computation of the first syzygy module (see @ref{syz})
types.tex(,3104) @item vdim
types.tex(,3105) vector space dimension of free module over the basering modulo module
types.tex(,3106) of leading terms (see @ref{vdim})
types.tex(,3107) @item weight
types.tex(,3108) "optimal" weights (see @ref{weight})
types.tex(,3109) @end table
types.tex(,3110) 
types.tex(,3111) @c @*@strong{Example:}
types.tex(,3112) @c @example
types.tex(,3113) @c @end example
types.tex(,3114) 
types.tex(,3115) @c ---------------------------------------
types.tex(,3120) @node number, poly, module, Data types
types.tex(,3122) @section number
types.tex(,3123) @cindex number
types.tex(,3124) @cindex coefficient field
types.tex(,3125) @cindex ground field
types.tex(,3126) @cindex field
types.tex(,3127) @cindex galois field
types.tex(,3128) @cindex finite field
types.tex(,3129) @cindex parameter, as numbers
types.tex(,3130) 
types.tex(,3131) Numbers are elements from the coefficient field (or ground field).
types.tex(,3132) They can only be defined or accessed with respect to a basering
types.tex(,3133) which determines the coefficient field. See @ref{ring declarations} for
types.tex(,3134) declarations of coefficient fields.
types.tex(,3135) 
types.tex(,3136) @strong{Warning:} Beware of the special meaning of the letter @code{e}
types.tex(,3137) (immediately following a sequence of digits) if the field is real (or complex).
types.tex(,3138) See @ref{number operations}, @ref{Miscellaneous oddities}.
types.tex(,3139) 
types.tex(,3140) @menu
types.tex(,3141) * number declarations::
types.tex(,3142) * number expressions::
types.tex(,3143) * number operations::
types.tex(,3144) * number related functions::
types.tex(,3145) @end menu
types.tex(,3146) 
types.tex(,3147) @c ------------------------------
types.tex(,3148) @node number declarations, number expressions, number, number
types.tex(,3149) @subsection number declarations
types.tex(,3150) @cindex number declarations
types.tex(,3151) 
types.tex(,3152) @table @strong
types.tex(,3153) @item Syntax:
types.tex(,3154) @code{number} name @code{=} number_expression @code{;}
types.tex(,3155) 
types.tex(,3156) @item Purpose:
types.tex(,3157) defines a number.
types.tex(,3158) 
types.tex(,3159) @item Default:
types.tex(,3160) 0
types.tex(,3161) 
types.tex(,3162) @item Note:
types.tex(,3163) Numbers may only be declared w.r.t. the coefficient field of the current
types.tex(,3164) basering, i.e., a ring
types.tex(,3165) has to be defined prior to any number declaration. See @ref{Rings and
types.tex(,3166) orderings} for a list of the available coefficient fields.
types.tex(,3167) 
types.tex(,3168) @item Example:
types.tex(,3169) @smallexample
types.tex(,3170) @c reused example number_declarations types.doc:2677 
types.tex(,3171)   // finite field Z/p, p<= 32003
types.tex(,3172)   ring r = 32003,(x,y,z),dp;
types.tex(,3173)   number n = 4/6;
types.tex(,3174)   n;
types.tex(,3175) @expansion{} -10667
types.tex(,3176)   // finite field GF(p^n), p^n <= 32767
types.tex(,3177)   // z is a primitive root of the minimal polynomial
types.tex(,3178)   ring rg= (7^2,z),x,dp;
types.tex(,3179)   number n = 4/9+z;
types.tex(,3180)   n;
types.tex(,3181) @expansion{} z11
types.tex(,3182)   // the rational numbers
types.tex(,3183)   ring r0 = 0,x,dp;
types.tex(,3184)   number n = 4/6;
types.tex(,3185)   n;
types.tex(,3186) @expansion{} 2/3
types.tex(,3187)   // algebraic extensions of Z/p or Q
types.tex(,3188)   ring ra=(0,a),x,dp;
types.tex(,3189)   minpoly=a^2+1;
types.tex(,3190)   number n=a3+a2+2a-1;
types.tex(,3191)   n;
types.tex(,3192) @expansion{} (a-2)
types.tex(,3193)   a^2;
types.tex(,3194) @expansion{} -1
types.tex(,3195)   // transcedental extensions of Z/p or Q
types.tex(,3196)   ring rt=(0,a),x,dp;
types.tex(,3197)   number n=a3+a2+2a-1;
types.tex(,3198)   n;
types.tex(,3199) @expansion{} (a3+a2+2a-1)
types.tex(,3200)   a^2;
types.tex(,3201) @expansion{} (a2)
types.tex(,3202)   // machine floating point numbers, single precision
types.tex(,3203)   ring R_0=real,x,dp;
types.tex(,3204)   number n=4/6;
types.tex(,3205)   n;
types.tex(,3206) @expansion{} 6.667e-01
types.tex(,3207)   n=0.25e+2;
types.tex(,3208)   n;
types.tex(,3209) @expansion{} 2.500e+01
types.tex(,3210)   // floating point numbers, arbitrary prescribed precision
types.tex(,3211)   ring R_1=(real,50),x,dp;
types.tex(,3212)   number n=4.0/6;
types.tex(,3213)   n;
types.tex(,3214) @expansion{} 0.66666666666666666666666666666666666666666666666667
types.tex(,3215)   n=0.25e+2;
types.tex(,3216)   n;
types.tex(,3217) @expansion{} 25
types.tex(,3218)   // floating point complex numbers, arbitrary prescribed precision
types.tex(,3219)   // the third parameter gives the name of the imaginary unit
types.tex(,3220)   ring R_2=(complex,50,i),x,dp;
types.tex(,3221)   number n=4.0/6;
types.tex(,3222)   n;
types.tex(,3223) @expansion{} 0.66666666666666666666666666666666666666666666666667
types.tex(,3224)   n=0.25e+2*i+n;
types.tex(,3225)   n;
types.tex(,3226) @expansion{} (0.66666666666666666666666666666666666666666666666667+i*25)
types.tex(,3227) @c end example number_declarations types.doc:2677
types.tex(,3228) @end smallexample
types.tex(,3229) @end table
types.tex(,3230) 
types.tex(,3231) @c ------------------------------
types.tex(,3232) @node number expressions, number operations, number declarations, number
types.tex(,3233) @subsection number expressions
types.tex(,3234) @cindex number expressions
types.tex(,3235) 
types.tex(,3236) A number expression is:
types.tex(,3237) @enumerate
types.tex(,3238) @item
types.tex(,3239) a rational number (there are NO spaces allowed inside a rational number,
types.tex(,3240) see @ref{int expressions})
types.tex(,3241) @item
types.tex(,3242) a floating point number (if the coefficient field is @code{real}):
types.tex(,3243) @*<digits>@code{.}<digits>@code{e}<sign><digits>
types.tex(,3244) @item
types.tex(,3245) an identifier of type number
types.tex(,3246) @item
types.tex(,3247) a function returning number
types.tex(,3248) @item
types.tex(,3249) an int expression (see @ref{Type conversion and casting})
types.tex(,3250) @item
types.tex(,3251) number expressions combined by the arithmetic operations
types.tex(,3252) @code{+}, @code{-}, @code{*}, @code{/}, @code{^}, or @code{**}.
types.tex(,3253) @item
types.tex(,3254) a type cast to number
types.tex(,3255) @end enumerate
types.tex(,3256) 
types.tex(,3257) @*@strong{Example:}
types.tex(,3258) @smallexample
types.tex(,3259) @c reused example number_expressions types.doc:2753 
types.tex(,3260)   // the following expressions are in any ring int expressions
types.tex(,3261)   2 / 3;
types.tex(,3262) @expansion{} 0
types.tex(,3263)   4/ 8;
types.tex(,3264) @expansion{} 0
types.tex(,3265)   2 /2;   // the notation of / for div might change in the future
types.tex(,3266) @expansion{} 1
types.tex(,3267)   ring r0=0,x,dp;
types.tex(,3268)   2/3, 4/8, 2/2 ; // are numbers
types.tex(,3269) @expansion{} 2/3 1/2 1
types.tex(,3270) 
types.tex(,3271)   poly f = 2x2 +1;
types.tex(,3272)   leadcoef(f);
types.tex(,3273) @expansion{} 2
types.tex(,3274)   typeof(_);
types.tex(,3275) @expansion{} number
types.tex(,3276)   ring rr =real,x,dp;
types.tex(,3277)   1.7e-2; 1.7e+2; // are valid (but  1.7e2 not), if the field is `real`
types.tex(,3278) @expansion{} 1.700e-02
types.tex(,3279) @expansion{} 1.700e+02
types.tex(,3280)   ring rp = (31,t),x,dp;
types.tex(,3281)   2/3, 4/8, 2/2 ; // are numbers
types.tex(,3282) @expansion{} 11 -15 1
types.tex(,3283)   poly g = (3t2 +1)*x2 +1;
types.tex(,3284)   leadcoef(g);
types.tex(,3285) @expansion{} (3t2+1)
types.tex(,3286)   typeof(_);
types.tex(,3287) @expansion{} number
types.tex(,3288)   par(1);
types.tex(,3289) @expansion{} (t)
types.tex(,3290)   typeof(_);
types.tex(,3291) @expansion{} number
types.tex(,3292) @c end example number_expressions types.doc:2753
types.tex(,3293) @end smallexample
types.tex(,3294) @c inserted refs from types.doc:2775
types.tex(,3307) @c end inserted refs from types.doc:2775
types.tex(,3308) 
types.tex(,3309) @c ------------------------------
types.tex(,3310) @node number operations, number related functions, number expressions, number
types.tex(,3311) @subsection number operations
types.tex(,3312) @cindex number operations
types.tex(,3313) @cindex mod
types.tex(,3314) 
types.tex(,3315) @table @asis
types.tex(,3316) @item @code{+}
types.tex(,3317) addition
types.tex(,3318) @item @code{-}
types.tex(,3319) negation or subtraction
types.tex(,3320) @item @code{*}
types.tex(,3321) multiplication
types.tex(,3322) @item @code{/}
types.tex(,3323) division
types.tex(,3324) @item @code{^}, @code{**}
types.tex(,3325) power, exponentiation (by an integer)
types.tex(,3326) @item @code{<=, >=, ==, <>}
types.tex(,3327) comparison
types.tex(,3328) @item @code{mod}
types.tex(,3329) integer modulo (the remainder of the division @code{div}), always non-negative
types.tex(,3330) @end table
types.tex(,3331) 
types.tex(,3332) @strong{Note:} quotient and exponentiation is only recognized as a
types.tex(,3333) number expression if it is already a number, see @ref{Miscellaneous
types.tex(,3334) oddities}.
types.tex(,3335) @* For the behavior of comparison operators in rings with
types.tex(,3336) ground field different from real or the rational numbers, see @ref{boolean
types.tex(,3337) expressions}.
types.tex(,3338) 
types.tex(,3339) @*@strong{Example:}
types.tex(,3340) @smallexample
types.tex(,3341) @c reused example number_operations types.doc:2813 
types.tex(,3342)   ring r=0,x,dp;
types.tex(,3343)   number n = 1/2 +1/3;
types.tex(,3344)   n;
types.tex(,3345) @expansion{} 5/6
types.tex(,3346)   n/2;
types.tex(,3347) @expansion{} 5/12
types.tex(,3348)   1/2/3;
types.tex(,3349) @expansion{} 1/6
types.tex(,3350)   1/2 * 1/3;
types.tex(,3351) @expansion{} 1/6
types.tex(,3352)   n = 2;
types.tex(,3353)   n^-2;
types.tex(,3354) @expansion{} 1/4
types.tex(,3355)   // the following oddities appear here
types.tex(,3356)   2/(2+3);
types.tex(,3357) @expansion{} 0
types.tex(,3358)   number(2)/(2+3);
types.tex(,3359) @expansion{} 2/5
types.tex(,3360)   2^-2; // for int's exponent must be non-negative
types.tex(,3361) @expansion{}    ? exponent must be non-negative
types.tex(,3362) @expansion{}    ? error occurred in line 12: `  2^-2; // for int's exponent must be no\
types.tex(,3363)    n-negative`
types.tex(,3364)   number(2)^-2;
types.tex(,3365) @expansion{} 1/4
types.tex(,3366)   3/4>=2/5;
types.tex(,3367) @expansion{} 1
types.tex(,3368)   2/6==1/3;
types.tex(,3369) @expansion{} 1
types.tex(,3370) @c end example number_operations types.doc:2813
types.tex(,3371) @end smallexample
types.tex(,3372) 
types.tex(,3373) @c ------------------------------
types.tex(,3374) @node number related functions,  , number operations, number
types.tex(,3375) @subsection number related functions
types.tex(,3376) @cindex number related functions
types.tex(,3377) 
types.tex(,3378) @table @code
types.tex(,3379) @item cleardenom
types.tex(,3380) cancel denominators of numbers in poly and divide it by its content
types.tex(,3381) (see @ref{cleardenom})
types.tex(,3382) @item impart
types.tex(,3383) imaginary part of a complex number, 0 otherwise
types.tex(,3384) (see @ref{impart}, @ref{repart})
types.tex(,3385) @item numerator, denominator
types.tex(,3386) return the numerator/denominator of a rational number
types.tex(,3387) (see @ref{numerator}, @ref{denominator})
types.tex(,3388) @item leadcoef
types.tex(,3389) coefficient of the leading term (see @ref{leadcoef})
types.tex(,3390) @item par
types.tex(,3391) n-th parameter of the basering (see @ref{par})
types.tex(,3392) @item pardeg
types.tex(,3393) degree of a number in ring parameters (see @ref{pardeg})
types.tex(,3394) @item parstr
types.tex(,3395) string form of ring parameters (see @ref{parstr})
types.tex(,3396) @item repart
types.tex(,3397) real part of a complex number
types.tex(,3398) (see @ref{impart}, @ref{repart})
types.tex(,3399) @end table
types.tex(,3400) 
types.tex(,3401) @c ---------------------------------------
types.tex(,3481) 
types.tex(,3482) @c ---------------------------------------
types.tex(,3487) @node poly, proc, number, Data types
types.tex(,3489) @section poly
types.tex(,3490) @cindex poly
types.tex(,3491) 
types.tex(,3492) Polynomials are the basic data for all main algorithms in
types.tex(,3493) @code{@sc{Singular}}. They consist of finitely many terms
types.tex(,3494) (coefficient*power product) which are combined by the usual polynomial
types.tex(,3495) operations (see @ref{poly expressions}). Polynomials can only be defined
types.tex(,3496) or accessed with respect to a basering which determines the coefficient
types.tex(,3497) type, the names of the indeterminates and the monomial ordering.
types.tex(,3498) 
types.tex(,3499) @smallexample
types.tex(,3500) @c reused example poly types.doc:2950 
types.tex(,3501)   ring r=32003,(x,y,z),dp;
types.tex(,3502)   poly f=x3+y5+z2;
types.tex(,3503) @c end example poly types.doc:2950
types.tex(,3504) @end smallexample
types.tex(,3505) 
types.tex(,3506) @menu
types.tex(,3507) * poly declarations::
types.tex(,3508) * poly expressions::
types.tex(,3509) * poly operations::
types.tex(,3510) * poly related functions::
types.tex(,3511) @end menu
types.tex(,3512) 
types.tex(,3513) @c ------------------------------
types.tex(,3514) @node poly declarations, poly expressions, poly, poly
types.tex(,3515) @subsection poly declarations
types.tex(,3516) @cindex poly declarations
types.tex(,3517) 
types.tex(,3518) @table @strong
types.tex(,3519) @item Syntax:
types.tex(,3520) @code{poly} name @code{=} poly_expression @code{;}
types.tex(,3521) 
types.tex(,3522) @item Purpose:
types.tex(,3523) defines a polynomial.
types.tex(,3524) 
types.tex(,3525) @item Default:
types.tex(,3526) 0
types.tex(,3527) 
types.tex(,3528) @item Example:
types.tex(,3529) @smallexample
types.tex(,3530) @c reused example poly_declarations types.doc:2980 
types.tex(,3531)   ring r = 32003,(x,y,z),dp;
types.tex(,3532)   poly s1  = x3y2+151x5y+186xy6+169y9;
types.tex(,3533)   poly s2  = 1*x^2*y^2*z^2+3z8;
types.tex(,3534)   poly s3  = 5/4x4y2+4/5*x*y^5+2x2y2z3+y7+11x10;
types.tex(,3535)   int a,b,c,t=37,5,4,1;
types.tex(,3536)   poly f=3*x^a+x*y^(b+c)+t*x^a*y^b*z^c;
types.tex(,3537)   f;
types.tex(,3538) @expansion{} x37y5z4+3x37+xy9
types.tex(,3539)   short = 0;
types.tex(,3540)   f;
types.tex(,3541) @expansion{} x^37*y^5*z^4+3*x^37+x*y^9
types.tex(,3542) @c end example poly_declarations types.doc:2980
types.tex(,3543) @end smallexample
types.tex(,3544) @end table
types.tex(,3545) @c inserted refs from types.doc:2993
types.tex(,3556) @c end inserted refs from types.doc:2993
types.tex(,3557) @c ------------------------------
types.tex(,3558) @node poly expressions, poly operations, poly declarations, poly
types.tex(,3559) @subsection poly expressions
types.tex(,3560) @cindex poly expressions
types.tex(,3561) 
types.tex(,3562) A poly expression is (optional parts in square brackets):
types.tex(,3563) @enumerate
types.tex(,3564) @item
types.tex(,3565) a monomial (there are NO spaces allowed inside a monomial)
types.tex(,3566) @smallexample
types.tex(,3567)   [coefficient] ring_variable [ exponent] [ring_variable [exponent] @dots{}]
types.tex(,3568) @end smallexample
types.tex(,3569) monomials which contain an indexed ring variable
types.tex(,3570) must be built from @code{ring_variable} and @code{coefficient}
types.tex(,3571) with the operations @code{*} and @code{^}
types.tex(,3572) @item
types.tex(,3573) an identifier of type poly
types.tex(,3574) @item
types.tex(,3575) a function returning poly
types.tex(,3576) @item
types.tex(,3577) poly expressions combined by the arithmetic operations
types.tex(,3578) @code{+}, @code{-}, @code{*}, @code{/}, or @code{^}
types.tex(,3579) @item
types.tex(,3580) an int expression (see @ref{Type conversion and casting})
types.tex(,3581) @item
types.tex(,3582) a type cast to poly
types.tex(,3583) @end enumerate
types.tex(,3584) 
types.tex(,3585) @*@strong{Example:}
types.tex(,3586) @smallexample
types.tex(,3587) 2x, x3, 2x2y3, xyz, 2xy2; //  are monomials
types.tex(,3588) 2*x, x^3, 2*x^2*y^3, x*y*z, 2*x*y^2; // are poly expressions
types.tex(,3589) 2*x(1); // is a valid poly expression, but not 2x(1) (a syntax error)
types.tex(,3590) 2*x^3;  // is a valid poly expression equal to 2x3 (a valid monomial)
types.tex(,3591)         // but not equal to 2x^3 which will be interpreted as (2x)^3
types.tex(,3592)         // since 2x is a monomial
types.tex(,3593) @c reused example poly_expressions types.doc:3032 
types.tex(,3594)   ring r=0,(x,y),dp;
types.tex(,3595)   poly f = 10x2y3 +2x2y2-2xy+y -x+2;
types.tex(,3596)   lead(f);
types.tex(,3597) @expansion{} 10x2y3
types.tex(,3598)   leadmonom(f);
types.tex(,3599) @expansion{} x2y3
types.tex(,3600)   simplify(f,1);     // normalize leading coefficient
types.tex(,3601) @expansion{} x2y3+1/5x2y2-1/5xy-1/10x+1/10y+1/5
types.tex(,3602)   poly g = 1/2x2 + 1/3y;
types.tex(,3603)   cleardenom(g);
types.tex(,3604) @expansion{} 3x2+2y
types.tex(,3605)   int i = 102;
types.tex(,3606)   poly(i);
types.tex(,3607) @expansion{} 102
types.tex(,3608)   typeof(_);
types.tex(,3609) @expansion{} poly
types.tex(,3610) @c end example poly_expressions types.doc:3032
types.tex(,3611) @end smallexample
types.tex(,3612) 
types.tex(,3613) @c inserted refs from types.doc:3046
types.tex(,3626) @c end inserted refs from types.doc:3046
types.tex(,3627) 
types.tex(,3628) @c ------------------------------
types.tex(,3629) @node poly operations, poly related functions, poly expressions, poly
types.tex(,3630) @subsection poly operations
types.tex(,3631) @cindex poly operations
types.tex(,3632) 
types.tex(,3633) @table @asis
types.tex(,3634) @item @code{+}
types.tex(,3635) addition
types.tex(,3636) 
types.tex(,3637) @item @code{-}
types.tex(,3638) negation or subtraction
types.tex(,3639) 
types.tex(,3640) @item @code{*}
types.tex(,3641) multiplication
types.tex(,3642) 
types.tex(,3643) @item @code{/}
types.tex(,3644) division by a polynomial, ignoring the rest
types.tex(,3645) 
types.tex(,3646) @item @code{^}, @code{**}
types.tex(,3647) power by an integer
types.tex(,3648) 
types.tex(,3649) @item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
types.tex(,3650) comparison (w.r.t. monomial ordering)
types.tex(,3651) 
types.tex(,3652) @item poly_expression @code{[} intvec_expression @code{]}
types.tex(,3653) the monomial at the indicated place w.r.t.@: the monomial ordering
types.tex(,3654) @end table
types.tex(,3655) 
types.tex(,3656) @*@strong{Example:}
types.tex(,3657) @smallexample
types.tex(,3658) @c reused example poly_operations types.doc:3080 
types.tex(,3659)   ring R=0,(x,y),dp;
types.tex(,3660)   poly f = x3y2 + 2x2y2 + xy - x + y + 1;
types.tex(,3661)   f;
types.tex(,3662) @expansion{} x3y2+2x2y2+xy-x+y+1
types.tex(,3663)   f + x5 + 2;
types.tex(,3664) @expansion{} x5+x3y2+2x2y2+xy-x+y+3
types.tex(,3665)   f * x2;
types.tex(,3666) @expansion{} x5y2+2x4y2+x3y-x3+x2y+x2
types.tex(,3667)   (x+y)/x;
types.tex(,3668) @expansion{} 1
types.tex(,3669)   f/3x2;
types.tex(,3670) @expansion{} 1/3xy2+2/3y2
types.tex(,3671)   x5 > f;
types.tex(,3672) @expansion{} 1
types.tex(,3673)   x<=y;
types.tex(,3674) @expansion{} 0
types.tex(,3675)   x>y;
types.tex(,3676) @expansion{} 1
types.tex(,3677)   ring r=0,(x,y),ds;
types.tex(,3678)   poly f = fetch(R,f);
types.tex(,3679)   f;
types.tex(,3680) @expansion{} 1-x+y+xy+2x2y2+x3y2
types.tex(,3681)   x5 > f;
types.tex(,3682) @expansion{} 0
types.tex(,3683)   f[2..4];
types.tex(,3684) @expansion{} -x+y+xy
types.tex(,3685)   size(f);
types.tex(,3686) @expansion{} 6
types.tex(,3687)   f[size(f)+1]; f[-1];    // monomials out of range are 0
types.tex(,3688) @expansion{} 0
types.tex(,3689) @expansion{} 0
types.tex(,3690)   intvec v = 6,1,3;
types.tex(,3691)   f[v];          // the polynom built from the 1st, 3rd and 6th monomial of f
types.tex(,3692) @expansion{} 1+y+x3y2
types.tex(,3693) @c end example poly_operations types.doc:3080
types.tex(,3694) @end smallexample
types.tex(,3695) 
types.tex(,3696) @c ------------------------------
types.tex(,3697) @node poly related functions,  , poly operations, poly
types.tex(,3698) @subsection poly related functions
types.tex(,3699) @cindex poly related functions
types.tex(,3700) 
types.tex(,3701) @table @code
types.tex(,3702) @item cleardenom
types.tex(,3703) cancel denominators of numbers in poly and divide it by its content
types.tex(,3704) (see @ref{cleardenom})
types.tex(,3705) @item coef
types.tex(,3706) matrix of coefficients and monomials (see @ref{coef})
types.tex(,3707) @item coeffs
types.tex(,3708) matrix of coefficients (see @ref{coeffs})
types.tex(,3709) @item deg
types.tex(,3710) degree (see @ref{deg})
types.tex(,3711) @item det
types.tex(,3712) determinant (see @ref{det})
types.tex(,3713) @item diff
types.tex(,3714) partial derivative (see @ref{diff})
types.tex(,3715) @item extgcd
types.tex(,3716) Bezout representation of gcd (see @ref{extgcd})
types.tex(,3717) @item factorize
types.tex(,3718) factorize polynomial (see @ref{factorize})
types.tex(,3719) @item finduni
types.tex(,3720) find univariate polynomials in a zero-dimensional ideal (see @ref{finduni})
types.tex(,3721) @item gcd
types.tex(,3722) greatest common divisor (see @ref{gcd})
types.tex(,3723) @item homog
types.tex(,3724) homogenization (see @ref{homog})
types.tex(,3725) @item jacob
types.tex(,3726) ideal, resp.@: matrix, of all partial derivatives (see @ref{jacob})
types.tex(,3727) @item lead
types.tex(,3728) leading term (see @ref{lead})
types.tex(,3729) @item leadcoef
types.tex(,3730) coefficient of the leading term (see @ref{leadcoef})
types.tex(,3731) @item leadexp
types.tex(,3732) the exponent vector of the leading monomial (see @ref{leadexp})
types.tex(,3733) @item leadmonom
types.tex(,3734) leading monomial (see @ref{leadmonom})
types.tex(,3735) @item jet
types.tex(,3736) monomials with degree smaller k+1 (see @ref{jet})
types.tex(,3737) @item ord
types.tex(,3738) degree of the leading monomial (see @ref{ord})
types.tex(,3739) @item qhweight
types.tex(,3740) quasihomogeneous weights (see @ref{qhweight})
types.tex(,3741) @item reduce
types.tex(,3742) normal form with respect to a standard base (see @ref{reduce})
types.tex(,3743) @item rvar
types.tex(,3744) test for ring variable (see @ref{rvar})
types.tex(,3745) @item simplify
types.tex(,3746) normalize a polynomial (see @ref{simplify})
types.tex(,3747) @item size
types.tex(,3748) number of monomials (see @ref{size})
types.tex(,3749) @item subst
types.tex(,3750) substitute a ring variable (see @ref{subst})
types.tex(,3751) @item trace
types.tex(,3752) trace of a matrix (see @ref{trace})
types.tex(,3753) @item var
types.tex(,3754) the indicated variable of the ring (see @ref{var})
types.tex(,3755) @item varstr
types.tex(,3756) variable in string form (see @ref{varstr})
types.tex(,3757) @end table
types.tex(,3758) 
types.tex(,3759) @c @*@strong{Example:}
types.tex(,3760) @c @example
types.tex(,3761) @c @end example
types.tex(,3762) 
types.tex(,3763) @c ---------------------------------------
types.tex(,3764) @node proc, qring, poly, Data types
types.tex(,3765) @section proc
types.tex(,3766) @cindex proc
types.tex(,3767) 
types.tex(,3768) Procedures are sequences of @sc{Singular} commands in a special
types.tex(,3769) format. They are used to extend the set of @sc{Singular} commands with
types.tex(,3770) user defined commands. Once a procedure is defined it can be used as
types.tex(,3771) any other @sc{Singular} command. Procedures may be defined by either
types.tex(,3772) typing them on the command line or by loading them from a file. For a
types.tex(,3773) detailed description on the concept of procedures in @sc{Singular} see
types.tex(,3774) @ref{Procedures}. A file containing procedure definitions which comply with
types.tex(,3775) certain syntax rules is called a library. Such a file is loaded
types.tex(,3776) using the command @code{LIB}. For more information on libraries see
types.tex(,3777) @ref{Libraries}.
types.tex(,3778) 
types.tex(,3779) @menu
types.tex(,3780) * proc declaration::
types.tex(,3781) @end menu
types.tex(,3782) 
types.tex(,3783) @c ---------------------------------------
types.tex(,3784) @node proc declaration,  , proc, proc
types.tex(,3785) @subsection proc declaration
types.tex(,3786) @cindex proc declaration
types.tex(,3787) 
types.tex(,3788) @c ------------------------------------------------------------
types.tex(,3789) @c   This piece of text exists also in the file general.doc,
types.tex(,3790) @c   chapter "Proc in a library".
types.tex(,3791) @c   If you change something here, change it there, too!
types.tex(,3792) @c ------------------------------------------------------------
types.tex(,3793) @table @strong
types.tex(,3794) @item Syntax:
types.tex(,3795) [@code{static}] @code{proc} proc_name [parameter_list]
types.tex(,3796) @*["help_text"]
types.tex(,3797) @*@code{@{}
types.tex(,3798) @*
types.tex(,3802)    procedure_body
types.tex(,3803) @*@code{@}}
types.tex(,3804) @*[@code{example}
types.tex(,3805) @*@code{@{}
types.tex(,3806) @*
types.tex(,3810)    sequence_of_commands;
types.tex(,3811) @*@code{@}}]
types.tex(,3812) @*@code{proc} proc_name @code{=} proc_name @code{;}
types.tex(,3813) @*@code{proc} proc_name @code{=} string_expression @code{;}
types.tex(,3814) @item Purpose:
types.tex(,3815) defines a new function, the @code{proc} proc_name, with the additional
types.tex(,3816) information help_text, which is copied to the screen by
types.tex(,3817) @code{help proc_name;} and the @code{example} section
types.tex(,3818) which is executed by @code{example proc_name;}.
types.tex(,3819) @* The help_text, the parameter_list, and the example section are optional.
types.tex(,3820) The default for a parameter_list is @code{(list #)}, see @ref{Parameter list}.
types.tex(,3821) The help and example sections are ignored if the procedure is defined
types.tex(,3822) interactively, i.e., if it was not loaded from a file by a @ref{LIB} command.
types.tex(,3823) @* Specifying @code{static} in front of the proc-definition is only possible
types.tex(,3824) in a library file and makes this procedure local to the library,
types.tex(,3825) i.e., accessible only for the other procedures in the same library,
types.tex(,3826) but not for the users.
types.tex(,3827) 
types.tex(,3828) @item Example:
types.tex(,3829) @smallexample
types.tex(,3830) @c reused example proc_declaration types.doc:3237 
types.tex(,3831)   proc milnor_number (poly p)
types.tex(,3832)   @{
types.tex(,3833)     ideal i= std(jacob(p));
types.tex(,3834)     int m_nr=vdim(i);
types.tex(,3835)     if (m_nr<0)
types.tex(,3836)     @{
types.tex(,3837)       "// not an isolated singularity";
types.tex(,3838)     @}
types.tex(,3839)     return(m_nr);         // the value of m_nr is returned
types.tex(,3840)   @}
types.tex(,3841)   ring r1=0,(x,y,z),ds;
types.tex(,3842)   poly p=x^2+y^2+z^5;
types.tex(,3843)   milnor_number(p);
types.tex(,3844) @expansion{} 4
types.tex(,3845) @c end example proc_declaration types.doc:3237
types.tex(,3846) @end smallexample
types.tex(,3847) @end table
types.tex(,3848) @c inserted refs from types.doc:3254
types.tex(,3863) @c end inserted refs from types.doc:3254
types.tex(,3864) 
types.tex(,3865) 
types.tex(,3866) 
types.tex(,3867) @c ---------------------------------------
types.tex(,3868) @node qring, resolution, proc, Data types
types.tex(,3869) @section qring
types.tex(,3870) @cindex qring
types.tex(,3871) 
types.tex(,3872) @sc{Singular} offers the opportunity to calculate in quotient rings
types.tex(,3873) (factor rings), i.e., rings modulo an ideal.  The ideal has to be given
types.tex(,3874) as a standard basis.  For a detailed description of the concept
types.tex(,3875) of rings and quotient rings see @ref{Rings and orderings}.
types.tex(,3876) 
types.tex(,3877) @menu
types.tex(,3878) * qring declaration::
types.tex(,3879) @end menu
types.tex(,3880) 
types.tex(,3881) @c ---------------------------------------
types.tex(,3882) @node qring declaration,  , qring, qring
types.tex(,3883) @subsection qring declaration
types.tex(,3884) @cindex qring declaration
types.tex(,3885) 
types.tex(,3886) @c ------------------------------------------------------------
types.tex(,3887) @c   This piece of text exists also in the file general.doc,
types.tex(,3888) @c   chapter "General syntax of a ring declaration".
types.tex(,3889) @c   If you change something here, change it there, too!
types.tex(,3890) @c ------------------------------------------------------------
types.tex(,3891) @table @strong
types.tex(,3892) @item Syntax:
types.tex(,3893) @code{qring} name @code{=} ideal_expression @code{;}
types.tex(,3894) @item Default:
types.tex(,3895) none
types.tex(,3896) @item Purpose:
types.tex(,3897) declares a quotient ring as the basering modulo ideal_expression.  Sets
types.tex(,3898) it as current basering.
types.tex(,3899) @item Example:
types.tex(,3900) @smallexample
types.tex(,3901) @c reused example qring_declaration types.doc:3297 
types.tex(,3902) ring r=0,(x,y,z),dp;
types.tex(,3903) ideal i=xy;
types.tex(,3904) qring q=std(i);
types.tex(,3905) basering;
types.tex(,3906) @expansion{} //   characteristic : 0
types.tex(,3907) @expansion{} //   number of vars : 3
types.tex(,3908) @expansion{} //        block   1 : ordering dp
types.tex(,3909) @expansion{} //                  : names    x y z 
types.tex(,3910) @expansion{} //        block   2 : ordering C
types.tex(,3911) @expansion{} // quotient ring from ideal
types.tex(,3912) @expansion{} _[1]=xy
types.tex(,3913) @c end example qring_declaration types.doc:3297
types.tex(,3914) @end smallexample
types.tex(,3915) @end table
types.tex(,3916) 
types.tex(,3917) @c ---------------------------------------
types.tex(,3918) @node resolution, ring, qring, Data types
types.tex(,3919) @section resolution
types.tex(,3920) @cindex resolution
types.tex(,3921) 
types.tex(,3922) The resolution type is intended as an intermediate representation which
types.tex(,3923) internally retains additional information obtained during computation of
types.tex(,3924) resolutions. It furthermore enables the use of partial results to
types.tex(,3925) compute, for example, Betti numbers or minimal resolutions. Like ideals
types.tex(,3926) and modules, a resolution can only be defined w.r.t.@: a basering.
types.tex(,3927) 
types.tex(,3928) @strong{Note:}
types.tex(,3929) to access the elements of a resolution, it has to be assigned to a list,
types.tex(,3930) which also completes computations and may therefore take time,
types.tex(,3931) (resp.@: an access directly with the brackets @code{[ , ]} causes
types.tex(,3932) implicitly a cast to a list).
types.tex(,3933) 
types.tex(,3934) @menu
types.tex(,3935) * resolution declarations::
types.tex(,3936) * resolution expressions::
types.tex(,3937) * resolution related functions::
types.tex(,3938) @end menu
types.tex(,3939) 
types.tex(,3940) @c ---------------------------------------
types.tex(,3941) @node resolution declarations, resolution expressions, resolution, resolution
types.tex(,3942) @subsection resolution declarations
types.tex(,3943) @cindex resolution declarations
types.tex(,3944) 
types.tex(,3945) @table @strong
types.tex(,3946) @item Syntax:
types.tex(,3947) @code{resolution} name @code{=} resolution_expression @code{;}
types.tex(,3948) 
types.tex(,3949) @item Purpose:
types.tex(,3950) defines a resolution.
types.tex(,3951) 
types.tex(,3952) @item Default:
types.tex(,3953) none
types.tex(,3954) 
types.tex(,3955) @item Example:
types.tex(,3956) @smallexample
types.tex(,3957) @c reused example resolution_declarations types.doc:3346 
types.tex(,3958)   ring R;
types.tex(,3959)   ideal i=z2,x;
types.tex(,3960)   resolution re=res(i,0);
types.tex(,3961)   re;
types.tex(,3962) @expansion{}  1      2      1      
types.tex(,3963) @expansion{} R <--  R <--  R
types.tex(,3964) @expansion{} 
types.tex(,3965) @expansion{} 0      1      2      
types.tex(,3966) @expansion{} resolution not minimized yet
types.tex(,3967) @expansion{} 
types.tex(,3968)   betti(re);
types.tex(,3969) @expansion{} 1,1,0,
types.tex(,3970) @expansion{} 0,1,1 
types.tex(,3971)   list l = re;
types.tex(,3972)   l;
types.tex(,3973) @expansion{} [1]:
types.tex(,3974) @expansion{}    _[1]=x
types.tex(,3975) @expansion{}    _[2]=z2
types.tex(,3976) @expansion{} [2]:
types.tex(,3977) @expansion{}    _[1]=-z2*gen(1)+x*gen(2)
types.tex(,3978) @expansion{} [3]:
types.tex(,3979) @expansion{}    _[1]=0
types.tex(,3980) @c end example resolution_declarations types.doc:3346
types.tex(,3981) @end smallexample
types.tex(,3982) @end table
types.tex(,3983) 
types.tex(,3984) @c ------------------------------
types.tex(,3985) @node resolution expressions, resolution related functions, resolution declarations, resolution
types.tex(,3986) @subsection resolution expressions
types.tex(,3987) @cindex resolution expressions
types.tex(,3988) 
types.tex(,3989) A resolution expression is:
types.tex(,3990) @enumerate
types.tex(,3991) @item
types.tex(,3992) an identifier of type resolution
types.tex(,3993) @item
types.tex(,3994) a function returning a resolution
types.tex(,3995) @item
types.tex(,3996) a type cast to resolution from a list of ideals, resp.@: modules..
types.tex(,3997) @end enumerate
types.tex(,3998) 
types.tex(,3999) @c inserted refs from types.doc:3373
types.tex(,4010) @c end inserted refs from types.doc:3373
types.tex(,4011) 
types.tex(,4012) @c ------------------------------
types.tex(,4013) @node resolution related functions,  , resolution expressions, resolution
types.tex(,4014) @subsection resolution related functions
types.tex(,4015) @cindex resolution related functions
types.tex(,4016) 
types.tex(,4017) @table @code
types.tex(,4018) @item betti
types.tex(,4019) Betti numbers of a resolution (see @ref{betti})
types.tex(,4020) @item lres
types.tex(,4021) free resolution (see @ref{lres})
types.tex(,4022) @item minres
types.tex(,4023) minimize a free resolution (see @ref{minres})
types.tex(,4024) @item mres
types.tex(,4025) minimal free resolution of an ideal, resp.@: module w.r.t. a minimal set of generators of
types.tex(,4026) the given ideal, resp.@: module (see @ref{mres})
types.tex(,4027) @item res
types.tex(,4028) free resolution of an ideal, resp.@: module, but not changing the
types.tex(,4029) given ideal, resp.@: module (see @ref{res})
types.tex(,4030) @item sres
types.tex(,4031) free resolution of a standard basis (see @ref{sres})
types.tex(,4032) @end table
types.tex(,4033) 
types.tex(,4034) @c @*@strong{Example:}
types.tex(,4035) @c @example
types.tex(,4036) @c @end example
types.tex(,4037) 
types.tex(,4038) @c ---------------------------------------
types.tex(,4039) @node ring, string, resolution, Data types
types.tex(,4040) @section ring
types.tex(,4041) @cindex ring
types.tex(,4042) 
types.tex(,4043) Rings are used to describe properties of polynomials, ideals etc.
types.tex(,4044) Almost all computations in @sc{Singular} require a basering.
types.tex(,4045) For a detailed description of the concept of rings see
types.tex(,4046) @ref{Rings and orderings}.
types.tex(,4047) 
types.tex(,4048) @menu
types.tex(,4049) * ring declarations::
types.tex(,4050) * ring related functions::
types.tex(,4051) * ring operations::
types.tex(,4052) @end menu
types.tex(,4053) 
types.tex(,4054) @c ---------------------------------------
types.tex(,4055) @node ring declarations, ring related functions, ring, ring
types.tex(,4056) @subsection ring declarations
types.tex(,4057) @cindex ring declarations
types.tex(,4058) 
types.tex(,4059) @table @strong
types.tex(,4060) @item Syntax:
types.tex(,4061) @code{ring} name @code{= (} coefficient_field @code{),}
types.tex(,4062)   @code{(} names_of_ring_variables @code{),}
types.tex(,4063)   @code{(} ordering @code{);}
types.tex(,4064) @item Default:
types.tex(,4065) @code{32003,(x,y,z),(dp,C);}
types.tex(,4066) @item Purpose:
types.tex(,4067) declares a ring and sets it as the actual basering.
types.tex(,4068) @end table
types.tex(,4069) 
types.tex(,4070) The coefficient_field is given by one of the following:
types.tex(,4071) @enumerate
types.tex(,4072) @item
types.tex(,4073) a non-negative int_expression less or equal 2147483629.
types.tex(,4074) @item
types.tex(,4075) an expression_list of an int_expression and one or more names.
types.tex(,4076) @item
types.tex(,4077) the name @code{real}
types.tex(,4078) @item
types.tex(,4079) an expression_list of the name @code{real} and an  int_expression.
types.tex(,4080) @item
types.tex(,4081) an expression_list of the name @code{complex}, an optional int_expression
types.tex(,4082) and a name.
types.tex(,4083) @end enumerate
types.tex(,4084) 
types.tex(,4085) For the definition of the 'coefficient_field', see @ref{Rings and orderings}.
types.tex(,4086) 
types.tex(,4087) 'names_of_ring_variables' must be a list of names or indexed names.
types.tex(,4088) 
types.tex(,4089) 'ordering' is a list of block orderings where each block ordering is either
types.tex(,4090) @enumerate
types.tex(,4091) @item
types.tex(,4092) @code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, or @code{Ds}
types.tex(,4093) optionally followed by a size parameter in parentheses.
types.tex(,4094) 
types.tex(,4095) @item
types.tex(,4096) @code{wp}, @code{Wp}, @code{ws}, @code{Ws}, or @code{a} followed by a
types.tex(,4097) weight vector given as an intvec_expression in parentheses.
types.tex(,4098) 
types.tex(,4099) @item
types.tex(,4100) @code{M} followed by an intmat_expression in parentheses.
types.tex(,4101) 
types.tex(,4102) @item
types.tex(,4103) @code{c} or @code{C}.
types.tex(,4104) @end enumerate
types.tex(,4105) 
types.tex(,4106) For the definition of the orderings, see @ref{Term orderings},
types.tex(,4107) @ref{Monomial orderings}.
types.tex(,4108) 
types.tex(,4109) If one of coefficient_field, names_of_ring_variables, and ordering
types.tex(,4110) consists of only one entry, the parentheses around this entry may be
types.tex(,4111) omitted.
types.tex(,4112) 
types.tex(,4113) @c ---------------------------------------
types.tex(,4114) @node ring related functions, ring operations, ring declarations, ring
types.tex(,4115) @subsection ring related functions
types.tex(,4116) @cindex ring related functions
types.tex(,4117) 
types.tex(,4118) @table @code
types.tex(,4119) @item charstr
types.tex(,4120) description of the coefficient field of a ring (see @ref{charstr})
types.tex(,4121) @item keepring
types.tex(,4122) move ring to next upper level (see @ref{keepring})
types.tex(,4123) @item npars
types.tex(,4124) number of ring parameters (see @ref{npars})
types.tex(,4125) @item nvars
types.tex(,4126) number of ring variables (see @ref{nvars})
types.tex(,4127) @item ordstr
types.tex(,4128) monomial ordering of a ring (see @ref{ordstr})
types.tex(,4129) @item parstr
types.tex(,4130) names of all ring parameters or the
types.tex(,4131) name of the n-th ring parameter (see @ref{parstr})
types.tex(,4132) @item qring
types.tex(,4133) quotient ring (see @ref{qring})
types.tex(,4134) @item setring
types.tex(,4135) set a new basering (see @ref{setring})
types.tex(,4136) @item varstr
types.tex(,4137) names of all ring variables or the
types.tex(,4138) name of the n-th ring variable (see @ref{varstr})
types.tex(,4139) @end table
types.tex(,4140) 
types.tex(,4141) @c ---------------------------------------
types.tex(,4142) @node ring operations, , ring related functions, ring
types.tex(,4143) @subsection ring operations
types.tex(,4144) @cindex ring operations
types.tex(,4145) @table @asis
types.tex(,4146) @item @code{+}
types.tex(,4147) construct a new ring 
types.tex(,4154)  from 
types.tex(,4161)   and 
types.tex(,4168) .
types.tex(,4169) @end table
types.tex(,4170) 
types.tex(,4171) Concerning the ground fields 
types.tex(,4178)  and 
types.tex(,4185)  take the
types.tex(,4186) following guide lines into consideration:
types.tex(,4187) @itemize @bullet
types.tex(,4188) @item Neither 
types.tex(,4195)  nor 
types.tex(,4202)  may be 
types.tex(,4209)  or 
types.tex(,4216) .
types.tex(,4217) @item If the characteristic of 
types.tex(,4224)  and 
types.tex(,4231)  differs, then one of them must be 
types.tex(,4238) .
types.tex(,4239) @item At most one of 
types.tex(,4246)  and 
types.tex(,4253)  may be have parameters.
types.tex(,4254) @item If one of 
types.tex(,4261)  and 
types.tex(,4268)  is an algebraic extension of 
types.tex(,4275)  it may not be defined by a @code{charstr} of type @code{(p^n,a)}.
types.tex(,4276) @end itemize
types.tex(,4277) 
types.tex(,4278) 
types.tex(,4279) @strong{Example:}
types.tex(,4280) @smallexample
types.tex(,4281) @c reused example ring_operations types.doc:3527 
types.tex(,4282)   ring R1=0,(x,y),dp;
types.tex(,4283)   ring R2=32003,(a,b),dp;
types.tex(,4284)   def R=R1+R2;
types.tex(,4285)   R;
types.tex(,4286) @expansion{} //   characteristic : 32003
types.tex(,4287) @expansion{} //   number of vars : 4
types.tex(,4288) @expansion{} //        block   1 : ordering dp
types.tex(,4289) @expansion{} //                  : names    x y 
types.tex(,4290) @expansion{} //        block   2 : ordering dp
types.tex(,4291) @expansion{} //                  : names    a b 
types.tex(,4292) @expansion{} //        block   3 : ordering C
types.tex(,4293) @c end example ring_operations types.doc:3527
types.tex(,4294) @end smallexample
types.tex(,4295) 
types.tex(,4296) @c inserted refs from types.doc:3535
types.tex(,4307) @c end inserted refs from types.doc:3535
types.tex(,4308) 
types.tex(,4309) @c ---------------------------------------
types.tex(,4310) @node string, vector, ring, Data types
types.tex(,4311) @section string
types.tex(,4312) @cindex string
types.tex(,4313) @cindex newline
types.tex(,4314) 
types.tex(,4315) Variables of type @code{string} are used for output (almost every type
types.tex(,4316) can be "converted" to @code{string}) and for creating new
types.tex(,4317) commands at runtime see @ref{execute}.  They are also return values of
types.tex(,4318) certain interpreter related functions (see @ref{Functions}).  String
types.tex(,4319) constants consist of a sequence of ANY characters (including newline!)
types.tex(,4320) between a starting @code{"} and a closing @code{"}.  There is also a
types.tex(,4321) string constant @code{newline}, which is the newline character.  The
types.tex(,4322) @code{+} sign "adds" strings, @code{""} is the empty string (hence
types.tex(,4323) strings form a semigroup). Strings may be used to comment the output of
types.tex(,4324) a computation or to give it a nice format. Strings may also be used for
types.tex(,4325) intermediate conversion of one type into another.
types.tex(,4326) 
types.tex(,4327) @smallexample
types.tex(,4328) @c reused example string types.doc:3558 
types.tex(,4329)   string s="Hi";
types.tex(,4330)   string s1="a string with new line at the end"+newline;
types.tex(,4331)   string s2="another string with new line at the end
types.tex(,4332)   ";
types.tex(,4333)   s;s1;s2;
types.tex(,4334) @expansion{} Hi
types.tex(,4335) @expansion{} a string with new line at the end
types.tex(,4336) @expansion{} 
types.tex(,4337) @expansion{} another string with new line at the end
types.tex(,4338) @expansion{}   
types.tex(,4339)   ring r; ideal i=std(ideal(x,y^3));
types.tex(,4340)   "dimension of i =",dim(i),", multiplicity of i =",mult(i);
types.tex(,4341) @expansion{} dimension of i = 1 , multiplicity of i = 3
types.tex(,4342)   "dimension of i = "+string(dim(i))+", multiplicity of i = "+string(mult(i));
types.tex(,4343) @expansion{} dimension of i = 1, multiplicity of i = 3
types.tex(,4344)   "a"+"b","c";
types.tex(,4345) @expansion{} ab c
types.tex(,4346) @c end example string types.doc:3558
types.tex(,4347) @end smallexample
types.tex(,4348) A comma between two strings makes an expression list out of them
types.tex(,4349) (such a list is printed with a separating blank in between),
types.tex(,4350) while a @code{+} concatenates strings.
types.tex(,4351) 
types.tex(,4352) @menu
types.tex(,4353) * string declarations::
types.tex(,4354) * string expressions::
types.tex(,4355) * string type cast::
types.tex(,4356) * string operations::
types.tex(,4357) * string related functions::
types.tex(,4358) @end menu
types.tex(,4359) 
types.tex(,4360) @c ------------------------------
types.tex(,4361) @node string declarations, string expressions, string, string
types.tex(,4362) @subsection string declarations
types.tex(,4363) @cindex string declarations
types.tex(,4364) 
types.tex(,4365) @table @strong
types.tex(,4366) @item Syntax:
types.tex(,4367) @code{string} name @code{=} string_expression @code{;}
types.tex(,4368) @*@code{string} name @code{=} list_of_string_expressions @code{;}
types.tex(,4369) 
types.tex(,4370) @item Purpose:
types.tex(,4371) defines a string variable.
types.tex(,4372) 
types.tex(,4373) @item Default:
types.tex(,4374) "" (the empty string)
types.tex(,4375) 
types.tex(,4376) @item Example:
types.tex(,4377) @smallexample
types.tex(,4378) @c reused example string_declarations types.doc:3600 
types.tex(,4379)   string s1="Now I know";
types.tex(,4380)   string s2="how to encode a \" in a string...";
types.tex(,4381)   string s=s1+" "+s2; // concatenation of 3 strings
types.tex(,4382)   s;
types.tex(,4383) @expansion{} Now I know how to encode a " in a string...
types.tex(,4384)   s1,s2;   // 2 strings, separated by a blank in the output:
types.tex(,4385) @expansion{} Now I know how to encode a " in a string...
types.tex(,4386) @c end example string_declarations types.doc:3600
types.tex(,4387) @end smallexample
types.tex(,4388) @end table
types.tex(,4389) 
types.tex(,4390) @c ------------------------------
types.tex(,4391) @node string expressions, string type cast, string declarations, string
types.tex(,4392) @subsection string expressions
types.tex(,4393) @cindex string expressions
types.tex(,4394) 
types.tex(,4395) A string expression is:
types.tex(,4396) @enumerate
types.tex(,4397) @item
types.tex(,4398) a sequence of characters between two unescaped quotes (@code{"})
types.tex(,4399) @item
types.tex(,4400) an identifier of type string
types.tex(,4401) @item
types.tex(,4402) a function returning string
types.tex(,4403) @item
types.tex(,4404) a substring (using the bracket operator)
types.tex(,4405) @item
types.tex(,4406) a type cast to string (@pxref{string type cast})
types.tex(,4407) @item
types.tex(,4408) string expressions combined by the operation @code{+}.
types.tex(,4409) @end enumerate
types.tex(,4410) 
types.tex(,4411) @*@strong{Example:}
types.tex(,4412) @smallexample
types.tex(,4413) @c  // a string constant
types.tex(,4414) @c  "@dots{}";
types.tex(,4415) @c  // a type cast from name
types.tex(,4416) @c  string(name)
types.tex(,4417) @c  // concatenation
types.tex(,4418) @c  string_expression + string_expression
types.tex(,4419) @c reused example string_expressions types.doc:3639 
types.tex(,4420) // string_expression[start, length] : a substring
types.tex(,4421) // (possibly filled up with blanks)
types.tex(,4422) // the substring of s starting at position 2
types.tex(,4423) // with a length of 4
types.tex(,4424) string s="123456";
types.tex(,4425) s[2,4];
types.tex(,4426) @expansion{} 2345
types.tex(,4427) "abcd"[2,2];
types.tex(,4428) @expansion{} bc
types.tex(,4429) // string_expression[position] : a character from a string
types.tex(,4430) s[3];
types.tex(,4431) @expansion{} 3
types.tex(,4432) // string_expression[position..position] :
types.tex(,4433) // a substring starting at the first position up to the second
types.tex(,4434) // given position
types.tex(,4435) s[2..4];
types.tex(,4436) @expansion{} 2 3 4
types.tex(,4437) // a function returning a string
types.tex(,4438) typeof(s);
types.tex(,4439) @expansion{} string
types.tex(,4440) @c end example string_expressions types.doc:3639
types.tex(,4441) @end smallexample
types.tex(,4442) 
types.tex(,4443) @c inserted refs from types.doc:3658
types.tex(,4456) @c end inserted refs from types.doc:3658
types.tex(,4457) 
types.tex(,4458) @c ------------------------------
types.tex(,4459) @node string type cast,  string operations, string expressions, string
types.tex(,4460) @subsection string type cast
types.tex(,4461) @cindex string type cast
types.tex(,4462) @table @code
types.tex(,4463) @item @strong{Syntax:}
types.tex(,4464) @code{string (} expression [, expression_2, ... expression_n]@code{)}
types.tex(,4465) @item @strong{Type:}
types.tex(,4466) string
types.tex(,4467) @item @strong{Purpose:}
types.tex(,4468) Converts each expression to a string, where expression can be of any
types.tex(,4469) type. The concatenated string of all concersions is returned.
types.tex(,4470) 
types.tex(,4471) @*The elements of intvec, intmat, ideal, module, matrix, and list, are
types.tex(,4472) separated by a comma. No newlines are inserted.
types.tex(,4473) @*Not defined elements of a list are omitted.
types.tex(,4474) @*For link, the name of the link is used.
types.tex(,4475) @*For map, the ideal defining the mapping is converted.
types.tex(,4476) 
types.tex(,4477) @item @strong{Note:}
types.tex(,4478) When applied to a list, elements of type intvec, intmat, ideal, module,
types.tex(,4479) matrix, and list become indistinguishable.
types.tex(,4480) 
types.tex(,4481) @item @strong{Example:}
types.tex(,4482) @smallexample
types.tex(,4483) @c reused example string_type_cast types.doc:3688 
types.tex(,4484)   string("1+1=", 2);
types.tex(,4485) @expansion{} 1+1=2
types.tex(,4486)   string(intvec(1,2,3,4));
types.tex(,4487) @expansion{} 1,2,3,4
types.tex(,4488)   string(intmat(intvec(1,2,3,4), 2, 2));
types.tex(,4489) @expansion{} 1,2,3,4 
types.tex(,4490)   ring r;
types.tex(,4491)   string(r);
types.tex(,4492) @expansion{} (32003),(x,y,z),(dp(3),C)
types.tex(,4493)   string(ideal(x,y));
types.tex(,4494) @expansion{} x,y
types.tex(,4495)   qring R = std(ideal(x,y));
types.tex(,4496)   string(R);
types.tex(,4497) @expansion{} (32003),(x,y,z),(dp(3),C)
types.tex(,4498)   map phi = r, ideal(x,z);
types.tex(,4499)   string(phi);
types.tex(,4500) @expansion{} x,z
types.tex(,4501)   list l;
types.tex(,4502)   string(l);
types.tex(,4503) @expansion{} 
types.tex(,4504)   l[3] = 1;
types.tex(,4505)   string(l); // notice that l[1],l[2] are omitted
types.tex(,4506) @expansion{} 1
types.tex(,4507)   l[2] = l;
types.tex(,4508)   l;
types.tex(,4509) @expansion{} [2]:
types.tex(,4510) @expansion{}    [3]:
types.tex(,4511) @expansion{}       1
types.tex(,4512) @expansion{} [3]:
types.tex(,4513) @expansion{}    1
types.tex(,4514)   string(l); // notice that lists of list is flattened
types.tex(,4515) @expansion{} 1,1
types.tex(,4516)   l[1] = intvec(1,2,3);
types.tex(,4517)   l;
types.tex(,4518) @expansion{} [1]:
types.tex(,4519) @expansion{}    1,2,3
types.tex(,4520) @expansion{} [2]:
types.tex(,4521) @expansion{}    [3]:
types.tex(,4522) @expansion{}       1
types.tex(,4523) @expansion{} [3]:
types.tex(,4524) @expansion{}    1
types.tex(,4525)   string(l); // notice that intvec elements are not distinguishable
types.tex(,4526) @expansion{} 1,2,3,1,1
types.tex(,4527) @c end example string_type_cast types.doc:3688
types.tex(,4528) @end smallexample
types.tex(,4529) @end table
types.tex(,4530) @c inserted refs from types.doc:3712
types.tex(,4545) @c end inserted refs from types.doc:3712
types.tex(,4546) 
types.tex(,4547) @c ------------------------------
types.tex(,4548) @node string operations, string related functions, string type cast, string
types.tex(,4549) @subsection string operations
types.tex(,4550) @cindex string operations
types.tex(,4551) 
types.tex(,4552) @table @asis
types.tex(,4553) @item @code{+}
types.tex(,4554) concatenation
types.tex(,4555) 
types.tex(,4556) @item @code{<=}, @code{>=}, @code{==}, @code{<>}
types.tex(,4557) comparison (lexicographical with respect to the ASCII encoding)
types.tex(,4558) 
types.tex(,4559) @item string_expression @code{[} int_expression @code{]}
types.tex(,4560) is a character of the string; the index 1 gives the first character.
types.tex(,4561) 
types.tex(,4562) @item string_expression @code{[} int_expression@code{,} int_expression @code{]}
types.tex(,4563) is a substring, where the first argument is the start index and the
types.tex(,4564) second is the length of the substring, filled up with blanks if the
types.tex(,4565) length exceeds the total size of the string
types.tex(,4566) 
types.tex(,4567) @item string_expression @code{[} intvec_expression @code{]}
types.tex(,4568) is a expression list of characters from the string
types.tex(,4569) @end table
types.tex(,4570) 
types.tex(,4571) @*@strong{Example:}
types.tex(,4572) @smallexample
types.tex(,4573) @c reused example string_operations types.doc:3745 
types.tex(,4574)   string s="abcde";
types.tex(,4575)   s[2];
types.tex(,4576) @expansion{} b
types.tex(,4577)   s[3,2];
types.tex(,4578) @expansion{} cd
types.tex(,4579)   ">>"+s[1,10]+"<<";
types.tex(,4580) @expansion{} >>abcde     <<
types.tex(,4581)   s[2]="BC"; s;
types.tex(,4582) @expansion{} aBcde
types.tex(,4583)   intvec v=1,3,5;
types.tex(,4584)   s=s[v]; s;
types.tex(,4585) @expansion{} ace
types.tex(,4586)   s="123456"; s=s[3..5]; s;
types.tex(,4587) @expansion{} 345
types.tex(,4588) @c end example string_operations types.doc:3745
types.tex(,4589) @end smallexample
types.tex(,4590) 
types.tex(,4591) @c ------------------------------
types.tex(,4592) @node string related functions,  , string operations, string
types.tex(,4593) @subsection string related functions
types.tex(,4594) @cindex string related functions
types.tex(,4595) 
types.tex(,4596) @table @code
types.tex(,4597) @item charstr
types.tex(,4598) description of the coefficient field of a ring (see @ref{charstr})
types.tex(,4599) @item execute
types.tex(,4600) executing string as command (see @ref{execute})
types.tex(,4601) @item find
types.tex(,4602) position of a substring in a string (see @ref{find})
types.tex(,4603) @item names
types.tex(,4604) list of strings of all user-defined variable names (see @ref{names})
types.tex(,4605) @item nameof
types.tex(,4606) name of an object (see @ref{nameof})
types.tex(,4607) @item option
types.tex(,4608) lists all defined options (see @ref{option})
types.tex(,4609) @item ordstr
types.tex(,4610) monomial ordering of a ring (see @ref{ordstr})
types.tex(,4611) @item parstr
types.tex(,4612) names of all ring parameters or the
types.tex(,4613) name of the n-th ring parameter (see @ref{parstr})
types.tex(,4614) @item read
types.tex(,4615) read a file (see @ref{read})
types.tex(,4616) @item size
types.tex(,4617) length of a string (see @ref{size})
types.tex(,4618) @item sprintf
types.tex(,4619) string formatting (see @ref{sprintf})
types.tex(,4620) @item typeof
types.tex(,4621) type of an object (see @ref{typeof})
types.tex(,4622) @item varstr
types.tex(,4623) names of all ring variables or the
types.tex(,4624) name of the n-th ring variable (see @ref{varstr})
types.tex(,4625) @end table
types.tex(,4626) 
types.tex(,4627) @c @*@strong{Example:}
types.tex(,4628) @c @example
types.tex(,4629) @c @end example
types.tex(,4630) 
types.tex(,4631) @c ---------------------------------------
types.tex(,4632) @node vector,  , string, Data types
types.tex(,4633) @section vector
types.tex(,4634) @cindex vector
types.tex(,4635) 
types.tex(,4636) Vectors are elements of a free module over the basering with basis
types.tex(,4637) @code{gen(1)}, @code{gen(2)}, @dots{} .
types.tex(,4638) Each vector belongs to a free module of rank equal to the biggest index
types.tex(,4639) of a generator with non-zero coefficient. Since generators with zero
types.tex(,4640) coefficients need not be written any vector may be considered
types.tex(,4641) also as an element of a free module of higher rank.
types.tex(,4642) Like polynomials they
types.tex(,4643) can only be defined or accessed with respect to the basering.
types.tex(,4644) (E.g., if @code{f} and @code{g} are polynomials then
types.tex(,4645) @code{f*gen(1)+g*gen(3)+gen(4)} may also be written as @code{[f,0,g,1]}
types.tex(,4646) or as @code{[f,0,g,1,0]}.) Note that the elements of a vector have to be
types.tex(,4647) surrounded by square brackets (@code{[}  , @code{]})
types.tex(,4648) (cf. @ref{Representation of mathematical objects}).
types.tex(,4649) 
types.tex(,4650) @menu
types.tex(,4651) * vector declarations::
types.tex(,4652) * vector expressions::
types.tex(,4653) * vector operations::
types.tex(,4654) * vector related functions::
types.tex(,4655) @end menu
types.tex(,4656) 
types.tex(,4657) @c ------------------------------
types.tex(,4658) @node vector declarations, vector expressions, vector, vector
types.tex(,4659) @subsection vector declarations
types.tex(,4660) @cindex vector declarations
types.tex(,4661) 
types.tex(,4662) @table @strong
types.tex(,4663) @item Syntax:
types.tex(,4664) @code{vector} name @code{=} vector_expression @code{;}
types.tex(,4665) 
types.tex(,4666) @item Purpose:
types.tex(,4667) defines a vector of polynomials (an element of a free module).
types.tex(,4668) 
types.tex(,4669) @item Default:
types.tex(,4670) [0]
types.tex(,4671) 
types.tex(,4672) @item Example:
types.tex(,4673) @smallexample
types.tex(,4674) @c reused example vector_declarations types.doc:3840 
types.tex(,4675)   ring r=0,(x,y,z),(c,dp);
types.tex(,4676)   poly s1 = x2;
types.tex(,4677)   poly s2 = y3;
types.tex(,4678)   poly s3 = z;
types.tex(,4679)   vector v = [s1, s2-s1, s3-s1]+ s1*gen(5);
types.tex(,4680)   // v is a vector in the free module of rank 5
types.tex(,4681)   v;
types.tex(,4682) @expansion{} [x2,y3-x2,-x2+z,0,x2]
types.tex(,4683) @c end example vector_declarations types.doc:3840
types.tex(,4684) @end smallexample
types.tex(,4685) @end table
types.tex(,4686) 
types.tex(,4687) @c ------------------------------
types.tex(,4688) @node vector expressions, vector operations, vector declarations, vector
types.tex(,4689) @subsection vector expressions
types.tex(,4690) @cindex vector expressions
types.tex(,4691) 
types.tex(,4692) A vector expression is:
types.tex(,4693) @enumerate
types.tex(,4694) @item
types.tex(,4695) an identifier of type vector
types.tex(,4696) @item
types.tex(,4697) a function returning vector
types.tex(,4698) @item
types.tex(,4699) a poly expression (via the canonical embedding @code{p} @expansion{} @code{p*gen(1)})
types.tex(,4700) @item
types.tex(,4701) vector expressions combined by the arithmetic operations @code{+} or
types.tex(,4702) @code{-}
types.tex(,4703) @item
types.tex(,4704) a poly expression and a vector expression combined by the arithmetic
types.tex(,4705) operation @code{*}
types.tex(,4706) @item
types.tex(,4707) a type cast to vector using the brackets @code{[} , @code{]}
types.tex(,4708) @end enumerate
types.tex(,4709) 
types.tex(,4710) @*@strong{Example:}
types.tex(,4711) @smallexample
types.tex(,4712) @c reused example vector_expressions types.doc:3877 
types.tex(,4713)   // ordering gives priority to components:
types.tex(,4714)   ring rr=0,(x,y,z),(c,dp);
types.tex(,4715)   vector v=[x2+y3,2,0,x*y]+gen(6)*x6;
types.tex(,4716)   v;
types.tex(,4717) @expansion{} [y3+x2,2,0,xy,0,x6]
types.tex(,4718)   vector w=[z3-x,3y];
types.tex(,4719)   v-w;
types.tex(,4720) @expansion{} [y3-z3+x2+x,-3y+2,0,xy,0,x6]
types.tex(,4721)   v*(z+x);
types.tex(,4722) @expansion{} [xy3+y3z+x3+x2z,2x+2z,0,x2y+xyz,0,x7+x6z]
types.tex(,4723) @c end example vector_expressions types.doc:3877
types.tex(,4724) @end smallexample
types.tex(,4725) 
types.tex(,4726) @c inserted refs from types.doc:3888
types.tex(,4739) @c end inserted refs from types.doc:3888
types.tex(,4740) 
types.tex(,4741) @c ------------------------------
types.tex(,4742) @node vector operations, vector related functions, vector expressions, vector
types.tex(,4743) @subsection vector operations
types.tex(,4744) @cindex vector operations
types.tex(,4745) 
types.tex(,4746) @table @asis
types.tex(,4747) @item @code{+}
types.tex(,4748) addition
types.tex(,4749) 
types.tex(,4750) @item @code{-}
types.tex(,4751) negation or subtraction
types.tex(,4752) 
types.tex(,4753) @item @code{/}
types.tex(,4754) division by a monomial, not divisible terms yield 0
types.tex(,4755) 
types.tex(,4756) @item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
types.tex(,4757) comparison of leading terms w.r.t. monomial ordering
types.tex(,4758) 
types.tex(,4759) @item vector_expression @code{[} int_expressions @code{]}
types.tex(,4760) is a vector entry; the index 1 gives the first entry.
types.tex(,4761) @end table
types.tex(,4762) 
types.tex(,4763) @*@strong{Example:}
types.tex(,4764) @smallexample
types.tex(,4765) @c reused example vector_operations types.doc:3918 
types.tex(,4766)   ring R=0,(x,y),(c,dp);
types.tex(,4767)   [x,y]-[1,x];
types.tex(,4768) @expansion{} [x-1,-x+y]
types.tex(,4769)   [1,2,x,4][3];
types.tex(,4770) @expansion{} x
types.tex(,4771) @c end example vector_operations types.doc:3918
types.tex(,4772) @end smallexample
types.tex(,4773) 
types.tex(,4774) 
types.tex(,4775) @c ------------------------------
types.tex(,4776) @node vector related functions,  , vector operations, vector
types.tex(,4777) @subsection vector related functions
types.tex(,4778) @cindex vector related functions
types.tex(,4779) 
types.tex(,4780) @table @code
types.tex(,4781) @item cleardenom
types.tex(,4782) quotient of a vector by its content (see @ref{cleardenom})
types.tex(,4783) @item coeffs
types.tex(,4784) matrix of coefficients (see @ref{coeffs})
types.tex(,4785) @item deg
types.tex(,4786) degree (see @ref{deg})
types.tex(,4787) @item diff
types.tex(,4788) partial derivative (see @ref{diff})
types.tex(,4789) @item gen
types.tex(,4790) i-th generator (see @ref{gen})
types.tex(,4791) @item homog
types.tex(,4792) homogenization (see @ref{homog})
types.tex(,4793) @item jet
types.tex(,4794) k-jet: monomials with degree smaller k+1 (see @ref{jet})
types.tex(,4795) @item lead
types.tex(,4796) leading term (see @ref{lead})
types.tex(,4797) @item leadcoef
types.tex(,4798) leading coefficient (see @ref{leadcoef})
types.tex(,4799) @item leadexp
types.tex(,4800) the exponent vector of the leading monomial (see @ref{leadexp})
types.tex(,4801) @item leadmonom
types.tex(,4802) leading monomial (see @ref{leadmonom})
types.tex(,4803) @item nrows
types.tex(,4804) number of rows (see @ref{nrows})
types.tex(,4805) @item ord
types.tex(,4806) degree of the leading monomial (see @ref{ord})
types.tex(,4807) @item reduce
types.tex(,4808) normal form with respect to a standard base (see @ref{reduce})
types.tex(,4809) @item simplify
types.tex(,4810) normalize a vector (see @ref{simplify})
types.tex(,4811) @item size
types.tex(,4812) number of monomials (see @ref{size})
types.tex(,4813) @item subst
types.tex(,4814) substitute a ring variable (see @ref{subst})
types.tex(,4815) @end table
types.tex(,4816) 
types.tex(,4817) @c @*@strong{Example:}
types.tex(,4818) @c @example
types.tex(,4819) @c @end example
singular.texi(,139) 
singular.texi(,140) @c ----------------------------------------------------------------------------
singular.texi(,141) @node Functions and system variables, Tricks and pitfalls, Data types, Top
singular.texi(,142) @chapter Functions and system variables
singular.texi(,143) @cindex Commands
reference.tex(,1) @comment -*-texinfo-*-
reference.tex(,2) @comment This file was generated by doc2tex.pl from reference.doc
reference.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT reference.doc INSTEAD
reference.tex(,4) @comment Id: reference.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
reference.tex(,5) @comment this file contains the reference part of the manual
reference.tex(,6) 
reference.tex(,7) @c The following directives are necessary for proper compilation
reference.tex(,8) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
reference.tex(,9) @c is wrapped in `@ifset' and `@end' it does not harm `tex' or
reference.tex(,10) @c `makeinfo' but is a great help in editing this file (emacs
reference.tex(,11) @c ignores the conditionals).
reference.tex(,24) 
reference.tex(,25) @c ---------------------------------------
reference.tex(,26) @menu
reference.tex(,27) * Functions::
reference.tex(,28) * Control structures::
reference.tex(,29) * System variables::
reference.tex(,30) @end menu
reference.tex(,31) 
reference.tex(,32) @c ---------------------------------------
reference.tex(,33) @node Functions, Control structures, Functions and system variables, Functions and system variables
reference.tex(,34) @section Functions
reference.tex(,35) @cindex Functions
reference.tex(,36) 
reference.tex(,37) This section gives a complete reference of all functions, commands and
reference.tex(,38) special variables of the @sc{Singular} kernel (i.e., all built-in
reference.tex(,39) commands). @xref{standard_lib}, for those
reference.tex(,40) functions from the @code{standard.lib} (this library is automatically
reference.tex(,41) loaded at start-up time) which extend the functionality of the kernel
reference.tex(,42) and are written
reference.tex(,43) in the  @sc{Singular} programming language.
reference.tex(,44) 
reference.tex(,45) The general syntax of a function is
reference.tex(,46) @format
reference.tex(,47)                    [target =] function_name (<arguments>);
reference.tex(,48) @end format
reference.tex(,49) If no target is specified, the result is printed.
reference.tex(,50) In some cases (e.g., @code{export}, @code{keepring}, @code{kill},
reference.tex(,51) @code{setring}, @code{type}) the brackets are optional. For the commands
reference.tex(,52) @code{help}, @code{break}, @code{quit}, @code{exit} and @code{LIB} no
reference.tex(,53) brackets are allowed.
reference.tex(,54) 
reference.tex(,58) @menu
reference.tex(,59) * attrib::
reference.tex(,60) * bareiss::
reference.tex(,61) * betti::
reference.tex(,62) * char::
reference.tex(,63) * char_series::
reference.tex(,64) * charstr::
reference.tex(,65) * cleardenom::
reference.tex(,66) * close::
reference.tex(,67) * coef::
reference.tex(,68) * coeffs::
reference.tex(,69) * contract::
reference.tex(,70) * dbprint::
reference.tex(,71) * defined::
reference.tex(,72) * deg::
reference.tex(,73) * degree::
reference.tex(,74) * delete::
reference.tex(,75) * det::
reference.tex(,76) * diff::
reference.tex(,77) * dim::
reference.tex(,78) * division::
reference.tex(,79) * dump::
reference.tex(,80) * eliminate::
reference.tex(,81) * eval::
reference.tex(,82) * ERROR::
reference.tex(,83) * example::
reference.tex(,84) * execute::
reference.tex(,85) * exit::
reference.tex(,86) * extgcd::
reference.tex(,87) * facstd::
reference.tex(,88) * factorize::
reference.tex(,89) * fetch::
reference.tex(,90) * fglm::
reference.tex(,91) * fglmquot::
reference.tex(,92) * filecmd::
reference.tex(,93) * find::
reference.tex(,94) * finduni::
reference.tex(,95) * fprintf::
reference.tex(,96) * freemodule::
reference.tex(,97) * gcd::
reference.tex(,98) * gen::
reference.tex(,99) * getdump::
reference.tex(,100) * groebner::
reference.tex(,101) * help::
reference.tex(,102) * highcorner::
reference.tex(,103) * hilb::
reference.tex(,104) * homog::
reference.tex(,105) * hres::
reference.tex(,106) * imap::
reference.tex(,107) * impart::
reference.tex(,108) * indepSet::
reference.tex(,109) * insert::
reference.tex(,110) * interred::
reference.tex(,111) * intersect::
reference.tex(,112) * jacob::
reference.tex(,113) * jet::
reference.tex(,114) * kbase::
reference.tex(,115) * kill::
reference.tex(,116) * killattrib::
reference.tex(,117) * koszul::
reference.tex(,118) * laguerre::
reference.tex(,119) * lead::
reference.tex(,120) * leadcoef::
reference.tex(,121) * leadexp::
reference.tex(,122) * leadmonom::
reference.tex(,123) * LIB::
reference.tex(,124) * lift::
reference.tex(,125) * liftstd::
reference.tex(,126) * listvar::
reference.tex(,127) * lres::
reference.tex(,128) * maxideal::
reference.tex(,129) * memory::
reference.tex(,130) * minbase::
reference.tex(,131) * minor::
reference.tex(,132) * minres::
reference.tex(,133) * modulo::
reference.tex(,134) * monitor::
reference.tex(,135) * mpresmat::
reference.tex(,136) * mres::
reference.tex(,137) * mstd::
reference.tex(,138) * mult::
reference.tex(,139) * nameof::
reference.tex(,140) * names::
reference.tex(,141) * ncols::
reference.tex(,142) * npars::
reference.tex(,143) * nres::
reference.tex(,144) * nrows::
reference.tex(,145) * nvars::
reference.tex(,146) * open::
reference.tex(,147) * option::
reference.tex(,148) * ord::
reference.tex(,149) * ordstr::
reference.tex(,150) * par::
reference.tex(,151) * pardeg::
reference.tex(,152) * parstr::
reference.tex(,153) * preimage::
reference.tex(,154) * prime::
reference.tex(,155) * print::
reference.tex(,156) * printf::
reference.tex(,157) * prune::
reference.tex(,158) * qhweight::
reference.tex(,159) * quot::
reference.tex(,160) * quote::
reference.tex(,161) * quotient::
reference.tex(,162) * random::
reference.tex(,163) * read::
reference.tex(,164) * reduce::
reference.tex(,165) * regularity::
reference.tex(,166) * repart::
reference.tex(,167) * res::
reference.tex(,168) * reservedName::
reference.tex(,169) * resultant::
reference.tex(,170) * rvar::
reference.tex(,171) * setring::
reference.tex(,172) * simplex::
reference.tex(,173) * simplify::
reference.tex(,174) * size::
reference.tex(,175) * sortvec::
reference.tex(,176) * sprintf::
reference.tex(,177) * sres::
reference.tex(,178) * status::
reference.tex(,179) * std::
reference.tex(,180) * stdfglm::
reference.tex(,181) * stdhilb::
reference.tex(,182) * subst::
reference.tex(,183) * system::
reference.tex(,184) * syz::
reference.tex(,185) * trace::
reference.tex(,186) * transpose::
reference.tex(,187) * type::
reference.tex(,188) * typeof::
reference.tex(,189) * uressolve::
reference.tex(,190) * vandermonde::
reference.tex(,191) * var::
reference.tex(,192) * varstr::
reference.tex(,193) * vdim::
reference.tex(,194) * wedge::
reference.tex(,195) * weight::
reference.tex(,196) * write::
reference.tex(,197) @end menu
reference.tex(,198) @c ---------------------------------------
reference.tex(,199) @node attrib, bareiss, Functions, Functions
reference.tex(,200) @subsection attrib
reference.tex(,201) @cindex attrib
reference.tex(,202) @table @code
reference.tex(,203) @item @strong{Syntax:}
reference.tex(,204) @code{attrib (} name @code{)}
reference.tex(,205) @item @strong{Type:}
reference.tex(,206) none
reference.tex(,207) @item @strong{Purpose:}
reference.tex(,208) displays the attribute list of the object called name.
reference.tex(,209) @item @strong{Example:}
reference.tex(,210) @smallexample
reference.tex(,211) @c reused example attrib reference.doc:209 
reference.tex(,212)   ring r=0,(x,y,z),dp;
reference.tex(,213)   ideal I=std(maxideal(2));
reference.tex(,214)   attrib(I);
reference.tex(,215) @expansion{} attr:isSB, type int
reference.tex(,216) @c end example attrib reference.doc:209
reference.tex(,217) @end smallexample
reference.tex(,218) @item @strong{Syntax:}
reference.tex(,219) @code{attrib (} name @code{,} string_expression @code{)}
reference.tex(,220) @item @strong{Type:}
reference.tex(,221) any
reference.tex(,222) @item @strong{Purpose:}
reference.tex(,223) returns the value of the attribute string_expression of the
reference.tex(,224) variable name. If the attribute is not defined for this variable,
reference.tex(,225) @code{attrib} returns the empty string.
reference.tex(,226) @item @strong{Example:}
reference.tex(,227) @smallexample
reference.tex(,228) @c reused example attrib_1 reference.doc:225 
reference.tex(,229)   ring r=0,(x,y,z),dp;
reference.tex(,230)   ideal I=std(maxideal(2));
reference.tex(,231)   attrib(I,"isSB");
reference.tex(,232) @expansion{} 1
reference.tex(,233)   // although maxideal(2) is a standard basis,
reference.tex(,234)   // SINGULAR does not know it:
reference.tex(,235)   attrib(maxideal(2), "isSB");
reference.tex(,236) @expansion{} 0
reference.tex(,237) @c end example attrib_1 reference.doc:225
reference.tex(,238) @end smallexample
reference.tex(,239) @item @strong{Syntax:}
reference.tex(,240) @code{attrib (} name@code{,} string_expression@code{,} expression @code{)}
reference.tex(,241) @item @strong{Type:}
reference.tex(,242) none
reference.tex(,243) @item @strong{Purpose:}
reference.tex(,244) sets the attribute string_expression of the variable name
reference.tex(,245) to the value expression.
reference.tex(,246) @item @strong{Example:}
reference.tex(,247) @smallexample
reference.tex(,248) @c reused example attrib_2 reference.doc:243 
reference.tex(,249)   ring r=0,(x,y,z),dp;
reference.tex(,250)   ideal I=maxideal(2); // the attribute "isSB" is not set
reference.tex(,251)   vdim(I);
reference.tex(,252) @expansion{} // ** I is no standardbasis
reference.tex(,253) @expansion{} 4
reference.tex(,254)   attrib(I,"isSB",1);  // the standard basis attribute is set here
reference.tex(,255)   vdim(I);
reference.tex(,256) @expansion{} 4
reference.tex(,257) @c end example attrib_2 reference.doc:243
reference.tex(,258) @end smallexample
reference.tex(,259) @item @strong{Remark:}
reference.tex(,260) An attribute may be described by any string_expression. Some of these are
reference.tex(,261) used by the kernel of @sc{Singular} and referred to as reserved attributes.
reference.tex(,262) Non-reserved attributes may be used, however, in procedures and can
reference.tex(,263) considerably speed up computations.
reference.tex(,264) @sp 1
reference.tex(,265) @item @strong{Reserved attributes:}
reference.tex(,266) (not all are in use at the moment)
reference.tex(,267) @table @code
reference.tex(,268) @item isSB
reference.tex(,269) the standard basis property is set by all commands computing a standard
reference.tex(,270) basis like
reference.tex(,271) @code{groebner}, @code{std}, @code{stdhilb} etc.; used by @code{lift}, @code{dim},
reference.tex(,272) @code{degree}, @code{mult}, @code{hilb}, @code{vdim}, @code{kbase}
reference.tex(,273) @item isHomog
reference.tex(,274) the weight vector for homogeneous or quasihomogeneous ideals/modules
reference.tex(,275) @item isCI
reference.tex(,276) complete intersection property
reference.tex(,277) @item isCM
reference.tex(,278) Cohen-Macaulay property
reference.tex(,279) @item rank
reference.tex(,280) set the rank of a module (see @ref{nrows})
reference.tex(,281) @item withSB
reference.tex(,282) value of type ideal, resp.@: module, is std
reference.tex(,283) @item withHilb
reference.tex(,284) value of type intvec is hilb(_,1) (see @ref{hilb})
reference.tex(,285) @item withRes
reference.tex(,286) value of type list is a free resolution
reference.tex(,287) @item withDim
reference.tex(,288) value of type int is the dimension (see @ref{dim})
reference.tex(,289) @item withMult
reference.tex(,290) value of type int is the multiplicity (see @ref{mult})
reference.tex(,291) @c @item @code{D}
reference.tex(,292) @c object is an differential operator, if set to 1;
reference.tex(,293) @c @*object is in a module, if set to 0
reference.tex(,294) @c @*only valid in a dring (see @ref{dring}).
reference.tex(,295) @end table
reference.tex(,296) @end table
reference.tex(,297) @c @c ref
reference.tex(,298) @c See
reference.tex(,299) @c @ref{Expressions};
reference.tex(,300) @c @ref{killattrib}.
reference.tex(,301) @c @c ref
reference.tex(,302) @c ---------------------------------------
reference.tex(,303) @node bareiss, betti, attrib, Functions
reference.tex(,304) @subsection bareiss
reference.tex(,305) @cindex bareiss
reference.tex(,306) 
reference.tex(,307) @table @code
reference.tex(,308) @item @strong{Syntax:}
reference.tex(,309) @code{bareiss (} module_expression @code{)}
reference.tex(,310) @*@code{bareiss (} matrix_expression @code{)}
reference.tex(,311) @*@code{bareiss (} module_expression@code{,} int_expression@code{,} int_expression @code{)}
reference.tex(,312) @*@code{bareiss (} matrix_expression@code{,} int_expression@code{,} int_expression @code{)}
reference.tex(,313) @item @strong{Type:}
reference.tex(,314) list of module and intvec
reference.tex(,315) @item @strong{Purpose:}
reference.tex(,316) applies the sparse Gauss-Bareiss algorithm (see @ref{References}, Lee and
reference.tex(,317) Saunders) to a module (or with type conversion to a matrix) with an 'optimal'
reference.tex(,318) pivot strategy. The vectors of the module are the columns of the matrix,
reference.tex(,319) hence elimination takes place w.r.t.@: rows.
reference.tex(,320) @* With only one parameter a complete elimination is done.
reference.tex(,321) Result is a list: the first entry is a module with a minimal independent set
reference.tex(,322) of vectors (as a matrix lower triangular),
reference.tex(,323) the second entry an intvec with the permutation of the rows
reference.tex(,324) w.r.t.@: the original matrix, that is, a k at position l indicates that
reference.tex(,325) row l became row k.
reference.tex(,326) @* The further parameters control the algorithm. @code{bareiss(M,i,j)}
reference.tex(,327) does not consider the last i rows in the elimination procedure and stops
reference.tex(,328) computing when the remaining number of vectors (columns) to reduce is at
reference.tex(,329) most j.
reference.tex(,330) @item @strong{Example:}
reference.tex(,331) @smallexample
reference.tex(,332) @c reused example bareiss reference.doc:324 
reference.tex(,333)   ring r=0,(x,y,z),(c,dp);
reference.tex(,334)   module mm;
reference.tex(,335)   // ** generation of the module mm **
reference.tex(,336)   int d=7;
reference.tex(,337)   int b=2;
reference.tex(,338)   int db=d-b;
reference.tex(,339)   int i;
reference.tex(,340)   for(i=d;i>0;i--)@{ mm[i]=3*x*gen(i); @}
reference.tex(,341)   for(i=db;i;i--)@{ mm[i]=mm[i]+7*y*gen(i+b); @}
reference.tex(,342)   for(i=d;i>db;i--)@{ mm[i]=mm[i]+7*y*gen(i-db); @}
reference.tex(,343)   for(i=d;i>b;i--)@{ mm[i]=mm[i]+11*z*gen(i-b); @}
reference.tex(,344)   for(i=b;i;i--)@{ mm[i]=mm[i]+11*z*gen(i+db); @}
reference.tex(,345)   // ** the generating matrix of mm **
reference.tex(,346)   print(mm);
reference.tex(,347) @expansion{} 3x, 0,  11z,0,  0,  7y, 0,  
reference.tex(,348) @expansion{} 0,  3x, 0,  11z,0,  0,  7y, 
reference.tex(,349) @expansion{} 7y, 0,  3x, 0,  11z,0,  0,  
reference.tex(,350) @expansion{} 0,  7y, 0,  3x, 0,  11z,0,  
reference.tex(,351) @expansion{} 0,  0,  7y, 0,  3x, 0,  11z,
reference.tex(,352) @expansion{} 11z,0,  0,  7y, 0,  3x, 0,  
reference.tex(,353) @expansion{} 0,  11z,0,  0,  7y, 0,  3x  
reference.tex(,354)   // complete elimination
reference.tex(,355)   list ss=bareiss(mm);
reference.tex(,356)   print(ss[1]);
reference.tex(,357) @expansion{} 7y, 0,     0,     0,      0,        0,     0,    
reference.tex(,358) @expansion{} 3x, -33xz, 0,     0,      0,        0,     0,    
reference.tex(,359) @expansion{} 11z,-121z2,1331z3,0,      0,        0,     0,    
reference.tex(,360) @expansion{} 0,  0,     0,     9317yz3,0,        0,     0,    
reference.tex(,361) @expansion{} 0,  21xy,  _[5,3],14641z4,-43923xz4,0,     0,    
reference.tex(,362) @expansion{} 0,  0,     0,     0,      65219y2z3,_[6,6],0,    
reference.tex(,363) @expansion{} 0,  49y2,  _[7,3],3993xz3,_[7,5],   _[7,6],_[7,7]
reference.tex(,364)   ss[2];
reference.tex(,365) @expansion{} 2,7,5,1,4,3,6
reference.tex(,366)   // elimination up to 3 vectors
reference.tex(,367)   ss=bareiss(mm,0,3);
reference.tex(,368)   print(ss[1]);
reference.tex(,369) @expansion{} 7y, 0,     0,     0,      0,        0,        0,        
reference.tex(,370) @expansion{} 3x, -33xz, 0,     0,      0,        0,        0,        
reference.tex(,371) @expansion{} 11z,-121z2,1331z3,0,      0,        0,        0,        
reference.tex(,372) @expansion{} 0,  0,     0,     9317yz3,0,        0,        0,        
reference.tex(,373) @expansion{} 0,  0,     0,     0,      27951xyz3,102487yz4,65219y2z3,
reference.tex(,374) @expansion{} 0,  21xy,  _[6,3],14641z4,_[6,5],   _[6,6],   -43923xz4,
reference.tex(,375) @expansion{} 0,  49y2,  _[7,3],3993xz3,_[7,5],   _[7,6],   _[7,7]    
reference.tex(,376)   ss[2];
reference.tex(,377) @expansion{} 2,7,5,1,3,4,6
reference.tex(,378)   // elimination without the last 3 rows
reference.tex(,379)   ss=bareiss(mm,3,0);
reference.tex(,380)   print(ss[1]);
reference.tex(,381) @expansion{} 7y, 0,   0,      0,       0,     0,     0,       
reference.tex(,382) @expansion{} 0,  77yz,0,      0,       0,     0,     0,       
reference.tex(,383) @expansion{} 0,  0,   231xyz, 0,       0,     0,     0,       
reference.tex(,384) @expansion{} 0,  0,   0,      1617xy2z,0,     0,     0,       
reference.tex(,385) @expansion{} 11z,21xy,-1331z3,14641z4, _[5,5],_[5,6],_[5,7],  
reference.tex(,386) @expansion{} 0,  0,   539y2z, _[6,4],  _[6,5],_[6,6],-3773y3z,
reference.tex(,387) @expansion{} 3x, 49y2,-363xz2,3993xz3, _[7,5],_[7,6],_[7,7]   
reference.tex(,388)   ss[2];
reference.tex(,389) @expansion{} 2,3,4,1
reference.tex(,390) @c end example bareiss reference.doc:324
reference.tex(,391) @end smallexample
reference.tex(,392) @end table
reference.tex(,393) @c inserted refs from reference.doc:354
reference.tex(,406) @c end inserted refs from reference.doc:354
reference.tex(,407) @c ---------------------------------------
reference.tex(,408) @node betti, char, bareiss, Functions
reference.tex(,409) @subsection betti
reference.tex(,410) @cindex betti
reference.tex(,411) @table @code
reference.tex(,412) @item @strong{Syntax:}
reference.tex(,413) @code{betti (} list_expression @code{)}
reference.tex(,414) @*@code{betti (} resolution_expression @code{)}
reference.tex(,415) @*@code{betti (} list_expression @code{,} int_expression @code{)}
reference.tex(,416) @*@code{betti (} resolution_expression @code{,} int_expression @code{)}
reference.tex(,417) @item @strong{Type:}
reference.tex(,418) intmat
reference.tex(,419) @item @strong{Purpose:}
reference.tex(,420) with 1 argument: computes the graded Betti numbers of a minimal resolution of
reference.tex(,445) The argument is considered to be the result of a res/sres/mres/nres/lres
reference.tex(,446) command. This implies that a zero is only allowed (and counted) as a
reference.tex(,447) generator in the first module.
reference.tex(,448) @*For the computation betti uses only the initial monomials. This could lead
reference.tex(,449) to confusing results for a non-homogeneous input.
reference.tex(,450) 
reference.tex(,451) The optional second argument is a switch for the minimization of the Betti
reference.tex(,452) numbers. If it is 0 then the Betti numbers correspond exactly to the input -
reference.tex(,453) otherwise the command is identical to the one-argument form.
reference.tex(,454) @item @strong{Example:}
reference.tex(,455) @smallexample
reference.tex(,456) @c reused example betti reference.doc:408 
reference.tex(,457)   ring r=32003,(a,b,c,d),dp;
reference.tex(,458)   ideal j=bc-ad,b3-a2c,c3-bd2,ac2-b2d;
reference.tex(,459)   list T=mres(j,0); // 0 forces a full resolution
reference.tex(,460)   // a minimal set of generators for j:
reference.tex(,461)   print(T[1]);
reference.tex(,462) @expansion{} bc-ad,
reference.tex(,463) @expansion{} c3-bd2,
reference.tex(,464) @expansion{} ac2-b2d,
reference.tex(,465) @expansion{} b3-a2c
reference.tex(,466)   // second syzygy module of r/j which is the first
reference.tex(,467)   // syzygy module of j (minimal generating set):
reference.tex(,468)   print(T[2]);
reference.tex(,469) @expansion{} bd,c2,ac,b2,
reference.tex(,470) @expansion{} -a,-b,0, 0, 
reference.tex(,471) @expansion{} c, d, -b,-a,
reference.tex(,472) @expansion{} 0, 0, -d,-c 
reference.tex(,473)   // the second syzygy module (minimal generating set):
reference.tex(,474)   print(T[3]);
reference.tex(,475) @expansion{} -b,
reference.tex(,476) @expansion{} a, 
reference.tex(,477) @expansion{} -c,
reference.tex(,478) @expansion{} d  
reference.tex(,479)   print(T[4]);
reference.tex(,480) @expansion{} 0
reference.tex(,481)   betti(T);
reference.tex(,482) @expansion{} 1,0,0,0,
reference.tex(,483) @expansion{} 0,1,0,0,
reference.tex(,484) @expansion{} 0,3,4,1 
reference.tex(,485)   // most useful for reading off the graded Betti numbers:
reference.tex(,486)   print(betti(T),"betti");
reference.tex(,487) @expansion{}            0     1     2     3
reference.tex(,488) @expansion{} ------------------------------
reference.tex(,489) @expansion{}     0:     1     -     -     -
reference.tex(,490) @expansion{}     1:     -     1     -     -
reference.tex(,491) @expansion{}     2:     -     3     4     1
reference.tex(,492) @expansion{} ------------------------------
reference.tex(,493) @expansion{} total:     1     4     4     1
reference.tex(,494) @c end example betti reference.doc:408
reference.tex(,495) @end smallexample
reference.tex(,496) @end table
reference.tex(,497) 
reference.tex(,498) Hence
reference.tex(,499) @itemize @bullet
reference.tex(,500) @item the 0th syzygy module of r/j (which is r) has 1 generator in
reference.tex(,501) degree 0 (which is 1),
reference.tex(,502) @item the 1st syzygy module @code{T[1]} (which is j) has 4
reference.tex(,503) generators (one in degree 2 and three in degree 3),
reference.tex(,504) @item the 2nd syzygy
reference.tex(,505) module @code{T[2]} has 4 generators (all in degree 4),
reference.tex(,506) @item the 3rd syzygy module @code{T[3]} has
reference.tex(,507) 1 generator in degree 5,
reference.tex(,508) @end itemize
reference.tex(,509) where the generators are the columns of the
reference.tex(,510) displayed matrix and degrees are assigned such that the corresponding maps
reference.tex(,511) have degree 0:
reference.tex(,525) 
reference.tex(,526) @c inserted refs from reference.doc:455
reference.tex(,551) @c end inserted refs from reference.doc:455
reference.tex(,552) @c ---------------------------------------
reference.tex(,553) @node char, char_series, betti, Functions
reference.tex(,554) @subsection char
reference.tex(,555) @cindex char
reference.tex(,556) 
reference.tex(,557) @table @code
reference.tex(,558) @item @strong{Syntax:}
reference.tex(,559) @code{char (} ring_name @code{)}
reference.tex(,560) @item @strong{Type:}
reference.tex(,561) int
reference.tex(,562) @item @strong{Purpose:}
reference.tex(,563) returns the characteristic of the coefficient field of a ring.
reference.tex(,564) @item @strong{Example:}
reference.tex(,565) @smallexample
reference.tex(,566) @c reused example char reference.doc:480 
reference.tex(,567)   ring r=32003,(x,y),dp;
reference.tex(,568)   char(r);
reference.tex(,569) @expansion{} 32003
reference.tex(,570)   ring s=0,(x,y),dp;
reference.tex(,571)   char(s);
reference.tex(,572) @expansion{} 0
reference.tex(,573)   ring ra=(7,a),(x,y),dp;
reference.tex(,574)   minpoly=a^3+a+1;
reference.tex(,575)   char(ra);
reference.tex(,576) @expansion{} 7
reference.tex(,577)   ring rp=(49,a),(x,y),dp;
reference.tex(,578)   char(rp);
reference.tex(,579) @expansion{} 7
reference.tex(,580)   ring rr=real,x,dp;
reference.tex(,581)   char(rr);
reference.tex(,582) @expansion{} 0
reference.tex(,583) @c end example char reference.doc:480
reference.tex(,584) @end smallexample
reference.tex(,585) @end table
reference.tex(,586) @c inserted refs from reference.doc:495
reference.tex(,599) @c end inserted refs from reference.doc:495
reference.tex(,600) @c ---------------------------------------
reference.tex(,601) @node char_series, charstr, char, Functions
reference.tex(,602) @subsection char_series
reference.tex(,603) @cindex char_series
reference.tex(,604) 
reference.tex(,605) @table @code
reference.tex(,606) @item @strong{Syntax:}
reference.tex(,607) @code{char_series (} ideal_expression @code{)}
reference.tex(,608) @item @strong{Type:}
reference.tex(,609) matrix
reference.tex(,610) @item @strong{Purpose:}
reference.tex(,611) the rows of the matrix represent the irreducible characteristic series of the
reference.tex(,612) ideal with respect to the current ordering of variables.
reference.tex(,613) @*One application is the decomposition of the zero-set.
reference.tex(,614) @item @strong{Example:}
reference.tex(,615) @smallexample
reference.tex(,616) @c reused example char_series reference.doc:516 
reference.tex(,617)   ring r=32003,(x,y,z),dp;
reference.tex(,618)   print(char_series(ideal(xyz,xz,y)));
reference.tex(,619) @expansion{} y,z,
reference.tex(,620) @expansion{} x,y 
reference.tex(,621) @c end example char_series reference.doc:516
reference.tex(,622) @end smallexample
reference.tex(,623) @c @item @strong{Background:}
reference.tex(,624) @c @tex
reference.tex(,625) @c Let $>$ be the lexicographical ordering $x_1 < ... < x_n$ on $R=K[x_1,...,x_n]$.
reference.tex(,626) @c For $f \in R$ let lvar(f) (the leading variable of f) be the largest
reference.tex(,627) @c variable in lead(f) (the leading term of f with respect to $>$),
reference.tex(,628) @c i.e., if $f=a_k(x_1,...,x_{k-1})x_k^s+...+a_0(x_1,...,x_{k-1})$ for some
reference.tex(,629) @c $k \leq n$ then $lvar(f)=x_k$, moreover let $ini(f):=a_k(x_1,...,x_{k-1})$.
reference.tex(,630) @c
reference.tex(,631) @c A set $T=\{f_1,...,f_r\} \subset R$ is called triangular if $lvar(f_1)<...<lvar(f_r)$.
reference.tex(,632) @c The pseudo remainder $r=prem(g,f)$ of $g$ with respect to $f$ is defined by
reference.tex(,633) @c $ini(f)^a*g=q*f+r$ with the property $deg_{lvar(f)}(r)<deg_{lvar(f)}(f)$,
reference.tex(,634) @c a minimal.
reference.tex(,635) @c
reference.tex(,636) @c (T,U) is called a triangular system, if T is a triangular set such that ini(T)
reference.tex(,637) @c does not vanish on $Zero(T) \setminus Zero(U)
reference.tex(,638) @c ( =:Zero(T\setminus U))$.
reference.tex(,639) @c
reference.tex(,640) @c T is called irreducible if for every i there are no $d_i$,$f_i'$,$f_i''$ with
reference.tex(,641) @c the property:
reference.tex(,642) @c $$   lvar(d_i)<lvar(f_i) $$
reference.tex(,643) @c $$   lvar(f_i')=lvar(f_i'')=lvar(f_i)$$
reference.tex(,644) @c $$   0 \not\in prem(\{ d_i, ini(f_i'), ini(f_i'')\},\{ f_1,...,f_(i-1)\})$$
reference.tex(,645) @c such that $prem(d_i*f_i-f_i'*f_i'',\{f_1,...,f_(i-1)\})=0$.
reference.tex(,646) @c
reference.tex(,647) @c (T,U) is irreducible if T is irreducible.
reference.tex(,648) @c
reference.tex(,649) @c Let $G=\{g_1,...,g_s\}$ then there are irreducible triangular sets $T_1,...,T_l$
reference.tex(,650) @c such that $Zero(G)=\bigcup(i=1..l: Zero(T_i\setminus I_i))$
reference.tex(,651) @c where $I_i=\{ini(f), f \in T_i \}$.
reference.tex(,652) @c @end tex
reference.tex(,653) @c @ifinfo
reference.tex(,654) @c Let > be the lexicographical ordering x_1 < ... < x_n on R=K[x_1,...,x_n].
reference.tex(,655) @c For f in R let lvar(f) (the leading variable of f) be the largest
reference.tex(,656) @c variable in lead(f) (the leading term of f with respect to >),
reference.tex(,657) @c i.e., if f=a_k(x_1,...,x_(k-1))x_k^s+...+a_0(x_1,...,x_(k-1)) for some
reference.tex(,658) @c k<=n then lvar(f)=x_k, moreover let ini(f):=a_k(x_1,...,x_(k-1)).
reference.tex(,659) @c
reference.tex(,660) @c A set T=@{f_1,...,f_r@} in R is called triangular if lvar(f_1)<...<lvar(f_r).
reference.tex(,661) @c The pseudo remainder r=prem(g,f) of g with respect to f is defined by
reference.tex(,662) @c ini(f)^a*g=q*f+r with the property deg_(lvar(f))(r)<deg_(lvar(f))(f),s
reference.tex(,663) @c a minimal.
reference.tex(,664) @c
reference.tex(,665) @c (T,U) is called a triangular system, if T is a triangular set such that ini(T)
reference.tex(,666) @c does not vanish on the zero-set of T \ zero-set of U
reference.tex(,667) @c ( =:Zero(T\U)).
reference.tex(,668) @c
reference.tex(,669) @c T is called irreducible if for every i there are no d_i,f_i',f_i'' with
reference.tex(,670) @c the property:
reference.tex(,671) @c @*   lvar(d_i)<lvar(f_i)
reference.tex(,672) @c @*   lvar(f_i')=lvar(f_i'')=lvar(f_i)
reference.tex(,673) @c @*   0 not in prem(@{ d_i, ini(f_i'), ini(f_i'')@},@{ f_1,...,f_(i-1)@})
reference.tex(,674) @c @*such that prem(d_i*f_i-f_i'*f_i'',@{f_1,...,f_(i-1)@})=0.
reference.tex(,675) @c
reference.tex(,676) @c (T,U) is irreducible if T is irreducible.
reference.tex(,677) @c
reference.tex(,678) @c Let G=@{g_1,...,g_s@} then there are irreducible triangular sets T_1,...,T_l
reference.tex(,679) @c such that Zero(G)=Union(i=1..l: Zero(T_i\I_i))
reference.tex(,680) @c where I_i=@{ini(f), f in T_i @}.
reference.tex(,681) @c @end ifinfo
reference.tex(,682) @c @item @strong{Example:}
reference.tex(,683) @c @example
reference.tex(,684) @c @c example
reference.tex(,685) @c   ring R=0,(x,y,z,u),dp;
reference.tex(,686) @c   ideal i=-3zu+y2-2x+2,
reference.tex(,687) @c           -3x2u-4yz-6xz+2y2+3xy,
reference.tex(,688) @c           -3z2u-xu+y2z+y;
reference.tex(,689) @c   print(char_series(i));
reference.tex(,690) @c @c example
reference.tex(,691) @c @end example
reference.tex(,692) @end table
reference.tex(,693) 
reference.tex(,694) @c inserted refs from reference.doc:592
reference.tex(,705) @c end inserted refs from reference.doc:592
reference.tex(,706) @c ---------------------------------------
reference.tex(,707) @node charstr, cleardenom, char_series, Functions
reference.tex(,708) @subsection charstr
reference.tex(,709) @cindex charstr
reference.tex(,710) 
reference.tex(,711) @table @code
reference.tex(,712) @item @strong{Syntax:}
reference.tex(,713) @code{charstr (} ring_name @code{)}
reference.tex(,714) @item @strong{Type:}
reference.tex(,715) string
reference.tex(,716) @item @strong{Purpose:}
reference.tex(,717) returns the description of the coefficient field of a ring.
reference.tex(,718) @item @strong{Example:}
reference.tex(,719) @smallexample
reference.tex(,720) @c reused example charstr reference.doc:610 
reference.tex(,721)   ring r=32003,(x,y),dp;
reference.tex(,722)   charstr(r);
reference.tex(,723) @expansion{} 32003
reference.tex(,724)   ring s=0,(x,y),dp;
reference.tex(,725)   charstr(s);
reference.tex(,726) @expansion{} 0
reference.tex(,727)   ring ra=(7,a),(x,y),dp;
reference.tex(,728)   minpoly=a^3+a+1;
reference.tex(,729)   charstr(ra);
reference.tex(,730) @expansion{} 7,a
reference.tex(,731)   ring rp=(49,a),(x,y),dp;
reference.tex(,732)   charstr(rp);
reference.tex(,733) @expansion{} 49,a
reference.tex(,734)   ring rr=real,x,dp;
reference.tex(,735)   charstr(rr);
reference.tex(,736) @expansion{} real
reference.tex(,737) @c end example charstr reference.doc:610
reference.tex(,738) @end smallexample
reference.tex(,739) @end table
reference.tex(,740) @c inserted refs from reference.doc:625
reference.tex(,757) @c end inserted refs from reference.doc:625
reference.tex(,758) @c ---------------------------------------
reference.tex(,759) @node cleardenom, close, charstr, Functions
reference.tex(,760) @subsection cleardenom
reference.tex(,761) @cindex cleardenom
reference.tex(,762) 
reference.tex(,763) @table @code
reference.tex(,764) @item @strong{Syntax:}
reference.tex(,765) @code{cleardenom (} poly_expression @code{)}
reference.tex(,766) @*@code{cleardenom (} vector_expression @code{)}
reference.tex(,767) @item @strong{Type:}
reference.tex(,768) same as the input type
reference.tex(,769) @item @strong{Purpose:}
reference.tex(,770) multiplies a polynomial, resp.@: vector, by a suitable constant to cancel
reference.tex(,771) all denominators from its coefficients and then divide it by its content.
reference.tex(,772) @item @strong{Example:}
reference.tex(,773) @smallexample
reference.tex(,774) @c reused example cleardenom reference.doc:648 
reference.tex(,775)   ring r=0,(x,y,z),dp;
reference.tex(,776)   poly f=(3x+6y)^5;
reference.tex(,777)   f/5;
reference.tex(,778) @expansion{} 243/5x5+486x4y+1944x3y2+3888x2y3+3888xy4+7776/5y5
reference.tex(,779)   cleardenom(f/5);
reference.tex(,780) @expansion{} x5+10x4y+40x3y2+80x2y3+80xy4+32y5
reference.tex(,781) @c end example cleardenom reference.doc:648
reference.tex(,782) @end smallexample
reference.tex(,783) @end table
reference.tex(,784) @c @c ref
reference.tex(,785) @c See @ref{poly}.
reference.tex(,786) @c @c ref
reference.tex(,787) @c ---------------------------------------
reference.tex(,788) @node close, coef, cleardenom, Functions
reference.tex(,789) @subsection close
reference.tex(,790) @cindex close
reference.tex(,791) @table @code
reference.tex(,792) @item @strong{Syntax:}
reference.tex(,793) @code{close (} link_expression @code{)}
reference.tex(,794) @item @strong{Type:}
reference.tex(,795) none
reference.tex(,796) @item @strong{Purpose:}
reference.tex(,797) closes a link.
reference.tex(,798) @item @strong{Example:}
reference.tex(,799) @smallexample
reference.tex(,800) link l="MPtcp:launch";
reference.tex(,801) open(l); // start SINGULAR "server" on localhost in batchmode
reference.tex(,802) close(l); // shut down SINGULAR server
reference.tex(,803) @end smallexample
reference.tex(,804) @end table
reference.tex(,805) @c inserted refs from reference.doc:677
reference.tex(,818) @c end inserted refs from reference.doc:677
reference.tex(,819) @c ---------------------------------------
reference.tex(,820) @node coef, coeffs, close, Functions
reference.tex(,821) @subsection coef
reference.tex(,822) @cindex coef
reference.tex(,823) 
reference.tex(,824) @table @code
reference.tex(,825) @item @strong{Syntax:}
reference.tex(,826) @code{coef (} poly_expression@code{,} product_of_ringvars @code{)}
reference.tex(,827) @item @strong{Type:}
reference.tex(,828) matrix
reference.tex(,829) @item @strong{Syntax:}
reference.tex(,830) @code{coef (} vector_expression@code{,} product_of_ringvars@code{,} matrix_name@code{,} matrix_name @code{)}
reference.tex(,831) @item @strong{Type:}
reference.tex(,832) none
reference.tex(,833) @item @strong{Purpose:}
reference.tex(,834) determines the monomials in f divisible by one of the ring variables of m
reference.tex(,835) (where f is the first argument and m the second argument) and the coefficients
reference.tex(,836) of these monomials as polynomials in the remaining variables.
reference.tex(,837) 
reference.tex(,838) First case:  returns a 2 x n matrix M, n being the number
reference.tex(,839) of the determined monomials.
reference.tex(,840) The first row consists of these monomials, the second row
reference.tex(,841) of the corresponding coefficients of the monomials in f.
reference.tex(,842) Thus, f = M[1,1]*M[2,1]+...+M[1,n]*M[2,n].
reference.tex(,843) 
reference.tex(,844) Second case: the second matrix (i.e., the 4th argument) contains the
reference.tex(,845) monomials, the first matrix (i.e., the 3rd argument) the corresponding
reference.tex(,846) coefficients of the monomials in the vector.
reference.tex(,847) 
reference.tex(,848) @item @strong{Note:}
reference.tex(,849) coef considers only monomials which really occur in f (i.e., which are not 0),
reference.tex(,850) while coeffs (see @ref{coeffs}) returns the coefficient 0 at the
reference.tex(,851) appropriate place if a monomial is not present.
reference.tex(,852) 
reference.tex(,853) @item @strong{Example:}
reference.tex(,854) @smallexample
reference.tex(,855) @c reused example coef reference.doc:718 
reference.tex(,856)   ring r=32003,(x,y,z),dp;
reference.tex(,857)   poly f=x5+5x4y+10x2y3+y5;
reference.tex(,858)   matrix m=coef(f,y);
reference.tex(,859)   print(m);
reference.tex(,860) @expansion{} y5,y3,  y,  1,
reference.tex(,861) @expansion{} 1, 10x2,5x4,x5
reference.tex(,862)   f=x20+xyz+xy+x2y+z3;
reference.tex(,863)   print(coef(f,xy));
reference.tex(,864) @expansion{} x20,x2y,xy, 1,
reference.tex(,865) @expansion{} 1,  1,  z+1,z3
reference.tex(,866)   vector v=[f,zy+77+xy];
reference.tex(,867)   print(v);
reference.tex(,868) @expansion{} [x20+x2y+xyz+z3+xy,xy+yz+77]
reference.tex(,869)   matrix mc; matrix mm;
reference.tex(,870)   coef(v,y,mc,mm);
reference.tex(,871)   print(mc);
reference.tex(,872) @expansion{} x2+xz+x,x20+z3,
reference.tex(,873) @expansion{} x+z,    77     
reference.tex(,874)   print(mm);
reference.tex(,875) @expansion{} y,1,
reference.tex(,876) @expansion{} y,1 
reference.tex(,877) @c end example coef reference.doc:718
reference.tex(,878) @end smallexample
reference.tex(,879) @end table
reference.tex(,880) @c inserted refs from reference.doc:734
reference.tex(,891) @c end inserted refs from reference.doc:734
reference.tex(,892) @c ---------------------------------------
reference.tex(,893) @node coeffs, contract, coef, Functions
reference.tex(,894) @subsection coeffs
reference.tex(,895) @cindex coeffs
reference.tex(,896) 
reference.tex(,897) @table @code
reference.tex(,898) @item @strong{Syntax:}
reference.tex(,899) @code{coeffs (} poly_expression @code{,} ring_variable @code{)}
reference.tex(,900) @*@code{coeffs (} ideal_expression@code{,} ring_variable @code{)}
reference.tex(,901) @*@code{coeffs (} vector_expression@code{,} ring_variable @code{)}
reference.tex(,902) @*@code{coeffs (} module_expression@code{,} ring_variable @code{)}
reference.tex(,903) @*@code{coeffs (} poly_expression@code{,} ring_variable@code{,} matrix_name @code{)}
reference.tex(,904) @*@code{coeffs (} ideal_expression@code{,} ring_variable@code{,} matrix_name @code{)}
reference.tex(,905) @*@code{coeffs (} vector_expression@code{,} ring_variable@code{,} matrix_name @code{)}
reference.tex(,906) @*@code{coeffs (} module_expression@code{,} ring_variable@code{,} matrix_name @code{)}
reference.tex(,907) @item @strong{Type:}
reference.tex(,908) matrix
reference.tex(,909) @item @strong{Purpose:}
reference.tex(,910) develops each polynomial of the first argument, say J,
reference.tex(,911) as a univariate polynomial in the given ring_variable,
reference.tex(,912) say z, and returns the coefficients as a k x d
reference.tex(,913) matrix M,
reference.tex(,914) where:
reference.tex(,915) @format
reference.tex(,916)     d-1 = maximum z-degree of all occurring polynomials
reference.tex(,917)       k = 1 if J is a polynomial,
reference.tex(,918)       k = number of generators  if J is an ideal.
reference.tex(,919) @end format
reference.tex(,920) If J is a vector or a module this procedure is repeated for each
reference.tex(,921) component and the resulting matrices are appended.@*
reference.tex(,930) @item @strong{Note:}
reference.tex(,931) @code{coeffs} returns the coefficient 0 at the appropriate place if a monomial
reference.tex(,932) is not present, while @code{coef} considers only monomials which really occur
reference.tex(,933) in the given expression. @*
reference.tex(,934) If
reference.tex(,941) then the j-th generator of an ideal J is equal to
reference.tex(,968) 
reference.tex(,969) @item @strong{Example:}
reference.tex(,970) @smallexample
reference.tex(,971) @c reused example coeffs reference.doc:817 
reference.tex(,972)   ring r;
reference.tex(,973)   poly f=(x+y)^3;
reference.tex(,974)   matrix M=coeffs(f,y);
reference.tex(,975)   print(M);
reference.tex(,976) @expansion{} x3, 
reference.tex(,977) @expansion{} 3x2,
reference.tex(,978) @expansion{} 3x, 
reference.tex(,979) @expansion{} 1   
reference.tex(,980)   ideal i=f,xyz+z10y4;
reference.tex(,981)   print(coeffs(i,y));
reference.tex(,982) @expansion{} x3, 0, 
reference.tex(,983) @expansion{} 3x2,xz,
reference.tex(,984) @expansion{} 3x, 0, 
reference.tex(,985) @expansion{} 1,  0, 
reference.tex(,986) @expansion{} 0,  z10
reference.tex(,987) @c end example coeffs reference.doc:817
reference.tex(,988) @end smallexample
reference.tex(,989) @item @strong{Syntax:}
reference.tex(,990) @code{coeffs (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,991) @*@code{coeffs (} module_expression@code{,} module_expression @code{)}
reference.tex(,992) @*@code{coeffs (} ideal_expression@code{,} ideal_expression@code{,} product_of_ringvars @code{)}
reference.tex(,993) @*@code{coeffs (} module_expression@code{,} module_expression@code{,} product_of_ringvars @code{)}
reference.tex(,994) @item @strong{Type:}
reference.tex(,995) matrix
reference.tex(,996) @item @strong{Purpose:}
reference.tex(,997) let the first argument be M,
reference.tex(,998) the second argument  be K (a set of monomials, resp.@: vectors with monomial
reference.tex(,999) entries, in the variables appearing in P),
reference.tex(,1000) the third argument be the product P of variables to consider (if this
reference.tex(,1001) argument is not given, then the product of all ring variables is taken
reference.tex(,1002) as default argument).
reference.tex(,1003) @*M is supposed to consist of elements of (resp.@: have entries in)
reference.tex(,1004) a finitely generated module
reference.tex(,1005) over a ring in the variables not appearing in P. K should contain the
reference.tex(,1006) generators of M over this smaller ring.
reference.tex(,1007) Then @code{coeffs(M,K,P)} returns a matrix A of coefficients with K*A=M
reference.tex(,1008) such that the entries of A do not contain any variable from P.
reference.tex(,1009) @*If K does not contain all generators that are necessary to express
reference.tex(,1010) M, then K*A=M' where M' is the part of M that can be expressed.
reference.tex(,1011) 
reference.tex(,1012) @item @strong{Example:}
reference.tex(,1013) @smallexample
reference.tex(,1014) @c reused example coeffs_1 reference.doc:851 
reference.tex(,1015)   ring r=32003,(x,y,z),dp;
reference.tex(,1016)   ideal M=x2z+y3,xy;
reference.tex(,1017)   print(coeffs(M,ideal(x2,xy,y2),xy));
reference.tex(,1018) @expansion{} z,0,
reference.tex(,1019) @expansion{} 0,1,
reference.tex(,1020) @expansion{} 0,0 
reference.tex(,1021)   print(coeffs(M,ideal(x2,xy,y2)));
reference.tex(,1022) @expansion{} 0,0,
reference.tex(,1023) @expansion{} 0,1,
reference.tex(,1024) @expansion{} 0,0 
reference.tex(,1025) @c end example coeffs_1 reference.doc:851
reference.tex(,1026) @end smallexample
reference.tex(,1027) @end table
reference.tex(,1028) @c inserted refs from reference.doc:859
reference.tex(,1041) @c end inserted refs from reference.doc:859
reference.tex(,1042) @c ---------------------------------------
reference.tex(,1043) @node contract, dbprint, coeffs, Functions
reference.tex(,1044) @subsection contract
reference.tex(,1045) @cindex contract
reference.tex(,1046) 
reference.tex(,1047) @table @code
reference.tex(,1048) @item @strong{Syntax:}
reference.tex(,1049) @code{contract (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,1050) @item @strong{Type:}
reference.tex(,1051) matrix
reference.tex(,1052) @item @strong{Purpose:}
reference.tex(,1053) contracts each of the n elements of the second ideal J
reference.tex(,1054) by each of the m elements of the first ideal I,
reference.tex(,1055) producing a m x n matrix.
reference.tex(,1056) @*Contraction is defined on monomials by:
reference.tex(,1057) @*
reference.tex(,1068) where A and B are the multiexponents of the ring variables represented by
reference.tex(,1075) @code{contract} is extended bilinearly to all polynomials.
reference.tex(,1076) @item @strong{Example:}
reference.tex(,1077) @smallexample
reference.tex(,1078) @c reused example contract reference.doc:900 
reference.tex(,1079)   ring r=0,(a,b,c,d),dp;
reference.tex(,1080)   ideal I=a2,a2+bc,abc;
reference.tex(,1081)   ideal J=a2-bc,abcd;
reference.tex(,1082)   print(contract(I,J));
reference.tex(,1083) @expansion{} 1,0, 
reference.tex(,1084) @expansion{} 0,ad,
reference.tex(,1085) @expansion{} 0,d  
reference.tex(,1086) @c end example contract reference.doc:900
reference.tex(,1087) @end smallexample
reference.tex(,1088) @end table
reference.tex(,1089) @c inserted refs from reference.doc:908
reference.tex(,1100) @c end inserted refs from reference.doc:908
reference.tex(,1101) @c ---------------------------------------
reference.tex(,1102) @node dbprint, defined, contract, Functions
reference.tex(,1103) @subsection dbprint
reference.tex(,1104) @cindex dbprint
reference.tex(,1105) @table @code
reference.tex(,1106) @item @strong{Syntax:}
reference.tex(,1107) @code{dbprint (} int_expression@code{,} expression_list @code{)}
reference.tex(,1108) @item @strong{Type:}
reference.tex(,1109) none
reference.tex(,1110) @item @strong{Purpose:}
reference.tex(,1111) applies the print command to each expression in the expression_list if
reference.tex(,1112) int_expression is positive.
reference.tex(,1113) @code{dbprint} may also be used in procedures
reference.tex(,1114) in order to print results subject to certain
reference.tex(,1115) conditions.
reference.tex(,1116) @item @strong{Syntax:}
reference.tex(,1117) @code{dbprint (} expression @code{)}
reference.tex(,1118) @item @strong{Type:}
reference.tex(,1119) none
reference.tex(,1120) @item @strong{Purpose:}
reference.tex(,1121) The print command is applied to the expression
reference.tex(,1122) if @code{printlevel>=voice}.
reference.tex(,1123) @item @strong{Note:}
reference.tex(,1124) @xref{Guidelines for writing a library}, for an example how this is used
reference.tex(,1125) for displaying comments while procedures are executed.
reference.tex(,1126) @item @strong{Example:}
reference.tex(,1127) @smallexample
reference.tex(,1128) @c reused example dbprint reference.doc:939 
reference.tex(,1129)   int debug=0;
reference.tex(,1130)   intvec i=1,2,3;
reference.tex(,1131)   dbprint(debug,i);
reference.tex(,1132)   debug=1;
reference.tex(,1133)   dbprint(debug,i);
reference.tex(,1134) @expansion{} 1,2,3
reference.tex(,1135)   voice;
reference.tex(,1136) @expansion{} 1
reference.tex(,1137)   printlevel;
reference.tex(,1138) @expansion{} 0
reference.tex(,1139)   dbprint(i);
reference.tex(,1140) @c end example dbprint reference.doc:939
reference.tex(,1141) @end smallexample
reference.tex(,1142) @end table
reference.tex(,1143) @c inserted refs from reference.doc:951
reference.tex(,1160) @c end inserted refs from reference.doc:951
reference.tex(,1161) @c ---------------------------------------
reference.tex(,1162) @node defined, deg, dbprint, Functions
reference.tex(,1163) @subsection defined
reference.tex(,1164) @cindex defined
reference.tex(,1165) 
reference.tex(,1166) @table @code
reference.tex(,1167) @item @strong{Syntax:}
reference.tex(,1168) @code{defined (} name @code{)}
reference.tex(,1169) @item @strong{Type:}
reference.tex(,1170) int
reference.tex(,1171) @item @strong{Purpose:}
reference.tex(,1172) returns a value <>0 (TRUE) if there is a user-defined object with this name,
reference.tex(,1173) and 0 (FALSE) otherwise.
reference.tex(,1174) @*A non-zero return value is the level where the object is defined (level
reference.tex(,1175) 1 denotes the top level, level 2 the level of a first procedure, level 3
reference.tex(,1176) the level of a procedure called by a first procedure, etc.). For ring
reference.tex(,1177) variables, -1 is returned.
reference.tex(,1178) @item @strong{Note:}
reference.tex(,1179) A local object @code{m} may be identified by @code{if
reference.tex(,1180) (defined(m)==voice)}.
reference.tex(,1181) @item @strong{Example:}
reference.tex(,1182) @smallexample
reference.tex(,1183) @c reused example defined reference.doc:980 
reference.tex(,1184)   ring r=(0,t),(x,y),dp;
reference.tex(,1185)   matrix m[5][6]=x,y,1,2,0,x+y;
reference.tex(,1186)   defined(mm);
reference.tex(,1187) @expansion{} 0
reference.tex(,1188)   defined(r) and defined(m);
reference.tex(,1189) @expansion{} 1
reference.tex(,1190)   defined(m)==voice;   // m is defined in the current level
reference.tex(,1191) @expansion{} 1
reference.tex(,1192)   defined(x);
reference.tex(,1193) @expansion{} -1
reference.tex(,1194)   defined(z);
reference.tex(,1195) @expansion{} 0
reference.tex(,1196)   defined(t);
reference.tex(,1197) @expansion{} -1
reference.tex(,1198)   defined(42);
reference.tex(,1199) @expansion{} -1
reference.tex(,1200) @c end example defined reference.doc:980
reference.tex(,1201) @end smallexample
reference.tex(,1202) @end table
reference.tex(,1203) @c inserted refs from reference.doc:993
reference.tex(,1216) @c end inserted refs from reference.doc:993
reference.tex(,1217) @c ---------------------------------------
reference.tex(,1218) @node deg, degree, defined, Functions
reference.tex(,1219) @subsection deg
reference.tex(,1220) @cindex deg
reference.tex(,1221) 
reference.tex(,1222) @table @code
reference.tex(,1223) @item @strong{Syntax:}
reference.tex(,1224) @code{deg (} poly_expression @code{)}
reference.tex(,1225) @*@code{deg (} vector_expression @code{)}
reference.tex(,1226) @*@code{deg (} poly_expression @code{,} intvec_expression @code{)}
reference.tex(,1227) @*@code{deg (} vector_expression @code{,} intvec_expression @code{)}
reference.tex(,1228) @item @strong{Type:}
reference.tex(,1229) int
reference.tex(,1230) @item @strong{Purpose:}
reference.tex(,1231) returns the maximal (weighted) degree of
reference.tex(,1232) the terms of a polynomial or a vector;
reference.tex(,1233) @*deg(0) is -1.
reference.tex(,1234) @*The optional second argument gives the weight vector,
reference.tex(,1235) the default weights of the base ring will be used otherwise.
reference.tex(,1236) @item @strong{Example:}
reference.tex(,1237) @smallexample
reference.tex(,1238) @c reused example deg reference.doc:1019 
reference.tex(,1239)   ring r=0,(x,y,z),lp;
reference.tex(,1240)   deg(0);
reference.tex(,1241) @expansion{} -1
reference.tex(,1242)   deg(x3+y4+xyz3);
reference.tex(,1243) @expansion{} 5
reference.tex(,1244)   ring rr=7,(x,y),wp(2,3);
reference.tex(,1245)   poly f=x2+y3;
reference.tex(,1246)   deg(f);
reference.tex(,1247) @expansion{} 9
reference.tex(,1248)   ring R=7,(x,y),ws(2,3);
reference.tex(,1249)   poly f=x2+y3;
reference.tex(,1250)   deg(f);
reference.tex(,1251) @expansion{} 9
reference.tex(,1252)   vector v=[x2,y];
reference.tex(,1253)   deg(v);
reference.tex(,1254) @expansion{} 4
reference.tex(,1255) @c end example deg reference.doc:1019
reference.tex(,1256) @end smallexample
reference.tex(,1257) @end table
reference.tex(,1258) @c inserted refs from reference.doc:1034
reference.tex(,1275) @c end inserted refs from reference.doc:1034
reference.tex(,1276) @c ---------------------------------------
reference.tex(,1277) @node degree, delete, deg, Functions
reference.tex(,1278) @subsection degree
reference.tex(,1279) @cindex degree
reference.tex(,1280) @table @code
reference.tex(,1281) @item @strong{Syntax:}
reference.tex(,1282) @code{degree (} ideal_expression @code{)}
reference.tex(,1283) @*@code{degree (} module_expression @code{)}
reference.tex(,1284) @item @strong{Type:}
reference.tex(,1285) int
reference.tex(,1286) @item @strong{Purpose:}
reference.tex(,1287) computes the (weighted) degree of the projective
reference.tex(,1288) variety, respectively sheaf over the projective variety, defined by the ideal,
reference.tex(,1289) respectively module, generated by the leading monomials of the input.  
reference.tex(,1290) This is equal to the
reference.tex(,1291) (weighted) degree of the projective variety, respectively
reference.tex(,1292) sheaf over the projective variety, defined by the ideal,
reference.tex(,1293) respectively module, if the 
reference.tex(,1294) input is a standard basis with respect to a (weighted) degree ordering. 
reference.tex(,1295) @item @strong{Example:}
reference.tex(,1296) @smallexample
reference.tex(,1297) ring r3=32003,(x,y,z,h),dp;
reference.tex(,1298) int a,b,c,t=11,10,3,1;
reference.tex(,1299) poly f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
reference.tex(,1300)   +x^(c-2)*y^c*(y2+t*x)^2;
reference.tex(,1301) ideal i=jacob(f);
reference.tex(,1302) i=homog(i,h);
reference.tex(,1303) ideal i0=std(i);
reference.tex(,1304) degree(i0);
reference.tex(,1305) @expansion{} 720 
reference.tex(,1306) @end smallexample
reference.tex(,1307) @end table
reference.tex(,1308) @c inserted refs from reference.doc:1073
reference.tex(,1327) @c end inserted refs from reference.doc:1073
reference.tex(,1328) @c ---------------------------------------
reference.tex(,1329) @node delete, det, degree, Functions
reference.tex(,1330) @subsection delete
reference.tex(,1331) @cindex delete
reference.tex(,1332) 
reference.tex(,1333) @table @code
reference.tex(,1334) @item @strong{Syntax:}
reference.tex(,1335) @code{delete (} list_expression@code{,} int_expression @code{)}
reference.tex(,1336) @item @strong{Type:}
reference.tex(,1337) list
reference.tex(,1338) @item @strong{Purpose:}
reference.tex(,1339) deletes the element with the given index from a list (the input is not changed).
reference.tex(,1340) @item @strong{Example:}
reference.tex(,1341) @smallexample
reference.tex(,1342) @c reused example delete reference.doc:1095 
reference.tex(,1343)   list l="a","b","c";
reference.tex(,1344)   list l1=delete(l,2);l1;
reference.tex(,1345) @expansion{} [1]:
reference.tex(,1346) @expansion{}    a
reference.tex(,1347) @expansion{} [2]:
reference.tex(,1348) @expansion{}    c
reference.tex(,1349)   l;
reference.tex(,1350) @expansion{} [1]:
reference.tex(,1351) @expansion{}    a
reference.tex(,1352) @expansion{} [2]:
reference.tex(,1353) @expansion{}    b
reference.tex(,1354) @expansion{} [3]:
reference.tex(,1355) @expansion{}    c
reference.tex(,1356) @c end example delete reference.doc:1095
reference.tex(,1357) @end smallexample
reference.tex(,1358) @end table
reference.tex(,1359) @c inserted refs from reference.doc:1102
reference.tex(,1372) @c end inserted refs from reference.doc:1102
reference.tex(,1373) @c ---------------------------------------
reference.tex(,1374) @node det, diff, delete, Functions
reference.tex(,1375) @subsection det
reference.tex(,1376) @cindex det
reference.tex(,1377) 
reference.tex(,1378) @table @code
reference.tex(,1379) @item @strong{Syntax:}
reference.tex(,1380) @code{det (} intmat_expression @code{)}
reference.tex(,1381) @*@code{det (} matrix_expression @code{)}
reference.tex(,1382) @*@code{det (} module_expression @code{)}
reference.tex(,1383) @item @strong{Type:}
reference.tex(,1384) int, resp.@: poly
reference.tex(,1385) @item @strong{Purpose:}
reference.tex(,1386) returns the determinant of a square matrix. A module is considered
reference.tex(,1387) as a matrix. The applied algorithms depend on type of input.
reference.tex(,1388) If the input is a module or matrix with symbolic entries the
reference.tex(,1389) Bareiss algorithm is used. In the other cases the chinese remainder
reference.tex(,1390) algorithm is used. For large sparse problems the input as a module
reference.tex(,1391) has advantages.
reference.tex(,1392) @item @strong{Example:}
reference.tex(,1393) @smallexample
reference.tex(,1394) @c reused example det reference.doc:1128 
reference.tex(,1395)   ring r=7,(x,y),wp(2,3);
reference.tex(,1396)   matrix m[3][3]=1,2,3,4,5,6,7,8,x;
reference.tex(,1397)   det(m);
reference.tex(,1398) @expansion{} -3x-1
reference.tex(,1399) @c end example det reference.doc:1128
reference.tex(,1400) @end smallexample
reference.tex(,1401) @end table
reference.tex(,1402) @c inserted refs from reference.doc:1135
reference.tex(,1417) @c end inserted refs from reference.doc:1135
reference.tex(,1418) @c ---------------------------------------
reference.tex(,1419) @node diff, dim, det, Functions
reference.tex(,1420) @subsection diff
reference.tex(,1421) @cindex diff
reference.tex(,1422) 
reference.tex(,1423) @table @code
reference.tex(,1424) @item @strong{Syntax:}
reference.tex(,1425) @code{diff (} poly_expression@code{,} ring_variable @code{)}
reference.tex(,1426) @*@code{diff (} vector_expression@code{,} ring_variable @code{)}
reference.tex(,1427) @*@code{diff (} ideal_expression@code{,} ring_variable @code{)}
reference.tex(,1428) @*@code{diff (} module_expression@code{,} ring_variable @code{)}
reference.tex(,1429) @*@code{diff (} matrix_expression@code{,} ring_variable @code{)}
reference.tex(,1430) @item @strong{Type:}
reference.tex(,1431) the same as the type of the first argument
reference.tex(,1432) @item @strong{Syntax:}
reference.tex(,1433) @code{diff (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,1434) @item @strong{Type:}
reference.tex(,1435) matrix
reference.tex(,1436) @item @strong{Purpose:}
reference.tex(,1437) computes the partial derivative of a polynomial object by a ring variable
reference.tex(,1438) (first forms)
reference.tex(,1439) @*respectively differentiates each polynomial (1..n) of the second ideal
reference.tex(,1440) by the differential operator corresponding to each polynomial (1..m) in the first
reference.tex(,1441) ideal, producing an m x n matrix.
reference.tex(,1442) @item @strong{Example:}
reference.tex(,1443) @smallexample
reference.tex(,1444) @c reused example diff reference.doc:1167 
reference.tex(,1445)   ring r=0,(x,y,z),dp;
reference.tex(,1446)   poly f=2x3y+3z5;
reference.tex(,1447)   diff(f,x);
reference.tex(,1448) @expansion{} 6x2y
reference.tex(,1449)   vector v=[f,y2+z];
reference.tex(,1450)   diff(v,z);
reference.tex(,1451) @expansion{} 15z4*gen(1)+gen(2)
reference.tex(,1452)   ideal j=x2-yz,xyz;
reference.tex(,1453)   ideal i=x2,x2+yz,xyz;
reference.tex(,1454)   // corresponds to differential operators
reference.tex(,1455)   // d2/dx2, d2/dx2+d2/dydz, d3/dxdydz:
reference.tex(,1456)   print(diff(i,j));
reference.tex(,1457) @expansion{} 2,0,
reference.tex(,1458) @expansion{} 1,x,
reference.tex(,1459) @expansion{} 0,1 
reference.tex(,1460) @c end example diff reference.doc:1167
reference.tex(,1461) @end smallexample
reference.tex(,1462) @end table
reference.tex(,1463) @c inserted refs from reference.doc:1181
reference.tex(,1488) @c end inserted refs from reference.doc:1181
reference.tex(,1489) @c ---------------------------------------
reference.tex(,1490) @node dim, division, diff, Functions
reference.tex(,1491) @subsection dim
reference.tex(,1492) @cindex dim
reference.tex(,1493) 
reference.tex(,1494) @table @code
reference.tex(,1495) @item @strong{Syntax:}
reference.tex(,1496) @code{dim (} ideal_expression @code{)}
reference.tex(,1497) @*@code{dim (} module_expression @code{)}
reference.tex(,1498) @item @strong{Type:}
reference.tex(,1499) int
reference.tex(,1500) @item @strong{Purpose:}
reference.tex(,1501) computes the dimension of the ideal, resp.@: module, generated by
reference.tex(,1502) the leading monomials of the given generators of the ideal, resp.@: module.
reference.tex(,1503) This is also the dimension of the ideal if it is represented by
reference.tex(,1504) a standard basis.
reference.tex(,1505) @item @strong{Note:}
reference.tex(,1506) The dimension of an ideal I means
reference.tex(,1507) the Krull dimension of the basering modulo I.
reference.tex(,1508) @*The dimension of a
reference.tex(,1509) module is the dimension of its annihilator ideal.
reference.tex(,1510) @item @strong{Example:}
reference.tex(,1511) @smallexample
reference.tex(,1512) @c reused example dim reference.doc:1215 
reference.tex(,1513)   ring r=32003,(x,y,z),dp;
reference.tex(,1514)   ideal I=x2-y,x3;
reference.tex(,1515)   dim(std(I));
reference.tex(,1516) @expansion{} 1
reference.tex(,1517) @c end example dim reference.doc:1215
reference.tex(,1518) @end smallexample
reference.tex(,1519) @end table
reference.tex(,1520) @c inserted refs from reference.doc:1222
reference.tex(,1539) @c end inserted refs from reference.doc:1222
reference.tex(,1540) @c -------------------------------------------------
reference.tex(,1541) @node division, dump, dim, Functions
reference.tex(,1542) @subsection division
reference.tex(,1543) @cindex division
reference.tex(,1544) @table @code
reference.tex(,1545) @item @strong{Syntax:}
reference.tex(,1546) @code{division (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,1547) @*@code{division (} module_expression@code{,} module_expression @code{)}
reference.tex(,1548) @*@code{division (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
reference.tex(,1549) @*@code{division (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
reference.tex(,1550) @*@code{division (} ideal_expression@code{,} ideal_expression@code{,} int_expression@code{,} intvec_expression @code{)}
reference.tex(,1551) @*@code{division (} module_expression@code{,} module_expression@code{,} int_expression@code{,} intvec_expression @code{)}
reference.tex(,1552) @item @strong{Type:}
reference.tex(,1553) list
reference.tex(,1554) @item @strong{Purpose:}
reference.tex(,1555) @code{division} computes a division with remainder.
reference.tex(,1556) For two ideals resp.@: modules @code{M} (first argument) and @code{N} (second argument), it returns a list @code{T,R,U} where @code{T} is a matrix, @code{R} is an ideal resp. a module, and @code{U} is a diagonal matrix of units such that @code{matrix(M)*U=matrix(N)*T+matrix(R)} is a standard representation for the normal form @code{R} of @code{M} with respect to a standard basis of @code{N}.
reference.tex(,1557) @code{division} uses different algorithms depending on whether @code{N} is represented by a standard basis.
reference.tex(,1558) For a polynomial basering, the matrix @code{U} is the identity matrix.
reference.tex(,1559) A matrix @code{T} as above is also computed by @code{lift}.
reference.tex(,1560) @*For additional arguments @code{n} (third argument) and @code{w} (fourth argument), @code{division} returns a list @code{T,R} as above such that @code{matrix(M)=matrix(N)*T+matrix(R)} is a standard representation for the normal form @code{R} of @code{M} with respect to @code{N} up to weighted degree @code{n} with respect to the weight vector @code{w}.
reference.tex(,1561) The weighted degree of @code{T} and @code{R} respect to @code{w} is at most @code{n}.
reference.tex(,1562) If the weight vector @code{w} is not given, @code{division} uses the standard weight vector @code{w=1,...,1}.
reference.tex(,1563) @item @strong{Example:}
reference.tex(,1564) @smallexample
reference.tex(,1565) @c reused example division reference.doc:1255 
reference.tex(,1566) ring R=0,(x,y),ds;
reference.tex(,1567) poly f=x5+x2y2+y5;
reference.tex(,1568) division(f,jacob(f));
reference.tex(,1569) @expansion{} [1]:
reference.tex(,1570) @expansion{}    _[1,1]=1/5x
reference.tex(,1571) @expansion{}    _[2,1]=3/10y
reference.tex(,1572) @expansion{} [2]:
reference.tex(,1573) @expansion{}    _[1]=-1/2y5
reference.tex(,1574) @expansion{} [3]:
reference.tex(,1575) @expansion{}    _[1,1]=1
reference.tex(,1576) division(f^2,jacob(f));
reference.tex(,1577) @expansion{} [1]:
reference.tex(,1578) @expansion{}    _[1,1]=1/20x6-9/80xy5-5/16x7y+5/8x2y6
reference.tex(,1579) @expansion{}    _[2,1]=1/8x2y3+1/5x5y+1/20y6-3/4x3y4-5/4x6y2-5/16xy7
reference.tex(,1580) @expansion{} [2]:
reference.tex(,1581) @expansion{}    _[1]=0
reference.tex(,1582) @expansion{} [3]:
reference.tex(,1583) @expansion{}    _[1,1]=1/4-25/16xy
reference.tex(,1584) division(ideal(f^2),jacob(f),10);
reference.tex(,1585) @expansion{} // ** _ is no standardbasis
reference.tex(,1586) @expansion{} [1]:
reference.tex(,1587) @expansion{}    _[1,1]=-75/8y9
reference.tex(,1588) @expansion{}    _[2,1]=1/2x2y3+x5y-1/4y6-3/2x3y4+15/4xy7+375/16x2y8
reference.tex(,1589) @expansion{} [2]:
reference.tex(,1590) @expansion{}    _[1]=x10+9/4y10
reference.tex(,1591) @c end example division reference.doc:1255
reference.tex(,1592) @end smallexample
reference.tex(,1593) @end table
reference.tex(,1594) @c inserted refs from reference.doc:1264
reference.tex(,1609) @c end inserted refs from reference.doc:1264
reference.tex(,1610) @c ---------------------------------------
reference.tex(,1611) @node dump, eliminate, division, Functions
reference.tex(,1612) @subsection dump
reference.tex(,1613) @cindex dump
reference.tex(,1614) @table @code
reference.tex(,1615) @item @strong{Syntax:}
reference.tex(,1616) @code{dump (} link_expression @code{)}
reference.tex(,1617) @item @strong{Type:}
reference.tex(,1618) none
reference.tex(,1619) @item @strong{Purpose:}
reference.tex(,1620) dumps (i.e., writes in one "message" or "block") the state of the @sc{Singular}
reference.tex(,1621) session (i.e., all defined variables and their values) to the specified
reference.tex(,1622) link (which must be either an ASCII or MP link) such that a
reference.tex(,1623) @code{getdump} can retrieve it later on.
reference.tex(,1624) @item @strong{Example:}
reference.tex(,1625) @smallexample
reference.tex(,1626) @c reused example dump reference.doc:1286 
reference.tex(,1627)   ring r;
reference.tex(,1628)   // write the whole session to the file dump.ascii
reference.tex(,1629)   // in ASCII format
reference.tex(,1630)   dump(":w dump.ascii");
reference.tex(,1631)   kill r;                  // kill the basering
reference.tex(,1632)   // reread the session from the file
reference.tex(,1633)   // redefining everything which was not explicitly killed before
reference.tex(,1634)   getdump("dump.ascii");
reference.tex(,1635) @expansion{} // ** redefining stdfglm **
reference.tex(,1636) @expansion{} // ** redefining stdhilb **
reference.tex(,1637) @expansion{} // ** redefining groebner **
reference.tex(,1638) @expansion{} // ** redefining res **
reference.tex(,1639) @expansion{} // ** redefining quot **
reference.tex(,1640) @expansion{} // ** redefining quot1 **
reference.tex(,1641) @expansion{} // ** redefining quotient0 **
reference.tex(,1642) @expansion{} // ** redefining quotient1 **
reference.tex(,1643) @expansion{} // ** redefining quotient2 **
reference.tex(,1644) @expansion{} // ** redefining quotient3 **
reference.tex(,1645) @expansion{} // ** redefining quotient5 **
reference.tex(,1646) @expansion{} // ** redefining quotient4 **
reference.tex(,1647) @expansion{} // ** redefining intersect1 **
reference.tex(,1648) @expansion{} // ** redefining sprintf **
reference.tex(,1649) @expansion{} // ** redefining printf **
reference.tex(,1650) @expansion{} // ** redefining fprintf **
reference.tex(,1651)   r;
reference.tex(,1652) @expansion{} //   characteristic : 32003
reference.tex(,1653) @expansion{} //   number of vars : 3
reference.tex(,1654) @expansion{} //        block   1 : ordering dp
reference.tex(,1655) @expansion{} //                  : names    x y z 
reference.tex(,1656) @expansion{} //        block   2 : ordering C
reference.tex(,1657) @c end example dump reference.doc:1286
reference.tex(,1658) @end smallexample
reference.tex(,1659) @item @strong{Restrictions:}
reference.tex(,1660) For ASCII links, integer matrices contained in lists are  dumped as
reference.tex(,1661) integer list elements (and not as integer matrices), and lists of lists
reference.tex(,1662) are dumped as one flatted list. Furthermore, links
reference.tex(,1663) themselves are not dumped.
reference.tex(,1664) @end table
reference.tex(,1665) @c inserted refs from reference.doc:1304
reference.tex(,1680) @c end inserted refs from reference.doc:1304
reference.tex(,1681) @c ---------------------------------------
reference.tex(,1682) @node eliminate, eval, dump, Functions
reference.tex(,1683) @subsection eliminate
reference.tex(,1684) @cindex eliminate
reference.tex(,1685) 
reference.tex(,1686) @table @code
reference.tex(,1687) @item @strong{Syntax:}
reference.tex(,1688) @code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{)}
reference.tex(,1689) @*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{)}
reference.tex(,1690) @*@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
reference.tex(,1691) @*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
reference.tex(,1692) @item @strong{Type:}
reference.tex(,1693) the same as the type of the first argument
reference.tex(,1694) @item @strong{Purpose:}
reference.tex(,1695) eliminates variables occurring as factors of the second argument from an
reference.tex(,1696) ideal, resp.@: module, by intersecting it with the subring not containing
reference.tex(,1697) these variables.
reference.tex(,1698) @*@code{eliminate} does not need a special ordering nor a standard basis as input.
reference.tex(,1699) @item @strong{Note:}
reference.tex(,1700) Since elimination is expensive, for homogeneous input it might be useful
reference.tex(,1701) first to compute the Hilbert function of the ideal (first
reference.tex(,1702) argument) with a fast ordering (e.g., @code{dp}). Then make use of it to speed
reference.tex(,1703) up the computation: a Hilbert-driven elimination uses the intvec
reference.tex(,1704) provided as the third argument.
reference.tex(,1705) @item @strong{Example:}
reference.tex(,1706) @smallexample
reference.tex(,1707) @c reused example eliminate reference.doc:1336 
reference.tex(,1708)   ring r=32003,(x,y,z),dp;
reference.tex(,1709)   ideal i=x2,xy,y5;
reference.tex(,1710)   eliminate(i,x);
reference.tex(,1711) @expansion{} _[1]=y5
reference.tex(,1712)   ring R=0,(x,y,t,s,z),dp;
reference.tex(,1713)   ideal i=x-t,y-t2,z-t3,s-x+y3;
reference.tex(,1714)   eliminate(i,ts);
reference.tex(,1715) @expansion{} _[1]=y2-xz
reference.tex(,1716) @expansion{} _[2]=xy-z
reference.tex(,1717) @expansion{} _[3]=x2-y
reference.tex(,1718)   intvec v=hilb(std(i),1);
reference.tex(,1719)   eliminate(i,ts,v);
reference.tex(,1720) @expansion{} _[1]=y2-xz
reference.tex(,1721) @expansion{} _[2]=xy-z
reference.tex(,1722) @expansion{} _[3]=x2-y
reference.tex(,1723) @c end example eliminate reference.doc:1336
reference.tex(,1724) @end smallexample
reference.tex(,1725) @end table
reference.tex(,1726) @c inserted refs from reference.doc:1348
reference.tex(,1743) @c end inserted refs from reference.doc:1348
reference.tex(,1744) @c ---------------------------------------
reference.tex(,1745) @node eval, ERROR, eliminate, Functions
reference.tex(,1746) @subsection eval
reference.tex(,1747) @cindex eval
reference.tex(,1748) @table @code
reference.tex(,1749) @item @strong{Syntax:}
reference.tex(,1750) @code{eval (} expression @code{)}
reference.tex(,1751) @item @strong{Type:}
reference.tex(,1752) none
reference.tex(,1753) @item @strong{Purpose:}
reference.tex(,1754) evaluates (quoted) expressions. Within a quoted expression, the
reference.tex(,1755) quote can be "undone" by an @code{eval} (i.e., each eval "undoes" the
reference.tex(,1756) effect of exactly one quote). Used only when receiving a quoted expression
reference.tex(,1757) from an MPfile link,
reference.tex(,1758) with @code{quote} and @code{write} to
reference.tex(,1759) prevent local evaluations  when writing to an MPtcp link.
reference.tex(,1760) @item @strong{Example:}
reference.tex(,1761) @smallexample
reference.tex(,1762) @c @c example unix_only
reference.tex(,1763)   link l="MPfile:w example.mp";
reference.tex(,1764)   ring r=0,(x,y,z),ds;
reference.tex(,1765)   ideal i=maxideal(3);
reference.tex(,1766)   ideal j=x7,x2,z;
reference.tex(,1767)   // compute i+j before writing, but not std
reference.tex(,1768)   // this writes 'std(ideal(x3,...,z))'
reference.tex(,1769)   write (l, quote(std(eval(i+j))));
reference.tex(,1770)   option(prot);
reference.tex(,1771)   close(l);
reference.tex(,1772)   // now read it in again and evaluate
reference.tex(,1773)   // read(l) forces to compute 'std(ideal(x3,...,z))'
reference.tex(,1774)   read(l);
reference.tex(,1775)   close(l);
reference.tex(,1776) @c @c example
reference.tex(,1777) @end smallexample
reference.tex(,1778) @end table
reference.tex(,1779) @c inserted refs from reference.doc:1390
reference.tex(,1794) @c end inserted refs from reference.doc:1390
reference.tex(,1795) @c ---------------------------------------
reference.tex(,1796) @node ERROR, example, eval, Functions
reference.tex(,1797) @subsection ERROR
reference.tex(,1798) @cindex ERROR
reference.tex(,1799) @table @code
reference.tex(,1800) @item @strong{Syntax:}
reference.tex(,1801) @code{ERROR (} string_expression @code{)}
reference.tex(,1802) @item @strong{Type:}
reference.tex(,1803) none
reference.tex(,1804) @item @strong{Purpose:}
reference.tex(,1805) Immediately interrupts the current computation, returns to the
reference.tex(,1806) top-level, and displays the argument @code{string_expression} as error
reference.tex(,1807) message.
reference.tex(,1808) 
reference.tex(,1809) @item @strong{Note:}
reference.tex(,1810) This should be used as an emergency, resp.@: failure, exit within procedures.
reference.tex(,1811) 
reference.tex(,1812) @item @strong{Example:}
reference.tex(,1813) @smallexample
reference.tex(,1814) @c reused example ERROR reference.doc:1415 
reference.tex(,1815) int i=1;
reference.tex(,1816) proc myError() @{ERROR("Need to leave now");i=2;@}
reference.tex(,1817) myError();
reference.tex(,1818) @expansion{}    ? Need to leave now
reference.tex(,1819) @expansion{}    ? error occurred in line 2: `ERROR("Need to leave now");i=2;`
reference.tex(,1820) @expansion{}    ? leaving ::myError
reference.tex(,1821) @expansion{}    skipping text from `;` error at token `)`
reference.tex(,1822) i;
reference.tex(,1823) @expansion{} 1
reference.tex(,1824) @c end example ERROR reference.doc:1415
reference.tex(,1825) @end smallexample
reference.tex(,1826) @end table
reference.tex(,1827) @c ---------------------------------------
reference.tex(,1828) @node example, execute, ERROR, Functions
reference.tex(,1829) @subsection example
reference.tex(,1830) @cindex example
reference.tex(,1831) @table @code
reference.tex(,1832) @item @strong{Syntax:}
reference.tex(,1833) @code{example} topic @code{;}
reference.tex(,1834) @item @strong{Purpose:}
reference.tex(,1835) computes an example for @code{topic}. Examples are available for all
reference.tex(,1836) @sc{Singular} kernel and library functions. Where available (e.g.,
reference.tex(,1837) within Emacs), use @code{<TAB>} completion for a list of all available
reference.tex(,1838) example @code{topic}s.
reference.tex(,1839) @item @strong{Example:}
reference.tex(,1840) @smallexample
reference.tex(,1841) example prime;
reference.tex(,1842) example intvec_declarations;
reference.tex(,1843) @end smallexample
reference.tex(,1844) @end table
reference.tex(,1845) @c inserted refs from reference.doc:1441
reference.tex(,1856) @c end inserted refs from reference.doc:1441
reference.tex(,1857) @c ---------------------------------------
reference.tex(,1858) @node execute, exit, example, Functions
reference.tex(,1859) @subsection execute
reference.tex(,1860) @cindex execute
reference.tex(,1861) @table @code
reference.tex(,1862) @item @strong{Syntax:}
reference.tex(,1863) @code{execute (} string_expression @code{)}
reference.tex(,1864) @item @strong{Type:}
reference.tex(,1865) none
reference.tex(,1866) @item @strong{Purpose:}
reference.tex(,1867) executes a string containing a sequence of @sc{Singular} commands.
reference.tex(,1868) @item @strong{Note:}
reference.tex(,1869) The command @code{return} cannot appear in the string.
reference.tex(,1870) @* @code{execute} should be avoided in procedures
reference.tex(,1871) whenever possible, since it may give rise to name conflicts.  Moreover,
reference.tex(,1872) such procedures cannot be precompiled (a feature which @sc{Singular} will
reference.tex(,1873) provide in the future).
reference.tex(,1874) @item @strong{Example:}
reference.tex(,1875) @smallexample
reference.tex(,1876) @c reused example execute reference.doc:1463 
reference.tex(,1877)   ring r=32003,(x,y,z),dp;
reference.tex(,1878)   ideal i=x+y,z3+22y;
reference.tex(,1879)   write(":w save_i",i);
reference.tex(,1880)   ring r0=0,(x,y,z),Dp;
reference.tex(,1881)   string s="ideal k="+read("save_i")+";";
reference.tex(,1882)   s;
reference.tex(,1883) @expansion{} ideal k=x+y,z3+22y
reference.tex(,1884) @expansion{} ;
reference.tex(,1885)   execute(s); // define the ideal k
reference.tex(,1886)   k;
reference.tex(,1887) @expansion{} k[1]=x+y
reference.tex(,1888) @expansion{} k[2]=z3+22y
reference.tex(,1889) @c end example execute reference.doc:1463
reference.tex(,1890) @end smallexample
reference.tex(,1891) @end table
reference.tex(,1892) @c ---------------------------------------
reference.tex(,1893) @node exit, extgcd, execute, Functions
reference.tex(,1894) @subsection exit
reference.tex(,1895) @cindex exit
reference.tex(,1896) @table @code
reference.tex(,1897) @item @strong{Syntax:}
reference.tex(,1898) @code{exit;}
reference.tex(,1899) @item @strong{Purpose:}
reference.tex(,1900) exits (quits) @sc{Singular},
reference.tex(,1901) works also from inside a procedure or from an interrupt.
reference.tex(,1902) @end table
reference.tex(,1903) @c ---------------------------------------
reference.tex(,1904) @node extgcd, facstd, exit, Functions
reference.tex(,1905) @subsection extgcd
reference.tex(,1906) @cindex extgcd
reference.tex(,1907) 
reference.tex(,1908) @table @code
reference.tex(,1909) @item @strong{Syntax:}
reference.tex(,1910) @code{extgcd (} int_expression@code{,} int_expression @code{)}
reference.tex(,1911) @*@code{extgcd (} poly_expression@code{,} poly_expression @code{)}
reference.tex(,1912) @item @strong{Type:}
reference.tex(,1913) list of 3 objects of the same type as the type of the arguments
reference.tex(,1914) @item @strong{Purpose:}
reference.tex(,1915) computes extended gcd: the first element is the greatest common divisor
reference.tex(,1916) of the two arguments,
reference.tex(,1917) the second and third are factors such that if @code{list L=extgcd(a,b);}
reference.tex(,1918) then L[1]=a*L[2]+b*L[3].
reference.tex(,1919) @item @strong{Note:}
reference.tex(,1920) Polynomials must be univariate to apply @code{extgcd}.
reference.tex(,1921) @item @strong{Example:}
reference.tex(,1922) @smallexample
reference.tex(,1923) @c reused example extgcd reference.doc:1506 
reference.tex(,1924)   extgcd(24,10);
reference.tex(,1925) @expansion{} [1]:
reference.tex(,1926) @expansion{}    2
reference.tex(,1927) @expansion{} [2]:
reference.tex(,1928) @expansion{}    -2
reference.tex(,1929) @expansion{} [3]:
reference.tex(,1930) @expansion{}    5
reference.tex(,1931)   ring r=0,(x,y),lp;
reference.tex(,1932)   extgcd(x4-x6,(x2+x5)*(x2+x3));
reference.tex(,1933) @expansion{} [1]:
reference.tex(,1934) @expansion{}    2x5+2x4
reference.tex(,1935) @expansion{} [2]:
reference.tex(,1936) @expansion{}    x2+x+1
reference.tex(,1937) @expansion{} [3]:
reference.tex(,1938) @expansion{}    1
reference.tex(,1939) @c end example extgcd reference.doc:1506
reference.tex(,1940) @end smallexample
reference.tex(,1941) @end table
reference.tex(,1942) @c inserted refs from reference.doc:1513
reference.tex(,1957) @c end inserted refs from reference.doc:1513
reference.tex(,1958) @c ---------------------------------------
reference.tex(,1959) @node facstd, factorize, extgcd, Functions
reference.tex(,1960) @subsection facstd
reference.tex(,1961) @cindex facstd
reference.tex(,1962) 
reference.tex(,1963) @table @code
reference.tex(,1964) @item @strong{Syntax:}
reference.tex(,1965) @code{facstd (} ideal_expression @code{)}
reference.tex(,1966) @*@code{facstd (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,1967) @item @strong{Type:}
reference.tex(,1968) list of ideals
reference.tex(,1969) @item @strong{Purpose:}
reference.tex(,1970) returns a list of ideals computed by the factorizing Groebner basis algorithm.
reference.tex(,1971) @*The intersection of these ideals has the same zero-set as the input,
reference.tex(,1972) i.e., the radical of the intersection coincides with the radical of the input
reference.tex(,1973) ideal.
reference.tex(,1974) In many (but not all!) cases this is already a decomposition of the radical
reference.tex(,1975) of the ideal. (Note however, that, in general, no inclusion between the
reference.tex(,1976) input and output ideals holds.)
reference.tex(,1977) @*The second, optional argument gives a list of polynomials which define
reference.tex(,1978) non-zero constraints. Hence, the intersection of the output ideals
reference.tex(,1979) has a zero-set which is the (closure of the) complement of the zero-set
reference.tex(,1980) of the second argument in the zero-set of the first argument.
reference.tex(,1981) @item @strong{Note:}
reference.tex(,1982) Not implemented for baserings over real ground fields, galois fields and
reference.tex(,1983) over algebraic extensions over the rational numbers (that is, only
reference.tex(,1984) implemented for ground fields for which @ref{factorize} is implemented).
reference.tex(,1985) @item @strong{Example:}
reference.tex(,1986) @smallexample
reference.tex(,1987) @c reused example facstd reference.doc:1548 
reference.tex(,1988)   ring r=32003,(x,y,z),(c,dp);
reference.tex(,1989)   ideal I=xyz,x2z;
reference.tex(,1990)   facstd(I);
reference.tex(,1991) @expansion{} [1]:
reference.tex(,1992) @expansion{}    _[1]=z
reference.tex(,1993) @expansion{} [2]:
reference.tex(,1994) @expansion{}    _[1]=x
reference.tex(,1995)   facstd(I,x);
reference.tex(,1996) @expansion{} [1]:
reference.tex(,1997) @expansion{}    _[1]=z
reference.tex(,1998) @c end example facstd reference.doc:1548
reference.tex(,1999) @end smallexample
reference.tex(,2000) @end table
reference.tex(,2001) @c inserted refs from reference.doc:1556
reference.tex(,2016) @c end inserted refs from reference.doc:1556
reference.tex(,2017) @c ---------------------------------------
reference.tex(,2018) @node factorize, fetch, facstd, Functions
reference.tex(,2019) @subsection factorize
reference.tex(,2020) @cindex factorize
reference.tex(,2021) 
reference.tex(,2022) @table @code
reference.tex(,2023) @item @strong{Syntax:}
reference.tex(,2024) @code{factorize (} poly_expression @code{)}
reference.tex(,2025) @*@code{factorize (} poly_expression@code{, 0 )}
reference.tex(,2026) @*@code{factorize (} poly_expression@code{, 2 )}
reference.tex(,2027) @item @strong{Type:}
reference.tex(,2028) list of ideal and intvec
reference.tex(,2029) @*
reference.tex(,2030) @item @strong{Syntax:}
reference.tex(,2031) @code{factorize (} poly_expression@code{, 1 )}
reference.tex(,2032) @item @strong{Type:}
reference.tex(,2033) ideal
reference.tex(,2034) @item @strong{Purpose:}
reference.tex(,2035) computes the irreducible factors (as an ideal) of the polynomial
reference.tex(,2036) together with or without
reference.tex(,2037) the multiplicities (as an intvec) depending on the second argument:
reference.tex(,2038) @format
reference.tex(,2039)     0: returns factors and multiplicities, first factor is a constant.
reference.tex(,2040)        May also be written with only one argument.
reference.tex(,2041)     1: returns non-constant factors (no multiplicities).
reference.tex(,2042)     2: returns non-constant factors and multiplicities.
reference.tex(,2043) @end format
reference.tex(,2044) @item @strong{Note:}
reference.tex(,2045) Not implemented for the coefficient fields real and finite fields of
reference.tex(,2046) type @code{(p^n,a)}.
reference.tex(,2047) @item @strong{Example:}
reference.tex(,2048) @smallexample
reference.tex(,2049) @c reused example factorize reference.doc:1594 
reference.tex(,2050)   ring r=32003,(x,y,z),dp;
reference.tex(,2051)   factorize(9*(x-1)^2*(y+z));
reference.tex(,2052) @expansion{} [1]:
reference.tex(,2053) @expansion{}    _[1]=9
reference.tex(,2054) @expansion{}    _[2]=y+z
reference.tex(,2055) @expansion{}    _[3]=x-1
reference.tex(,2056) @expansion{} [2]:
reference.tex(,2057) @expansion{}    1,1,2
reference.tex(,2058)   factorize(9*(x-1)^2*(y+z),1);
reference.tex(,2059) @expansion{} _[1]=y+z
reference.tex(,2060) @expansion{} _[2]=x-1
reference.tex(,2061)   factorize(9*(x-1)^2*(y+z),2);
reference.tex(,2062) @expansion{} [1]:
reference.tex(,2063) @expansion{}    _[1]=y+z
reference.tex(,2064) @expansion{}    _[2]=x-1
reference.tex(,2065) @expansion{} [2]:
reference.tex(,2066) @expansion{}    1,2
reference.tex(,2067) @c end example factorize reference.doc:1594
reference.tex(,2068) @end smallexample
reference.tex(,2069) @end table
reference.tex(,2070) @c inserted refs from reference.doc:1602
reference.tex(,2081) @c end inserted refs from reference.doc:1602
reference.tex(,2082) @c ---------------------------------------
reference.tex(,2083) @node fetch, fglm, factorize, Functions
reference.tex(,2084) @subsection fetch
reference.tex(,2085) @cindex fetch
reference.tex(,2086) 
reference.tex(,2087) @table @code
reference.tex(,2088) @item @strong{Syntax:}
reference.tex(,2089) @code{fetch (} ring_name@code{,} name @code{)}
reference.tex(,2090) @item @strong{Type:}
reference.tex(,2091) number, poly, vector, ideal, module, matrix or list
reference.tex(,2092) (the same type as the second argument)
reference.tex(,2093) @item @strong{Purpose:}
reference.tex(,2094) maps objects between rings.
reference.tex(,2095) @code{fetch} is the identity map between rings and qrings,
reference.tex(,2096) the i-th variable of the source ring is mapped to the i-th
reference.tex(,2097) variable of the basering.  The coefficient fields must be compatible.
reference.tex(,2098) (See @ref{map} for a description of possible mapping between
reference.tex(,2099) different ground fields).
reference.tex(,2100) @*@code{fetch} offers a convenient way to change
reference.tex(,2101) variable names or orderings, or to map objects from a ring to a quotient
reference.tex(,2102) ring of that ring or vice versa.
reference.tex(,2103) @item @strong{Note:}
reference.tex(,2104) Compared with @code{imap}, @code{fetch} uses the position of the ring
reference.tex(,2105) variables, not their names.
reference.tex(,2106) @item @strong{Example:}
reference.tex(,2107) @smallexample
reference.tex(,2108) @c reused example fetch reference.doc:1632 
reference.tex(,2109)   ring r=0,(x,y,z),dp;
reference.tex(,2110)   ideal i=maxideal(2);
reference.tex(,2111)   ideal j=std(i);
reference.tex(,2112)   poly f=x+y2+z3;
reference.tex(,2113)   vector v=[f,1];
reference.tex(,2114)   qring q=j;
reference.tex(,2115)   poly f=fetch(r,f);
reference.tex(,2116)   f;
reference.tex(,2117) @expansion{} z3+y2+x
reference.tex(,2118)   vector v=fetch(r,v);
reference.tex(,2119)   v;
reference.tex(,2120) @expansion{} z3*gen(1)+y2*gen(1)+x*gen(1)+gen(2)
reference.tex(,2121)   ideal i=fetch(r,i);
reference.tex(,2122)   i;
reference.tex(,2123) @expansion{} i[1]=z2
reference.tex(,2124) @expansion{} i[2]=yz
reference.tex(,2125) @expansion{} i[3]=y2
reference.tex(,2126) @expansion{} i[4]=xz
reference.tex(,2127) @expansion{} i[5]=xy
reference.tex(,2128) @expansion{} i[6]=x2
reference.tex(,2129)   ring rr=0,(a,b,c),lp;
reference.tex(,2130)   poly f=fetch(q,f);
reference.tex(,2131)   f;
reference.tex(,2132) @expansion{} a+b2+c3
reference.tex(,2133)   vector v=fetch(r,v);
reference.tex(,2134)   v;
reference.tex(,2135) @expansion{} a*gen(1)+b2*gen(1)+c3*gen(1)+gen(2)
reference.tex(,2136)   ideal k=fetch(q,i);
reference.tex(,2137)   k;
reference.tex(,2138) @expansion{} k[1]=c2
reference.tex(,2139) @expansion{} k[2]=bc
reference.tex(,2140) @expansion{} k[3]=b2
reference.tex(,2141) @expansion{} k[4]=ac
reference.tex(,2142) @expansion{} k[5]=ab
reference.tex(,2143) @expansion{} k[6]=a2
reference.tex(,2144) @c end example fetch reference.doc:1632
reference.tex(,2145) @end smallexample
reference.tex(,2146) @end table
reference.tex(,2147) @c inserted refs from reference.doc:1655
reference.tex(,2164) @c end inserted refs from reference.doc:1655
reference.tex(,2165) @c ---------------------------------------
reference.tex(,2166) @node fglm, fglmquot, fetch, Functions
reference.tex(,2167) @subsection fglm
reference.tex(,2168) @cindex fglm
reference.tex(,2169) 
reference.tex(,2170) @table @code
reference.tex(,2171) @item @strong{Syntax:}
reference.tex(,2172) @code{fglm (} ring_name@code{,} ideal_name @code{)}
reference.tex(,2173) @item @strong{Type:}
reference.tex(,2174) ideal
reference.tex(,2175) @item @strong{Purpose:}
reference.tex(,2176) computes for the given ideal in the given ring
reference.tex(,2177) a reduced Groebner basis in the current ring, by applying the so-called FGLM
reference.tex(,2178) (Faugere, Gianni, Lazard, Mora)  algorithm.
reference.tex(,2179) @*The main application is to compute a lexicographical Groebner basis
reference.tex(,2180) from a reduced Groebner basis with respect to a degree ordering. This
reference.tex(,2181) can be much faster than computing a lexicographical Groebner basis
reference.tex(,2182) directly.
reference.tex(,2183) @item @strong{Note:}
reference.tex(,2184) The ideal must be zero-dimensional and given as a reduced Groebner
reference.tex(,2185) basis in the given ring.
reference.tex(,2186) @*The only permissible differences between the given ring and the current ring
reference.tex(,2187) are the monomial ordering and a permutation of the variables,
reference.tex(,2188) resp.@: parameters.
reference.tex(,2189) @item @strong{Example:}
reference.tex(,2190) @smallexample
reference.tex(,2191) @c reused example fglm reference.doc:1688 
reference.tex(,2192)   ring r=0,(x,y,z),dp;
reference.tex(,2193)   ideal i=y3+x2, x2y+x2, x3-x2, z4-x2-y;
reference.tex(,2194)   option(redSB);   // force the computation of a reduced SB
reference.tex(,2195)   i=std(i);
reference.tex(,2196)   vdim(i);
reference.tex(,2197) @expansion{} 28
reference.tex(,2198)   ring s=0,(z,x,y),lp;
reference.tex(,2199)   ideal j=fglm(r,i);
reference.tex(,2200)   j;
reference.tex(,2201) @expansion{} j[1]=y4+y3
reference.tex(,2202) @expansion{} j[2]=xy3-y3
reference.tex(,2203) @expansion{} j[3]=x2+y3
reference.tex(,2204) @expansion{} j[4]=z4+y3-y
reference.tex(,2205) @c end example fglm reference.doc:1688
reference.tex(,2206) @end smallexample
reference.tex(,2207) @end table
reference.tex(,2208) @c inserted refs from reference.doc:1700
reference.tex(,2231) @c end inserted refs from reference.doc:1700
reference.tex(,2232) @c ---------------------------------------
reference.tex(,2233) @node fglmquot, filecmd, fglm, Functions
reference.tex(,2234) @subsection fglmquot
reference.tex(,2235) @cindex fglmquot
reference.tex(,2236) 
reference.tex(,2237) @table @code
reference.tex(,2238) @item @strong{Syntax:}
reference.tex(,2239) @code{fglmquot (} ideal_expression@code{,} poly_expression @code{)}
reference.tex(,2240) @item @strong{Type:}
reference.tex(,2241) ideal
reference.tex(,2242) @item @strong{Purpose:}
reference.tex(,2243) computes a reduced Groebner basis of the ideal quotient @code{I:p} of
reference.tex(,2244) a zero-dimensional ideal @code{I} and a polynomial @code{p} using
reference.tex(,2245) FGLM-techniques.
reference.tex(,2246) @item @strong{Note:}
reference.tex(,2247) The ideal must be zero-dimensional and given as a reduced Groebner
reference.tex(,2248) basis in the given ring. The poly must be reduced with respect to the
reference.tex(,2249) ideal.
reference.tex(,2250) @item @strong{Example:}
reference.tex(,2251) @smallexample
reference.tex(,2252) @c reused example fglmquot reference.doc:1730 
reference.tex(,2253)   ring r=0,(x,y,z),lp;
reference.tex(,2254)   ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
reference.tex(,2255)   option(redSB);   // force the computation of a reduced SB
reference.tex(,2256)   i=std(i);
reference.tex(,2257)   poly p=reduce(x+yz2+z10,i);
reference.tex(,2258)   ideal j=fglmquot(i,p);
reference.tex(,2259)   j;
reference.tex(,2260) @expansion{} j[1]=z12
reference.tex(,2261) @expansion{} j[2]=yz4-z8
reference.tex(,2262) @expansion{} j[3]=y2+y-z8-z4
reference.tex(,2263) @expansion{} j[4]=x+y-z10-z6-z4
reference.tex(,2264) @c end example fglmquot reference.doc:1730
reference.tex(,2265) @end smallexample
reference.tex(,2266) @end table
reference.tex(,2267) @c inserted refs from reference.doc:1741
reference.tex(,2288) @c end inserted refs from reference.doc:1741
reference.tex(,2289) @c ---------------------------------------
reference.tex(,2290) @node filecmd, find, fglmquot, Functions
reference.tex(,2291) @subsection files, input from
reference.tex(,2292) @cindex filecmd
reference.tex(,2293) @cindex <
reference.tex(,2294) @table @code
reference.tex(,2295) @item @strong{Syntax:}
reference.tex(,2296) @code{< "}filename@code{"}
reference.tex(,2297) @item @strong{Type:}
reference.tex(,2298) none
reference.tex(,2299) @item @strong{Purpose:}
reference.tex(,2300) input comes from the file filename. Shorthand for
reference.tex(,2301) @code{execute(read(filename))}.
reference.tex(,2302) @item @strong{Example:}
reference.tex(,2303) @smallexample
reference.tex(,2304) < "example"; //read in the file example and execute it
reference.tex(,2305) @end smallexample
reference.tex(,2306) @end table
reference.tex(,2307) @c inserted refs from reference.doc:1768
reference.tex(,2320) @c end inserted refs from reference.doc:1768
reference.tex(,2321) @c ---------------------------------------
reference.tex(,2322) @node find, finduni, filecmd, Functions
reference.tex(,2323) @subsection find
reference.tex(,2324) @cindex find
reference.tex(,2325) @table @code
reference.tex(,2326) @item @strong{Syntax:}
reference.tex(,2327) @code{find (} string_expression@code{,} substring_expression @code{)}
reference.tex(,2328) @*@code{find (} string_expression@code{,} substring_expression@code{,} int_expression @code{)}
reference.tex(,2329) @item @strong{Type:}
reference.tex(,2330) int
reference.tex(,2331) @item @strong{Purpose:}
reference.tex(,2332) returns the first position of the substring
reference.tex(,2333) in the string or 0 (if not found),
reference.tex(,2334) @*starts the search at the position given in the 3rd argument.
reference.tex(,2335) @item @strong{Example:}
reference.tex(,2336) @smallexample
reference.tex(,2337) @c reused example find reference.doc:1789 
reference.tex(,2338)   find("Aac","a");
reference.tex(,2339) @expansion{} 2
reference.tex(,2340)   find("abab","a"+"b");
reference.tex(,2341) @expansion{} 1
reference.tex(,2342)   find("abab","a"+"b",2);
reference.tex(,2343) @expansion{} 3
reference.tex(,2344)   find("abab","ab",3);
reference.tex(,2345) @expansion{} 3
reference.tex(,2346)   find("0123","abcd");
reference.tex(,2347) @expansion{} 0
reference.tex(,2348) @c end example find reference.doc:1789
reference.tex(,2349) @end smallexample
reference.tex(,2350) @end table
reference.tex(,2351) @c inserted refs from reference.doc:1798
reference.tex(,2362) @c end inserted refs from reference.doc:1798
reference.tex(,2363) @c ---------------------------------------
reference.tex(,2364) @node finduni, fprintf, find, Functions
reference.tex(,2365) @subsection finduni
reference.tex(,2366) @cindex finduni
reference.tex(,2367) @table @code
reference.tex(,2368) @item @strong{Syntax:}
reference.tex(,2369) @code{finduni (} ideal_expression @code{)}
reference.tex(,2370) @item @strong{Type:}
reference.tex(,2371) ideal
reference.tex(,2372) @item @strong{Purpose:}
reference.tex(,2373) returns an ideal which is contained in the ideal_expression such that the i-th
reference.tex(,2374) generator is a univariate polynomial in the i-th ring variable.
reference.tex(,2375) @* The polynomials have minimal degree w.r.t.@: this property.
reference.tex(,2376) @item @strong{Note:}
reference.tex(,2377) The ideal must be zero-dimensional and given as a reduced Groebner basis in
reference.tex(,2378) the current ring.
reference.tex(,2379) @item @strong{Example:}
reference.tex(,2380) @smallexample
reference.tex(,2381) @c reused example finduni reference.doc:1820 
reference.tex(,2382)   ring  r=0,(x,y,z), dp;
reference.tex(,2383)   ideal i=y3+x2,x2y+x2,z4-x2-y;
reference.tex(,2384)   option(redSB);  // force computation of reduced basis
reference.tex(,2385)   i=std(i);
reference.tex(,2386)   ideal k=finduni(i);
reference.tex(,2387)   print(k);
reference.tex(,2388) @expansion{} x4-x2,
reference.tex(,2389) @expansion{} y4+y3,
reference.tex(,2390) @expansion{} z12
reference.tex(,2391) @c end example finduni reference.doc:1820
reference.tex(,2392) @end smallexample
reference.tex(,2393) @end table
reference.tex(,2394) @c inserted refs from reference.doc:1830
reference.tex(,2411) @c end inserted refs from reference.doc:1830
reference.tex(,2412) 
reference.tex(,2413) @c ---------------------------------------
reference.tex(,2414) @node fprintf, freemodule, finduni, Functions
reference.tex(,2415) @subsection fprintf
reference.tex(,2416) @cindex fprintf
reference.tex(,2417) @c start include of docu for standard.lib:fprintf
reference.tex(,2418) @c replaced @subsubsection by @sub
reference.tex(,2419) @c ---content fprintf---
reference.tex(,2420) Procedure from library @code{standard.lib} (@pxref{standard_lib}).
reference.tex(,2421) 
reference.tex(,2422) @table @asis
reference.tex(,2423) @item @strong{Syntax:}
reference.tex(,2424) @code{fprintf (} link_expression@code{,} string_expression @code{[,}
reference.tex(,2425) any_expressions@code{] )}
reference.tex(,2426) 
reference.tex(,2427) @item @strong{Return:}
reference.tex(,2428) none
reference.tex(,2429) 
reference.tex(,2430) @item @strong{Purpose:}
reference.tex(,2431) @code{fprintf(l,fmt,...);} performs output formatting.
reference.tex(,2432) The second argument is a format control string. Additional
reference.tex(,2433) arguments may be required, depending on the content of the
reference.tex(,2434) control string. A series of output characters is generated as
reference.tex(,2435) directed by the control string; these characters are
reference.tex(,2436) written to the link l.
reference.tex(,2437) The control string @code{fmt} is simply text to be copied, except
reference.tex(,2438) that the string may contain conversion specifications.@*
reference.tex(,2439) Do @code{help print;} for a listing of valid conversion
reference.tex(,2440) specifications. As an addition to the conversions of @code{print},
reference.tex(,2441) the @code{%n} and @code{%2} conversion specification does not
reference.tex(,2442) consume an additional argument, but simply generates a newline
reference.tex(,2443) character.
reference.tex(,2444) 
reference.tex(,2445) @item @strong{Note:}
reference.tex(,2446) If one of the additional arguments is a list, then it should be
reference.tex(,2447) enclosed once more into a @code{list()} command, since passing
reference.tex(,2448) a list as an argument flattens the list by one level.
reference.tex(,2449) 
reference.tex(,2450) @end table
reference.tex(,2451) @strong{Example:}
reference.tex(,2452) @smallexample
reference.tex(,2453) @c reused example fprintf d2t_singular/standard_lib.doc:393 
reference.tex(,2454)   ring r=0,(x,y,z),dp;
reference.tex(,2455) module m=[1,y],[0,x+z];
reference.tex(,2456) intmat M=betti(mres(m,0));
reference.tex(,2457) list l=r,m,M;
reference.tex(,2458) link li="";   // link to stdout
reference.tex(,2459) fprintf(li,"s:%s,l:%l",1,2);
reference.tex(,2460) @expansion{} s:1,l:int(2)
reference.tex(,2461) fprintf(li,"s:%s",l);
reference.tex(,2462) @expansion{} s:(0),(x,y,z),(dp(3),C)
reference.tex(,2463) fprintf(li,"s:%s",list(l));
reference.tex(,2464) @expansion{} s:(0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
reference.tex(,2465) fprintf(li,"2l:%2l",list(l));
reference.tex(,2466) @expansion{} 2l:list("(0),(x,y,z),(dp(3),C)",
reference.tex(,2467) @expansion{} module(y*gen(2)+gen(1),
reference.tex(,2468) @expansion{} x*gen(2)+z*gen(2)),
reference.tex(,2469) @expansion{} intmat(intvec(1,1 ),1,2))
reference.tex(,2470) @expansion{} 
reference.tex(,2471) fprintf(li,"%p",list(l));
reference.tex(,2472) @expansion{} [1]:
reference.tex(,2473) @expansion{}    //   characteristic : 0
reference.tex(,2474) @expansion{} //   number of vars : 3
reference.tex(,2475) @expansion{} //        block   1 : ordering dp
reference.tex(,2476) @expansion{} //                  : names    x y z 
reference.tex(,2477) @expansion{} //        block   2 : ordering C
reference.tex(,2478) @expansion{} [2]:
reference.tex(,2479) @expansion{}    _[1]=y*gen(2)+gen(1)
reference.tex(,2480) @expansion{}    _[2]=x*gen(2)+z*gen(2)
reference.tex(,2481) @expansion{} [3]:
reference.tex(,2482) @expansion{}    1,1 
reference.tex(,2483) @expansion{} 
reference.tex(,2484) fprintf(li,"%;",list(l));
reference.tex(,2485) @expansion{} [1]:
reference.tex(,2486) @expansion{}    //   characteristic : 0
reference.tex(,2487) @expansion{} //   number of vars : 3
reference.tex(,2488) @expansion{} //        block   1 : ordering dp
reference.tex(,2489) @expansion{} //                  : names    x y z 
reference.tex(,2490) @expansion{} //        block   2 : ordering C
reference.tex(,2491) @expansion{} [2]:
reference.tex(,2492) @expansion{}    _[1]=y*gen(2)+gen(1)
reference.tex(,2493) @expansion{}    _[2]=x*gen(2)+z*gen(2)
reference.tex(,2494) @expansion{} [3]:
reference.tex(,2495) @expansion{}    1,1 
reference.tex(,2496) @expansion{} 
reference.tex(,2497) fprintf(li,"%b",M);
reference.tex(,2498) @expansion{}            0     1
reference.tex(,2499) @expansion{} ------------------
reference.tex(,2500) @expansion{}     0:     1     1
reference.tex(,2501) @expansion{} ------------------
reference.tex(,2502) @expansion{} total:     1     1
reference.tex(,2503) @expansion{} 
reference.tex(,2504) @c end example fprintf d2t_singular/standard_lib.doc:393
reference.tex(,2505) @end smallexample
reference.tex(,2506) @c inserted refs from d2t_singular/standard_lib.doc:408
reference.tex(,2523) @c end inserted refs from d2t_singular/standard_lib.doc:408
reference.tex(,2524) 
reference.tex(,2525) @c ---end content fprintf---
reference.tex(,2526) @c generated lib proc docu for standard.lib:fprintf reference.doc:1842 
reference.tex(,2527) @c end include of docu for standard.lib:fprintf
reference.tex(,2528) 
reference.tex(,2529) @c ---------------------------------------
reference.tex(,2530) @node freemodule, gcd, fprintf, Functions
reference.tex(,2531) @subsection freemodule
reference.tex(,2532) @cindex freemodule
reference.tex(,2533) 
reference.tex(,2534) @table @code
reference.tex(,2535) @item @strong{Syntax:}
reference.tex(,2536) @code{freemodule (} int_expression @code{)}
reference.tex(,2537) @item @strong{Type:}
reference.tex(,2538) module
reference.tex(,2539) @item @strong{Purpose:}
reference.tex(,2540) creates the free module of rank n generated by
reference.tex(,2541) @code{gen(1)}, @dots{}, @code{gen(n)}.
reference.tex(,2542) @item @strong{Example:}
reference.tex(,2543) @smallexample
reference.tex(,2544) @c reused example freemodule reference.doc:1859 
reference.tex(,2545)   ring r=32003,(x,y),(c,dp);
reference.tex(,2546)   freemodule(3);
reference.tex(,2547) @expansion{} _[1]=[1]
reference.tex(,2548) @expansion{} _[2]=[0,1]
reference.tex(,2549) @expansion{} _[3]=[0,0,1]
reference.tex(,2550)   matrix m=freemodule(3); // generates the 3x3 unit matrix
reference.tex(,2551)   print(m);
reference.tex(,2552) @expansion{} 1,0,0,
reference.tex(,2553) @expansion{} 0,1,0,
reference.tex(,2554) @expansion{} 0,0,1 
reference.tex(,2555) @c end example freemodule reference.doc:1859
reference.tex(,2556) @end smallexample
reference.tex(,2557) @end table
reference.tex(,2558) @c inserted refs from reference.doc:1867
reference.tex(,2571) @c end inserted refs from reference.doc:1867
reference.tex(,2572) @c ---------------------------------------
reference.tex(,2573) @node gcd, gen, freemodule, Functions
reference.tex(,2574) @subsection gcd
reference.tex(,2575) @cindex gcd
reference.tex(,2576) 
reference.tex(,2577) @table @code
reference.tex(,2578) @item @strong{Syntax:}
reference.tex(,2579) @code{gcd (} int_expression@code{,} int_expression @code{)}
reference.tex(,2580) @*@code{gcd (} number_expression@code{,} number_expression @code{)}
reference.tex(,2581) @*@code{gcd (} poly_expression@code{,} poly_expression @code{)}
reference.tex(,2582) @item @strong{Type:}
reference.tex(,2583) the same as the type of the arguments
reference.tex(,2584) @item @strong{Purpose:}
reference.tex(,2585) computes the greatest common divisor.
reference.tex(,2586) @item @strong{Note:}
reference.tex(,2587) Not implemented for the coefficient fields real and finite fields of
reference.tex(,2588) type @code{(p^n,a)}.
reference.tex(,2589) @*The gcd of two numbers is their gcd as integer numbers or polynomials,
reference.tex(,2590) otherwise it is not defined.
reference.tex(,2591) @item @strong{Example:}
reference.tex(,2592) @smallexample
reference.tex(,2593) @c reused example gcd reference.doc:1893 
reference.tex(,2594)   gcd(2,3);
reference.tex(,2595) @expansion{} 1
reference.tex(,2596)   ring r=0,(x,y,z),lp;
reference.tex(,2597)   gcd(3x2*(x+y),9x*(y2-x2));
reference.tex(,2598) @expansion{} x2+xy
reference.tex(,2599)   gcd(number(6472674604870),number(878646537247372));
reference.tex(,2600) @expansion{} 2
reference.tex(,2601) @c end example gcd reference.doc:1893
reference.tex(,2602) @end smallexample
reference.tex(,2603) @end table
reference.tex(,2604) @c inserted refs from reference.doc:1901
reference.tex(,2621) @c end inserted refs from reference.doc:1901
reference.tex(,2622) @c ----------------------------------------
reference.tex(,2623) @node gen, getdump, gcd, Functions
reference.tex(,2624) @subsection gen
reference.tex(,2625) @cindex gen
reference.tex(,2626) 
reference.tex(,2627) @table @code
reference.tex(,2628) @item @strong{Syntax:}
reference.tex(,2629) @code{gen (} int_expression @code{)}
reference.tex(,2630) @item @strong{Type:}
reference.tex(,2631) vector
reference.tex(,2632) @item @strong{Purpose:}
reference.tex(,2633) returns the i-th free generator of a free module.
reference.tex(,2634) @item @strong{Example:}
reference.tex(,2635) @smallexample
reference.tex(,2636) @c reused example gen reference.doc:1922 
reference.tex(,2637)   ring r=32003,(x,y,z),(c,dp);
reference.tex(,2638)   gen(3);
reference.tex(,2639) @expansion{} [0,0,1]
reference.tex(,2640)   vector v=gen(5);
reference.tex(,2641)   poly f=xyz;
reference.tex(,2642)   v=v+f*gen(4); v;
reference.tex(,2643) @expansion{} [0,0,0,xyz,1]
reference.tex(,2644)   ring rr=32003,(x,y,z),dp;
reference.tex(,2645)   fetch(r,v);
reference.tex(,2646) @expansion{} xyz*gen(4)+gen(5)
reference.tex(,2647) @c end example gen reference.doc:1922
reference.tex(,2648) @end smallexample
reference.tex(,2649) @end table
reference.tex(,2650) @c inserted refs from reference.doc:1933
reference.tex(,2665) @c end inserted refs from reference.doc:1933
reference.tex(,2666) @c ---------------------------------------
reference.tex(,2667) @node getdump, groebner, gen, Functions
reference.tex(,2668) @subsection getdump
reference.tex(,2669) @cindex getdump
reference.tex(,2670) @table @code
reference.tex(,2671) @item @strong{Syntax:}
reference.tex(,2672) @code{getdump (} link_expression @code{)}
reference.tex(,2673) @item @strong{Type:}
reference.tex(,2674) none
reference.tex(,2675) @item @strong{Purpose:}
reference.tex(,2676) reads the content of the entire file, resp.@: link, and restores all variables
reference.tex(,2677) from it. For ASCII links, @code{getdump} is equivalent to an
reference.tex(,2678) @code{execute(read(} link @code{))} command. For MP links,
reference.tex(,2679) @code{getdump} should only be used on data which were previously
reference.tex(,2680) @code{dump}'ed.
reference.tex(,2681) @item @strong{Example:}
reference.tex(,2682) @smallexample
reference.tex(,2683) @c reused example getdump reference.doc:1956 
reference.tex(,2684)   int i=3;
reference.tex(,2685)   dump(":w example.txt");
reference.tex(,2686)   kill i;
reference.tex(,2687)   option(noredefine);
reference.tex(,2688)   getdump("example.txt");
reference.tex(,2689)   i;
reference.tex(,2690) @expansion{} 3
reference.tex(,2691) @c end example getdump reference.doc:1956
reference.tex(,2692) @end smallexample
reference.tex(,2693) @item @strong{Restrictions:}
reference.tex(,2694) @code{getdump} is not supported for DBM links, or for a link connecting
reference.tex(,2695) to @code{stdin} (standard input).
reference.tex(,2696) @end table
reference.tex(,2697) @c inserted refs from reference.doc:1969
reference.tex(,2712) @c end inserted refs from reference.doc:1969
reference.tex(,2713) @c ---------------------------------------
reference.tex(,2714) @node groebner, help, getdump, Functions
reference.tex(,2715) @subsection groebner
reference.tex(,2716) @cindex groebner
reference.tex(,2717) @c start include of docu for standard.lib:groebner
reference.tex(,2718) @c replaced @subsubsection by @sub
reference.tex(,2719) @c ---content groebner---
reference.tex(,2720) Procedure from library @code{standard.lib} (@pxref{standard_lib}).
reference.tex(,2721) 
reference.tex(,2722) @table @asis
reference.tex(,2723) @item @strong{Syntax:}
reference.tex(,2724) @code{groebner (} ideal_expression @code{)} @*
reference.tex(,2725) @code{groebner (} module_expression @code{)} @*
reference.tex(,2726) @code{groebner (} ideal_expression@code{,} int_expression @code{)} @*
reference.tex(,2727) @code{groebner (} module_expression@code{,} int_expression @code{)}
reference.tex(,2728) 
reference.tex(,2729) @item @strong{Type:}
reference.tex(,2730) type of the first argument
reference.tex(,2731) 
reference.tex(,2732) @item @strong{Purpose:}
reference.tex(,2733) computes the standard basis of the first argument @code{I}
reference.tex(,2734) (ideal or module), by a heuristically chosen method: if the
reference.tex(,2735) ordering of the current ring is a local ordering, or if it is a
reference.tex(,2736) non-block ordering and the current ring has no parameters, then
reference.tex(,2737) @code{std(I)} is returned. Otherwise, @code{I} is mapped into a
reference.tex(,2738) ring with no parameters and ordering dp, where its Hilbert series
reference.tex(,2739) is computed. This is followed by a Hilbert-series based std
reference.tex(,2740) computation in the original ring.
reference.tex(,2741) 
reference.tex(,2742) @item @strong{Note:}
reference.tex(,2743) If a 2nd argument @code{wait} is given, then the computation proceeds
reference.tex(,2744) at most @code{wait} seconds. That is, if no result could be computed in
reference.tex(,2745) @code{wait} seconds, then the computation is interrupted, 0 is returned,
reference.tex(,2746) a warning message is displayed, and the global variable
reference.tex(,2747) @code{groebner_error} is defined.
reference.tex(,2748) 
reference.tex(,2749) @cindex time limit on computations
reference.tex(,2750) @cindex MP, groebner basis computations
reference.tex(,2751) @end table
reference.tex(,2752) @strong{Example:}
reference.tex(,2753) @smallexample
reference.tex(,2754) @c reused example groebner d2t_singular/standard_lib.doc:149 
reference.tex(,2755)   ring r=0,(a,b,c,d),lp;
reference.tex(,2756) option(prot);
reference.tex(,2757) ideal i=a+b+c+d,ab+ad+bc+cd,abc+abd+acd+bcd,abcd-1; // cyclic 4
reference.tex(,2758) groebner(i);
reference.tex(,2759) @expansion{} std in (0),(a,b,c,d,@@t),(dp,C)
reference.tex(,2760) @expansion{} [63:1]1(3)s2(2)s3s4-s5ss6-s7--
reference.tex(,2761) @expansion{} product criterion:8 chain criterion:5
reference.tex(,2762) @expansion{} std with hilb in  (0),(a,b,c,d,@@t),(lp(4),C)
reference.tex(,2763) @expansion{} [63:1]1(3)s2(2)s3s4-s5ss6shhhh8shh
reference.tex(,2764) @expansion{} product criterion:9 chain criterion:8
reference.tex(,2765) @expansion{} hilbert series criterion:6
reference.tex(,2766) @expansion{} dehomogenization
reference.tex(,2767) @expansion{} imap to original ring
reference.tex(,2768) @expansion{} simplification
reference.tex(,2769) @expansion{} _[1]=c2d6-c2d2-d4+1
reference.tex(,2770) @expansion{} _[2]=c3d2+c2d3-c-d
reference.tex(,2771) @expansion{} _[3]=bd4-b+d5-d
reference.tex(,2772) @expansion{} _[4]=bc-bd5+c2d4+cd-d6-d2
reference.tex(,2773) @expansion{} _[5]=b2+2bd+d2
reference.tex(,2774) @expansion{} _[6]=a+b+c+d
reference.tex(,2775) ring rp=(0,a,b),(c,d), lp;
reference.tex(,2776) ideal i=imap(r,i);
reference.tex(,2777) ideal j=groebner(i);
reference.tex(,2778) @expansion{} std in 0,(c,d,a,b,@@t),(dp,C)
reference.tex(,2779) @expansion{} [63:1]1(3)s2(2)s3s4-s5ss6-s7--
reference.tex(,2780) @expansion{} product criterion:8 chain criterion:5
reference.tex(,2781) @expansion{} std with hilb in  (0),(c,d,a,b,@@t),(lp(2),C, dp(3))
reference.tex(,2782) @expansion{} [63:3]1(3)s2(2)s3s4-s5ss6shhhh8shh
reference.tex(,2783) @expansion{} product criterion:9 chain criterion:8
reference.tex(,2784) @expansion{} hilbert series criterion:6
reference.tex(,2785) @expansion{} dehomogenization
reference.tex(,2786) @expansion{} imap to original ring
reference.tex(,2787) @expansion{} simplification
reference.tex(,2788) option(noprot);
reference.tex(,2789) j; simplify(j,1); std(i);
reference.tex(,2790) @expansion{} j[1]=(a3b2+a2b3-a-b)
reference.tex(,2791) @expansion{} _[1]=1
reference.tex(,2792) @expansion{} _[1]=1
reference.tex(,2793) if (system("with","MP")) @{groebner(i,0);@}
reference.tex(,2794) @expansion{} // ** groebner did not finish
reference.tex(,2795) @expansion{} _[1]=0
reference.tex(,2796) defined(groebner_error);
reference.tex(,2797) @expansion{} 1
reference.tex(,2798) @c end example groebner d2t_singular/standard_lib.doc:149
reference.tex(,2799) @end smallexample
reference.tex(,2800) @c inserted refs from d2t_singular/standard_lib.doc:163
reference.tex(,2815) @c end inserted refs from d2t_singular/standard_lib.doc:163
reference.tex(,2816) 
reference.tex(,2817) @c ---end content groebner---
reference.tex(,2818) @c generated lib proc docu for standard.lib:groebner reference.doc:1979 
reference.tex(,2819) @c end include of docu for standard.lib:groebner
reference.tex(,2820) 
reference.tex(,2821) @c @table @code
reference.tex(,2822) @c @item @strong{Syntax:}
reference.tex(,2823) @c @code{groebner (} ideal_expression @code{)}
reference.tex(,2824) @c @*@code{groebner (} module_expression @code{)}
reference.tex(,2825) @c @item @strong{Type:}
reference.tex(,2826) @c ideal or module
reference.tex(,2827) @c @item @strong{Purpose:}
reference.tex(,2828) @c returns a standard basis of an ideal or module with respect to the
reference.tex(,2829) @c monomial ordering of the basering using a heuristically chosen method.
reference.tex(,2830) @c @item @strong{Example:}
reference.tex(,2831) @c @example
reference.tex(,2832) @c @c example
reference.tex(,2833) @c   ring r=0,(a,b,c,d),lp;
reference.tex(,2834) @c   ideal i=a+b+c+d,ab+ad+bc+cd,abc+abd+acd+bcd,abcd-1;
reference.tex(,2835) @c   groebner(i);
reference.tex(,2836) @c @c example
reference.tex(,2837) @c @end example
reference.tex(,2838) @c @end table
reference.tex(,2839) @c @c ref
reference.tex(,2840) @c See
reference.tex(,2841) @c @ref{std};
reference.tex(,2842) @c @ref{stdfglm};
reference.tex(,2843) @c @ref{stdhilb}.
reference.tex(,2844) @c @c ref
reference.tex(,2845) @c ---------------------------------------
reference.tex(,2846) @node help, highcorner, groebner, Functions
reference.tex(,2847) @subsection help
reference.tex(,2848) @cindex help
reference.tex(,2849) @table @code
reference.tex(,2850) @item @strong{Syntax:}
reference.tex(,2851) @code{help;}
reference.tex(,2852) @*@code{help} topic @code{;}
reference.tex(,2853) @item @strong{Type:}
reference.tex(,2854) none
reference.tex(,2855) @item @strong{Purpose:}
reference.tex(,2856) displays online help information for @code{topic} using the currently
reference.tex(,2857) set help browser. If no @code{topic} is given, the title page of the
reference.tex(,2858) manual is displayed.
reference.tex(,2859) 
reference.tex(,2860) @item @strong{Note:}
reference.tex(,2861) @itemize @bullet
reference.tex(,2862) @cindex ?
reference.tex(,2863) @item
reference.tex(,2864) @code{?} may be used instead of @code{help}.
reference.tex(,2865) 
reference.tex(,2866) @item
reference.tex(,2867) @code{topic} can be an index entry of the @sc{Singular} manual or the
reference.tex(,2868) name of a (loaded) procedure which has a help section.
reference.tex(,2869) @item
reference.tex(,2870) @code{topic} may contain wildcard characters (i.e.,
reference.tex(,2871) @code{*} characters).
reference.tex(,2872) @item
reference.tex(,2873) If a (possibly "wildcarded") @code{topic} cannot be found (or
reference.tex(,2874) uniquely matched) a warning is displayed and no help information is
reference.tex(,2875) provided.
reference.tex(,2876) @item
reference.tex(,2877) If @code{topic} is the name of a (loaded) procedure whose help
reference.tex(,2878) section has changed w.r.t.@: the help available in the manual then,
reference.tex(,2879) instead of displaying the respective help section of the manual in the
reference.tex(,2880) help browser, the "newer" help section of the procedure is simply
reference.tex(,2881) printed to the terminal.
reference.tex(,2882) 
reference.tex(,2883) @item
reference.tex(,2884) The browser in which the help information is displayed can be either set
reference.tex(,2885) with the command-line option @code{--browser=<browser>} (@pxref{Command
reference.tex(,2886) line options}), or with the command @code{system("--browser",
reference.tex(,2887) "<browser>")}. Use the command @code{system("browsers");} for a list of
reference.tex(,2888) all available browsers. @xref{The online help system}, for more details
reference.tex(,2889) about help browsers.
reference.tex(,2890) 
reference.tex(,2891) @end itemize
reference.tex(,2892) 
reference.tex(,2893) @item @strong{Example:}
reference.tex(,2894) @smallexample
reference.tex(,2895) help;      // display title page of manual
reference.tex(,2896) help ring; // display help for 'ring'
reference.tex(,2897) ?ringe;    // equivalent to 'help ringe;'
reference.tex(,2898) @expansion{} // ** No help for topic 'ringe' (not even for '*ringe*')
reference.tex(,2899) @expansion{} // ** Try '?;'       for general help
reference.tex(,2900) @expansion{} // ** or  '?Index;'  for all available help topics
reference.tex(,2901) ?ring*;
reference.tex(,2902) @expansion{} //  ** No unique help for 'ring*'
reference.tex(,2903) @expansion{} //  ** Try one of
reference.tex(,2904) @expansion{} ?Rings and orderings; ?Rings and standard bases; ?ring;
reference.tex(,2905) @expansion{} ?ring declarations; ?ring operations; ?ring related functions;
reference.tex(,2906) @expansion{} ?ring.lib; ?ring_lib; ?ringtensor; ?ringweights;
reference.tex(,2907) help Rings and orderings;
reference.tex(,2908) help standard.lib;  // displays help for library 'standard.lib'
reference.tex(,2909) @end smallexample
reference.tex(,2910) @end table
reference.tex(,2911) 
reference.tex(,2912) @c inserted refs from reference.doc:2072
reference.tex(,2931) @c end inserted refs from reference.doc:2072
reference.tex(,2932) @c ---------------------------------------
reference.tex(,2933) @node highcorner, hilb, help, Functions
reference.tex(,2934) @subsection highcorner
reference.tex(,2935) @cindex highcorner
reference.tex(,2936) @table @code
reference.tex(,2937) @item @strong{Syntax:}
reference.tex(,2938) @code{highcorner (} ideal_expression @code{)}
reference.tex(,2939) @*@code{highcorner (} module_expression @code{)}
reference.tex(,2940) @item @strong{Type:}
reference.tex(,2941) poly, resp.@: vector
reference.tex(,2942) @item @strong{Purpose:}
reference.tex(,2943) returns the smallest monomial not contained in
reference.tex(,2944) the ideal, resp.@: module, generated by the initial terms of the given
reference.tex(,2945) generators. If the generators are a standard basis,
reference.tex(,2946) this is also the smallest monomial not contained in the ideal, resp.@: module.
reference.tex(,2947) @*If the ideal, resp.@: module, is not zero-dimensional, 0 is returned.
reference.tex(,2948) @item @strong{Note:}
reference.tex(,2949) Let the ideal I be given by a standard basis. Then
reference.tex(,2950) @code{highcorner(I)} returns 0 iff @code{dim(I)>0} or @code{dim(I)=-1}.
reference.tex(,2951) Otherwise it returns the smallest monomial m not in I which has the following
reference.tex(,2952) properties (with
reference.tex(,2959) the variables of the basering):
reference.tex(,2960) @itemize @bullet
reference.tex(,2961) @item
reference.tex(,2962) if
reference.tex(,2969) does not divide m (e.g., m=1 if the ordering is global)
reference.tex(,2970) @item
reference.tex(,2971) given any set of generators
reference.tex(,2982) @end itemize
reference.tex(,2983) @item @strong{Example:}
reference.tex(,2984) @smallexample
reference.tex(,2985) @c reused example highcorner reference.doc:2133 
reference.tex(,2986) ring r=0,(x,y),ds;
reference.tex(,2987) ideal i=x3,x2y,y3;
reference.tex(,2988) highcorner(std(i));
reference.tex(,2989) @expansion{} xy2
reference.tex(,2990) highcorner(std(ideal(1)));
reference.tex(,2991) @expansion{} 0
reference.tex(,2992) @c end example highcorner reference.doc:2133
reference.tex(,2993) @end smallexample
reference.tex(,2994) @end table
reference.tex(,2995) @c inserted refs from reference.doc:2141
reference.tex(,3010) @c end inserted refs from reference.doc:2141
reference.tex(,3011) @c ---------------------------------------
reference.tex(,3012) @node hilb, homog, highcorner, Functions
reference.tex(,3013) @subsection hilb
reference.tex(,3014) @cindex hilb
reference.tex(,3015) @table @code
reference.tex(,3016) @item @strong{Syntax:}
reference.tex(,3017) @code{hilb (} ideal_expression @code{)}
reference.tex(,3018) @*@code{hilb (} module_expression @code{)}
reference.tex(,3019) @*@code{hilb (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,3020) @*@code{hilb (} module_expression@code{,} int_expression @code{)}
reference.tex(,3021) @*@code{hilb (} ideal_expression@code{,} int_expression @code{,} intvec_expression @code{)}
reference.tex(,3022) @*@code{hilb (} module_expression@code{,} int_expression @code{,} intvec_expression @code{)}
reference.tex(,3023) @item @strong{Type:}
reference.tex(,3024) none (if called with one argument)
reference.tex(,3025) @*intvec (if called with two or three arguments)
reference.tex(,3026) @item @strong{Purpose:}
reference.tex(,3027) computes the (weighted) Hilbert series of the ideal, resp.@: module,
reference.tex(,3028) defined by the leading terms of the generators of the given ideal, resp.@: module.@*
reference.tex(,3029) If @code{hilb} is called with one argument, then the 1st and 2nd Hilbert series
reference.tex(,3030) together with some additional information are displayed.@*
reference.tex(,3031) If @code{hilb} is called with two arguments, then the n-th Hilbert series is returned
reference.tex(,3032) as an intvec, where n=1,2 is the second argument.@*
reference.tex(,3033) If a weight vector w is a given as 3rd argument, then the Hilbert series is computed
reference.tex(,3034) w.r.t.@: these weights w (by default all weights are set to 1).
reference.tex(,3035) @item @strong{Caution:}
reference.tex(,3036) The last entry of the returned intvec is not part of the actual Hilbert series,
reference.tex(,3037) but is used in the Hilbert driven standard basis computation (see @ref{stdhilb}).
reference.tex(,3038) @item @strong{Note:}
reference.tex(,3039) If the input is homogeneous w.r.t.@: the weights and a standard basis, the result is
reference.tex(,3040) the (weighted) Hilbert series of the original ideal, resp.@: module.@*
reference.tex(,3041) @item @strong{Example:}
reference.tex(,3042) @smallexample
reference.tex(,3043) @c reused example hilb reference.doc:2179 
reference.tex(,3044)   ring R=32003,(x,y,z),dp;
reference.tex(,3045)   ideal i=x2,y2,z2;
reference.tex(,3046)   ideal s=std(i);
reference.tex(,3047)   hilb(s);
reference.tex(,3048) @expansion{} //         1 t^0
reference.tex(,3049) @expansion{} //        -3 t^2
reference.tex(,3050) @expansion{} //         3 t^4
reference.tex(,3051) @expansion{} //        -1 t^6
reference.tex(,3052) @expansion{} 
reference.tex(,3053) @expansion{} //         1 t^0
reference.tex(,3054) @expansion{} //         3 t^1
reference.tex(,3055) @expansion{} //         3 t^2
reference.tex(,3056) @expansion{} //         1 t^3
reference.tex(,3057) @expansion{} // dimension (affine)  = 0
reference.tex(,3058) @expansion{} // degree      = 8
reference.tex(,3059)   hilb(s,1);
reference.tex(,3060) @expansion{} 1,0,-3,0,3,0,-1,0
reference.tex(,3061)   hilb(s,2);
reference.tex(,3062) @expansion{} 1,3,3,1,0
reference.tex(,3063)   intvec w=2,2,2;
reference.tex(,3064)   hilb(s,1,w);
reference.tex(,3065) @expansion{} 1,0,0,0,-3,0,0,0,3,0,0,0,-1,0
reference.tex(,3066) @c end example hilb reference.doc:2179
reference.tex(,3067) @end smallexample
reference.tex(,3068) @end table
reference.tex(,3069) @c inserted refs from reference.doc:2191
reference.tex(,3090) @c end inserted refs from reference.doc:2191
reference.tex(,3091) @c ---------------------------------------
reference.tex(,3092) @node homog, hres, hilb, Functions
reference.tex(,3093) @subsection homog
reference.tex(,3094) @cindex homog
reference.tex(,3095) 
reference.tex(,3096) @table @code
reference.tex(,3097) @item @strong{Syntax:}
reference.tex(,3098) @code{homog (} ideal_expression @code{)}
reference.tex(,3099) @*@code{homog (} module_expression @code{)}
reference.tex(,3100) @item @strong{Type:}
reference.tex(,3101) int
reference.tex(,3102) @item @strong{Purpose:}
reference.tex(,3103) tests for homogeneity: returns 1 for homogeneous input, 0 otherwise.
reference.tex(,3104) @item @strong{Syntax:}
reference.tex(,3105) @*@code{homog (} polynomial_expression@code{,} ring_variable @code{)}
reference.tex(,3106) @*@code{homog (} vector_expression@code{,} ring_variable @code{)}
reference.tex(,3107) @*@code{homog (} ideal_expression@code{,} ring_variable @code{)}
reference.tex(,3108) @*@code{homog (} module_expression@code{,} ring_variable @code{)}
reference.tex(,3109) @item @strong{Type:}
reference.tex(,3110) same as first argument
reference.tex(,3111) @item @strong{Purpose:}
reference.tex(,3112) homogenizes polynomials, vectors, ideals, or modules by multiplying
reference.tex(,3113) each monomial with a suitable power of the given ring variable (which must have
reference.tex(,3114) weight 1).
reference.tex(,3115) @item @strong{Example:}
reference.tex(,3116) @smallexample
reference.tex(,3117) @c reused example homog reference.doc:2226 
reference.tex(,3118)   ring r=32003,(x,y,z),ds;
reference.tex(,3119)   poly s1=x3y2+x5y+3y9;
reference.tex(,3120)   poly s2=x2y2z2+3z8;
reference.tex(,3121)   poly s3=5x4y2+4xy5+2x2y2z3+y7+11x10;
reference.tex(,3122)   ideal i=s1,s2,s3;
reference.tex(,3123)   homog(s2,z);
reference.tex(,3124) @expansion{} x2y2z4+3z8
reference.tex(,3125)   homog(i,z);
reference.tex(,3126) @expansion{} _[1]=3y9+x5yz3+x3y2z4
reference.tex(,3127) @expansion{} _[2]=x2y2z4+3z8
reference.tex(,3128) @expansion{} _[3]=11x10+y7z3+5x4y2z4+4xy5z4+2x2y2z6
reference.tex(,3129)   homog(i);
reference.tex(,3130) @expansion{} 0
reference.tex(,3131)   homog(homog(i,z));
reference.tex(,3132) @expansion{} 1
reference.tex(,3133) @c end example homog reference.doc:2226
reference.tex(,3134) @end smallexample
reference.tex(,3135) @end table
reference.tex(,3136) @c inserted refs from reference.doc:2239
reference.tex(,3153) @c end inserted refs from reference.doc:2239
reference.tex(,3154) @c ---------------------------------------
reference.tex(,3155) @node hres, imap, homog, Functions
reference.tex(,3156) @subsection hres
reference.tex(,3157) @cindex hres
reference.tex(,3158) @cindex resolution, hilbert-driven
reference.tex(,3159) @table @code
reference.tex(,3160) @item @strong{Syntax:}
reference.tex(,3161) @code{hres (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,3162) @item @strong{Type:}
reference.tex(,3163) resolution
reference.tex(,3164) @item @strong{Purpose:}
reference.tex(,3165) computes a free resolution of an ideal using the Hilbert-driven
reference.tex(,3166) algorithm.
reference.tex(,3167) 
reference.tex(,3168) More precisely, let R be the basering and I be the given ideal.
reference.tex(,3169) Then @code{hres} computes a minimal free resolution of R/I
reference.tex(,3181) If the int_expression k is not zero then the computation stops after
reference.tex(,3182) k steps and returns a list of modules
reference.tex(,3189) 
reference.tex(,3190) @code{list L=hres(I,0);} returns a list L of n modules (where n is the
reference.tex(,3191) number of variables of the basering) such that
reference.tex(,3198) in the above notation.
reference.tex(,3199) @item @strong{Note:}
reference.tex(,3200) The ideal_expression has to be homogeneous.
reference.tex(,3201) @* Accessing single elements of a resolution may require that some partial
reference.tex(,3202) computations have to be finished and may therefore take some time.
reference.tex(,3203) @item @strong{Example:}
reference.tex(,3204) @smallexample
reference.tex(,3205) @c reused example hres reference.doc:2297 
reference.tex(,3206)   ring r=0,(x,y,z),dp;
reference.tex(,3207)   ideal I=xz,yz,x3-y3;
reference.tex(,3208)   def L=hres(I,0);
reference.tex(,3209)   print(betti(L),"betti");
reference.tex(,3210) @expansion{}            0     1     2
reference.tex(,3211) @expansion{} ------------------------
reference.tex(,3212) @expansion{}     0:     1     -     -
reference.tex(,3213) @expansion{}     1:     -     2     1
reference.tex(,3214) @expansion{}     2:     -     1     1
reference.tex(,3215) @expansion{} ------------------------
reference.tex(,3216) @expansion{} total:     1     3     2
reference.tex(,3217)   L[2];     // the first syzygy module of r/I
reference.tex(,3218) @expansion{} _[1]=-x*gen(1)+y*gen(2)
reference.tex(,3219) @expansion{} _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)
reference.tex(,3220) @c end example hres reference.doc:2297
reference.tex(,3221) @end smallexample
reference.tex(,3222) @end table
reference.tex(,3223) @c inserted refs from reference.doc:2306
reference.tex(,3250) @c end inserted refs from reference.doc:2306
reference.tex(,3251) @c ---------------------------------------
reference.tex(,3252) @node imap, impart, hres, Functions
reference.tex(,3253) @subsection imap
reference.tex(,3254) @cindex imap
reference.tex(,3255) 
reference.tex(,3256) @table @code
reference.tex(,3257) @item @strong{Syntax:}
reference.tex(,3258) @code{imap (} ring_name@code{,} name @code{)}
reference.tex(,3259) @item @strong{Type:}
reference.tex(,3260) number, poly, vector, ideal, module, matrix or list
reference.tex(,3261) (the same type as the second argument)
reference.tex(,3262) @item @strong{Purpose:}
reference.tex(,3263) identity map on common subrings.  @code{imap} is the map between rings
reference.tex(,3264) and qrings with compatible ground fields which is the identity on
reference.tex(,3265) variables and parameters of the same name and 0 otherwise.
reference.tex(,3266) (See @ref{map} for a description of possible mapping between
reference.tex(,3267) different ground fields).
reference.tex(,3268) Useful for mapping from a homogenized ring to the original ring or
reference.tex(,3269) for mappings from/to rings with/without parameters. Compared with
reference.tex(,3270) @code{fetch}, @code{imap} uses the names of variables and parameters.
reference.tex(,3271) Unlike @code{map} and @code{fetch} @code{imap} can map parameters to variables.
reference.tex(,3272) @item @strong{Example:}
reference.tex(,3273) @smallexample
reference.tex(,3274) @c reused example imap reference.doc:2341 
reference.tex(,3275)   ring r=0,(x,y,z,a,b,c),dp;
reference.tex(,3276)   ideal i=xy2z3a4b5+1,homog(xy2z3a4b5+1,c); i;
reference.tex(,3277) @expansion{} i[1]=xy2z3a4b5+1
reference.tex(,3278) @expansion{} i[2]=xy2z3a4b5+c15
reference.tex(,3279)   ring r1=0,(a,b,x,y,z),lp;
reference.tex(,3280)   ideal j=imap(r,i); j;
reference.tex(,3281) @expansion{} j[1]=a4b5xy2z3+1
reference.tex(,3282) @expansion{} j[2]=a4b5xy2z3
reference.tex(,3283)   ring r2=(0,a,b),(x,y,z),ls;
reference.tex(,3284)   ideal j=imap(r,i); j;
reference.tex(,3285) @expansion{} j[1]=1+(a4b5)*xy2z3
reference.tex(,3286) @expansion{} j[2]=(a4b5)*xy2z3
reference.tex(,3287) @c end example imap reference.doc:2341
reference.tex(,3288) @end smallexample
reference.tex(,3289) @end table
reference.tex(,3290) @c inserted refs from reference.doc:2351
reference.tex(,3309) @c end inserted refs from reference.doc:2351
reference.tex(,3310) @c ---------------------------------------
reference.tex(,3311) @node impart, indepSet, imap, Functions
reference.tex(,3312) @subsection impart
reference.tex(,3313) @cindex impart
reference.tex(,3314) 
reference.tex(,3315) @table @code
reference.tex(,3316) @item @strong{Syntax:}
reference.tex(,3317) @code{impart (} number_expression @code{)}
reference.tex(,3318) @item @strong{Type:}
reference.tex(,3319) number
reference.tex(,3320) @item @strong{Purpose:}
reference.tex(,3321) returns the imaginary part of a number in a complex ground field,
reference.tex(,3322) @*returns 0 otherwise.
reference.tex(,3323) @item @strong{Example:}
reference.tex(,3324) @smallexample
reference.tex(,3325) @c reused example impart reference.doc:2374 
reference.tex(,3326)   ring r=(complex,i),x,dp;
reference.tex(,3327)   impart(1+2*i);
reference.tex(,3328) @expansion{} 2
reference.tex(,3329) @c end example impart reference.doc:2374
reference.tex(,3330) @end smallexample
reference.tex(,3331) @end table
reference.tex(,3332) @c inserted refs from reference.doc:2380
reference.tex(,3343) @c end inserted refs from reference.doc:2380
reference.tex(,3344) @c ---------------------------------------
reference.tex(,3345) @node indepSet, insert, impart, Functions
reference.tex(,3346) @subsection indepSet
reference.tex(,3347) @cindex indepSet
reference.tex(,3348) 
reference.tex(,3349) @table @code
reference.tex(,3350) @item @strong{Syntax:}
reference.tex(,3351) @code{indepSet (} ideal_expression @code{)}
reference.tex(,3352) @item @strong{Type:}
reference.tex(,3353) intvec
reference.tex(,3354) @item @strong{Purpose:}
reference.tex(,3355) computes a maximal set U of independent variables of the ideal given by
reference.tex(,3356) a standard basis.  If @code{v} is the result then @code{v[i]} is 1 if and
reference.tex(,3357) only if the i-th variable of the ring, @code{x(i)}, is an independent
reference.tex(,3358) variable.  Hence, the set U consisting of all variables @code{x(i)} with
reference.tex(,3359) @code{v[i]=1} is a maximal independent set.
reference.tex(,3360) 
reference.tex(,3361) @c Indeed we compute a maximal strongly independent set U,
reference.tex(,3362) @c where no power of a variable from U occurs as a leading term ofs
reference.tex(,3363) @c a standard basis of the ideal.
reference.tex(,3364) 
reference.tex(,3365) @item @strong{Note:}
reference.tex(,3366) U is a set of independent variables for I if and only if
reference.tex(,3373) i.e., eliminating the remaining variables gives (0).
reference.tex(,3374) U is maximal if dim(I)=#U.
reference.tex(,3375) @item @strong{Syntax:}
reference.tex(,3376) @code{indepSet (} ideal_expression, int_expression @code{)}
reference.tex(,3377) @item @strong{Type:}
reference.tex(,3378) list
reference.tex(,3379) @item @strong{Purpose:}
reference.tex(,3380) computes a list of all maximal independent sets of the leading ideal
reference.tex(,3381) (if the flag is 0), resp.@: of all those sets of independent variables
reference.tex(,3382) of the leading ideal which cannot be enlarged.
reference.tex(,3383) @item @strong{Example:}
reference.tex(,3384) @smallexample
reference.tex(,3385) @c reused example indepSet reference.doc:2425 
reference.tex(,3386)   ring r=32003,(x,y,u,v,w),dp;
reference.tex(,3387)   ideal I=xyw,yvw,uyw,xv;
reference.tex(,3388)   attrib(I,"isSB",1);
reference.tex(,3389)   indepSet(I);
reference.tex(,3390) @expansion{} 1,1,1,0,0
reference.tex(,3391)   eliminate(I,vw);
reference.tex(,3392) @expansion{} _[1]=0
reference.tex(,3393)   indepSet(I,0);
reference.tex(,3394) @expansion{} [1]:
reference.tex(,3395) @expansion{}    1,1,1,0,0
reference.tex(,3396) @expansion{} [2]:
reference.tex(,3397) @expansion{}    0,1,1,1,0
reference.tex(,3398) @expansion{} [3]:
reference.tex(,3399) @expansion{}    1,0,1,0,1
reference.tex(,3400) @expansion{} [4]:
reference.tex(,3401) @expansion{}    0,0,1,1,1
reference.tex(,3402)   indepSet(I,1);
reference.tex(,3403) @expansion{} [1]:
reference.tex(,3404) @expansion{}    1,1,1,0,0
reference.tex(,3405) @expansion{} [2]:
reference.tex(,3406) @expansion{}    0,1,1,1,0
reference.tex(,3407) @expansion{} [3]:
reference.tex(,3408) @expansion{}    1,0,1,0,1
reference.tex(,3409) @expansion{} [4]:
reference.tex(,3410) @expansion{}    0,0,1,1,1
reference.tex(,3411) @expansion{} [5]:
reference.tex(,3412) @expansion{}    0,1,0,0,1
reference.tex(,3413)   eliminate(I,xuv);
reference.tex(,3414) @expansion{} _[1]=0
reference.tex(,3415) @c end example indepSet reference.doc:2425
reference.tex(,3416) @end smallexample
reference.tex(,3417) @end table
reference.tex(,3418) @c inserted refs from reference.doc:2437
reference.tex(,3431) @c end inserted refs from reference.doc:2437
reference.tex(,3432) @c ---------------------------------------
reference.tex(,3433) @node insert, interred, indepSet, Functions
reference.tex(,3434) @subsection insert
reference.tex(,3435) @cindex insert
reference.tex(,3436) 
reference.tex(,3437) @table @code
reference.tex(,3438) @item @strong{Syntax:}
reference.tex(,3439) @code{insert (} list_expression@code{,} expression @code{)}
reference.tex(,3440) @*@code{insert (} list_expression@code{,} expression@code{,} int_expression @code{)}
reference.tex(,3441) @item @strong{Type:}
reference.tex(,3442) list
reference.tex(,3443) @item @strong{Purpose:}
reference.tex(,3444) inserts a new element (expression) into a list at the beginning, or (if
reference.tex(,3445) called with 3 arguments) after the given position (the input is not changed).
reference.tex(,3446) @item @strong{Example:}
reference.tex(,3447) @smallexample
reference.tex(,3448) @c reused example insert reference.doc:2458 
reference.tex(,3449)   list L=1,2;
reference.tex(,3450)   insert(L,4,2);
reference.tex(,3451) @expansion{} [1]:
reference.tex(,3452) @expansion{}    1
reference.tex(,3453) @expansion{} [2]:
reference.tex(,3454) @expansion{}    2
reference.tex(,3455) @expansion{} [3]:
reference.tex(,3456) @expansion{}    4
reference.tex(,3457)   insert(L,4);
reference.tex(,3458) @expansion{} [1]:
reference.tex(,3459) @expansion{}    4
reference.tex(,3460) @expansion{} [2]:
reference.tex(,3461) @expansion{}    1
reference.tex(,3462) @expansion{} [3]:
reference.tex(,3463) @expansion{}    2
reference.tex(,3464) @c end example insert reference.doc:2458
reference.tex(,3465) @end smallexample
reference.tex(,3466) @end table
reference.tex(,3467) @c inserted refs from reference.doc:2465
reference.tex(,3480) @c end inserted refs from reference.doc:2465
reference.tex(,3481) @c ---------------------------------------
reference.tex(,3482) @node interred, intersect, insert, Functions
reference.tex(,3483) @subsection interred
reference.tex(,3484) @cindex interred
reference.tex(,3485) @table @code
reference.tex(,3486) @item @strong{Syntax:}
reference.tex(,3487) @code{interred (} ideal_expression @code{)}
reference.tex(,3488) @*@code{interred (} module_expression @code{)}
reference.tex(,3489) @item @strong{Type:}
reference.tex(,3490) the same as the input type
reference.tex(,3491) @item @strong{Purpose:}
reference.tex(,3492) interreduces a set of polynomials/vectors.
reference.tex(,3493) @*
reference.tex(,3500) @*
reference.tex(,3509) @itemize @bullet
reference.tex(,3510) @item
reference.tex(,3517) @item
reference.tex(,3524) @item
reference.tex(,3525) in the case of a global ordering (polynomial ring):
reference.tex(,3526) @*
reference.tex(,3533)  does not divide m for all monomials m of
reference.tex(,3540) @item
reference.tex(,3541) in the case of a local or mixed ordering (localization of polynomial ring):
reference.tex(,3542) @* if
reference.tex(,3549) then
reference.tex(,3556) @end itemize
reference.tex(,3566) @item @strong{Example:}
reference.tex(,3567) @smallexample
reference.tex(,3568) @c reused example interred reference.doc:2557 
reference.tex(,3569)   ring r=0,(x,y,z),dp;
reference.tex(,3570)   ideal i=x2+z,z,2z;
reference.tex(,3571)   interred(i);
reference.tex(,3572) @expansion{} _[1]=z
reference.tex(,3573) @expansion{} _[2]=x2
reference.tex(,3574)   ring R=0,(x,y,z),ds;
reference.tex(,3575)   ideal i=zx+y3,z+y3,z+xy;
reference.tex(,3576)   interred(i);
reference.tex(,3577) @expansion{} _[1]=z+xy
reference.tex(,3578) @expansion{} _[2]=xy-y3
reference.tex(,3579) @expansion{} _[3]=x2y-y3
reference.tex(,3580) @c end example interred reference.doc:2557
reference.tex(,3581) @end smallexample
reference.tex(,3582) @end table
reference.tex(,3583) @c inserted refs from reference.doc:2567
reference.tex(,3598) @c end inserted refs from reference.doc:2567
reference.tex(,3599) @c ---------------------------------------
reference.tex(,3600) @node intersect, jacob, interred, Functions
reference.tex(,3601) @subsection intersect
reference.tex(,3602) @cindex intersect
reference.tex(,3603) @table @code
reference.tex(,3604) @item @strong{Syntax:}
reference.tex(,3605) @code{intersect (} expression_list of ideal_expression @code{)}
reference.tex(,3606) @*@code{intersect (} expression_list of module_expression @code{)}
reference.tex(,3607) @item @strong{Type:}
reference.tex(,3608) ideal, resp.@: module
reference.tex(,3609) @item @strong{Purpose:}
reference.tex(,3610) computes the intersection of ideals, resp.@: modules.
reference.tex(,3611) @item @strong{Note:}
reference.tex(,3612) If the option @code{returnSB} is enabled then the result is a standard basis.
reference.tex(,3613) @item @strong{Example:}
reference.tex(,3614) @smallexample
reference.tex(,3615) @c reused example intersect reference.doc:2589 
reference.tex(,3616)   ring R=0,(x,y),dp;
reference.tex(,3617)   ideal i=x;
reference.tex(,3618)   ideal j=y;
reference.tex(,3619)   intersect(i,j);
reference.tex(,3620) @expansion{} _[1]=xy
reference.tex(,3621)   ring r=181,(x,y,z),(c,ls);
reference.tex(,3622)   ideal id1=maxideal(3);
reference.tex(,3623)   ideal id2=x2+xyz,y2-z3y,z3+y5xz;
reference.tex(,3624)   ideal id3=intersect(id1,id2,ideal(x,y));
reference.tex(,3625)   id3;
reference.tex(,3626) @expansion{} id3[1]=yz3+xy6z
reference.tex(,3627) @expansion{} id3[2]=yz4-y2z
reference.tex(,3628) @expansion{} id3[3]=y2z3-y3
reference.tex(,3629) @expansion{} id3[4]=xz3+x2y5z
reference.tex(,3630) @expansion{} id3[5]=xyz2+x2z
reference.tex(,3631) @expansion{} id3[6]=xyz3-xy2
reference.tex(,3632) @expansion{} id3[7]=xy2z+x2y
reference.tex(,3633) @expansion{} id3[8]=x2yz+x3
reference.tex(,3634) @c end example intersect reference.doc:2589
reference.tex(,3635) @end smallexample
reference.tex(,3636) @end table
reference.tex(,3637) @c inserted refs from reference.doc:2602
reference.tex(,3652) @c end inserted refs from reference.doc:2602
reference.tex(,3653) @c ---------------------------------------
reference.tex(,3654) @node jacob, jet, intersect, Functions
reference.tex(,3655) @subsection jacob
reference.tex(,3656) @cindex jacob
reference.tex(,3657) @table @code
reference.tex(,3658) @item @strong{Syntax:}
reference.tex(,3659) @code{jacob (} poly_expression @code{)}
reference.tex(,3660) @*@code{jacob (} ideal_expression @code{)}
reference.tex(,3661) @item @strong{Type:}
reference.tex(,3662) ideal, if the input is a polynomial
reference.tex(,3663) @* matrix, if the input is an ideal
reference.tex(,3664) @item @strong{Purpose:}
reference.tex(,3665) computes the Jacobi ideal, resp.@: Jacobi matrix, generated by all
reference.tex(,3666) partial derivatives of the input.
reference.tex(,3667) @item @strong{Example:}
reference.tex(,3668) @smallexample
reference.tex(,3669) @c reused example jacob reference.doc:2624 
reference.tex(,3670)   ring R;
reference.tex(,3671)   poly f=x2+y3+z5;
reference.tex(,3672)   jacob(f);
reference.tex(,3673) @expansion{} _[1]=2x
reference.tex(,3674) @expansion{} _[2]=3y2
reference.tex(,3675) @expansion{} _[3]=5z4
reference.tex(,3676)   ideal i=jacob(f);
reference.tex(,3677)   print(jacob(i));
reference.tex(,3678) @expansion{} 2,0, 0,  
reference.tex(,3679) @expansion{} 0,6y,0,  
reference.tex(,3680) @expansion{} 0,0, 20z3
reference.tex(,3681) @c end example jacob reference.doc:2624
reference.tex(,3682) @end smallexample
reference.tex(,3683) @end table
reference.tex(,3684) @c inserted refs from reference.doc:2633
reference.tex(,3701) @c end inserted refs from reference.doc:2633
reference.tex(,3702) @c ---------------------------------------
reference.tex(,3703) @node jet, kbase, jacob, Functions
reference.tex(,3704) @subsection jet
reference.tex(,3705) @cindex jet
reference.tex(,3706) @table @code
reference.tex(,3707) @item @strong{Syntax:}
reference.tex(,3708) @code{jet (} poly_expression@code{,} int_expression @code{)}
reference.tex(,3709) @*@code{jet (} vector_expression@code{,} int_expression @code{)}
reference.tex(,3710) @*@code{jet (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,3711) @*@code{jet (} module_expression@code{,} int_expression @code{)}
reference.tex(,3712) @*@code{jet (} poly_expression@code{,} int_expression@code{,} intvec_expression @code{)}
reference.tex(,3713) @*@code{jet (} vector_expression@code{,} int_expression@code{,} intvec_expression @code{)}
reference.tex(,3714) @*@code{jet (} ideal_expression@code{,} int_expression@code{,} intvec_expression @code{)}
reference.tex(,3715) @*@code{jet (} module_expression@code{,} int_expression@code{,} intvec_expression @code{)}
reference.tex(,3716) @*@code{jet (} poly_expression@code{,} int_expression@code{,} poly_expression @code{)}
reference.tex(,3717) @*@code{jet (} vector_expression@code{,} int_expression@code{,} poly_expression @code{)}
reference.tex(,3718) @*@code{jet (} ideal_expression@code{,} int_expression@code{,} matrix_expression @code{)}
reference.tex(,3719) @*@code{jet (} module_expression@code{,} int_expression@code{,} matrix_expression @code{)}
reference.tex(,3720) @item @strong{Type:}
reference.tex(,3721) the same as the type of the first argument
reference.tex(,3722) @item @strong{Purpose:}
reference.tex(,3723) deletes from the first argument all terms of degree bigger than the second argument.
reference.tex(,3724) @*If a third argument @code{w} of type intvec is given, the degree is replaced by the weighted degree defined by @code{w}.
reference.tex(,3725) @*If a third argument @code{u} of type poly or matrix is given, the first argument @code{p} is replaced by @code{p/u}.
reference.tex(,3726) @item @strong{Example:}
reference.tex(,3727) @smallexample
reference.tex(,3728) @c reused example jet reference.doc:2666 
reference.tex(,3729)   ring r=32003,(x,y,z),(c,dp);
reference.tex(,3730)   jet(1+x+x2+x3+x4,3);
reference.tex(,3731) @expansion{} x3+x2+x+1
reference.tex(,3732)   poly f=1+x+x2+xz+y2+x3+y3+x2y2+z4;
reference.tex(,3733)   jet(f,3);
reference.tex(,3734) @expansion{} x3+y3+x2+y2+xz+x+1
reference.tex(,3735)   intvec iv=2,1,1;
reference.tex(,3736)   jet(f,3,iv);
reference.tex(,3737) @expansion{} y3+y2+xz+x+1
reference.tex(,3738)   // the part of f with (total) degree >3:
reference.tex(,3739)   f-jet(f,3);
reference.tex(,3740) @expansion{} x2y2+z4
reference.tex(,3741)   // the homogeneous part of f of degree 2:
reference.tex(,3742)   jet(f,2)-jet(f,1);
reference.tex(,3743) @expansion{} x2+y2+xz
reference.tex(,3744)   // the part of maximal degree:
reference.tex(,3745)   jet(f,deg(f))-jet(f,deg(f)-1);
reference.tex(,3746) @expansion{} x2y2+z4
reference.tex(,3747)   // the absolute term of f:
reference.tex(,3748)   jet(f,0);
reference.tex(,3749) @expansion{} 1
reference.tex(,3750)   // now for other types:
reference.tex(,3751)   ideal i=f,x,f*f;
reference.tex(,3752)   jet(i,2);
reference.tex(,3753) @expansion{} _[1]=x2+y2+xz+x+1
reference.tex(,3754) @expansion{} _[2]=x
reference.tex(,3755) @expansion{} _[3]=3x2+2y2+2xz+2x+1
reference.tex(,3756)   vector v=[f,1,x];
reference.tex(,3757)   jet(v,1);
reference.tex(,3758) @expansion{} [x+1,1,x]
reference.tex(,3759)   jet(v,0);
reference.tex(,3760) @expansion{} [1,1]
reference.tex(,3761)   v=[f,1,0];
reference.tex(,3762)   module m=v,v,[1,x2,z3,0,1];
reference.tex(,3763)   jet(m,2);
reference.tex(,3764) @expansion{} _[1]=[x2+y2+xz+x+1,1]
reference.tex(,3765) @expansion{} _[2]=[x2+y2+xz+x+1,1]
reference.tex(,3766) @expansion{} _[3]=[1,x2,0,0,1]
reference.tex(,3767) @c end example jet reference.doc:2666
reference.tex(,3768) @end smallexample
reference.tex(,3769) @end table
reference.tex(,3770) @c inserted refs from reference.doc:2693
reference.tex(,3793) @c end inserted refs from reference.doc:2693
reference.tex(,3794) @c ---------------------------------------
reference.tex(,3795) @node kbase, kill, jet, Functions
reference.tex(,3796) @subsection kbase
reference.tex(,3797) @cindex kbase
reference.tex(,3798) @table @code
reference.tex(,3799) @item @strong{Syntax:}
reference.tex(,3800) @code{kbase (} ideal_expression @code{)}
reference.tex(,3801) @*@code{kbase (} module_expression @code{)}
reference.tex(,3802) @*@code{kbase (} ideal_expression@code{,} int_expression@code{)}
reference.tex(,3803) @*@code{kbase (} module_expression@code{,} int_expression@code{)}
reference.tex(,3804) @item @strong{Type:}
reference.tex(,3805) the same as the input type of the first argument
reference.tex(,3806) @item @strong{Purpose:}
reference.tex(,3807) with one argument:
reference.tex(,3808) computes a vector space basis (consisting of monomials)
reference.tex(,3809) of the quotient ring by the ideal,
reference.tex(,3810) resp.@: of a free module by the module, in case it is finite dimensional
reference.tex(,3811) and if the input is a standard basis with respect to the ring ordering.
reference.tex(,3812) If the input is not a standard basis, the leading terms of the input are
reference.tex(,3813) used and the result may have no meaning.
reference.tex(,3814) @*With two arguments: computes the part of a vector space basis of the
reference.tex(,3815) respective quotient with degree of the monomials equal to the
reference.tex(,3816) second argument. Here, the quotient does not need to be finite dimensional.
reference.tex(,3817) @item @strong{Example:}
reference.tex(,3818) @smallexample
reference.tex(,3819) @c reused example kbase reference.doc:2728 
reference.tex(,3820)   ring r=32003,(x,y,z),ds;
reference.tex(,3821)   ideal i=x2,y2,z;
reference.tex(,3822)   kbase(std(i));
reference.tex(,3823) @expansion{} _[1]=xy
reference.tex(,3824) @expansion{} _[2]=y
reference.tex(,3825) @expansion{} _[3]=x
reference.tex(,3826) @expansion{} _[4]=1
reference.tex(,3827)   i=x2,y3,xyz;  // quotient not finite dimensional
reference.tex(,3828)   kbase(std(i),2);
reference.tex(,3829) @expansion{} _[1]=z2
reference.tex(,3830) @expansion{} _[2]=yz
reference.tex(,3831) @expansion{} _[3]=xz
reference.tex(,3832) @expansion{} _[4]=y2
reference.tex(,3833) @expansion{} _[5]=xy
reference.tex(,3834) @c end example kbase reference.doc:2728
reference.tex(,3835) @end smallexample
reference.tex(,3836) @end table
reference.tex(,3837) @c inserted refs from reference.doc:2737
reference.tex(,3852) @c end inserted refs from reference.doc:2737
reference.tex(,3853) @c ---------------------------------------
reference.tex(,3854) @node kill, killattrib, kbase, Functions
reference.tex(,3855) @subsection kill
reference.tex(,3856) @cindex kill
reference.tex(,3857) @table @code
reference.tex(,3858) @item @strong{Syntax:}
reference.tex(,3859) @code{kill (} name @code{)}
reference.tex(,3860) @*@code{kill (} list_of_names @code{)}
reference.tex(,3861) @item @strong{Type:}
reference.tex(,3862) none
reference.tex(,3863) @item @strong{Purpose:}
reference.tex(,3864) deletes objects.
reference.tex(,3865) @item @strong{Example:}
reference.tex(,3866) @smallexample
reference.tex(,3867) @c reused example kill reference.doc:2757 
reference.tex(,3868)   int i=3;
reference.tex(,3869)   ring r=0,x,dp;
reference.tex(,3870)   poly p;
reference.tex(,3871)   listvar();
reference.tex(,3872) @expansion{} // r                    [0]  *ring
reference.tex(,3873) @expansion{} //      p                    [0]  poly
reference.tex(,3874) @expansion{} // i                    [0]  int 3
reference.tex(,3875) @expansion{} // LIB                  [0]  string standard.lib
reference.tex(,3876)   kill(i,r);
reference.tex(,3877)   // the variable `i` does not exist any more
reference.tex(,3878)   i;
reference.tex(,3879) @expansion{}    ? `i` is undefined
reference.tex(,3880) @expansion{}    ? error occurred in line 7: `  i;`
reference.tex(,3881)   listvar();
reference.tex(,3882) @expansion{} // LIB                  [0]  string standard.lib
reference.tex(,3883) @c end example kill reference.doc:2757
reference.tex(,3884) @end smallexample
reference.tex(,3885) @end table
reference.tex(,3886) @c inserted refs from reference.doc:2769
reference.tex(,3901) @c end inserted refs from reference.doc:2769
reference.tex(,3902) @c ---------------------------------------
reference.tex(,3903) @node killattrib, koszul, kill, Functions
reference.tex(,3904) @subsection killattrib
reference.tex(,3905) @cindex killattrib
reference.tex(,3906) @table @code
reference.tex(,3907) @item @strong{Syntax:}
reference.tex(,3908) @code{killattrib (} name@code{,} string_expression @code{)}
reference.tex(,3909) @item @strong{Type:}
reference.tex(,3910) none
reference.tex(,3911) @item @strong{Purpose:}
reference.tex(,3912) deletes the attribute given as the second argument.
reference.tex(,3913) @item @strong{Example:}
reference.tex(,3914) @smallexample
reference.tex(,3915) @c reused example killattrib reference.doc:2788 
reference.tex(,3916)   ring r=32003,(x,y),lp;
reference.tex(,3917)   ideal i=maxideal(1);
reference.tex(,3918)   attrib(i,"isSB",1);
reference.tex(,3919)   attrib(i);
reference.tex(,3920) @expansion{} attr:isSB, type int
reference.tex(,3921)   killattrib(i,"isSB");
reference.tex(,3922)   attrib(i);
reference.tex(,3923) @expansion{} no attributes
reference.tex(,3924) @c end example killattrib reference.doc:2788
reference.tex(,3925) @end smallexample
reference.tex(,3926) @end table
reference.tex(,3927) @c inserted refs from reference.doc:2798
reference.tex(,3940) @c end inserted refs from reference.doc:2798
reference.tex(,3941) @c ---------------------------------------
reference.tex(,3942) @node koszul, laguerre, killattrib, Functions
reference.tex(,3943) @subsection koszul
reference.tex(,3944) @cindex koszul
reference.tex(,3945) @table @code
reference.tex(,3946) @item @strong{Syntax:}
reference.tex(,3947) @code{koszul (} int_expression@code{,} int_expression @code{)}
reference.tex(,3948) @*@code{koszul (} int_expression@code{,} ideal_expression @code{)}
reference.tex(,3949) @*@code{koszul (} int_expression@code{,} int_expression@code{,} ideal_expression @code{)}
reference.tex(,3950) @item @strong{Type:}
reference.tex(,3951) matrix
reference.tex(,3952) @item @strong{Purpose:}
reference.tex(,3953) @code{koszul(d,n)} computes a matrix of the Koszul relations of degree d of
reference.tex(,3954) the first n ring variables.
reference.tex(,3955) 
reference.tex(,3956) @code{koszul(d,id)} computes a matrix of the Koszul relations of degree d of
reference.tex(,3957) the generators of the ideal @code{id}.
reference.tex(,3958) 
reference.tex(,3959) @code{koszul(d,n,id)} computes a matrix of the Koszul relations of degree d of
reference.tex(,3960) the first n generators of the ideal @code{id}.
reference.tex(,3961) 
reference.tex(,3962) @item @strong{Note:}
reference.tex(,3963) @code{koszul(1,id),koszul(2,id),...} form a complex, that is, the product
reference.tex(,3964) of the matrices @code{koszul(i,id)} and @code{koszul(i+1,id)} equals zero.
reference.tex(,3965) @item @strong{Example:}
reference.tex(,3966) @smallexample
reference.tex(,3967) @c reused example koszul reference.doc:2829 
reference.tex(,3968)   ring r=32003,(x,y,z),dp;
reference.tex(,3969)   print(koszul(2,3));
reference.tex(,3970) @expansion{} -y,-z,0, 
reference.tex(,3971) @expansion{} x, 0, -z,
reference.tex(,3972) @expansion{} 0, x, y  
reference.tex(,3973)   ideal I=xz2+yz2+z3,xyz+y2z+yz2,xy2+y3+y2z;
reference.tex(,3974)   print(koszul(1,I));
reference.tex(,3975) @expansion{} xz2+yz2+z3,xyz+y2z+yz2,xy2+y3+y2z
reference.tex(,3976)   print(koszul(2,I));
reference.tex(,3977) @expansion{} -xyz-y2z-yz2,-xy2-y3-y2z,0,          
reference.tex(,3978) @expansion{} xz2+yz2+z3,  0,          -xy2-y3-y2z,
reference.tex(,3979) @expansion{} 0,           xz2+yz2+z3, xyz+y2z+yz2 
reference.tex(,3980)   print(koszul(2,I)*koszul(3,I));
reference.tex(,3981) @expansion{} 0,
reference.tex(,3982) @expansion{} 0,
reference.tex(,3983) @expansion{} 0 
reference.tex(,3984) @c end example koszul reference.doc:2829
reference.tex(,3985) @end smallexample
reference.tex(,3986) @end table
reference.tex(,3987) @c inserted refs from reference.doc:2839
reference.tex(,4000) @c end inserted refs from reference.doc:2839
reference.tex(,4001) @c ---------------------------------------
reference.tex(,4002) @node laguerre, lead, koszul, Functions
reference.tex(,4003) @subsection laguerre
reference.tex(,4004) @cindex laguerre
reference.tex(,4005) @table @code
reference.tex(,4006) @item @strong{Syntax:}
reference.tex(,4007) @code{laguerre (} poly_expression@code{,} int_expression@code{,} int_expression @code{)}
reference.tex(,4008) @item @strong{Type:}
reference.tex(,4009) list
reference.tex(,4010) @item @strong{Purpose:}
reference.tex(,4011) computes all complex roots of a univariate polynomial using Laguerre's
reference.tex(,4012) algorithm. The second argument defines the precision of the fractional part
reference.tex(,4013) if the ground field is the field of rational numbers, otherwise it will be
reference.tex(,4014) ignored. The third argument (can be 0, 1 or 2) gives the number of extra runs
reference.tex(,4015) for Laguerre's algorithm (with corrupted roots), leading to better results.
reference.tex(,4016) @item @strong{Note:}
reference.tex(,4017) If the ground field is the field of complex numbers, the elements of the
reference.tex(,4018) list are of type number, otherwise of type string.
reference.tex(,4019) @item @strong{Example:}
reference.tex(,4020) @smallexample
reference.tex(,4021) @c reused example laguerre reference.doc:2864 
reference.tex(,4022) ring rs1=0,(x,y),lp;
reference.tex(,4023) poly f=15x5+x3+x2-10;
reference.tex(,4024) laguerre(f,10,2);
reference.tex(,4025) @expansion{} [1]:
reference.tex(,4026) @expansion{}    (0.2930464644-I*0.9003002396)
reference.tex(,4027) @expansion{} [2]:
reference.tex(,4028) @expansion{}    (0.2930464644+I*0.9003002396)
reference.tex(,4029) @expansion{} [3]:
reference.tex(,4030) @expansion{}    (-0.7392783383-I*0.5355190078)
reference.tex(,4031) @expansion{} [4]:
reference.tex(,4032) @expansion{}    (-0.7392783383+I*0.5355190078)
reference.tex(,4033) @expansion{} [5]:
reference.tex(,4034) @expansion{}    0.8924637479
reference.tex(,4035) @c end example laguerre reference.doc:2864
reference.tex(,4036) @end smallexample
reference.tex(,4037) @end table
reference.tex(,4038) @c @c ref
reference.tex(,4039) @c @c ref
reference.tex(,4040) @c -------------------------------------------------
reference.tex(,4041) @node lead, leadcoef, laguerre, Functions
reference.tex(,4042) @subsection lead
reference.tex(,4043) @cindex lead
reference.tex(,4044) @table @code
reference.tex(,4045) @item @strong{Syntax:}
reference.tex(,4046) @code{lead (} poly_expression @code{)}
reference.tex(,4047) @*@code{lead (} vector_expression @code{)}
reference.tex(,4048) @*@code{lead (} ideal_expression @code{)}
reference.tex(,4049) @*@code{lead (} module_expression @code{)}
reference.tex(,4050) @item @strong{Type:}
reference.tex(,4051) the same as the input type
reference.tex(,4052) @item @strong{Purpose:}
reference.tex(,4053) returns the leading (or initial) term(s) of a polynomial, a vector,
reference.tex(,4054) resp.@: of the generators of an ideal or module with respect
reference.tex(,4055) to the monomial ordering.
reference.tex(,4056) @cindex IN
reference.tex(,4057) @item @strong{Note:}
reference.tex(,4058) @code{IN} may be used instead of @code{lead}.
reference.tex(,4059) @item @strong{Example:}
reference.tex(,4060) @smallexample
reference.tex(,4061) @c reused example lead reference.doc:2894 
reference.tex(,4062)   ring r=32003,(x,y,z),(c,ds);
reference.tex(,4063)   poly f=2x2+3y+4z3;
reference.tex(,4064)   vector v=[2x10,f];
reference.tex(,4065)   ideal i=f,z;
reference.tex(,4066)   module m=v,[0,0,2+x];
reference.tex(,4067)   lead(f);
reference.tex(,4068) @expansion{} 3y
reference.tex(,4069)   lead(v);
reference.tex(,4070) @expansion{} [2x10]
reference.tex(,4071)   lead(i);
reference.tex(,4072) @expansion{} _[1]=3y
reference.tex(,4073) @expansion{} _[2]=z
reference.tex(,4074)   lead(m);
reference.tex(,4075) @expansion{} _[1]=[2x10]
reference.tex(,4076) @expansion{} _[2]=[0,0,2]
reference.tex(,4077)   lead(0);
reference.tex(,4078) @expansion{} 0
reference.tex(,4079) @c end example lead reference.doc:2894
reference.tex(,4080) @end smallexample
reference.tex(,4081) @end table
reference.tex(,4082) @c inserted refs from reference.doc:2908
reference.tex(,4105) @c end inserted refs from reference.doc:2908
reference.tex(,4106) @c -------------------------------------------------
reference.tex(,4107) @node leadcoef, leadexp, lead, Functions
reference.tex(,4108) @subsection leadcoef
reference.tex(,4109) @cindex leadcoef
reference.tex(,4110) @table @code
reference.tex(,4111) @item @strong{Syntax:}
reference.tex(,4112) @code{leadcoef (} poly_expression @code{)}
reference.tex(,4113) @*@code{leadcoef (} vector_expression @code{)}
reference.tex(,4114) @item @strong{Type:}
reference.tex(,4115) number
reference.tex(,4116) @item @strong{Purpose:}
reference.tex(,4117) returns the leading (or initial) coefficient of a polynomial or a vector
reference.tex(,4118) with respect to the monomial ordering.
reference.tex(,4119) @item @strong{Example:}
reference.tex(,4120) @smallexample
reference.tex(,4121) @c reused example leadcoef reference.doc:2933 
reference.tex(,4122)   ring r=32003,(x,y,z),(c,ds);
reference.tex(,4123)   poly f=x2+y+z3;
reference.tex(,4124)   vector v=[2*x^10,f];
reference.tex(,4125)   leadcoef(f);
reference.tex(,4126) @expansion{} 1
reference.tex(,4127)   leadcoef(v);
reference.tex(,4128) @expansion{} 2
reference.tex(,4129)   leadcoef(0);
reference.tex(,4130) @expansion{} 0
reference.tex(,4131) @c end example leadcoef reference.doc:2933
reference.tex(,4132) @end smallexample
reference.tex(,4133) @end table
reference.tex(,4134) @c inserted refs from reference.doc:2943
reference.tex(,4155) @c end inserted refs from reference.doc:2943
reference.tex(,4156) @c -------------------------------------------------
reference.tex(,4157) @node leadexp, leadmonom, leadcoef, Functions
reference.tex(,4158) @subsection leadexp
reference.tex(,4159) @cindex leadexp
reference.tex(,4160) @table @code
reference.tex(,4161) @item @strong{Syntax:}
reference.tex(,4162) @code{leadexp (} poly_expression @code{)}
reference.tex(,4163) @*@code{leadexp (} vector_expression @code{)}
reference.tex(,4164) @item @strong{Type:}
reference.tex(,4165) intvec
reference.tex(,4166) @item @strong{Purpose:}
reference.tex(,4167) returns the exponent vector of the leading monomial of a polynomial or a vector.
reference.tex(,4168) In the case of a vector the last component is the index in the vector.
reference.tex(,4169) @item @strong{Example:}
reference.tex(,4170) @smallexample
reference.tex(,4171) @c reused example leadexp reference.doc:2967 
reference.tex(,4172)   ring r=32003,(x,y,z),(c,ds);
reference.tex(,4173)   poly f=x2+y+z3;
reference.tex(,4174)   vector v=[2*x^10,f];
reference.tex(,4175)   leadexp(f);
reference.tex(,4176) @expansion{} 0,1,0
reference.tex(,4177)   leadexp(v);
reference.tex(,4178) @expansion{} 10,0,0,1
reference.tex(,4179)   leadexp(0);
reference.tex(,4180) @expansion{} 0,0,0
reference.tex(,4181) @c end example leadexp reference.doc:2967
reference.tex(,4182) @end smallexample
reference.tex(,4183) @end table
reference.tex(,4184) @c inserted refs from reference.doc:2977
reference.tex(,4205) @c end inserted refs from reference.doc:2977
reference.tex(,4206) @c -------------------------------------------------
reference.tex(,4207) @node leadmonom, LIB, leadexp, Functions
reference.tex(,4208) @subsection leadmonom
reference.tex(,4209) @cindex leadmonom
reference.tex(,4210) @table @code
reference.tex(,4211) @item @strong{Syntax:}
reference.tex(,4212) @code{leadmonom (} poly_expression @code{)}
reference.tex(,4213) @*@code{leadmonom (} vector_expression @code{)}
reference.tex(,4214) @item @strong{Type:}
reference.tex(,4215) the same as the input type
reference.tex(,4216) @item @strong{Purpose:}
reference.tex(,4217) returns the leading monomial of a polynomial or a vector as a polynomial
reference.tex(,4218) or vector whose coefficient is one.
reference.tex(,4219) @item @strong{Example:}
reference.tex(,4220) @smallexample
reference.tex(,4221) @c reused example leadmonom reference.doc:3001 
reference.tex(,4222)   ring r=32003,(x,y,z),(c,ds);
reference.tex(,4223)   poly f=2x2+3y+4z3;
reference.tex(,4224)   vector v=[2x10,f];
reference.tex(,4225)   leadmonom(f);
reference.tex(,4226) @expansion{} y
reference.tex(,4227)   leadmonom(v);
reference.tex(,4228) @expansion{} [x10]
reference.tex(,4229)   leadmonom(0);
reference.tex(,4230) @expansion{} 0
reference.tex(,4231) @c end example leadmonom reference.doc:3001
reference.tex(,4232) @end smallexample
reference.tex(,4233) @end table
reference.tex(,4234) 
reference.tex(,4235) @c inserted refs from reference.doc:3012
reference.tex(,4256) @c end inserted refs from reference.doc:3012
reference.tex(,4257) @c ---------------------------------------
reference.tex(,4258) @node LIB, lift, leadmonom, Functions
reference.tex(,4259) @subsection LIB
reference.tex(,4260) @cindex LIB
reference.tex(,4261) @table @code
reference.tex(,4262) @item @strong{Syntax:}
reference.tex(,4263) @code{LIB} string_expression@code{;}
reference.tex(,4264) @item @strong{Type:}
reference.tex(,4265) none
reference.tex(,4272) @item @strong{Purpose:}
reference.tex(,4273) reads a library of procedures from a file. If the given filename does
reference.tex(,4274) not start with @kbd{.} or @kbd{/} and cannot be located in the current
reference.tex(,4275) directory, each directory contained in the library
reference.tex(,4276) @code{SearchPath} is searched for file of this name.
reference.tex(,4277) @xref{Loading of a library}, for more info on @code{SearchPath}.
reference.tex(,4279) 
reference.tex(,4280) @item @strong{Note on standard.lib:}
reference.tex(,4281) Unless  @sc{Singular} is started with the @code{--no-stdlib} option, the
reference.tex(,4282) library @code{standard.lib} is automatically loaded at start-up time.
reference.tex(,4283) 
reference.tex(,4284) @item @strong{Syntax:}
reference.tex(,4285) @code{LIB;}
reference.tex(,4286) @item @strong{Type:}
reference.tex(,4287) string
reference.tex(,4288) @item @strong{Purpose:}
reference.tex(,4289) shows all loaded libraries written in Singular.
reference.tex(,4290) 
reference.tex(,4291) 
reference.tex(,4292) @item @strong{Example:}
reference.tex(,4293) @smallexample
reference.tex(,4294) @c reused example LIB reference.doc:3058 
reference.tex(,4295)   option(loadLib); // show loading of libraries
reference.tex(,4296)   LIB;             // standard.lib is loaded
reference.tex(,4297) @expansion{} standard.lib
reference.tex(,4298) 
reference.tex(,4299)                    // the names of the procedures of inout.lib
reference.tex(,4300)   LIB "inout.lib"; // are now known to Singular
reference.tex(,4301) @expansion{} // ** loaded inout.lib (1.21.2.5,2002/06/12)
reference.tex(,4302)   LIB;
reference.tex(,4303) @expansion{} standard.lib,inout.lib
reference.tex(,4304) @c end example LIB reference.doc:3058
reference.tex(,4305) @end smallexample
reference.tex(,4306) @end table
reference.tex(,4340) @c inserted refs from reference.doc:3084
reference.tex(,4365) @c end inserted refs from reference.doc:3084
reference.tex(,4367) @c -------------------------------------------------
reference.tex(,4368) @node lift, liftstd, LIB, Functions
reference.tex(,4369) @subsection lift
reference.tex(,4370) @cindex lift
reference.tex(,4371) @table @code
reference.tex(,4372) @item @strong{Syntax:}
reference.tex(,4373) @code{lift (} ideal_expression@code{,} subideal_expression @code{)}
reference.tex(,4374) @*@code{lift (} module_expression@code{,} submodule_expression @code{)}
reference.tex(,4375) @*@code{lift (} ideal_expression@code{,} subideal_expression@code{,} matrix_name @code{)}
reference.tex(,4376) @*@code{lift (} module_expression@code{,} submodule_expression@code{,} matrix_name @code{)}
reference.tex(,4377) @item @strong{Type:}
reference.tex(,4378) matrix
reference.tex(,4379) @item @strong{Purpose:}
reference.tex(,4380) computes the transformation matrix which expresses the generators of a
reference.tex(,4381) submodule in terms of the generators of a module.  Uses different
reference.tex(,4382) algorithms for modules which are, resp.@: are not, represented by a
reference.tex(,4383) standard basis.
reference.tex(,4384) @* More precisely, if  @code{m} is the
reference.tex(,4385) module (or ideal), @code{sm} the submodule (or ideal),
reference.tex(,4386) and @code{T} the transformation matrix returned by
reference.tex(,4387) lift, then @code{matrix(sm)*U = matrix(m)*T}
reference.tex(,4388) and @code{module(sm*U) = module(matrix(m)*T)}
reference.tex(,4389) (resp.@: @code{ideal(sm*U) = ideal(matrix(m)*T)}),
reference.tex(,4390) where @code{U} is a diagonal matrix of units.
reference.tex(,4391) @*@code{U} is always the unity matrix if the basering is a polynomial ring
reference.tex(,4392) (not power series ring). @code{U} is stored in the optional third argument.
reference.tex(,4393) @item @strong{Note:}
reference.tex(,4394) Gives a warning if @code{sm} is not a submodule.
reference.tex(,4395) @item @strong{Example:}
reference.tex(,4396) @smallexample
reference.tex(,4397) @c reused example lift reference.doc:3126 
reference.tex(,4398)   ring r=32003,(x,y,z),(dp,C);
reference.tex(,4399)   ideal m=3x2+yz,7y6+2x2y+5xz;
reference.tex(,4400)   poly f=y7+x3+xyz+z2;
reference.tex(,4401)   ideal i=jacob(f);
reference.tex(,4402)   matrix T=lift(i,m);
reference.tex(,4403)   matrix(m)-matrix(i)*T;
reference.tex(,4404) @expansion{} _[1,1]=0
reference.tex(,4405) @expansion{} _[1,2]=0
reference.tex(,4406) @c end example lift reference.doc:3126
reference.tex(,4407) @end smallexample
reference.tex(,4408) @end table
reference.tex(,4409) @c inserted refs from reference.doc:3136
reference.tex(,4424) @c end inserted refs from reference.doc:3136
reference.tex(,4425) @c -----------------------------------------
reference.tex(,4426) @node liftstd, listvar, lift, Functions
reference.tex(,4427) @subsection liftstd
reference.tex(,4428) @cindex liftstd
reference.tex(,4429) @table @code
reference.tex(,4430) @item @strong{Syntax:}
reference.tex(,4431) @code{liftstd (} ideal_expression@code{,} matrix_name @code{)}
reference.tex(,4432) @*@code{liftstd (} module_expression@code{,} matrix_name @code{)}
reference.tex(,4433) @item @strong{Type:}
reference.tex(,4434) ideal or module
reference.tex(,4435) @item @strong{Purpose:}
reference.tex(,4436) returns a standard basis of an ideal or module and the transformation
reference.tex(,4437) matrix from the given ideal, resp.@: module, to the standard basis.
reference.tex(,4438) @*That is, if @code{m} is the ideal or module, @code{sm} the standard
reference.tex(,4439) basis returned by @code{liftstd}, and @code{T} the transformation matrix
reference.tex(,4440) then @code{matrix(sm)=matrix(m)*T} and @code{sm=ideal(matrix(m)*T)},
reference.tex(,4441) resp.@: @code{sm=module(matrix(m)*T)}.
reference.tex(,4442) @item @strong{Example:}
reference.tex(,4443) @smallexample
reference.tex(,4444) @c reused example liftstd reference.doc:3161 
reference.tex(,4445)   ring R=0,(x,y,z),dp;
reference.tex(,4446)   poly f=x3+y7+z2+xyz;
reference.tex(,4447)   ideal i=jacob(f);
reference.tex(,4448)   matrix T;
reference.tex(,4449)   ideal sm=liftstd(i,T);
reference.tex(,4450)   sm;
reference.tex(,4451) @expansion{} sm[1]=xy+2z
reference.tex(,4452) @expansion{} sm[2]=3x2+yz
reference.tex(,4453) @expansion{} sm[3]=yz2+3048192z3
reference.tex(,4454) @expansion{} sm[4]=3024xz2-yz2
reference.tex(,4455) @expansion{} sm[5]=y2z-6xz
reference.tex(,4456) @expansion{} sm[6]=3097158156288z4+2016z3
reference.tex(,4457) @expansion{} sm[7]=7y6+xz
reference.tex(,4458)   print(T);
reference.tex(,4459) @expansion{} 0,1,T[1,3],   T[1,4],y,  T[1,6],0,
reference.tex(,4460) @expansion{} 0,0,-3x+3024z,3x,    0,  T[2,6],1,
reference.tex(,4461) @expansion{} 1,0,T[3,3],   T[3,4],-3x,T[3,6],0 
reference.tex(,4462)   matrix(sm)-matrix(i)*T;
reference.tex(,4463) @expansion{} _[1,1]=0
reference.tex(,4464) @expansion{} _[1,2]=0
reference.tex(,4465) @expansion{} _[1,3]=0
reference.tex(,4466) @expansion{} _[1,4]=0
reference.tex(,4467) @expansion{} _[1,5]=0
reference.tex(,4468) @expansion{} _[1,6]=0
reference.tex(,4469) @expansion{} _[1,7]=0
reference.tex(,4470) @c end example liftstd reference.doc:3161
reference.tex(,4471) @end smallexample
reference.tex(,4472) @end table
reference.tex(,4473) @c inserted refs from reference.doc:3173
reference.tex(,4492) @c end inserted refs from reference.doc:3173
reference.tex(,4493) @c ---------------------------------------
reference.tex(,4494) @node listvar, lres, liftstd, Functions
reference.tex(,4495) @subsection listvar
reference.tex(,4496) @cindex listvar
reference.tex(,4497) @table @code
reference.tex(,4498) @item @strong{Syntax:}
reference.tex(,4507) @code{listvar (} [package] @code{)}
reference.tex(,4508) @*@code{listvar (} [package@code{,}] type @code{)}
reference.tex(,4509) @*@code{listvar (} [package@code{,}] ring_name @code{)}
reference.tex(,4510) @*@code{listvar (} [package@code{,}] name @code{)}
reference.tex(,4511) @*@code{listvar (} [package@code{,}] @code{all )}
reference.tex(,4513) @item @strong{Type:}
reference.tex(,4514) none
reference.tex(,4515) @item @strong{Purpose:}
reference.tex(,4516) lists all (user-)defined names in the current namespace:
reference.tex(,4517) @itemize @bullet
reference.tex(,4518) @item @code{listvar()}: all currently visible names except procedures,
reference.tex(,4519) @item @code{listvar(}type@code{)}: all currently visible names of the given
reference.tex(,4520) type,
reference.tex(,4521) @item @code{listvar(}ring_name@code{)}: all names which belong to the given
reference.tex(,4522) ring,
reference.tex(,4523) @item @code{listvar(}name@code{)}: the object with the given name,
reference.tex(,4524) @item @code{listvar(all)}: all names except procedures.
reference.tex(,4525) @end itemize
reference.tex(,4526) The current basering is marked with a @code{*}.  The nesting level of
reference.tex(,4527) variables in procedures is shown in square brackets.
reference.tex(,4528) 
reference.tex(,4588) @item @strong{Example:}
reference.tex(,4589) @smallexample
reference.tex(,4590) @c reused example listvar_1 reference.doc:3243 
reference.tex(,4591)   proc t1 @{ @}
reference.tex(,4592)   proc t2 @{ @}
reference.tex(,4593)   ring s;
reference.tex(,4594)   poly ss;
reference.tex(,4595)   ring r;
reference.tex(,4596)   poly f=x+y+z;
reference.tex(,4597)   int i=7;
reference.tex(,4598)   ideal I=f,x,y;
reference.tex(,4599)   listvar(all);
reference.tex(,4600) @expansion{} // i                    [0]  int 7
reference.tex(,4601) @expansion{} // r                    [0]  *ring
reference.tex(,4602) @expansion{} //      I                    [0]  ideal, 3 generator(s)
reference.tex(,4603) @expansion{} //      f                    [0]  poly
reference.tex(,4604) @expansion{} // s                    [0]  ring
reference.tex(,4605) @expansion{} //      ss                   [0]  poly
reference.tex(,4606) @expansion{} // LIB                  [0]  string standard.lib
reference.tex(,4607)   listvar();
reference.tex(,4608) @expansion{} // i                    [0]  int 7
reference.tex(,4609) @expansion{} // r                    [0]  *ring
reference.tex(,4610) @expansion{} //      I                    [0]  ideal, 3 generator(s)
reference.tex(,4611) @expansion{} //      f                    [0]  poly
reference.tex(,4612) @expansion{} // s                    [0]  ring
reference.tex(,4613) @expansion{} // LIB                  [0]  string standard.lib
reference.tex(,4614)   listvar(r);
reference.tex(,4615) @expansion{} // r                    [0]  *ring
reference.tex(,4616) @expansion{} // I                    [0]  ideal, 3 generator(s)
reference.tex(,4617) @expansion{} // f                    [0]  poly
reference.tex(,4618)   listvar(t1);
reference.tex(,4619) @expansion{} // t1                   [0]  proc
reference.tex(,4620)   listvar(proc);
reference.tex(,4621) @expansion{} // t2                   [0]  proc
reference.tex(,4622) @expansion{} // t1                   [0]  proc
reference.tex(,4623) @expansion{} // fprintf              [0]  proc from standard.lib
reference.tex(,4624) @expansion{} // printf               [0]  proc from standard.lib
reference.tex(,4625) @expansion{} // sprintf              [0]  proc from standard.lib
reference.tex(,4626) @expansion{} // intersect1           [0]  proc from standard.lib (static)
reference.tex(,4627) @expansion{} // quotient4            [0]  proc from standard.lib
reference.tex(,4628) @expansion{} // quotient5            [0]  proc from standard.lib
reference.tex(,4629) @expansion{} // quotient3            [0]  proc from standard.lib
reference.tex(,4630) @expansion{} // quotient2            [0]  proc from standard.lib
reference.tex(,4631) @expansion{} // quotient1            [0]  proc from standard.lib
reference.tex(,4632) @expansion{} // quotient0            [0]  proc from standard.lib (static)
reference.tex(,4633) @expansion{} // quot1                [0]  proc from standard.lib (static)
reference.tex(,4634) @expansion{} // quot                 [0]  proc from standard.lib
reference.tex(,4635) @expansion{} // res                  [0]  proc from standard.lib
reference.tex(,4636) @expansion{} // groebner             [0]  proc from standard.lib
reference.tex(,4637) @expansion{} // stdhilb              [0]  proc from standard.lib
reference.tex(,4638) @expansion{} // stdfglm              [0]  proc from standard.lib
reference.tex(,4639) @c end example listvar_1 reference.doc:3243
reference.tex(,4640) @end smallexample
reference.tex(,4642) @end table
reference.tex(,4670) @c inserted refs from reference.doc:3274
reference.tex(,4689) @c end inserted refs from reference.doc:3274
reference.tex(,4691) @c ---------------------------------------
reference.tex(,4692) @node lres, maxideal, listvar, Functions
reference.tex(,4693) @subsection lres
reference.tex(,4694) @cindex lres
reference.tex(,4695) @cindex resolution, La Scala's method
reference.tex(,4696) 
reference.tex(,4697) @table @code
reference.tex(,4698) @item @strong{Syntax:}
reference.tex(,4699) @code{lres (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,4700) @item @strong{Type:}
reference.tex(,4701) resolution
reference.tex(,4702) @item @strong{Purpose:}
reference.tex(,4703) computes a free resolution of an ideal using La Scala's algorithm.
reference.tex(,4704) 
reference.tex(,4705) More precisely, let R be the basering and I be the given ideal.
reference.tex(,4706) Then @code{lres} computes a minimal free resolution of R/I
reference.tex(,4718) If the int_expression k is not zero then the computation stops after
reference.tex(,4719) k steps and returns a list of modules
reference.tex(,4726) 
reference.tex(,4727) @code{list L=lres(I,0);} returns a list L of n modules (where n is the
reference.tex(,4728) number of variables of the basering) such that
reference.tex(,4735) in the above notation.
reference.tex(,4736) @item @strong{Note:}
reference.tex(,4737) The ideal_expression has to be homogeneous.
reference.tex(,4738) @*Accessing single elements of a resolution may require that some partial
reference.tex(,4739) computations have to be finished and may therefore take some time.
reference.tex(,4740) @item @strong{Example:}
reference.tex(,4741) @smallexample
reference.tex(,4742) @c reused example lres reference.doc:3334 
reference.tex(,4743)   ring r=0,(x,y,z),dp;
reference.tex(,4744)   ideal I=xz,yz,x3-y3;
reference.tex(,4745)   def L=lres(I,0);
reference.tex(,4746)   print(betti(L),"betti");
reference.tex(,4747) @expansion{}            0     1     2
reference.tex(,4748) @expansion{} ------------------------
reference.tex(,4749) @expansion{}     0:     1     -     -
reference.tex(,4750) @expansion{}     1:     -     2     1
reference.tex(,4751) @expansion{}     2:     -     1     1
reference.tex(,4752) @expansion{} ------------------------
reference.tex(,4753) @expansion{} total:     1     3     2
reference.tex(,4754)   L[2];     // the first syzygy module of r/I
reference.tex(,4755) @expansion{} _[1]=-x*gen(1)+y*gen(2)
reference.tex(,4756) @expansion{} _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)
reference.tex(,4757) @c end example lres reference.doc:3334
reference.tex(,4758) @end smallexample
reference.tex(,4759) @end table
reference.tex(,4760) @c inserted refs from reference.doc:3343
reference.tex(,4787) @c end inserted refs from reference.doc:3343
reference.tex(,4788) @c ---------------------------------------
reference.tex(,4789) @node maxideal, memory, lres, Functions
reference.tex(,4790) @subsection maxideal
reference.tex(,4791) @cindex maxideal
reference.tex(,4792) @table @code
reference.tex(,4793) @item @strong{Syntax:}
reference.tex(,4794) @code{maxideal (} int_expression @code{)}
reference.tex(,4795) @item @strong{Type:}
reference.tex(,4796) ideal
reference.tex(,4797) @item @strong{Purpose:}
reference.tex(,4798) returns the power given by int_expression of the maximal ideal
reference.tex(,4799) generated by all ring variables (@code{maxideal(i)=1} for @code{i<=0}).
reference.tex(,4800) @item @strong{Example:}
reference.tex(,4801) @smallexample
reference.tex(,4802) @c reused example maxideal reference.doc:3369 
reference.tex(,4803)   ring r=32003,(x,y,z),dp;
reference.tex(,4804)   maxideal(2);
reference.tex(,4805) @expansion{} _[1]=z2
reference.tex(,4806) @expansion{} _[2]=yz
reference.tex(,4807) @expansion{} _[3]=y2
reference.tex(,4808) @expansion{} _[4]=xz
reference.tex(,4809) @expansion{} _[5]=xy
reference.tex(,4810) @expansion{} _[6]=x2
reference.tex(,4811) @c end example maxideal reference.doc:3369
reference.tex(,4812) @end smallexample
reference.tex(,4813) @end table
reference.tex(,4814) @c inserted refs from reference.doc:3375
reference.tex(,4827) @c end inserted refs from reference.doc:3375
reference.tex(,4828) @c ---------------------------------------
reference.tex(,4829) @node  memory, minbase, maxideal, Functions
reference.tex(,4830) @subsection memory
reference.tex(,4831) @cindex memory
reference.tex(,4832) @cindex memory managment
reference.tex(,4833) @table @code
reference.tex(,4834) @item @strong{Syntax:}
reference.tex(,4835) @code{memory (} int_expression @code{)}
reference.tex(,4836) @item @strong{Type:}
reference.tex(,4837) int
reference.tex(,4838) @item @strong{Purpose:}
reference.tex(,4839) returns statistics concerning the memory management:
reference.tex(,4840) @itemize @bullet
reference.tex(,4841) @item @code{memory(0)} is the number of active (used) bytes,
reference.tex(,4842) @item @code{memory(1)} is the number of bytes allocated from the
reference.tex(,4843) operating system,
reference.tex(,4844) @item @code{memory(2)} is the maximal number of bytes ever allocated from the
reference.tex(,4845) operating system during the current @sc{Singular} session.
reference.tex(,4846) @end itemize
reference.tex(,4847) @item @strong{Note:}
reference.tex(,4848) To monitor the memory usage during ongoing computations the option
reference.tex(,4849) @code{mem} should be set (using the command @code{option(mem);}, see
reference.tex(,4850) also @ref{option}).
reference.tex(,4851) @item @strong{Example:}
reference.tex(,4852) @smallexample
reference.tex(,4853) @c reused example memory reference.doc:3405 
reference.tex(,4854)   ring r=0,(x(1..500)),dp;
reference.tex(,4855)   poly p=(x(1)+x(500))^50;
reference.tex(,4856)   proc ReportMemoryUsage()
reference.tex(,4857)   @{  "Memory currently used by SINGULAR     :",memory(0),"Byte (",
reference.tex(,4858)      memory(0)/1023, "KByte)" +newline+
reference.tex(,4859)      "Memory currently allocated from system:",memory(1), "Byte (",
reference.tex(,4860)      memory(1)/1023, "KByte)";
reference.tex(,4861)      "Maximal memory allocated from system  :",memory(2), "Byte (",
reference.tex(,4862)      memory(2)/1023, "KByte)";
reference.tex(,4863)   @}
reference.tex(,4864)   ReportMemoryUsage();
reference.tex(,4865) @expansion{} Memory currently used by SINGULAR     : 206940 Byte ( 202 KByte)
reference.tex(,4866) @expansion{} Memory currently allocated from system: 669128 Byte ( 654 KByte)
reference.tex(,4867) @expansion{} Maximal memory allocated from system  : 669128 Byte ( 654 KByte)
reference.tex(,4868)   kill p;
reference.tex(,4869)   ReportMemoryUsage(); // less memory used: p killed
reference.tex(,4870) @expansion{} Memory currently used by SINGULAR     : 153704 Byte ( 150 KByte)
reference.tex(,4871) @expansion{} Memory currently allocated from system: 669128 Byte ( 654 KByte)
reference.tex(,4872) @expansion{} Maximal memory allocated from system  : 669128 Byte ( 654 KByte)
reference.tex(,4873)   kill r;
reference.tex(,4874)   ReportMemoryUsage(); // even less memory: r killed
reference.tex(,4875) @expansion{} Memory currently used by SINGULAR     : 143124 Byte ( 139 KByte)
reference.tex(,4876) @expansion{} Memory currently allocated from system: 669128 Byte ( 654 KByte)
reference.tex(,4877) @expansion{} Maximal memory allocated from system  : 669128 Byte ( 654 KByte)
reference.tex(,4878) @c end example memory reference.doc:3405
reference.tex(,4879) @end smallexample
reference.tex(,4880) @end table
reference.tex(,4881) @c inserted refs from reference.doc:3424
reference.tex(,4894) @c end inserted refs from reference.doc:3424
reference.tex(,4895) @c ---------------------------------------
reference.tex(,4896) @node minbase, minor, memory, Functions
reference.tex(,4897) @subsection minbase
reference.tex(,4898) @cindex minbase
reference.tex(,4899) @table @code
reference.tex(,4900) @item @strong{Syntax:}
reference.tex(,4901) @code{minbase (} ideal_expression @code{)}
reference.tex(,4902) @*@code{minbase (} module_expression @code{)}
reference.tex(,4903) @item @strong{Type:}
reference.tex(,4904) the same as the type of the argument
reference.tex(,4905) @item @strong{Purpose:}
reference.tex(,4906) returns a minimal set of generators of an ideal, resp.@: module, if the
reference.tex(,4907) input is
reference.tex(,4908) either homogeneous or if the ordering is local.
reference.tex(,4909) @item @strong{Example:}
reference.tex(,4910) @smallexample
reference.tex(,4911) @c reused example minbase reference.doc:3445 
reference.tex(,4912)   ring r=181,(x,y,z),(c,ls);
reference.tex(,4913)   ideal id2=x2+xyz,y2-z3y,z3+y5xz;
reference.tex(,4914)   ideal id4=maxideal(3)+id2;
reference.tex(,4915)   size(id4);
reference.tex(,4916) @expansion{} 13
reference.tex(,4917)   minbase(id4);
reference.tex(,4918) @expansion{} _[1]=x2
reference.tex(,4919) @expansion{} _[2]=xyz+x2
reference.tex(,4920) @expansion{} _[3]=xz2
reference.tex(,4921) @expansion{} _[4]=y2
reference.tex(,4922) @expansion{} _[5]=yz2
reference.tex(,4923) @expansion{} _[6]=z3
reference.tex(,4924) @c end example minbase reference.doc:3445
reference.tex(,4925) @end smallexample
reference.tex(,4926) @end table
reference.tex(,4927) @c inserted refs from reference.doc:3454
reference.tex(,4938) @c end inserted refs from reference.doc:3454
reference.tex(,4939) @c ---------------------------------------
reference.tex(,4940) @node minor, minres, minbase, Functions
reference.tex(,4941) @subsection minor
reference.tex(,4942) @cindex minor
reference.tex(,4943) @table @code
reference.tex(,4944) @item @strong{Syntax:}
reference.tex(,4945) @code{minor (} matrix_expression@code{,} int_expression @code{)}
reference.tex(,4946) @*@code{minor (} matrix_expression@code{,} int_expression@code{,} ideal_expression @code{)}
reference.tex(,4947) @item @strong{Type:}
reference.tex(,4948) ideal
reference.tex(,4949) @item @strong{Purpose:}
reference.tex(,4950) returns the set of all minors (=subdeterminants) of the given size of a matrix.
reference.tex(,4951) The optional third argument must be a standard basis.
reference.tex(,4952) If a third argument is given, the computations will be performed modulo that
reference.tex(,4953) ideal.
reference.tex(,4954) @item @strong{Example:}
reference.tex(,4955) @smallexample
reference.tex(,4956) @c reused example minor reference.doc:3475 
reference.tex(,4957)   ring r=0,(x(1..5)),ds;
reference.tex(,4958)   matrix m[2][4]=x(1..4),x(2..5);
reference.tex(,4959)   print(m);
reference.tex(,4960) @expansion{} x(1),x(2),x(3),x(4),
reference.tex(,4961) @expansion{} x(2),x(3),x(4),x(5) 
reference.tex(,4962)   ideal j=minor(m,2);
reference.tex(,4963)   j;
reference.tex(,4964) @expansion{} j[1]=-x(4)^2+x(3)*x(5)
reference.tex(,4965) @expansion{} j[2]=-x(3)*x(4)+x(2)*x(5)
reference.tex(,4966) @expansion{} j[3]=-x(2)*x(4)+x(1)*x(5)
reference.tex(,4967) @expansion{} j[4]=x(3)^2-x(2)*x(4)
reference.tex(,4968) @expansion{} j[5]=x(2)*x(3)-x(1)*x(4)
reference.tex(,4969) @expansion{} j[6]=-x(2)^2+x(1)*x(3)
reference.tex(,4970)   minor(m,2,std(ideal(x(1))));
reference.tex(,4971) @expansion{} _[1]=-x(4)^2+x(3)*x(5)
reference.tex(,4972) @expansion{} _[2]=-x(3)*x(4)+x(2)*x(5)
reference.tex(,4973) @expansion{} _[3]=-x(2)*x(4)
reference.tex(,4974) @expansion{} _[4]=x(3)^2-x(2)*x(4)
reference.tex(,4975) @expansion{} _[5]=x(2)*x(3)
reference.tex(,4976) @expansion{} _[6]=-x(2)^2
reference.tex(,4977) @c end example minor reference.doc:3475
reference.tex(,4978) @end smallexample
reference.tex(,4979) @end table
reference.tex(,4980) @c inserted refs from reference.doc:3485
reference.tex(,4991) @c end inserted refs from reference.doc:3485
reference.tex(,4992) @c ---------------------------------------
reference.tex(,4993) @node  minres, modulo, minor, Functions
reference.tex(,4994) @subsection minres
reference.tex(,4995) @cindex minres
reference.tex(,4996) @table @code
reference.tex(,4997) @item @strong{Syntax:}
reference.tex(,4998) @code{minres (} list_expression @code{)}
reference.tex(,4999) @item @strong{Type:}
reference.tex(,5000) list
reference.tex(,5001) @item @strong{Syntax:}
reference.tex(,5002) @code{minres (} resolution_expression @code{)}
reference.tex(,5003) @item @strong{Type:}
reference.tex(,5004) resolution
reference.tex(,5005) @item @strong{Purpose:}
reference.tex(,5006) minimizes a free resolution of an ideal or module
reference.tex(,5007) given by the list_expression, resp.@: resolution_expression.
reference.tex(,5008) @item @strong{Example:}
reference.tex(,5009) @smallexample
reference.tex(,5010) @c reused example minres reference.doc:3507 
reference.tex(,5011)   ring r1=32003,(x,y),dp;
reference.tex(,5012)   ideal i=x5+xy4,x3+x2y+xy2+y3;
reference.tex(,5013)   resolution rs=lres(i,0);
reference.tex(,5014)   rs;
reference.tex(,5015) @expansion{}   1       2       1       
reference.tex(,5016) @expansion{} r1 <--  r1 <--  r1
reference.tex(,5017) @expansion{} 
reference.tex(,5018) @expansion{} 0       1       2       
reference.tex(,5019) @expansion{} resolution not minimized yet
reference.tex(,5020) @expansion{} 
reference.tex(,5021)   list(rs);
reference.tex(,5022) @expansion{} [1]:
reference.tex(,5023) @expansion{}    _[1]=x3+x2y+xy2+y3
reference.tex(,5024) @expansion{}    _[2]=xy4
reference.tex(,5025) @expansion{}    _[3]=y7
reference.tex(,5026) @expansion{} [2]:
reference.tex(,5027) @expansion{}    _[1]=-y4*gen(1)+x2*gen(2)+xy*gen(2)+y2*gen(2)+gen(3)
reference.tex(,5028) @expansion{}    _[2]=-y3*gen(2)+x*gen(3)
reference.tex(,5029)   minres(rs);
reference.tex(,5030) @expansion{}   1       2       1       
reference.tex(,5031) @expansion{} r1 <--  r1 <--  r1
reference.tex(,5032) @expansion{} 
reference.tex(,5033) @expansion{} 0       1       2       
reference.tex(,5034) @expansion{} 
reference.tex(,5035)   list(rs);
reference.tex(,5036) @expansion{} [1]:
reference.tex(,5037) @expansion{}    _[1]=x3+x2y+xy2+y3
reference.tex(,5038) @expansion{}    _[2]=xy4
reference.tex(,5039) @expansion{} [2]:
reference.tex(,5040) @expansion{}    _[1]=xy4*gen(1)-x3*gen(2)-x2y*gen(2)-xy2*gen(2)-y3*gen(2)
reference.tex(,5041) @c end example minres reference.doc:3507
reference.tex(,5042) @end smallexample
reference.tex(,5043) @end table
reference.tex(,5044) @c inserted refs from reference.doc:3518
reference.tex(,5059) @c end inserted refs from reference.doc:3518
reference.tex(,5060) @c --------------------------------------
reference.tex(,5061) @node modulo, monitor, minres, Functions
reference.tex(,5062) @subsection modulo
reference.tex(,5063) @cindex modulo
reference.tex(,5064) @table @code
reference.tex(,5065) @item @strong{Syntax:}
reference.tex(,5066) @code{modulo (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,5067) @*@code{modulo (} module_expression@code{,} module_expression @code{)}
reference.tex(,5068) @item @strong{Type:}
reference.tex(,5069) module
reference.tex(,5070) @item @strong{Purpose:}
reference.tex(,5071) @code{modulo(h1,h2)}
reference.tex(,5078) where
reference.tex(,5085) are considered as submodules of the same free module
reference.tex(,5092) (l=1 for ideals). Let
reference.tex(,5107) as columns.
reference.tex(,5108) @c @*
reference.tex(,5109) @c @tex
reference.tex(,5110) @c $R^k \buildrel{H_1}\over{\rightarrow} R^l
reference.tex(,5111) @c \buildrel{H_2}\over{\leftarrow} R^m$
reference.tex(,5112) @c @end tex
reference.tex(,5113) @c @ifinfo
reference.tex(,5114) @c @smallexample
reference.tex(,5115) @c      H1         H2
reference.tex(,5116) @c R^k ----> R^l <---- R^m
reference.tex(,5117) @c @end smallexample
reference.tex(,5118) @c @end ifinfo
reference.tex(,5119) Then
reference.tex(,5131) where
reference.tex(,5144) @*@code{modulo(h1,h2)} returns generators of
reference.tex(,5145) the kernel of this induced map.
reference.tex(,5146) @item @strong{Example:}
reference.tex(,5147) @smallexample
reference.tex(,5148) @c reused example modulo reference.doc:3612 
reference.tex(,5149)   ring r;
reference.tex(,5150)   ideal h1=x,y,z;
reference.tex(,5151)   ideal h2=x;
reference.tex(,5152)   module m=modulo(h1,h2);
reference.tex(,5153)   print(m);
reference.tex(,5154) @expansion{} 1,0, 0,0,
reference.tex(,5155) @expansion{} 0,-z,x,0,
reference.tex(,5156) @expansion{} 0,y, 0,x 
reference.tex(,5157) @c end example modulo reference.doc:3612
reference.tex(,5158) @end smallexample
reference.tex(,5159) @end table
reference.tex(,5160) @c inserted refs from reference.doc:3621
reference.tex(,5171) @c end inserted refs from reference.doc:3621
reference.tex(,5172) @c ---------------------------------------
reference.tex(,5173) @node monitor, mpresmat, modulo, Functions
reference.tex(,5174) @subsection monitor
reference.tex(,5175) @cindex monitor
reference.tex(,5176) @table @code
reference.tex(,5177) @item @strong{Syntax:}
reference.tex(,5178) @code{monitor (} string_expression @code{)}
reference.tex(,5179) @*@code{monitor (} string_expression@code{,} string_expression @code{)}
reference.tex(,5180) @item @strong{Type:}
reference.tex(,5181) none
reference.tex(,5182) @item @strong{Purpose:}
reference.tex(,5183) controls the recording of all user input and/or program output into a file.
reference.tex(,5184) The second argument describes what to log: @code{"i"} means input,
reference.tex(,5185) @code{"o"} means output, @code{"io"} for both.
reference.tex(,5186) @*The default for the second argument is @code{"i"}.
reference.tex(,5187) @*Each @code{monitor} command closes a previous monitor file
reference.tex(,5188) and opens the file given by the first string expression.
reference.tex(,5189) @*@code{monitor ("")} turns off recording.
reference.tex(,5190) @item @strong{Example:}
reference.tex(,5191) @smallexample
reference.tex(,5192)   monitor("doe.tmp","io"); // log input and output to doe.tmp
reference.tex(,5193)   ring r;
reference.tex(,5194)   poly f=x+y+z;
reference.tex(,5195)   int i=7;
reference.tex(,5196)   ideal I=f,x,y;
reference.tex(,5197)   monitor("");             // stop logging
reference.tex(,5198) @end smallexample
reference.tex(,5199) @end table
reference.tex(,5200) @c ---------------------------------------
reference.tex(,5201) @node mpresmat, mres, monitor, Functions
reference.tex(,5202) @subsection mpresmat
reference.tex(,5203) @cindex mpresmat
reference.tex(,5204) @table @code
reference.tex(,5205) @item @strong{Syntax:}
reference.tex(,5206) @code{mpresmat (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,5207) @item @strong{Type:}
reference.tex(,5208) module
reference.tex(,5209) @item @strong{Purpose:}
reference.tex(,5210) computes the multipolynomial resultant matrix of the input system.
reference.tex(,5211) Uses the sparse resultant matrix method of Gelfand, Kapranov and Zelevinsky
reference.tex(,5212) (second parameter = 0) or the resultant matrix method of Macaulay
reference.tex(,5213) (second parameter = 1).
reference.tex(,5214) @item @strong{Note:}
reference.tex(,5215) When using the resultant matrix method of Macaulay the input system must be
reference.tex(,5216) homogeneous. The number of elements in the input system must be the number of
reference.tex(,5217) variables in the basering plus one.
reference.tex(,5218) @item @strong{Example:}
reference.tex(,5219) @smallexample
reference.tex(,5220) @c reused example mpresmat reference.doc:3675 
reference.tex(,5221)   ring rsq=(0,s,t,u),(x,y),lp;
reference.tex(,5222)   ideal i=s+tx+uy,x2+y2-10,x2+xy+2y2-16;
reference.tex(,5223)   module m=mpresmat(i,0);
reference.tex(,5224)   print(m);
reference.tex(,5225) @expansion{} -16,0,  -10,0,  (s),0,  0,  0,  0,  0,  
reference.tex(,5226) @expansion{} 0,  -16,0,  -10,(u),(s),0,  0,  0,  0,  
reference.tex(,5227) @expansion{} 2,  0,  1,  0,  0,  (u),0,  0,  0,  0,  
reference.tex(,5228) @expansion{} 0,  2,  0,  1,  0,  0,  0,  0,  0,  0,  
reference.tex(,5229) @expansion{} 0,  0,  0,  0,  (t),0,  -10,(s),0,  -16,
reference.tex(,5230) @expansion{} 1,  0,  0,  0,  0,  (t),0,  (u),(s),0,  
reference.tex(,5231) @expansion{} 0,  1,  0,  0,  0,  0,  1,  0,  (u),2,  
reference.tex(,5232) @expansion{} 1,  0,  1,  0,  0,  0,  0,  (t),0,  0,  
reference.tex(,5233) @expansion{} 0,  1,  0,  1,  0,  0,  0,  0,  (t),1,  
reference.tex(,5234) @expansion{} 0,  0,  0,  0,  0,  0,  1,  0,  0,  1   
reference.tex(,5235) @c end example mpresmat reference.doc:3675
reference.tex(,5236) @end smallexample
reference.tex(,5237) @end table
reference.tex(,5238) @c inserted refs from reference.doc:3683
reference.tex(,5249) @c end inserted refs from reference.doc:3683
reference.tex(,5250) @c ---------------------------------------
reference.tex(,5251) @node  mres, mstd, mpresmat, Functions
reference.tex(,5252) @subsection mres
reference.tex(,5253) @cindex mres
reference.tex(,5254) @table @code
reference.tex(,5255) @item @strong{Syntax:}
reference.tex(,5256) @code{mres (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,5257) @*@code{mres (} module_expression@code{,} int_expression @code{)}
reference.tex(,5258) @item @strong{Type:}
reference.tex(,5259) resolution
reference.tex(,5260) @item @strong{Purpose:}
reference.tex(,5261) computes a minimal free resolution of an ideal or module M with the
reference.tex(,5262) standard basis method. More precisely, let A=@code{matrix}(M), then @code{mres}
reference.tex(,5263) computes a free resolution of
reference.tex(,5277) where the columns of the matrix
reference.tex(,5284) are a minimal set of generators
reference.tex(,5285) of M if the basering is local or if M is homogeneous.
reference.tex(,5286) If the int expression k is not zero then the computation stops after k steps
reference.tex(,5287) and returns a list of modules
reference.tex(,5294) @*@code{mres(M,0)} returns a resolution consisting of at most n+2 modules,
reference.tex(,5295) where n is the number of variables of the basering.
reference.tex(,5296) Let @code{list L=mres(M,0);}
reference.tex(,5297)  then @code{L[1]} consists of a minimal set of generators of the input, @code{L[2]}
reference.tex(,5298) consists of a minimal set of generators for the first syzygy module of
reference.tex(,5299) @code{L[1]}, etc., until @code{L[p+1]}, such that
reference.tex(,5306)  but @code{L[p+1]}, the first syzygy module of @code{L[p]},
reference.tex(,5307) is 0 (if the basering is not a qring).
reference.tex(,5308) @item @strong{Note:}
reference.tex(,5309) Accessing single elements of a resolution may require that some partial
reference.tex(,5310) computations have to be finished and may therefore take some time.
reference.tex(,5311) @item @strong{Example:}
reference.tex(,5312) @smallexample
reference.tex(,5313) @c reused example mres reference.doc:3750 
reference.tex(,5314)   ring r=31991,(t,x,y,z,w),ls;
reference.tex(,5315)   ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
reference.tex(,5316)           t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
reference.tex(,5317)   resolution L=mres(M,0);
reference.tex(,5318)   L;
reference.tex(,5319) @expansion{}  1      4      15      18      7      1      
reference.tex(,5320) @expansion{} r <--  r <--  r <--   r <--   r <--  r
reference.tex(,5321) @expansion{} 
reference.tex(,5322) @expansion{} 0      1      2       3       4      5      
reference.tex(,5323) @expansion{} 
reference.tex(,5324)   // projective dimension of M is 5
reference.tex(,5325) @c end example mres reference.doc:3750
reference.tex(,5326) @end smallexample
reference.tex(,5327) @end table
reference.tex(,5328) @c inserted refs from reference.doc:3760
reference.tex(,5349) @c end inserted refs from reference.doc:3760
reference.tex(,5350) @c ---------------------------------------
reference.tex(,5351) @node  mstd, mult, mres, Functions
reference.tex(,5352) @subsection mstd
reference.tex(,5353) @cindex mstd
reference.tex(,5354) @table @code
reference.tex(,5355) @item @strong{Syntax:}
reference.tex(,5356) @code{mstd (} ideal_expression @code{)}
reference.tex(,5357) @*@code{mstd (} module_expression @code{)}
reference.tex(,5358) @item @strong{Type:}
reference.tex(,5359) list
reference.tex(,5360) @item @strong{Purpose:}
reference.tex(,5361) returns a list whose first entry is a standard basis for the ideal, resp.@:
reference.tex(,5362) module. If the monomial ordering is global, then the second entry is both
reference.tex(,5363) a generating set for the
reference.tex(,5364) ideal, resp.@: module, and a subset of the standard basis.
reference.tex(,5365) If, additionally, the input is homogeneous then the second entry is a
reference.tex(,5366) minimal generating set for the ideal, resp.@: module.
reference.tex(,5367) @item @strong{Example:}
reference.tex(,5368) @smallexample
reference.tex(,5369) @c reused example mstd reference.doc:3788 
reference.tex(,5370)   ring r=0,(x,y,z,t),dp;
reference.tex(,5371)   poly f=x3+y4+z6+xyz;
reference.tex(,5372)   ideal j=jacob(f),f;
reference.tex(,5373)   j=homog(j,t);j;
reference.tex(,5374) @expansion{} j[1]=3x2+yz
reference.tex(,5375) @expansion{} j[2]=4y3+xzt
reference.tex(,5376) @expansion{} j[3]=6z5+xyt3
reference.tex(,5377) @expansion{} j[4]=0
reference.tex(,5378) @expansion{} j[5]=z6+y4t2+x3t3+xyzt3
reference.tex(,5379)   mstd(j);
reference.tex(,5380) @expansion{} [1]:
reference.tex(,5381) @expansion{}    _[1]=3x2+yz
reference.tex(,5382) @expansion{}    _[2]=4y3+xzt
reference.tex(,5383) @expansion{}    _[3]=6z5+xyt3
reference.tex(,5384) @expansion{}    _[4]=xyzt3
reference.tex(,5385) @expansion{}    _[5]=y2z2t3
reference.tex(,5386) @expansion{}    _[6]=yz3t4
reference.tex(,5387) @expansion{}    _[7]=xz3t4
reference.tex(,5388) @expansion{}    _[8]=yz2t7
reference.tex(,5389) @expansion{}    _[9]=xz2t7
reference.tex(,5390) @expansion{}    _[10]=y2zt7
reference.tex(,5391) @expansion{}    _[11]=xy2t7
reference.tex(,5392) @expansion{} [2]:
reference.tex(,5393) @expansion{}    _[1]=3x2+yz
reference.tex(,5394) @expansion{}    _[2]=4y3+xzt
reference.tex(,5395) @expansion{}    _[3]=6z5+xyt3
reference.tex(,5396) @expansion{}    _[4]=xyzt3
reference.tex(,5397) @c end example mstd reference.doc:3788
reference.tex(,5398) @end smallexample
reference.tex(,5399) @end table
reference.tex(,5400) @c inserted refs from reference.doc:3797
reference.tex(,5417) @c end inserted refs from reference.doc:3797
reference.tex(,5418) @c ---------------------------------------
reference.tex(,5419) @node mult, nameof, mstd, Functions
reference.tex(,5420) @subsection mult
reference.tex(,5421) @cindex mult
reference.tex(,5422) @table @code
reference.tex(,5423) @item @strong{Syntax:}
reference.tex(,5424) @code{mult (} ideal_expression @code{)}
reference.tex(,5425) @*@code{mult (} module_expression @code{)}
reference.tex(,5426) @item @strong{Type:}
reference.tex(,5427) int
reference.tex(,5428) @item @strong{Purpose:}
reference.tex(,5429) computes the degree of the monomial ideal, resp.@: module, generated by
reference.tex(,5430) the leading monomials of the input.
reference.tex(,5431) @*If the input is a standard basis of a homogeneous ideal
reference.tex(,5432) then it returns the degree of this ideal.
reference.tex(,5433) @*If the input is a standard basis of an ideal in a (local)
reference.tex(,5434) ring with respect to a local degree ordering
reference.tex(,5435) then it returns the multiplicity of the ideal (in the sense of Samuel,
reference.tex(,5436) with respect to the maximal ideal).
reference.tex(,5437) @item @strong{Example:}
reference.tex(,5438) @smallexample
reference.tex(,5439) @c reused example mult reference.doc:3825 
reference.tex(,5440)   ring r=32003,(x,y),ds;
reference.tex(,5441)   poly f=(x3+y5)^2+x2y7;
reference.tex(,5442)   ideal i=std(jacob(f));
reference.tex(,5443)   mult(i);
reference.tex(,5444) @expansion{} 46
reference.tex(,5445)   mult(std(f));
reference.tex(,5446) @expansion{} 6
reference.tex(,5447) @c end example mult reference.doc:3825
reference.tex(,5448) @end smallexample
reference.tex(,5449) @end table
reference.tex(,5450) @c inserted refs from reference.doc:3834
reference.tex(,5469) @c end inserted refs from reference.doc:3834
reference.tex(,5470) @c ---------------------------------------
reference.tex(,5471) @node nameof, names, mult, Functions
reference.tex(,5472) @subsection nameof
reference.tex(,5473) @cindex nameof
reference.tex(,5474) @table @code
reference.tex(,5475) @item @strong{Syntax:}
reference.tex(,5476) @code{nameof (} expression @code{)}
reference.tex(,5477) @item @strong{Type:}
reference.tex(,5478) string
reference.tex(,5479) @item @strong{Purpose:}
reference.tex(,5480) returns the name of an expression as string.
reference.tex(,5481) @item @strong{Example:}
reference.tex(,5482) @smallexample
reference.tex(,5483) @c reused example nameof reference.doc:3855 
reference.tex(,5484)   int i=9;
reference.tex(,5485)   string s=nameof(i);
reference.tex(,5486)   s;
reference.tex(,5487) @expansion{} i
reference.tex(,5488)   nameof(s);
reference.tex(,5489) @expansion{} s
reference.tex(,5490)   nameof(i+1); //returns the empty string:
reference.tex(,5491) @expansion{} 
reference.tex(,5492)   nameof(basering);
reference.tex(,5493) @expansion{} basering
reference.tex(,5494)   basering;
reference.tex(,5495) @expansion{}    ? `basering` is undefined
reference.tex(,5496) @expansion{}    ? error occurred in line 7: `  basering;`
reference.tex(,5497)   ring r;
reference.tex(,5498)   nameof(basering);
reference.tex(,5499) @expansion{} r
reference.tex(,5500) @c end example nameof reference.doc:3855
reference.tex(,5501) @end smallexample
reference.tex(,5502) @end table
reference.tex(,5503) @c inserted refs from reference.doc:3868
reference.tex(,5518) @c end inserted refs from reference.doc:3868
reference.tex(,5519) @c ---------------------------------------
reference.tex(,5520) @node names, ncols, nameof, Functions
reference.tex(,5521) @subsection names
reference.tex(,5522) @cindex names
reference.tex(,5523) @table @code
reference.tex(,5524) @item @strong{Syntax:}
reference.tex(,5525) @code{names ( )}
reference.tex(,5526) @*@code{names (} ring_name @code{)}
reference.tex(,5530) @item @strong{Type:}
reference.tex(,5531) list of strings
reference.tex(,5532) @item @strong{Purpose:}
reference.tex(,5533) returns the names of all user-defined variables which are ring independent
reference.tex(,5534) (this includes the names of  procedures) or, in the second case, which
reference.tex(,5535) belong to the given ring.
reference.tex(,5536) 
reference.tex(,5613) @item @strong{Example:}
reference.tex(,5614) @smallexample
reference.tex(,5615) @c reused example names_1 reference.doc:3916 
reference.tex(,5616)   int i=9;
reference.tex(,5617)   ring r;
reference.tex(,5618)   poly f;
reference.tex(,5619)   poly g;
reference.tex(,5620)   setring r;
reference.tex(,5621)   names();
reference.tex(,5622) @expansion{} [1]:
reference.tex(,5623) @expansion{}    r
reference.tex(,5624) @expansion{} [2]:
reference.tex(,5625) @expansion{}    i
reference.tex(,5626) @expansion{} [3]:
reference.tex(,5627) @expansion{}    fprintf
reference.tex(,5628) @expansion{} [4]:
reference.tex(,5629) @expansion{}    printf
reference.tex(,5630) @expansion{} [5]:
reference.tex(,5631) @expansion{}    sprintf
reference.tex(,5632) @expansion{} [6]:
reference.tex(,5633) @expansion{}    intersect1
reference.tex(,5634) @expansion{} [7]:
reference.tex(,5635) @expansion{}    quotient4
reference.tex(,5636) @expansion{} [8]:
reference.tex(,5637) @expansion{}    quotient5
reference.tex(,5638) @expansion{} [9]:
reference.tex(,5639) @expansion{}    quotient3
reference.tex(,5640) @expansion{} [10]:
reference.tex(,5641) @expansion{}    quotient2
reference.tex(,5642) @expansion{} [11]:
reference.tex(,5643) @expansion{}    quotient1
reference.tex(,5644) @expansion{} [12]:
reference.tex(,5645) @expansion{}    quotient0
reference.tex(,5646) @expansion{} [13]:
reference.tex(,5647) @expansion{}    quot1
reference.tex(,5648) @expansion{} [14]:
reference.tex(,5649) @expansion{}    quot
reference.tex(,5650) @expansion{} [15]:
reference.tex(,5651) @expansion{}    res
reference.tex(,5652) @expansion{} [16]:
reference.tex(,5653) @expansion{}    groebner
reference.tex(,5654) @expansion{} [17]:
reference.tex(,5655) @expansion{}    stdhilb
reference.tex(,5656) @expansion{} [18]:
reference.tex(,5657) @expansion{}    stdfglm
reference.tex(,5658) @expansion{} [19]:
reference.tex(,5659) @expansion{}    LIB
reference.tex(,5660)   names(r);
reference.tex(,5661) @expansion{} [1]:
reference.tex(,5662) @expansion{}    g
reference.tex(,5663) @expansion{} [2]:
reference.tex(,5664) @expansion{}    f
reference.tex(,5665) @c end example names_1 reference.doc:3916
reference.tex(,5666) @end smallexample
reference.tex(,5668) @end table
reference.tex(,5669) @c inserted refs from reference.doc:3928
reference.tex(,5682) @c end inserted refs from reference.doc:3928
reference.tex(,5683) @c ---------------------------------------
reference.tex(,5684) @node ncols, npars, names, Functions
reference.tex(,5685) @subsection ncols
reference.tex(,5686) @cindex ncols
reference.tex(,5687) @table @code
reference.tex(,5688) @item @strong{Syntax:}
reference.tex(,5689) @code{ncols (} matrix_expression @code{)}
reference.tex(,5690) @*@code{ncols (} intmat_expression @code{)}
reference.tex(,5691) @*@code{ncols (} ideal_expression @code{)}
reference.tex(,5692) @item @strong{Type:}
reference.tex(,5693) int
reference.tex(,5694) @item @strong{Purpose:}
reference.tex(,5695) returns the number of columns of a matrix or an intmat or the number of
reference.tex(,5696) given generators of the ideal, including zeros.
reference.tex(,5697) @item @strong{Note:}
reference.tex(,5698) @code{size(}ideal@code{)} counts the number of generators
reference.tex(,5699) which are different from zero. (Use @code{nrows} to get the number of rows
reference.tex(,5700) of a given matrix or intmat.)
reference.tex(,5701) @item @strong{Example:}
reference.tex(,5702) @smallexample
reference.tex(,5703) @c reused example ncols reference.doc:3953 
reference.tex(,5704)   ring r;
reference.tex(,5705)   matrix m[5][6];
reference.tex(,5706)   ncols(m);
reference.tex(,5707) @expansion{} 6
reference.tex(,5708)   ideal i=x,0,y;
reference.tex(,5709)   ncols(i);
reference.tex(,5710) @expansion{} 3
reference.tex(,5711)   size(i);
reference.tex(,5712) @expansion{} 2
reference.tex(,5713) @c end example ncols reference.doc:3953
reference.tex(,5714) @end smallexample
reference.tex(,5715) @end table
reference.tex(,5716) @c inserted refs from reference.doc:3963
reference.tex(,5731) @c end inserted refs from reference.doc:3963
reference.tex(,5732) @c ---------------------------------------
reference.tex(,5733) @node npars, nres, ncols, Functions
reference.tex(,5734) @subsection npars
reference.tex(,5735) @cindex npars
reference.tex(,5736) @table @code
reference.tex(,5737) @item @strong{Syntax:}
reference.tex(,5738) @code{npars (} ring_name @code{)}
reference.tex(,5739) @item @strong{Type:}
reference.tex(,5740) int
reference.tex(,5741) @item @strong{Purpose:}
reference.tex(,5742) returns the number of parameters of a ring.
reference.tex(,5743) @item @strong{Example:}
reference.tex(,5744) @smallexample
reference.tex(,5745) @c reused example npars reference.doc:3982 
reference.tex(,5746)   ring r=(23,t,v),(x,a(1..7)),lp;
reference.tex(,5747)   // the parameters are t,v
reference.tex(,5748)   npars(r);
reference.tex(,5749) @expansion{} 2
reference.tex(,5750) @c end example npars reference.doc:3982
reference.tex(,5751) @end smallexample
reference.tex(,5752) @end table
reference.tex(,5753) @c inserted refs from reference.doc:3989
reference.tex(,5768) @c end inserted refs from reference.doc:3989
reference.tex(,5769) @c ---------------------------------------
reference.tex(,5770) @node  nres, nrows, npars, Functions
reference.tex(,5771) @subsection nres
reference.tex(,5772) @cindex nres
reference.tex(,5773) @table @code
reference.tex(,5774) @item @strong{Syntax:}
reference.tex(,5775) @code{nres (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,5776) @*@code{nres (} module_expression@code{,} int_expression @code{)}
reference.tex(,5777) @item @strong{Type:}
reference.tex(,5778) resolution
reference.tex(,5779) @item @strong{Purpose:}
reference.tex(,5780) computes a free resolution of an ideal or module M which is minimized from
reference.tex(,5781) the second module on (by the standard basis method).
reference.tex(,5782) 
reference.tex(,5783) More precisely, let
reference.tex(,5790) then @code{nres} computes a free resolution of
reference.tex(,5802) @*where the columns of the matrix
reference.tex(,5809) are the given set of generators of M.
reference.tex(,5810) If the int expression k is not zero then the computation stops after k steps
reference.tex(,5811) and returns a list of modules
reference.tex(,5818) @*@code{nres(M,0)} returns a list of n modules where n is the number of
reference.tex(,5819) variables of the basering.
reference.tex(,5820) Let @code{list L=nres(M,0);} then @code{L[1]=M} is identical to the input,
reference.tex(,5821) @code{L[2]} is a minimal set of generators for the first syzygy
reference.tex(,5822) module of  @code{L[1]}, etc.
reference.tex(,5829) in the notations from above).
reference.tex(,5830) @item @strong{Example:}
reference.tex(,5831) @smallexample
reference.tex(,5832) @c reused example nres reference.doc:4058 
reference.tex(,5833)   ring r=31991,(t,x,y,z,w),ls;
reference.tex(,5834)   ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
reference.tex(,5835)           t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
reference.tex(,5836)   resolution L=nres(M,0);
reference.tex(,5837)   L;
reference.tex(,5838) @expansion{}  1      4      15      18      7      1      
reference.tex(,5839) @expansion{} r <--  r <--  r <--   r <--   r <--  r
reference.tex(,5840) @expansion{} 
reference.tex(,5841) @expansion{} 0      1      2       3       4      5      
reference.tex(,5842) @expansion{} resolution not minimized yet
reference.tex(,5843) @expansion{} 
reference.tex(,5844) @c end example nres reference.doc:4058
reference.tex(,5845) @end smallexample
reference.tex(,5846) @end table
reference.tex(,5847) @c inserted refs from reference.doc:4067
reference.tex(,5872) @c end inserted refs from reference.doc:4067
reference.tex(,5873) @c ---------------------------------------
reference.tex(,5874) @node nrows, nvars, nres, Functions
reference.tex(,5875) @subsection nrows
reference.tex(,5876) @cindex nrows
reference.tex(,5877) @table @code
reference.tex(,5878) @item @strong{Syntax:}
reference.tex(,5879) @code{nrows (} matrix_expression @code{)}
reference.tex(,5880) @*@code{nrows (} intmat_expression @code{)}
reference.tex(,5881) @*@code{nrows (} intvec_expression @code{)}
reference.tex(,5882) @*@code{nrows (} module_expression @code{)}
reference.tex(,5883) @*@code{nrows (} vector_expression @code{)}
reference.tex(,5884) @item @strong{Type:}
reference.tex(,5885) int
reference.tex(,5886) @item @strong{Purpose:}
reference.tex(,5887) returns the number of rows of a matrix, an intmat or an intvec, resp.@:
reference.tex(,5888) the minimal rank of a free module in which the given module or
reference.tex(,5889) vector lives (the index of the last non-zero component).
reference.tex(,5890) @item @strong{Note:}
reference.tex(,5891) Use @code{ncols} to get the number of columns of a given matrix or intmat.
reference.tex(,5892) @item @strong{Example:}
reference.tex(,5893) @smallexample
reference.tex(,5894) @c reused example nrows reference.doc:4099 
reference.tex(,5895)   ring R;
reference.tex(,5896)   matrix M[2][3];
reference.tex(,5897)   nrows(M);
reference.tex(,5898) @expansion{} 2
reference.tex(,5899)   nrows(freemodule(4));
reference.tex(,5900) @expansion{} 4
reference.tex(,5901)   module m=[0,0,1];
reference.tex(,5902)   nrows(m);
reference.tex(,5903) @expansion{} 3
reference.tex(,5904)   nrows([0,x,0]);
reference.tex(,5905) @expansion{} 2
reference.tex(,5906) @c end example nrows reference.doc:4099
reference.tex(,5907) @end smallexample
reference.tex(,5908) @end table
reference.tex(,5909) @c inserted refs from reference.doc:4110
reference.tex(,5928) @c end inserted refs from reference.doc:4110
reference.tex(,5929) @c ---------------------------------------
reference.tex(,5930) @node nvars, open, nrows, Functions
reference.tex(,5931) @subsection nvars
reference.tex(,5932) @cindex nvars
reference.tex(,5933) @table @code
reference.tex(,5934) @item @strong{Syntax:}
reference.tex(,5935) @code{nvars (} ring_name @code{)}
reference.tex(,5936) @item @strong{Type:}
reference.tex(,5937) int
reference.tex(,5938) @item @strong{Purpose:}
reference.tex(,5939) returns the number of variables of a ring.
reference.tex(,5940) @item @strong{Example:}
reference.tex(,5941) @smallexample
reference.tex(,5942) @c reused example nvars reference.doc:4131 
reference.tex(,5943)   ring r=(23,t,v),(x,a(1..7)),ls;
reference.tex(,5944)   // the variables are x,a(1),...,a(7)
reference.tex(,5945)   nvars(r);
reference.tex(,5946) @expansion{} 8
reference.tex(,5947) @c end example nvars reference.doc:4131
reference.tex(,5948) @end smallexample
reference.tex(,5949) @end table
reference.tex(,5950) @c inserted refs from reference.doc:4138
reference.tex(,5967) @c end inserted refs from reference.doc:4138
reference.tex(,5968) @c ---------------------------------------
reference.tex(,5969) @node open, option, nvars, Functions
reference.tex(,5970) @subsection open
reference.tex(,5971) @cindex open
reference.tex(,5972) @table @code
reference.tex(,5973) @item @strong{Syntax:}
reference.tex(,5974) @code{open (} link_expression @code{)}
reference.tex(,5975) @item @strong{Type:}
reference.tex(,5976) none
reference.tex(,5977) @item @strong{Purpose:}
reference.tex(,5978) opens a link.
reference.tex(,5979) @item @strong{Example:}
reference.tex(,5980) @smallexample
reference.tex(,5981) link l="MPtcp:launch";
reference.tex(,5982) open(l);  // start SINGULAR "server" on localhost in batchmode
reference.tex(,5983) close(l); // shut down SINGULAR server
reference.tex(,5984) @end smallexample
reference.tex(,5985) @end table
reference.tex(,5986) @c inserted refs from reference.doc:4163
reference.tex(,5999) @c end inserted refs from reference.doc:4163
reference.tex(,6000) @c ---------------------------------------
reference.tex(,6001) @node option, ord, open, Functions
reference.tex(,6002) @subsection option
reference.tex(,6003) @cindex option
reference.tex(,6004) @table @code
reference.tex(,6005) @item @strong{Syntax:}
reference.tex(,6006) @code{option ()}
reference.tex(,6007) @item @strong{Type:}
reference.tex(,6008) string
reference.tex(,6009) @item @strong{Purpose:}
reference.tex(,6010) lists all defined options.
reference.tex(,6011) @*
reference.tex(,6012) @item @strong{Syntax:}
reference.tex(,6013) @code{option (} option_name @code{)}
reference.tex(,6014) @item @strong{Type:}
reference.tex(,6015) none
reference.tex(,6016) @item @strong{Purpose:}
reference.tex(,6017) sets an option.
reference.tex(,6018) @item @strong{Note:}
reference.tex(,6019) To disable an option, use the prefix @code{no}.
reference.tex(,6020) @*
reference.tex(,6021) @item @strong{Syntax:}
reference.tex(,6022) @code{option ( get )}
reference.tex(,6023) @item @strong{Type:}
reference.tex(,6024) intvec
reference.tex(,6025) @item @strong{Purpose:}
reference.tex(,6026) dumps the state of all options to an intvec.
reference.tex(,6027) @*
reference.tex(,6028) @item @strong{Syntax:}
reference.tex(,6029) @code{option ( set,} intvec_expression @code{)}
reference.tex(,6030) @item @strong{Type:}
reference.tex(,6031) none
reference.tex(,6032) @item @strong{Purpose:}
reference.tex(,6033) restores the state of all options from an intvec (produced by
reference.tex(,6034) @code{option(get)}).
reference.tex(,6035) @sp 1
reference.tex(,6036) @item @strong{Values:}
reference.tex(,6037) The following options are used to manipulate the behavior of
reference.tex(,6038) computations and act like boolean switches. Use the prefix @code{no} to
reference.tex(,6039) disable an option. Notice that some options are ring dependent and reset
reference.tex(,6040) to their default values on a change of the current basering.
reference.tex(,6041) @table @asis
reference.tex(,6042) @item @code{none}
reference.tex(,6043) @c ---------
reference.tex(,6044) @cindex none, option
reference.tex(,6045) turns off all options (including the @code{prompt} option).
reference.tex(,6046) @c ---------
reference.tex(,6047) @item @code{returnSB}
reference.tex(,6048) @cindex returnSB, option
reference.tex(,6049) the functions @code{syz}, @code{intersect}, @code{quotient},
reference.tex(,6050) @code{modulo} return a standard base instead of a generating set if
reference.tex(,6051) @code{returnSB} is set. This option should not be used for @code{lift}.
reference.tex(,6052) @c ---------
reference.tex(,6053) @item @code{fastHC}
reference.tex(,6054) @cindex fastHC, option
reference.tex(,6055) tries to the find the highest corner of the staircase (HC) as fast as
reference.tex(,6056) possible during a standard basis computation (only used for local
reference.tex(,6057) orderings).
reference.tex(,6058) @c ---------
reference.tex(,6059) @c @item @code{interrupt}
reference.tex(,6060) @c allows fast interruption of standard basis computation
reference.tex(,6061) @c ---------
reference.tex(,6062) @item @code{intStrategy}
reference.tex(,6063) @cindex intStrategy, option
reference.tex(,6064) avoids division of coefficients during standard basis
reference.tex(,6065) computations. This option is ring dependent. By default, it is set for
reference.tex(,6066) rings with characteristic 0 and not set for all other rings.
reference.tex(,6067) @c ---------
reference.tex(,6068) @item @code{oldStd}
reference.tex(,6069) @cindex oldStd, option
reference.tex(,6070) uses a more lazy approach in std computations,
reference.tex(,6071) which was used in Singular version before 2-0
reference.tex(,6072) (and which may lead to faster or slower computations, depending on the example)
reference.tex(,6073) @item @code{minRes}
reference.tex(,6074) @cindex minRes, option
reference.tex(,6075) special (additional) minimizing during computations (@code{res}, @code{mres}),
reference.tex(,6076) @*assumes homogeneous case and degree-compatible ordering.
reference.tex(,6077) @c ---------
reference.tex(,6078) @item @code{notRegularity}
reference.tex(,6079) @cindex notRegularity, option
reference.tex(,6080) disables the regularity bound for @code{res} and @code{mres} (see
reference.tex(,6081) @ref{regularity}).
reference.tex(,6082) @c ---------
reference.tex(,6083) @item @code{notSugar}
reference.tex(,6084) @cindex notSugar, option
reference.tex(,6085) disables the sugar strategy during standard basis computation.
reference.tex(,6086) @anchor{option(prot)}
reference.tex(,6087) @c ---------
reference.tex(,6088) @item @code{notBuckets}
reference.tex(,6089) @cindex notBuckets, option
reference.tex(,6090) disables the bucket representation of polynomials during standard basis
reference.tex(,6091) computations. This option usually decreases the memory usage but
reference.tex(,6092) increases the computation time. It should only be set for
reference.tex(,6093) memory-critical standard basis computations.
reference.tex(,6094) @c ---------
reference.tex(,6095) @item @code{prot}
reference.tex(,6096) @cindex prot, option
reference.tex(,6097) @cindex protocoll of computations
reference.tex(,6098) @cindex progress watch
reference.tex(,6099) shows protocol information indicating the
reference.tex(,6100) progress during the following computations:
reference.tex(,6101) @code{facstd},
reference.tex(,6102) @code{fglm},
reference.tex(,6103) @code{groebner},
reference.tex(,6104) @code{lres},
reference.tex(,6105) @code{mres},
reference.tex(,6106) @code{minres},
reference.tex(,6107) @code{mstd},
reference.tex(,6108) @code{res},
reference.tex(,6109) @code{sres},
reference.tex(,6110) @code{std},
reference.tex(,6111) @code{stdfglm},
reference.tex(,6112) @code{stdhilb},
reference.tex(,6113) @code{syz}.
reference.tex(,6114) See below for more details.
reference.tex(,6115) @c ---------
reference.tex(,6116) @item @code{redSB}
reference.tex(,6117) @cindex redSB, option
reference.tex(,6118) @cindex reduced standard basis
reference.tex(,6119) computes a reduced standard basis in any standard basis computation.
reference.tex(,6120) @c ---------
reference.tex(,6121) @item @code{redTail}
reference.tex(,6122) @cindex redTail, option
reference.tex(,6123) reduction of the tails of polynomials during standard basis
reference.tex(,6124) computations. This option is ring dependent. By default, it is set for
reference.tex(,6125) rings with global degree orderings and not set for all other rings.
reference.tex(,6126) @c ---------
reference.tex(,6127) @item @code{redThrough}
reference.tex(,6128) @cindex redThrough, option
reference.tex(,6129) for inhomogeneous input, polynomial reductions during standard basis
reference.tex(,6130) computations are never postponed, but always finished through. This option
reference.tex(,6131) is ring   dependent. By default, it is set for rings with global degree
reference.tex(,6132) orderings and not set for all other rings.
reference.tex(,6133) @c ---------
reference.tex(,6134) @item @code{sugarCrit}
reference.tex(,6135) @cindex sugarCrit, option
reference.tex(,6136) uses criteria similar to the homogeneous case to keep more useless pairs.
reference.tex(,6137) @c ---------
reference.tex(,6138) @item @code{weightM}
reference.tex(,6139) @cindex weightM, option
reference.tex(,6140) automatically computes suitable weights for the weighted ecart and the
reference.tex(,6141) weighted sugar method.
reference.tex(,6142) @end table
reference.tex(,6143) @*
reference.tex(,6144) The following options, which also control computations, are special,
reference.tex(,6145) since they are not manipulated by the @code{option} command but by a
reference.tex(,6146) direct assignment of a value. Reset the option by assigning the value 0;
reference.tex(,6147) the command @code{option(none)} will not reset them! If there is a
reference.tex(,6148) non-zero value assigned, the command @code{option()} prints the option.
reference.tex(,6149) @table @asis
reference.tex(,6150) @item @code{multBound}
reference.tex(,6151) a multiplicity bound is set (see @ref{multBound}).
reference.tex(,6152) @item @code{degBound}
reference.tex(,6153) a degree bound is set (see @ref{degBound}).
reference.tex(,6154) @end table
reference.tex(,6155) @*
reference.tex(,6156) The last set of options controls the output of @sc{Singular}:
reference.tex(,6157) @table @asis
reference.tex(,6158) @item @code{Imap}
reference.tex(,6159) @cindex Imap, option
reference.tex(,6160) shows the mapping of variables with the fetch and imap commands.
reference.tex(,6161) @item @code{loadLib}
reference.tex(,6162) @cindex loadLib, option
reference.tex(,6163) shows loading of libraries (set by default).
reference.tex(,6164) @item @code{debugLib}
reference.tex(,6165) @cindex debugLib, option
reference.tex(,6166) warns about syntax errors during loading of libraries.
reference.tex(,6167) @item @code{loadProc}
reference.tex(,6168) @cindex loadProc, option
reference.tex(,6169) shows loading of procedures from libraries.
reference.tex(,6170) @item @code{mem}
reference.tex(,6171) @cindex mem, option
reference.tex(,6172) shows memory usage in square brackets (see @ref{memory}).
reference.tex(,6173) @item @code{prompt}
reference.tex(,6174) @cindex prompt, option
reference.tex(,6175) shows prompt (@code{>}, resp.@: @code{.}) if ready for input (default).
reference.tex(,6176) @item @code{reading}
reference.tex(,6177) @cindex reading, option
reference.tex(,6178) shows the number of characters read from a file.
reference.tex(,6179) @item @code{redefine}
reference.tex(,6180) @cindex redefine, option
reference.tex(,6181) warns about variable redefinitions (set by default).
reference.tex(,6182) @item @code{usage}
reference.tex(,6183) @cindex usage, option
reference.tex(,6184) shows correct usage in error messages (set by default).
reference.tex(,6185) @end table
reference.tex(,6186) @item @strong{Example:}
reference.tex(,6187) @smallexample
reference.tex(,6188) @c reused example option reference.doc:4356 
reference.tex(,6189)   option(prot);
reference.tex(,6190)   option();
reference.tex(,6191) @expansion{} //options: prot redefine usage prompt
reference.tex(,6192)   option(notSugar);
reference.tex(,6193)   option();
reference.tex(,6194) @expansion{} //options: prot notSugar redefine usage prompt
reference.tex(,6195)   option(noprot);
reference.tex(,6196)   option();
reference.tex(,6197) @expansion{} //options: notSugar redefine usage prompt
reference.tex(,6198)   option(none);
reference.tex(,6199)   option();
reference.tex(,6200) @expansion{} //options: none
reference.tex(,6201)   ring r=0,x,dp;
reference.tex(,6202)   degBound=22;
reference.tex(,6203)   option();
reference.tex(,6204) @expansion{} //options: degBound redTail redThrough intStrategy
reference.tex(,6205)   intvec i=option(get);
reference.tex(,6206)   option(none);
reference.tex(,6207)   option(set,i);
reference.tex(,6208)   option();
reference.tex(,6209) @expansion{} //options: degBound redTail redThrough intStrategy
reference.tex(,6210) @c end example option reference.doc:4356
reference.tex(,6211) @end smallexample
reference.tex(,6212) @end table
reference.tex(,6213) 
reference.tex(,6214) @*The output reported on @code{option(prot)} has the following meaning:
reference.tex(,6215) @multitable @columnfractions .01 .14 .11 .65
reference.tex(,6216) 
reference.tex(,6217) @item @tab @code{facstd}
reference.tex(,6218) @tab @code{F} @tab found a new factor
reference.tex(,6219) @item @tab @tab @tab all other characters: like the output of @code{std} and @code{reduce}
reference.tex(,6220) @item @tab @tab @tab
reference.tex(,6221) @item @tab @code{fglm}
reference.tex(,6222) @tab @code{.} @tab basis monomial found
reference.tex(,6223) @item @tab @tab @code{+} @tab edge monomial found
reference.tex(,6224) @item @tab @tab @code{-} @tab border monomial found
reference.tex(,6225) @item @tab @tab @tab
reference.tex(,6226) @item @tab @code{groebner} @tab @tab all characters: like the output of @code{std}
reference.tex(,6227) @item @tab @tab @tab
reference.tex(,6228) @item @tab @code{lres}
reference.tex(,6229) @tab @code{.} @tab minimal syzygy found
reference.tex(,6230) @item @tab @tab @code{n} @tab slanted degree, i.e., row of Betti matrix
reference.tex(,6231) @item @tab @tab @code{(mn)} @tab calculate in module n
reference.tex(,6232) @item @tab @tab @code{g} @tab pair found giving reductum and syzygy
reference.tex(,6233) @item @tab @tab @tab
reference.tex(,6234) @item @tab @code{mres}
reference.tex(,6235) @tab @code{[d]}
reference.tex(,6236) @tab computations of the d-th syzygy module
reference.tex(,6237) @item @tab @tab @tab all other characters: like the output of @code{std}
reference.tex(,6238) @item @tab @tab @tab
reference.tex(,6239) @item @tab @code{minres}
reference.tex(,6240) @tab @code{[d]}
reference.tex(,6241) @tab minimizing of the d-th syzygy module
reference.tex(,6242) @item @tab @tab @tab
reference.tex(,6243) @item @tab @code{mstd} @tab @tab all characters: like the output of @code{std}
reference.tex(,6244) @item @tab @tab @tab
reference.tex(,6245) @item @tab @code{reduce}
reference.tex(,6246) @tab @code{r} @tab reduced a leading term
reference.tex(,6247) @item @tab @tab @code{t} @tab reduced a non-leading term
reference.tex(,6248) @item @tab @code{res}
reference.tex(,6249) @tab @code{[d]}
reference.tex(,6250) @tab computations of the d-th syzygy module
reference.tex(,6251) @item @tab @tab @tab all other characters: like the output of @code{std}
reference.tex(,6252) @item @tab @tab @tab
reference.tex(,6253) @item @tab @code{sres}
reference.tex(,6254) @tab @code{.} @tab syzygy found
reference.tex(,6255) @item @tab @tab @code{(n)} @tab n elements remaining
reference.tex(,6256) @item @tab @tab @code{[n]} @tab finished module n
reference.tex(,6257) @item @tab @tab @tab
reference.tex(,6258) @item @tab @code{std}
reference.tex(,6259) @tab @code{[m:n]}
reference.tex(,6260) @tab internal ring change to poly representation with exponent bound
reference.tex(,6261) m and n words in exponent vector
reference.tex(,6262) @item @tab @tab @code{s} @tab found a new element of the standard basis
reference.tex(,6263) @item @tab @tab @code{-} @tab reduced a pair/S-polynomial to 0
reference.tex(,6264) @item @tab @tab @code{.} @tab postponed a reduction of a pair/S-polynomial
reference.tex(,6265) @item @tab @tab @code{h} @tab used Hilbert series criterion
reference.tex(,6266) @item @tab @tab @code{H(d)} @tab found a 'highest corner' of degree d, no need to consider higher degrees
reference.tex(,6267) @item @tab @tab @code{(n)} @tab n critical pairs are still to be reduced
reference.tex(,6268) @item @tab @tab @code{(S:n)} @tab doing complete reduction of n elements
reference.tex(,6269) @item @tab @tab @code{d} @tab the degree of the leading terms is currently d
reference.tex(,6270) @item @tab @tab @tab
reference.tex(,6271) @item @tab @code{stdfglm} @tab @tab all characters in first part: like the output of @code{std}
reference.tex(,6272) @item @tab @tab @tab all characters in second part: like the output of @code{fglm}
reference.tex(,6273) @item @tab @tab @tab
reference.tex(,6274) @item @tab @code{stdhilb} @tab @tab all characters: like the output of @code{std}
reference.tex(,6275) @item @tab @tab @tab
reference.tex(,6276) @item @tab @code{syz} @tab @tab all characters: like the output of @code{std}
reference.tex(,6277) @end multitable
reference.tex(,6278) 
reference.tex(,6279) 
reference.tex(,6280) @c inserted refs from reference.doc:4442
reference.tex(,6295) @c end inserted refs from reference.doc:4442
reference.tex(,6296) @c ---------------------------------------
reference.tex(,6297) @node ord, ordstr, option, Functions
reference.tex(,6298) @subsection ord
reference.tex(,6299) @cindex ord
reference.tex(,6300) @table @code
reference.tex(,6301) @item @strong{Syntax:}
reference.tex(,6302) @code{ord (} poly_expression @code{)}
reference.tex(,6303) @*@code{ord (} vector_expression @code{)}
reference.tex(,6304) @item @strong{Type:}
reference.tex(,6305) int
reference.tex(,6306) @item @strong{Purpose:}
reference.tex(,6307) returns the (weighted) degree of
reference.tex(,6308) the initial term of a polynomial or a vector;
reference.tex(,6309) the weights are the weights used for the first block of the ring ordering.
reference.tex(,6310) @item @strong{Note:}
reference.tex(,6311) @code{ord(0)} is @code{-1}.
reference.tex(,6312) @item @strong{Example:}
reference.tex(,6313) @smallexample
reference.tex(,6314) @c reused example ord reference.doc:4466 
reference.tex(,6315)   ring r=7,(x,y),wp(2,3);
reference.tex(,6316)   ord(0);
reference.tex(,6317) @expansion{} -1
reference.tex(,6318)   poly f=x2+y3;  // weight on y is 3
reference.tex(,6319)   ord(f);
reference.tex(,6320) @expansion{} 9
reference.tex(,6321)   ring R=7,(x,y),ws(2,3);
reference.tex(,6322)   poly f=x2+y3;
reference.tex(,6323)   ord(f);
reference.tex(,6324) @expansion{} 4
reference.tex(,6325)   vector v=[x2,y];
reference.tex(,6326)   ord(v);
reference.tex(,6327) @expansion{} 3
reference.tex(,6328) @c end example ord reference.doc:4466
reference.tex(,6329) @end smallexample
reference.tex(,6330) @end table
reference.tex(,6331) @c inserted refs from reference.doc:4479
reference.tex(,6346) @c end inserted refs from reference.doc:4479
reference.tex(,6347) @c ---------------------------------------
reference.tex(,6348) @node ordstr, par, ord, Functions
reference.tex(,6349) @subsection ordstr
reference.tex(,6350) @cindex ordstr
reference.tex(,6351) @table @code
reference.tex(,6352) @item @strong{Syntax:}
reference.tex(,6353) @code{ordstr (} ring_name @code{)}
reference.tex(,6354) @item @strong{Type:}
reference.tex(,6355) string
reference.tex(,6356) @item @strong{Purpose:}
reference.tex(,6357) returns the description of the monomial ordering of the ring.
reference.tex(,6358) @item @strong{Example:}
reference.tex(,6359) @smallexample
reference.tex(,6360) @c reused example ordstr reference.doc:4498 
reference.tex(,6361)   ring r=7,(x,y),wp(2,3);
reference.tex(,6362)   ordstr(r);
reference.tex(,6363) @expansion{} wp(2,3),C
reference.tex(,6364) @c end example ordstr reference.doc:4498
reference.tex(,6365) @end smallexample
reference.tex(,6366) @end table
reference.tex(,6367) @c inserted refs from reference.doc:4504
reference.tex(,6384) @c end inserted refs from reference.doc:4504
reference.tex(,6385) @c ---------------------------------------
reference.tex(,6386) @node par, pardeg, ordstr, Functions
reference.tex(,6387) @subsection par
reference.tex(,6388) @cindex par
reference.tex(,6389) @table @code
reference.tex(,6390) @item @strong{Syntax:}
reference.tex(,6391) @code{par (} int_expression @code{)}
reference.tex(,6392) @item @strong{Type:}
reference.tex(,6393) number
reference.tex(,6394) @item @strong{Purpose:}
reference.tex(,6395) @code{par(n);} returns the n-th parameter of the basering.
reference.tex(,6396) @item @strong{Note:}
reference.tex(,6397) This command should only be used if the basering has at least one parameter.
reference.tex(,6398) @item @strong{Example:}
reference.tex(,6399) @smallexample
reference.tex(,6400) @c reused example par reference.doc:4526 
reference.tex(,6401)   ring r=(0,a,b,c),(x,y,z),dp;
reference.tex(,6402)   char(r);  // char to get the characteristic
reference.tex(,6403) @expansion{} 0
reference.tex(,6404)   par(2);   // par to get the n-th parameter
reference.tex(,6405) @expansion{} (b)
reference.tex(,6406) @c end example par reference.doc:4526
reference.tex(,6407) @end smallexample
reference.tex(,6408) @end table
reference.tex(,6409) @c inserted refs from reference.doc:4533
reference.tex(,6428) @c end inserted refs from reference.doc:4533
reference.tex(,6429) @c ---------------------------------------
reference.tex(,6430) @node pardeg, parstr, par, Functions
reference.tex(,6431) @subsection pardeg
reference.tex(,6432) @cindex pardeg
reference.tex(,6433) @table @code
reference.tex(,6434) @item @strong{Syntax:}
reference.tex(,6435) @code{pardeg (} number_expression @code{)}
reference.tex(,6436) @item @strong{Type:}
reference.tex(,6437) int
reference.tex(,6438) @item @strong{Purpose:}
reference.tex(,6439) returns the degree of a number considered as a polynomial in the ring parameters.
reference.tex(,6440) @item @strong{Example:}
reference.tex(,6441) @smallexample
reference.tex(,6442) @c reused example pardeg reference.doc:4554 
reference.tex(,6443)   ring r=(0,a,b,c),(x,y,z),dp;
reference.tex(,6444)   pardeg(a^2*b);
reference.tex(,6445) @expansion{} 3
reference.tex(,6446) @c end example pardeg reference.doc:4554
reference.tex(,6447) @end smallexample
reference.tex(,6448) @end table
reference.tex(,6449) @c inserted refs from reference.doc:4560
reference.tex(,6466) @c end inserted refs from reference.doc:4560
reference.tex(,6467) @c ---------------------------------------
reference.tex(,6468) @node parstr, preimage, pardeg, Functions
reference.tex(,6469) @subsection parstr
reference.tex(,6470) @cindex parstr
reference.tex(,6471) @table @code
reference.tex(,6472) @item @strong{Syntax:}
reference.tex(,6473) @code{parstr (} ring_name @code{)}
reference.tex(,6474) @*@code{parstr (} int_expression @code{)}
reference.tex(,6475) @*@code{parstr (} ring_name@code{,} int_expression @code{)}
reference.tex(,6476) @item @strong{Type:}
reference.tex(,6477) string
reference.tex(,6478) @item @strong{Purpose:}
reference.tex(,6479) returns the list of parameters of the ring as a string
reference.tex(,6480) or the name of the n-th parameter where n is given by the int_expression.
reference.tex(,6481) @*If the ring_name is omitted, the basering is used, thus
reference.tex(,6482) @code{parstr(n)} is equivalent to @code{parstr(basering,n)}.
reference.tex(,6483) @item @strong{Example:}
reference.tex(,6484) @smallexample
reference.tex(,6485) @c reused example parstr reference.doc:4585 
reference.tex(,6486)   ring r=(7,a,b,c),(x,y),wp(2,3);
reference.tex(,6487)   parstr(r);
reference.tex(,6488) @expansion{} a,b,c
reference.tex(,6489)   parstr(2);
reference.tex(,6490) @expansion{} b
reference.tex(,6491)   parstr(r,3);
reference.tex(,6492) @expansion{} c
reference.tex(,6493) @c end example parstr reference.doc:4585
reference.tex(,6494) @end smallexample
reference.tex(,6495) @end table
reference.tex(,6496) @c inserted refs from reference.doc:4593
reference.tex(,6517) @c end inserted refs from reference.doc:4593
reference.tex(,6518) @c ---------------------------------------
reference.tex(,6519) @node preimage, prime, parstr, Functions
reference.tex(,6520) @subsection preimage
reference.tex(,6521) @cindex preimage
reference.tex(,6522) @cindex kernel
reference.tex(,6523) 
reference.tex(,6524) @table @code
reference.tex(,6525) @item @strong{Syntax:}
reference.tex(,6526) @code{preimage (} ring_name@code{,} map_name@code{,} ideal_name @code{)}
reference.tex(,6527) @*@code{preimage (} ring_name@code{,} ideal_expression@code{,} ideal_name @code{)}
reference.tex(,6528) @item @strong{Type:}
reference.tex(,6529) ideal
reference.tex(,6530) @item @strong{Purpose:}
reference.tex(,6531) returns the preimage of an ideal under a given map.
reference.tex(,6532) @*
reference.tex(,6533) The second argument has to be a map from the basering to the given ring
reference.tex(,6534) (or an ideal defining such a map),
reference.tex(,6535) and the ideal has to be an ideal in the given ring.
reference.tex(,6536) @item @strong{Note:}
reference.tex(,6537) To compute the kernel of a map, the preimage of zero has to be determined.
reference.tex(,6538) Hence there is no special command for computing the kernel of a map in
reference.tex(,6539) @sc{Singular}.
reference.tex(,6540) @item @strong{Example:}
reference.tex(,6541) @smallexample
reference.tex(,6542) @c reused example preimage reference.doc:4626 
reference.tex(,6543)   ring r1=32003,(x,y,z,w),lp;
reference.tex(,6544)   ring r=32003,(x,y,z),dp;
reference.tex(,6545)   ideal i=x,y,z;
reference.tex(,6546)   ideal i1=x,y;
reference.tex(,6547)   ideal i0=0;
reference.tex(,6548)   map f=r1,i;
reference.tex(,6549)   setring r1;
reference.tex(,6550)   ideal i1=preimage(r,f,i1);
reference.tex(,6551)   i1;
reference.tex(,6552) @expansion{} i1[1]=w
reference.tex(,6553) @expansion{} i1[2]=y
reference.tex(,6554) @expansion{} i1[3]=x
reference.tex(,6555)   // the kernel of f
reference.tex(,6556)   preimage(r,f,i0);
reference.tex(,6557) @expansion{} _[1]=w
reference.tex(,6558) @c end example preimage reference.doc:4626
reference.tex(,6559) @end smallexample
reference.tex(,6560) @end table
reference.tex(,6561) @c inserted refs from reference.doc:4641
reference.tex(,6576) @c end inserted refs from reference.doc:4641
reference.tex(,6577) @c ---------------------------------------
reference.tex(,6578) @node prime, print, preimage, Functions
reference.tex(,6579) @subsection prime
reference.tex(,6580) @cindex prime
reference.tex(,6581) @table @code
reference.tex(,6582) @item @strong{Syntax:}
reference.tex(,6583) @code{prime (} int_expression @code{)}
reference.tex(,6584) @item @strong{Type:}
reference.tex(,6585) int
reference.tex(,6586) @item @strong{Purpose:}
reference.tex(,6587) returns the largest prime less then 32004 smaller or equal to the argument;
reference.tex(,6588) @*returns 2 for all arguments smaller than 3.
reference.tex(,6589) @item @strong{Example:}
reference.tex(,6590) @smallexample
reference.tex(,6591) @c reused example prime reference.doc:4661 
reference.tex(,6592)   prime(32004);
reference.tex(,6593) @expansion{} 32003
reference.tex(,6594)   prime(0);
reference.tex(,6595) @expansion{} 2
reference.tex(,6596)   prime(-1);
reference.tex(,6597) @expansion{} 2
reference.tex(,6598) @c end example prime reference.doc:4661
reference.tex(,6599) @end smallexample
reference.tex(,6600) @end table
reference.tex(,6601) @c inserted refs from reference.doc:4668
reference.tex(,6614) @c end inserted refs from reference.doc:4668
reference.tex(,6615) @c ---------------------------------------
reference.tex(,6616) @node print, printf, prime, Functions
reference.tex(,6617) @subsection print
reference.tex(,6618) @cindex print
reference.tex(,6619) @table @code
reference.tex(,6620) @item @strong{Syntax:}
reference.tex(,6621) @code{print (} expression @code{)}
reference.tex(,6622) @*@code{print (} expression@code{, "betti" )}
reference.tex(,6623) @*@code{print (} expression@code{,} format_string @code{)}
reference.tex(,6624) @item @strong{Type:}
reference.tex(,6625) none (for the first two calling sequences), resp.@:
reference.tex(,6626) @*string (for the last calling sequence)
reference.tex(,6627) @item @strong{Purpose:}
reference.tex(,6628) The first form prints the expression to the terminal and has no return
reference.tex(,6629) value. Use the format string @code{%p} to print into a string (see
reference.tex(,6630) below).
reference.tex(,6631) @*The second form prints the graded Betti numbers from a matrix. See
reference.tex(,6632) the description of the format string @code{"betti"} below for more
reference.tex(,6633) details.
reference.tex(,6634) @*The last form returns the printed output as a string. The format
reference.tex(,6635) string determines which format to use to generate the string.
reference.tex(,6636) 
reference.tex(,6637) The following format strings are supported:
reference.tex(,6638) @table @code
reference.tex(,6639) @item "betti"
reference.tex(,6640) The Betti numbers are printed in a matrix-like format where the entry
reference.tex(,6647) is the minimal number of generators in
reference.tex(,6648) degree
reference.tex(,6655)  syzygy module of
reference.tex(,6662) @item "%s"
reference.tex(,6663) returns @code{string(} expression @code{)}
reference.tex(,6664) @item "%2s"
reference.tex(,6665) similar to @code{"%s"}, except that newlines are inserted after every
reference.tex(,6666) comma and at the end
reference.tex(,6667) @item "%l"
reference.tex(,6668) similar to @code{"%s"}, except that each object is embraced by its type
reference.tex(,6669) such that it can be directly used for "cutting and pasting"
reference.tex(,6670) @item "%2l"
reference.tex(,6671) similar to @code{"%l"}, except that newlines are inserted after every
reference.tex(,6672) comma and at the end
reference.tex(,6673) @item "%;"
reference.tex(,6674) returns the string equivalent to typing @code{expression;}
reference.tex(,6675) @item "%t"
reference.tex(,6676) returns the string equivalent to typing @code{type expression;}
reference.tex(,6677) @item "%p"
reference.tex(,6678) returns the string equivalent to typing @code{print(expression);}
reference.tex(,6679) @item "%b"
reference.tex(,6680) returns the string equivalent to typing @code{print(expression, "betti");}
reference.tex(,6681) @end table
reference.tex(,6682) @item @strong{Example:}
reference.tex(,6683) @smallexample
reference.tex(,6684) @c reused example print reference.doc:4742 
reference.tex(,6685)   ring r=0,(x,y,z),dp;
reference.tex(,6686)   module m=[1,y],[0,x+z];
reference.tex(,6687)   m;
reference.tex(,6688) @expansion{} m[1]=y*gen(2)+gen(1)
reference.tex(,6689) @expansion{} m[2]=x*gen(2)+z*gen(2)
reference.tex(,6690)   print(m);  // the columns generate m
reference.tex(,6691) @expansion{} 1,0, 
reference.tex(,6692) @expansion{} y,x+z
reference.tex(,6693)   string s=print(m,"%s"); s;
reference.tex(,6694) @expansion{} y*gen(2)+gen(1),x*gen(2)+z*gen(2)
reference.tex(,6695)   s=print(m,"%2s"); s;
reference.tex(,6696) @expansion{} y*gen(2)+gen(1),
reference.tex(,6697) @expansion{} x*gen(2)+z*gen(2)
reference.tex(,6698) @expansion{} 
reference.tex(,6699)   s=print(m,"%l"); s;
reference.tex(,6700) @expansion{} module(y*gen(2)+gen(1),x*gen(2)+z*gen(2))
reference.tex(,6701)   s=print(m,"%;"); s;
reference.tex(,6702) @expansion{} m[1]=y*gen(2)+gen(1)
reference.tex(,6703) @expansion{} m[2]=x*gen(2)+z*gen(2)
reference.tex(,6704) @expansion{} 
reference.tex(,6705)   s=print(m,"%t"); s;
reference.tex(,6706) @expansion{} // m                    [0]  module, rk 2, 2 generator(s)
reference.tex(,6707) @expansion{} m[1]=y*gen(2)+gen(1)
reference.tex(,6708) @expansion{} m[2]=x*gen(2)+z*gen(2)
reference.tex(,6709)   s=print(m,"%p"); s;
reference.tex(,6710) @expansion{} 1,0, 
reference.tex(,6711) @expansion{} y,x+z
reference.tex(,6712) @expansion{} 
reference.tex(,6713)   intmat M=betti(mres(m,0));
reference.tex(,6714)   print(M,"betti");
reference.tex(,6715) @expansion{}            0     1
reference.tex(,6716) @expansion{} ------------------
reference.tex(,6717) @expansion{}     0:     1     1
reference.tex(,6718) @expansion{} ------------------
reference.tex(,6719) @expansion{} total:     1     1
reference.tex(,6720)   list l=r,M;
reference.tex(,6721)   s=print(l,"%s"); s;
reference.tex(,6722) @expansion{} (0),(x,y,z),(dp(3),C),1,1 
reference.tex(,6723)   s=print(l,"%2s"); s;
reference.tex(,6724) @expansion{} (0),(x,y,z),(dp(3),C),
reference.tex(,6725) @expansion{} 1,1 
reference.tex(,6726) @expansion{} 
reference.tex(,6727)   s=print(l,"%l"); s;
reference.tex(,6728) @expansion{} list("(0),(x,y,z),(dp(3),C)",intmat(intvec(1,1 ),1,2))
reference.tex(,6729) @c end example print reference.doc:4742
reference.tex(,6730) @end smallexample
reference.tex(,6731) @end table
reference.tex(,6732) @c inserted refs from reference.doc:4762
reference.tex(,6759) @c end inserted refs from reference.doc:4762
reference.tex(,6760) 
reference.tex(,6761) @c ---------------------------------------
reference.tex(,6762) @node printf, prune, print, Functions
reference.tex(,6763) @subsection printf
reference.tex(,6764) @cindex printf
reference.tex(,6765) @c start include of docu for standard.lib:printf
reference.tex(,6766) @c replaced @subsubsection by @sub
reference.tex(,6767) @c ---content printf---
reference.tex(,6768) Procedure from library @code{standard.lib} (@pxref{standard_lib}).
reference.tex(,6769) 
reference.tex(,6770) @table @asis
reference.tex(,6771) @item @strong{Syntax:}
reference.tex(,6772) @code{printf (} string_expression @code{[,} any_expressions@code{] )}
reference.tex(,6773) 
reference.tex(,6774) @item @strong{Return:}
reference.tex(,6775) none
reference.tex(,6776) 
reference.tex(,6777) @item @strong{Purpose:}
reference.tex(,6778) @code{printf(fmt,...);} performs output formatting. The first
reference.tex(,6779) argument is a format control string. Additional arguments may be
reference.tex(,6780) required, depending on the content of the control string. A series
reference.tex(,6781) of output characters is generated as directed by the control string;
reference.tex(,6782) these characters are displayed (i.e., printed to standard out). @*
reference.tex(,6783) The control string @code{fmt} is simply text to be copied, except
reference.tex(,6784) that the string may contain conversion specifications. @*
reference.tex(,6785) Do @code{help print;} for a listing of valid conversion
reference.tex(,6786) specifications. As an addition to the conversions of @code{print},
reference.tex(,6787) the @code{%n} and @code{%2} conversion specification does not
reference.tex(,6788) consume an additional argument, but simply generates a newline
reference.tex(,6789) character.
reference.tex(,6790) 
reference.tex(,6791) @item @strong{Note:}
reference.tex(,6792) If one of the additional arguments is a list, then it should be
reference.tex(,6793) enclosed once more into a @code{list()} command, since passing a
reference.tex(,6794) list as an argument flattens the list by one level.
reference.tex(,6795) 
reference.tex(,6796) @end table
reference.tex(,6797) @strong{Example:}
reference.tex(,6798) @smallexample
reference.tex(,6799) @c reused example printf d2t_singular/standard_lib.doc:450 
reference.tex(,6800)   ring r=0,(x,y,z),dp;
reference.tex(,6801) module m=[1,y],[0,x+z];
reference.tex(,6802) intmat M=betti(mres(m,0));
reference.tex(,6803) list l=r,m,M;
reference.tex(,6804) printf("s:%s,l:%l",1,2);
reference.tex(,6805) @expansion{} s:1,l:int(2)
reference.tex(,6806) printf("s:%s",l);
reference.tex(,6807) @expansion{} s:(0),(x,y,z),(dp(3),C)
reference.tex(,6808) printf("s:%s",list(l));
reference.tex(,6809) @expansion{} s:(0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
reference.tex(,6810) printf("2l:%2l",list(l));
reference.tex(,6811) @expansion{} 2l:list("(0),(x,y,z),(dp(3),C)",
reference.tex(,6812) @expansion{} module(y*gen(2)+gen(1),
reference.tex(,6813) @expansion{} x*gen(2)+z*gen(2)),
reference.tex(,6814) @expansion{} intmat(intvec(1,1 ),1,2))
reference.tex(,6815) @expansion{} 
reference.tex(,6816) printf("%p",list(l));
reference.tex(,6817) @expansion{} [1]:
reference.tex(,6818) @expansion{}    //   characteristic : 0
reference.tex(,6819) @expansion{} //   number of vars : 3
reference.tex(,6820) @expansion{} //        block   1 : ordering dp
reference.tex(,6821) @expansion{} //                  : names    x y z 
reference.tex(,6822) @expansion{} //        block   2 : ordering C
reference.tex(,6823) @expansion{} [2]:
reference.tex(,6824) @expansion{}    _[1]=y*gen(2)+gen(1)
reference.tex(,6825) @expansion{}    _[2]=x*gen(2)+z*gen(2)
reference.tex(,6826) @expansion{} [3]:
reference.tex(,6827) @expansion{}    1,1 
reference.tex(,6828) @expansion{} 
reference.tex(,6829) printf("%;",list(l));
reference.tex(,6830) @expansion{} [1]:
reference.tex(,6831) @expansion{}    //   characteristic : 0
reference.tex(,6832) @expansion{} //   number of vars : 3
reference.tex(,6833) @expansion{} //        block   1 : ordering dp
reference.tex(,6834) @expansion{} //                  : names    x y z 
reference.tex(,6835) @expansion{} //        block   2 : ordering C
reference.tex(,6836) @expansion{} [2]:
reference.tex(,6837) @expansion{}    _[1]=y*gen(2)+gen(1)
reference.tex(,6838) @expansion{}    _[2]=x*gen(2)+z*gen(2)
reference.tex(,6839) @expansion{} [3]:
reference.tex(,6840) @expansion{}    1,1 
reference.tex(,6841) @expansion{} 
reference.tex(,6842) printf("%b",M);
reference.tex(,6843) @expansion{}            0     1
reference.tex(,6844) @expansion{} ------------------
reference.tex(,6845) @expansion{}     0:     1     1
reference.tex(,6846) @expansion{} ------------------
reference.tex(,6847) @expansion{} total:     1     1
reference.tex(,6848) @expansion{} 
reference.tex(,6849) @c end example printf d2t_singular/standard_lib.doc:450
reference.tex(,6850) @end smallexample
reference.tex(,6851) @c inserted refs from d2t_singular/standard_lib.doc:464
reference.tex(,6868) @c end inserted refs from d2t_singular/standard_lib.doc:464
reference.tex(,6869) 
reference.tex(,6870) @c ---end content printf---
reference.tex(,6871) @c generated lib proc docu for standard.lib:printf reference.doc:4779 
reference.tex(,6872) @c end include of docu for standard.lib:printf
reference.tex(,6873) 
reference.tex(,6874) @c ---------------------------------------
reference.tex(,6875) @node prune, qhweight, printf, Functions
reference.tex(,6876) @subsection prune
reference.tex(,6877) @cindex prune
reference.tex(,6878) @table @code
reference.tex(,6879) @item @strong{Syntax:}
reference.tex(,6880) @code{prune (} module_expression @code{)}
reference.tex(,6881) @item @strong{Type:}
reference.tex(,6882) module
reference.tex(,6883) @item @strong{Purpose:}
reference.tex(,6884) returns the module minimally embedded in a free module such that the
reference.tex(,6885) corresponding factor modules are isomorphic.
reference.tex(,6886) @item @strong{Example:}
reference.tex(,6887) @smallexample
reference.tex(,6888) @c reused example prune reference.doc:4795 
reference.tex(,6889)   ring r=0,(x,y,z),dp;
reference.tex(,6890)   module m=gen(1),gen(3),[x,y,0,z],[x+y,0,0,0,1];
reference.tex(,6891)   print(m);
reference.tex(,6892) @expansion{} 1,0,x,x+y,
reference.tex(,6893) @expansion{} 0,0,y,0,  
reference.tex(,6894) @expansion{} 0,1,0,0,  
reference.tex(,6895) @expansion{} 0,0,z,0,  
reference.tex(,6896) @expansion{} 0,0,0,1   
reference.tex(,6897)   print(prune(m));
reference.tex(,6898) @expansion{} y,
reference.tex(,6899) @expansion{} z 
reference.tex(,6900) @c end example prune reference.doc:4795
reference.tex(,6901) @end smallexample
reference.tex(,6902) @end table
reference.tex(,6903) @c inserted refs from reference.doc:4803
reference.tex(,6914) @c end inserted refs from reference.doc:4803
reference.tex(,6915) @c ---------------------------------------
reference.tex(,6916) @node qhweight, quot, prune, Functions
reference.tex(,6917) @subsection qhweight
reference.tex(,6918) @cindex qhweight
reference.tex(,6919) @table @code
reference.tex(,6920) @item @strong{Syntax:}
reference.tex(,6921) @code{qhweight (} ideal_expression @code{)}
reference.tex(,6922) @item @strong{Type:}
reference.tex(,6923) intvec
reference.tex(,6924) @item @strong{Purpose:}
reference.tex(,6925) computes the weight vector of the variables for a quasihomogeneous ideal.
reference.tex(,6926) If the input is not weighted homogeneous, an intvec of zeros is returned.
reference.tex(,6927) @item @strong{Example:}
reference.tex(,6928) @smallexample
reference.tex(,6929) @c reused example qhweight reference.doc:4821 
reference.tex(,6930)   ring h1=32003,(t,x,y,z),dp;
reference.tex(,6931)   ideal i=x4+y3+z2;
reference.tex(,6932)   qhweight(i);
reference.tex(,6933) @expansion{} 0,3,4,6
reference.tex(,6934) @c end example qhweight reference.doc:4821
reference.tex(,6935) @end smallexample
reference.tex(,6936) @end table
reference.tex(,6937) @c inserted refs from reference.doc:4828
reference.tex(,6952) @c end inserted refs from reference.doc:4828
reference.tex(,6953) 
reference.tex(,6954) @c ---------------------------------------
reference.tex(,6955) @node quot, quote, qhweight, Functions
reference.tex(,6956) @subsection quot
reference.tex(,6957) @cindex quot
reference.tex(,6958) @c start include of docu for standard.lib:quot
reference.tex(,6959) @c replaced @subsubsection by @sub
reference.tex(,6960) @c ---content quot---
reference.tex(,6961) Procedure from library @code{standard.lib} (@pxref{standard_lib}).
reference.tex(,6962) 
reference.tex(,6963) @table @asis
reference.tex(,6964) @item @strong{Syntax:}
reference.tex(,6965) @code{quot (} module_expression@code{,} module_expression @code{)}
reference.tex(,6966) @*@code{quot (} module_expression@code{,} module_expression@code{,}
reference.tex(,6967) int_expression @code{)}
reference.tex(,6968) @*@code{quot (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,6969) @*@code{quot (} ideal_expression@code{,} ideal_expression@code{,}
reference.tex(,6970) int_expression @code{)}
reference.tex(,6971) 
reference.tex(,6972) @item @strong{Type:}
reference.tex(,6973) ideal
reference.tex(,6974) 
reference.tex(,6975) @item @strong{Syntax:}
reference.tex(,6976) @code{quot (} module_expression@code{,} ideal_expression @code{)}
reference.tex(,6977) 
reference.tex(,6978) @item @strong{Type:}
reference.tex(,6979) module
reference.tex(,6980) 
reference.tex(,6981) @item @strong{Purpose:}
reference.tex(,6982) computes the quotient of the 1st and the 2nd argument.
reference.tex(,6983) If a 3rd argument 'n' is given the n-th method is used
reference.tex(,6984) (n=1...5).
reference.tex(,6985) 
reference.tex(,6986) @end table
reference.tex(,6987) @strong{Example:}
reference.tex(,6988) @smallexample
reference.tex(,6989) @c reused example quot d2t_singular/standard_lib.doc:202 
reference.tex(,6990)   ring r=181,(x,y,z),(c,ls);
reference.tex(,6991) ideal id1=maxideal(4);
reference.tex(,6992) ideal id2=x2+xyz,y2-z3y,z3+y5xz;
reference.tex(,6993) option(prot);
reference.tex(,6994) ideal id3=quotient(id1,id2);
reference.tex(,6995) @expansion{} [1023:1]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
reference.tex(,6996) @expansion{} product criterion:12 chain criterion:0
reference.tex(,6997) @expansion{} @{3@}[1023:3]8(2)s(4)s(5)s9s.s.s.s.s.s
reference.tex(,6998) @expansion{} product criterion:0 chain criterion:39
reference.tex(,6999) id3;
reference.tex(,7000) @expansion{} id3[1]=z2
reference.tex(,7001) @expansion{} id3[2]=yz
reference.tex(,7002) @expansion{} id3[3]=y2
reference.tex(,7003) @expansion{} id3[4]=xz
reference.tex(,7004) @expansion{} id3[5]=xy
reference.tex(,7005) @expansion{} id3[6]=x2
reference.tex(,7006) ideal id4=quot(id1,id2,1);
reference.tex(,7007) @expansion{} [1023:2]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
reference.tex(,7008) @expansion{} product criterion:0 chain criterion:0
reference.tex(,7009) @expansion{} (S:3)rtrtrt
reference.tex(,7010) @expansion{} @{1@}[1023:3]4(2)s(4)s(5)s5s.s(3)s(2)sss
reference.tex(,7011) @expansion{} product criterion:0 chain criterion:39
reference.tex(,7012) @expansion{} @{1@}[1023:3]4(5)s(4)s(3)s(2)sss
reference.tex(,7013) @expansion{} product criterion:0 chain criterion:9
reference.tex(,7014) @expansion{} [255:3]3(11)s(10)sss(9)s(10)s(8)ss(7)s(8)s(6)s(7)s4(5)-----
reference.tex(,7015) @expansion{} product criterion:12 chain criterion:9
reference.tex(,7016) @expansion{} @{1@}[1023:3]4(2)sss
reference.tex(,7017) @expansion{} product criterion:0 chain criterion:12
reference.tex(,7018) @expansion{} [255:3]2(8)s(7)s(6)s3(5)ssssss4-----
reference.tex(,7019) @expansion{} product criterion:15 chain criterion:3
reference.tex(,7020) id4;
reference.tex(,7021) @expansion{} id4[1]=z2
reference.tex(,7022) @expansion{} id4[2]=yz
reference.tex(,7023) @expansion{} id4[3]=xz
reference.tex(,7024) @expansion{} id4[4]=y2
reference.tex(,7025) @expansion{} id4[5]=xy
reference.tex(,7026) @expansion{} id4[6]=x2
reference.tex(,7027) ideal id5=quot(id1,id2,2);
reference.tex(,7028) @expansion{} [1023:2]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
reference.tex(,7029) @expansion{} product criterion:0 chain criterion:0
reference.tex(,7030) @expansion{} (S:3)rtrtrt
reference.tex(,7031) @expansion{} @{1@}[1023:3]4(2)sss
reference.tex(,7032) @expansion{} product criterion:0 chain criterion:12
reference.tex(,7033) @expansion{} @{1@}[1023:3]4(5)s(4)s(3)s(2)sss
reference.tex(,7034) @expansion{} product criterion:0 chain criterion:9
reference.tex(,7035) @expansion{} [255:3]2(8)s(7)s(6)s3(5)s(4)s(3)s(2)sss
reference.tex(,7036) @expansion{} product criterion:15 chain criterion:0
reference.tex(,7037) id5;
reference.tex(,7038) @expansion{} id5[1]=z2
reference.tex(,7039) @expansion{} id5[2]=yz
reference.tex(,7040) @expansion{} id5[3]=xz
reference.tex(,7041) @expansion{} id5[4]=y2
reference.tex(,7042) @expansion{} id5[5]=xy
reference.tex(,7043) @expansion{} id5[6]=x2
reference.tex(,7044) @c end example quot d2t_singular/standard_lib.doc:202
reference.tex(,7045) @end smallexample
reference.tex(,7046) @c inserted refs from d2t_singular/standard_lib.doc:215
reference.tex(,7057) @c end inserted refs from d2t_singular/standard_lib.doc:215
reference.tex(,7058) 
reference.tex(,7059) @c ---end content quot---
reference.tex(,7060) @c generated lib proc docu for standard.lib:quot reference.doc:4839 
reference.tex(,7061) @c end include of docu for standard.lib:quot
reference.tex(,7062) 
reference.tex(,7063) 
reference.tex(,7064) @c ---------------------------------------
reference.tex(,7065) @node quote, quotient, quot, Functions
reference.tex(,7066) @subsection quote
reference.tex(,7067) @cindex quote
reference.tex(,7068) @table @code
reference.tex(,7069) @item @strong{Syntax:}
reference.tex(,7070) @code{quote (} expression @code{)}
reference.tex(,7071) @item @strong{Type:}
reference.tex(,7072) none
reference.tex(,7073) @item @strong{Purpose:}
reference.tex(,7074) prevents expressions from evaluation. Used only in connections with write to
reference.tex(,7075) MPfile links, prevents evaluation of an expression before sending it to an other
reference.tex(,7076) @sc{Singular} process.
reference.tex(,7077) Within a quoted expression, the
reference.tex(,7078) quote can be "undone" by an @code{eval} (i.e., each eval "undoes" the
reference.tex(,7079) effect of exactly one quote).
reference.tex(,7080) @item @strong{Example:}
reference.tex(,7081) @smallexample
reference.tex(,7082) @c reused example quote reference.doc:4860 
reference.tex(,7083)   link l="MPfile:w example.mp";
reference.tex(,7084)   ring r=0,(x,y,z),ds;
reference.tex(,7085)   ideal i=maxideal(3);
reference.tex(,7086)   ideal j=x7,x2,z;
reference.tex(,7087)   option(prot);
reference.tex(,7088)   // compute i+j before writing, but not std
reference.tex(,7089)   write (l, quote(std(eval(i+j))));
reference.tex(,7090)   close(l);
reference.tex(,7091)   // now read it in again and evaluate:
reference.tex(,7092)   read(l);
reference.tex(,7093) @expansion{} [1023:1]1(12)s2(11)s3(10)--s(7)s(6)-----7-
reference.tex(,7094) @expansion{} product criterion:4 chain criterion:0
reference.tex(,7095) @expansion{} _[1]=z
reference.tex(,7096) @expansion{} _[2]=x2
reference.tex(,7097) @expansion{} _[3]=xy2
reference.tex(,7098) @expansion{} _[4]=y3
reference.tex(,7099)   close(l);
reference.tex(,7100) @c end example quote reference.doc:4860
reference.tex(,7101) @end smallexample
reference.tex(,7102) @end table
reference.tex(,7103) @c inserted refs from reference.doc:4875
reference.tex(,7118) @c end inserted refs from reference.doc:4875
reference.tex(,7119) @c ---------------------------------------
reference.tex(,7120) @node quotient, random, quote, Functions
reference.tex(,7121) @subsection quotient
reference.tex(,7122) @cindex quotient
reference.tex(,7123) @table @code
reference.tex(,7124) @item @strong{Syntax:}
reference.tex(,7125) @code{quotient (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,7126) @*@code{quotient (} module_expression@code{,} module_expression @code{)}
reference.tex(,7127) @item @strong{Type:}
reference.tex(,7128) ideal
reference.tex(,7129) @item @strong{Syntax:}
reference.tex(,7130) @code{quotient (} module_expression@code{,} ideal_expression @code{)}
reference.tex(,7131) @item @strong{Type:}
reference.tex(,7132) module
reference.tex(,7133) @item @strong{Purpose:}
reference.tex(,7134) computes the ideal quotient, resp.@: module quotient. Let @code{R} be the
reference.tex(,7135) basering, @code{I,J} ideals and @code{M} a module in
reference.tex(,7142) Then
reference.tex(,7143) @itemize
reference.tex(,7144) @item
reference.tex(,7145) @code{quotient(I,J)}=
reference.tex(,7152) @item
reference.tex(,7153) @code{quotient(M,J)}=
reference.tex(,7160) @end itemize
reference.tex(,7161) @item @strong{Example:}
reference.tex(,7162) @smallexample
reference.tex(,7163) @c reused example quotient reference.doc:4925 
reference.tex(,7164) ring r=181,(x,y,z),(c,ls);
reference.tex(,7165) ideal id1=maxideal(3);
reference.tex(,7166) ideal id2=x2+xyz,y2-z3y,z3+y5xz;
reference.tex(,7167) ideal id6=quotient(id1,id2);
reference.tex(,7168) id6;
reference.tex(,7169) @expansion{} id6[1]=z
reference.tex(,7170) @expansion{} id6[2]=y
reference.tex(,7171) @expansion{} id6[3]=x
reference.tex(,7172) quotient(id2,id1);
reference.tex(,7173) @expansion{} _[1]=z2
reference.tex(,7174) @expansion{} _[2]=yz
reference.tex(,7175) @expansion{} _[3]=y2
reference.tex(,7176) @expansion{} _[4]=xz
reference.tex(,7177) @expansion{} _[5]=xy
reference.tex(,7178) @expansion{} _[6]=x2
reference.tex(,7179) module m=x*freemodule(3),y*freemodule(2);
reference.tex(,7180) ideal id3=x,y;
reference.tex(,7181) quotient(m,id3);
reference.tex(,7182) @expansion{} _[1]=[1]
reference.tex(,7183) @expansion{} _[2]=[0,1]
reference.tex(,7184) @expansion{} _[3]=[0,0,x]
reference.tex(,7185) @c end example quotient reference.doc:4925
reference.tex(,7186) @end smallexample
reference.tex(,7187) @end table
reference.tex(,7188) @c inserted refs from reference.doc:4938
reference.tex(,7203) @c end inserted refs from reference.doc:4938
reference.tex(,7204) @c ---------------------------------------
reference.tex(,7205) @node random, read, quotient, Functions
reference.tex(,7206) @subsection random
reference.tex(,7207) @cindex random
reference.tex(,7208) @table @code
reference.tex(,7209) @item @strong{Syntax:}
reference.tex(,7210) @code{random (} int_expression@code{,} int_expression @code{)}
reference.tex(,7211) @item @strong{Type:}
reference.tex(,7212) int
reference.tex(,7213) @item @strong{Purpose:}
reference.tex(,7214) returns a random integer between the integer given by the first
reference.tex(,7215) int_expression and the one given by the second int_expression.
reference.tex(,7216) @*
reference.tex(,7217) @item @strong{Syntax:}
reference.tex(,7218) @code{random (} int_expression@code{,} int_expression@code{,} int_expression @code{)}
reference.tex(,7219) @item @strong{Type:}
reference.tex(,7220) intmat
reference.tex(,7221) @item @strong{Purpose:}
reference.tex(,7222) returns a random intmat where the size is given by the second (number of
reference.tex(,7223) rows) and third argument (number of columns). The absolute value of the
reference.tex(,7224) entries of the matrix is smaller than or equal to the integer given as
reference.tex(,7225) the first argument.
reference.tex(,7226) @item @strong{Note:}
reference.tex(,7227) The random generator can be set to a start value with
reference.tex(,7228) the function @code{system}, resp.@: by a command line option.
reference.tex(,7229) @item @strong{Example:}
reference.tex(,7230) @smallexample
reference.tex(,7231) @c reused example random reference.doc:4971 
reference.tex(,7232)   random(1,1000);
reference.tex(,7233) @expansion{} 35
reference.tex(,7234)   random(1,2,3);
reference.tex(,7235) @expansion{} 0,0,0,
reference.tex(,7236) @expansion{} 1,1,-1 
reference.tex(,7237)   system("random",210);  // start random generator with 210
reference.tex(,7238)   random(-1000,1000);
reference.tex(,7239) @expansion{} 707
reference.tex(,7240)   random(-1000,1000);
reference.tex(,7241) @expansion{} 284
reference.tex(,7242)   system("random",210);
reference.tex(,7243)   random(-1000,1000);    // the same random values again
reference.tex(,7244) @expansion{} 707
reference.tex(,7245) @c end example random reference.doc:4971
reference.tex(,7246) @end smallexample
reference.tex(,7247) @end table
reference.tex(,7248) @c inserted refs from reference.doc:4982
reference.tex(,7265) @c end inserted refs from reference.doc:4982
reference.tex(,7266) @c ---------------------------------------
reference.tex(,7267) @node read, reduce, random, Functions
reference.tex(,7268) @subsection read
reference.tex(,7269) @cindex read
reference.tex(,7270) @table @code
reference.tex(,7271) @item @strong{Syntax:}
reference.tex(,7272) @code{read (} link_expression @code{)}
reference.tex(,7273) @*for DBM links:
reference.tex(,7274) @*@code{read (} link_expression @code{)}
reference.tex(,7275) @*@code{read (} link_expression@code{,} string_expression @code{)}
reference.tex(,7276) @item @strong{Type:}
reference.tex(,7277) any
reference.tex(,7278) @item @strong{Purpose:}
reference.tex(,7279) reads data from a link.
reference.tex(,7280) @*For ASCII links, the content of the entire
reference.tex(,7281) file is returned as one string. If the ASCII link is the empty string,
reference.tex(,7282) @code{read} reads from standard input.
reference.tex(,7283) @*For MP links, one expression is read
reference.tex(,7284) from the link and returned after evaluation.
reference.tex(,7285) @*For MPtcp links the @code{read} command blocks as long as there is no
reference.tex(,7286) data to be read from the link. The @code{status} command can be used to
reference.tex(,7287) check whether or not there is data to be read.
reference.tex(,7288) @*For DBM links, a @code{read} with one argument returns the value of
reference.tex(,7289) the next entry in the data base, and a @code{read} with two arguments
reference.tex(,7290) returns the value to the key given as the second argument from the data
reference.tex(,7291) base.
reference.tex(,7292) @item @strong{Example:}
reference.tex(,7293) @smallexample
reference.tex(,7294) @c reused example read reference.doc:5017 
reference.tex(,7295)   ring r=32003,(x,y,z),dp;
reference.tex(,7296)   ideal i=x+y,z3+22y;
reference.tex(,7297)   // write the ideal i to the file save_i
reference.tex(,7298)   write(":w save_i",i);
reference.tex(,7299)   ring r0=0,(x,y,z),Dp;
reference.tex(,7300)   // create an ideal k equal to the content
reference.tex(,7301)   // of the file save_i
reference.tex(,7302)   string s="ideal k="+read("save_i")+";";
reference.tex(,7303)   execute(s);
reference.tex(,7304)   k;
reference.tex(,7305) @expansion{} k[1]=x+y
reference.tex(,7306) @expansion{} k[2]=z3+22y
reference.tex(,7307) @c end example read reference.doc:5017
reference.tex(,7308) @end smallexample
reference.tex(,7309) @end table
reference.tex(,7310) @c inserted refs from reference.doc:5031
reference.tex(,7329) @c end inserted refs from reference.doc:5031
reference.tex(,7330) @c ---------------------------------------
reference.tex(,7331) @node reduce, regularity, read, Functions
reference.tex(,7332) @subsection reduce
reference.tex(,7333) @cindex reduce
reference.tex(,7334) @cindex NF
reference.tex(,7335) @table @code
reference.tex(,7336) @item @strong{Syntax:}
reference.tex(,7337) @code{reduce (} poly_expression@code{,} ideal_expression @code{)}
reference.tex(,7338) @*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
reference.tex(,7339) @*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} poly_expression @code{)}
reference.tex(,7340) @*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
reference.tex(,7341) @*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
reference.tex(,7342) @*@code{reduce (} vector_expression@code{,} module_expression @code{)}
reference.tex(,7343) @*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
reference.tex(,7344) @*@code{reduce (} vector_expression@code{,} module_expression@code{,} poly_expression @code{)}
reference.tex(,7345) @*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
reference.tex(,7346) @*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
reference.tex(,7347) @*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} matrix_expression @code{)}
reference.tex(,7348) @*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
reference.tex(,7349) @*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
reference.tex(,7350) @*@code{reduce (} module_expression@code{,} module_expression @code{)}
reference.tex(,7351) @*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
reference.tex(,7352) @*@code{reduce (} module_expression@code{,} module_expression@code{,} matrix_expression @code{)}
reference.tex(,7353) @item @strong{Type:}
reference.tex(,7354) the type of the first argument
reference.tex(,7355) @item @strong{Purpose:}
reference.tex(,7356) reduces a polynomial, vector, ideal  or module to its normal form with respect to an ideal or module represented by a standard basis.
reference.tex(,7357) Returns 0 if and only if the polynomial (resp.@: vector, ideal, module)
reference.tex(,7358) is an element (resp.@: subideal, submodule) of the ideal (resp.@: module).
reference.tex(,7359) The result may have no meaning if the second argument is not a standard basis.
reference.tex(,7360) @*The third (optional) argument 1 of type int forces a reduction which considers only the leading term and does no tail reduction.
reference.tex(,7361) @*If a third argument @code{u} of type poly or matrix is given, the first argument @code{p} is replaced by @code{p/u}.
reference.tex(,7362) This works only for zero dimensional ideals (resp.@: modules) in the second argument and gives, even in a local ring, a reduced normal form which is the projection to the quotient by the ideal (resp.@: module).
reference.tex(,7363) @item @strong{Note:}
reference.tex(,7364) The commands @code{reduce} and @code{NF} are synonymous.
reference.tex(,7365) @item @strong{Example:}
reference.tex(,7366) @smallexample
reference.tex(,7367) @c reused example reduce reference.doc:5076 
reference.tex(,7368)   ring r1 = 0,(z,y,x),ds;
reference.tex(,7369)   poly s1=2x5y+7x2y4+3x2yz3;
reference.tex(,7370)   poly s2=1x2y2z2+3z8;
reference.tex(,7371)   poly s3=4xy5+2x2y2z3+11x10;
reference.tex(,7372)   ideal i=s1,s2,s3;
reference.tex(,7373)   ideal j=std(i);
reference.tex(,7374)   reduce(3z3yx2+7y4x2+yx5+z12y2x2,j);
reference.tex(,7375) @expansion{} -yx5+2401/81y14x2+2744/81y11x5+392/27y8x8+224/81y5x11+16/81y2x14
reference.tex(,7376)   reduce(3z3yx2+7y4x2+yx5+z12y2x2,j,1);
reference.tex(,7377) @expansion{} -yx5+z12y2x2
reference.tex(,7378) @c end example reduce reference.doc:5076
reference.tex(,7379) @end smallexample
reference.tex(,7380) @end table
reference.tex(,7381) @c inserted refs from reference.doc:5088
reference.tex(,7398) @c end inserted refs from reference.doc:5088
reference.tex(,7399) @c ---------------------------------------
reference.tex(,7400) @node regularity, repart, reduce, Functions
reference.tex(,7401) @subsection regularity
reference.tex(,7402) @cindex regularity
reference.tex(,7403) @table @code
reference.tex(,7404) @item @strong{Syntax:}
reference.tex(,7405) @code{regularity (} list_expression @code{)}
reference.tex(,7406) @*@code{regularity (} resolution_expression @code{)}
reference.tex(,7407) @item @strong{Type:}
reference.tex(,7408) int
reference.tex(,7409) @item @strong{Purpose:}
reference.tex(,7410) computes the regularity of a homogeneous ideal, resp.@: module, from a
reference.tex(,7411) minimal resolution given by the list expression.
reference.tex(,7412) @*
reference.tex(,7431) @item @strong{Note:}
reference.tex(,7432) If applied to a non minimal resolution only an upper bound is returned.
reference.tex(,7433) @*If the input to the commands @code{res} and @code{mres} is homogeneous
reference.tex(,7434) the regularity is computed and used as a degree bound during
reference.tex(,7435) the computation unless @code{option(notRegularity);} is given.
reference.tex(,7436) @item @strong{Example:}
reference.tex(,7437) @smallexample
reference.tex(,7438) @c reused example regularity reference.doc:5134 
reference.tex(,7439)   ring rh3=32003,(w,x,y,z),(dp,C);
reference.tex(,7440)   poly f=x11+y10+z9+x5y2+x2y2z3+xy3*(y2+x)^2;
reference.tex(,7441)   ideal j=homog(jacob(f),w);
reference.tex(,7442)   def jr=res(j,0);
reference.tex(,7443)   regularity(jr);
reference.tex(,7444) @expansion{} 25
reference.tex(,7445)   // example for upper bound behavior:
reference.tex(,7446)   list jj=jr;
reference.tex(,7447)   regularity(jj);
reference.tex(,7448) @expansion{} 25
reference.tex(,7449)   jj=nres(j,0);
reference.tex(,7450)   regularity(jj);
reference.tex(,7451) @expansion{} 27
reference.tex(,7452)   jj=minres(jj);
reference.tex(,7453)   regularity(jj);
reference.tex(,7454) @expansion{} 25
reference.tex(,7455) @c end example regularity reference.doc:5134
reference.tex(,7456) @end smallexample
reference.tex(,7457) @end table
reference.tex(,7458) @c inserted refs from reference.doc:5150
reference.tex(,7481) @c end inserted refs from reference.doc:5150
reference.tex(,7482) @c ---------------------------------------
reference.tex(,7483) @node repart, res, regularity, Functions
reference.tex(,7484) @subsection repart
reference.tex(,7485) @cindex repart
reference.tex(,7486) 
reference.tex(,7487) @table @code
reference.tex(,7488) @item @strong{Syntax:}
reference.tex(,7489) @code{repart (} number_expression @code{)}
reference.tex(,7490) @item @strong{Type:}
reference.tex(,7491) number
reference.tex(,7492) @item @strong{Purpose:}
reference.tex(,7493) returns the real part of a number from a complex ground field,
reference.tex(,7494) @*returns its argument otherwise.
reference.tex(,7495) @item @strong{Example:}
reference.tex(,7496) @smallexample
reference.tex(,7497) @c reused example repart reference.doc:5175 
reference.tex(,7498)   ring r=(complex,i),x,dp;
reference.tex(,7499)   repart(1+2*i);
reference.tex(,7500) @expansion{} 1
reference.tex(,7501) @c end example repart reference.doc:5175
reference.tex(,7502) @end smallexample
reference.tex(,7503) @end table
reference.tex(,7504) @c inserted refs from reference.doc:5181
reference.tex(,7515) @c end inserted refs from reference.doc:5181
reference.tex(,7516) @c ---------------------------------------
reference.tex(,7517) @node  res, reservedName, repart, Functions
reference.tex(,7518) @subsection res
reference.tex(,7519) @cindex res
reference.tex(,7520) @c start include of docu for standard.lib:res
reference.tex(,7521) @c replaced @subsubsection by @sub
reference.tex(,7522) @c ---content res---
reference.tex(,7523) Procedure from library @code{standard.lib} (@pxref{standard_lib}).
reference.tex(,7524) 
reference.tex(,7525) @c we do texinfo here:
reference.tex(,7526) @cindex resolution, computation of
reference.tex(,7527) @table @code
reference.tex(,7528) @item @strong{Syntax:}
reference.tex(,7529) @code{res (} ideal_expression@code{,} int_expression @code{[,} any_expression @code{])}
reference.tex(,7530) @*@code{res (} module_expression@code{,} int_expression @code{[,} any_expression @code{])}
reference.tex(,7531) @item @strong{Type:}
reference.tex(,7532) resolution
reference.tex(,7533) @item @strong{Purpose:}
reference.tex(,7534) computes a (possibly minimal) free resolution of an ideal or module using
reference.tex(,7535) a heuristically chosen method.
reference.tex(,7536) @* The second (int) argument (say, @code{k}) specifies the length of
reference.tex(,7537) the resolution. If it is not positive then @code{k} is assumed to be the
reference.tex(,7538) number of variables of the basering.
reference.tex(,7539) @* If a third argument is given, the returned resolution is minimized.
reference.tex(,7540) 
reference.tex(,7541) Depending on the input, the returned resolution is computed using the
reference.tex(,7542) following methods:
reference.tex(,7543) @table @asis
reference.tex(,7544) @item @strong{quotient rings:}
reference.tex(,7545) @code{nres} (classical method using syzygies) , see @ref{nres}.
reference.tex(,7546) 
reference.tex(,7547) @item @strong{homogeneous ideals and k=0:}
reference.tex(,7548) @code{lres} (La'Scala's method), see @ref{lres}.
reference.tex(,7549) 
reference.tex(,7550) @item @strong{not minimized resolution and (homogeneous input with k not 0, or local rings):}
reference.tex(,7551) @code{sres} (Schreyer's method), see @ref{sres}.
reference.tex(,7552) 
reference.tex(,7553) @item @strong{all other inputs:}
reference.tex(,7554) @code{mres} (classical method), see @ref{mres}.
reference.tex(,7555) @end table
reference.tex(,7556) @item @strong{Note:}
reference.tex(,7557) Accessing single elements of a resolution may require that some partial
reference.tex(,7558) computations have to be finished and may therefore take some time.
reference.tex(,7559) @end table
reference.tex(,7560) @c inserted refs from d2t_singular/standard_lib.doc:263
reference.tex(,7589) @c end inserted refs from d2t_singular/standard_lib.doc:263
reference.tex(,7590) 
reference.tex(,7591) @strong{Example:}
reference.tex(,7592) @smallexample
reference.tex(,7593) @c reused example res d2t_singular/standard_lib.doc:279 
reference.tex(,7594)   ring r=0,(x,y,z),dp;
reference.tex(,7595) ideal i=xz,yz,x3-y3;
reference.tex(,7596) def l=res(i,0); // homogeneous ideal: uses lres
reference.tex(,7597) l;
reference.tex(,7598) @expansion{}  1      3      2      
reference.tex(,7599) @expansion{} r <--  r <--  r
reference.tex(,7600) @expansion{} 
reference.tex(,7601) @expansion{} 0      1      2      
reference.tex(,7602) @expansion{} resolution not minimized yet
reference.tex(,7603) @expansion{} 
reference.tex(,7604) print(betti(l), "betti"); // input to betti may be of type resolution
reference.tex(,7605) @expansion{}            0     1     2
reference.tex(,7606) @expansion{} ------------------------
reference.tex(,7607) @expansion{}     0:     1     -     -
reference.tex(,7608) @expansion{}     1:     -     2     1
reference.tex(,7609) @expansion{}     2:     -     1     1
reference.tex(,7610) @expansion{} ------------------------
reference.tex(,7611) @expansion{} total:     1     3     2
reference.tex(,7612) l[2];         // element access may take some time
reference.tex(,7613) @expansion{} _[1]=-x*gen(1)+y*gen(2)
reference.tex(,7614) @expansion{} _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)
reference.tex(,7615) i=i,x+1;
reference.tex(,7616) l=res(i,0);   // inhomogeneous ideal: uses mres
reference.tex(,7617) l;
reference.tex(,7618) @expansion{}  1      3      3      1      
reference.tex(,7619) @expansion{} r <--  r <--  r <--  r
reference.tex(,7620) @expansion{} 
reference.tex(,7621) @expansion{} 0      1      2      3      
reference.tex(,7622) @expansion{} resolution not minimized yet
reference.tex(,7623) @expansion{} 
reference.tex(,7624) ring rs=0,(x,y,z),ds;
reference.tex(,7625) ideal i=imap(r,i);
reference.tex(,7626) def l=res(i,0); // local ring not minimized: uses sres
reference.tex(,7627) l;
reference.tex(,7628) @expansion{}   1       1       
reference.tex(,7629) @expansion{} rs <--  rs
reference.tex(,7630) @expansion{} 
reference.tex(,7631) @expansion{} 0       1       
reference.tex(,7632) @expansion{} resolution not minimized yet
reference.tex(,7633) @expansion{} 
reference.tex(,7634) res(i,0,0);     // local ring and minimized: uses mres
reference.tex(,7635) @expansion{}   1       1       
reference.tex(,7636) @expansion{} rs <--  rs
reference.tex(,7637) @expansion{} 
reference.tex(,7638) @expansion{} 0       1       
reference.tex(,7639) @expansion{} 
reference.tex(,7640) @c end example res d2t_singular/standard_lib.doc:279
reference.tex(,7641) @end smallexample
reference.tex(,7642) @c ---end content res---
reference.tex(,7643) @c generated lib proc docu for standard.lib:res reference.doc:5189 
reference.tex(,7644) @c end include of docu for standard.lib:res
reference.tex(,7645) 
reference.tex(,7646) @c ---------------------------------------
reference.tex(,7647) @node reservedName, resultant, res, Functions
reference.tex(,7648) @subsection reservedName
reference.tex(,7649) @cindex reservedName
reference.tex(,7650) @table @code
reference.tex(,7651) @item @strong{Syntax:}
reference.tex(,7652) @code{reservedName ()}
reference.tex(,7653) @item @strong{Type:}
reference.tex(,7654) none
reference.tex(,7655) @item @strong{Syntax:}
reference.tex(,7656) @code{reservedName (} string_expression @code{)}
reference.tex(,7657) @item @strong{Type:}
reference.tex(,7658) int
reference.tex(,7659) @item @strong{Purpose:}
reference.tex(,7660) prints a list of all reserved identifiers (first form) or tests
reference.tex(,7661) whether the string is a reserved identifier (second form).
reference.tex(,7662) @item @strong{Example:}
reference.tex(,7663) @smallexample
reference.tex(,7664) reservedName();
reference.tex(,7665) @expansion{} ... // output skipped
reference.tex(,7666) @c reused example reservedName reference.doc:5211 
reference.tex(,7667)   reservedName("ring");
reference.tex(,7668) @expansion{} 1
reference.tex(,7669)   reservedName("xyz");
reference.tex(,7670) @expansion{} 0
reference.tex(,7671) @c end example reservedName reference.doc:5211
reference.tex(,7672) @end smallexample
reference.tex(,7673) @end table
reference.tex(,7674) @c inserted refs from reference.doc:5217
reference.tex(,7687) @c end inserted refs from reference.doc:5217
reference.tex(,7688) @c ---------------------------------------
reference.tex(,7689) @node  resultant, rvar, reservedName, Functions
reference.tex(,7690) @subsection resultant
reference.tex(,7691) @cindex resultant
reference.tex(,7692) @table @code
reference.tex(,7693) @item @strong{Syntax:}
reference.tex(,7694) @code{resultant (} poly_expression@code{,} poly_expression@code{,} ring_variable @code{)}
reference.tex(,7695) @item @strong{Type:}
reference.tex(,7696) poly
reference.tex(,7697) @item @strong{Purpose:}
reference.tex(,7698) computes the resultant of the first and second argument with respect
reference.tex(,7699) to the variable given as the third argument.
reference.tex(,7700) @item @strong{Example:}
reference.tex(,7701) @smallexample
reference.tex(,7702) @c reused example resultant reference.doc:5236 
reference.tex(,7703)   ring r=32003,(x,y,z),dp;
reference.tex(,7704)   poly f=3*(x+2)^3+y;
reference.tex(,7705)   poly g=x+y+z;
reference.tex(,7706)   resultant(f,g,x);
reference.tex(,7707) @expansion{} 3y3+9y2z+9yz2+3z3-18y2-36yz-18z2+35y+36z-24
reference.tex(,7708) @c end example resultant reference.doc:5236
reference.tex(,7709) @end smallexample
reference.tex(,7710) @end table
reference.tex(,7711) @c inserted refs from reference.doc:5244
reference.tex(,7724) @c end inserted refs from reference.doc:5244
reference.tex(,7725) @c ---------------------------------------
reference.tex(,7726) @node rvar, setring, resultant, Functions
reference.tex(,7727) @subsection rvar
reference.tex(,7728) @cindex rvar
reference.tex(,7729) @table @code
reference.tex(,7730) @item @strong{Syntax:}
reference.tex(,7731) @code{rvar (} name @code{)}
reference.tex(,7732) @*@code{rvar (} poly_expression @code{)}
reference.tex(,7733) @*@code{rvar (} string_expression @code{)}
reference.tex(,7734) @item @strong{Type:}
reference.tex(,7735) int
reference.tex(,7736) @item @strong{Purpose:}
reference.tex(,7737) returns the number of the variable if the name is a ring variable of the
reference.tex(,7738) basering or if the string is the name of a ring variable of the
reference.tex(,7739) basering; returns 0 if not. Hence the return value of @code{rvar} can
reference.tex(,7740) also be used in a boolean context to check whether the variable exists.
reference.tex(,7741) @item @strong{Example:}
reference.tex(,7742) @smallexample
reference.tex(,7743) @c reused example rvar reference.doc:5267 
reference.tex(,7744)   ring r=29,(x,y,z),lp;
reference.tex(,7745)   rvar(x);
reference.tex(,7746) @expansion{} 1
reference.tex(,7747)   rvar(r);
reference.tex(,7748) @expansion{} 0
reference.tex(,7749)   rvar(y);
reference.tex(,7750) @expansion{} 2
reference.tex(,7751)   rvar(var(3));
reference.tex(,7752) @expansion{} 3
reference.tex(,7753)   rvar("x");
reference.tex(,7754) @expansion{} 1
reference.tex(,7755) @c end example rvar reference.doc:5267
reference.tex(,7756) @end smallexample
reference.tex(,7757) @end table
reference.tex(,7758) @c inserted refs from reference.doc:5277
reference.tex(,7775) @c end inserted refs from reference.doc:5277
reference.tex(,7776) @c ---------------------------------------
reference.tex(,7777) @node setring, simplex, rvar, Functions
reference.tex(,7778) @subsection setring
reference.tex(,7779) @cindex setring
reference.tex(,7780) @table @code
reference.tex(,7781) @item @strong{Syntax:}
reference.tex(,7782) @code{setring} ring_name
reference.tex(,7783) @item @strong{Type:}
reference.tex(,7784) none
reference.tex(,7785) @item @strong{Purpose:}
reference.tex(,7786) changes the basering to another (already defined) ring.
reference.tex(,7787) @item @strong{Example:}
reference.tex(,7788) @smallexample
reference.tex(,7789) @c reused example setring reference.doc:5297 
reference.tex(,7790)   ring r1=0,(x,y),lp;
reference.tex(,7791)   // the basering is r1
reference.tex(,7792)   ring r2=32003,(a(1..8)),ds;
reference.tex(,7793)   // the basering is r2
reference.tex(,7794)   setring r1;
reference.tex(,7795)   // the basering is again r1
reference.tex(,7796)   nameof(basering);
reference.tex(,7797) @expansion{} r1
reference.tex(,7798)   listvar();
reference.tex(,7799) @expansion{} // r2                   [0]  ring
reference.tex(,7800) @expansion{} // r1                   [0]  *ring
reference.tex(,7801) @expansion{} // LIB                  [0]  string standard.lib
reference.tex(,7802) @c end example setring reference.doc:5297
reference.tex(,7803) @end smallexample
reference.tex(,7804) @item @strong{Use in procedures:}
reference.tex(,7805) All changes of the basering by a definition of a new ring or a
reference.tex(,7806) @code{setring} command in a procedure are local to this procedure.  Use
reference.tex(,7807) @code{keepring} to move a ring, which is local to a procedure, up by one
reference.tex(,7808) nesting level.
reference.tex(,7809) 
reference.tex(,7810) @end table
reference.tex(,7811) @c inserted refs from reference.doc:5315
reference.tex(,7826) @c end inserted refs from reference.doc:5315
reference.tex(,7827) @c ---------------------------------------
reference.tex(,7828) @node simplex, simplify, setring, Functions
reference.tex(,7829) @subsection simplex
reference.tex(,7830) @cindex simplex
reference.tex(,7831) @table @code
reference.tex(,7832) @item @strong{Syntax:}
reference.tex(,7833) @code{simplex (} matrix_expression@code{,} int_expression@code{,} 
reference.tex(,7834) int_expression@code{,} int_expression@code{,} int_expression@code{,} 
reference.tex(,7835) int_expression@code{)}
reference.tex(,7836) @item @strong{Type:}
reference.tex(,7837) list
reference.tex(,7838) @item @strong{Purpose:}
reference.tex(,7839) perform the simplex algorithm for the tableau given by the input, e.g.
reference.tex(,7840) M,m,n,m1,m2,m3: 
reference.tex(,7841) 
reference.tex(,7842) @table @asis
reference.tex(,7843) @item  M matrix of numbers : 
reference.tex(,7844)      first row describing the objective function (maximize problem), 
reference.tex(,7845)      the remaining rows describing constraints; 
reference.tex(,7846) @item  m,n,m1,m2,m3 int :
reference.tex(,7847)      n = number of variables; 
reference.tex(,7848)      m = total number of constraints; 
reference.tex(,7849)      m1 = number of <=constraints (rows 2 ... m1+1 of M); 
reference.tex(,7850)      m2 = number of >=constraints (rows m1+2 ... m1+m2+1 of M); 
reference.tex(,7851)      m3 = number of == constraints.
reference.tex(,7852) @end table 
reference.tex(,7853) 
reference.tex(,7854) The following assumptions are made: 
reference.tex(,7855) @table @asis
reference.tex(,7856) @item   * ground field is of type @code{(real,N)}, N>=4; 
reference.tex(,7857) @item   * the matrix M is of size m x n; 
reference.tex(,7858) @item   * m=m1+m2+m3;
reference.tex(,7859) @item   * the entries M[2,1] ,..., M[m+1,1] are non-negative;
reference.tex(,7860) @item   * the variables x(i) are non-negative;
reference.tex(,7861) @item   * a row  b, a(1) ,..., a(n)  corresponds to  b+a(1)x(1)+...+a(n)x(n);
reference.tex(,7862) @item   * for a <=, >=, or == constraint: add "in mind" >=0, <=0, or ==0.
reference.tex(,7863) @end table   
reference.tex(,7864) 
reference.tex(,7865) The output is a list L with 
reference.tex(,7866) @table @asis
reference.tex(,7867) @item * L[1] = matrix
reference.tex(,7868) @item * L[2] = int: 
reference.tex(,7869)     0 = finite solution found;  1 = unbounded;  -1 = no solution;  
reference.tex(,7870)    -2 = error occured;
reference.tex(,7871) @item * L[3] = intvec :  
reference.tex(,7872)    L[3][k] = number of variable which corresponds to row k+1 of L[1];             
reference.tex(,7873) @item * L[4] = intvec :  
reference.tex(,7874)    L[4][j] = number of variable which is represented by column j+1 of L[1] 
reference.tex(,7875)    ("non-basis variable");
reference.tex(,7876) @item * L[5] = int :  
reference.tex(,7877)    number of constraints (= m);
reference.tex(,7878) @item * L[6] = int :  
reference.tex(,7879)    number of variables (= n).
reference.tex(,7880) @end table
reference.tex(,7881) 
reference.tex(,7882) The solution can be read from the first column of L[1] as is done by the 
reference.tex(,7883) procedure @ref{simplexOut} in @code{solve.lib}. 
reference.tex(,7884) 
reference.tex(,7885) @item @strong{Example:}
reference.tex(,7886) @smallexample
reference.tex(,7887) @c reused example simplex reference.doc:5381 
reference.tex(,7888)     ring r = (real,10),(x),lp;
reference.tex(,7889) 
reference.tex(,7890)     // consider the max. problem:
reference.tex(,7891)     //
reference.tex(,7892)     //    maximize  x(1) + x(2) + 3*x(3) - 0.5*x(4)
reference.tex(,7893)     //
reference.tex(,7894)     //  with constraints:   x(1) +          2*x(3)          <= 740
reference.tex(,7895)     //                             2*x(2)          - 7*x(4) <=   0
reference.tex(,7896)     //                               x(2) -   x(3) + 2*x(4) >=   0.5
reference.tex(,7897)     //                      x(1) +   x(2) +   x(3) +   x(4)  =   9
reference.tex(,7898)     //
reference.tex(,7899)     matrix sm[5][5]=(  0, 1, 1, 3,-0.5,
reference.tex(,7900)                      740,-1, 0,-2, 0,
reference.tex(,7901)                        0, 0,-2, 0, 7,
reference.tex(,7902)                      0.5, 0,-1, 1,-2,
reference.tex(,7903)                        9,-1,-1,-1,-1);
reference.tex(,7904) 
reference.tex(,7905)     int n = 4;  // number of constraints
reference.tex(,7906)     int m = 4;  // number of variables
reference.tex(,7907)     int m1= 2;  // number of <= constraints
reference.tex(,7908)     int m2= 1;  // number of >= constraints
reference.tex(,7909)     int m3= 1;  // number of == constraints
reference.tex(,7910)     simplex(sm, n, m, m1, m2, m3);
reference.tex(,7911) @expansion{} [1]:
reference.tex(,7912) @expansion{}    _[1,1]=17.025
reference.tex(,7913) @expansion{}    _[1,2]=-0.95
reference.tex(,7914) @expansion{}    _[1,3]=-0.05
reference.tex(,7915) @expansion{}    _[1,4]=1.95
reference.tex(,7916) @expansion{}    _[1,5]=-1.05
reference.tex(,7917) @expansion{}    _[2,1]=730.55
reference.tex(,7918) @expansion{}    _[2,2]=0.1
reference.tex(,7919) @expansion{}    _[2,3]=-0.1
reference.tex(,7920) @expansion{}    _[2,4]=-1.1
reference.tex(,7921) @expansion{}    _[2,5]=0.9
reference.tex(,7922) @expansion{}    _[3,1]=3.325
reference.tex(,7923) @expansion{}    _[3,2]=-0.35
reference.tex(,7924) @expansion{}    _[3,3]=-0.15
reference.tex(,7925) @expansion{}    _[3,4]=0.35
reference.tex(,7926) @expansion{}    _[3,5]=0.35
reference.tex(,7927) @expansion{}    _[4,1]=0.95
reference.tex(,7928) @expansion{}    _[4,2]=-0.1
reference.tex(,7929) @expansion{}    _[4,3]=0.1
reference.tex(,7930) @expansion{}    _[4,4]=0.1
reference.tex(,7931) @expansion{}    _[4,5]=0.1
reference.tex(,7932) @expansion{}    _[5,1]=4.725
reference.tex(,7933) @expansion{}    _[5,2]=-0.55
reference.tex(,7934) @expansion{}    _[5,3]=0.05
reference.tex(,7935) @expansion{}    _[5,4]=0.55
reference.tex(,7936) @expansion{}    _[5,5]=-0.45
reference.tex(,7937) @expansion{} [2]:
reference.tex(,7938) @expansion{}    0
reference.tex(,7939) @expansion{} [3]:
reference.tex(,7940) @expansion{}    5,2,4,3
reference.tex(,7941) @expansion{} [4]:
reference.tex(,7942) @expansion{}    1,6,8,7
reference.tex(,7943) @expansion{} [5]:
reference.tex(,7944) @expansion{}    4
reference.tex(,7945) @expansion{} [6]:
reference.tex(,7946) @expansion{}    4
reference.tex(,7947) @c end example simplex reference.doc:5381
reference.tex(,7948) @end smallexample
reference.tex(,7949) @end table
reference.tex(,7950) @c inserted refs from reference.doc:5408
reference.tex(,7961) @c end inserted refs from reference.doc:5408
reference.tex(,7962) @c ---------------------------------------
reference.tex(,7963) @node simplify, size, simplex, Functions
reference.tex(,7964) @subsection simplify
reference.tex(,7965) @cindex simplify
reference.tex(,7966) @table @code
reference.tex(,7967) @item @strong{Syntax:}
reference.tex(,7968) @code{simplify (} poly_expression@code{,} int_expression @code{)}
reference.tex(,7969) @*@code{simplify (} vector_expression@code{,} int_expression @code{)}
reference.tex(,7970) @*@code{simplify (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,7971) @*@code{simplify (} module_expression@code{,} int_expression @code{)}
reference.tex(,7972) @item @strong{Type:}
reference.tex(,7973) the type of the first argument
reference.tex(,7974) @item @strong{Purpose:}
reference.tex(,7975) returns the "simplified" first argument depending on the simplification rule
reference.tex(,7976) given as the second argument.
reference.tex(,7977) The simplification rules are the sum of the following
reference.tex(,7978) functions:
reference.tex(,7979) @table @code
reference.tex(,7980) @item 1
reference.tex(,7981) normalize (make leading coefficients 1).
reference.tex(,7982) @item 2
reference.tex(,7983) erase zero generators/columns.
reference.tex(,7984) @item 4
reference.tex(,7985) keep only the first one of identical generators/columns.
reference.tex(,7986) @item 8
reference.tex(,7987) keep only the first one of generators/columns which differ only by a factor
reference.tex(,7988) in the ground field.
reference.tex(,7989) @item 16
reference.tex(,7990) keep only those generators/columns whose leading monomials
reference.tex(,7991) differ.
reference.tex(,7992) @item 32
reference.tex(,7993) keep only those generators/columns whose leading monomials are
reference.tex(,7994) not divisible by other ones.
reference.tex(,7995) @end table
reference.tex(,7996) @item @strong{Example:}
reference.tex(,7997) @smallexample
reference.tex(,7998) @c reused example simplify reference.doc:5448 
reference.tex(,7999) ring r=0,(x,y,z),(c,dp);
reference.tex(,8000) ideal i=0,2x,2x,4x,3x+y,5x2;
reference.tex(,8001) simplify(i,1);
reference.tex(,8002) @expansion{} _[1]=0
reference.tex(,8003) @expansion{} _[2]=x
reference.tex(,8004) @expansion{} _[3]=x
reference.tex(,8005) @expansion{} _[4]=x
reference.tex(,8006) @expansion{} _[5]=x+1/3y
reference.tex(,8007) @expansion{} _[6]=x2
reference.tex(,8008) simplify(i,2);
reference.tex(,8009) @expansion{} _[1]=2x
reference.tex(,8010) @expansion{} _[2]=2x
reference.tex(,8011) @expansion{} _[3]=4x
reference.tex(,8012) @expansion{} _[4]=3x+y
reference.tex(,8013) @expansion{} _[5]=5x2
reference.tex(,8014) simplify(i,4);
reference.tex(,8015) @expansion{} _[1]=0
reference.tex(,8016) @expansion{} _[2]=2x
reference.tex(,8017) @expansion{} _[3]=4x
reference.tex(,8018) @expansion{} _[4]=3x+y
reference.tex(,8019) @expansion{} _[5]=5x2
reference.tex(,8020) simplify(i,8);
reference.tex(,8021) @expansion{} _[1]=0
reference.tex(,8022) @expansion{} _[2]=2x
reference.tex(,8023) @expansion{} _[3]=3x+y
reference.tex(,8024) @expansion{} _[4]=5x2
reference.tex(,8025) simplify(i,16);
reference.tex(,8026) @expansion{} _[1]=0
reference.tex(,8027) @expansion{} _[2]=2x
reference.tex(,8028) @expansion{} _[3]=5x2
reference.tex(,8029) simplify(i,32);
reference.tex(,8030) @expansion{} _[1]=0
reference.tex(,8031) @expansion{} _[2]=2x
reference.tex(,8032) simplify(i,32+2+1);
reference.tex(,8033) @expansion{} _[1]=x
reference.tex(,8034) matrix A[2][3]=x,0,2x,y,0,2y;
reference.tex(,8035) simplify(A,2+8); // by automatic conversion to module
reference.tex(,8036) @expansion{} _[1]=[x,y]
reference.tex(,8037) @c end example simplify reference.doc:5448
reference.tex(,8038) @end smallexample
reference.tex(,8039) @end table
reference.tex(,8040) @c inserted refs from reference.doc:5463
reference.tex(,8057) @c end inserted refs from reference.doc:5463
reference.tex(,8058) @c ---------------------------------------
reference.tex(,8059) @node size, sortvec, simplify, Functions
reference.tex(,8060) @subsection size
reference.tex(,8061) @cindex size
reference.tex(,8062) @table @code
reference.tex(,8063) @item @strong{Syntax:}
reference.tex(,8064) @code{size (} string_expression @code{)}
reference.tex(,8065) @*@code{size (} intvec_expression @code{)}
reference.tex(,8066) @*@code{size (} intmat_expression @code{)}
reference.tex(,8067) @*@code{size (} poly_expression @code{)}
reference.tex(,8068) @*@code{size (} vector_expression @code{)}
reference.tex(,8069) @*@code{size (} ideal_expression @code{)}
reference.tex(,8070) @*@code{size (} module_expression @code{)}
reference.tex(,8071) @*@code{size (} matrix_expression @code{)}
reference.tex(,8072) @*@code{size (} list_expression @code{)}
reference.tex(,8073) @*@code{size (} resolution_expression @code{)}
reference.tex(,8074) @*@code{size (} ring_expression @code{)}
reference.tex(,8075) @item @strong{Type:}
reference.tex(,8076) int
reference.tex(,8077) @item @strong{Purpose:}
reference.tex(,8078) depends on the type of argument:
reference.tex(,8079) @table @asis
reference.tex(,8080) @item ideal or module
reference.tex(,8081) returns the number of (non-zero) generators.
reference.tex(,8082) @item string, intvec, list or resolution
reference.tex(,8083) returns the length, i.e., the number of characters, entries or elements.
reference.tex(,8084) @item poly or vector
reference.tex(,8085) returns the number of monomials.
reference.tex(,8086) @item matrix or intmat
reference.tex(,8087) returns the number of entries (rows*columns).
reference.tex(,8088) @item ring
reference.tex(,8089) returns the number of elements in the ground field
reference.tex(,8090) (for Z/p and algebraic extensions) or -1
reference.tex(,8091) @end table
reference.tex(,8092) @item @strong{Example:}
reference.tex(,8093) @smallexample
reference.tex(,8094) @c reused example size reference.doc:5506 
reference.tex(,8095)   string s="hello";
reference.tex(,8096)   size(s);
reference.tex(,8097) @expansion{} 5
reference.tex(,8098)   intvec iv=1,2;
reference.tex(,8099)   size(iv);
reference.tex(,8100) @expansion{} 2
reference.tex(,8101)   ring r=0,(x,y,z),lp;
reference.tex(,8102)   poly f=x+y+z;
reference.tex(,8103)   size(f);
reference.tex(,8104) @expansion{} 3
reference.tex(,8105)   vector v=[x+y,0,0,1];
reference.tex(,8106)   size(v);
reference.tex(,8107) @expansion{} 3
reference.tex(,8108)   ideal i=f,y;
reference.tex(,8109)   size(i);
reference.tex(,8110) @expansion{} 2
reference.tex(,8111)   module m=v,[0,1],[0,0,1],2*v;
reference.tex(,8112)   size(m);
reference.tex(,8113) @expansion{} 4
reference.tex(,8114)   matrix mm[2][2];
reference.tex(,8115)   size(mm);
reference.tex(,8116) @expansion{} 4
reference.tex(,8117)   ring r1=(2,a),x,dp;
reference.tex(,8118)   minpoly=a4+a+1;
reference.tex(,8119)   size(r1);
reference.tex(,8120) @expansion{} 8
reference.tex(,8121) @c end example size reference.doc:5506
reference.tex(,8122) @end smallexample
reference.tex(,8123) @end table
reference.tex(,8124) @c inserted refs from reference.doc:5528
reference.tex(,8151) @c end inserted refs from reference.doc:5528
reference.tex(,8152) @c ---------------------------------------
reference.tex(,8153) @node sortvec, sprintf, size, Functions
reference.tex(,8154) @subsection sortvec
reference.tex(,8155) @cindex sortvec
reference.tex(,8156) @table @code
reference.tex(,8157) @item @strong{Syntax:}
reference.tex(,8158) @code{sortvec (} ideal_expression @code{)}
reference.tex(,8159) @*@code{sortvec (} module_expression @code{)}
reference.tex(,8160) @item @strong{Type:}
reference.tex(,8161) intvec
reference.tex(,8162) @item @strong{Purpose:}
reference.tex(,8175) @item @strong{Example:}
reference.tex(,8176) @smallexample
reference.tex(,8177) @c reused example sortvec reference.doc:5565 
reference.tex(,8178)   ring r=0,(x,y,z),dp;
reference.tex(,8179)   ideal I=y,z,x,x3,xz;
reference.tex(,8180)   sortvec(I);
reference.tex(,8181) @expansion{} 2,1,3,5,4
reference.tex(,8182) @c end example sortvec reference.doc:5565
reference.tex(,8183) @end smallexample
reference.tex(,8184) @end table
reference.tex(,8185) @c inserted refs from reference.doc:5572
reference.tex(,8196) @c end inserted refs from reference.doc:5572
reference.tex(,8197) @c ---------------------------------------
reference.tex(,8198) @node sprintf, sres, sortvec, Functions
reference.tex(,8199) @subsection sprintf
reference.tex(,8200) @cindex sprintf
reference.tex(,8201) @c start include of docu for standard.lib:sprintf
reference.tex(,8202) @c replaced @subsubsection by @sub
reference.tex(,8203) @c ---content sprintf---
reference.tex(,8204) Procedure from library @code{standard.lib} (@pxref{standard_lib}).
reference.tex(,8205) 
reference.tex(,8206) @table @asis
reference.tex(,8207) @item @strong{Syntax:}
reference.tex(,8208) @code{sprintf (} string_expression @code{[,} any_expressions
reference.tex(,8209) @code{] )}
reference.tex(,8210) 
reference.tex(,8211) @item @strong{Return:}
reference.tex(,8212) string
reference.tex(,8213) 
reference.tex(,8214) @item @strong{Purpose:}
reference.tex(,8215) @code{sprintf(fmt,...);} performs output formatting. The first
reference.tex(,8216) argument is a format control string. Additional arguments may be
reference.tex(,8217) required, depending on the content of the control string. A series
reference.tex(,8218) of output characters is generated as directed by the control string;
reference.tex(,8219) these characters are returned as a string. @*
reference.tex(,8220) The control string @code{fmt} is simply text to be copied,
reference.tex(,8221) except that the string may contain conversion specifications.@*
reference.tex(,8222) Do @code{help print;} for a listing of valid conversion
reference.tex(,8223) specifications. As an addition to the conversions of @code{print},
reference.tex(,8224) the @code{%n} and @code{%2} conversion specification does not
reference.tex(,8225) consume an additional argument, but simply generates a newline
reference.tex(,8226) character.
reference.tex(,8227) 
reference.tex(,8228) @item @strong{Note:}
reference.tex(,8229) If one of the additional arguments is a list, then it should be
reference.tex(,8230) enclosed once more into a @code{list()} command, since passing a list
reference.tex(,8231) as an argument flattens the list by one level.
reference.tex(,8232) 
reference.tex(,8233) @end table
reference.tex(,8234) @strong{Example:}
reference.tex(,8235) @smallexample
reference.tex(,8236) @c reused example sprintf d2t_singular/standard_lib.doc:335 
reference.tex(,8237)   ring r=0,(x,y,z),dp;
reference.tex(,8238) module m=[1,y],[0,x+z];
reference.tex(,8239) intmat M=betti(mres(m,0));
reference.tex(,8240) list l = r, m, M;
reference.tex(,8241) string s = sprintf("s:%s,%n l:%l", 1, 2); s;
reference.tex(,8242) @expansion{} s:1,
reference.tex(,8243) @expansion{}  l:int(2)
reference.tex(,8244) s = sprintf("s:%n%s", l); s;
reference.tex(,8245) @expansion{} s:
reference.tex(,8246) @expansion{} (0),(x,y,z),(dp(3),C)
reference.tex(,8247) s = sprintf("s:%2%s", list(l)); s;
reference.tex(,8248) @expansion{} s:
reference.tex(,8249) @expansion{} (0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
reference.tex(,8250) s = sprintf("2l:%n%2l", list(l)); s;
reference.tex(,8251) @expansion{} 2l:
reference.tex(,8252) @expansion{} list("(0),(x,y,z),(dp(3),C)",
reference.tex(,8253) @expansion{} module(y*gen(2)+gen(1),
reference.tex(,8254) @expansion{} x*gen(2)+z*gen(2)),
reference.tex(,8255) @expansion{} intmat(intvec(1,1 ),1,2))
reference.tex(,8256) @expansion{} 
reference.tex(,8257) s = sprintf("%p", list(l)); s;
reference.tex(,8258) @expansion{} [1]:
reference.tex(,8259) @expansion{}    //   characteristic : 0
reference.tex(,8260) @expansion{} //   number of vars : 3
reference.tex(,8261) @expansion{} //        block   1 : ordering dp
reference.tex(,8262) @expansion{} //                  : names    x y z 
reference.tex(,8263) @expansion{} //        block   2 : ordering C
reference.tex(,8264) @expansion{} [2]:
reference.tex(,8265) @expansion{}    _[1]=y*gen(2)+gen(1)
reference.tex(,8266) @expansion{}    _[2]=x*gen(2)+z*gen(2)
reference.tex(,8267) @expansion{} [3]:
reference.tex(,8268) @expansion{}    1,1 
reference.tex(,8269) @expansion{} 
reference.tex(,8270) s = sprintf("%;", list(l)); s;
reference.tex(,8271) @expansion{} [1]:
reference.tex(,8272) @expansion{}    //   characteristic : 0
reference.tex(,8273) @expansion{} //   number of vars : 3
reference.tex(,8274) @expansion{} //        block   1 : ordering dp
reference.tex(,8275) @expansion{} //                  : names    x y z 
reference.tex(,8276) @expansion{} //        block   2 : ordering C
reference.tex(,8277) @expansion{} [2]:
reference.tex(,8278) @expansion{}    _[1]=y*gen(2)+gen(1)
reference.tex(,8279) @expansion{}    _[2]=x*gen(2)+z*gen(2)
reference.tex(,8280) @expansion{} [3]:
reference.tex(,8281) @expansion{}    1,1 
reference.tex(,8282) @expansion{} 
reference.tex(,8283) s = sprintf("%b", M); s;
reference.tex(,8284) @expansion{}            0     1
reference.tex(,8285) @expansion{} ------------------
reference.tex(,8286) @expansion{}     0:     1     1
reference.tex(,8287) @expansion{} ------------------
reference.tex(,8288) @expansion{} total:     1     1
reference.tex(,8289) @expansion{} 
reference.tex(,8290) @c end example sprintf d2t_singular/standard_lib.doc:335
reference.tex(,8291) @end smallexample
reference.tex(,8292) @c inserted refs from d2t_singular/standard_lib.doc:349
reference.tex(,8309) @c end inserted refs from d2t_singular/standard_lib.doc:349
reference.tex(,8310) 
reference.tex(,8311) @c ---end content sprintf---
reference.tex(,8312) @c generated lib proc docu for standard.lib:sprintf reference.doc:5580 
reference.tex(,8313) @c end include of docu for standard.lib:sprintf
reference.tex(,8314) 
reference.tex(,8315) @c ---------------------------------------
reference.tex(,8316) @node sres, status, sprintf, Functions
reference.tex(,8317) @subsection sres
reference.tex(,8318) @cindex sres
reference.tex(,8319) @table @code
reference.tex(,8320) @item @strong{Syntax:}
reference.tex(,8321) @code{sres (} ideal_expression@code{,} int_expression @code{)}
reference.tex(,8322) @*@code{sres (} module_expression@code{,} int_expression @code{)}
reference.tex(,8323) @item @strong{Type:}
reference.tex(,8324) resolution
reference.tex(,8325) @item @strong{Purpose:}
reference.tex(,8326) computes a free resolution of an ideal or module with Schreyer's
reference.tex(,8327) method. The ideal, resp.@: module, has to be a standard basis.
reference.tex(,8328) More precisely, let M be given by a standard basis and
reference.tex(,8335) Then @code{sres}
reference.tex(,8336) computes a free resolution of
reference.tex(,8348) If the int expression k is not zero then the computation stops after k steps
reference.tex(,8349) and returns a list of modules (given by standard bases)
reference.tex(,8356) @*@code{sres(M,0)}
reference.tex(,8357) returns a list of n modules where n is the number of variables of the basering.
reference.tex(,8358) 
reference.tex(,8359) Even if @code{sres} does not compute a minimal resolution, the @code{betti}
reference.tex(,8360) command gives the true betti numbers! In many cases of interest
reference.tex(,8361) @code{sres} is much faster than any other known method.
reference.tex(,8362) Let @code{list L=sres(M,0);} then @code{L[1]=M} is identical to the input,
reference.tex(,8363) @code{L[2]} is a standard basis with respect to the Schreyer ordering of
reference.tex(,8364) the first syzygy
reference.tex(,8365) module of @code{L[1]}, etc.
reference.tex(,8372)  in the notations from above.)
reference.tex(,8373) @item @strong{Note:}
reference.tex(,8374) Accessing single elements of a resolution may require that some partial
reference.tex(,8375) computations have to be finished and may therefore take some time.
reference.tex(,8376) @item @strong{Example:}
reference.tex(,8377) @smallexample
reference.tex(,8378) @c reused example sres reference.doc:5645 
reference.tex(,8379)   ring r=31991,(t,x,y,z,w),ls;
reference.tex(,8380)   ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
reference.tex(,8381)           t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
reference.tex(,8382)   M=std(M);
reference.tex(,8383)   resolution L=sres(M,0);
reference.tex(,8384)   L;
reference.tex(,8385) @expansion{}  1      35      141      209      141      43      4      
reference.tex(,8386) @expansion{} r <--  r <--   r <--    r <--    r <--    r <--   r
reference.tex(,8387) @expansion{} 
reference.tex(,8388) @expansion{} 0      1       2        3        4        5       6      
reference.tex(,8389) @expansion{} resolution not minimized yet
reference.tex(,8390) @expansion{} 
reference.tex(,8391)   print(betti(L),"betti");
reference.tex(,8392) @expansion{}            0     1     2     3     4     5
reference.tex(,8393) @expansion{} ------------------------------------------
reference.tex(,8394) @expansion{}     0:     1     -     -     -     -     -
reference.tex(,8395) @expansion{}     1:     -     -     -     -     -     -
reference.tex(,8396) @expansion{}     2:     -     -     -     -     -     -
reference.tex(,8397) @expansion{}     3:     -     4     -     -     -     -
reference.tex(,8398) @expansion{}     4:     -     -     -     -     -     -
reference.tex(,8399) @expansion{}     5:     -     -     -     -     -     -
reference.tex(,8400) @expansion{}     6:     -     -     6     -     -     -
reference.tex(,8401) @expansion{}     7:     -     -     9    16     2     -
reference.tex(,8402) @expansion{}     8:     -     -     -     2     5     1
reference.tex(,8403) @expansion{} ------------------------------------------
reference.tex(,8404) @expansion{} total:     1     4    15    18     7     1
reference.tex(,8405) @c end example sres reference.doc:5645
reference.tex(,8406) @end smallexample
reference.tex(,8407) @end table
reference.tex(,8408) @c inserted refs from reference.doc:5656
reference.tex(,8437) @c end inserted refs from reference.doc:5656
reference.tex(,8438) @c ---------------------------------------
reference.tex(,8439) @node status, std, sres, Functions
reference.tex(,8440) @subsection status
reference.tex(,8441) @cindex status
reference.tex(,8442) @cindex sleep
reference.tex(,8443) @cindex suspend
reference.tex(,8444) @table @code
reference.tex(,8445) @item @strong{Syntax:}
reference.tex(,8446) @code{status (} link_expression@code{,} string_expression @code{)}
reference.tex(,8447) @item @strong{Type:}
reference.tex(,8448) string
reference.tex(,8449) @item @strong{Syntax:}
reference.tex(,8450) @code{status (} link_expression@code{,} string_expression@code{,} string_expression @code{)}
reference.tex(,8451) @*@code{status (} link_expression@code{,} string_expression@code{,} string_expression@code{,} int_expression @code{)}
reference.tex(,8452) @item @strong{Type:}
reference.tex(,8453) int
reference.tex(,8454) @item @strong{Purpose:}
reference.tex(,8455) returns the status of the link as asked for by the second argument.  If
reference.tex(,8456) a third argument is given, the result of the comparison to the status
reference.tex(,8457) string is returned: @code{(status(l,s1)==s2)} is equivalent to
reference.tex(,8458) @code{status(l,s1,s2)}.  If a fourth integer argument (say, @code{i}) is
reference.tex(,8459) given and if @code{status(l,s1,s2)} yields @code{0}, then the execution
reference.tex(,8460) of the current process is suspended (the process is put to ``sleep'')
reference.tex(,8461) for approximately@: @code{i} microseconds, and afterwards the result of another
reference.tex(,8462) call to @code{status(l,s1,s2)} is returned. The latter is useful for
reference.tex(,8463) ``polling'' the @code{read} status of MPtcp links such that busy
reference.tex(,8464) loops are avoided (see @ref{Parallelization with MPtcp links} for an
reference.tex(,8465) example).  Note that on some systems, the minimum time for a process to
reference.tex(,8466) be put to sleep is one second.
reference.tex(,8467) @*The following string expressions are allowed:
reference.tex(,8468) @table @code
reference.tex(,8469) @item @code{"name"}
reference.tex(,8470) the name string given by the definition of the link (usually the filename)
reference.tex(,8471) @item @code{"type"}
reference.tex(,8472) returns @code{"ASCII"}, @code{"MPfile"}, @code{"MPtcp"} or @code{"DBM"}
reference.tex(,8473) @item @code{"open"}
reference.tex(,8474) returns @code{"yes"} or @code{"no"}
reference.tex(,8475) @item @code{"openread"}
reference.tex(,8476) returns @code{"yes"} or @code{"no"}
reference.tex(,8477) @item @code{"openwrite"}
reference.tex(,8478) returns @code{"yes"} or @code{"no"}
reference.tex(,8479) @item @code{"read"}
reference.tex(,8480) returns @code{"ready"} or @code{"not ready"}
reference.tex(,8481) @item @code{"write"}
reference.tex(,8482) returns @code{"ready"} or @code{"not ready"}
reference.tex(,8483) @item @code{"mode"}
reference.tex(,8484) returns (depending on the type of the link and its status)
reference.tex(,8485) @code{"","w","a","r"} or @code{"rw"}
reference.tex(,8486) @end table
reference.tex(,8487) @item @strong{Example:}
reference.tex(,8488) @smallexample
reference.tex(,8489) @c reused example status reference.doc:5720 
reference.tex(,8490)   link l=":w example.txt";
reference.tex(,8491)   status(l,"write");
reference.tex(,8492) @expansion{} not ready
reference.tex(,8493)   open(l);
reference.tex(,8494)   status(l,"write","ready");
reference.tex(,8495) @expansion{} 1
reference.tex(,8496)   close(l);
reference.tex(,8497) @c end example status reference.doc:5720
reference.tex(,8498) @end smallexample
reference.tex(,8499) @end table
reference.tex(,8500) @c inserted refs from reference.doc:5729
reference.tex(,8517) @c end inserted refs from reference.doc:5729
reference.tex(,8518) @c ---------------------------------------
reference.tex(,8519) @node std, stdfglm, status, Functions
reference.tex(,8520) @subsection std
reference.tex(,8521) @cindex std
reference.tex(,8522) @table @code
reference.tex(,8523) @item @strong{Syntax:}
reference.tex(,8524) @code{std (} ideal_expression@code{)}
reference.tex(,8525) @*@code{std (} module_expression@code{)}
reference.tex(,8526) @*@code{std (} ideal_expression@code{,} intvec_expression @code{)}
reference.tex(,8527) @*@code{std (} module_expression@code{,} intvec_expression @code{)}
reference.tex(,8528) @*@code{std (} ideal_expression@code{,} intvec_expression@code{,} intvec_expression @code{)}
reference.tex(,8529) @*@code{std (} module_expression@code{,} intvec_expression@code{,} intvec_expression @code{)}
reference.tex(,8530) @*@code{std (} ideal_expression@code{,} poly_expression @code{)}
reference.tex(,8531) @*@code{std (} module_expression@code{,} vector_expression @code{)}
reference.tex(,8532) @item @strong{Type:}
reference.tex(,8533) ideal or module
reference.tex(,8534) @item @strong{Purpose:}
reference.tex(,8535) returns a standard basis of an ideal or module with respect to the
reference.tex(,8536) monomial ordering of the basering.
reference.tex(,8537) A standard basis is a set of generators such that
reference.tex(,8538) the leading terms generate the leading ideal, resp.@: module.
reference.tex(,8539) @*Use an optional
reference.tex(,8540) second argument of type intvec as Hilbert series
reference.tex(,8541) (result of @code{hilb(i,1)}, see @ref{hilb}),
reference.tex(,8542) if the ideal, resp.@: module, is homogeneous
reference.tex(,8543) (Hilbert driven standard basis computation, @ref{stdhilb}).
reference.tex(,8544) If the ideal is quasihomogeneous with some weights w and if the Hilbert series
reference.tex(,8545) is computed w.r.t.@: to these weights, then use w as third argument.
reference.tex(,8546) @*Use an optional second argument of type poly, resp.@: vector,
reference.tex(,8547) to construct the standard basis from an already computed one (given as the
reference.tex(,8548) first argument) and one additional generator (the second argument).
reference.tex(,8549) @item @strong{Note:}
reference.tex(,8550) The
reference.tex(,8551) standard basis is computed with a (more or less) straight-forward
reference.tex(,8552) implementation of the classical
reference.tex(,8553) Buchberger (resp.@: Mora) algorithm. For global orderings, use the
reference.tex(,8554) @code{groebner} command instead (@pxref{groebner}), which heuristically
reference.tex(,8555) chooses the "best" algorithm to compute a Groebner basis.
reference.tex(,8556) @*To view the progress of long running computations, use
reference.tex(,8557) @code{option(prot)} (see @ref{option(prot)}).
reference.tex(,8558) 
reference.tex(,8559) @item @strong{Example:}
reference.tex(,8560) @smallexample
reference.tex(,8561) @c reused example std reference.doc:5779 
reference.tex(,8562)   // local computation
reference.tex(,8563)   ring r=32003,(x,y,z),ds;
reference.tex(,8564)   poly s1=1x2y+151xyz10+169y21;
reference.tex(,8565)   poly s2=1xz14+6x2y4+3z24;
reference.tex(,8566)   poly s3=5y10z10x+2y20z10+y10z20+11x3;
reference.tex(,8567)   ideal i=s1,s2,s3;
reference.tex(,8568)   ideal j=std(i);
reference.tex(,8569)   degree(j);
reference.tex(,8570) @expansion{} 0
reference.tex(,8571)   // Hilbert driven elimination (standard)
reference.tex(,8572)   ring rhom=32003,(x,y,z,h),dp;
reference.tex(,8573)   ideal i=homog(imap(r,i),h);
reference.tex(,8574)   ideal j=std(i);
reference.tex(,8575)   intvec iv=hilb(j,1);
reference.tex(,8576)   ring rlex=32003,(x,y,z,h),lp;
reference.tex(,8577)   ideal i=fetch(rhom,i);
reference.tex(,8578)   ideal j=std(i,iv);
reference.tex(,8579)   j=subst(j,h,1);
reference.tex(,8580)   j[1];
reference.tex(,8581) @expansion{} z64
reference.tex(,8582)   // Hilbert driven elimination (ideal is quasihomogeneous)
reference.tex(,8583)   intvec w=10,1,1;
reference.tex(,8584)   ring whom=32003,(x,y,z),wp(w);
reference.tex(,8585)   ideal i=fetch(r,i);
reference.tex(,8586)   ideal j=std(i);
reference.tex(,8587)   intvec iw=hilb(j,1,w);
reference.tex(,8588)   ring wlex=32003,(x,y,z),lp;
reference.tex(,8589)   ideal i=fetch(whom,i);
reference.tex(,8590)   ideal j=std(i,iw,w);
reference.tex(,8591)   j[1];
reference.tex(,8592) @expansion{} z64
reference.tex(,8593) @c end example std reference.doc:5779
reference.tex(,8594) @end smallexample
reference.tex(,8595) @end table
reference.tex(,8596) @c inserted refs from reference.doc:5811
reference.tex(,8623) @c end inserted refs from reference.doc:5811
reference.tex(,8624) 
reference.tex(,8625) @c ---------------------------------------
reference.tex(,8626) @node stdfglm, stdhilb, std, Functions
reference.tex(,8627) @subsection stdfglm
reference.tex(,8628) @cindex stdfglm
reference.tex(,8629) @c start include of docu for standard.lib:stdfglm
reference.tex(,8630) @c replaced @subsubsection by @sub
reference.tex(,8631) @c ---content stdfglm---
reference.tex(,8632) Procedure from library @code{standard.lib} (@pxref{standard_lib}).
reference.tex(,8633) 
reference.tex(,8634) @table @asis
reference.tex(,8635) @item @strong{Syntax:}
reference.tex(,8636) @code{stdfglm (} ideal_expression @code{)} @*
reference.tex(,8637) @code{stdfglm (} ideal_expression@code{,} string_expression @code{)}
reference.tex(,8638) 
reference.tex(,8639) @item @strong{Type:}
reference.tex(,8640) ideal
reference.tex(,8641) 
reference.tex(,8642) @item @strong{Purpose:}
reference.tex(,8643) computes the standard basis of the ideal in the basering
reference.tex(,8644) via @code{fglm} (from the ordering given as the second argument
reference.tex(,8645) to the ordering of the basering).@*
reference.tex(,8646) If no second argument is given, "dp" is used.
reference.tex(,8647) 
reference.tex(,8648) @cindex fglm
reference.tex(,8649) @end table
reference.tex(,8650) @strong{Example:}
reference.tex(,8651) @smallexample
reference.tex(,8652) @c reused example stdfglm d2t_singular/standard_lib.doc:52 
reference.tex(,8653)    ring r=0,(x,y,z),lp;
reference.tex(,8654) ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
reference.tex(,8655) ideal i1=stdfglm(i);         //uses fglm from "dp" to "lp"
reference.tex(,8656) i1;
reference.tex(,8657) @expansion{} i1[1]=z12
reference.tex(,8658) @expansion{} i1[2]=yz4-z8
reference.tex(,8659) @expansion{} i1[3]=y2+y-z8-z4
reference.tex(,8660) @expansion{} i1[4]=xy-xz4-y+z4
reference.tex(,8661) @expansion{} i1[5]=x2+y-z4
reference.tex(,8662) ideal i2=stdfglm(i,"Dp");    //uses fglm from "Dp" to "lp"
reference.tex(,8663) i2;
reference.tex(,8664) @expansion{} i2[1]=z12
reference.tex(,8665) @expansion{} i2[2]=yz4-z8
reference.tex(,8666) @expansion{} i2[3]=y2+y-z8-z4
reference.tex(,8667) @expansion{} i2[4]=xy-xz4-y+z4
reference.tex(,8668) @expansion{} i2[5]=x2+y-z4
reference.tex(,8669) @c end example stdfglm d2t_singular/standard_lib.doc:52
reference.tex(,8670) @end smallexample
reference.tex(,8671) @c inserted refs from d2t_singular/standard_lib.doc:61
reference.tex(,8688) @c end inserted refs from d2t_singular/standard_lib.doc:61
reference.tex(,8689) 
reference.tex(,8690) @c ---end content stdfglm---
reference.tex(,8691) @c generated lib proc docu for standard.lib:stdfglm reference.doc:5828 
reference.tex(,8692) @c end include of docu for standard.lib:stdfglm
reference.tex(,8693) 
reference.tex(,8694) @c ---------------------------------------
reference.tex(,8695) @node stdhilb, subst, stdfglm, Functions
reference.tex(,8696) @subsection stdhilb
reference.tex(,8697) @cindex stdhilb
reference.tex(,8698) @c start include of docu for standard.lib:stdhilb
reference.tex(,8699) @c replaced @subsubsection by @sub
reference.tex(,8700) @c ---content stdhilb---
reference.tex(,8701) Procedure from library @code{standard.lib} (@pxref{standard_lib}).
reference.tex(,8702) 
reference.tex(,8703) @table @asis
reference.tex(,8704) @item @strong{Syntax:}
reference.tex(,8705) @code{stdhilb (} ideal_expression @code{)} @*
reference.tex(,8706) @code{stdhilb (} ideal_expression@code{,} intvec_expression @code{)}
reference.tex(,8707) 
reference.tex(,8708) @item @strong{Type:}
reference.tex(,8709) ideal
reference.tex(,8710) 
reference.tex(,8711) @item @strong{Purpose:}
reference.tex(,8712) computes the standard basis of the homogeneous ideal in the basering,
reference.tex(,8713) via a Hilbert driven standard basis computation.@*
reference.tex(,8714) An optional second argument will be used as 1st Hilbert function.
reference.tex(,8715) 
reference.tex(,8716) @item @strong{Assume:}
reference.tex(,8717) The optional second argument is the first Hilbert series as computed
reference.tex(,8718) by @code{hilb}.
reference.tex(,8719) 
reference.tex(,8720) @cindex Hilbert function
reference.tex(,8721) @end table
reference.tex(,8722) @strong{Example:}
reference.tex(,8723) @smallexample
reference.tex(,8724) @c reused example stdhilb d2t_singular/standard_lib.doc:95 
reference.tex(,8725)    ring  r=0,(x,y,z),dp;
reference.tex(,8726) ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
reference.tex(,8727) ideal i1=stdhilb(i); i1;
reference.tex(,8728) @expansion{} i1[1]=y3+x2
reference.tex(,8729) @expansion{} i1[2]=x2y+x2
reference.tex(,8730) @expansion{} i1[3]=x3-x2
reference.tex(,8731) @expansion{} i1[4]=z4-x2-y
reference.tex(,8732) // the latter computation is equivalent to:
reference.tex(,8733) intvec v=hilb(i,1);
reference.tex(,8734) @expansion{} // ** i is no standardbasis
reference.tex(,8735) ideal i2=stdhilb(i,v); i2;
reference.tex(,8736) @expansion{} i2[1]=y3+x2
reference.tex(,8737) @expansion{} i2[2]=x2y+x2
reference.tex(,8738) @expansion{} i2[3]=x3-x2
reference.tex(,8739) @expansion{} i2[4]=z4-x2-y
reference.tex(,8740) @c end example stdhilb d2t_singular/standard_lib.doc:95
reference.tex(,8741) @end smallexample
reference.tex(,8742) @c inserted refs from d2t_singular/standard_lib.doc:104
reference.tex(,8757) @c end inserted refs from d2t_singular/standard_lib.doc:104
reference.tex(,8758) 
reference.tex(,8759) @c ---end content stdhilb---
reference.tex(,8760) @c generated lib proc docu for standard.lib:stdhilb reference.doc:5834 
reference.tex(,8761) @c end include of docu for standard.lib:stdhilb
reference.tex(,8762) 
reference.tex(,8763) @c ---------------------------------------
reference.tex(,8764) @node subst, system, stdhilb, Functions
reference.tex(,8765) @subsection subst
reference.tex(,8766) @cindex subst
reference.tex(,8767) @table @code
reference.tex(,8768) @item @strong{Syntax:}
reference.tex(,8769) @code{subst (} poly_expression@code{,} ring_variable@code{,} poly_expression @code{)}
reference.tex(,8770) @*@code{subst (} vector_expression@code{,} ring_variable@code{,} poly_expression @code{)}
reference.tex(,8771) @*@code{subst (} ideal_expression@code{,} ring_variable@code{,} poly_expression @code{)}
reference.tex(,8772) @*@code{subst (} module_expression@code{,} ring_variable@code{,} poly_expression @code{)}
reference.tex(,8773) @item @strong{Type:}
reference.tex(,8774) poly, vector, ideal or module (corresponding to the first argument)
reference.tex(,8775) @item @strong{Purpose:}
reference.tex(,8776) substitutes a ring variable by a polynomial.
reference.tex(,8777) @item @strong{Example:}
reference.tex(,8778) @smallexample
reference.tex(,8779) @c reused example subst reference.doc:5852 
reference.tex(,8780)   ring r=0,(x,y,z),dp;
reference.tex(,8781)   poly f=x2+y2+z2+x+y+z;
reference.tex(,8782)   subst(f,x,3/2);
reference.tex(,8783) @expansion{} y2+z2+y+z+15/4
reference.tex(,8784)   int a=1;
reference.tex(,8785)   subst(f,y,a);
reference.tex(,8786) @expansion{} x2+z2+x+z+2
reference.tex(,8787)   subst(f,y,z);
reference.tex(,8788) @expansion{} x2+2z2+x+2z
reference.tex(,8789)   subst(f,y,z+1);
reference.tex(,8790) @expansion{} x2+2z2+x+4z+2
reference.tex(,8791) @c end example subst reference.doc:5852
reference.tex(,8792) @end smallexample
reference.tex(,8793) @end table
reference.tex(,8794) @c inserted refs from reference.doc:5863
reference.tex(,8813) @c end inserted refs from reference.doc:5863
reference.tex(,8814) @c ---------------------------------------
reference.tex(,8815) @node  system, syz, subst, Functions
reference.tex(,8816) @subsection system
reference.tex(,8817) @cindex system
reference.tex(,8818) @table @code
reference.tex(,8819) @item @strong{Syntax:}
reference.tex(,8820) @code{system (} string_expression @code{)}
reference.tex(,8821) @*@code{system (} string_expression@code{,} expression @code{)}
reference.tex(,8822) @item @strong{Type:}
reference.tex(,8823) depends on the desired function, may be none
reference.tex(,8824) @item @strong{Purpose:}
reference.tex(,8825) interface to internal data and the operating system. The
reference.tex(,8826) string_expression determines the command to execute. Some commands
reference.tex(,8827) require an additional argument (second form) where the type of the
reference.tex(,8828) argument depends on the command. See below for a list of all possible
reference.tex(,8829) commands.
reference.tex(,8830) @item @strong{Note:}
reference.tex(,8831) Not all functions work on every platform.
reference.tex(,8832) @item @strong{Functions:}
reference.tex(,8833) @table @asis
reference.tex(,8834) @item @code{system("sh"}, string_expression @code{)}
reference.tex(,8835) @cindex sh
reference.tex(,8836) @cindex system, sh
reference.tex(,8837) shell escape, returns the return code of the shell as int. The string is
reference.tex(,8838) sent literally to the shell.
reference.tex(,8839) @item @code{system("pid")}
reference.tex(,8840) @cindex pid
reference.tex(,8841) @cindex system, pid
reference.tex(,8842) returns the process number as int (for creating unique names).
reference.tex(,8843) @item @code{system("uname")}
reference.tex(,8844) @cindex uname
reference.tex(,8845) @cindex system, uname
reference.tex(,8846) @cindex hardware platform
reference.tex(,8847) returns a string identifying the architecture for which @sc{Singular}
reference.tex(,8848) was compiled.
reference.tex(,8849) @item @code{system("getenv",} string_expression@code{)}
reference.tex(,8850) @cindex getenv
reference.tex(,8851) @cindex system, getenv
reference.tex(,8852) returns the value of the shell environment variable given as the second
reference.tex(,8853) argument. The return type is string.
reference.tex(,8854) @item @code{system("setenv",}string_expression, string_expression@code{)}
reference.tex(,8855) @cindex setenv
reference.tex(,8856) @cindex system, setenv
reference.tex(,8857) sets the shell environment variable given as the second argument to the
reference.tex(,8858) value given as the third argument. Returns the third argument. Might not
reference.tex(,8859) be available on all platforms.
reference.tex(,8860) @item @code{system("tty")}
reference.tex(,8861) @cindex tty
reference.tex(,8862) @cindex system, tty
reference.tex(,8863) resets the terminal.
reference.tex(,8864) @item @code{system("version")}
reference.tex(,8865) @cindex version
reference.tex(,8866) @cindex system, version
reference.tex(,8867) returns the version number of  @sc{Singular} as int.
reference.tex(,8868) @item @code{system("contributors")}
reference.tex(,8869) @cindex contributors
reference.tex(,8870) @cindex system, contributors
reference.tex(,8871) returns names of people who contributed to the @sc{Singular} kernel as string.
reference.tex(,8872) @item @code{system("gen")}
reference.tex(,8873) @c gen is reserved id: @cindex gen
reference.tex(,8874) @cindex system, gen
reference.tex(,8875) returns the generating element of the multiplicative
reference.tex(,8876) group of (Z/p)\@{0@} (as int) where p is the characteristic of the
reference.tex(,8877) basering.
reference.tex(,8878) @item @code{system("nblocks")}
reference.tex(,8879) @item @code{system("nblocks",} ring_name @code{)}
reference.tex(,8880) @cindex nblocks
reference.tex(,8881) @cindex system, nblocks
reference.tex(,8882) returns the number of blocks of the given ring, or the number of parameters
reference.tex(,8883) of the current basering, if no second argument is given. The return type
reference.tex(,8884) is int.
reference.tex(,8885) @item @code{system("Singular")}
reference.tex(,8886) @cindex Singular
reference.tex(,8887) @cindex system, Singular
reference.tex(,8888) returns the absolute (path) name of the running @sc{Singular} as string.
reference.tex(,8889) @item @code{system("}--@code{")}
reference.tex(,8890) @cindex system, --
reference.tex(,8891) @cindex command-line options, print all values of
reference.tex(,8892) prints the values of all options.
reference.tex(,8893) @item @code{system("}--long_option_name@code{")}
reference.tex(,8894) @cindex command-line option, value of
reference.tex(,8895) @cindex system, --long_option_name
reference.tex(,8896) returns the value of the (command-line) option long_option_name. The
reference.tex(,8897) type of the returned value is either string or int.
reference.tex(,8898) @xref{Command line options}, for more info.
reference.tex(,8899) @item @code{system("}--long_option_name@code{",} expression@code{)}
reference.tex(,8900) @cindex command-line option, setting value of
reference.tex(,8901) @cindex system, --long_option_name=value
reference.tex(,8902) @cindex random number generator, seed
reference.tex(,8903) @cindex browsers, setting the
reference.tex(,8904) @cindex browser, setting the
reference.tex(,8905) @cindex help browsers, setting the
reference.tex(,8906) @cindex timer resolution, setting the
reference.tex(,8907) @cindex minimal display time, setting the
reference.tex(,8908) sets the value of the (command-line) option long_option_name to the
reference.tex(,8909) value given by the expression. Type of the expression must be string, or
reference.tex(,8910) int.  @xref{Command line options}, for more info. Among others,
reference.tex(,8911) this can be used for setting the seed of the random number generator,
reference.tex(,8912) the used help browser, the minimal display time, or the timer
reference.tex(,8913) resolution.
reference.tex(,8914) @item @code{system("browsers");}
reference.tex(,8915) @cindex system, browsers
reference.tex(,8916) returns a string about available help browsers.
reference.tex(,8917) @xref{The online help system}.
reference.tex(,8918) @end table
reference.tex(,8919) @item @strong{Example:}
reference.tex(,8920) @smallexample
reference.tex(,8921) // a listing of the current directory:
reference.tex(,8922) system("sh","ls");
reference.tex(,8923) // execute a shell, return to SINGULAR with exit:
reference.tex(,8924) system("sh","sh");
reference.tex(,8925) string unique_name="/tmp/xx"+string(system("pid"));
reference.tex(,8926) unique_name;
reference.tex(,8927) @expansion{} /tmp/xx4711
reference.tex(,8928) system("uname")
reference.tex(,8929) @expansion{} ix86-Linux
reference.tex(,8930) system("getenv","PATH");
reference.tex(,8931) @expansion{} /bin:/usr/bin:/usr/local/bin
reference.tex(,8932) system("Singular");
reference.tex(,8933) @expansion{} /usr/local/bin/Singular
reference.tex(,8934) // report value of all options
reference.tex(,8935) system("--");
reference.tex(,8936) @expansion{} // --batch           0
reference.tex(,8937) @expansion{} // --execute
reference.tex(,8938) @expansion{} // --sdb             0
reference.tex(,8939) @expansion{} // --echo            0
reference.tex(,8940) @expansion{} // --help            0
reference.tex(,8941) @expansion{} // --quiet           0
reference.tex(,8942) @expansion{} // --random          937848971
reference.tex(,8943) @expansion{} // --no-tty          0
reference.tex(,8944) @expansion{} // --user-option
reference.tex(,8945) @expansion{} // --version         0
reference.tex(,8946) @expansion{} // --allow-net       0
reference.tex(,8947) @expansion{} // --browser
reference.tex(,8948) @expansion{} // --emacs           0
reference.tex(,8949) @expansion{} // --no-stdlib       0
reference.tex(,8950) @expansion{} // --no-rc           0
reference.tex(,8951) @expansion{} // --no-warn         0
reference.tex(,8952) @expansion{} // --no-out          0
reference.tex(,8953) @expansion{} // --min-time        "0.5"
reference.tex(,8954) @expansion{} // --mp-port
reference.tex(,8955) @expansion{} // --mp-host
reference.tex(,8956) @expansion{} // --ticks-per-sec   1
reference.tex(,8957) @expansion{} // --mp-transp
reference.tex(,8958) @expansion{} // --mp-mode
reference.tex(,8959) // set minimal display time to 0.02 seconds
reference.tex(,8960) system("--min-time", "0.02");
reference.tex(,8961) // set timer resolution to 0.01 seconds
reference.tex(,8962) system("--ticks-per-sec", 100);
reference.tex(,8963) // re-seed random number generator
reference.tex(,8964) system("--random", 12345678);
reference.tex(,8965) // allow netscape to access HTML pages from the net
reference.tex(,8966) system("--allow-net", 1);
reference.tex(,8967) // and set help browser to netscape
reference.tex(,8968) system("--browser", "netscape");
reference.tex(,8969) @end smallexample
reference.tex(,8970) @end table
reference.tex(,8971) @c -------------------------------------------------
reference.tex(,8972) @node syz, trace, system, Functions
reference.tex(,8973) @subsection syz
reference.tex(,8974) @cindex syz
reference.tex(,8975) @table @code
reference.tex(,8976) @item @strong{Syntax:}
reference.tex(,8977) @code{syz (} ideal_expression @code{)}
reference.tex(,8978) @*@code{syz (} module_expression @code{)}
reference.tex(,8979) @item @strong{Type:}
reference.tex(,8980) module
reference.tex(,8981) @item @strong{Purpose:}
reference.tex(,8982) computes the first syzygy (i.e., the module of relations of the given
reference.tex(,8983) generators) of the ideal, resp.@: module.
reference.tex(,8984) @item @strong{Example:}
reference.tex(,8985) @smallexample
reference.tex(,8986) @c reused example syz reference.doc:6043 
reference.tex(,8987)   ring R=0,(x,y),(c,dp);
reference.tex(,8988)   ideal i=x,y;
reference.tex(,8989)   syz(i);
reference.tex(,8990) @expansion{} _[1]=[y,-x]
reference.tex(,8991) @c end example syz reference.doc:6043
reference.tex(,8992) @end smallexample
reference.tex(,8993) @end table
reference.tex(,8994) @c inserted refs from reference.doc:6050
reference.tex(,9019) @c end inserted refs from reference.doc:6050
reference.tex(,9020) @c ---------------------------------------
reference.tex(,9021) @node trace, transpose, syz, Functions
reference.tex(,9022) @subsection trace
reference.tex(,9023) @cindex trace
reference.tex(,9024) @table @code
reference.tex(,9025) @item @strong{Syntax:}
reference.tex(,9026) @code{trace (} intmat_expression @code{)}
reference.tex(,9027) @*@code{trace (} matrix_expression @code{)}
reference.tex(,9028) @item @strong{Type:}
reference.tex(,9029) int, if the argument is an intmat, resp.@: @*
reference.tex(,9030) poly, if the argument is a matrix
reference.tex(,9031) @item @strong{Purpose:}
reference.tex(,9032) returns the trace of an intmat, resp.@: matrix.
reference.tex(,9033) @item @strong{Example:}
reference.tex(,9034) @smallexample
reference.tex(,9035) @c reused example trace reference.doc:6076 
reference.tex(,9036)   intmat m[2][2]=1,2,3,4;
reference.tex(,9037)   print(m);
reference.tex(,9038) @expansion{}      1     2
reference.tex(,9039) @expansion{}      3     4
reference.tex(,9040)   trace(m);
reference.tex(,9041) @expansion{} 5
reference.tex(,9042) @c end example trace reference.doc:6076
reference.tex(,9043) @end smallexample
reference.tex(,9044) @end table
reference.tex(,9045) @c inserted refs from reference.doc:6083
reference.tex(,9058) @c end inserted refs from reference.doc:6083
reference.tex(,9059) @c ---------------------------------------
reference.tex(,9060) @node transpose, type, trace, Functions
reference.tex(,9061) @subsection transpose
reference.tex(,9062) @cindex transpose
reference.tex(,9063) @table @code
reference.tex(,9064) @item @strong{Syntax:}
reference.tex(,9065) @code{transpose (} intmat_expression @code{)}
reference.tex(,9066) @*@code{transpose (} matrix_expression @code{)}
reference.tex(,9067) @*@code{transpose (} module_expression @code{)}
reference.tex(,9068) @item @strong{Type:}
reference.tex(,9069) intmat, matrix, or module, corresponding to the argument
reference.tex(,9070) @item @strong{Purpose:}
reference.tex(,9071) transposes a matrix.
reference.tex(,9072) @item @strong{Example:}
reference.tex(,9073) @smallexample
reference.tex(,9074) @c reused example transpose reference.doc:6103 
reference.tex(,9075)   ring R=0,x,dp;
reference.tex(,9076)   matrix m[2][3]=1,2,3,4,5,6;
reference.tex(,9077)   print(m);
reference.tex(,9078) @expansion{} 1,2,3,
reference.tex(,9079) @expansion{} 4,5,6 
reference.tex(,9080)   print(transpose(m));
reference.tex(,9081) @expansion{} 1,4,
reference.tex(,9082) @expansion{} 2,5,
reference.tex(,9083) @expansion{} 3,6 
reference.tex(,9084) @c end example transpose reference.doc:6103
reference.tex(,9085) @end smallexample
reference.tex(,9086) @end table
reference.tex(,9087) @c inserted refs from reference.doc:6111
reference.tex(,9102) @c end inserted refs from reference.doc:6111
reference.tex(,9103) @c ---------------------------------------
reference.tex(,9104) @node type, typeof, transpose, Functions
reference.tex(,9105) @subsection type
reference.tex(,9106) @cindex type
reference.tex(,9107) @table @code
reference.tex(,9108) @item @strong{Syntax:}
reference.tex(,9109) @code{type } name @code{;} @*
reference.tex(,9110) @code{type (} name @code{);}
reference.tex(,9111) @item @strong{Type:}
reference.tex(,9112) none
reference.tex(,9113) @item @strong{Purpose:}
reference.tex(,9114) prints the name, level, type and value of a variable. To display the
reference.tex(,9115) value of an expression, it is sufficient to type the expression followed
reference.tex(,9116) by @code{;}.
reference.tex(,9117) @item @strong{Example:}
reference.tex(,9118) @smallexample
reference.tex(,9119) @c reused example type reference.doc:6133 
reference.tex(,9120)   int i=3;
reference.tex(,9121)   i;
reference.tex(,9122) @expansion{} 3
reference.tex(,9123)   type(i);
reference.tex(,9124) @expansion{} // i                    [0]  int 3
reference.tex(,9125) @c end example type reference.doc:6133
reference.tex(,9126) @end smallexample
reference.tex(,9127) @end table
reference.tex(,9128) @c inserted refs from reference.doc:6140
reference.tex(,9143) @c end inserted refs from reference.doc:6140
reference.tex(,9144) @c ---------------------------------------
reference.tex(,9145) @node typeof, uressolve, type, Functions
reference.tex(,9146) @subsection typeof
reference.tex(,9147) @cindex typeof
reference.tex(,9148) @table @code
reference.tex(,9149) @item @strong{Syntax:}
reference.tex(,9150) @code{typeof (} expression @code{)}
reference.tex(,9151) @item @strong{Type:}
reference.tex(,9152) string
reference.tex(,9153) @item @strong{Purpose:}
reference.tex(,9154) returns the type of an expression as string.
reference.tex(,9155) 
reference.tex(,9156) Returns the type of the first list element if the expression is an
reference.tex(,9157) expression list.
reference.tex(,9158) 
reference.tex(,9159) Possible types are:
reference.tex(,9160) @code{"ideal"},
reference.tex(,9161) @code{"int"},
reference.tex(,9162) @code{"intmat"},
reference.tex(,9163) @code{"intvec"},
reference.tex(,9164) @code{"list"},
reference.tex(,9165) @code{"map"},
reference.tex(,9166) @code{"matrix"},
reference.tex(,9167) @code{"module"},
reference.tex(,9168) @code{"number"},
reference.tex(,9169) @code{"none"},
reference.tex(,9170) @code{"poly"},
reference.tex(,9171) @code{"proc"},
reference.tex(,9172) @code{"qring"},
reference.tex(,9173) @code{"resolution"},
reference.tex(,9174) @code{"ring"},
reference.tex(,9175) @code{"string"},
reference.tex(,9176) @code{"vector"}.
reference.tex(,9177) 
reference.tex(,9178) For internal use only is the type
reference.tex(,9179) @c @code{"package"},
reference.tex(,9180) @code{"?unknown type?"}.
reference.tex(,9181) @item @strong{Example:}
reference.tex(,9182) @smallexample
reference.tex(,9183) @c reused example typeof reference.doc:6185 
reference.tex(,9184)   int i=9; i;
reference.tex(,9185) @expansion{} 9
reference.tex(,9186)   typeof(_);
reference.tex(,9187) @expansion{} int
reference.tex(,9188)   print(i);
reference.tex(,9189) @expansion{} 9
reference.tex(,9190)   typeof(_);
reference.tex(,9191) @expansion{} none
reference.tex(,9192)   type i;
reference.tex(,9193) @expansion{} // i                    [0]  int 9
reference.tex(,9194)   typeof(_);
reference.tex(,9195) @expansion{} string
reference.tex(,9196)   string s=typeof(i);
reference.tex(,9197)   s;
reference.tex(,9198) @expansion{} int
reference.tex(,9199)   typeof(s);
reference.tex(,9200) @expansion{} string
reference.tex(,9201)   proc p() @{  "hello"; return();@}
reference.tex(,9202)   p();
reference.tex(,9203) @expansion{} hello
reference.tex(,9204)   typeof(_);
reference.tex(,9205) @expansion{} none
reference.tex(,9206) @c end example typeof reference.doc:6185
reference.tex(,9207) @end smallexample
reference.tex(,9208) @end table
reference.tex(,9209) @c inserted refs from reference.doc:6201
reference.tex(,9222) @c end inserted refs from reference.doc:6201
reference.tex(,9223) @c ---------------------------------------
reference.tex(,9224) @node uressolve, vandermonde, typeof, Functions
reference.tex(,9225) @subsection uressolve
reference.tex(,9226) @cindex uressolve
reference.tex(,9227) @table @code
reference.tex(,9228) @item @strong{Syntax:}
reference.tex(,9229) @code{uressolve (} ideal_expression@code{,} int_expression@code{,} int_expression@code{,} int_expression @code{)}
reference.tex(,9230) @item @strong{Type:}
reference.tex(,9231) list
reference.tex(,9232) @item @strong{Purpose:}
reference.tex(,9233) computes all complex roots of a zerodimensional ideal. @*
reference.tex(,9234) Makes either use of the multipolynomial resultant of Macaulay (second argument
reference.tex(,9235) = 1), which works only for homogeneous ideals, or uses the sparse resultant
reference.tex(,9236) of Gelfand, Kapranov and Zelevinsky (second argument = 0). @*
reference.tex(,9237) The sparse resultant algorithm uses a mixed polyhedral subdivision of the
reference.tex(,9238) Minkowsky sum of the Newton polytopes in order to construct the sparse
reference.tex(,9239) resultant matrix. Its determinant is a nonzero multiple of the sparse
reference.tex(,9240) resultant. The u-resultant of B.L.@: van der Waerden and Laguerre's algorithm
reference.tex(,9241) are used to determine the complex roots. @*
reference.tex(,9242) The third argument defines the precision of the fractional part if the ground
reference.tex(,9243) field is the field of rational numbers, otherwise it will be ignored. @*
reference.tex(,9244) The fourth argument (can be 0, 1 or 2) gives the number of extra runs of
reference.tex(,9245) Laguerre's algorithm (with corrupted roots), leading to better results.
reference.tex(,9246) @item @strong{Note:}
reference.tex(,9247) If the ground field is the field of complex numbers, the elements of the list
reference.tex(,9248) are of type number, otherwise of type string.
reference.tex(,9249) @item @strong{Example:}
reference.tex(,9250) @smallexample
reference.tex(,9251) @c reused example uressolve reference.doc:6234 
reference.tex(,9252) ring rsc=(real,20,I),(x,y),lp;
reference.tex(,9253) ideal i=(2+3*I)*x2+(0.35+I*45.0e-2)*y2-8,x2+xy+(42.7)*y2;
reference.tex(,9254) list l=uressolve(i,0,0,2);
reference.tex(,9255) l[1];
reference.tex(,9256) @expansion{} [1]:
reference.tex(,9257) @expansion{}    (-1.315392899374542198+I*0.70468233142752928117)
reference.tex(,9258) @expansion{} [2]:
reference.tex(,9259) @expansion{}    (0.12292646536251281054+I*0.19245727404407015049)
reference.tex(,9260) subst(subst(i[1],x,l[1][1]),y,l[1][2]);
reference.tex(,9261) @expansion{} 0
reference.tex(,9262) @c end example uressolve reference.doc:6234
reference.tex(,9263) @end smallexample
reference.tex(,9264) @end table
reference.tex(,9265) @c inserted refs from reference.doc:6243
reference.tex(,9278) @c end inserted refs from reference.doc:6243
reference.tex(,9279) @c ---------------------------------------
reference.tex(,9280) @node vandermonde, var, uressolve, Functions
reference.tex(,9281) @subsection vandermonde
reference.tex(,9282) @cindex vandermonde
reference.tex(,9283) @table @code
reference.tex(,9284) @item @strong{Syntax:}
reference.tex(,9285) @code{vandermonde (} ideal_expression@code{,} ideal_expression@code{,}
reference.tex(,9286) int_expression @code{)}
reference.tex(,9287) @item @strong{Type:}
reference.tex(,9288) poly
reference.tex(,9289) @item @strong{Purpose:}
reference.tex(,9318) @item @strong{Note:}
reference.tex(,9333) @item @strong{Example:}
reference.tex(,9334) @smallexample
reference.tex(,9335) @c reused example vandermonde reference.doc:6304 
reference.tex(,9336) ring r=0,(x,y),dp;
reference.tex(,9337) // determine f with deg(f)=2 and with given values v of f
reference.tex(,9338) // at 9 points: (2,3)^0=(1,1),...,(2,3)^8=(2^8,3^8)
reference.tex(,9339) // valuation point: (2,3)
reference.tex(,9340) ideal p=2,3;
reference.tex(,9341) ideal v=1,2,3,4,5,6,7,8,9;
reference.tex(,9342) poly ip=vandermonde(p,v,2);
reference.tex(,9343) ip[1..5];  //  the 5 first terms of ip:
reference.tex(,9344) @expansion{} -1/9797760x2y2-595/85536x2y+55/396576xy2+935/384x2-1309/3240xy
reference.tex(,9345) // compute value of ip at the point 2^8,3^8, result must be 9
reference.tex(,9346) subst(subst(ip,x,2^8),y,3^8);
reference.tex(,9347) @expansion{} 9
reference.tex(,9348) @c end example vandermonde reference.doc:6304
reference.tex(,9349) @end smallexample
reference.tex(,9350) @end table
reference.tex(,9351) @c inserted refs from reference.doc:6318
reference.tex(,9360) @c end inserted refs from reference.doc:6318
reference.tex(,9361) @c ---------------------------------------
reference.tex(,9362) @node var, varstr, vandermonde, Functions
reference.tex(,9363) @subsection var
reference.tex(,9364) @cindex var
reference.tex(,9365) @table @code
reference.tex(,9366) @item @strong{Syntax:}
reference.tex(,9367) @code{var (} int_expression @code{)}
reference.tex(,9368) @item @strong{Type:}
reference.tex(,9369) poly
reference.tex(,9370) @item @strong{Purpose:}
reference.tex(,9371) @code{var(n)} returns the n-th ring variable.
reference.tex(,9372) @item @strong{Example:}
reference.tex(,9373) @smallexample
reference.tex(,9374) @c reused example var reference.doc:6333 
reference.tex(,9375)   ring r=0,(x,y,z),dp;
reference.tex(,9376)   var(2);
reference.tex(,9377) @expansion{} y
reference.tex(,9378) @c end example var reference.doc:6333
reference.tex(,9379) @end smallexample
reference.tex(,9380) @end table
reference.tex(,9381) @c inserted refs from reference.doc:6339
reference.tex(,9398) @c end inserted refs from reference.doc:6339
reference.tex(,9399) @c ---------------------------------------
reference.tex(,9400) @node varstr, vdim, var, Functions
reference.tex(,9401) @subsection varstr
reference.tex(,9402) @cindex varstr
reference.tex(,9403) @table @code
reference.tex(,9404) @item @strong{Syntax:}
reference.tex(,9405) @code{varstr (} ring_name @code{)}
reference.tex(,9406) @*@code{varstr (} int_expression @code{)}
reference.tex(,9407) @*@code{varstr (} ring_name@code{,} int_expression @code{)}
reference.tex(,9408) @item @strong{Type:}
reference.tex(,9409) string
reference.tex(,9410) @item @strong{Purpose:}
reference.tex(,9411) returns the list of the names of the ring variables as a string
reference.tex(,9412) or the name of the n-th ring variable, where n is given by the
reference.tex(,9413) int_expression.
reference.tex(,9414) @*If the ring name is omitted, the basering is used, thus
reference.tex(,9415) @code{varstr(n)} is equivalent to @code{varstr(basering,n)}.
reference.tex(,9416) @item @strong{Example:}
reference.tex(,9417) @smallexample
reference.tex(,9418) @c reused example varstr reference.doc:6365 
reference.tex(,9419)   ring r=0,(x,y,z),dp;
reference.tex(,9420)   varstr(r);
reference.tex(,9421) @expansion{} x,y,z
reference.tex(,9422)   varstr(r,1);
reference.tex(,9423) @expansion{} x
reference.tex(,9424)   varstr(2);
reference.tex(,9425) @expansion{} y
reference.tex(,9426) @c end example varstr reference.doc:6365
reference.tex(,9427) @end smallexample
reference.tex(,9428) @end table
reference.tex(,9429) @c inserted refs from reference.doc:6373
reference.tex(,9452) @c end inserted refs from reference.doc:6373
reference.tex(,9453) @c ---------------------------------------
reference.tex(,9454) @node vdim, wedge, varstr, Functions
reference.tex(,9455) @subsection vdim
reference.tex(,9456) @cindex vdim
reference.tex(,9457) @table @code
reference.tex(,9458) @item @strong{Syntax:}
reference.tex(,9459) @code{vdim (} ideal_expression @code{)}
reference.tex(,9460) @*@code{vdim (} module_expression @code{)}
reference.tex(,9461) @item @strong{Type:}
reference.tex(,9462) int
reference.tex(,9463) @item @strong{Purpose:}
reference.tex(,9464) computes the vector space dimension of the ring, resp.@: free module,
reference.tex(,9465) modulo the ideal, resp.@: module,
reference.tex(,9466) generated by the initial terms of the given generators.
reference.tex(,9467) If the generators form a standard basis,
reference.tex(,9468) this is the same as the vector space dimension of the ring, resp.@:
reference.tex(,9469) free module, modulo the ideal, resp.@: module.
reference.tex(,9470) @*If the ideal, resp.@: module, is not zero-dimensional, -1 is returned.
reference.tex(,9471) @item @strong{Example:}
reference.tex(,9472) @smallexample
reference.tex(,9473) @c reused example vdim reference.doc:6403 
reference.tex(,9474)   ring r=0,(x,y),ds;
reference.tex(,9475)   ideal i=x2+y2,x2-y2;
reference.tex(,9476)   ideal j=std(i);
reference.tex(,9477)   vdim(j);
reference.tex(,9478) @expansion{} 4
reference.tex(,9479) @c end example vdim reference.doc:6403
reference.tex(,9480) @end smallexample
reference.tex(,9481) @end table
reference.tex(,9482) @c inserted refs from reference.doc:6411
reference.tex(,9503) @c end inserted refs from reference.doc:6411
reference.tex(,9504) @c ---------------------------------------
reference.tex(,9505) @node wedge, weight, vdim, Functions
reference.tex(,9506) @subsection wedge
reference.tex(,9507) @cindex wedge
reference.tex(,9508) @table @code
reference.tex(,9509) @item @strong{Syntax:}
reference.tex(,9510) @code{wedge (} matrix_expression@code{,} int_expression @code{)}
reference.tex(,9511) @item @strong{Type:}
reference.tex(,9512) matrix
reference.tex(,9513) @item @strong{Purpose:}
reference.tex(,9514) @code{wedge(M,n)} computes the @code{n}-th exterior power of the matrix
reference.tex(,9515) @code{M}.
reference.tex(,9516) @item @strong{Example:}
reference.tex(,9517) @smallexample
reference.tex(,9518) @c reused example wedge reference.doc:6434 
reference.tex(,9519)   ring r;
reference.tex(,9520)   matrix m[2][3]=x,y,y,z,z,x;
reference.tex(,9521)   print(m);
reference.tex(,9522) @expansion{} x,y,y,
reference.tex(,9523) @expansion{} z,z,x 
reference.tex(,9524)   print(wedge(m,2));
reference.tex(,9525) @expansion{} xz-yz,-x2+yz,xy-yz
reference.tex(,9526) @c end example wedge reference.doc:6434
reference.tex(,9527) @end smallexample
reference.tex(,9528) @end table
reference.tex(,9529) @c inserted refs from reference.doc:6442
reference.tex(,9544) @c end inserted refs from reference.doc:6442
reference.tex(,9545) @c ---------------------------------------
reference.tex(,9546) @node weight, write, wedge, Functions
reference.tex(,9547) @subsection weight
reference.tex(,9548) @cindex weight
reference.tex(,9549) @table @code
reference.tex(,9550) @item @strong{Syntax:}
reference.tex(,9551) @code{weight (} ideal_expression @code{)}
reference.tex(,9552) @*@code{weight (} module_expression @code{)}
reference.tex(,9553) @item @strong{Type:}
reference.tex(,9554) intvec
reference.tex(,9555) @item @strong{Purpose:}
reference.tex(,9556) computes an "optimal" weight vector for an ideal, resp.@: module,
reference.tex(,9557) which may be used as weight vector for the variables in order to speed
reference.tex(,9558) up the standard basis algorithm. If the input is weighted homogeneous,
reference.tex(,9559) a weight vector for which the input is weighted homogeneous is found.
reference.tex(,9560) @item @strong{Example:}
reference.tex(,9561) @smallexample
reference.tex(,9562) @c reused example weight reference.doc:6465 
reference.tex(,9563)   ring h1=32003,(t,x,y,z),dp;
reference.tex(,9564)   ideal i=
reference.tex(,9565)   9x8+y7t3z4+5x4y2t2+2xy2z3t2,
reference.tex(,9566)   9y8+7xy6t+2x5y4t2+2x2yz3t2,
reference.tex(,9567)   9z8+3x2y3z2t4;
reference.tex(,9568)   intvec e=weight(i);
reference.tex(,9569)   e;
reference.tex(,9570) @expansion{} 5,7,5,7
reference.tex(,9571)   ring r=32003,(a,b,c,d),wp(e);
reference.tex(,9572)   map f=h1,a,b,c,d;
reference.tex(,9573)   ideal i0=std(f(i));
reference.tex(,9574) @c end example weight reference.doc:6465
reference.tex(,9575) @end smallexample
reference.tex(,9576) @end table
reference.tex(,9577) @c inserted refs from reference.doc:6479
reference.tex(,9592) @c end inserted refs from reference.doc:6479
reference.tex(,9593) @c ---------------------------------------
reference.tex(,9594) @node  write,  , weight, Functions
reference.tex(,9595) @subsection write
reference.tex(,9596) @cindex write
reference.tex(,9597) @table @code
reference.tex(,9598) @item @strong{Syntax:}
reference.tex(,9599) @code{write (} link_expression@code{,} expression_list @code{)}
reference.tex(,9600) @*for DBM links:
reference.tex(,9601) @*@code{write (} link@code{,} string_expression@code{,} string_expression @code{)}
reference.tex(,9602) @*@code{write (} link@code{,} string_expression @code{)}
reference.tex(,9603) @item @strong{Type:}
reference.tex(,9604) none
reference.tex(,9605) @item @strong{Purpose:}
reference.tex(,9606) writes data to a link.
reference.tex(,9607) @*If the link is of type @code{ASCII}, all expressions are converted to
reference.tex(,9608) strings  (and separated by a newline character) before they are
reference.tex(,9609) written. As a consequence, only such values which can be converted to a
reference.tex(,9610) string can be written to an  @code{ASCII} link.
reference.tex(,9611) @*For MP links,
reference.tex(,9612) ring-dependent expressions are written together with a ring
reference.tex(,9613) description. To prevent an evaluation of the expression before it is
reference.tex(,9614) written, the @code{quote} command (possibly together with @code{eval})
reference.tex(,9615) can be used. A @code{write} blocks (i.e., does not return to the prompt),
reference.tex(,9616) as long as a MPtcp link is not ready for writing.
reference.tex(,9617) @*For DBM links, @code{write} with three arguments inserts the first
reference.tex(,9618) string as key and the second string as value into the dbm data
reference.tex(,9619) base.
reference.tex(,9620) @*Called with two arguments, it deletes the entry with the key
reference.tex(,9621) specified by the string from the data base.
reference.tex(,9622) @item @strong{Example:}
reference.tex(,9623) @smallexample
reference.tex(,9624) // write the values of the variables f and i as strings into
reference.tex(,9625) // the file "outfile" (overwrite it, if it exists)
reference.tex(,9626) write(":w outfile",f,i);
reference.tex(,9627) 
reference.tex(,9628) // now append the string "that was f,i" (without the quotes)
reference.tex(,9629) // at the end of the file "outfile"
reference.tex(,9630) write(":a outfile","that was f,i");
reference.tex(,9631) // alternatively, links could be used:
reference.tex(,9632) link l=":a outfile"; l;
reference.tex(,9633) // type : ASCII
reference.tex(,9634) // mode : a
reference.tex(,9635) // name : outfile
reference.tex(,9636) // open : no
reference.tex(,9637) // read : not ready
reference.tex(,9638) // write: not ready
reference.tex(,9639) write(l," that was f,i");
reference.tex(,9640) // saving and retrieving data (ASCII format):
reference.tex(,9641) ring r=32003,(x,y,z),dp;
reference.tex(,9642) ideal i=x+y,z3+22y;
reference.tex(,9643) write(":w save_i",i);// this writes x+y,z3+22y to the file save_i
reference.tex(,9644) ring r=32003,(x,y,z),dp;
reference.tex(,9645) string s=read("save_i");   //creates the string x+y,z3+22y
reference.tex(,9646) execute("ideal k="+s+";"); // this defines an ideal k which
reference.tex(,9647)                            // is equal to i.
reference.tex(,9648) // for large objects, the MP format and MPfile links are better:
reference.tex(,9649) write("MPfile:w save_i.mp",i);
reference.tex(,9650) def j=read("MPfile:r save_i.mp");
reference.tex(,9651) @end smallexample
reference.tex(,9652) @end table
reference.tex(,9653) @c inserted refs from reference.doc:6545
reference.tex(,9680) @c end inserted refs from reference.doc:6545
reference.tex(,9681) 
reference.tex(,9682) 
reference.tex(,9683) @c ---------------------------------------
reference.tex(,9684) @node Control structures, System variables, Functions, Functions and system variables
reference.tex(,9685) @section Control structures
reference.tex(,9686) @cindex Control structures
reference.tex(,9687) @cindex block
reference.tex(,9691) @menu
reference.tex(,9692) * break::
reference.tex(,9693) * breakpoint::
reference.tex(,9694) * continue::
reference.tex(,9695) * else::
reference.tex(,9696) * export::
reference.tex(,9697) * for::
reference.tex(,9698) * if::
reference.tex(,9699) * keepring::
reference.tex(,9700) * quit::
reference.tex(,9701) * return::
reference.tex(,9702) * while::
reference.tex(,9703) * ~::
reference.tex(,9710) @end menu
reference.tex(,9711) 
reference.tex(,9712) A sequence of commands surrounded by curly brackets (@code{@{} and
reference.tex(,9713) @code{@}}) is a so called block. Blocks are used in @sc{Singular} in
reference.tex(,9714) order to define procedures and to collect commands belonging to
reference.tex(,9715) @code{if}, @code{else}, @code{for} and @code{while} statements and to the
reference.tex(,9716) @code{example} part in libraries. Even if
reference.tex(,9717) the sequence of statements consists of only a single command it has to be
reference.tex(,9718) surrounded by curly brackets!
reference.tex(,9719) Variables which are defined inside a block
reference.tex(,9720) are not local to that block. Note that there is no ending semicolon at
reference.tex(,9721) the end of the block.
reference.tex(,9722) @table @code
reference.tex(,9723) @item @strong{Example:}
reference.tex(,9724) @smallexample
reference.tex(,9725) if ( i>j )
reference.tex(,9726) @{
reference.tex(,9727)   // This is the block
reference.tex(,9728)   int temp;
reference.tex(,9729)   temp=i;
reference.tex(,9730)   i=j;
reference.tex(,9731)   j=temp;
reference.tex(,9732)   kill temp;
reference.tex(,9733) @}
reference.tex(,9734) @end smallexample
reference.tex(,9735) @end table
reference.tex(,9736) 
reference.tex(,9737) @c ---------------------------------------
reference.tex(,9738) @node break, breakpoint, Control structures, Control structures
reference.tex(,9739) @subsection break
reference.tex(,9740) @cindex break
reference.tex(,9741) @table @code
reference.tex(,9742) @item @strong{Syntax:}
reference.tex(,9743) @code{break;}
reference.tex(,9744) @item @strong{Purpose:}
reference.tex(,9745) leaves the innermost @code{for} or @code{while} block.
reference.tex(,9746) @item @strong{Example:}
reference.tex(,9747) @smallexample
reference.tex(,9748) while (1)
reference.tex(,9749) @{
reference.tex(,9750)   @dots{}
reference.tex(,9751)   if ( @dots{} )
reference.tex(,9752)   @{
reference.tex(,9753)     break; // leave the while block
reference.tex(,9754)   @}
reference.tex(,9755) @}
reference.tex(,9756) @end smallexample
reference.tex(,9757) @end table
reference.tex(,9758) @c inserted refs from reference.doc:6634
reference.tex(,9773) @c end inserted refs from reference.doc:6634
reference.tex(,9774) @c ---------------------------------------
reference.tex(,9775) @node breakpoint, continue, break, Control structures
reference.tex(,9776) @subsection breakpoint
reference.tex(,9777) @cindex breakpoint
reference.tex(,9778) @table @code
reference.tex(,9779) @item @strong{Syntax:}
reference.tex(,9780) @code{breakpoint(} proc_name @code{);}
reference.tex(,9781) @*@code{breakpoint(} proc_name@code{,} line_no @code{);}
reference.tex(,9782) @item @strong{Purpose:}
reference.tex(,9783) sets a breakpoint at the beginning of the specified procedure or
reference.tex(,9784) at the given line.
reference.tex(,9785) @strong{Note:} Line number 1 is the first line of a library (for
reference.tex(,9786) procedures from libraries), resp.@: the line with the @code{@{}.
reference.tex(,9787) @*A line number of -1 removes all breakpoint from that procedure.
reference.tex(,9788) @item @strong{Example:}
reference.tex(,9789) @smallexample
reference.tex(,9790) @c reused example breakpoint reference.doc:6656 
reference.tex(,9791) breakpoint(groebner);
reference.tex(,9792) @expansion{} breakpoint 1, at line 163 in groebner
reference.tex(,9793) breakpoint(groebner, 176);
reference.tex(,9794) @expansion{} breakpoint 2, at line 176 in groebner
reference.tex(,9795) breakpoint(groebner, -1);
reference.tex(,9796) @expansion{} breakpoints in groebner deleted(0x6)
reference.tex(,9797) @c end example breakpoint reference.doc:6656
reference.tex(,9798) @end smallexample
reference.tex(,9799) @end table
reference.tex(,9800) @c inserted refs from reference.doc:6663
reference.tex(,9813) @c end inserted refs from reference.doc:6663
reference.tex(,9814) @c ---------------------------------------
reference.tex(,9815) @node continue, else, breakpoint, Control structures
reference.tex(,9816) @subsection continue
reference.tex(,9817) @cindex continue
reference.tex(,9818) @table @code
reference.tex(,9819) @item @strong{Syntax:}
reference.tex(,9820) @code{continue;}
reference.tex(,9821) @item @strong{Purpose:}
reference.tex(,9822) skips the rest of the innermost @code{for} or @code{while} loop und jumps
reference.tex(,9823) to the beginning of the block. This command is only valid inside a
reference.tex(,9824) @code{for} or a @code{while} construction.
reference.tex(,9825) @item @strong{Note:}
reference.tex(,9826) Unlike the C-construct it @strong{does not execute the increment statement}.
reference.tex(,9827) The command @code{continue} is mainly for internal use.
reference.tex(,9828) @item @strong{Example:}
reference.tex(,9829) @smallexample
reference.tex(,9830) for (int i = 1 ; i<=10; i=i+1)
reference.tex(,9831) @{
reference.tex(,9832)    @dots{}
reference.tex(,9833)    if (i==3) @{ i=8;continue; @}
reference.tex(,9834)      // skip the rest if i is 3 and
reference.tex(,9835)      // continue with the next i: 8
reference.tex(,9836)    i;
reference.tex(,9837) @}
reference.tex(,9838) @expansion{} 1
reference.tex(,9839) @expansion{} 2
reference.tex(,9840) @expansion{} 8
reference.tex(,9841) @expansion{} 9
reference.tex(,9842) @expansion{} 10
reference.tex(,9843) @end smallexample
reference.tex(,9844) @end table
reference.tex(,9845) @c inserted refs from reference.doc:6699
reference.tex(,9860) @c end inserted refs from reference.doc:6699
reference.tex(,9861) @c ---------------------------------------
reference.tex(,9862) @node else, export, continue, Control structures
reference.tex(,9863) @subsection else
reference.tex(,9864) @table @code
reference.tex(,9865) @item @strong{Syntax:}
reference.tex(,9866) @code{if (} boolean_expression @code{)} true_block @code{else} false_block
reference.tex(,9867) @item @strong{Purpose:}
reference.tex(,9868) executes false_block if the boolean_expression of the @code{if} statement
reference.tex(,9869) is false. This command is only valid in combination with an @code{if}
reference.tex(,9870) command.
reference.tex(,9871) @item @strong{Example:}
reference.tex(,9872) @smallexample
reference.tex(,9873) int i=3;
reference.tex(,9874) if (i > 5)
reference.tex(,9875) @{
reference.tex(,9876)   "i is bigger than 5";
reference.tex(,9877) @}
reference.tex(,9878) else
reference.tex(,9879) @{
reference.tex(,9880)   "i is smaller than 6";
reference.tex(,9881) @}
reference.tex(,9882) @expansion{} i is smaller than 6
reference.tex(,9883) @end smallexample
reference.tex(,9884) @end table
reference.tex(,9885) @c inserted refs from reference.doc:6729
reference.tex(,9900) @c end inserted refs from reference.doc:6729
reference.tex(,9901) @c ---------------------------------------
reference.tex(,9906) @node export, for, else, Control structures
reference.tex(,9908) @subsection export
reference.tex(,9909) @cindex export
reference.tex(,9910) @table @code
reference.tex(,9911) @item @strong{Syntax:}
reference.tex(,9912) @code{export} name @code{;}
reference.tex(,9913) @*@code{export} list_of_names @code{;}
reference.tex(,9914) @item @strong{Purpose:}
reference.tex(,9915) converts a local variable of a procedure to a global one.
reference.tex(,9916) @item @strong{Note:}
reference.tex(,9917) Objects defined in a ring are not automatically exported
reference.tex(,9918) when exporting the ring (use @code{keepring} instead).
reference.tex(,9919) @item @strong{Example:}
reference.tex(,9920) @smallexample
reference.tex(,9921) proc p1
reference.tex(,9922) @{
reference.tex(,9923)   int i,j;
reference.tex(,9924)   export(i);
reference.tex(,9925)   intmat m;
reference.tex(,9926)   listvar();
reference.tex(,9927)   export(m);
reference.tex(,9928) @}
reference.tex(,9929) p1();
reference.tex(,9930) @expansion{} // m                    [1]  intmat 1 x 1
reference.tex(,9931) @expansion{} // j                    [1]  int 0
reference.tex(,9932) @expansion{} // i                    [0]  int 0
reference.tex(,9933) listvar();
reference.tex(,9934) @expansion{} // m                    [0]  intmat 1 x 1
reference.tex(,9935) @expansion{} // i                    [0]  int 0
reference.tex(,9936) @end smallexample
reference.tex(,9937) @end table
reference.tex(,9938) 
reference.tex(,9956) @c inserted refs from reference.doc:6780
reference.tex(,9967) @c end inserted refs from reference.doc:6780
reference.tex(,9969) @c ---------------------------------------
reference.tex(,10198) @c ---------------------------------------
reference.tex(,10203) @node for, if, export, Control structures
reference.tex(,10205) @subsection for
reference.tex(,10206) @cindex for
reference.tex(,10207) @table @code
reference.tex(,10208) @item @strong{Syntax:}
reference.tex(,10209) @code{for (} init_command@code{;}
reference.tex(,10210) boolean_expression@code{;}
reference.tex(,10211) iterate_commands@code{)} block
reference.tex(,10212) @item @strong{Purpose:}
reference.tex(,10213) repetitive, conditional execution of a command block.
reference.tex(,10214) @*The command init_command is executed first. Then boolean_expression is
reference.tex(,10215) evaluated. If its value is TRUE the block is executed, otherwise the
reference.tex(,10216) @code{for} statement is complete. After each execution of the block, the
reference.tex(,10217) command iterate_command is executed and boolean_expression is
reference.tex(,10218) evaluated. This is repeated until boolean_expression evaluates to FALSE.
reference.tex(,10219) @*The command @code{break;} leaves the innermost @code{for} construct.
reference.tex(,10220) @item @strong{Example:}
reference.tex(,10221) @smallexample
reference.tex(,10222) // sum of 1 to 10:
reference.tex(,10223) int s=0;
reference.tex(,10224) for (int i=1; i<=10; i=i+1)
reference.tex(,10225) @{
reference.tex(,10226)    s=s+i;
reference.tex(,10227) @}
reference.tex(,10228) s;
reference.tex(,10229) @expansion{} 55
reference.tex(,10230) @end smallexample
reference.tex(,10231) @end table
reference.tex(,10232) @c inserted refs from reference.doc:7004
reference.tex(,10253) @c end inserted refs from reference.doc:7004
reference.tex(,10254) @c ---------------------------------------
reference.tex(,10255) @node if, keepring, for, Control structures
reference.tex(,10256) @subsection if
reference.tex(,10257) @cindex if
reference.tex(,10258) @cindex else
reference.tex(,10259) @table @code
reference.tex(,10260) @item @strong{Syntax:}
reference.tex(,10261) @code{if (} boolean_expression @code{)} true_block
reference.tex(,10262) @*@code{if (} boolean_expression @code{)} true_block @code{else} false_block
reference.tex(,10263) @item @strong{Purpose:}
reference.tex(,10264) executes true_block if the boolean condition is true. If the @code{if}
reference.tex(,10265) statement is followed by an @code{else} statement and the boolean
reference.tex(,10266) condition is false, then false_block is executed.
reference.tex(,10267) @item @strong{Example:}
reference.tex(,10268) @smallexample
reference.tex(,10269) int i = 9;
reference.tex(,10270) matrix m[i][i];
reference.tex(,10271) if (i > 5 and typeof(m) == "matrix")
reference.tex(,10272) @{
reference.tex(,10273)   m[i][i] = i;
reference.tex(,10274) @}
reference.tex(,10275) @end smallexample
reference.tex(,10276) @end table
reference.tex(,10277) @c inserted refs from reference.doc:7036
reference.tex(,10294) @c end inserted refs from reference.doc:7036
reference.tex(,10295) @c ---------------------------------------
reference.tex(,10296) @node keepring, quit, if, Control structures
reference.tex(,10297) @subsection keepring
reference.tex(,10298) @cindex keepring
reference.tex(,10299) @table @code
reference.tex(,10300) @item @strong{Syntax:}
reference.tex(,10301) @code{keepring} name @code{;}
reference.tex(,10302) @item @strong{Purpose:}
reference.tex(,10303) moves the specified ring to the next (upper) level. This command can only
reference.tex(,10304) be used inside of procedures and it should be the last command before the
reference.tex(,10305) @code{return} statement. There it provides the possibility to keep
reference.tex(,10306) a ring which is local to the procedure (and its objects) accessible after
reference.tex(,10307) the procedure ended without making the ring global.
reference.tex(,10308) @item @strong{Example:}
reference.tex(,10309) @smallexample
reference.tex(,10310) proc P1
reference.tex(,10311) @{
reference.tex(,10312)   ring r=0,x,dp;
reference.tex(,10313)   keepring r;
reference.tex(,10314) @}
reference.tex(,10315) proc P2
reference.tex(,10316) @{
reference.tex(,10317)   "inside P2: " + nameof(basering);
reference.tex(,10318)   P1();
reference.tex(,10319)   "inside P2, after call of P1: " + nameof(basering);
reference.tex(,10320) @}
reference.tex(,10321) ring r1= 0,y,dp;
reference.tex(,10322) P2();
reference.tex(,10323) @expansion{} inside P2: r1
reference.tex(,10324) @expansion{} inside P2, after call of P1: r
reference.tex(,10325) "at top level: " + nameof(basering);
reference.tex(,10326) @expansion{} at top level: r1
reference.tex(,10327) @end smallexample
reference.tex(,10328) @end table
reference.tex(,10329) @c inserted refs from reference.doc:7077
reference.tex(,10340) @c end inserted refs from reference.doc:7077
reference.tex(,10341) @c ---------------------------------------
reference.tex(,10342) @node quit, return, keepring, Control structures
reference.tex(,10343) @subsection quit
reference.tex(,10344) @cindex quit
reference.tex(,10345) @cindex exit
reference.tex(,10346) @table @code
reference.tex(,10347) @item @strong{Syntax:}
reference.tex(,10348) @code{quit;}
reference.tex(,10349) @item @strong{Purpose:}
reference.tex(,10350) quits @sc{Singular};
reference.tex(,10351) works also from inside a procedure. The commands @code{quit} and
reference.tex(,10352) @code{exit} are synonymous.
reference.tex(,10353) @item @strong{Example:}
reference.tex(,10354) @smallexample
reference.tex(,10355)   quit;
reference.tex(,10356) @end smallexample
reference.tex(,10357) @end table
reference.tex(,10358) @c ---------------------------------------
reference.tex(,10359) @node return, while, quit, Control structures
reference.tex(,10360) @subsection return
reference.tex(,10361) @cindex return
reference.tex(,10362) @table @code
reference.tex(,10363) @item @strong{Syntax:}
reference.tex(,10364) @code{return (} expression_list @code{);}
reference.tex(,10365) @*@code{return ();}
reference.tex(,10366) @item @strong{Type:}
reference.tex(,10367) any
reference.tex(,10368) @item @strong{Purpose:}
reference.tex(,10369) returns the result(s) of a procedure and can only be used inside a
reference.tex(,10370) procedure. Note that the brackets are required even if no return value
reference.tex(,10371) is given.
reference.tex(,10372) @item @strong{Example:}
reference.tex(,10373) @smallexample
reference.tex(,10374) proc p2
reference.tex(,10375) @{
reference.tex(,10376)   int i,j;
reference.tex(,10377)   for(i=1;i<=10;i++)
reference.tex(,10378)   @{
reference.tex(,10379)     j=j+i;
reference.tex(,10380)   @}
reference.tex(,10381)   return(j);
reference.tex(,10382) @}
reference.tex(,10383) // can also return an expression list, i.e., more than one value
reference.tex(,10384) proc tworeturn ()
reference.tex(,10385) @{ return (1,2); @}
reference.tex(,10386) int i,j = tworeturn();
reference.tex(,10387) // return type may even depend on the input
reference.tex(,10388) proc type_return (int i)
reference.tex(,10389) @{
reference.tex(,10390)   if (i > 0) @{return (i);@}
reference.tex(,10391)   else @{return (list(i));@}
reference.tex(,10392) @}
reference.tex(,10393) // then we need def type (or list) to collect value
reference.tex(,10394) def t1 = type_return(1);
reference.tex(,10395) def t2 = type_return(-1);
reference.tex(,10396) @end smallexample
reference.tex(,10397) @end table
reference.tex(,10398) @c inserted refs from reference.doc:7138
reference.tex(,10411) @c end inserted refs from reference.doc:7138
reference.tex(,10412) @c ---------------------------------------
reference.tex(,10413) @node while, ~ , return, Control structures
reference.tex(,10414) @subsection while
reference.tex(,10415) @cindex while
reference.tex(,10416) @table @code
reference.tex(,10417) @item @strong{Syntax:}
reference.tex(,10418) @code{while (}boolean_expression@code{)} block
reference.tex(,10419) @item @strong{Purpose:}
reference.tex(,10420) repetitive, conditional execution of block.
reference.tex(,10421) @*The boolean_expression is evaluated and if its value is TRUE, the
reference.tex(,10422) block gets executed. This is repeated until boolean_expression evaluates
reference.tex(,10423) to FALSE.  The command @code{break} leaves the innermost @code{while}
reference.tex(,10424) construction.
reference.tex(,10425) @item @strong{Example:}
reference.tex(,10426) @smallexample
reference.tex(,10427) int i = 9;
reference.tex(,10428) while (i>0)
reference.tex(,10429) @{
reference.tex(,10430)    // @dots{} // do something for i=9, 8, ..., 1
reference.tex(,10431)    i = i - 1;
reference.tex(,10432) @}
reference.tex(,10433) while (1)
reference.tex(,10434) @{
reference.tex(,10435)    // @dots{}   // do something forever
reference.tex(,10436)    if (i == -5) // but leave the loop if i is -5
reference.tex(,10437)    @{
reference.tex(,10438)      break;
reference.tex(,10439)    @}
reference.tex(,10440) @}
reference.tex(,10441) @end smallexample
reference.tex(,10442) @end table
reference.tex(,10443) @c inserted refs from reference.doc:7174
reference.tex(,10458) @c end inserted refs from reference.doc:7174
reference.tex(,10459) 
reference.tex(,10460) @c ---------------------------------------
reference.tex(,10461) @node ~, , while, Control structures
reference.tex(,10462) @subsection ~ (break point)
reference.tex(,10463) @cindex ~
reference.tex(,10464) @cindex break point
reference.tex(,10465) @table @code
reference.tex(,10466) @item @strong{Syntax:}
reference.tex(,10467) @code{~;}
reference.tex(,10468) @item @strong{Purpose:}
reference.tex(,10469) sets a break point. Whenever @sc{Singular} reaches the command @code{~;}
reference.tex(,10470) in a sequence of commands it prompts for input. The user may now input
reference.tex(,10471) lines of @sc{Singular} commands. The line length cannot exceed 80
reference.tex(,10472) characters.
reference.tex(,10473) @sc{Singular} proceeds with the execution of the command following @code{~;}
reference.tex(,10474) as soon as it receives an empty line.
reference.tex(,10475) @item @strong{Example:}
reference.tex(,10476) @smallexample
reference.tex(,10477) proc t
reference.tex(,10478) @{
reference.tex(,10479)   int i=2;
reference.tex(,10480)   ~;
reference.tex(,10481)   return(i+1);
reference.tex(,10482) @}
reference.tex(,10483) t();
reference.tex(,10484) @expansion{} -- break point in t --
reference.tex(,10485) @expansion{} -- 0: called    from STDIN --
reference.tex(,10486) // here local variables of the procedure can be accessed
reference.tex(,10487) i;
reference.tex(,10488) @expansion{} 2
reference.tex(,10489) @expansion{} -- break point in t --
reference.tex(,10490) 
reference.tex(,10491) @expansion{} 3
reference.tex(,10492) @end smallexample
reference.tex(,10493) @end table
reference.tex(,10494) @c inserted refs from reference.doc:7215
reference.tex(,10505) @c end inserted refs from reference.doc:7215
reference.tex(,10506) 
reference.tex(,10507) @c ---------------------------------------
reference.tex(,10508) @node System variables,  , Control structures, Functions and system variables
reference.tex(,10509) @section System variables
reference.tex(,10510) @cindex System variables
reference.tex(,10514) @menu
reference.tex(,10515) * degBound::
reference.tex(,10516) * echo::
reference.tex(,10517) * minpoly::
reference.tex(,10518) * multBound::
reference.tex(,10519) * noether::
reference.tex(,10520) * printlevel::
reference.tex(,10521) * short::
reference.tex(,10522) * timer::
reference.tex(,10523) * TRACE var::
reference.tex(,10524) * rtimer::
reference.tex(,10525) * voice::
reference.tex(,10526) @end menu
reference.tex(,10527) @c ---------------------------------------
reference.tex(,10528) @c @node alternating, degBound, System variables, System variables
reference.tex(,10529) @c @subsection alternating
reference.tex(,10530) @c @cindex alternating
reference.tex(,10531) @c @table @code
reference.tex(,10532) @c @item @strong{Syntax:}
reference.tex(,10533) @c @code{alternating =} int_expression@code{;}
reference.tex(,10534) @c @*int_variable @code{= alternating;}
reference.tex(,10535) @c @item @strong{Purpose:}
reference.tex(,10536) @c describes the position of the first alternating variable in the current
reference.tex(,10537) @c basering, thus creating the tensor
reference.tex(,10538) @c product of a polynomial ring with an exterior algebra.
reference.tex(,10539) @c @*Remark: Setting @code{alternating=1;} defines the exterior algebra.
reference.tex(,10540) @c @item @strong{Note:}
reference.tex(,10541) @c These algebras are only available in those versions of
reference.tex(,10542) @c @sc{Singular} which are compiled with the SRING option.
reference.tex(,10543) @c The SRING version is
reference.tex(,10544) @c significantly slower for usual (commutative) ring operations.
reference.tex(,10545) @c @item @strong{Example:}
reference.tex(,10546) @c @example
reference.tex(,10547) @c   // define the exterior algebra in 3 variables x, y, z
reference.tex(,10548) @c   ring r=0,(x,y,z),dp;
reference.tex(,10549) @c   alternating=1;
reference.tex(,10550) @c   y*x;
reference.tex(,10551) @c   @expansion{} -1*xy
reference.tex(,10552) @c @end example
reference.tex(,10553) @c @end table
reference.tex(,10554) @c @c ref
reference.tex(,10555) @c See
reference.tex(,10556) @c @ref{ring};
reference.tex(,10557) @c @ref{int expressions}.
reference.tex(,10558) @c @c ref
reference.tex(,10559) @c @c -----------------------------------------------------
reference.tex(,10560) @node degBound, echo, System variables, System variables
reference.tex(,10561) @subsection degBound
reference.tex(,10562) @cindex degBound
reference.tex(,10563) @table @code
reference.tex(,10564) @item @strong{Type:}
reference.tex(,10565) int
reference.tex(,10566) @item @strong{Purpose:}
reference.tex(,10567) The standard basis computation is stopped if the total
reference.tex(,10568) (weighted) degree
reference.tex(,10569) exceeds @code{degBound}.
reference.tex(,10570) @* @code{degBound} should not be used for a global ordering with inhomogeneous
reference.tex(,10571) input.
reference.tex(,10572) @*Reset this bound by setting @code{degBound} to 0.
reference.tex(,10573) @item @strong{Example:}
reference.tex(,10574) @smallexample
reference.tex(,10575) degBound = 7;
reference.tex(,10576) option();
reference.tex(,10577) @expansion{} //options for 'std'-command: degBound
reference.tex(,10578) ideal j=std(i);
reference.tex(,10579) degBound;
reference.tex(,10580) @expansion{} 7
reference.tex(,10581) degBound = 0; //resets degree bound to infinity
reference.tex(,10582) @end smallexample
reference.tex(,10583) @end table
reference.tex(,10584) @c inserted refs from reference.doc:7297
reference.tex(,10601) @c end inserted refs from reference.doc:7297
reference.tex(,10602) @c -----------------------------------------------------
reference.tex(,10603) @node echo, minpoly, degBound, System variables
reference.tex(,10604) @subsection echo
reference.tex(,10605) @cindex echo
reference.tex(,10606) @table @code
reference.tex(,10607) @item @strong{Type:}
reference.tex(,10608) int
reference.tex(,10609) @item @strong{Purpose:}
reference.tex(,10610) input is echoed if @code{echo} >= @code{voice}.
reference.tex(,10611) @*@code{echo} is a local setting for a procedure and defaulted to 0.
reference.tex(,10612) @*@code{echo} does not affect the output of commands.
reference.tex(,10613) @item @strong{Example:}
reference.tex(,10614) @c this example cannot be a computed one - echo interferes with -e
reference.tex(,10615) @smallexample
reference.tex(,10616) echo = 1;
reference.tex(,10617) int i = echo;
reference.tex(,10618) @expansion{} int i = echo;
reference.tex(,10619) @end smallexample
reference.tex(,10620) @end table
reference.tex(,10621) @c inserted refs from reference.doc:7323
reference.tex(,10634) @c end inserted refs from reference.doc:7323
reference.tex(,10635) @c -----------------------------------------------------
reference.tex(,10636) @node minpoly, multBound, echo, System variables
reference.tex(,10637) @subsection minpoly
reference.tex(,10638) @cindex minpoly
reference.tex(,10639) @table @code
reference.tex(,10640) @item @strong{Type:}
reference.tex(,10641) number
reference.tex(,10642) @item @strong{Purpose:}
reference.tex(,10643) describes the coefficient field of the current basering as
reference.tex(,10644) an algebraic extension with the minimal polynomial equal to @code{minpoly}.
reference.tex(,10645) Setting the @code{minpoly} should be the first command after
reference.tex(,10646) defining the ring.
reference.tex(,10647) @item @strong{Note:}
reference.tex(,10648) The minimal polynomial has to be specified in the syntax of a polynomial.
reference.tex(,10649) Its variable is not one of the ring variables, but the algebraic element
reference.tex(,10650) which is being adjoined to the field.
reference.tex(,10651) Algebraic extensions in @sc{singular} are only possible over the rational
reference.tex(,10652) numbers or over Z/p, p a prime number.
reference.tex(,10653) @c @*@strong{Warning:}
reference.tex(,10654) @*@sc{Singular} does not check whether the given
reference.tex(,10655) polynomial is irreducible! It can be checked in advance with the
reference.tex(,10656) function @code{factorize} (@pxref{factorize}).
reference.tex(,10657) @item @strong{Example:}
reference.tex(,10658) @smallexample
reference.tex(,10659) @c reused example minpoly reference.doc:7352 
reference.tex(,10660)   //(Q[i]/(i^2+1))[x,y,z]:
reference.tex(,10661)   ring Cxyz=(0,i),(x,y,z),dp;
reference.tex(,10662)   minpoly=i^2+1;
reference.tex(,10663)   i2;  //this is a number, not a poly
reference.tex(,10664) @expansion{} -1
reference.tex(,10665) @c end example minpoly reference.doc:7352
reference.tex(,10666) @end smallexample
reference.tex(,10667) @end table
reference.tex(,10668) @c inserted refs from reference.doc:7360
reference.tex(,10681) @c end inserted refs from reference.doc:7360
reference.tex(,10682) @c -----------------------------------------------------
reference.tex(,10683) @node multBound, noether, minpoly, System variables
reference.tex(,10684) @subsection multBound
reference.tex(,10685) @cindex multBound
reference.tex(,10686) @table @code
reference.tex(,10687) @item @strong{Type:}
reference.tex(,10688) int
reference.tex(,10689) @item @strong{Purpose:}
reference.tex(,10690) The standard basis computation is stopped if the ideal is
reference.tex(,10691) zero-dimensional in a ring with local ordering
reference.tex(,10692) and its multiplicity (@code{mult}) is lower than @code{multBound}.
reference.tex(,10693) @*Reset this bound by setting @code{multBound} to 0.
reference.tex(,10694) @item @strong{Example:}
reference.tex(,10695) @smallexample
reference.tex(,10696) multBound = 20;
reference.tex(,10697) option();
reference.tex(,10698) @expansion{}    //options for 'std'-command: multBound
reference.tex(,10699) ideal j=std(i);
reference.tex(,10700) multBound;
reference.tex(,10701) @expansion{} 20
reference.tex(,10702) multBound = 0;  //disables multBound
reference.tex(,10703) @end smallexample
reference.tex(,10704) @end table
reference.tex(,10705) @c inserted refs from reference.doc:7388
reference.tex(,10722) @c end inserted refs from reference.doc:7388
reference.tex(,10723) @c -----------------------------------------------------
reference.tex(,10724) @node noether, printlevel, multBound, System variables
reference.tex(,10725) @subsection noether
reference.tex(,10726) @cindex noether
reference.tex(,10727) @table @code
reference.tex(,10728) @item @strong{Type:}
reference.tex(,10729) poly
reference.tex(,10730) @item @strong{Purpose:}
reference.tex(,10731) The standard basis computation in local rings
reference.tex(,10732) cuts off  all monomials above
reference.tex(,10733) (in the sense of the monomial ordering)
reference.tex(,10734) the monomial @code{noether} during the computation.
reference.tex(,10735) @*Reset @code{noether} by setting @code{noether} to 0.
reference.tex(,10736) @item @strong{Example:}
reference.tex(,10737) @smallexample
reference.tex(,10738) @c reused example noether reference.doc:7410 
reference.tex(,10739)   ring R=32003,(x,y,z),ds;
reference.tex(,10740)   ideal i=x2+y12,y13;
reference.tex(,10741)   std(i);
reference.tex(,10742) @expansion{} _[1]=x2+y12
reference.tex(,10743) @expansion{} _[2]=y13
reference.tex(,10744)   noether=x11;
reference.tex(,10745)   std(i);
reference.tex(,10746) @expansion{} _[1]=x2
reference.tex(,10747)   noether=0; //disables noether
reference.tex(,10748) @c end example noether reference.doc:7410
reference.tex(,10749) @end smallexample
reference.tex(,10750) @end table
reference.tex(,10751) @c inserted refs from reference.doc:7420
reference.tex(,10764) @c end inserted refs from reference.doc:7420
reference.tex(,10765) @c -----------------------------------------------------
reference.tex(,10766) @node printlevel, short, noether, System variables
reference.tex(,10767) @subsection printlevel
reference.tex(,10768) @cindex printlevel
reference.tex(,10769) @table @code
reference.tex(,10770) @item @strong{Type:}
reference.tex(,10771) int
reference.tex(,10772) @item @strong{Purpose:}
reference.tex(,10773) sets the debug level for @code{dbprint}.
reference.tex(,10774) If @code{printlevel} >= @code{voice} then @code{dbprint} is equivalent to
reference.tex(,10775) @code{print}, otherwise nothing is printed.
reference.tex(,10776) @item @strong{Note:}
reference.tex(,10777) @xref{Procedures in a library}, for a small example about how this
reference.tex(,10778) is used for the display of comments while procedures are executed.
reference.tex(,10779) @item @strong{Example:}
reference.tex(,10780) @smallexample
reference.tex(,10781) @c reused example printlevel reference.doc:7441 
reference.tex(,10782)   voice;
reference.tex(,10783) @expansion{} 1
reference.tex(,10784)   printlevel=0;
reference.tex(,10785)   dbprint(1);
reference.tex(,10786)   printlevel=voice;
reference.tex(,10787)   dbprint(1);
reference.tex(,10788) @expansion{} 1
reference.tex(,10789) @c end example printlevel reference.doc:7441
reference.tex(,10790) @end smallexample
reference.tex(,10791) @end table
reference.tex(,10792) @c inserted refs from reference.doc:7450
reference.tex(,10807) @c end inserted refs from reference.doc:7450
reference.tex(,10808) @c -----------------------------------------------------
reference.tex(,10809) @node short, timer, printlevel, System variables
reference.tex(,10810) @subsection short
reference.tex(,10811) @cindex short
reference.tex(,10812) @table @code
reference.tex(,10813) @item @strong{Type:}
reference.tex(,10814) int
reference.tex(,10815) @item @strong{Purpose:}
reference.tex(,10816) the output of monomials is done in the short manner,
reference.tex(,10817) if @code{short} is non-zero. A C-like notion is used, if short is zero.
reference.tex(,10818) Both notations may be used as input.
reference.tex(,10819) @*The default depends on the names of the ring variables
reference.tex(,10820) (0 if there are names of variables longer than 1 character, 1 otherwise). Every
reference.tex(,10821) change of the basering sets @code{short} to the previous value for
reference.tex(,10822) that ring. In other words, the value of the variable @code{short} is
reference.tex(,10823) "ring-local".
reference.tex(,10824) @item @strong{Example:}
reference.tex(,10825) @smallexample
reference.tex(,10826) @c reused example short reference.doc:7474 
reference.tex(,10827)   ring r=23,x,dp;
reference.tex(,10828)   int save=short;
reference.tex(,10829)   short=1;
reference.tex(,10830)   2x2,x2;
reference.tex(,10831) @expansion{} 2x2 x2
reference.tex(,10832)   short=0;
reference.tex(,10833)   2x2,x2;
reference.tex(,10834) @expansion{} 2*x^2 x^2
reference.tex(,10835)   short=save;  //resets short to the previous value
reference.tex(,10836) @c end example short reference.doc:7474
reference.tex(,10837) @end smallexample
reference.tex(,10838) @end table
reference.tex(,10839) @c inserted refs from reference.doc:7485
reference.tex(,10850) @c end inserted refs from reference.doc:7485
reference.tex(,10851) @c -----------------------------------------------------
reference.tex(,10852) @node timer, TRACE var, short, System variables
reference.tex(,10853) @subsection timer
reference.tex(,10854) @cindex timer
reference.tex(,10855) @table @code
reference.tex(,10856) @item @strong{Type:}
reference.tex(,10857) int
reference.tex(,10858) @item @strong{Purpose:}
reference.tex(,10859) @enumerate
reference.tex(,10860) @item
reference.tex(,10861) the CPU time (i.e, user and system time) used for each command is
reference.tex(,10862) printed if timer >0 , if this
reference.tex(,10863) time is bigger than a (customizable) minimal time and
reference.tex(,10864) if @code{printlevel+1 >= voice} (which is by default true on the
reference.tex(,10865) @sc{Singular} top level, but not true while procedures are executed).
reference.tex(,10866) 
reference.tex(,10867) @item
reference.tex(,10868) yields the used CPU time since the start-up of @sc{Singular} in a
reference.tex(,10869) (customizable) resolution.
reference.tex(,10870) @end enumerate
reference.tex(,10871) 
reference.tex(,10872) The default setting of @code{timer} is 0, the default minimal time is
reference.tex(,10873) 0.5 seconds, and the default timer resolution is 1 (i.e., the default unit
reference.tex(,10874) of time is one second). The minimal time and timer resolution
reference.tex(,10875) can be set using the command line options @code{--min-time} and
reference.tex(,10876) @code{--ticks-per-sec} and can be checked using
reference.tex(,10877) @code{system("--min-time")} and @code{system("--ticks-per-sec")}.
reference.tex(,10878) 
reference.tex(,10879) How to use @code{timer} in order to measure the time for a sequence of
reference.tex(,10880) commands, see example below.
reference.tex(,10881) 
reference.tex(,10882) @item @strong{Note for Windows95/98:}
reference.tex(,10883) The value of the @code{timer} cannot be used (resp.@: trusted) when
reference.tex(,10884) @sc{Singular} is run under Windows95/98 (this is due to the shortcomings
reference.tex(,10885) of the Windows95/98 operating system). Use @ref{rtimer}, instead.
reference.tex(,10886) 
reference.tex(,10887) @item @strong{Example:}
reference.tex(,10888) @smallexample
reference.tex(,10889) @c reused example timer reference.doc:7527 
reference.tex(,10890)   timer=1; // The time of each command is printed
reference.tex(,10891)   int t=timer; // initialize t by timer
reference.tex(,10892)   ring r=0,(x,y,z),dp;
reference.tex(,10893)   poly p=(x+2y+3z+4xy+5xz+6yz)^20;
reference.tex(,10894)   // timer as int_expression:
reference.tex(,10895)   t=timer-t;
reference.tex(,10896)   t;  // yields the time in ticks-per-sec (default 1)
reference.tex(,10897) @expansion{} 0
reference.tex(,10898)       // since t was initialized by timer
reference.tex(,10899)   int tps=system("--ticks-per-sec");
reference.tex(,10900)   t/tps; // yields the time in seconds truncated to int
reference.tex(,10901) @expansion{} 0
reference.tex(,10902) @c end example timer reference.doc:7527
reference.tex(,10903) @end smallexample
reference.tex(,10904) @end table
reference.tex(,10905) @c inserted refs from reference.doc:7541
reference.tex(,10924) @c end inserted refs from reference.doc:7541
reference.tex(,10925) @c ---------------------------------------
reference.tex(,10926) @node TRACE var, rtimer, timer, System variables
reference.tex(,10927) @subsection TRACE
reference.tex(,10928) @cindex TRACE
reference.tex(,10929) 
reference.tex(,10930) @table @code
reference.tex(,10931) @item @strong{Type:}
reference.tex(,10932) int
reference.tex(,10933) @item @strong{Purpose:}
reference.tex(,10934) sets level of debugging.
reference.tex(,10935) @table @asis
reference.tex(,10936) @item @code{TRACE=0}
reference.tex(,10937) no debugging messages are printed.
reference.tex(,10938) @item @code{TRACE=1}
reference.tex(,10939) messages about entering and leaving of procedures are displayed.
reference.tex(,10940) @item @code{TRACE=3}
reference.tex(,10941) messages about entering and leaving of procedures together with
reference.tex(,10942) line numbers are displayed.
reference.tex(,10943) @item @code{TRACE=4}
reference.tex(,10944) each line is echoed and the interpretation of commands
reference.tex(,10945) in this line is suspended until the user presses @code{RETURN}.
reference.tex(,10946) @end table
reference.tex(,10947) @*@code{TRACE} is defaulted to 0.
reference.tex(,10948) @*@code{TRACE} does not affect the output of commands.
reference.tex(,10949) @item @strong{Example:}
reference.tex(,10950) @smallexample
reference.tex(,10951) @c reused example TRACE reference.doc:7575 
reference.tex(,10952)   TRACE=1;
reference.tex(,10953)   LIB "general.lib";
reference.tex(,10954)   sum(1..100);
reference.tex(,10955) @expansion{} entering sum (level 0)
reference.tex(,10956) @expansion{} leaving  sum (level 0)
reference.tex(,10957) @expansion{} 5050
reference.tex(,10958) @c end example TRACE reference.doc:7575
reference.tex(,10959) @end smallexample
reference.tex(,10960) @end table
reference.tex(,10961) @c inserted refs from reference.doc:7582
reference.tex(,10972) @c end inserted refs from reference.doc:7582
reference.tex(,10973) @c ---------------------------------------
reference.tex(,10974) @node rtimer, voice, TRACE var, System variables
reference.tex(,10975) @subsection rtimer
reference.tex(,10976) @cindex timer
reference.tex(,10977) @table @code
reference.tex(,10978) @item @strong{Type:}
reference.tex(,10979) int
reference.tex(,10980) @item @strong{Purpose:}
reference.tex(,10981) identical to @code{timer} (@pxref{timer}), except that real times (i.e.,
reference.tex(,10982) wall-clock) times are reported, instead of CPU times. This can be
reference.tex(,10983) trusted on all operating systems (including Windows95/98).
reference.tex(,10984) 
reference.tex(,10985) @end table
reference.tex(,10986) @c ---------------------------------------
reference.tex(,10987) @node voice,, rtimer, System variables
reference.tex(,10988) @subsection voice
reference.tex(,10989) @cindex voice
reference.tex(,10990) 
reference.tex(,10991) @table @code
reference.tex(,10992) @item @strong{Type:}
reference.tex(,10993) int
reference.tex(,10994) @item @strong{Purpose:}
reference.tex(,10995) shows the nesting level of procedures.
reference.tex(,10996) @item @strong{Note:}
reference.tex(,10997) @xref{Guidelines for writing a library}, for an small example how this is used
reference.tex(,10998) for the display of comments while procedures are executed.
reference.tex(,10999) @item @strong{Example:}
reference.tex(,11000) @smallexample
reference.tex(,11001) @c reused example voice reference.doc:7614 
reference.tex(,11002)   voice;
reference.tex(,11003) @expansion{} 1
reference.tex(,11004) @c end example voice reference.doc:7614
reference.tex(,11005) proc p
reference.tex(,11006) @{
reference.tex(,11007)   voice;
reference.tex(,11008) @};
reference.tex(,11009) p();
reference.tex(,11010) @expansion{} 2
reference.tex(,11011) @end smallexample
reference.tex(,11012) @end table
reference.tex(,11013) @c inserted refs from reference.doc:7625
reference.tex(,11028) @c end inserted refs from reference.doc:7625
reference.tex(,11029) @c ---------------------------------------
singular.texi(,145) 
singular.texi(,146) @c ----------------------------------------------------------------------------
singular.texi(,147) @node Tricks and pitfalls, Examples, Functions and system variables, Top
singular.texi(,148) @chapter Tricks and pitfalls
singular.texi(,149) @cindex Tricks and pitfalls
tricks.tex(,1) @comment -*-texinfo-*-
tricks.tex(,2) @comment This file was generated by doc2tex.pl from tricks.doc
tricks.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT tricks.doc INSTEAD
tricks.tex(,4) @comment Id: tricks.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
tricks.tex(,5) @comment this file contains the "Tricks and pittfals" sections
tricks.tex(,6) 
tricks.tex(,7) @c The following directives are necessary for proper compilation
tricks.tex(,8) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
tricks.tex(,9) @c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
tricks.tex(,10) @c `makeinfo' but is a great help in editing this file (emacs
tricks.tex(,11) @c ignores the `@ignore').
tricks.tex(,24) 
tricks.tex(,25) @menu
tricks.tex(,26) * Limitations::
tricks.tex(,27) * Major differences to the C programming language::
tricks.tex(,28) * Miscellaneous oddities::
tricks.tex(,29) * Identifier resolution::
tricks.tex(,30) @end menu
tricks.tex(,31) 
tricks.tex(,32) @c -------------------------------------------------------------------------
tricks.tex(,33) @node Limitations,Major differences to the C programming language,,Tricks and pitfalls
tricks.tex(,34) @section Limitations
tricks.tex(,35) @cindex Limitations
tricks.tex(,36) 
tricks.tex(,37) @sc{Singular} has the following limitations:
tricks.tex(,38) @itemize @bullet
tricks.tex(,39) @item
tricks.tex(,40) the characteristic of a prime field must be less than 2147483629 
tricks.tex(,41) @item
tricks.tex(,42) the (weighted) degree of a monomial must be smaller than the largest @code{long},
tricks.tex(,43) usually 2147483648
tricks.tex(,44) @item
tricks.tex(,45) the exponent of a ring variable must be smaller than 32768
tricks.tex(,46) unless the ring ordering start with the pseudo ordering 
tricks.tex(,47) @code{L(} max_exponent @code{)}
tricks.tex(,48) @item
tricks.tex(,49) the rank of any free module must be smaller than the largest @code{long},
tricks.tex(,50) usually 2147483648
tricks.tex(,51) @item
tricks.tex(,52) the number of parameters must be smaller than 32768
tricks.tex(,53) @item
tricks.tex(,54) the number of ring variables must be smaller than 32768
tricks.tex(,55) @item
tricks.tex(,56) the precision of long floating point numbers (for ground field @code{real})
tricks.tex(,57) must be smaller than 32768
tricks.tex(,58) @item
tricks.tex(,59) integers (of type @code{int}) have the limited range
tricks.tex(,60) from -2147483647 to 2147483647
tricks.tex(,61) @item
tricks.tex(,62) floating point numbers (type @code{number} from field @code{real}) have
tricks.tex(,63) a limited range which is machine dependent. A typical range is -1.0e-38
tricks.tex(,64) to 1.0e+38.  The string representation of overflow and underflow is
tricks.tex(,65) machine dependent, as well. For example "@code{Inf}" on Linux, or 
tricks.tex(,66) "@code{+.+00e+00}" on HPUX.
tricks.tex(,67) @c @item
tricks.tex(,68) @c a token (in the input) must have 16383 characters or less.
tricks.tex(,69) @c @*(Tokens are strings, blocks of statements, numbers)
tricks.tex(,70) @c @*This does not apply to proc in libraries but to blocks
tricks.tex(,71) @c within a procedure
tricks.tex(,72) @item
tricks.tex(,73) the length of an identifier is unlimited but @code{listvar}
tricks.tex(,74) displays only the first 20 characters
tricks.tex(,75) @c @item
tricks.tex(,76) @c the interpretation of text between a closing @code{@}} and the end of
tricks.tex(,77) @c the line is undefined. (Therefore do not put anything but spaces between
tricks.tex(,78) @c @code{@}} and the end of the line.)
tricks.tex(,79) @item
tricks.tex(,80) statements may not contain more than 10000 tokens
tricks.tex(,81) @item
tricks.tex(,82) @cindex German Umlaute
tricks.tex(,83) @cindex non-english special characters
tricks.tex(,84) @cindex special characters, non-english
tricks.tex(,85) All input to Singular must be 7-bit clean, i.e. special characters like the
tricks.tex(,86) the German Umlaute (@"a, @"o, etc.), or the French accent characters may 
tricks.tex(,87) neither appear as input to @sc{Singular}, nor in libraries or procedure
tricks.tex(,88) definitions.
tricks.tex(,89) @end itemize
tricks.tex(,90) 
tricks.tex(,91) @c -------------------------------------------------------------------------
tricks.tex(,92) @node Major differences to the C programming language,Miscellaneous oddities,Limitations,Tricks and pitfalls
tricks.tex(,93) @section Major differences to the C programming language
tricks.tex(,94) @cindex C programming language
tricks.tex(,95) 
tricks.tex(,96) Although many constructs from @sc{Singular}'s programming language are similar
tricks.tex(,97) to those from the C programming language, there are some subtle
tricks.tex(,98) differences. Most notably:
tricks.tex(,99) 
tricks.tex(,100) @menu
tricks.tex(,101) * No rvalue of increments and assignments::
tricks.tex(,102) * Evaluation of logical expressions::
tricks.tex(,103) * No case or switch statement::
tricks.tex(,104) * Usage of commas::
tricks.tex(,105) * Usage of brackets::
tricks.tex(,106) * Behavior of continue::
tricks.tex(,107) * Return type of procedures::
tricks.tex(,108) @end menu
tricks.tex(,109) @c ---------------------------------------
tricks.tex(,110) @node No rvalue of increments and assignments, Evaluation of logical expressions,,Major differences to the C programming language
tricks.tex(,111) @subsection No rvalue of increments and assignments
tricks.tex(,112) @cindex rvalue
tricks.tex(,113) 
tricks.tex(,114) The increment operator @code{++} (resp.@: decrement operator @code{--})
tricks.tex(,115) has no rvalue, i.e., cannot be used on the right-hand sides of
tricks.tex(,116) assignments.  So, instead of
tricks.tex(,117) 
tricks.tex(,118) @smallexample
tricks.tex(,119) j = i++;  // WRONG!!!
tricks.tex(,120) @end smallexample
tricks.tex(,121) 
tricks.tex(,122) @noindent (which results in an error), it must be written
tricks.tex(,123) 
tricks.tex(,124) @smallexample
tricks.tex(,125) i++; j = i;
tricks.tex(,126) @end smallexample
tricks.tex(,127) 
tricks.tex(,128) Likewise, an assignment expression does not have a result.  Therefore,
tricks.tex(,129) compound assignments like @code{i = j = k;} are not allowed and result
tricks.tex(,130) in an error.
tricks.tex(,131) 
tricks.tex(,132) @c ---------------------------------------
tricks.tex(,133) @node Evaluation of logical expressions, No case or switch statement, No rvalue of increments and assignments, Major differences to the C programming language
tricks.tex(,134) @subsection Evaluation of logical expressions
tricks.tex(,135) @cindex Evaluation of logical expressions
tricks.tex(,136) @cindex and
tricks.tex(,137) @cindex or
tricks.tex(,138) 
tricks.tex(,139) @c ------------------------------------------------------------
tricks.tex(,140) @c   This piece of text partially exists also in the file types.doc,
tricks.tex(,141) @c   chapter "boolean expressions".
tricks.tex(,142) @c   If you change something here, change it there, too!
tricks.tex(,143) @c ------------------------------------------------------------
tricks.tex(,144) @strong{All} arguments of a logical expression are first evaluated and
tricks.tex(,145) then the value of the logical expression is determined. For example, the
tricks.tex(,146) logical expressions @code{(a || b)} is evaluated by first evaluating
tricks.tex(,147) @code{a} @emph{and} @code{b}, even though the value of @code{b} has no
tricks.tex(,148) influence on the value of @code{(a || b)}, if @code{a} evaluates to
tricks.tex(,149) true. 
tricks.tex(,150) 
tricks.tex(,151) Note, that this evaluation is different from the left-to-right,
tricks.tex(,152) conditional evaluation of logical expressions (as found in most
tricks.tex(,153) programming languages). For example, in these other languages, the value
tricks.tex(,154) of @code{(1 || b)} is determined without ever evaluating @code{b}.  This
tricks.tex(,155) causes some problems with boolean tests on variables, which might not be
tricks.tex(,156) defined at evaluation time. For example, the following results in an
tricks.tex(,157) error, if the variable @code{i} is undefined:
tricks.tex(,158) 
tricks.tex(,159) @smallexample
tricks.tex(,160) if (defined(i) && i > 0) @{@} // WRONG!!!
tricks.tex(,161) @end smallexample
tricks.tex(,162) 
tricks.tex(,163) This must be written instead as:
tricks.tex(,164) 
tricks.tex(,165) @smallexample
tricks.tex(,166) if (defined(i))
tricks.tex(,167) @{
tricks.tex(,168)   if (i > 0) @{@}
tricks.tex(,169) @}
tricks.tex(,170) @end smallexample
tricks.tex(,171) @c ------------------------------------------------------------
tricks.tex(,172) @c end of duplicate text
tricks.tex(,173) @c ------------------------------------------------------------
tricks.tex(,174) 
tricks.tex(,175) However, there are several short work-arounds for this problem:
tricks.tex(,176) @enumerate
tricks.tex(,177) @item
tricks.tex(,178) If a variable (say, @code{i}) is only to be used as a boolean flag, then
tricks.tex(,179) define (value is TRUE) and undefine (value is FALSE) @code{i} instead of
tricks.tex(,180) assigning a value. Using this scheme, it is sufficient to simply write
tricks.tex(,181) 
tricks.tex(,182) @smallexample
tricks.tex(,183) if (defined(i))
tricks.tex(,184) @end smallexample
tricks.tex(,185) 
tricks.tex(,186) in order to check whether @code{i} is TRUE. Use the command @code{kill}
tricks.tex(,187) to undefine a variable, i.e.@: to assign it a FALSE value (@pxref{kill}).
tricks.tex(,188) @item
tricks.tex(,189) If a variable  can have more than two values, then
tricks.tex(,190) define it, if necessary, before it is used for the first time.
tricks.tex(,191) For example, if the following is used within a procedure
tricks.tex(,192) 
tricks.tex(,193) @smallexample
tricks.tex(,194) if (! defined(DEBUG)) @{ int DEBUG = 1;@}
tricks.tex(,195) @dots{}
tricks.tex(,196) if (DEBUG == 3)  @{@dots{}@}
tricks.tex(,197) if (DEBUG == 2)  @{@dots{}@}
tricks.tex(,198) @dots{}
tricks.tex(,199) @end smallexample
tricks.tex(,200) 
tricks.tex(,201) then a user of this procedure does not need to care about the existence
tricks.tex(,202) of the @code{DEBUG} variable -- this remains hidden from the
tricks.tex(,203) user. However, if @code{DEBUG} exists globally, then its local default
tricks.tex(,204) value is overwritten by its global one.
tricks.tex(,205) @end enumerate
tricks.tex(,206) 
tricks.tex(,207) @c ---------------------------------------
tricks.tex(,208) @node No case or switch statement,  Usage of commas, Evaluation of logical expressions, Major differences to the C programming language
tricks.tex(,209) @subsection No case or switch statement
tricks.tex(,210) @cindex case
tricks.tex(,211) @cindex switch
tricks.tex(,212) 
tricks.tex(,213) @sc{Singular} does not offer a @code{case} (or @code{switch})
tricks.tex(,214) statement. However, it can be imitated in the following way:
tricks.tex(,215) 
tricks.tex(,216) @smallexample
tricks.tex(,217) while (1)
tricks.tex(,218) @{
tricks.tex(,219)    if (choice == choice_1) @{ @dots{}; break;@}
tricks.tex(,220)    @dots{}
tricks.tex(,221)    if (choice == choice_n) @{ @dots{}; break;@}
tricks.tex(,222)    // default case
tricks.tex(,223)    @dots{}; break;
tricks.tex(,224) @}
tricks.tex(,225) @end smallexample
tricks.tex(,226) 
tricks.tex(,227) @c ---------------------------------------
tricks.tex(,228) @node Usage of commas, Usage of brackets, No case or switch statement, Major differences to the C programming language
tricks.tex(,229) @subsection Usage of commas
tricks.tex(,230) @cindex comma
tricks.tex(,231) 
tricks.tex(,232) In @sc{Singular}, a comma separates list elements and the value of a comma
tricks.tex(,233) expression is a list.
tricks.tex(,234) Hence, commas can not be used to combine several expressions into
tricks.tex(,235) a single expression. For example, instead of writing
tricks.tex(,236) 
tricks.tex(,237) @smallexample
tricks.tex(,238) for (i=1, j=5; i<5 || j<10; i++, j++) @{@dots{}@} // WRONG!!!!!!
tricks.tex(,239) @end smallexample
tricks.tex(,240) 
tricks.tex(,241) @noindent one has to write
tricks.tex(,242) 
tricks.tex(,243) @smallexample
tricks.tex(,244) for (i,j = 1,5; i<5 || j<10; i++, j++) @{@dots{}@}
tricks.tex(,245) @end smallexample
tricks.tex(,246) 
tricks.tex(,247) @c ---------------------------------------
tricks.tex(,248) @node Usage of brackets, Behavior of continue, Usage of commas, Major differences to the C programming language
tricks.tex(,249) @subsection Usage of brackets
tricks.tex(,250) @cindex bracket
tricks.tex(,251) 
tricks.tex(,252) In @sc{Singular}, curly brackets (@code{@{} @code{@}}) @strong{must
tricks.tex(,253) always} be used to enclose the statement body following such constructs
tricks.tex(,254) like @code{if}, @code{else}, @code{for}, or @code{while}, even if this
tricks.tex(,255) block consists of only a single statement. Similarly, in the return
tricks.tex(,256) statement of a procedure, parentheses (@code{(} @code{)}) @strong{must
tricks.tex(,257) always} be used to enclose the return value.  Even if there is no value
tricks.tex(,258) to return, parentheses have to be used after a return statement
tricks.tex(,259) (i.e., @code{return();}).  For example,
tricks.tex(,260) 
tricks.tex(,261) @smallexample
tricks.tex(,262) if (i == 1) return i;    // WRONG!!!!!
tricks.tex(,263) @end smallexample
tricks.tex(,264) 
tricks.tex(,265) @noindent results in an error. Instead, it must be written as
tricks.tex(,266) 
tricks.tex(,267) @smallexample
tricks.tex(,268) if (i == 1) @{ return (i); @}
tricks.tex(,269) @end smallexample
tricks.tex(,270) 
tricks.tex(,271) @c ---------------------------------------
tricks.tex(,272) @node  Behavior of continue, Return type of procedures, Usage of brackets, Major differences to the C programming language
tricks.tex(,273) @subsection Behavior of continue
tricks.tex(,274) @cindex continue
tricks.tex(,275) @sc{Singular}'s @code{continue} construct is only valid inside the body
tricks.tex(,276) of a @code{for} or @code{while} construct. It skips the rest of the
tricks.tex(,277) loop-body and jumps to the beginning of the block. Unlike the
tricks.tex(,278) C-construct @sc{Singular}'s @code{continue} @strong{does not execute the
tricks.tex(,279) increment statement}. For example,
tricks.tex(,280) 
tricks.tex(,281) @smallexample
tricks.tex(,282) for (int i = 1 ; i<=10; i=i+1)
tricks.tex(,283) @{
tricks.tex(,284)    @dots{}
tricks.tex(,285)    if (i==3) @{ i=8;continue; @}
tricks.tex(,286)      // skip the rest if i is 3 and
tricks.tex(,287)      // continue with the next i: 8
tricks.tex(,288)    i;
tricks.tex(,289) @}
tricks.tex(,290) @expansion{} 1
tricks.tex(,291) @expansion{} 2
tricks.tex(,292) @expansion{} 8
tricks.tex(,293) @expansion{} 9
tricks.tex(,294) @expansion{} 10
tricks.tex(,295) @end smallexample
tricks.tex(,296) @c ---------------------------------------
tricks.tex(,297) @node Return type of procedures,,Behavior of continue, Major differences to the C programming language
tricks.tex(,298) @subsection Return type of procedures
tricks.tex(,299) @cindex return type of procedures
tricks.tex(,300) 
tricks.tex(,301) Although the @sc{Singular} language is a strongly typed programming
tricks.tex(,302) language, the type of the
tricks.tex(,303) return value of a procedure does not need to be specified. As a
tricks.tex(,304) consequence, the return type of a procedure may vary, i.e., may, for
tricks.tex(,305) example, depend on the input. However, the return value
tricks.tex(,306) of such a procedure may then only be assigned to a variable of type
tricks.tex(,307) @code{def}.
tricks.tex(,308) 
tricks.tex(,309) @smallexample
tricks.tex(,310) @c reused example Return_type_of_procedures tricks.doc:308 
tricks.tex(,311) proc type_return (int i)
tricks.tex(,312) @{
tricks.tex(,313)   if (i > 0) @{return (i);@}
tricks.tex(,314)   else @{return (list(i));@}
tricks.tex(,315) @}
tricks.tex(,316) def t1 = type_return(1);
tricks.tex(,317) def t2 = type_return(-1);
tricks.tex(,318) typeof(t1); typeof(t2);
tricks.tex(,319) @expansion{} int
tricks.tex(,320) @expansion{} list
tricks.tex(,321) @c end example Return_type_of_procedures tricks.doc:308
tricks.tex(,322) @end smallexample
tricks.tex(,323) 
tricks.tex(,324) Furthermore, it is mandatory to assign the return value of a procedure
tricks.tex(,325) to a variable of type @code{def}, if a procedure changes the current
tricks.tex(,326) ring using the @code{keepring} command (@pxref{keepring}) and returns a
tricks.tex(,327) ring-dependent value (like a polynomial or module).
tricks.tex(,328) 
tricks.tex(,329) @smallexample
tricks.tex(,330) @c reused example Return_type_of_procedures_1 tricks.doc:326 
tricks.tex(,331) proc def_return
tricks.tex(,332) @{
tricks.tex(,333)   ring r=0,(x,y),dp;
tricks.tex(,334)   poly p = x;
tricks.tex(,335)   keepring r;
tricks.tex(,336)   return (x);
tricks.tex(,337) @}
tricks.tex(,338) def p = def_return();
tricks.tex(,339) // poly p = def_return(); would be WRONG!!!
tricks.tex(,340) typeof(p);
tricks.tex(,341) @expansion{} poly
tricks.tex(,342) @c end example Return_type_of_procedures_1 tricks.doc:326
tricks.tex(,343) @end smallexample
tricks.tex(,344) 
tricks.tex(,345) On the other hand, more than one value can be returned by a single
tricks.tex(,346) @code{return} statement. For example,
tricks.tex(,347) 
tricks.tex(,348) @smallexample
tricks.tex(,349) proc tworeturn () @{ return (1,2); @}
tricks.tex(,350) int i,j = tworeturn();
tricks.tex(,351) @end smallexample
tricks.tex(,352) 
tricks.tex(,353) 
tricks.tex(,354) @c -------------------------------------------------------------------------
tricks.tex(,355) @node Miscellaneous oddities, Identifier resolution, Major differences to the C programming language, Tricks and pitfalls
tricks.tex(,356) @section Miscellaneous oddities
tricks.tex(,357) 
tricks.tex(,358) @enumerate
tricks.tex(,359) @item integer division
tricks.tex(,360) @cindex integer division
tricks.tex(,361) @cindex div
tricks.tex(,362) 
tricks.tex(,363) If two numerical constants (i.e., two sequences of digits) are divided
tricks.tex(,364) using the @code{/} operator, the surrounding whitespace determines
tricks.tex(,365) which division to use: if there is no space between the constants and
tricks.tex(,366) the @code{/} operator (e.g., "3/2"), both numerical constants are
tricks.tex(,367) treated as of type @code{number} and the current ring division is
tricks.tex(,368) used. If there is at least one space surrounding the @code{/} operator
tricks.tex(,369) (e.g., "3 / 2"), both numerical constants are treated as of type
tricks.tex(,370) @code{int} and an integer division is performed. To avoid confusion, use
tricks.tex(,371) the @code{div} operator instead of @code{/} for integer division and an
tricks.tex(,372) explicit type cast to @code{number} for ring division. Note, that this
tricks.tex(,373) problem does only occur for divisions of numerical constants.
tricks.tex(,374) @smallexample
tricks.tex(,375) @c reused example Miscellaneous_oddities tricks.doc:370 
tricks.tex(,376)   ring r=32002,x,dp;
tricks.tex(,377)   3/2;    // ring division
tricks.tex(,378) @expansion{} -15994
tricks.tex(,379)   3 / 2;  // integer division
tricks.tex(,380) @expansion{} 1
tricks.tex(,381)   3 div 2;
tricks.tex(,382) @expansion{} 1
tricks.tex(,383)   number(3) / number(2);
tricks.tex(,384) @expansion{} -15994
tricks.tex(,385)   number a=3;
tricks.tex(,386)   number b=2;
tricks.tex(,387)   a/b;
tricks.tex(,388) @expansion{} -15994
tricks.tex(,389)   int c=3;
tricks.tex(,390)   int d=2;
tricks.tex(,391)   c / d;
tricks.tex(,392) @expansion{} 1
tricks.tex(,393) @c end example Miscellaneous_oddities tricks.doc:370
tricks.tex(,394) @end smallexample
tricks.tex(,395) 
tricks.tex(,396) 
tricks.tex(,397) @item monomials and precedence
tricks.tex(,398) @cindex monomials and precedence
tricks.tex(,399) 
tricks.tex(,400) The computation of a monomial has precedence over all operators:
tricks.tex(,401) @smallexample
tricks.tex(,402) @c reused example Miscellaneous_oddities_1 tricks.doc:391 
tricks.tex(,403)   ring r=0,(x,y),dp;
tricks.tex(,404)   2xy^2 == (2*x*y)^2;
tricks.tex(,405) @expansion{} 1
tricks.tex(,406)   2xy^2 == 2x*y^2;
tricks.tex(,407) @expansion{} 0
tricks.tex(,408)   2x*y^2 == 2*x * (y^2);
tricks.tex(,409) @expansion{} 1
tricks.tex(,410) @c end example Miscellaneous_oddities_1 tricks.doc:391
tricks.tex(,411) @end smallexample
tricks.tex(,412) 
tricks.tex(,413) @item meaning of @code{mult}
tricks.tex(,414) @cindex mult
tricks.tex(,415) @cindex degree
tricks.tex(,416) 
tricks.tex(,417) For an arbitrary ideal or module @code{i}, @code{mult(i)} returns the
tricks.tex(,418) multiplicity of the ideal generated by the leading monomials of the
tricks.tex(,419) given generators of @code{i}, hence depends on the monomial ordering!
tricks.tex(,420) 
tricks.tex(,421) A standard mistake is to interpret @code{degree(i)} or @code{mult(i)}
tricks.tex(,422) for an inhomogeneous ideal @code{i} as the degree of the homogenization
tricks.tex(,423) or as something like the 'degree of the affine part'. For the ordering
tricks.tex(,424) @code{dp} (degree reverse lexicographical) the converse is true: if
tricks.tex(,425) @code{i} is given by a standard basis, @code{mult(i)} is the degree of
tricks.tex(,426) the homogeneous ideal obtained by homogenization of @code{i} and then
tricks.tex(,427) putting the homogenizing variable to 0, hence it is the degree of the
tricks.tex(,428) part at infinity (this can also be checked by looking at the initial
tricks.tex(,429) ideal).
tricks.tex(,430) 
tricks.tex(,431) @item size of ideals
tricks.tex(,432) @cindex ideals
tricks.tex(,433) @cindex size
tricks.tex(,434) 
tricks.tex(,435) @code{size} counts the non-zero entries of an ideal or module. Use
tricks.tex(,436) @code{ncols} to determine the actual number of entries in the ideal or module.
tricks.tex(,437) 
tricks.tex(,438) @item computations in @code{qring}
tricks.tex(,439) @cindex qring
tricks.tex(,440) 
tricks.tex(,441) In order to speed up computations in quotient rings, @sc{Singular}
tricks.tex(,442) usually does not reduce polynomials w.r.t.@: the quotient ideal; rather
tricks.tex(,443) the given representative is used as long as possible during
tricks.tex(,444) computations. If it is necessary, reduction is done during standard base
tricks.tex(,445) computations. To reduce a polynomial @code{f} by hand w.r.t.@: the
tricks.tex(,446) current quotient ideal use the command @code{reduce(f,std(0))}
tricks.tex(,447) (@pxref{reduce}).
tricks.tex(,448) 
tricks.tex(,449) @item substring selection
tricks.tex(,450) @cindex string
tricks.tex(,451) 
tricks.tex(,452) To extract substrings from a @code{string}, square brackets are used,
tricks.tex(,453) enclosing either two comma-separated @code{int}s or an
tricks.tex(,454) @code{intvec}. Although two comma-separated @code{int}s represent an
tricks.tex(,455) @code{intvec}, they mean different things in substring access. Square
tricks.tex(,456) brackets enclosing two @code{int}s (e.g.@: @code{s[2,6]}) return a
tricks.tex(,457) substring where the first integer denotes the starting position and the
tricks.tex(,458) second integer denotes the length of the substring. The result is
tricks.tex(,459) returned as a @code{string}. Square brackets enclosing an @code{intvec}
tricks.tex(,460) (e.g.@: @code{s[intvec(2,6)]}) return the characters of the string at the
tricks.tex(,461) position given by the values of the @code{intvec}. The result is
tricks.tex(,462) returned as an expression list of strings. 
tricks.tex(,463) @c  Note, that this problem does
tricks.tex(,464) @c  not occur for square brackets enclosing a single @code{int} or more than
tricks.tex(,465) @c  two @code{int}s. Those always return an expression list of strings.
tricks.tex(,466) 
tricks.tex(,467) @smallexample
tricks.tex(,468) @c reused example Miscellaneous_oddities_2 tricks.doc:454 
tricks.tex(,469)   string s = "one-word";
tricks.tex(,470)   s[2,6];     // a substring starting at the second char
tricks.tex(,471) @expansion{} ne-wor
tricks.tex(,472)   size(_);
tricks.tex(,473) @expansion{} 6
tricks.tex(,474)   intvec v = 2,6;
tricks.tex(,475)   s[v];      // the second and the sixth char
tricks.tex(,476) @expansion{} n o
tricks.tex(,477)   string st = s[v];  // stick together by an assignment
tricks.tex(,478)   st;
tricks.tex(,479) @expansion{} no
tricks.tex(,480)   size(_);
tricks.tex(,481) @expansion{} 2
tricks.tex(,482)   v = 2,6,8;
tricks.tex(,483)   s[v];
tricks.tex(,484) @expansion{} n o d
tricks.tex(,485) @c end example Miscellaneous_oddities_2 tricks.doc:454
tricks.tex(,486) @end smallexample
tricks.tex(,487) 
tricks.tex(,518) 
tricks.tex(,519) @end enumerate
tricks.tex(,520) 
tricks.tex(,521) @c ----------------------------------------------
tricks.tex(,522) @node Identifier resolution,, Miscellaneous oddities, Tricks and pitfalls
tricks.tex(,523) @section Identifier resolution
tricks.tex(,524) @cindex identifier
tricks.tex(,525) 
tricks.tex(,526) In @sc{Singular}, an identifier (i.e., a "word") is resolved in the
tricks.tex(,527) following way and order: It is checked for
tricks.tex(,528) @enumerate
tricks.tex(,529) @item
tricks.tex(,530) a reserved name (like @code{ring}, @code{std}, @dots{}),
tricks.tex(,531) @item
tricks.tex(,532) a local  variable (w.r.t. a procedure),
tricks.tex(,533) @item
tricks.tex(,534) a local ring variable (w.r.t. the current basering locally set in a procedure),
tricks.tex(,535) @item
tricks.tex(,536) a global variable,
tricks.tex(,537) @item
tricks.tex(,538) a global ring variable (w.r.t. the current basering)
tricks.tex(,539) @item
tricks.tex(,540) a monomial consisting of local ring variables written without operators,
tricks.tex(,541) @item
tricks.tex(,542) a monomial consisting of global ring variables written without operators.
tricks.tex(,543) @end enumerate
tricks.tex(,544) 
tricks.tex(,545) Consequently, it is allowed to have general variables with the same name
tricks.tex(,546) as ring  variables. However, the above identifier resolution order must
tricks.tex(,547) be kept in mind. Otherwise, surprising results may come up.
tricks.tex(,548) 
tricks.tex(,549) @smallexample
tricks.tex(,550) @c reused example Identifier_resolution tricks.doc:517 
tricks.tex(,551) ring r=0,(x,y),dp;
tricks.tex(,552) int x;
tricks.tex(,553) x*y; // resolved product int*poly, i.e., 0*y
tricks.tex(,554) @expansion{} 0
tricks.tex(,555) xy; // "xy" is one identifier and resolved to monomial xy
tricks.tex(,556) @expansion{} xy
tricks.tex(,557) @c end example Identifier_resolution tricks.doc:517
tricks.tex(,558) @end smallexample
tricks.tex(,559) 
tricks.tex(,560) For these reasons, we strongly recommend not to use variables which
tricks.tex(,561) have the same name(s) as ring variables.
tricks.tex(,562) 
tricks.tex(,563) Moreover, we strongly recommend not to use ring variables whose name is
tricks.tex(,564) fully contained in (i.e., is a substring of) another name of a ring
tricks.tex(,565) variable. Otherwise, effects like the following might occur:
tricks.tex(,566) 
tricks.tex(,567) 
tricks.tex(,568) @smallexample
tricks.tex(,569) @c reused example Identifier_resolution_1 tricks.doc:534 
tricks.tex(,570) ring r=0,(x, x1),dp; // name x is substring of name x1 !!!!!!!!!
tricks.tex(,571) x;x1;   // resolved poly x
tricks.tex(,572) @expansion{} x
tricks.tex(,573) @expansion{} x1
tricks.tex(,574) short=0; 2x1; // resolved to monomial 2*x^1 !!!!!!
tricks.tex(,575) @expansion{} 2*x
tricks.tex(,576) 2*x1; // resolved to product 2 times x1
tricks.tex(,577) @expansion{} 2*x1
tricks.tex(,578) @c end example Identifier_resolution_1 tricks.doc:534
tricks.tex(,579) @end smallexample
singular.texi(,151) 
singular.texi(,152) @c ----------------------------------------------------------------------------
singular.texi(,153) @node Examples, Polynomial data, Tricks and pitfalls, Top
singular.texi(,154) @appendix Examples
singular.texi(,155) @cindex Examples
examples.tex(,1) @comment -*-texinfo-*-
examples.tex(,2) @comment This file was generated by doc2tex.pl from examples.doc
examples.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT examples.doc INSTEAD
examples.tex(,4) @comment Id: examples.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
examples.tex(,5) @comment this file contains the examples
examples.tex(,6) 
examples.tex(,7) @c The following directives are necessary for proper compilation
examples.tex(,8) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
examples.tex(,9) @c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
examples.tex(,10) @c `makeinfo' but is a great help in editing this file (emacs
examples.tex(,11) @c ignores the `@ignore').
examples.tex(,24) 
examples.tex(,28) 
examples.tex(,30) @menu
examples.tex(,31) * Milnor and Tjurina::
examples.tex(,32) * Procedures and LIB::
examples.tex(,33) * Critical points::
examples.tex(,34) * Saturation::
examples.tex(,35) * Long coefficients::
examples.tex(,36) * Parameters::
examples.tex(,37) * T1 and T2::
examples.tex(,38) * Deformations::
examples.tex(,39) * Finite fields::
examples.tex(,40) * Elimination::
examples.tex(,41) * Free resolution::
examples.tex(,42) * Computation of Ext::
examples.tex(,43) * Polar curves::
examples.tex(,44) * Depth::
examples.tex(,45) * Formatting output::
examples.tex(,46) * Cyclic roots::
examples.tex(,47) * G_a -Invariants::
examples.tex(,48) * Invariants of a finite group::
examples.tex(,49) * Factorization::
examples.tex(,50) * Puiseux pairs::
examples.tex(,51) * Primary decomposition::
examples.tex(,52) * Normalization::
examples.tex(,53) * Branches of an Isolated Space Curve Singularity::
examples.tex(,54) * Kernel of module homomorphisms::
examples.tex(,55) * Algebraic dependence::
examples.tex(,56) * Classification::
examples.tex(,57) * Fast lexicographical GB::
examples.tex(,58) * Parallelization with MPtcp links::
examples.tex(,59) @end menu
examples.tex(,61) 
examples.tex(,78) 
examples.tex(,79) @c ----------------------------------------------------------------------------
examples.tex(,80) @c @node Start SINGULAR, Milnor and Tjurina,Examples, Examples
examples.tex(,81) @c @section Start SINGULAR
examples.tex(,82) @c @cindex Start SINGULAR
examples.tex(,83) 
examples.tex(,84) @c Call @sc{Singular} by typing @code{Singular} [return]
examples.tex(,85) 
examples.tex(,86) @c To use the online help type for instance:
examples.tex(,87) @c    @code{help;} @code{help command;} @code{help General syntax;} @code{help ring;}...
examples.tex(,88) @c Please note:  EVERY COMMAND MUST END WITH A SEMICOLON ";"
examples.tex(,89) 
examples.tex(,90) @c To leave @sc{Singular}, type one of the:
examples.tex(,91) @c    @code{quit;} @code{exit;} @code{$}
examples.tex(,92) 
examples.tex(,93) @c The two characters @code{//} make the rest of the line a comment.
examples.tex(,94) 
examples.tex(,95) @c ----------------------------------------------------------------------------
examples.tex(,96) @node Milnor and Tjurina, Procedures and LIB, Examples, Examples
examples.tex(,97) @section Milnor and Tjurina
examples.tex(,98) @cindex Milnor
examples.tex(,99) @cindex Tjurina
examples.tex(,100) 
examples.tex(,101) The Milnor number, resp.@: the Tjurina number, of a power
examples.tex(,102) series f in
examples.tex(,109) is
examples.tex(,126) @code{jacob(f)} is the ideal generated by the partials
examples.tex(,127) of @code{f}. @code{tjurina(f)} is finite, if and only if @code{f} has an
examples.tex(,128) isolated singularity. The same holds for @code{milnor(f)} if
examples.tex(,129) K has characteristic 0.
examples.tex(,130) @sc{Singular} displays -1 if the dimension is infinite.
examples.tex(,131) 
examples.tex(,132) @sc{Singular} cannot compute with infinite power series. But it can
examples.tex(,133) work in
examples.tex(,140) the localization of
examples.tex(,147) at the maximal ideal
examples.tex(,154) To do this one has to define an
examples.tex(,155) s-ordering like ds, Ds, ls, ws, Ws or an appropriate matrix
examples.tex(,156) ordering (look at the manual to get information about the possible
examples.tex(,157) monomial orderings in @sc{Singular}, or type @code{help Monomial orderings;}
examples.tex(,158) to get a menu of possible orderings. For further help type, e.g.,
examples.tex(,159) @code{help local orderings;}).
examples.tex(,161) See @ref{Monomial orderings}.
examples.tex(,163) 
examples.tex(,164) We shall show in the example below how to realize the following:
examples.tex(,165) @itemize @bullet
examples.tex(,166) @item
examples.tex(,167) set option @code{prot} to have a short protocol during standard basis
examples.tex(,168) computation
examples.tex(,169) @item
examples.tex(,170) define the ring @code{r1} with char 32003, variables @code{x,y,z}, monomial
examples.tex(,171)   ordering @code{ds}, series ring (i.e., K[x,y,z] localized at (x,y,z))
examples.tex(,172) @item
examples.tex(,173) list the information about @code{r1} by typing its name
examples.tex(,174) @item
examples.tex(,175) define the integers @code{a,b,c,t}
examples.tex(,176) @item
examples.tex(,177) define a polynomial @code{f} (depending on @code{a,b,c,t}) and display it
examples.tex(,178) @item
examples.tex(,179) define the jacobian ideal @code{i} of @code{f}
examples.tex(,180) @item
examples.tex(,181) compute a standard basis of @code{i}
examples.tex(,182) @item
examples.tex(,183) compute the Milnor number (=250) with @code{vdim} and create and display
examples.tex(,184)   a string in order to comment the result
examples.tex(,185)   (text between quotes "  "; is a 'string')
examples.tex(,186) @item
examples.tex(,187) compute a standard basis of @code{i+(f)}
examples.tex(,188) @item
examples.tex(,189) compute the Tjurina number (=195) with @code{vdim}
examples.tex(,190) @item
examples.tex(,191) then compute the Milnor number (=248) and the Tjurina number
examples.tex(,192) (=195) for @code{t}=1
examples.tex(,193) @item
examples.tex(,194) reset the option to @code{noprot}
examples.tex(,195) @end itemize
examples.tex(,196) 
examples.tex(,197) @smallexample
examples.tex(,198) @c computed example Milnor_and_Tjurina examples.doc:196 
examples.tex(,199)   option(prot);
examples.tex(,200)   ring r1 = 32003,(x,y,z),ds;
examples.tex(,201)   r1;
examples.tex(,202) @expansion{} //   characteristic : 32003
examples.tex(,203) @expansion{} //   number of vars : 3
examples.tex(,204) @expansion{} //        block   1 : ordering ds
examples.tex(,205) @expansion{} //                  : names    x y z 
examples.tex(,206) @expansion{} //        block   2 : ordering C
examples.tex(,207)   int a,b,c,t=11,5,3,0;
examples.tex(,208)   poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
examples.tex(,209)            x^(c-2)*y^c*(y^2+t*x)^2;
examples.tex(,210)   f;
examples.tex(,211) @expansion{} y5+x5y2+x2y2z3+xy7+z9+x11
examples.tex(,212)   ideal i=jacob(f);
examples.tex(,213)   i;
examples.tex(,214) @expansion{} i[1]=5x4y2+2xy2z3+y7+11x10
examples.tex(,215) @expansion{} i[2]=5y4+2x5y+2x2yz3+7xy6
examples.tex(,216) @expansion{} i[3]=3x2y2z2+9z8
examples.tex(,217)   ideal j=std(i);
examples.tex(,218) @expansion{} [1023:2]7(2)s8s10s11s12s(3)s13(4)s(5)s14(6)s(7)15--.s(6)-16.-.s(5)17.s(7)\
examples.tex(,219)    s--s18(6).--19-..sH(24)20(3)...21....22....23.--24-
examples.tex(,220) @expansion{} product criterion:10 chain criterion:69
examples.tex(,221)   "The Milnor number of f(11,5,3) for t=0 is", vdim(j);
examples.tex(,222) @expansion{} The Milnor number of f(11,5,3) for t=0 is 250
examples.tex(,223)   j=i+f;    // overwrite j
examples.tex(,224)   j=std(j);
examples.tex(,225) @expansion{} [1023:2]7(3)s8(2)s10s11(3)ss12(4)s(5)s13(6)s(8)s14(9).s(10).15--sH(23)(8)\
examples.tex(,226)    ...16......17.......sH(21)(9)sH(20)16(10).17...........18.......19..----.\
examples.tex(,227)    .sH(19)
examples.tex(,228) @expansion{} product criterion:10 chain criterion:53
examples.tex(,229)   vdim(j);  // compute the Tjurina number for t=0
examples.tex(,230) @expansion{} 195
examples.tex(,231)   t=1;
examples.tex(,232)   f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
examples.tex(,233)     +x^(c-2)*y^c*(y^2+t*x)^2;
examples.tex(,234)   ideal i1=jacob(f);
examples.tex(,235)   ideal j1=std(i1);
examples.tex(,236) @expansion{} [1023:2]7(2)s8s10s11s12s13(3)ss(4)s14(5)s(6)s15(7).....s(8)16.s...s(9)..1\
examples.tex(,237)    7............s18(10).....s(11)..-.19.......sH(24)(10).....20...........21\
examples.tex(,238)    ..........22.............................23..............................\
examples.tex(,239)    .24.----------.25.26
examples.tex(,240) @expansion{} product criterion:11 chain criterion:83
examples.tex(,241)   "The Milnor number of f(11,5,3) for t=1:",vdim(j1);
examples.tex(,242) @expansion{} The Milnor number of f(11,5,3) for t=1: 248
examples.tex(,243)   vdim(std(j1+f));   // compute the Tjurina number for t=1
examples.tex(,244) @expansion{} [1023:2]7(16)s8(15)s10s11ss(16)-12.s-s13s(17)s(18)s(19)-s(18).-14-s(17)-s\
examples.tex(,245)    (16)ss(17)s15(18)..-s...--.16....-.......s(16).sH(23)s(18)...17..........\
examples.tex(,246)    18.........sH(20)17(17)....................18..........19..---....-.-....\
examples.tex(,247)    .....20.-----...s17(9).........18..............19..-.......20.-......21..\
examples.tex(,248)    .......sH(19)16(5).....18......19.-----
examples.tex(,249) @expansion{} product criterion:15 chain criterion:174
examples.tex(,250) @expansion{} 195
examples.tex(,251)   option(noprot);
examples.tex(,252) @c end example Milnor_and_Tjurina examples.doc:196
examples.tex(,253) @end smallexample
examples.tex(,254) 
examples.tex(,255) @c ----------------------------------------------------------------------------
examples.tex(,256) @node Procedures and LIB, Critical points, Milnor and Tjurina, Examples
examples.tex(,257) @section Procedures and LIB
examples.tex(,258) @cindex Procedures and LIB
examples.tex(,259) 
examples.tex(,260) The computation of the Milnor number (for an arbitrary isolated complete
examples.tex(,261) intersection singularity ICIS) and the Tjurina number (for an arbitrary
examples.tex(,262) isolated singularity) can be done by using procedures from the library
examples.tex(,263) @code{sing.lib}. For a hypersurface singularity it is very easy to write a
examples.tex(,264) procedure which computes the Milnor number and the Tjurina number.
examples.tex(,265) 
examples.tex(,266) We shall demonstrate:
examples.tex(,267) @itemize @bullet
examples.tex(,268) @item
examples.tex(,269) load the library @code{sing.lib}
examples.tex(,270) @c item
examples.tex(,271) @c disable the protocol option
examples.tex(,272) @item
examples.tex(,273) define a local ring in 2 variables and characteristic 0
examples.tex(,274) @item
examples.tex(,275) define a plane curve singularity
examples.tex(,276) @item
examples.tex(,277) compute Milnor number and Tjurina number by using the procedures
examples.tex(,278) @code{milnor} and @code{tjurina}
examples.tex(,279) @item
examples.tex(,280) write your own procedures:
examples.tex(,281) (A procedure has a list of input parameters and of return values, both
examples.tex(,282) lists may be empty.)
examples.tex(,283)   @itemize @minus
examples.tex(,284)   @item
examples.tex(,285)   the procedure @code{mil} which must be called with one parameter, a
examples.tex(,286)   polynomial.
examples.tex(,287)   The name g is local to the procedure and is killed automatically.
examples.tex(,288)   @code{mil} returns the Milnor number (and displays a comment).
examples.tex(,289)   @item
examples.tex(,290)   the procedure @code{tjur} where the parameters are not specified. They
examples.tex(,291)   are referred
examples.tex(,292)   to by @code{#[1]} for the 1st, @code{#[2]} for the 2nd parameter, etc.
examples.tex(,293)   @code{tjur} returns the Tjurina number (and displays a comment).
examples.tex(,294)   @item
examples.tex(,295)   the procedure @code{milrina} which returns a list consisting of two
examples.tex(,296)   integers,
examples.tex(,297)   the Milnor and the Tjurina number.
examples.tex(,298)   @end itemize
examples.tex(,299) @end itemize
examples.tex(,300) 
examples.tex(,301) @smallexample
examples.tex(,302) LIB "sing.lib";
examples.tex(,303) // you should get the information that sing.lib has been loaded
examples.tex(,304) // together with some other libraries which are needed by sing.lib
examples.tex(,305) ring r = 0,(x,y),ds;
examples.tex(,306) poly f = x7+y7+(x-y)^2*x2y2;
examples.tex(,307) milnor(f);
examples.tex(,308) @expansion{} 28
examples.tex(,309) tjurina(f);
examples.tex(,310) @expansion{} 24
examples.tex(,311) 
examples.tex(,312) proc mil (poly g)
examples.tex(,313) @{
examples.tex(,314)    "Milnor number:";
examples.tex(,315)    return(vdim(std(jacob(g))));
examples.tex(,316) @}
examples.tex(,317) mil(f);
examples.tex(,318) @expansion{} Milnor number:
examples.tex(,319) @expansion{} 28
examples.tex(,320) 
examples.tex(,321) proc tjur
examples.tex(,322) @{
examples.tex(,323)    "Tjurina number:";
examples.tex(,324)    return(vdim(std(jacob(#[1])+#[1])));
examples.tex(,325) @}
examples.tex(,326) tjur(f);
examples.tex(,327) @expansion{} Tjurina number:
examples.tex(,328) @expansion{} 24
examples.tex(,329) 
examples.tex(,330) proc milrina (poly f)
examples.tex(,331) @{
examples.tex(,332)    ideal j=jacob(f);
examples.tex(,333)    list L=vdim(std(j)),vdim(std(j+f));
examples.tex(,334)    return(L);
examples.tex(,335) @}
examples.tex(,336) milrina(f);     // a list containing Milnor and Tjurina number
examples.tex(,337) @expansion{} [1]:
examples.tex(,338) @expansion{}    28
examples.tex(,339) @expansion{} [2]:
examples.tex(,340) @expansion{}    24
examples.tex(,341) milrina(f)[2];  // the second element of the list
examples.tex(,342) @expansion{} 24
examples.tex(,343) @end smallexample
examples.tex(,344) 
examples.tex(,345) @c ----------------------------------------------------------------------------
examples.tex(,346) @node Critical points, Saturation, Procedures and LIB, Examples
examples.tex(,347) @section Critical points
examples.tex(,348) @cindex Critical points
examples.tex(,349) 
examples.tex(,350) The same computation which computes the Milnor, resp.@: the Tjurina,
examples.tex(,351) number, but with ordering @code{dp} instead of @code{ds} (i.e., in
examples.tex(,358) instead of
examples.tex(,365) gives:
examples.tex(,366) @itemize @bullet
examples.tex(,367) @item
examples.tex(,368) the number of critical points of @code{f} in the affine plane
examples.tex(,369) (counted with multiplicities)
examples.tex(,370) @item
examples.tex(,371) the number of singular points of @code{f} on the affine plane curve @code{f}=0
examples.tex(,372) (counted with multiplicities).
examples.tex(,373) @end itemize
examples.tex(,374) 
examples.tex(,375) We start with the ring @code{r1} from section @ref{Milnor and Tjurina} and its elements.
examples.tex(,376) 
examples.tex(,377) The following will be realized below:
examples.tex(,378) @itemize @bullet
examples.tex(,379) @item
examples.tex(,380) reset the protocol option and activate the timer
examples.tex(,381) @item
examples.tex(,382) define the ring @code{r2} with char 32003, variables @code{x,y,z} and monomial
examples.tex(,383)   ordering @code{dp} (= degrevlex) (i.e., the polynomial ring = K[x,y,z]).
examples.tex(,384) @item
examples.tex(,385) Note that polynomials, ideals, matrices (of polys), vectors,
examples.tex(,386)   modules belong to a ring, hence we have to define @code{f} and @code{jacob(f)}
examples.tex(,387)   again in @code{r2}. Since these objects are local to a ring, we may use
examples.tex(,388)   the same names.
examples.tex(,389)   Instead of defining @code{f} again we map it from ring @code{r1} to @code{r2}
examples.tex(,390)   by using the @code{imap} command
examples.tex(,391)   (@code{imap} is a convenient way to map variables
examples.tex(,392)   from some ring identically to variables with the same name in the
examples.tex(,393)   basering, even if the ground field is different. Compare with @code{fetch}
examples.tex(,394)   which works for almost identical rings,
examples.tex(,395)   e.g., if the rings differ only by the ordering or by the names of the
examples.tex(,396)   variables and which may be used to rename variables).
examples.tex(,397)   Integers and strings, however, do not belong to any ring. Once
examples.tex(,398)   defined they are globally known.
examples.tex(,399) @item
examples.tex(,400) The result of the computation here (together with the previous one in
examples.tex(,401)  @ref{Milnor and Tjurina}) shows that (for @code{t}=0)
examples.tex(,408) = 250 (previously computed) while
examples.tex(,415) = 536. Hence @code{f} has 286 critical points,
examples.tex(,416)   counted with multiplicity, outside the origin.
examples.tex(,417)   Moreover, since
examples.tex(,424) = 195 =
examples.tex(,431) the affine surface @code{f}=0 is smooth outside the origin.
examples.tex(,432) @end itemize
examples.tex(,433) 
examples.tex(,434) @smallexample
examples.tex(,435) @c computed example Critical_points examples.doc:402 
examples.tex(,436)   ring r1 = 32003,(x,y,z),ds;
examples.tex(,437)   int a,b,c,t=11,5,3,0;
examples.tex(,438)   poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
examples.tex(,439)            x^(c-2)*y^c*(y^2+t*x)^2;
examples.tex(,440)   option(noprot);
examples.tex(,441)   timer=1;
examples.tex(,442)   ring r2 = 32003,(x,y,z),dp;
examples.tex(,443)   poly f=imap(r1,f);
examples.tex(,444)   ideal j=jacob(f);
examples.tex(,445)   vdim(std(j));
examples.tex(,446) @expansion{} 536
examples.tex(,447)   vdim(std(j+f));
examples.tex(,448) @expansion{} 195
examples.tex(,449)   timer=0;  // reset timer
examples.tex(,450) @c end example Critical_points examples.doc:402
examples.tex(,451) @end smallexample
examples.tex(,452) 
examples.tex(,453) @c ----------------------------------------------------------------------------
examples.tex(,455) @node Saturation, Long coefficients, Critical points, Examples
examples.tex(,460) @section Saturation
examples.tex(,461) @cindex Saturation
examples.tex(,462) 
examples.tex(,463) Since in the example above, the ideal 
examples.tex(,470)  has the same @code{vdim}
examples.tex(,471) in the polynomial ring and in the localization at 0 (each 195),
examples.tex(,472) 
examples.tex(,479)  is smooth outside 0.
examples.tex(,480) Hence 
examples.tex(,487)  contains some power of the maximal ideal 
examples.tex(,494) . We shall
examples.tex(,495) check this in a different manner:
examples.tex(,496) For any two ideals 
examples.tex(,503)  in the basering 
examples.tex(,510)  let
examples.tex(,521) @*denote the saturation of 
examples.tex(,528)  with respect to 
examples.tex(,535) . This defines,
examples.tex(,536) geometrically, the closure of the complement of V(
examples.tex(,543) ) in V(
examples.tex(,550) )
examples.tex(,551) (V(
examples.tex(,558) ) denotes the variety defined by 
examples.tex(,565) ).
examples.tex(,566) In our case, 
examples.tex(,573)  must be the whole ring, hence
examples.tex(,574) generated by 1.
examples.tex(,575) 
examples.tex(,576) The saturation is computed by the procedure @code{sat} in
examples.tex(,577) @code{elim.lib} by computing iterated ideal quotients with the maximal
examples.tex(,578) ideal.  @code{sat} returns a list of two elements: the saturated ideal
examples.tex(,579) and the number of iterations.  (Note that @code{maxideal(n)} denotes the
examples.tex(,580) n-th power of the maximal ideal).
examples.tex(,581) 
examples.tex(,582) @smallexample
examples.tex(,583) @c computed example Saturation examples.doc:457 
examples.tex(,584)   LIB "elim.lib";         // loading library elim.lib
examples.tex(,585)   // you should get the information that elim.lib has been loaded
examples.tex(,586)   // together with some other libraries which are needed by it
examples.tex(,587)   option(noprot);         // no protocol
examples.tex(,588)   ring r2 = 32003,(x,y,z),dp;
examples.tex(,589)   poly f = x^11+y^5+z^(3*3)+x^(3+2)*y^(3-1)+x^(3-1)*y^(3-1)*z3+
examples.tex(,590)     x^(3-2)*y^3*(y^2)^2;
examples.tex(,591)   ideal j=jacob(f);
examples.tex(,592)   sat(j+f,maxideal(1));
examples.tex(,593) @expansion{} [1]:
examples.tex(,594) @expansion{}    _[1]=1
examples.tex(,595) @expansion{} [2]:
examples.tex(,596) @expansion{}    17
examples.tex(,597)   // list the variables defined so far:
examples.tex(,598)   listvar();
examples.tex(,599) @expansion{} // r2                   [0]  *ring
examples.tex(,600) @expansion{} //      j                    [0]  ideal, 3 generator(s)
examples.tex(,601) @expansion{} //      f                    [0]  poly
examples.tex(,602) @expansion{} // LIB                  [0]  string standard.lib,elim.li..., 83 char(s)
examples.tex(,603) @c end example Saturation examples.doc:457
examples.tex(,604) @end smallexample
examples.tex(,605) 
examples.tex(,606) @c ----------------------------------------------------------------------------
examples.tex(,608) @node Long coefficients, Parameters, Saturation, Examples
examples.tex(,609) @section Long coefficients
examples.tex(,610) @cindex Long coefficients
examples.tex(,611) 
examples.tex(,612) The following innocent example produces in its standard basis
examples.tex(,613) extremely long coefficients in char 0 for the lexicographical
examples.tex(,614) ordering.
examples.tex(,615) But a very small deformation does not (the undeformed
examples.tex(,616) example is degenerate with respect to the Newton boundary).
examples.tex(,617) This example demonstrates that it might be wise, for complicated
examples.tex(,618) examples, to do the calculation first in positive char (e.g., 32003).
examples.tex(,619) It has been shown, that in complicated examples, more than 95 percent of
examples.tex(,620) the time needed for a standard basis computation is used in the
examples.tex(,621) computation of the coefficients (in char 0).
examples.tex(,622) The representation of long integers with real is demonstrated.
examples.tex(,623) 
examples.tex(,624) @smallexample
examples.tex(,625) @c computed example Long_coefficients examples.doc:491 
examples.tex(,626) timer = 1;                              // activate the timer
examples.tex(,627) option(prot);
examples.tex(,628) ring R0 = 0,(x,y),lp;
examples.tex(,629) poly f = x5+y11+xy9+x3y9;
examples.tex(,630) ideal i = jacob(f);
examples.tex(,631) ideal i1 = i,i[1]*i[2];                 // undeformed ideal
examples.tex(,632) ideal i2 = i,i[1]*i[2]+1/1000000*x5y8;  // deformation of i1
examples.tex(,633) i1; i2;
examples.tex(,634) @expansion{} i1[1]=5x4+3x2y9+y9
examples.tex(,635) @expansion{} i1[2]=9x3y8+9xy8+11y10
examples.tex(,636) @expansion{} i1[3]=45x7y8+27x5y17+45x5y8+55x4y10+36x3y17+33x2y19+9xy17+11y19
examples.tex(,637) @expansion{} i2[1]=5x4+3x2y9+y9
examples.tex(,638) @expansion{} i2[2]=9x3y8+9xy8+11y10
examples.tex(,639) @expansion{} i2[3]=45x7y8+27x5y17+45000001/1000000x5y8+55x4y10+36x3y17+33x2y19+9xy17+1\
examples.tex(,640)    1y19
examples.tex(,641) ideal j = std(i1);
examples.tex(,642) @expansion{} [65535:1]11(2)ss19s20s21s22(3)-23-s27s28s29s30s31s32s33s34s35s36s37s38s39\
examples.tex(,643)    s40s70-
examples.tex(,644) @expansion{} product criterion:1 chain criterion:30
examples.tex(,645) j;
examples.tex(,646) @expansion{} j[1]=264627y39+26244y35-1323135y30-131220y26+1715175y21+164025y17+1830125\
examples.tex(,647)    y16
examples.tex(,648) @expansion{} j[2]=12103947791971846719838321886393392913750065060875xy8-28639152114168\
examples.tex(,649)    3198701331939250003266767738632875y38-31954402206909026926764622877573565\
examples.tex(,650)    78554430672591y37+57436621420822663849721381265738895282846320y36+1657764\
examples.tex(,651)    214948799497573918210031067353932439400y35+213018481589308191195677223898\
examples.tex(,652)    98682697001205500y34+1822194158663066565585991976961565719648069806148y33\
examples.tex(,653)    -4701709279892816135156972313196394005220175y32-1351872269688192267600786\
examples.tex(,654)    97600850686824231975y31-3873063305929810816961516976025038053001141375y30\
examples.tex(,655)    +1325886675843874047990382005421144061861290080000y29+1597720195476063141\
examples.tex(,656)    9467945895542406089526966887310y28-26270181336309092660633348002625330426\
examples.tex(,657)    7126525y27-7586082690893335269027136248944859544727953125y26-867853074106\
examples.tex(,658)    49464602285843351672148965395945625y25-5545808143273594102173252331151835\
examples.tex(,659)    700278863924745y24+19075563013460437364679153779038394895638325y23+548562\
examples.tex(,660)    322715501761058348996776922561074021125y22+157465452677648386073957464715\
examples.tex(,661)    68100780933983125y21-1414279129721176222978654235817359505555191156250y20\
examples.tex(,662)    -20711190069445893615213399650035715378169943423125y19+272942733337472665\
examples.tex(,663)    573418092977905322984009750y18+789065115845334505801847294677413365720955\
examples.tex(,664)    3750y17+63554897038491686787729656061044724651089803125y16-22099251729923\
examples.tex(,665)    906699732244761028266074350255961625y14+147937139679655904353579489722585\
examples.tex(,666)    91339027857296625y10
examples.tex(,667) @expansion{} j[3]=5x4+3x2y9+y9
examples.tex(,668) // Compute average coefficient length (=51) by
examples.tex(,669) //   - converting j[2] to a string in order to compute the number
examples.tex(,670) //   of characters
examples.tex(,671) //   - divide this by the number of monomials:
examples.tex(,672) size(string(j[2]))/size(j[2]);
examples.tex(,673) @expansion{} 51
examples.tex(,674) vdim(j);
examples.tex(,675) @expansion{} 63
examples.tex(,676) // For a better representation normalize the long coefficients
examples.tex(,677) // of the polynomial j[2] and map it  to real:
examples.tex(,678) poly p=(1/12103947791971846719838321886393392913750065060875)*j[2];
examples.tex(,679) ring R1=real,(x,y),lp;
examples.tex(,680) short=0; // force the long output format
examples.tex(,681) poly p=imap(R0,p);
examples.tex(,682) p;
examples.tex(,683) @expansion{} x*y^8-2.366e-02*y^38-2.640e-01*y^37+4.745e-06*y^36+1.370e-04*y^35+1.760e-\
examples.tex(,684)    03*y^34+1.505e-01*y^33+3.884e-07*y^32-1.117e-05*y^31-3.200e-04*y^30+1.095\
examples.tex(,685)    e-01*y^29+1.320e+00*y^28-2.170e-05*y^27-6.267e-04*y^26-7.170e-03*y^25-4.5\
examples.tex(,686)    82e-01*y^24+1.576e-06*y^23+4.532e-05*y^22+1.301e-03*y^21-1.168e-01*y^20-1\
examples.tex(,687)    .711e+00*y^19+2.255e-05*y^18+6.519e-04*y^17+5.251e-03*y^16-1.826e+00*y^14\
examples.tex(,688)    +1.222e+00*y^10
examples.tex(,689) // Compute a standard basis for the deformed ideal:
examples.tex(,690) setring R0;
examples.tex(,691) j = std(i2);
examples.tex(,692) @expansion{} [65535:1]11(2)ss19s20s21s22(3)-s23(2)s27.28.s29(3)s30.s31ss32sss33sss34ss\
examples.tex(,693)    35--38-
examples.tex(,694) @expansion{} product criterion:11 chain criterion:21
examples.tex(,695) j;
examples.tex(,696) @expansion{} j[1]=y16
examples.tex(,697) @expansion{} j[2]=65610xy8+17393508y27+7223337y23+545292y19+6442040y18-119790y14+80190\
examples.tex(,698)    y10
examples.tex(,699) @expansion{} j[3]=5x4+3x2y9+y9
examples.tex(,700) vdim(j);
examples.tex(,701) @expansion{} 40
examples.tex(,702) @c end example Long_coefficients examples.doc:491
examples.tex(,703) @end smallexample
examples.tex(,705) @c ----------------------------------------------------------------------------
examples.tex(,707) @node Parameters, T1 and T2, Long coefficients, Examples
examples.tex(,712) @section Parameters
examples.tex(,713) @cindex Parameters
examples.tex(,714) 
examples.tex(,716) Let us deform the above ideal now by introducing a parameter t
examples.tex(,717) and compute over the ground field Q(t).
examples.tex(,718) We compute the dimension at the generic point,
examples.tex(,725) i.e.,
examples.tex(,733) (This gives the
examples.tex(,734) same result as for the deformed ideal above. Hence, the above small
examples.tex(,735) deformation was "generic".)
examples.tex(,737) 
examples.tex(,738) For almost all
examples.tex(,745) this is the same as
examples.tex(,752) where
examples.tex(,759) 
examples.tex(,760) @smallexample
examples.tex(,761) @c computed example Parameters examples.doc:579 
examples.tex(,762)   ring Rt = (0,t),(x,y),lp;
examples.tex(,763)   Rt;
examples.tex(,764) @expansion{} //   characteristic : 0
examples.tex(,765) @expansion{} //   1 parameter    : t 
examples.tex(,766) @expansion{} //   minpoly        : 0
examples.tex(,767) @expansion{} //   number of vars : 2
examples.tex(,768) @expansion{} //        block   1 : ordering lp
examples.tex(,769) @expansion{} //                  : names    x y 
examples.tex(,770) @expansion{} //        block   2 : ordering C
examples.tex(,771)   poly f = x5+y11+xy9+x3y9;
examples.tex(,772)   ideal i = jacob(f);
examples.tex(,773)   ideal j = i,i[1]*i[2]+t*x5y8;  // deformed ideal, parameter t
examples.tex(,774)   vdim(std(j));
examples.tex(,775) @expansion{} 40
examples.tex(,776)   ring R=0,(x,y),lp;
examples.tex(,777)   ideal i=imap(Rt,i);
examples.tex(,778)   int a=random(1,30000);
examples.tex(,779)   ideal j=i,i[1]*i[2]+a*x5y8;  // deformed ideal, fixed integer a
examples.tex(,780)   vdim(std(j));
examples.tex(,781) @expansion{} 40
examples.tex(,782) @c end example Parameters examples.doc:579
examples.tex(,783) @end smallexample
examples.tex(,784) 
examples.tex(,785) @c ----------------------------------------------------------------------------
examples.tex(,787) @node T1 and T2, Deformations, Parameters, Examples
examples.tex(,788) @section T1 and T2
examples.tex(,789) @cindex T1
examples.tex(,790) @cindex T2
examples.tex(,791) 
examples.tex(,792) 
examples.tex(,799) , resp.@: 
examples.tex(,806) , of an ideal 
examples.tex(,813)  usually denote the modules of
examples.tex(,814) infinitesimal deformations, resp.@: of obstructions.
examples.tex(,815) In @sc{Singular} there are procedures @code{T_1} and @code{T_2} in
examples.tex(,816) @code{sing.lib} such that
examples.tex(,817) @code{T_1(j)} and @code{T_2(j)} compute a standard basis of
examples.tex(,818) a presentation of these modules.
examples.tex(,819) If T_1 and T_2 are finite dimensional K-vector spaces (e.g., for isolated
examples.tex(,820) singularities), a basis can be computed by applying
examples.tex(,821) @code{kbase(T_1(j));}, resp.@: @code{kbase(T_2(j));}, the dimensions by
examples.tex(,822) applying @code{vdim}.
examples.tex(,823) For a complete intersection j the procedure @code{Tjurina} also
examples.tex(,824) computes T_1, but faster (T_2=0 in this case).
examples.tex(,825) For a non complete intersection, it is faster to use the procedure @code{T_12}
examples.tex(,826) instead of @code{T_1} and @code{T_2}.
examples.tex(,827) Type @code{help T_1;} (or @code{help T_2;} or @code{help T_12;}) to obtain
examples.tex(,828) more detailed information about these procedures.
examples.tex(,829) 
examples.tex(,830) We give three examples, the first being a hypersurface, the second a complete
examples.tex(,831) intersection, the third no complete intersection:
examples.tex(,832) @itemize @bullet
examples.tex(,833) @item
examples.tex(,834) load @code{sing.lib}
examples.tex(,835) @item
examples.tex(,836) check whether the ideal j is a complete intersection. It is, if
examples.tex(,837)      number of variables = dimension + minimal number of generators
examples.tex(,838) @item
examples.tex(,839) compute the Tjurina number
examples.tex(,840) @item
examples.tex(,841) compute a vector space basis (kbase) of T_1
examples.tex(,842) @item
examples.tex(,843) compute the Hilbert function of T_1
examples.tex(,844) @item
examples.tex(,845) create a polynomial encoding the Hilbert series
examples.tex(,846) @item
examples.tex(,847) compute the dimension of T_2
examples.tex(,848) @end itemize
examples.tex(,849) 
examples.tex(,850) @smallexample
examples.tex(,851) @c computed example T1_and_T2 examples.doc:639 
examples.tex(,852)   LIB "sing.lib";
examples.tex(,853)   ring R=32003,(x,y,z),ds;
examples.tex(,854)   // ---------------------------------------
examples.tex(,855)   // hypersurface case (from series T[p,q,r]):
examples.tex(,856)   int p,q,r = 3,3,4;
examples.tex(,857)   poly f = x^p+y^q+z^r+xyz;
examples.tex(,858)   tjurina(f);
examples.tex(,859) @expansion{} 8
examples.tex(,860)   // Tjurina number = 8
examples.tex(,861)   kbase(Tjurina(f));
examples.tex(,862) @expansion{} // Tjurina number = 8
examples.tex(,863) @expansion{} _[1]=z3
examples.tex(,864) @expansion{} _[2]=z2
examples.tex(,865) @expansion{} _[3]=yz
examples.tex(,866) @expansion{} _[4]=xz
examples.tex(,867) @expansion{} _[5]=z
examples.tex(,868) @expansion{} _[6]=y
examples.tex(,869) @expansion{} _[7]=x
examples.tex(,870) @expansion{} _[8]=1
examples.tex(,871)   // ---------------------------------------
examples.tex(,872)   // complete intersection case (from series P[k,l]):
examples.tex(,873)   int k,l =3,2;
examples.tex(,874)   ideal j=xy,x^k+y^l+z2;
examples.tex(,875)   dim(std(j));          // Krull dimension
examples.tex(,876) @expansion{} 1
examples.tex(,877)   size(minbase(j));     // minimal number of generators
examples.tex(,878) @expansion{} 2
examples.tex(,879)   tjurina(j);           // Tjurina number
examples.tex(,880) @expansion{} 6
examples.tex(,881)   module T=Tjurina(j);
examples.tex(,882) @expansion{} // Tjurina number = 6
examples.tex(,883)   kbase(T);             // a sparse output of the k-basis of T_1
examples.tex(,884) @expansion{} _[1]=z*gen(1)
examples.tex(,885) @expansion{} _[2]=gen(1)
examples.tex(,886) @expansion{} _[3]=y*gen(2)
examples.tex(,887) @expansion{} _[4]=x2*gen(2)
examples.tex(,888) @expansion{} _[5]=x*gen(2)
examples.tex(,889) @expansion{} _[6]=gen(2)
examples.tex(,890)   print(kbase(T));      // columns of matrix are a k-basis of T_1
examples.tex(,891) @expansion{} z,1,0,0, 0,0,
examples.tex(,892) @expansion{} 0,0,y,x2,x,1 
examples.tex(,893)   // ---------------------------------------
examples.tex(,894)   // general case (cone over rational normal curve of degree 4):
examples.tex(,895)   ring r1=0,(x,y,z,u,v),ds;
examples.tex(,896)   matrix m[2][4]=x,y,z,u,y,z,u,v;
examples.tex(,897)   ideal i=minor(m,2);   // 2x2 minors of matrix m
examples.tex(,898)   module M=T_1(i);       // a presentation matrix of T_1
examples.tex(,899) @expansion{} // dim T_1 = 4
examples.tex(,900)   vdim(M);              // Tjurina number
examples.tex(,901) @expansion{} 4
examples.tex(,902)   hilb(M);              // display of both Hilbert series
examples.tex(,903) @expansion{} //         4 t^0
examples.tex(,904) @expansion{} //       -20 t^1
examples.tex(,905) @expansion{} //        40 t^2
examples.tex(,906) @expansion{} //       -40 t^3
examples.tex(,907) @expansion{} //        20 t^4
examples.tex(,908) @expansion{} //        -4 t^5
examples.tex(,909) @expansion{} 
examples.tex(,910) @expansion{} //         4 t^0
examples.tex(,911) @expansion{} // dimension (local)   = 0
examples.tex(,912) @expansion{} // multiplicity = 4
examples.tex(,913)   intvec v1=hilb(M,1);  // first Hilbert series as intvec
examples.tex(,914)   intvec v2=hilb(M,2);  // second Hilbert series as intvec
examples.tex(,915)   v1;
examples.tex(,916) @expansion{} 4,-20,40,-40,20,-4,0
examples.tex(,917)   v2;
examples.tex(,918) @expansion{} 4,0
examples.tex(,919)   v1[3];                // 3rd coefficient of the 1st Hilbert series
examples.tex(,920) @expansion{} 40
examples.tex(,921)   module N=T_2(i);
examples.tex(,922) @expansion{} // dim T_2 = 3
examples.tex(,923) @c end example T1_and_T2 examples.doc:639
examples.tex(,924) @end smallexample
examples.tex(,925) @smallexample
examples.tex(,926) // In some cases it might be useful to have a polynomial in some ring
examples.tex(,927) // encoding the Hilbert series. This polynomial can then be
examples.tex(,928) // differentiated, evaluated etc. It can be done as follows:
examples.tex(,929) ring H = 0,t,ls;
examples.tex(,930) poly h1;
examples.tex(,931) int ii;
examples.tex(,932) for (ii=1; ii<=size(v1); ii=ii+1)
examples.tex(,933) @{
examples.tex(,934)    h1=h1+v1[ii]*t^(ii-1);
examples.tex(,935) @}
examples.tex(,936) h1;                   // 1st Hilbert series
examples.tex(,937) @expansion{} 4-20t+40t2-40t3+20t4-4t5
examples.tex(,938) diff(h1,t);           // differentiate  h1
examples.tex(,939) @expansion{} -20+80t-120t2+80t3-20t4
examples.tex(,940) subst(h1,t,1);        // substitute t by 1
examples.tex(,941) @expansion{} 0
examples.tex(,942) 
examples.tex(,943) // The procedures T_1, T_2, T_12 may be called with two arguments and then
examples.tex(,944) // they return a list with more information (type help T_1; etc.)
examples.tex(,945) // e.g., T_12(i,<any>); returns a list with 9 nonempty objects where
examples.tex(,946) // _[1] = std basis of T_1-module, _[2] = std basis of T_2-module,
examples.tex(,947) // _[3]= vdim of T_1, _[4]= vdim of T_2
examples.tex(,948) setring r1;           // make r1 again the basering
examples.tex(,949) list L = T_12(i,1);
examples.tex(,950) @expansion{} // dim T_1  =  4
examples.tex(,951) @expansion{} // dim T_2  =  3
examples.tex(,952) kbase(L[1]);          // kbase of T_1
examples.tex(,953) @expansion{} _[1]=1*gen(2)
examples.tex(,954) @expansion{} _[2]=1*gen(3)
examples.tex(,955) @expansion{} _[3]=1*gen(6)
examples.tex(,956) @expansion{} _[4]=1*gen(7)
examples.tex(,957) kbase(L[2]);          // kbase of T_2
examples.tex(,958) @expansion{} _[1]=1*gen(6)
examples.tex(,959) @expansion{} _[2]=1*gen(8)
examples.tex(,960) @expansion{} _[3]=1*gen(9)
examples.tex(,961) L[3];                 // vdim of T_1
examples.tex(,962) @expansion{} 4
examples.tex(,963) L[4];                 // vdim of T_2
examples.tex(,964) @expansion{} 3
examples.tex(,965) @end smallexample
examples.tex(,966) @c killall();            // a procedure from general.lib
examples.tex(,967) @c @expansion{} // ** killing the basering for level 0
examples.tex(,969) @c ----------------------------------------------------------------------------
examples.tex(,971) @node Deformations, Finite fields, T1 and T2, Examples
examples.tex(,976) @section Deformations
examples.tex(,977) @cindex Deformations
examples.tex(,978) 
examples.tex(,979) @itemize @bullet
examples.tex(,980) @item
examples.tex(,981) The libraries @code{sing.lib}, resp.@: @code{deform.lib}, contain procedures
examples.tex(,982) to compute total and base space of the
examples.tex(,983) miniversal (= semiuniversal) deformation of an
examples.tex(,984) isolated complete intersection singularity, resp.@: arbitrary isolated
examples.tex(,985) singularity.
examples.tex(,986) @item
examples.tex(,987) The procedure @code{deform} in @code{sing.lib} returns a matrix whose columns
examples.tex(,994) represent all 1st order deformations. More precisely, if
examples.tex(,1006) 
examples.tex(,1007) @item
examples.tex(,1008) The procedure @code{versal} in @code{deform.lib} computes a formal
examples.tex(,1009) miniversal deformation up to a certain order which can be
examples.tex(,1010) prescribed by the user. For a complete intersection the 1st order
examples.tex(,1011) part is already miniversal.
examples.tex(,1012) @item
examples.tex(,1013) The procedure @code{versal} extends the basering to a new ring with
examples.tex(,1014) additional deformation parameters which contains the equations for the
examples.tex(,1015) miniversal base space and the miniversal total space.
examples.tex(,1016) @item
examples.tex(,1017) There are default names for the objects created, but the user may also
examples.tex(,1018) choose his own names.
examples.tex(,1019) @item
examples.tex(,1020) If the user sets @code{printlevel=2;} before running @code{versal}, some
examples.tex(,1021) intermediate results are shown. This is useful since @code{versal}
examples.tex(,1022) is already complicated and might run for some time on more
examples.tex(,1023) complicated examples. (type @code{help versal;})
examples.tex(,1024) @end itemize
examples.tex(,1025) 
examples.tex(,1027) We compute for the same examples as in the preceding section
examples.tex(,1028) the miniversal deformations:
examples.tex(,1035) 
examples.tex(,1036) @smallexample
examples.tex(,1037) @c computed example Deformations examples.doc:787 
examples.tex(,1038)   LIB "deform.lib";
examples.tex(,1039)   ring R=32003,(x,y,z),ds;
examples.tex(,1040)   //----------------------------------------------------
examples.tex(,1041)   // hypersurface case (from series T[p,q,r]):
examples.tex(,1042)   int p,q,r = 3,3,4;
examples.tex(,1043)   poly f = x^p+y^q+z^r+xyz;
examples.tex(,1044)   print(deform(f));
examples.tex(,1045) @expansion{} z3,z2,yz,xz,z,y,x,1
examples.tex(,1046)   // the miniversal deformation of f=0 is the projection from the
examples.tex(,1047)   // miniversal total space to the miniversal base space:
examples.tex(,1048)   // @{ (A,B,C,D,E,F,G,H,x,y,z) | x3+y3+xyz+z4+A+Bx+Cxz+Dy+Eyz+Fz+Gz2+Hz3 =0 @}
examples.tex(,1049)   //  --> @{ (A,B,C,D,E,F,G,H) @}
examples.tex(,1050)   //----------------------------------------------------
examples.tex(,1051)   // complete intersection case (from series P[k,l]):
examples.tex(,1052)   int k,l =3,2;
examples.tex(,1053)   ideal j=xy,x^k+y^l+z2;
examples.tex(,1054)   print(deform(j));
examples.tex(,1055) @expansion{} 0,0, 0,0,z,1,
examples.tex(,1056) @expansion{} y,x2,x,1,0,0 
examples.tex(,1057)   versal(j);                  // using default names
examples.tex(,1058) @expansion{} // smooth base space
examples.tex(,1059) @expansion{} // ready: T_1 and T_2
examples.tex(,1060) @expansion{} 
examples.tex(,1061) @expansion{} // Result belongs to ring Px.
examples.tex(,1062) @expansion{} // Equations of total space of miniversal deformation are 
examples.tex(,1063) @expansion{} // given by Fs, equations of miniversal base space by Js.
examples.tex(,1064) @expansion{} // Make Px the basering and list objects defined in Px by typing:
examples.tex(,1065) @expansion{}    setring Px; show(Px);
examples.tex(,1066) @expansion{}    listvar(matrix);
examples.tex(,1067) @expansion{} // NOTE: rings Qx, Px, So are alive!
examples.tex(,1068) @expansion{} // (use 'kill_rings("");' to remove)
examples.tex(,1069)   setring Px;
examples.tex(,1070)   show(Px);                   // show is a procedure from inout.lib
examples.tex(,1071) @expansion{} // ring: (32003),(A,B,C,D,E,F,x,y,z),(ds(6),ds(3),C);
examples.tex(,1072) @expansion{} // minpoly = 0
examples.tex(,1073) @expansion{} // objects belonging to this ring:
examples.tex(,1074) @expansion{} // Rs                   [0]  matrix 2 x 1
examples.tex(,1075) @expansion{} // Fs                   [0]  matrix 1 x 2
examples.tex(,1076) @expansion{} // Js                   [0]  matrix 1 x 0
examples.tex(,1077)   listvar(matrix);
examples.tex(,1078) @expansion{} // Rs                   [0]  matrix 2 x 1
examples.tex(,1079) @expansion{} // Fs                   [0]  matrix 1 x 2
examples.tex(,1080) @expansion{} // Js                   [0]  matrix 1 x 0
examples.tex(,1081)   // ___ Equations of miniversal base space ___:
examples.tex(,1082)   Js;
examples.tex(,1083) @expansion{} 
examples.tex(,1084)   // ___ Equations of miniversal total space ___:
examples.tex(,1085)   Fs;
examples.tex(,1086) @expansion{} Fs[1,1]=xy+Ez+F
examples.tex(,1087) @expansion{} Fs[1,2]=y2+z2+x3+Ay+Bx2+Cx+D
examples.tex(,1088)   // the miniversal deformation of V(j) is the projection from the
examples.tex(,1089)   // miniversal total space to the miniversal base space:
examples.tex(,1090)   // @{ (A,B,C,D,E,F,x,y,z) | xy+F+Ez=0, y2+z2+x3+D+Cx+Bx2+Ay=0 @}
examples.tex(,1091)   //  --> @{ (A,B,C,D,E,F) @}
examples.tex(,1092)   //----------------------------------------------------
examples.tex(,1093)   // general case (cone over rational normal curve of degree 4):
examples.tex(,1094)   ring r1=0,(x,y,z,u,v),ds;
examples.tex(,1095)   matrix m[2][4]=x,y,z,u,y,z,u,v;
examples.tex(,1096)   ideal i=minor(m,2);                 // 2x2 minors of matrix m
examples.tex(,1097)   int time=timer;
examples.tex(,1098)   // Def_r is the name of the miniversal base space with
examples.tex(,1099)   // parameters A(1),...,A(4)
examples.tex(,1100)   versal(i,0,"Def_r","A(");
examples.tex(,1101) @expansion{} // ready: T_1 and T_2
examples.tex(,1102) @expansion{} 
examples.tex(,1103) @expansion{} // Result belongs to ring Def_rPx.
examples.tex(,1104) @expansion{} // Equations of total space of miniversal deformation are 
examples.tex(,1105) @expansion{} // given by Fs, equations of miniversal base space by Js.
examples.tex(,1106) @expansion{} // Make Def_rPx the basering and list objects defined in Def_rPx by typin\
examples.tex(,1107)    g:
examples.tex(,1108) @expansion{}    setring Def_rPx; show(Def_rPx);
examples.tex(,1109) @expansion{}    listvar(matrix);
examples.tex(,1110) @expansion{} // NOTE: rings Def_rQx, Def_rPx, Def_rSo are alive!
examples.tex(,1111) @expansion{} // (use 'kill_rings("Def_r");' to remove)
examples.tex(,1112)   "// used time:",timer-time,"sec";   // time of last command
examples.tex(,1113) @expansion{} // used time: 1 sec
examples.tex(,1114)   // the miniversal deformation of V(i) is the projection from the
examples.tex(,1115)   // miniversal total space to the miniversal base space:
examples.tex(,1116)   // @{ (A(1..4),x,y,z,u,v) |
examples.tex(,1117)   //         -y^2+x*z+A(2)*x-A(3)*y=0, -y*z+x*u-A(1)*x-A(3)*z=0,
examples.tex(,1118)   //         -y*u+x*v-A(3)*u-A(4)*z=0, -z^2+y*u-A(1)*y-A(2)*z=0,
examples.tex(,1119)   //         -z*u+y*v-A(2)*u-A(4)*u=0, -u^2+z*v+A(1)*u-A(4)*v=0 @}
examples.tex(,1120)   //  --> @{ A(1..4) |
examples.tex(,1121)   //         -A(1)*A(4) = A(3)*A(4) = -A(2)*A(4)-A(4)^2 = 0 @}
examples.tex(,1122)   //----------------------------------------------------
examples.tex(,1123) @c end example Deformations examples.doc:787
examples.tex(,1124) @end smallexample
examples.tex(,1125) 
examples.tex(,1126) @c ----------------------------------------------------------------------------
examples.tex(,1128) @node Finite fields, Elimination, Deformations, Examples
examples.tex(,1129) @section Finite fields
examples.tex(,1130) @cindex Finite fields
examples.tex(,1131) 
examples.tex(,1132) We define a variety in 
examples.tex(,1139) -space of codimension 2 defined by
examples.tex(,1140) polynomials of degree 
examples.tex(,1147)  with generic coefficients over the prime
examples.tex(,1148) field 
examples.tex(,1155)  and look for zeros on the torus. First over the prime
examples.tex(,1156) field and then in the finite extension field with
examples.tex(,1163) elements.
examples.tex(,1164) In general there will be many more solutions in the second case.
examples.tex(,1165) (Since the @sc{Singular} language is interpreted, the evaluation of many
examples.tex(,1166) @code{for}-loops is not very fast):
examples.tex(,1167) 
examples.tex(,1168) @smallexample
examples.tex(,1169) @c computed example Finite_fields examples.doc:860 
examples.tex(,1170)   int p=3;  int n=3;  int d=5; int k=2;
examples.tex(,1171)   ring rp = p,(x(1..n)),dp;
examples.tex(,1172)   int s = size(maxideal(d));
examples.tex(,1173)   s;
examples.tex(,1174) @expansion{} 21
examples.tex(,1175)   // create a dense homogeneous ideal m, all generators of degree d, with
examples.tex(,1176)   // generic (random) coefficients:
examples.tex(,1177)   ideal m = maxideal(d)*random(p,s,n-2);
examples.tex(,1178)   m;
examples.tex(,1179) @expansion{} m[1]=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^3*x\
examples.tex(,1180)    (3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5
examples.tex(,1181)   // look for zeros on the torus by checking all points (with no component 0)
examples.tex(,1182)   // of the affine n-space over the field with p elements :
examples.tex(,1183)   ideal mt;
examples.tex(,1184)   int i(1..n);                    // initialize integers i(1),...,i(n)
examples.tex(,1185)   int l;
examples.tex(,1186)   s=0;
examples.tex(,1187)   for (i(1)=1;i(1)<p;i(1)=i(1)+1)
examples.tex(,1188)   @{
examples.tex(,1189)     for (i(2)=1;i(2)<p;i(2)=i(2)+1)
examples.tex(,1190)     @{
examples.tex(,1191)       for (i(3)=1;i(3)<p;i(3)=i(3)+1)
examples.tex(,1192)       @{
examples.tex(,1193)         mt=m;
examples.tex(,1194)         for (l=1;l<=n;l=l+1)
examples.tex(,1195)         @{
examples.tex(,1196)           mt=subst(mt,x(l),i(l));
examples.tex(,1197)         @}
examples.tex(,1198)         if (size(mt)==0)
examples.tex(,1199)         @{
examples.tex(,1200)           "solution:",i(1..n);
examples.tex(,1201)           s=s+1;
examples.tex(,1202)         @}
examples.tex(,1203)       @}
examples.tex(,1204)     @}
examples.tex(,1205)   @}
examples.tex(,1206) @expansion{} solution: 1 1 2
examples.tex(,1207) @expansion{} solution: 1 2 1
examples.tex(,1208) @expansion{} solution: 1 2 2
examples.tex(,1209) @expansion{} solution: 2 1 1
examples.tex(,1210) @expansion{} solution: 2 1 2
examples.tex(,1211) @expansion{} solution: 2 2 1
examples.tex(,1212)   "//",s,"solutions over GF("+string(p)+")";
examples.tex(,1213) @expansion{} // 6 solutions over GF(3)
examples.tex(,1214)   // Now go to the field with p^3 elements:
examples.tex(,1215)   // As long as there is no map from Z/p to the field with p^3 elements
examples.tex(,1216)   // implemented, use the following trick: convert the ideal to be mapped
examples.tex(,1217)   // to the new ring to a string and then execute this string in the
examples.tex(,1218)   // new ring
examples.tex(,1219)   string ms="ideal m="+string(m)+";";
examples.tex(,1220)   ms;
examples.tex(,1221) @expansion{} ideal m=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^\
examples.tex(,1222)    3*x(3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5;
examples.tex(,1223)   // define a ring rpk with p^k elements, call the primitive element z. Hence
examples.tex(,1224)   // 'solution exponent: 0 1 5' means that (z^0,z^1,z^5) is a solution
examples.tex(,1225)   ring rpk=(p^k,z),(x(1..n)),dp;
examples.tex(,1226)   rpk;
examples.tex(,1227) @expansion{} //   # ground field : 9
examples.tex(,1228) @expansion{} //   primitive element : z
examples.tex(,1229) @expansion{} //   minpoly        : 1*z^2+1*z^1+2*z^0
examples.tex(,1230) @expansion{} //   number of vars : 3
examples.tex(,1231) @expansion{} //        block   1 : ordering dp
examples.tex(,1232) @expansion{} //                  : names    x(1) x(2) x(3) 
examples.tex(,1233) @expansion{} //        block   2 : ordering C
examples.tex(,1234)   execute(ms);
examples.tex(,1235)   s=0;
examples.tex(,1236)   ideal mt;
examples.tex(,1237)   for (i(1)=0;i(1)<p^k-1;i(1)=i(1)+1)
examples.tex(,1238)   @{
examples.tex(,1239)     for (i(2)=0;i(2)<p^k-1;i(2)=i(2)+1)
examples.tex(,1240)     @{
examples.tex(,1241)       for (i(3)=0;i(3)<p^k-1;i(3)=i(3)+1)
examples.tex(,1242)       @{
examples.tex(,1243)         mt=m;
examples.tex(,1244)         for (l=1;l<=n;l=l+1)
examples.tex(,1245)         @{
examples.tex(,1246)           mt=subst(mt,x(l),z^i(l));
examples.tex(,1247)         @}
examples.tex(,1248)         if (size(mt)==0)
examples.tex(,1249)         @{
examples.tex(,1250)           "solution exponent:",i(1..n);
examples.tex(,1251)           s=s+1;
examples.tex(,1252)         @}
examples.tex(,1253)       @}
examples.tex(,1254)     @}
examples.tex(,1255)   @}
examples.tex(,1256) @expansion{} solution exponent: 0 0 2
examples.tex(,1257) @expansion{} solution exponent: 0 0 4
examples.tex(,1258) @expansion{} solution exponent: 0 0 6
examples.tex(,1259) @expansion{} solution exponent: 0 1 0
examples.tex(,1260) @expansion{} solution exponent: 0 3 0
examples.tex(,1261) @expansion{} solution exponent: 0 4 0
examples.tex(,1262) @expansion{} solution exponent: 0 4 4
examples.tex(,1263) @expansion{} solution exponent: 0 4 5
examples.tex(,1264) @expansion{} solution exponent: 0 4 7
examples.tex(,1265) @expansion{} solution exponent: 1 1 3
examples.tex(,1266) @expansion{} solution exponent: 1 1 5
examples.tex(,1267) @expansion{} solution exponent: 1 1 7
examples.tex(,1268) @expansion{} solution exponent: 1 2 1
examples.tex(,1269) @expansion{} solution exponent: 1 4 1
examples.tex(,1270) @expansion{} solution exponent: 1 5 0
examples.tex(,1271) @expansion{} solution exponent: 1 5 1
examples.tex(,1272) @expansion{} solution exponent: 1 5 5
examples.tex(,1273) @expansion{} solution exponent: 1 5 6
examples.tex(,1274) @expansion{} solution exponent: 2 2 0
examples.tex(,1275) @expansion{} solution exponent: 2 2 4
examples.tex(,1276) @expansion{} solution exponent: 2 2 6
examples.tex(,1277) @expansion{} solution exponent: 2 3 2
examples.tex(,1278) @expansion{} solution exponent: 2 5 2
examples.tex(,1279) @expansion{} solution exponent: 2 6 1
examples.tex(,1280) @expansion{} solution exponent: 2 6 2
examples.tex(,1281) @expansion{} solution exponent: 2 6 6
examples.tex(,1282) @expansion{} solution exponent: 2 6 7
examples.tex(,1283) @expansion{} solution exponent: 3 3 1
examples.tex(,1284) @expansion{} solution exponent: 3 3 5
examples.tex(,1285) @expansion{} solution exponent: 3 3 7
examples.tex(,1286) @expansion{} solution exponent: 3 4 3
examples.tex(,1287) @expansion{} solution exponent: 3 6 3
examples.tex(,1288) @expansion{} solution exponent: 3 7 0
examples.tex(,1289) @expansion{} solution exponent: 3 7 2
examples.tex(,1290) @expansion{} solution exponent: 3 7 3
examples.tex(,1291) @expansion{} solution exponent: 3 7 7
examples.tex(,1292) @expansion{} solution exponent: 4 0 0
examples.tex(,1293) @expansion{} solution exponent: 4 0 1
examples.tex(,1294) @expansion{} solution exponent: 4 0 3
examples.tex(,1295) @expansion{} solution exponent: 4 0 4
examples.tex(,1296) @expansion{} solution exponent: 4 4 0
examples.tex(,1297) @expansion{} solution exponent: 4 4 2
examples.tex(,1298) @expansion{} solution exponent: 4 4 6
examples.tex(,1299) @expansion{} solution exponent: 4 5 4
examples.tex(,1300) @expansion{} solution exponent: 4 7 4
examples.tex(,1301) @expansion{} solution exponent: 5 0 5
examples.tex(,1302) @expansion{} solution exponent: 5 1 1
examples.tex(,1303) @expansion{} solution exponent: 5 1 2
examples.tex(,1304) @expansion{} solution exponent: 5 1 4
examples.tex(,1305) @expansion{} solution exponent: 5 1 5
examples.tex(,1306) @expansion{} solution exponent: 5 5 1
examples.tex(,1307) @expansion{} solution exponent: 5 5 3
examples.tex(,1308) @expansion{} solution exponent: 5 5 7
examples.tex(,1309) @expansion{} solution exponent: 5 6 5
examples.tex(,1310) @expansion{} solution exponent: 6 1 6
examples.tex(,1311) @expansion{} solution exponent: 6 2 2
examples.tex(,1312) @expansion{} solution exponent: 6 2 3
examples.tex(,1313) @expansion{} solution exponent: 6 2 5
examples.tex(,1314) @expansion{} solution exponent: 6 2 6
examples.tex(,1315) @expansion{} solution exponent: 6 6 0
examples.tex(,1316) @expansion{} solution exponent: 6 6 2
examples.tex(,1317) @expansion{} solution exponent: 6 6 4
examples.tex(,1318) @expansion{} solution exponent: 6 7 6
examples.tex(,1319) @expansion{} solution exponent: 7 0 7
examples.tex(,1320) @expansion{} solution exponent: 7 2 7
examples.tex(,1321) @expansion{} solution exponent: 7 3 3
examples.tex(,1322) @expansion{} solution exponent: 7 3 4
examples.tex(,1323) @expansion{} solution exponent: 7 3 6
examples.tex(,1324) @expansion{} solution exponent: 7 3 7
examples.tex(,1325) @expansion{} solution exponent: 7 7 1
examples.tex(,1326) @expansion{} solution exponent: 7 7 3
examples.tex(,1327) @expansion{} solution exponent: 7 7 5
examples.tex(,1328)   "//",s,"solutions over GF("+string(p^k)+")";
examples.tex(,1329) @expansion{} // 72 solutions over GF(9)
examples.tex(,1330) @c end example Finite_fields examples.doc:860
examples.tex(,1331) @end smallexample
examples.tex(,1333) @c ----------------------------------------------------------------------------
examples.tex(,1335) @node Elimination, Free resolution, Finite fields, Examples
examples.tex(,1340) @section Elimination
examples.tex(,1341) @cindex Elimination
examples.tex(,1342) 
examples.tex(,1343) Elimination is the algebraic counterpart of the geometric concept of
examples.tex(,1344) projection. If
examples.tex(,1351) is a polynomial map,
examples.tex(,1352) the Zariski-closure of the image is the zero-set of the ideal
examples.tex(,1370) i.e, of the ideal j obtained from J by eliminating the variables
examples.tex(,1377) This can be done by computing a standard basis of J with respect to a product
examples.tex(,1378) ordering where the block of t-variables precedes the block of
examples.tex(,1379) x-variables and then selecting those polynomials which do not contain
examples.tex(,1380) any t. In @sc{Singular} the most convenient way is to use the
examples.tex(,1381) @code{eliminate} command.
examples.tex(,1382) In contrast to the first method, with @code{eliminate} the result needs not be a
examples.tex(,1383) standard basis in the given ordering.
examples.tex(,1384) Hence, there may be cases where the first method is the preferred one.
examples.tex(,1385) 
examples.tex(,1386) @strong{WARNING:} In the case of a local or a mixed ordering, elimination needs special
examples.tex(,1387) care. f may be considered as a map of germs
examples.tex(,1394) but even
examples.tex(,1395) if this map germ is finite, we are in general not able to compute the image
examples.tex(,1396) germ because for this we would need an implementation of the Weierstrass
examples.tex(,1397) preparation theorem. What we can compute, and what @code{eliminate} actually does,
examples.tex(,1398) is the following: let V(J) be the zero-set of J in
examples.tex(,1405) then the
examples.tex(,1406) closure of the image of V(J) under the projection
examples.tex(,1415) Note that this germ contains also those components
examples.tex(,1416) of V(J) which meet the fiber of pr outside the origin.
examples.tex(,1417) This is achieved by an ordering with the block of t-variables having a
examples.tex(,1418) global ordering (and preceding the x-variables) and the x-variables having
examples.tex(,1419) a local ordering. In a local situation we propose @code{eliminate} with
examples.tex(,1420) ordering ls.
examples.tex(,1421) 
examples.tex(,1422) In any case, if the input is weighted homogeneous (=quasihomogeneous),
examples.tex(,1423) the weights given to the variables should be chosen accordingly.
examples.tex(,1424) @sc{Singular} offers a function @code{weight} which proposes,
examples.tex(,1425) given an ideal or module, integer weights for the variables, such that
examples.tex(,1426) the ideal, resp.@: module, is as homogeneous as possible with respect to these weights.
examples.tex(,1427) The function finds correct weights, if the input is weighted homogeneous
examples.tex(,1428) (but is rather slow for many variables). In order to check, whether the
examples.tex(,1429) input is quasihomogeneous, use the function @code{qhweight}, which returns
examples.tex(,1430) an intvec of correct weights if the input is quasihomogeneous and an intvec
examples.tex(,1431) of zeros otherwise.
examples.tex(,1432) 
examples.tex(,1433) Let us give two examples:
examples.tex(,1434) @enumerate
examples.tex(,1435) @item
examples.tex(,1436) First we compute the equations of the simple space curve
examples.tex(,1443)    consisting of two tangential cusps given in parametric form.
examples.tex(,1444) @item
examples.tex(,1445) We compute weights for the equations such that the
examples.tex(,1446)    equations are quasihomogeneous w.r.t. these weights.
examples.tex(,1447) @item
examples.tex(,1448) Then we compute the tangent developable of the rational
examples.tex(,1449)    normal curve in
examples.tex(,1456) @end enumerate
examples.tex(,1457) 
examples.tex(,1458) @smallexample
examples.tex(,1459) @c computed example Elimination examples.doc:1058 
examples.tex(,1460)   // 1. Compute equations of curve given in parametric form:
examples.tex(,1461)   // Two transversal cusps in (k^3,0):
examples.tex(,1462)   ring r1 = 0,(t,x,y,z),ls;
examples.tex(,1463)   ideal i1 = x-t2,y-t3,z;        // parametrization of the first branch
examples.tex(,1464)   ideal i2 = y-t2,z-t3,x;        // parametrization of the second branch
examples.tex(,1465)   ideal j1 = eliminate(i1,t);
examples.tex(,1466)   j1;                            // equations of the first branch
examples.tex(,1467) @expansion{} j1[1]=z
examples.tex(,1468) @expansion{} j1[2]=y2-x3
examples.tex(,1469)   ideal j2 = eliminate(i2,t);
examples.tex(,1470)   j2;                            // equations of the second branch
examples.tex(,1471) @expansion{} j2[1]=x
examples.tex(,1472) @expansion{} j2[2]=z2-y3
examples.tex(,1473)   // Now map to a ring with only x,y,z as variables and compute the
examples.tex(,1474)   // intersection of j1 and j2 there:
examples.tex(,1475)   ring r2 = 0,(x,y,z),ds;
examples.tex(,1476)   ideal j1= imap(r1,j1);         // imap is a convenient ringmap for
examples.tex(,1477)   ideal j2= imap(r1,j2);         // inclusions and projections of rings
examples.tex(,1478)   ideal i = intersect(j1,j2);
examples.tex(,1479)   i;                             // equations of both branches
examples.tex(,1480) @expansion{} i[1]=z2-y3+x3y
examples.tex(,1481) @expansion{} i[2]=xz
examples.tex(,1482) @expansion{} i[3]=xy2-x4
examples.tex(,1483) @expansion{} i[4]=x3z
examples.tex(,1484)   //
examples.tex(,1485)   // 2. Compute the weights:
examples.tex(,1486)   intvec v= qhweight(i);         // compute weights
examples.tex(,1487)   v;
examples.tex(,1488) @expansion{} 4,6,9
examples.tex(,1489)   //
examples.tex(,1490)   // 3. Compute the tangent developable
examples.tex(,1491)   // The tangent developable of a projective variety given parametrically
examples.tex(,1492)   // by F=(f1,...,fn) : P^r --> P^n is the union of all tangent spaces
examples.tex(,1493)   // of the image. The tangent space at a smooth point F(t1,...,tr)
examples.tex(,1494)   // is given as the image of the tangent space at (t1,...,tr) under
examples.tex(,1495)   // the tangent map (affine coordinates)
examples.tex(,1496)   //   T(t1,...,tr): (y1,...,yr) --> jacob(f)*transpose((y1,...,yr))
examples.tex(,1497)   // where jacob(f) denotes the jacobian matrix of f with respect to the
examples.tex(,1498)   // t's evaluated at the point (t1,...,tr).
examples.tex(,1499)   // Hence we have to create the graph of this map and then to eliminate
examples.tex(,1500)   // the t's and y's.
examples.tex(,1501)   // The rational normal curve in P^4 is given as the image of
examples.tex(,1502)   //        F(s,t) = (s4,s3t,s2t2,st3,t4)
examples.tex(,1503)   // each component being homogeneous of degree 4.
examples.tex(,1504)   ring P = 0,(s,t,x,y,a,b,c,d,e),dp;
examples.tex(,1505)   ideal M = maxideal(1);
examples.tex(,1506)   ideal F = M[1..2];     // take the 1st two generators of M
examples.tex(,1507)   F=F^4;
examples.tex(,1508)   // simplify(...,2); deletes 0-columns
examples.tex(,1509)   matrix jac = simplify(jacob(F),2);
examples.tex(,1510)   ideal T = x,y;
examples.tex(,1511)   ideal J = jac*transpose(T);
examples.tex(,1512)   ideal H = M[5..9];
examples.tex(,1513)   ideal i = H-J;         // this is tricky: difference between two
examples.tex(,1514)                          // ideals is not defined, but between two
examples.tex(,1515)                          // matrices. By automatic type conversion
examples.tex(,1516)                          // the ideals are converted to matrices,
examples.tex(,1517)                          // subtracted and afterwards converted
examples.tex(,1518)                          // to an ideal. Note that '+' is defined
examples.tex(,1519)                          // and adds (concatenates) two ideals
examples.tex(,1520)   i;
examples.tex(,1521) @expansion{} i[1]=-4s3x+a
examples.tex(,1522) @expansion{} i[2]=-3s2tx-s3y+b
examples.tex(,1523) @expansion{} i[3]=-2st2x-2s2ty+c
examples.tex(,1524) @expansion{} i[4]=-t3x-3st2y+d
examples.tex(,1525) @expansion{} i[5]=-4t3y+e
examples.tex(,1526)   // Now we define a ring with product ordering and weights 4
examples.tex(,1527)   // for the variables a,...,e.
examples.tex(,1528)   // Then we map i from P to P1 and eliminate s,t,x,y from i.
examples.tex(,1529)   ring P1 = 0,(s,t,x,y,a,b,c,d,e),(dp(4),wp(4,4,4,4,4));
examples.tex(,1530)   ideal i = fetch(P,i);
examples.tex(,1531)   ideal j= eliminate(i,stxy);    // equations of tangent developable
examples.tex(,1532)   j;
examples.tex(,1533) @expansion{} j[1]=3c2-4bd+ae
examples.tex(,1534) @expansion{} j[2]=2bcd-3ad2-3b2e+4ace
examples.tex(,1535) @expansion{} j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde
examples.tex(,1536)   // We can use the product ordering to eliminate s,t,x,y from i
examples.tex(,1537)   // by a std-basis computation.
examples.tex(,1538)   // We need proc 'nselect' from elim.lib.
examples.tex(,1539)   LIB "elim.lib";
examples.tex(,1540)   j = std(i);                    // compute a std basis j
examples.tex(,1541)   j = nselect(j,1,4);            // select generators from j not
examples.tex(,1542)   j;                             // containing variable 1,...,4
examples.tex(,1543) @expansion{} j[1]=3c2-4bd+ae
examples.tex(,1544) @expansion{} j[2]=2bcd-3ad2-3b2e+4ace
examples.tex(,1545) @expansion{} j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde
examples.tex(,1546) @c end example Elimination examples.doc:1058
examples.tex(,1547) @end smallexample
examples.tex(,1548) @c  killall();
examples.tex(,1549) 
examples.tex(,1550) 
examples.tex(,1551) @c ----------------------------------------------------------------------------
examples.tex(,1553) @node Free resolution, Computation of Ext, Elimination, Examples
examples.tex(,1558) @section  Free resolution
examples.tex(,1559) @cindex  Free resolution
examples.tex(,1560) 
examples.tex(,1561) In @sc{Singular} a free resolution of a module or ideal has its own type:
examples.tex(,1562) @code{resolution}. It is a structure that stores all information related to
examples.tex(,1563) free resolutions. This allows partial computations of resolutions via
examples.tex(,1564) the command @code{res}. After applying @code{res}, only a pre-format of the
examples.tex(,1565) resolution is computed which allows to determine invariants like
examples.tex(,1566) Betti-numbers or homological dimension. To see the differentials
examples.tex(,1567) of the complex, a resolution must be converted into the type list which
examples.tex(,1568) yields a list of modules: the k-th module in this
examples.tex(,1569) list is the first syzygy-module (module of relations) of the (k-1)st module.
examples.tex(,1570) There are the following commands to compute a resolution:
examples.tex(,1571) @table @code
examples.tex(,1572) @item res
examples.tex(,1574) @ref{res}@*
examples.tex(,1576) computes a free resolution of an ideal or module using a heuristically
examples.tex(,1577) chosen method.
examples.tex(,1578) This is the preferred method to compute free resolutions of ideals or
examples.tex(,1579) modules.
examples.tex(,1580) @item lres
examples.tex(,1582) @ref{lres}@*
examples.tex(,1584) computes a free resolution of an ideal or module with La Scala's
examples.tex(,1585) method. The input needs to be homogeneous.
examples.tex(,1586) @item mres
examples.tex(,1588) @ref{mres}@*
examples.tex(,1590) computes a minimal free resolution of an ideal or module with the syzygy
examples.tex(,1591) method.
examples.tex(,1592) @item sres
examples.tex(,1594) @ref{sres}@*
examples.tex(,1596) computes a free resolution of an ideal or module with Schreyer's
examples.tex(,1597) method. The input has to be a standard basis.
examples.tex(,1598) @item nres
examples.tex(,1600) @ref{nres}@*
examples.tex(,1602) computes a free resolution of an ideal or module with the standard basis
examples.tex(,1603) method.
examples.tex(,1604) @item minres
examples.tex(,1606) @ref{minres}@*
examples.tex(,1608) minimizes a free resolution of an ideal or module.
examples.tex(,1609) @item syz
examples.tex(,1611) @ref{syz}@*
examples.tex(,1613) computes the first syzygy module.
examples.tex(,1614) @end table
examples.tex(,1615) @code{res(i,r)}, @code{lres(i,r)}, @code{sres(i,r)}, @code{mres(i,r)},
examples.tex(,1616) @code{nres(i,r)} compute the first r modules of the resolution
examples.tex(,1617) of i, resp.@: the full resolution if r=0 and the basering is not a qring.
examples.tex(,1618) See the manual for a precise description of these commands.
examples.tex(,1619) @*Note: The command @code{betti} does not require a minimal
examples.tex(,1620) resolution for the minimal betti numbers.
examples.tex(,1621) 
examples.tex(,1622) Now let's look at an example which uses resolutions: The Hilbert-Burch
examples.tex(,1623) theorem says that the ideal i of a reduced curve in
examples.tex(,1630) has a free resolution of length 2 and that i is given by the 2x2 minors
examples.tex(,1631) of the 2nd matrix in the resolution.
examples.tex(,1632) We test this for two transversal cusps in
examples.tex(,1639) Afterwards we compute the resolution of the ideal j of the tangent developable
examples.tex(,1640) of the rational normal curve in
examples.tex(,1647) from above.
examples.tex(,1648) Finally we demonstrate the use of the type @code{resolution} in connection with
examples.tex(,1649) the @code{lres} command.
examples.tex(,1650) 
examples.tex(,1651) @smallexample
examples.tex(,1652) @c computed example Free_resolution examples.doc:1231 
examples.tex(,1653)   // Two transversal cusps in (k^3,0):
examples.tex(,1654)   ring r2 =0,(x,y,z),ds;
examples.tex(,1655)   ideal i =z2-1y3+x3y,xz,-1xy2+x4,x3z;
examples.tex(,1656)   resolution rs=mres(i,0);   // computes a minimal resolution
examples.tex(,1657)   rs;                        // the standard representation of complexes
examples.tex(,1658) @expansion{}   1       3       2       
examples.tex(,1659) @expansion{} r2 <--  r2 <--  r2
examples.tex(,1660) @expansion{} 
examples.tex(,1661) @expansion{} 0       1       2       
examples.tex(,1662) @expansion{} 
examples.tex(,1663)     list resi=rs;            // convertion to a list
examples.tex(,1664)   print(resi[1]);            // the 1st module is i minimized
examples.tex(,1665) @expansion{} xz,
examples.tex(,1666) @expansion{} z2-y3+x3y,
examples.tex(,1667) @expansion{} xy2-x4
examples.tex(,1668)   print(resi[2]);            // the 1st syzygy module of i
examples.tex(,1669) @expansion{} -z,-y2+x3,
examples.tex(,1670) @expansion{} x, 0,     
examples.tex(,1671) @expansion{} y, z      
examples.tex(,1672)   resi[3];                   // the 2nd syzygy module of i
examples.tex(,1673) @expansion{} _[1]=0
examples.tex(,1674)   ideal j=minor(resi[2],2);
examples.tex(,1675)   reduce(j,std(i));          // check whether j is contained in i
examples.tex(,1676) @expansion{} _[1]=0
examples.tex(,1677) @expansion{} _[2]=0
examples.tex(,1678) @expansion{} _[3]=0
examples.tex(,1679)   size(reduce(i,std(j)));    // check whether i is contained in j
examples.tex(,1680) @expansion{} 0
examples.tex(,1681)   // size(<ideal>) counts the non-zero generators
examples.tex(,1682)   // ---------------------------------------------
examples.tex(,1683)   // The tangent developable of the rational normal curve in P^4:
examples.tex(,1684)   ring P = 0,(a,b,c,d,e),dp;
examples.tex(,1685)   ideal j= 3c2-4bd+ae, -2bcd+3ad2+3b2e-4ace,
examples.tex(,1686)            8b2d2-9acd2-9b2ce+9ac2e+2abde-1a2e2;
examples.tex(,1687)   resolution rs=mres(j,0);
examples.tex(,1688)   rs;
examples.tex(,1689) @expansion{}  1      2      1      
examples.tex(,1690) @expansion{} P <--  P <--  P
examples.tex(,1691) @expansion{} 
examples.tex(,1692) @expansion{} 0      1      2      
examples.tex(,1693) @expansion{} 
examples.tex(,1694)   list L=rs;
examples.tex(,1695)   print(L[2]);
examples.tex(,1696) @expansion{} 2bcd-3ad2-3b2e+4ace,
examples.tex(,1697) @expansion{} -3c2+4bd-ae         
examples.tex(,1698)   // create an intmat with graded betti numbers
examples.tex(,1699)   intmat B=betti(rs);
examples.tex(,1700)   // this gives a nice output of betti numbers
examples.tex(,1701)   print(B,"betti");
examples.tex(,1702) @expansion{}            0     1     2
examples.tex(,1703) @expansion{} ------------------------
examples.tex(,1704) @expansion{}     0:     1     -     -
examples.tex(,1705) @expansion{}     1:     -     1     -
examples.tex(,1706) @expansion{}     2:     -     1     -
examples.tex(,1707) @expansion{}     3:     -     -     1
examples.tex(,1708) @expansion{} ------------------------
examples.tex(,1709) @expansion{} total:     1     2     1
examples.tex(,1710)   // the user has access to all betti numbers
examples.tex(,1711)   // the 2-nd column of B:
examples.tex(,1712)   B[1..4,2];
examples.tex(,1713) @expansion{} 0 1 1 0
examples.tex(,1714)   ring cyc5=32003,(a,b,c,d,e,h),dp;
examples.tex(,1715)   ideal i=
examples.tex(,1716)   a+b+c+d+e,
examples.tex(,1717)   ab+bc+cd+de+ea,
examples.tex(,1718)   abc+bcd+cde+dea+eab,
examples.tex(,1719)   abcd+bcde+cdea+deab+eabc,
examples.tex(,1720)   h5-abcde;
examples.tex(,1721)   resolution rs=lres(i,0);   //computes the resolution according La Scala
examples.tex(,1722)   rs;                        //the shape of the minimal resolution
examples.tex(,1723) @expansion{}     1         5         10         10         5         1         
examples.tex(,1724) @expansion{} cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
examples.tex(,1725) @expansion{} 
examples.tex(,1726) @expansion{} 0         1         2          3          4         5         
examples.tex(,1727) @expansion{} resolution not minimized yet
examples.tex(,1728) @expansion{} 
examples.tex(,1729)   print(betti(rs),"betti");  //shows the Betti-numbers of cyclic 5
examples.tex(,1730) @expansion{}            0     1     2     3     4     5
examples.tex(,1731) @expansion{} ------------------------------------------
examples.tex(,1732) @expansion{}     0:     1     1     -     -     -     -
examples.tex(,1733) @expansion{}     1:     -     1     1     -     -     -
examples.tex(,1734) @expansion{}     2:     -     1     1     -     -     -
examples.tex(,1735) @expansion{}     3:     -     1     2     1     -     -
examples.tex(,1736) @expansion{}     4:     -     1     2     1     -     -
examples.tex(,1737) @expansion{}     5:     -     -     2     2     -     -
examples.tex(,1738) @expansion{}     6:     -     -     1     2     1     -
examples.tex(,1739) @expansion{}     7:     -     -     1     2     1     -
examples.tex(,1740) @expansion{}     8:     -     -     -     1     1     -
examples.tex(,1741) @expansion{}     9:     -     -     -     1     1     -
examples.tex(,1742) @expansion{}    10:     -     -     -     -     1     1
examples.tex(,1743) @expansion{} ------------------------------------------
examples.tex(,1744) @expansion{} total:     1     5    10    10     5     1
examples.tex(,1745)   dim(rs);                   //the homological dimension
examples.tex(,1746) @expansion{} 4
examples.tex(,1747)   size(list(rs));            //gets the full (non-reduced) resolution
examples.tex(,1748) @expansion{} 6
examples.tex(,1749)   minres(rs);                //minimizes the resolution
examples.tex(,1750) @expansion{}     1         5         10         10         5         1         
examples.tex(,1751) @expansion{} cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
examples.tex(,1752) @expansion{} 
examples.tex(,1753) @expansion{} 0         1         2          3          4         5         
examples.tex(,1754) @expansion{} 
examples.tex(,1755)   size(list(rs));            //gets the minimized resolution
examples.tex(,1756) @expansion{} 6
examples.tex(,1757) @c end example Free_resolution examples.doc:1231
examples.tex(,1758) @end smallexample
examples.tex(,1759) 
examples.tex(,1760) 
examples.tex(,1761) @c ----------------------------------------------------------------------------
examples.tex(,1763) @node Computation of Ext, Polar curves, Free resolution, Examples
examples.tex(,1764) @section  Computation of Ext
examples.tex(,1765) @cindex  Ext
examples.tex(,1766) 
examples.tex(,1767) We start by showing how to calculate the 
examples.tex(,1774) -th Ext group of an
examples.tex(,1775) ideal. The ingredients to do this are by the definition of Ext the
examples.tex(,1776) following: calculate a (minimal) resolution at least up to length
examples.tex(,1777) 
examples.tex(,1784) , apply the Hom-functor, and calculate the 
examples.tex(,1791) -th homology
examples.tex(,1792) group, that is form the quotient
examples.tex(,1799) in the resolution sequence.
examples.tex(,1800) 
examples.tex(,1801) The Hom functor is given simply by transposing (hence dualizing) the
examples.tex(,1802) module or the corresponding matrix with the command @code{transpose}.
examples.tex(,1803) The image of the 
examples.tex(,1810) -st map is generated by the columns of the
examples.tex(,1811) corresponding matrix. To calculate the kernel apply the command
examples.tex(,1812) @code{syz} at the 
examples.tex(,1819) -st transposed entry of the resolution.
examples.tex(,1820) Finally, the quotient is obtained by the command @code{modulo}, which
examples.tex(,1821) gives for two modules A = ker, B = Im the module of relations of
examples.tex(,1828) in the usual way. As we have a chain complex this is obviously the same
examples.tex(,1829) as ker/Im.
examples.tex(,1830) 
examples.tex(,1831) We collect these statements in the following short procedure:
examples.tex(,1832) 
examples.tex(,1833) @smallexample
examples.tex(,1834) proc ext(int n, ideal I)
examples.tex(,1835) @{
examples.tex(,1836)   resolution rs = mres(I,n+1);
examples.tex(,1837)   module tAn    = transpose(rs[n+1]);
examples.tex(,1838)   module tAn_1  = transpose(rs[n]);
examples.tex(,1839)   module ext_n  = modulo(syz(tAn),tAn_1);
examples.tex(,1840)   return(ext_n);
examples.tex(,1841) @}
examples.tex(,1842) @end smallexample
examples.tex(,1843) 
examples.tex(,1844) Now consider the following example:
examples.tex(,1845) 
examples.tex(,1846) @smallexample
examples.tex(,1847) ring r5 = 32003,(a,b,c,d,e),dp;
examples.tex(,1848) ideal I = a2b2+ab2c+b2cd, a2c2+ac2d+c2de,a2d2+ad2e+bd2e,a2e2+abe2+bce2;
examples.tex(,1849) print(ext(2,I));
examples.tex(,1850) @expansion{} 1,0,0,0,0,0,0,
examples.tex(,1851) @expansion{} 0,1,0,0,0,0,0,
examples.tex(,1852) @expansion{} 0,0,1,0,0,0,0,
examples.tex(,1853) @expansion{} 0,0,0,1,0,0,0,
examples.tex(,1854) @expansion{} 0,0,0,0,1,0,0,
examples.tex(,1855) @expansion{} 0,0,0,0,0,1,0,
examples.tex(,1856) @expansion{} 0,0,0,0,0,0,1
examples.tex(,1857) ext(3,I);   // too big to be displayed here
examples.tex(,1858) @end smallexample
examples.tex(,1859) 
examples.tex(,1860) The library @code{homolog.lib} contains several procedures for computing
examples.tex(,1861) Ext-modules and related modules, which are much more general and
examples.tex(,1862) sophisticated then the above one. They are used in the following
examples.tex(,1863) example.
examples.tex(,1864) 
examples.tex(,1865) If 
examples.tex(,1872)  is a module, then
examples.tex(,1879) are the modules of infinitesimal deformations, resp.@: of obstructions, of
examples.tex(,1880) 
examples.tex(,1887)  (like T1 and T2 for a singularity).  Similar to the treatment
examples.tex(,1888) for singularities, the semiuniversal deformation of 
examples.tex(,1895)  can be
examples.tex(,1896) computed (if
examples.tex(,1903) is finite dimensional) with the help of
examples.tex(,1910) and the cup product. There is an extra procedure for
examples.tex(,1917) if 
examples.tex(,1924)  is an ideal in 
examples.tex(,1931)  since this is faster than the
examples.tex(,1932) general Ext.
examples.tex(,1933) 
examples.tex(,1934) We compute
examples.tex(,1935) @itemize @bullet
examples.tex(,1936) @item
examples.tex(,1937) the infinitesimal deformations
examples.tex(,1944) and obstructions
examples.tex(,1951) of the residue field 
examples.tex(,1958)  of an ordinary cusp,
examples.tex(,1965) To compute
examples.tex(,1972) we have to apply @code{Ext(1,syz(m),syz(m))} with
examples.tex(,1973) @code{syz(m)} the first syzygy module of 
examples.tex(,1980) , which is isomorphic to
examples.tex(,1987) @item
examples.tex(,1994) for some ideal 
examples.tex(,2001)  and with an extra option.
examples.tex(,2002) @end itemize
examples.tex(,2003) 
examples.tex(,2004) @smallexample
examples.tex(,2005) @c computed example Computation_of_Ext examples.doc:1432 
examples.tex(,2006)   LIB "homolog.lib";
examples.tex(,2007)   ring R=0,(x,y),ds;
examples.tex(,2008)   ideal i=x2-y3;
examples.tex(,2009)   qring q = std(i);      // defines the quotient ring Loc_m k[x,y]/(x2-y3)
examples.tex(,2010)   ideal m = maxideal(1);
examples.tex(,2011)   module T1K = Ext(1,m,m);  // computes Ext^1(R/m,R/m)
examples.tex(,2012) @expansion{} // dimension of Ext^1:  0
examples.tex(,2013) @expansion{} // vdim of Ext^1:       2
examples.tex(,2014) @expansion{} 
examples.tex(,2015)   print(T1K);
examples.tex(,2016) @expansion{} 0,  0,y,x,0,y,0,    x2-y3,
examples.tex(,2017) @expansion{} -y2,x,x,0,y,0,x2-y3,0,    
examples.tex(,2018) @expansion{} 1,  0,0,0,0,0,0,    0     
examples.tex(,2019)   printlevel=2;             // gives more explanation
examples.tex(,2020)   module T2K=Ext(2,m,m);    // computes Ext^2(R/m,R/m)
examples.tex(,2021) @expansion{} // Computing Ext^2 (help Ext; gives an explanation):
examples.tex(,2022) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
examples.tex(,2023) @expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
examples.tex(,2024) @expansion{} // then Hom(F2,G0)-->Hom(F3,G0) is given by:
examples.tex(,2025) @expansion{} y2,x,
examples.tex(,2026) @expansion{} x, y 
examples.tex(,2027) @expansion{} // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
examples.tex(,2028) @expansion{} -y,x,  x,0,y,0,
examples.tex(,2029) @expansion{} x, -y2,0,x,0,y 
examples.tex(,2030) @expansion{} 
examples.tex(,2031) @expansion{} // dimension of Ext^2:  0
examples.tex(,2032) @expansion{} // vdim of Ext^2:       2
examples.tex(,2033) @expansion{} 
examples.tex(,2034)   print(std(T2K));
examples.tex(,2035) @expansion{} -y2,0,x,0,y,
examples.tex(,2036) @expansion{} 0,  x,0,y,0,
examples.tex(,2037) @expansion{} 1,  0,0,0,0 
examples.tex(,2038)   printlevel=0;
examples.tex(,2039)   module E = Ext(1,syz(m),syz(m));
examples.tex(,2040) @expansion{} // dimension of Ext^1:  0
examples.tex(,2041) @expansion{} // vdim of Ext^1:       2
examples.tex(,2042) @expansion{} 
examples.tex(,2043)   print(std(E));
examples.tex(,2044) @expansion{} -y,x, 0, 0,0,x,0,y,
examples.tex(,2045) @expansion{} 0, -y,-y,0,x,0,y,0,
examples.tex(,2046) @expansion{} 0, 0, 0, 1,0,0,0,0,
examples.tex(,2047) @expansion{} 0, 0, 1, 0,0,0,0,0,
examples.tex(,2048) @expansion{} 0, 1, 0, 0,0,0,0,0,
examples.tex(,2049) @expansion{} 1, 0, 0, 0,0,0,0,0 
examples.tex(,2050)   //The matrices which we have just computed are presentation matrices
examples.tex(,2051)   //of the modules T2K and E. Hence we may ignore those columns
examples.tex(,2052)   //containing 1 as an entry and see that T2K and E are isomorphic
examples.tex(,2053)   //as expected, but differently presented.
examples.tex(,2054)   //-------------------------------------------
examples.tex(,2055)   ring S=0,(x,y,z),dp;
examples.tex(,2056)   ideal  i = x2y,y2z,z3x;
examples.tex(,2057)   module E = Ext_R(2,i);
examples.tex(,2058) @expansion{} // dimension of Ext^2:  1
examples.tex(,2059) @expansion{} 
examples.tex(,2060)   print(E);
examples.tex(,2061) @expansion{} 0,y,0,z2,
examples.tex(,2062) @expansion{} z,0,0,-x,
examples.tex(,2063) @expansion{} 0,0,x,-y 
examples.tex(,2064)   // if a 3-rd argument is given (of any type)
examples.tex(,2065)   // a list of Ext^k(R/i,R), a SB of Ext^k(R/i,R) and a vector space basis
examples.tex(,2066)   // is returned:
examples.tex(,2067)   list LE = Ext_R(3,i,"");
examples.tex(,2068) @expansion{} // dimension of Ext^3:  0
examples.tex(,2069) @expansion{} // vdim of Ext^3:       2
examples.tex(,2070) @expansion{} 
examples.tex(,2071)   LE;
examples.tex(,2072) @expansion{} [1]:
examples.tex(,2073) @expansion{}    _[1]=y*gen(1)
examples.tex(,2074) @expansion{}    _[2]=x*gen(1)
examples.tex(,2075) @expansion{}    _[3]=z2*gen(1)
examples.tex(,2076) @expansion{} [2]:
examples.tex(,2077) @expansion{}    _[1]=y*gen(1)
examples.tex(,2078) @expansion{}    _[2]=x*gen(1)
examples.tex(,2079) @expansion{}    _[3]=z2*gen(1)
examples.tex(,2080) @expansion{} [3]:
examples.tex(,2081) @expansion{}    _[1,1]=z
examples.tex(,2082) @expansion{}    _[1,2]=1
examples.tex(,2083)   print(LE[2]);
examples.tex(,2084) @expansion{} y,x,z2
examples.tex(,2085)   print(kbase(LE[2]));
examples.tex(,2086) @expansion{} z,1
examples.tex(,2087) @c end example Computation_of_Ext examples.doc:1432
examples.tex(,2088) @end smallexample
examples.tex(,2089) @c  killall();
examples.tex(,2091) @c ----------------------------------------------------------------------------
examples.tex(,2093) @node Polar curves, Depth, Computation of Ext, Examples
examples.tex(,2094) @section   Polar curves
examples.tex(,2095) @cindex Polar curves
examples.tex(,2096) 
examples.tex(,2097) The polar curve of a hypersurface given by a polynomial
examples.tex(,2104) with respect to 
examples.tex(,2111)  (we may consider 
examples.tex(,2118)  as a family of
examples.tex(,2119) hypersurfaces parametrized by 
examples.tex(,2126) ) is defined as the Zariski
examples.tex(,2127) closure of
examples.tex(,2134) if this happens to be a curve.  Some authors consider
examples.tex(,2141) itself as polar curve.
examples.tex(,2142) 
examples.tex(,2143) We may consider projective hypersurfaces
examples.tex(,2150) affine hypersurfaces
examples.tex(,2157) or germs of hypersurfaces
examples.tex(,2164) getting in this way
examples.tex(,2165) projective, affine or local polar curves.
examples.tex(,2166) 
examples.tex(,2167) Now let us compute this for a family of curves.  We need the library
examples.tex(,2168) @code{elim.lib} for saturation and @code{sing.lib} for the singular
examples.tex(,2169) locus.
examples.tex(,2170) 
examples.tex(,2171) @smallexample
examples.tex(,2172) @c computed example Polar_curves examples.doc:1526 
examples.tex(,2173)   LIB "elim.lib";
examples.tex(,2174)   LIB "sing.lib";
examples.tex(,2175)   // Affine polar curve:
examples.tex(,2176)   ring R = 0,(x,z,t),dp;              // global ordering dp
examples.tex(,2177)   poly f = z5+xz3+x2-tz6;
examples.tex(,2178)   dim_slocus(f);                      // dimension of singular locus
examples.tex(,2179) @expansion{} 1
examples.tex(,2180)   ideal j = diff(f,x),diff(f,z);
examples.tex(,2181)   dim(std(j));                        // dim V(j)
examples.tex(,2182) @expansion{} 1
examples.tex(,2183)   dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
examples.tex(,2184) @expansion{} 1
examples.tex(,2185)   // j defines a curve, but to get the polar curve we must remove the
examples.tex(,2186)   // branches contained in f=0 (they exist since dim V(j,f) = 1). This
examples.tex(,2187)   // gives the polar curve set theoretically. But for the structure we
examples.tex(,2188)   // may take either j:f or j:f^k for k sufficiently large. The first is
examples.tex(,2189)   // just the ideal quotient, the second the iterated ideal quotient
examples.tex(,2190)   // or saturation. In our case both coincide.
examples.tex(,2191)   ideal q = quotient(j,ideal(f));     // ideal quotient
examples.tex(,2192)   ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
examples.tex(,2193)   ideal sq = std(q);
examples.tex(,2194)   dim(sq);
examples.tex(,2195) @expansion{} 1
examples.tex(,2196)   // 1-dimensional, hence q defines the affine polar curve
examples.tex(,2197)   //
examples.tex(,2198)   // to check that q and qsat are the same, we show both inclusions, i.e.,
examples.tex(,2199)   // both reductions must give the 0-ideal
examples.tex(,2200)   size(reduce(qsat,sq));
examples.tex(,2201) @expansion{} 0
examples.tex(,2202)   size(reduce(q,std(qsat)));
examples.tex(,2203) @expansion{} 0
examples.tex(,2204)   qsat;
examples.tex(,2205) @expansion{} qsat[1]=12zt+3z-10
examples.tex(,2206) @expansion{} qsat[2]=5z2+12xt+3x
examples.tex(,2207) @expansion{} qsat[3]=144xt2+72xt+9x+50z
examples.tex(,2208)   // We see that the affine polar curve does not pass through the origin,
examples.tex(,2209)   // hence we expect the local polar "curve" to be empty
examples.tex(,2210)   // ------------------------------------------------
examples.tex(,2211)   // Local polar curve:
examples.tex(,2212)   ring r = 0,(x,z,t),ds;              // local ordering ds
examples.tex(,2213)   poly f = z5+xz3+x2-tz6;
examples.tex(,2214)   ideal j = diff(f,x),diff(f,z);
examples.tex(,2215)   dim(std(j));                        // V(j) 1-dimensional
examples.tex(,2216) @expansion{} 1
examples.tex(,2217)   dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
examples.tex(,2218) @expansion{} 1
examples.tex(,2219)   ideal q = quotient(j,ideal(f));     // ideal quotient
examples.tex(,2220)   q;
examples.tex(,2221) @expansion{} q[1]=1
examples.tex(,2222)   // The local polar "curve" is empty, i.e., V(j) is contained in V(f)
examples.tex(,2223)   // ------------------------------------------------
examples.tex(,2224)   // Projective polar curve: (we need "sing.lib" and "elim.lib")
examples.tex(,2225)   ring P = 0,(x,z,t,y),dp;            // global ordering dp
examples.tex(,2226)   poly f = z5y+xz3y2+x2y4-tz6;
examples.tex(,2227)                                       // but consider t as parameter
examples.tex(,2228)   dim_slocus(f);              // projective 1-dimensional singular locus
examples.tex(,2229) @expansion{} 2
examples.tex(,2230)   ideal j = diff(f,x),diff(f,z);
examples.tex(,2231)   dim(std(j));                        // V(j), projective 1-dimensional
examples.tex(,2232) @expansion{} 2
examples.tex(,2233)   dim(std(j+ideal(f)));               // V(j,f) also projective 1-dimensional
examples.tex(,2234) @expansion{} 2
examples.tex(,2235)   ideal q = quotient(j,ideal(f));
examples.tex(,2236)   ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
examples.tex(,2237)   dim(std(qsat));
examples.tex(,2238) @expansion{} 2
examples.tex(,2239)   // projective 1-dimensional, hence q and/or qsat define the projective
examples.tex(,2240)   // polar curve. In this case, q and qsat are not the same, we needed
examples.tex(,2241)   // 2 quotients.
examples.tex(,2242)   // Let us check both reductions:
examples.tex(,2243)   size(reduce(qsat,std(q)));
examples.tex(,2244) @expansion{} 4
examples.tex(,2245)   size(reduce(q,std(qsat)));
examples.tex(,2246) @expansion{} 0
examples.tex(,2247)   // Hence q is contained in qsat but not conversely
examples.tex(,2248)   q;
examples.tex(,2249) @expansion{} q[1]=12zty+3zy-10y2
examples.tex(,2250) @expansion{} q[2]=60z2t-36xty-9xy-50zy
examples.tex(,2251)   qsat;
examples.tex(,2252) @expansion{} qsat[1]=12zt+3z-10y
examples.tex(,2253) @expansion{} qsat[2]=12xty+5z2+3xy
examples.tex(,2254) @expansion{} qsat[3]=144xt2+72xt+9x+50z
examples.tex(,2255) @expansion{} qsat[4]=z3+2xy2
examples.tex(,2256)   //
examples.tex(,2257)   // Now consider again the affine polar curve,
examples.tex(,2258)   // homogenize it with respect to y (deg t=0) and compare:
examples.tex(,2259)   // affine polar curve:
examples.tex(,2260)   ideal qa = 12zt+3z-10,5z2+12xt+3x,-144xt2-72xt-9x-50z;
examples.tex(,2261)   // homogenized:
examples.tex(,2262)   ideal qh = 12zt+3z-10y,5z2+12xyt+3xy,-144xt2-72xt-9x-50z;
examples.tex(,2263)   size(reduce(qh,std(qsat)));
examples.tex(,2264) @expansion{} 0
examples.tex(,2265)   size(reduce(qsat,std(qh)));
examples.tex(,2266) @expansion{} 0
examples.tex(,2267)   // both ideals coincide
examples.tex(,2268) @c end example Polar_curves examples.doc:1526
examples.tex(,2269) @end smallexample
examples.tex(,2271) @c ----------------------------------------------------------------------------
examples.tex(,2273) @node Depth, Formatting output, Polar curves, Examples
examples.tex(,2274) @section Depth
examples.tex(,2275) @cindex Depth
examples.tex(,2276) 
examples.tex(,2277) We compute the depth of the module of Kaehler differentials
examples.tex(,2284) of the variety defined by the 
examples.tex(,2291) -minors of a generic symmetric
examples.tex(,2298) We do this by computing the resolution over the polynomial
examples.tex(,2299) ring.  Then, by the Auslander-Buchsbaum formula, the depth is equal to
examples.tex(,2300) the number of variables minus the length of a minimal resolution.  This
examples.tex(,2301) example was suggested by U.@: Vetter in order to check whether his bound
examples.tex(,2308) could be improved.
examples.tex(,2309) 
examples.tex(,2310) @smallexample
examples.tex(,2311) @c computed example Depth examples.doc:1632 
examples.tex(,2312)   LIB "matrix.lib"; LIB "sing.lib";
examples.tex(,2313)   int n = 4;
examples.tex(,2314)   int m = 3;
examples.tex(,2315)   int N = n*(n+1)/2;           // will become number of variables
examples.tex(,2316)   ring R = 32003,x(1..N),dp;
examples.tex(,2317)   matrix X = symmat(n);        // proc from matrix.lib
examples.tex(,2318)                                // creates the symmetric generic nxn matrix
examples.tex(,2319)   print(X);
examples.tex(,2320) @expansion{} x(1),x(2),x(3),x(4),
examples.tex(,2321) @expansion{} x(2),x(5),x(6),x(7),
examples.tex(,2322) @expansion{} x(3),x(6),x(8),x(9),
examples.tex(,2323) @expansion{} x(4),x(7),x(9),x(10)
examples.tex(,2324)   ideal J = minor(X,m);
examples.tex(,2325)   J=std(J);
examples.tex(,2326)   // Kaehler differentials D_k(R)
examples.tex(,2327)   // of R=k[x1..xn]/J:
examples.tex(,2328)   module D = J*freemodule(N)+transpose(jacob(J));
examples.tex(,2329)   ncols(D);
examples.tex(,2330) @expansion{} 110
examples.tex(,2331)   nrows(D);
examples.tex(,2332) @expansion{} 10
examples.tex(,2333)   //
examples.tex(,2334)   // Note: D is a submodule with 110 generators of a free module
examples.tex(,2335)   // of rank 10 over a polynomial ring in 10 variables.
examples.tex(,2336)   // Compute a full resolution of D with sres.
examples.tex(,2337)   // This takes about 17 sec on a Mac PB 520c and 2 sec an a HP 735
examples.tex(,2338)   int time = timer;
examples.tex(,2339)   module sD = std(D);
examples.tex(,2340)   list Dres = sres(sD,0);                // the full resolution
examples.tex(,2341)   timer-time;                            // time used for std + sres
examples.tex(,2342) @expansion{} 0
examples.tex(,2343)   intmat B = betti(Dres);
examples.tex(,2344)   print(B,"betti");
examples.tex(,2345) @expansion{}            0     1     2     3     4     5     6
examples.tex(,2346) @expansion{} ------------------------------------------------
examples.tex(,2347) @expansion{}     0:    10     -     -     -     -     -     -
examples.tex(,2348) @expansion{}     1:     -    10     -     -     -     -     -
examples.tex(,2349) @expansion{}     2:     -    84   144    60     -     -     -
examples.tex(,2350) @expansion{}     3:     -     -    35    80    60    16     1
examples.tex(,2351) @expansion{} ------------------------------------------------
examples.tex(,2352) @expansion{} total:    10    94   179   140    60    16     1
examples.tex(,2353)   N-ncols(B)+1;                          // the desired depth
examples.tex(,2354) @expansion{} 4
examples.tex(,2355) @c end example Depth examples.doc:1632
examples.tex(,2356) @end smallexample
examples.tex(,2357) @c  killall();
examples.tex(,2359) 
examples.tex(,2360) @c ----------------------------------------------------------------------------
examples.tex(,2362) @node Formatting output, Cyclic roots, Depth, Examples
examples.tex(,2367) @section Formatting output
examples.tex(,2368) @cindex Formatting output
examples.tex(,2369) 
examples.tex(,2370) We show how to insert the result of a computation inside a text
examples.tex(,2371) by using strings.
examples.tex(,2372) First we compute the powers of 2 and comment the result with some text.
examples.tex(,2373) Then we do the same and give the output a nice format by computing and
examples.tex(,2374) adding appropriate space.
examples.tex(,2375) 
examples.tex(,2376) @smallexample
examples.tex(,2377) @c computed example Formatting_output examples.doc:1682 
examples.tex(,2378)   // The powers of 2:
examples.tex(,2379)   int  n;
examples.tex(,2380)   for (n = 2; n <= 128; n = n * 2)
examples.tex(,2381)   @{"n = " + string (n);@}
examples.tex(,2382) @expansion{} n = 2
examples.tex(,2383) @expansion{} n = 4
examples.tex(,2384) @expansion{} n = 8
examples.tex(,2385) @expansion{} n = 16
examples.tex(,2386) @expansion{} n = 32
examples.tex(,2387) @expansion{} n = 64
examples.tex(,2388) @expansion{} n = 128
examples.tex(,2389)   // The powers of 2 in a nice format
examples.tex(,2390)   int j;
examples.tex(,2391)   string space = "";
examples.tex(,2392)   for (n = 2; n <= 128; n = n * 2)
examples.tex(,2393)   @{
examples.tex(,2394)     space = "";
examples.tex(,2395)     for (j = 1; j <= 5 - size (string (n)); j = j+1)
examples.tex(,2396)     @{ space = space + " "; @}
examples.tex(,2397)     "n =" + space + string (n);
examples.tex(,2398)   @}
examples.tex(,2399) @expansion{} n =    2
examples.tex(,2400) @expansion{} n =    4
examples.tex(,2401) @expansion{} n =    8
examples.tex(,2402) @expansion{} n =   16
examples.tex(,2403) @expansion{} n =   32
examples.tex(,2404) @expansion{} n =   64
examples.tex(,2405) @expansion{} n =  128
examples.tex(,2406) @c end example Formatting_output examples.doc:1682
examples.tex(,2407) @end smallexample
examples.tex(,2408) 
examples.tex(,2409) @c ----------------------------------------------------------------------------
examples.tex(,2411) @node Cyclic roots, G_a -Invariants, Formatting output, Examples
examples.tex(,2412) @section Cyclic roots
examples.tex(,2413) @cindex Cyclic roots
examples.tex(,2414) 
examples.tex(,2415) We write a procedure returning a string that enables us to create
examples.tex(,2416) automatically the ideal of cyclic roots over the basering with n
examples.tex(,2417) variables. The procedure assumes that the variables consist of a single
examples.tex(,2418) letter each (hence no indexed variables are allowed; the procedure
examples.tex(,2419) @code{cyclic} in @code{poly.lib} does not have this restriction). Then
examples.tex(,2420) we compute a standard basis of this ideal and some numerical
examples.tex(,2421) information.  (This ideal is used as a classical benchmark for standard
examples.tex(,2422) basis computations).
examples.tex(,2423) 
examples.tex(,2424) @smallexample
examples.tex(,2425) // We call the procedure 'cyclic':
examples.tex(,2426) proc cyclic (int n)
examples.tex(,2427) @{
examples.tex(,2428)    string vs = varstr(basering)+varstr(basering);
examples.tex(,2429)    int c=find(vs,",");
examples.tex(,2430)    while ( c!=0 )
examples.tex(,2431)    @{
examples.tex(,2432)       vs=vs[1,c-1]+vs[c+1,size(vs)];
examples.tex(,2433)       c=find(vs,",");
examples.tex(,2434)    @}
examples.tex(,2435)    string t,s;
examples.tex(,2436)    int i,j;
examples.tex(,2437)    for ( j=1; j<=n-1; j=j+1 )
examples.tex(,2438)    @{
examples.tex(,2439)       t="";
examples.tex(,2440)       for ( i=1; i <=n; i=i+1 )
examples.tex(,2441)       @{
examples.tex(,2442)          t = t + vs[i,j] + "+";
examples.tex(,2443)       @}
examples.tex(,2444)       t = t[1,size(t)-1] + ","+newline;
examples.tex(,2445)       s=s+t;
examples.tex(,2446)    @}
examples.tex(,2447)    s=s+vs[1,n]+"-1";
examples.tex(,2448)    return (s);
examples.tex(,2449) @}
examples.tex(,2450) 
examples.tex(,2451) ring r=0,(a,b,c,d,e),lp;         // basering, char 0, lex ordering
examples.tex(,2452) string sc=cyclic(nvars(basering));
examples.tex(,2453) sc;                              // the string of the ideal
examples.tex(,2454) @expansion{} a+b+c+d+e,
examples.tex(,2455) @expansion{} ab+bc+cd+de+ea,
examples.tex(,2456) @expansion{} abc+bcd+cde+dea+eab,
examples.tex(,2457) @expansion{} abcd+bcde+cdea+deab+eabc,
examples.tex(,2458) @expansion{} abcde-1
examples.tex(,2459) execute("ideal i="+sc+";");      // this defines the ideal of cyclic roots
examples.tex(,2460) i;
examples.tex(,2461) @expansion{} i[1]=a+b+c+d+e
examples.tex(,2462) @expansion{} i[2]=ab+bc+cd+ae+de
examples.tex(,2463) @expansion{} i[3]=abc+bcd+abe+ade+cde
examples.tex(,2464) @expansion{} i[4]=abcd+abce+abde+acde+bcde
examples.tex(,2465) @expansion{} i[5]=abcde-1
examples.tex(,2466) timer=1;
examples.tex(,2467) ideal j=std(i);
examples.tex(,2468) @expansion{} //used time: 7.5 sec
examples.tex(,2469) size(j);                         // number of elements in the std basis
examples.tex(,2470) @expansion{} 11
examples.tex(,2471) degree(j);
examples.tex(,2472) @expansion{} // codimension = 5
examples.tex(,2473) @expansion{} // dimension   = 0
examples.tex(,2474) @expansion{} // degree      = 70
examples.tex(,2475) @end smallexample
examples.tex(,2477) @c ----------------------------------------------------------------------------
examples.tex(,2479) @node G_a -Invariants, Invariants of a finite group, Cyclic roots, Examples
examples.tex(,2480) @section G_a -Invariants
examples.tex(,2481) @cindex G_a -Invariants
examples.tex(,2482) 
examples.tex(,2483) We work in characteristic 0 and use the Lie algebra generated by one
examples.tex(,2484) vector field of the form
examples.tex(,2491) @smallexample
examples.tex(,2492) @c computed example G_a_-Invariants examples.doc:1783 
examples.tex(,2493)   LIB "ainvar.lib";
examples.tex(,2494)   int n=5;
examples.tex(,2495)   int i;
examples.tex(,2496)   ring s=32003,(x(1..n)),wp(1,2,3,4,5);
examples.tex(,2497)   // definition of the vector field m=sum m[i,1]*d/dx(i)
examples.tex(,2498)   matrix m[n][1];
examples.tex(,2499)   for (i=1;i<=n-1;i=i+1)
examples.tex(,2500)   @{
examples.tex(,2501)      m[i+1,1]=x(i);
examples.tex(,2502)   @}
examples.tex(,2503)   // computation of the ring of invariants
examples.tex(,2504)   ideal in=invariantRing(m,x(2),x(1),0);
examples.tex(,2505)   in;   //invariant ring is generated by 5 invariants
examples.tex(,2506) @expansion{} in[1]=x(1)
examples.tex(,2507) @expansion{} in[2]=x(2)^2-2*x(1)*x(3)
examples.tex(,2508) @expansion{} in[3]=x(3)^2-2*x(2)*x(4)+2*x(1)*x(5)
examples.tex(,2509) @expansion{} in[4]=x(2)^3-3*x(1)*x(2)*x(3)+3*x(1)^2*x(4)
examples.tex(,2510) @expansion{} in[5]=x(3)^3-3*x(2)*x(3)*x(4)-15997*x(1)*x(4)^2+3*x(2)^2*x(5)-6*x(1)*x(3)\
examples.tex(,2511)    *x(5)
examples.tex(,2512)   ring q=32003,(x,y,z,u,v,w),dp;
examples.tex(,2513)   matrix m[6][1];
examples.tex(,2514)   m[2,1]=x;
examples.tex(,2515)   m[3,1]=y;
examples.tex(,2516)   m[5,1]=u;
examples.tex(,2517)   m[6,1]=v;
examples.tex(,2518)   // the vector field is: xd/dy+yd/dz+ud/dv+vd/dw
examples.tex(,2519)   ideal in=invariantRing(m,y,x,0);
examples.tex(,2520)   in; //invariant ring is generated by 6 invariants
examples.tex(,2521) @expansion{} in[1]=x
examples.tex(,2522) @expansion{} in[2]=u
examples.tex(,2523) @expansion{} in[3]=v2-2uw
examples.tex(,2524) @expansion{} in[4]=zu-yv+xw
examples.tex(,2525) @expansion{} in[5]=yu-xv
examples.tex(,2526) @expansion{} in[6]=y2-2xz
examples.tex(,2527) @c end example G_a_-Invariants examples.doc:1783
examples.tex(,2528) @end smallexample
examples.tex(,2529) @c kill n,i,s,q;
examples.tex(,2531) @c ----------------------------------------------------------------------------
examples.tex(,2533) @node Invariants of a finite group, Factorization, G_a -Invariants, Examples
examples.tex(,2534) @section Invariants of a finite group
examples.tex(,2535) @cindex Invariants of a finite group
examples.tex(,2536) 
examples.tex(,2537) Two algorithms to compute the invariant ring are implemented in
examples.tex(,2538) @sc{Singular}, @code{invariant_ring} and @code{invariant_ring_random},
examples.tex(,2539) both by Agnes E. Heydtmann (@code{agnes@@math.uni-sb.de}).
examples.tex(,2540) 
examples.tex(,2541) Bases of homogeneous invariants are generated successively and those are
examples.tex(,2542) chosen as primary invariants that lower the dimension of the ideal
examples.tex(,2543) generated by the previously found invariants (see paper "Generating a
examples.tex(,2544) Noetherian Normalization of the Invariant Ring of a Finite Group" by
examples.tex(,2545) Decker, Heydtmann, Schreyer (1997) to appear in JSC).  In the
examples.tex(,2546) non-modular case secondary invariants are calculated by finding a basis
examples.tex(,2547) (in terms of monomials) of the basering modulo the primary invariants,
examples.tex(,2548) mapping to invariants with the Reynolds operator and using those or
examples.tex(,2549) their power products such that they are linearly independent modulo the
examples.tex(,2550) primary invariants (see paper "Some Algorithms in Invariant Theory of
examples.tex(,2551) Finite Groups" by Kemper and Steel (1997)).  In the modular case they
examples.tex(,2552) are generated according to "Generating Invariant Rings of Finite Groups
examples.tex(,2553) over Arbitrary Fields" by Kemper (1996, to appear in JSC).
examples.tex(,2554) 
examples.tex(,2555) We calculate now an example from Sturmfels: "Algorithms in Invariant
examples.tex(,2556) Theory 2.3.7":
examples.tex(,2557) 
examples.tex(,2558) @smallexample
examples.tex(,2559) @c computed example Invariants_of_a_finite_group examples.doc:1838 
examples.tex(,2560)   LIB "finvar.lib";
examples.tex(,2561)   ring R=0,(x,y,z),dp;
examples.tex(,2562)   matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
examples.tex(,2563)   // the group G is generated by A in Gl(3,Q);
examples.tex(,2564)   print(A);
examples.tex(,2565) @expansion{} 0, 1,0,
examples.tex(,2566) @expansion{} -1,0,0,
examples.tex(,2567) @expansion{} 0, 0,-1
examples.tex(,2568)   print(A*A*A*A); // the fourth power of A is 1
examples.tex(,2569) @expansion{} 1,0,0,
examples.tex(,2570) @expansion{} 0,1,0,
examples.tex(,2571) @expansion{} 0,0,1 
examples.tex(,2572)   // Use the first method to compute the invariants of G:
examples.tex(,2573)   matrix B(1..3);
examples.tex(,2574)   B(1..3)=invariant_ring(A);
examples.tex(,2575)   // SINGULAR returns 2 matrices, the first containing
examples.tex(,2576)   // primary invariants and the second secondary
examples.tex(,2577)   // invariants, i.e., module generators over a Noetherian
examples.tex(,2578)   // normalization
examples.tex(,2579)   // the third result are the irreducible secondary invariants
examples.tex(,2580)   // if the Molien series was available
examples.tex(,2581)   print(B(1));
examples.tex(,2582) @expansion{} z2,x2+y2,x2y2
examples.tex(,2583)   print(B(2));
examples.tex(,2584) @expansion{} 1,xyz,x2z-y2z,x3y-xy3
examples.tex(,2585)   print(B(3));
examples.tex(,2586) @expansion{} xyz,x2z-y2z,x3y-xy3
examples.tex(,2587)   // Use the second method,
examples.tex(,2588)   // with random numbers between -1 and 1:
examples.tex(,2589)   B(1..3)=invariant_ring_random(A,1);
examples.tex(,2590)   print(B(1..3));
examples.tex(,2591) @expansion{} z2,x2+y2,x4+y4-z4
examples.tex(,2592) @expansion{} 1,xyz,x2z-y2z,x3y-xy3
examples.tex(,2593) @expansion{} xyz,x2z-y2z,x3y-xy3
examples.tex(,2594) @c end example Invariants_of_a_finite_group examples.doc:1838
examples.tex(,2595) @end smallexample
examples.tex(,2597) @c ----------------------------------------------------------------------------
examples.tex(,2599) @node Factorization, Puiseux pairs, Invariants of a finite group, Examples
examples.tex(,2604) @section Factorization
examples.tex(,2605) @cindex Factorization
examples.tex(,2606) 
examples.tex(,2607) The factorization of polynomials is implemented in the C++ libraries
examples.tex(,2608) Factory (written mainly by Ruediger Stobbe) and libfac (written by
examples.tex(,2609) Michael Messollen) which are part of the @sc{Singular} system.
examples.tex(,2610) 
examples.tex(,2611) @smallexample
examples.tex(,2612) @c computed example Factorization examples.doc:1879 
examples.tex(,2613)   ring r = 0,(x,y),dp;
examples.tex(,2614)   poly f = 9x16-18x13y2-9x12y3+9x10y4-18x11y2+36x8y4
examples.tex(,2615)          +18x7y5-18x5y6+9x6y4-18x3y6-9x2y7+9y8;
examples.tex(,2616)   // = 9 * (x5-1y2)^2 * (x6-2x3y2-1x2y3+y4)
examples.tex(,2617)   factorize(f);
examples.tex(,2618) @expansion{} [1]:
examples.tex(,2619) @expansion{}    _[1]=9
examples.tex(,2620) @expansion{}    _[2]=x6-2x3y2-x2y3+y4
examples.tex(,2621) @expansion{}    _[3]=-x5+y2
examples.tex(,2622) @expansion{} [2]:
examples.tex(,2623) @expansion{}    1,1,2
examples.tex(,2624)   // returns factors and multiplicities,
examples.tex(,2625)   // first factor is a constant.
examples.tex(,2626)   poly g = (y4+x8)*(x2+y2);
examples.tex(,2627)   factorize(g);
examples.tex(,2628) @expansion{} [1]:
examples.tex(,2629) @expansion{}    _[1]=1
examples.tex(,2630) @expansion{}    _[2]=x8+y4
examples.tex(,2631) @expansion{}    _[3]=x2+y2
examples.tex(,2632) @expansion{} [2]:
examples.tex(,2633) @expansion{}    1,1,1
examples.tex(,2634)   // The same in characteristic 2:
examples.tex(,2635)   ring s =2,(x,y),dp;
examples.tex(,2636)   poly g = (y4+x8)*(x2+y2);
examples.tex(,2637)   factorize(g);
examples.tex(,2638) @expansion{} [1]:
examples.tex(,2639) @expansion{}    _[1]=1
examples.tex(,2640) @expansion{}    _[2]=x+y
examples.tex(,2641) @expansion{}    _[3]=x2+y
examples.tex(,2642) @expansion{} [2]:
examples.tex(,2643) @expansion{}    1,2,4
examples.tex(,2644) @c end example Factorization examples.doc:1879
examples.tex(,2645) @end smallexample
examples.tex(,2646) 
examples.tex(,2647) @c ----------------------------------------------------------------------------
examples.tex(,2649) @node Puiseux pairs, Primary decomposition, Factorization, Examples
examples.tex(,2650) @section Puiseux pairs
examples.tex(,2651) @cindex Puiseux pairs
examples.tex(,2652) 
examples.tex(,2653) The Puiseux pairs of an irreducible and reduced curve singularity are
examples.tex(,2654) its most important invariants.  They can be computed from its
examples.tex(,2655) Hamburger-Noether expansion.  The library @code{hnoether.lib} written by
examples.tex(,2656) Martin Lamm uses the algorithm of Antonio Campillo "Algebroid curves in
examples.tex(,2657) positive characteristic" SLN 813, 1980.  This algorithm has the
examples.tex(,2658) advantage that it needs least possible field extensions and, moreover,
examples.tex(,2659) works in any characteristic. This fact can be used to compute the
examples.tex(,2660) invariants over a field of finite characteristic, say 32003, which will
examples.tex(,2661) then most probably be the same in characteristic 0.
examples.tex(,2662) 
examples.tex(,2663) We compute the Hamburger-Noether expansion of a plane curve
examples.tex(,2664) singularity given by a polynomial 
examples.tex(,2671)  in two variables. This is a
examples.tex(,2672) matrix which allows to compute the parametrization (up to a given order)
examples.tex(,2673) and all numerical invariants like the
examples.tex(,2674) @itemize @bullet
examples.tex(,2675) @item
examples.tex(,2676)     characteristic exponents,
examples.tex(,2677) @item
examples.tex(,2678)     Puiseux pairs (of a complex model),
examples.tex(,2679) @item
examples.tex(,2680)     degree of the conductor,
examples.tex(,2681) @item
examples.tex(,2682)     delta invariant,
examples.tex(,2683) @item
examples.tex(,2684)     generators of the semigroup.
examples.tex(,2685) @end itemize
examples.tex(,2686) Besides this, the library contains procedures to compute the Newton
examples.tex(,2687) polygon of 
examples.tex(,2694) , the squarefree part of 
examples.tex(,2701)  and a procedure to
examples.tex(,2702) convert one set of invariants to another.
examples.tex(,2703) 
examples.tex(,2704) 
examples.tex(,2705) @smallexample
examples.tex(,2706) @c computed example Puiseux_pairs examples.doc:1934 
examples.tex(,2707)   LIB "hnoether.lib";
examples.tex(,2708)   // ======== The irreducible case ========
examples.tex(,2709)   ring s = 0,(x,y),ds;
examples.tex(,2710)   poly f = y4-2x3y2-4x5y+x6-x7;
examples.tex(,2711)   list hn = develop(f);
examples.tex(,2712)   show(hn[1]);     // Hamburger-Noether matrix
examples.tex(,2713) @expansion{} // matrix, 3x3
examples.tex(,2714) @expansion{} 0,x,  0,  
examples.tex(,2715) @expansion{} 0,1,  x,  
examples.tex(,2716) @expansion{} 0,1/4,-1/2
examples.tex(,2717)   displayHNE(hn);  // Hamburger-Noether development
examples.tex(,2718) @expansion{} HNE[1]=-y+z(0)*z(1)
examples.tex(,2719) @expansion{} HNE[2]=-x+z(1)^2+z(1)^2*z(2)
examples.tex(,2720) @expansion{} HNE[3]=1/4*z(2)^2-1/2*z(2)^3
examples.tex(,2721)   setring s;
examples.tex(,2722)   displayInvariants(hn);
examples.tex(,2723) @expansion{}  characteristic exponents  : 4,6,7
examples.tex(,2724) @expansion{}  generators of semigroup   : 4,6,13
examples.tex(,2725) @expansion{}  Puiseux pairs             : (3,2)(7,2)
examples.tex(,2726) @expansion{}  degree of the conductor   : 16
examples.tex(,2727) @expansion{}  delta invariant           : 8
examples.tex(,2728) @expansion{}  sequence of multiplicities: 4,2,2,1,1
examples.tex(,2729)   // invariants(hn);  returns the invariants as list
examples.tex(,2730)   // partial parametrization of f: param takes the first variable
examples.tex(,2731)   // as infinite except the ring has more than 2 variables. Then
examples.tex(,2732)   // the 3rd variable is chosen.
examples.tex(,2733)   param(hn);
examples.tex(,2734) @expansion{} // ** Warning: result is exact up to order 5 in x and 7 in y !
examples.tex(,2735) @expansion{} _[1]=1/16x4-3/16x5+1/4x7
examples.tex(,2736) @expansion{} _[2]=1/64x6-5/64x7+3/32x8+1/16x9-1/8x10
examples.tex(,2737)   ring extring=0,(x,y,t),ds;
examples.tex(,2738)   poly f=x3+2xy2+y2;
examples.tex(,2739)   list hn=develop(f,-1);
examples.tex(,2740)   param(hn);       // partial parametrization of f
examples.tex(,2741) @expansion{} // ** Warning: result is exact up to order 2 in x and 3 in y !
examples.tex(,2742) @expansion{} _[1]=-t2
examples.tex(,2743) @expansion{} _[2]=-t3
examples.tex(,2744)   list hn1=develop(f,6);
examples.tex(,2745)   param(hn1);     // a better parametrization
examples.tex(,2746) @expansion{} // ** Warning: result is exact up to order 6 in x and 7 in y !
examples.tex(,2747) @expansion{} _[1]=-t2+2t4-4t6
examples.tex(,2748) @expansion{} _[2]=-t3+2t5-4t7
examples.tex(,2749)   // instead of recomputing you may extend the development:
examples.tex(,2750)   list hn2=extdevelop(hn,12);
examples.tex(,2751)   param(hn2);     // a still better parametrization
examples.tex(,2752) @expansion{} // ** Warning: result is exact up to order 12 in x and 13 in y !
examples.tex(,2753) @expansion{} _[1]=-t2+2t4-4t6+8t8-16t10+32t12
examples.tex(,2754) @expansion{} _[2]=-t3+2t5-4t7+8t9-16t11+32t13
examples.tex(,2755)   //
examples.tex(,2756)   // ======== The reducible case ========
examples.tex(,2757)   ring r = 0,(x,y),dp;
examples.tex(,2758)   poly f=x11-2y2x8-y3x7-y2x6+y4x5+2y4x3+y5x2-y6;
examples.tex(,2759)   // = (x5-1y2) * (x6-2x3y2-1x2y3+y4)
examples.tex(,2760)   list hn=reddevelop(f);
examples.tex(,2761)   show(hn[1][1]);     // Hamburger-Noether matrix of 1st branch
examples.tex(,2762) @expansion{} // matrix, 3x3
examples.tex(,2763) @expansion{} 0,x,0,
examples.tex(,2764) @expansion{} 0,1,x,
examples.tex(,2765) @expansion{} 0,1,-1
examples.tex(,2766)   displayInvariants(hn);
examples.tex(,2767) @expansion{}  --- invariants of branch number 1 : ---
examples.tex(,2768) @expansion{}  characteristic exponents  : 4,6,7
examples.tex(,2769) @expansion{}  generators of semigroup   : 4,6,13
examples.tex(,2770) @expansion{}  Puiseux pairs             : (3,2)(7,2)
examples.tex(,2771) @expansion{}  degree of the conductor   : 16
examples.tex(,2772) @expansion{}  delta invariant           : 8
examples.tex(,2773) @expansion{}  sequence of multiplicities: 4,2,2,1,1
examples.tex(,2774) @expansion{} 
examples.tex(,2775) @expansion{}  --- invariants of branch number 2 : ---
examples.tex(,2776) @expansion{}  characteristic exponents  : 2,5
examples.tex(,2777) @expansion{}  generators of semigroup   : 2,5
examples.tex(,2778) @expansion{}  Puiseux pairs             : (5,2)
examples.tex(,2779) @expansion{}  degree of the conductor   : 4
examples.tex(,2780) @expansion{}  delta invariant           : 2
examples.tex(,2781) @expansion{}  sequence of multiplicities: 2,2,1,1
examples.tex(,2782) @expansion{} 
examples.tex(,2783) @expansion{}  -------------- contact numbers : -------------- 
examples.tex(,2784) @expansion{} 
examples.tex(,2785) @expansion{} branch |    2    
examples.tex(,2786) @expansion{} -------+-----
examples.tex(,2787) @expansion{}     1  |    2
examples.tex(,2788) @expansion{} 
examples.tex(,2789) @expansion{}  -------------- intersection multiplicities : -------------- 
examples.tex(,2790) @expansion{} 
examples.tex(,2791) @expansion{} branch |    2    
examples.tex(,2792) @expansion{} -------+-----
examples.tex(,2793) @expansion{}     1  |   12
examples.tex(,2794) @expansion{} 
examples.tex(,2795) @expansion{}  -------------- delta invariant of the curve :  22
examples.tex(,2796)   param(hn[2]);      // parametrization of 2nd branch
examples.tex(,2797) @expansion{} _[1]=x2
examples.tex(,2798) @expansion{} _[2]=x5
examples.tex(,2799) @c end example Puiseux_pairs examples.doc:1934
examples.tex(,2800) @end smallexample
examples.tex(,2802) @c ----------------------------------------------------------------------------
examples.tex(,2804) @node Primary decomposition, Normalization, Puiseux pairs, Examples
examples.tex(,2805) @section Primary decomposition
examples.tex(,2806) @cindex Primary decomposition
examples.tex(,2807) 
examples.tex(,2808) There are two algorithms implemented in @sc{Singular} which provide
examples.tex(,2809) primary decomposition: @code{primdecGTZ}, based on
examples.tex(,2810) Gianni/Trager/Zacharias (written by Gerhard Pfister) and
examples.tex(,2811) @code{primdecSY}, based on Shimoyama/Yokoyama (written by Wolfram Decker
examples.tex(,2812) and Hans Schoenemann).
examples.tex(,2813) 
examples.tex(,2814) The result of @code{primdecGTZ} and @code{primdecSY} is returned as
examples.tex(,2815) a list of pairs of ideals,
examples.tex(,2816) where the second ideal form the prime ideal and the first
examples.tex(,2817) ideal form the corresponding primary ideal.
examples.tex(,2818) 
examples.tex(,2819) @smallexample
examples.tex(,2820) @c computed example Primary_decomposition examples.doc:1988 
examples.tex(,2821)   LIB "primdec.lib";
examples.tex(,2822)   ring r = 0,(a,b,c,d,e,f),dp;
examples.tex(,2823)   ideal i= f3, ef2, e2f, bcf-adf, de+cf, be+af, e3;
examples.tex(,2824)   primdecGTZ(i);
examples.tex(,2825) @expansion{} [1]:
examples.tex(,2826) @expansion{}    [1]:
examples.tex(,2827) @expansion{}       _[1]=f
examples.tex(,2828) @expansion{}       _[2]=e
examples.tex(,2829) @expansion{}    [2]:
examples.tex(,2830) @expansion{}       _[1]=f
examples.tex(,2831) @expansion{}       _[2]=e
examples.tex(,2832) @expansion{} [2]:
examples.tex(,2833) @expansion{}    [1]:
examples.tex(,2834) @expansion{}       _[1]=f3
examples.tex(,2835) @expansion{}       _[2]=ef2
examples.tex(,2836) @expansion{}       _[3]=e2f
examples.tex(,2837) @expansion{}       _[4]=e3
examples.tex(,2838) @expansion{}       _[5]=de+cf
examples.tex(,2839) @expansion{}       _[6]=be+af
examples.tex(,2840) @expansion{}       _[7]=-bc+ad
examples.tex(,2841) @expansion{}    [2]:
examples.tex(,2842) @expansion{}       _[1]=f
examples.tex(,2843) @expansion{}       _[2]=e
examples.tex(,2844) @expansion{}       _[3]=-bc+ad
examples.tex(,2845)   // We consider now the ideal J of the base space of the
examples.tex(,2846)   // miniversal deformation of the cone over the rational
examples.tex(,2847)   // normal curve computed in section *8* and compute
examples.tex(,2848)   // its primary decomposition.
examples.tex(,2849)   ring R = 0,(A,B,C,D),dp;
examples.tex(,2850)   ideal J = CD, BD+D2, AD;
examples.tex(,2851)   primdecGTZ(J);
examples.tex(,2852) @expansion{} [1]:
examples.tex(,2853) @expansion{}    [1]:
examples.tex(,2854) @expansion{}       _[1]=D
examples.tex(,2855) @expansion{}    [2]:
examples.tex(,2856) @expansion{}       _[1]=D
examples.tex(,2857) @expansion{} [2]:
examples.tex(,2858) @expansion{}    [1]:
examples.tex(,2859) @expansion{}       _[1]=C
examples.tex(,2860) @expansion{}       _[2]=B+D
examples.tex(,2861) @expansion{}       _[3]=A
examples.tex(,2862) @expansion{}    [2]:
examples.tex(,2863) @expansion{}       _[1]=C
examples.tex(,2864) @expansion{}       _[2]=B+D
examples.tex(,2865) @expansion{}       _[3]=A
examples.tex(,2866)   // We see that there are two components which are both
examples.tex(,2867)   // prime, even linear subspaces, one 3-dimensional,
examples.tex(,2868)   // the other 1-dimensional.
examples.tex(,2869)   // (This is Pinkhams example and was the first known
examples.tex(,2870)   // surface singularity with two components of
examples.tex(,2871)   // different dimensions)
examples.tex(,2872)   //
examples.tex(,2873)   // Let us now produce an embedded component in the last
examples.tex(,2874)   // example, compute the minimal associated primes and
examples.tex(,2875)   // the radical. We use the Characteristic set methods
examples.tex(,2876)   // from prim_dec.lib.
examples.tex(,2877)   J = intersect(J,maxideal(3));
examples.tex(,2878)   // The following shows that the maximal ideal defines an embedded
examples.tex(,2879)   // (prime) component.
examples.tex(,2880)   primdecSY(J);
examples.tex(,2881) @expansion{} [1]:
examples.tex(,2882) @expansion{}    [1]:
examples.tex(,2883) @expansion{}       _[1]=D
examples.tex(,2884) @expansion{}    [2]:
examples.tex(,2885) @expansion{}       _[1]=D
examples.tex(,2886) @expansion{} [2]:
examples.tex(,2887) @expansion{}    [1]:
examples.tex(,2888) @expansion{}       _[1]=C
examples.tex(,2889) @expansion{}       _[2]=B+D
examples.tex(,2890) @expansion{}       _[3]=A
examples.tex(,2891) @expansion{}    [2]:
examples.tex(,2892) @expansion{}       _[1]=C
examples.tex(,2893) @expansion{}       _[2]=B+D
examples.tex(,2894) @expansion{}       _[3]=A
examples.tex(,2895) @expansion{} [3]:
examples.tex(,2896) @expansion{}    [1]:
examples.tex(,2897) @expansion{}       _[1]=D2
examples.tex(,2898) @expansion{}       _[2]=C2
examples.tex(,2899) @expansion{}       _[3]=B2
examples.tex(,2900) @expansion{}       _[4]=AB
examples.tex(,2901) @expansion{}       _[5]=A2
examples.tex(,2902) @expansion{}       _[6]=BCD
examples.tex(,2903) @expansion{}       _[7]=ACD
examples.tex(,2904) @expansion{}    [2]:
examples.tex(,2905) @expansion{}       _[1]=D
examples.tex(,2906) @expansion{}       _[2]=C
examples.tex(,2907) @expansion{}       _[3]=B
examples.tex(,2908) @expansion{}       _[4]=A
examples.tex(,2909)   minAssChar(J);
examples.tex(,2910) @expansion{} [1]:
examples.tex(,2911) @expansion{}    _[1]=C
examples.tex(,2912) @expansion{}    _[2]=B+D
examples.tex(,2913) @expansion{}    _[3]=A
examples.tex(,2914) @expansion{} [2]:
examples.tex(,2915) @expansion{}    _[1]=D
examples.tex(,2916)   radical(J);
examples.tex(,2917) @expansion{} _[1]=CD
examples.tex(,2918) @expansion{} _[2]=BD+D2
examples.tex(,2919) @expansion{} _[3]=AD
examples.tex(,2920) @c end example Primary_decomposition examples.doc:1988
examples.tex(,2921) @end smallexample
examples.tex(,2923) @c ----------------------------------------------------------------------------
examples.tex(,2925) @node Normalization, Branches of an Isolated Space Curve Singularity, Primary decomposition, Examples
examples.tex(,2926) @section Normalization
examples.tex(,2927) @cindex Normalization
examples.tex(,2928) The normalization will be computed for a reduced ring 
examples.tex(,2935) . The
examples.tex(,2936) result is a list of rings; ideals are always called @code{norid} in the
examples.tex(,2937) rings of this list. The normalization of 
examples.tex(,2944)  is the product of
examples.tex(,2945) the factor rings of the rings in the list divided out by the ideals
examples.tex(,2946) @code{norid}.
examples.tex(,2947) 
examples.tex(,2948) @smallexample
examples.tex(,2949) @c computed example Normalization examples.doc:2032 
examples.tex(,2950)   LIB "normal.lib";
examples.tex(,2951)   // ----- first example: rational quadruple point -----
examples.tex(,2952)   ring R=32003,(x,y,z),wp(3,5,15);
examples.tex(,2953)   ideal I=z*(y3-x5)+x10;
examples.tex(,2954)   list pr=normal(I);
examples.tex(,2955) @expansion{} 
examples.tex(,2956) @expansion{} // 'normal' created a list of 1 ring(s).
examples.tex(,2957) @expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
examples.tex(,2958) @expansion{} // To see the rings, type (if the name of your list is nor):
examples.tex(,2959) @expansion{}      show( nor);
examples.tex(,2960) @expansion{} // To access the 1-st ring and map (similar for the others), type:
examples.tex(,2961) @expansion{}      def R = nor[1]; setring R;  norid; normap;
examples.tex(,2962) @expansion{} // R/norid is the 1-st ring of the normalization and
examples.tex(,2963) @expansion{} // normap the map from the original basering to R/norid
examples.tex(,2964)   def S=pr[1];
examples.tex(,2965)   setring S;
examples.tex(,2966)   norid;
examples.tex(,2967) @expansion{} norid[1]=T(2)*T(3)-T(1)*T(4)
examples.tex(,2968) @expansion{} norid[2]=T(1)^7-T(1)^2*T(3)+T(2)*T(5)
examples.tex(,2969) @expansion{} norid[3]=T(1)^2*T(5)-T(2)*T(4)
examples.tex(,2970) @expansion{} norid[4]=T(1)^5*T(4)-T(3)*T(4)+T(5)^2
examples.tex(,2971) @expansion{} norid[5]=T(1)^6*T(3)-T(1)*T(3)^2+T(4)*T(5)
examples.tex(,2972) @expansion{} norid[6]=T(1)*T(3)*T(5)-T(4)^2
examples.tex(,2973)   // ----- second example: union of straight lines -----
examples.tex(,2974)   ring R1=0,(x,y,z),dp;
examples.tex(,2975)   ideal I=(x-y)*(x-z)*(y-z);
examples.tex(,2976)   list qr=normal(I);
examples.tex(,2977) @expansion{} 
examples.tex(,2978) @expansion{} // 'normal' created a list of 3 ring(s).
examples.tex(,2979) @expansion{} // nor[3+1] is the delta-invariant in case of choose=wd.
examples.tex(,2980) @expansion{} // To see the rings, type (if the name of your list is nor):
examples.tex(,2981) @expansion{}      show( nor);
examples.tex(,2982) @expansion{} // To access the 1-st ring and map (similar for the others), type:
examples.tex(,2983) @expansion{}      def R = nor[1]; setring R;  norid; normap;
examples.tex(,2984) @expansion{} // R/norid is the 1-st ring of the normalization and
examples.tex(,2985) @expansion{} // normap the map from the original basering to R/norid
examples.tex(,2986)   def S1=qr[1]; def S2=qr[2];
examples.tex(,2987)   setring S1; norid;
examples.tex(,2988) @expansion{} norid[1]=0
examples.tex(,2989)   setring S2; norid;
examples.tex(,2990) @expansion{} norid[1]=0
examples.tex(,2991) @c end example Normalization examples.doc:2032
examples.tex(,2992) @end smallexample
examples.tex(,2994) @c ----------------------------------------------------------------------------
examples.tex(,2996) @node Branches of an Isolated Space Curve Singularity, Kernel of module homomorphisms, Normalization,Examples
examples.tex(,2997) @section Branches of an Isolated Space Curve Singularity
examples.tex(,2998) @cindex Branches of an Isolated Space Curve Singularity
examples.tex(,2999) 
examples.tex(,3000) In this example, the number of branches of a given quasihomogeneous isolated
examples.tex(,3001) space curve singularity will be computed as an example of the pitfalls
examples.tex(,3002) appearing in the use of primary decomposition. When dealing with singularities,
examples.tex(,3003) two situations are possible in which the primary decomposition algorithm
examples.tex(,3004) might not lead to a complete decomposition: first of all, one of the computed
examples.tex(,3005) components could be globally irreducible, but analytically reducible
examples.tex(,3006) (this is impossible for quasihomogeneous singularities) and,
examples.tex(,3007) as a second possibility, a component might be irreducible over the rational
examples.tex(,3008) numbers, but reducible over the complex numbers.
examples.tex(,3009) @smallexample
examples.tex(,3010) @c computed example Branches_of_an_Isolated_Space_Curve_Singularity examples.doc:2067 
examples.tex(,3011)   ring r=0,(x,y,z),ds;
examples.tex(,3012)   ideal i=x^4-y*z^2,x*y-z^3,y^2-x^3*z;  // the space curve singularity
examples.tex(,3013)   qhweight(i);
examples.tex(,3014) @expansion{} 1,2,1
examples.tex(,3015)   // The given space curve singularity is quasihomogeneous. Hence we can pass
examples.tex(,3016)   // to the polynomial ring.
examples.tex(,3017)   ring rr=0,(x,y,z),dp;
examples.tex(,3018)   ideal i=imap(r,i);
examples.tex(,3019)   resolution ires=mres(i,0);
examples.tex(,3020)   ires;
examples.tex(,3021) @expansion{}   1       3       2       
examples.tex(,3022) @expansion{} rr <--  rr <--  rr
examples.tex(,3023) @expansion{} 
examples.tex(,3024) @expansion{} 0       1       2       
examples.tex(,3025) @expansion{} 
examples.tex(,3026)   // From the structure of the resolution, we see that the Cohen-Macaulay
examples.tex(,3027)   // type of the given singularity is 2
examples.tex(,3028)   //
examples.tex(,3029)   // Let us now look for the branches using the primdec library.
examples.tex(,3030)   LIB "primdec.lib";
examples.tex(,3031)   primdecSY(i);
examples.tex(,3032) @expansion{} [1]:
examples.tex(,3033) @expansion{}    [1]:
examples.tex(,3034) @expansion{}       _[1]=z3-xy
examples.tex(,3035) @expansion{}       _[2]=x3+x2z+xz2+xy+yz
examples.tex(,3036) @expansion{}       _[3]=x2z2+x2y+xyz+yz2+y2
examples.tex(,3037) @expansion{}    [2]:
examples.tex(,3038) @expansion{}       _[1]=z3-xy
examples.tex(,3039) @expansion{}       _[2]=x3+x2z+xz2+xy+yz
examples.tex(,3040) @expansion{}       _[3]=x2z2+x2y+xyz+yz2+y2
examples.tex(,3041) @expansion{} [2]:
examples.tex(,3042) @expansion{}    [1]:
examples.tex(,3043) @expansion{}       _[1]=x-z
examples.tex(,3044) @expansion{}       _[2]=z2-y
examples.tex(,3045) @expansion{}    [2]:
examples.tex(,3046) @expansion{}       _[1]=x-z
examples.tex(,3047) @expansion{}       _[2]=z2-y
examples.tex(,3048)   def li=_[2];
examples.tex(,3049)   ideal i2=li[2];       // call the second ideal i2
examples.tex(,3050)   // The curve seems to have 2 branches by what we computed using the
examples.tex(,3051)   // algorithm of Shimoyama-Yokoyama.
examples.tex(,3052)   // Now the same computation by the Gianni-Trager-Zacharias algorithm:
examples.tex(,3053)   primdecGTZ(i);
examples.tex(,3054) @expansion{} [1]:
examples.tex(,3055) @expansion{}    [1]:
examples.tex(,3056) @expansion{}       _[1]=z8+yz6+y2z4+y3z2+y4
examples.tex(,3057) @expansion{}       _[2]=xz5+z6+yz4+y2z2+y3
examples.tex(,3058) @expansion{}       _[3]=-z3+xy
examples.tex(,3059) @expansion{}       _[4]=x2z2+xz3+xyz+yz2+y2
examples.tex(,3060) @expansion{}       _[5]=x3+x2z+xz2+xy+yz
examples.tex(,3061) @expansion{}    [2]:
examples.tex(,3062) @expansion{}       _[1]=z8+yz6+y2z4+y3z2+y4
examples.tex(,3063) @expansion{}       _[2]=xz5+z6+yz4+y2z2+y3
examples.tex(,3064) @expansion{}       _[3]=-z3+xy
examples.tex(,3065) @expansion{}       _[4]=x2z2+xz3+xyz+yz2+y2
examples.tex(,3066) @expansion{}       _[5]=x3+x2z+xz2+xy+yz
examples.tex(,3067) @expansion{} [2]:
examples.tex(,3068) @expansion{}    [1]:
examples.tex(,3069) @expansion{}       _[1]=-z2+y
examples.tex(,3070) @expansion{}       _[2]=x-z
examples.tex(,3071) @expansion{}    [2]:
examples.tex(,3072) @expansion{}       _[1]=-z2+y
examples.tex(,3073) @expansion{}       _[2]=x-z
examples.tex(,3074)   // Having computed the primary decomposition in 2 different ways and
examples.tex(,3075)   // having obtained the same number of branches, we might expect that the
examples.tex(,3076)   // number of branches is really 2, but we can check this by formulae
examples.tex(,3077)   // for the invariants of space curve singularities:
examples.tex(,3078)   //
examples.tex(,3079)   // mu = tau - t + 1 (for quasihomogeneous curve singularities)
examples.tex(,3080)   // where mu denotes the Milnor number, tau the Tjurina number and
examples.tex(,3081)   // t the Cohen-Macaulay type
examples.tex(,3082)   //
examples.tex(,3083)   // mu = 2 delta - r + 1
examples.tex(,3084)   // where delta denotes the delta-Invariant and r the number of branches
examples.tex(,3085)   //
examples.tex(,3086)   // tau can be computed by using the corresponding procedure T1 from
examples.tex(,3087)   // sing.lib.
examples.tex(,3088)   setring r;
examples.tex(,3089)   LIB "sing.lib";
examples.tex(,3090)   T_1(i);
examples.tex(,3091) @expansion{} // dim T_1 = 13
examples.tex(,3092) @expansion{} _[1]=gen(6)+2z*gen(5)
examples.tex(,3093) @expansion{} _[2]=gen(4)+3x2*gen(2)
examples.tex(,3094) @expansion{} _[3]=gen(3)+gen(1)
examples.tex(,3095) @expansion{} _[4]=x*gen(5)-y*gen(2)-z*gen(1)
examples.tex(,3096) @expansion{} _[5]=x*gen(1)-z2*gen(2)
examples.tex(,3097) @expansion{} _[6]=y*gen(5)+3x2z*gen(2)
examples.tex(,3098) @expansion{} _[7]=y*gen(2)-z*gen(1)
examples.tex(,3099) @expansion{} _[8]=2y*gen(1)-z2*gen(5)
examples.tex(,3100) @expansion{} _[9]=z2*gen(5)
examples.tex(,3101) @expansion{} _[10]=z2*gen(1)
examples.tex(,3102) @expansion{} _[11]=x3*gen(2)
examples.tex(,3103) @expansion{} _[12]=x2z2*gen(2)
examples.tex(,3104) @expansion{} _[13]=xz3*gen(2)
examples.tex(,3105) @expansion{} _[14]=z4*gen(2)
examples.tex(,3106)   setring rr;
examples.tex(,3107)   // Hence tau is 13 and therefore mu is 12. But then it is impossible that
examples.tex(,3108)   // the singularity has two branches, since mu is even and delta is an
examples.tex(,3109)   // integer!
examples.tex(,3110)   // So obviously, we did not decompose completely. Because the first branch
examples.tex(,3111)   // is smooth, only the second ideal can be the one which can be decomposed
examples.tex(,3112)   // further.
examples.tex(,3113)   // Let us now consider the normalization of this second ideal i2.
examples.tex(,3114)   LIB "normal.lib";
examples.tex(,3115)   normal(i2);
examples.tex(,3116) @expansion{} 
examples.tex(,3117) @expansion{} // 'normal' created a list of 1 ring(s).
examples.tex(,3118) @expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
examples.tex(,3119) @expansion{} // To see the rings, type (if the name of your list is nor):
examples.tex(,3120) @expansion{}      show( nor);
examples.tex(,3121) @expansion{} // To access the 1-st ring and map (similar for the others), type:
examples.tex(,3122) @expansion{}      def R = nor[1]; setring R;  norid; normap;
examples.tex(,3123) @expansion{} // R/norid is the 1-st ring of the normalization and
examples.tex(,3124) @expansion{} // normap the map from the original basering to R/norid
examples.tex(,3125) @expansion{} [1]:
examples.tex(,3126) @expansion{}    //   characteristic : 0
examples.tex(,3127) @expansion{} //   number of vars : 1
examples.tex(,3128) @expansion{} //        block   1 : ordering dp
examples.tex(,3129) @expansion{} //                  : names    T(1) 
examples.tex(,3130) @expansion{} //        block   2 : ordering C
examples.tex(,3131)   def rno=_[1];
examples.tex(,3132)   setring rno;
examples.tex(,3133)   norid;
examples.tex(,3134) @expansion{} norid[1]=0
examples.tex(,3135)   // The ideal is generated by a polynomial in one variable of degree 4 which
examples.tex(,3136)   // factors completely into 4 polynomials of type T(2)+a.
examples.tex(,3137)   // From this, we know that the ring of the normalization is the direct sum of 
examples.tex(,3138)   // 4 polynomial rings in one variable.
examples.tex(,3139)   // Hence our original curve has these 4 branches plus a smooth one
examples.tex(,3140)   // which we already determined by primary decomposition.
examples.tex(,3141)   // Our final result is therefore: 5 branches.
examples.tex(,3142) @c end example Branches_of_an_Isolated_Space_Curve_Singularity examples.doc:2067
examples.tex(,3143) @end smallexample
examples.tex(,3145) @c ----------------------------------------------------------------------------
examples.tex(,3147) @node Kernel of module homomorphisms, Algebraic dependence, Branches of an Isolated Space Curve Singularity, Examples
examples.tex(,3152) @section Kernel of module homomorphisms
examples.tex(,3153) @cindex Kernel of module homomorphisms
examples.tex(,3154) Let 
examples.tex(,3161) , 
examples.tex(,3168)  be two matrices of size
examples.tex(,3175) over the ring 
examples.tex(,3182)  and consider the corresponding maps
examples.tex(,3202) We want to compute the kernel of the map
examples.tex(,3216) This can be done using the @code{modulo} command:
examples.tex(,3231) 
examples.tex(,3232) @smallexample
examples.tex(,3233) @c computed example Kernel_of_module_homomorphisms examples.doc:2196 
examples.tex(,3234)   ring r=0,(x,y,z),(c,dp);
examples.tex(,3235)   matrix A[2][2]=x,y,z,1;
examples.tex(,3236)   matrix B[2][2]=x2,y2,z2,xz;
examples.tex(,3237)   print(modulo(A,B));
examples.tex(,3238) @expansion{} yz2-x2, xyz-y2,  x2z-xy, x3-y2z,
examples.tex(,3239) @expansion{} x2z-xz2,-x2z+y2z,xyz-yz2,0      
examples.tex(,3240) @c end example Kernel_of_module_homomorphisms examples.doc:2196
examples.tex(,3241) @end smallexample
examples.tex(,3242) 
examples.tex(,3243) @c ----------------------------------------------------------------------------
examples.tex(,3245) @node Algebraic dependence, Classification, Kernel of module homomorphisms, Examples
examples.tex(,3250) @section Algebraic dependence
examples.tex(,3251) @cindex Algebraic dependence
examples.tex(,3252) Let
examples.tex(,3259) We want to check whether
examples.tex(,3260) @enumerate
examples.tex(,3261) @item
examples.tex(,3268) are algebraically dependent.
examples.tex(,3269) 
examples.tex(,3270) Let
examples.tex(,3282) Then
examples.tex(,3289) are the algebraic relations between
examples.tex(,3296) 
examples.tex(,3297) @item
examples.tex(,3304) 
examples.tex(,3311) if and only if the normal form of 
examples.tex(,3318)  with respect to 
examples.tex(,3325)  and a
examples.tex(,3326) block ordering with respect to
examples.tex(,3333) is in 
examples.tex(,3340) .
examples.tex(,3341) @end enumerate
examples.tex(,3342) 
examples.tex(,3343) Both questions can be answered using the following procedure. If the
examples.tex(,3344) second argument is zero, it checks for algebraic dependence and returns
examples.tex(,3345) the ideal of relations between the generators of the given ideal.
examples.tex(,3346) Otherwise it checks for subring membership and returns the normal form
examples.tex(,3347) of the second argument with respect to the ideal I.
examples.tex(,3348) 
examples.tex(,3349) @smallexample
examples.tex(,3350) @c computed example Algebraic_dependence examples.doc:2290 
examples.tex(,3351)   proc algebraicDep(ideal J, poly g)
examples.tex(,3352)   @{
examples.tex(,3353)     def R=basering;         // give a name to the basering
examples.tex(,3354)     int n=size(J);
examples.tex(,3355)     int k=nvars(R);
examples.tex(,3356)     int i;
examples.tex(,3357)     intvec v;
examples.tex(,3358) 
examples.tex(,3359)     // construction of the new ring:
examples.tex(,3360) 
examples.tex(,3361)     // construct a weight vector
examples.tex(,3362)     v[n+k]=0;         // gives a zero vector of length n+k
examples.tex(,3363)     for(i=1;i<=k;i++)
examples.tex(,3364)     @{
examples.tex(,3365)       v[i]=1;
examples.tex(,3366)     @}
examples.tex(,3367)     string orde="(a("+string(v)+"),dp);";
examples.tex(,3368)     string ri="ring Rhelp=("+charstr(R)+"),
examples.tex(,3369)                           ("+varstr(R)+",Y(1.."+string(n)+")),"+orde;
examples.tex(,3370)                             // ring definition as a string
examples.tex(,3371)     execute(ri);            // execution of the string
examples.tex(,3372) 
examples.tex(,3373)     // construction of the new ideal I=(J[1]-Y(1),...,J[n]-Y(n))
examples.tex(,3374)     ideal I=imap(R,J);
examples.tex(,3375)     for(i=1;i<=n;i++)
examples.tex(,3376)     @{
examples.tex(,3377)       I[i]=I[i]-var(k+i);
examples.tex(,3378)     @}
examples.tex(,3379)     poly g=imap(R,g);
examples.tex(,3380)     if(g==0)
examples.tex(,3381)     @{
examples.tex(,3382)       // construction of the ideal of relations by elimination
examples.tex(,3383)       poly el=var(1);
examples.tex(,3384)       for(i=2;i<=k;i++)
examples.tex(,3385)       @{
examples.tex(,3386)         el=el*var(i);
examples.tex(,3387)       @}
examples.tex(,3388)       ideal KK=eliminate(I,el);
examples.tex(,3389)       keepring(Rhelp);
examples.tex(,3390)       return(KK);
examples.tex(,3391)     @}
examples.tex(,3392)     // reduction of g with respect to I
examples.tex(,3393)     ideal KK=reduce(g,std(I));
examples.tex(,3394)     keepring(Rhelp);
examples.tex(,3395)     return(KK);
examples.tex(,3396)   @}
examples.tex(,3397) 
examples.tex(,3398)   // applications of the procedure
examples.tex(,3399)   ring r=0,(x,y,z),dp;
examples.tex(,3400)   ideal i=xz,yz;
examples.tex(,3401)   algebraicDep(i,0);
examples.tex(,3402) @expansion{} _[1]=0
examples.tex(,3403)   // Note: after call of algebraicDep(), the basering is Rhelp.
examples.tex(,3404)   setring r; kill Rhelp;
examples.tex(,3405)   ideal j=xy+z2,z2+y2,x2y2-2xy3+y4;
examples.tex(,3406)   algebraicDep(j,0);
examples.tex(,3407) @expansion{} _[1]=Y(1)^2-2*Y(1)*Y(2)+Y(2)^2-Y(3)
examples.tex(,3408)   setring r; kill Rhelp;
examples.tex(,3409)   poly g=y2z2-xz;
examples.tex(,3410)   algebraicDep(i,g);
examples.tex(,3411) @expansion{} _[1]=Y(2)^2-Y(1)
examples.tex(,3412)   // this shows that g is contained in i.
examples.tex(,3413)   setring r; kill Rhelp;
examples.tex(,3414)   algebraicDep(j,g);
examples.tex(,3415) @expansion{} _[1]=-z^4+z^2*Y(2)-x*z
examples.tex(,3416)   // this shows that g is contained in j.
examples.tex(,3417) @c end example Algebraic_dependence examples.doc:2290
examples.tex(,3418) @end smallexample
examples.tex(,3419) 
examples.tex(,3420) @c ----------------------------------------------------------------------------
examples.tex(,3422) @node Classification, Fast lexicographical GB, Algebraic dependence, Examples
examples.tex(,3423) @section Classification
examples.tex(,3424) @cindex Classification
examples.tex(,3425) 
examples.tex(,3426) Classification of isolated hypersurface singularities with respect to
examples.tex(,3427) right equivalence is provided by the command @code{classify} of the
examples.tex(,3428) library @code{classify.lib}. The classification is done using the
examples.tex(,3429) algorithm of Arnold. Before entering this algorithm, a first guess based
examples.tex(,3430) on the Hilbert polynomial of the Milnor algebra is made.
examples.tex(,3431) 
examples.tex(,3432) @smallexample
examples.tex(,3433) @c computed example Classification examples.doc:2369 
examples.tex(,3434)   LIB "classify.lib";
examples.tex(,3435)   ring r=0,(x,y,z),ds;
examples.tex(,3436)   poly p=singularity("E[6k+2]",2)[1];
examples.tex(,3437)   p=p+z^2;
examples.tex(,3438)   p;
examples.tex(,3439) @expansion{} z2+x3+xy6+y8
examples.tex(,3440)   // We received an E_14 singularity in normal form
examples.tex(,3441)   // from the database of normal forms. Since only the residual
examples.tex(,3442)   // part is saved in the database, we added z^2 to get an E_14
examples.tex(,3443)   // of embedding dimension 3.
examples.tex(,3444)   //
examples.tex(,3445)   // Now we apply a coordinate change in order to deal with a
examples.tex(,3446)   // singularity which is not in normal form:
examples.tex(,3447)   map phi=r,x+y,y+z,x;
examples.tex(,3448)   poly q=phi(p);
examples.tex(,3449)   // Yes, q really looks ugly, now:
examples.tex(,3450)   q;
examples.tex(,3451) @expansion{} x2+x3+3x2y+3xy2+y3+xy6+y7+6xy5z+6y6z+15xy4z2+15y5z2+20xy3z3+20y4z3+15xy2z\
examples.tex(,3452)    4+15y3z4+6xyz5+6y2z5+xz6+yz6+y8+8y7z+28y6z2+56y5z3+70y4z4+56y3z5+28y2z6+8\
examples.tex(,3453)    yz7+z8
examples.tex(,3454)   // Classification
examples.tex(,3455)   classify(q);
examples.tex(,3456) @expansion{} About the singularity :
examples.tex(,3457) @expansion{}           Milnor number(f)   = 14
examples.tex(,3458) @expansion{}           Corank(f)          = 2
examples.tex(,3459) @expansion{}           Determinacy       <= 12
examples.tex(,3460) @expansion{} Guessing type via Milnorcode:   E[6k+2]=E[14]
examples.tex(,3461) @expansion{} 
examples.tex(,3462) @expansion{} Computing normal form ...
examples.tex(,3463) @expansion{} I have to apply the splitting lemma. This will take some time....:-)
examples.tex(,3464) @expansion{}    Arnold step number 9
examples.tex(,3465) @expansion{} The singularity
examples.tex(,3466) @expansion{}    x3-9/4x4+27/4x5-189/8x6+737/8x7+6x6y+15x5y2+20x4y3+15x3y4+6x2y5+xy6-24\
examples.tex(,3467)    089/64x8-x7y+11/2x6y2+26x5y3+95/2x4y4+47x3y5+53/2x2y6+8xy7+y8+104535/64x9\
examples.tex(,3468)    +27x8y+135/2x7y2+90x6y3+135/2x5y4+27x4y5+9/2x3y6-940383/128x10-405/4x9y-2\
examples.tex(,3469)    025/8x8y2-675/2x7y3-2025/8x6y4-405/4x5y5-135/8x4y6+4359015/128x11+1701/4x\
examples.tex(,3470)    10y+8505/8x9y2+2835/2x8y3+8505/8x7y4+1701/4x6y5+567/8x5y6-82812341/512x12\
examples.tex(,3471)    -15333/8x11y-76809/16x10y2-25735/4x9y3-78525/16x8y4-16893/8x7y5-8799/16x6\
examples.tex(,3472)    y6-198x5y7-495/4x4y8-55x3y9-33/2x2y10-3xy11-1/4y12
examples.tex(,3473) @expansion{} is R-equivalent to E[14].
examples.tex(,3474) @expansion{}    Milnor number = 14
examples.tex(,3475) @expansion{}    modality      = 1
examples.tex(,3476) @expansion{} 2z2+x3+xy6+y8
examples.tex(,3477)   // The library also provides routines to determine the corank of q
examples.tex(,3478)   // and its residual part without going through the whole
examples.tex(,3479)   // classification algorithm.
examples.tex(,3480)   corank(q);
examples.tex(,3481) @expansion{} 2
examples.tex(,3482)   morsesplit(q);
examples.tex(,3483) @expansion{} y3-9/4y4+27/4y5-189/8y6+737/8y7+6y6z+15y5z2+20y4z3+15y3z4+6y2z5+yz6-24089\
examples.tex(,3484)    /64y8-y7z+11/2y6z2+26y5z3+95/2y4z4+47y3z5+53/2y2z6+8yz7+z8+104535/64y9+27\
examples.tex(,3485)    y8z+135/2y7z2+90y6z3+135/2y5z4+27y4z5+9/2y3z6-940383/128y10-405/4y9z-2025\
examples.tex(,3486)    /8y8z2-675/2y7z3-2025/8y6z4-405/4y5z5-135/8y4z6+4359015/128y11+1701/4y10z\
examples.tex(,3487)    +8505/8y9z2+2835/2y8z3+8505/8y7z4+1701/4y6z5+567/8y5z6-82812341/512y12-15\
examples.tex(,3488)    333/8y11z-76809/16y10z2-25735/4y9z3-78525/16y8z4-16893/8y7z5-8799/16y6z6-\
examples.tex(,3489)    198y5z7-495/4y4z8-55y3z9-33/2y2z10-3yz11-1/4z12
examples.tex(,3490) @c end example Classification examples.doc:2369
examples.tex(,3491) @end smallexample
examples.tex(,3493) @c ----------------------------------------------------------------------------
examples.tex(,3495) @node Fast lexicographical GB, Parallelization with MPtcp links, Classification, Examples
examples.tex(,3496) @section Fast lexicographical GB
examples.tex(,3497) @cindex Fast lexicographical GB
examples.tex(,3498) 
examples.tex(,3499) Compute Groebner basis in lexicographical ordering
examples.tex(,3500) by using the FGLM algorithm (@code{stdfglm})
examples.tex(,3501) and Hilbert driven Groebner (@code{stdhilb}).
examples.tex(,3502) 
examples.tex(,3503) The command @code{stdfglm} applies only for zero-dimensional ideals and
examples.tex(,3504) returns a reduced Groebner basis.
examples.tex(,3505) 
examples.tex(,3506) For the ideal below, @code{stdfglm} is more than 100 times
examples.tex(,3507) and @code{stdhilb} about 10 times faster than @code{std}.
examples.tex(,3508) 
examples.tex(,3509) @smallexample
examples.tex(,3510) @c computed example Fast_lexicographical_GB examples.doc:2413 
examples.tex(,3511)   ring r =32003,(a,b,c,d,e),lp;
examples.tex(,3512)   ideal i=a+b+c+d, ab+bc+cd+ae+de, abc+bcd+abe+ade+cde,
examples.tex(,3513)           abc+abce+abde+acde+bcde, abcde-1;
examples.tex(,3514)   int t=timer;
examples.tex(,3515)   ideal j1=stdfglm(i);
examples.tex(,3516)   timer-t;
examples.tex(,3517) @expansion{} 0
examples.tex(,3518)   size(j1);   // size (no. of polys) in computed GB
examples.tex(,3519) @expansion{} 5
examples.tex(,3520)   t=timer;
examples.tex(,3521)   ideal j2=stdhilb(i);
examples.tex(,3522)   timer-t;
examples.tex(,3523) @expansion{} 0
examples.tex(,3524)   size(j2);   // size (no. of polys) in computed GB
examples.tex(,3525) @expansion{} 158
examples.tex(,3526)   // usual Groebner basis computation for lex ordering
examples.tex(,3527)   t=timer;
examples.tex(,3528)   ideal j0 =std(i);
examples.tex(,3529)   timer-t;
examples.tex(,3530) @expansion{} 1
examples.tex(,3531) @c end example Fast_lexicographical_GB examples.doc:2413
examples.tex(,3532) @end smallexample
examples.tex(,3534) @c ----------------------------------------------------------------------------
examples.tex(,3536) @node  Parallelization with MPtcp links,  , Fast lexicographical GB, Examples
examples.tex(,3537) @section Parallelization with MPtcp links
examples.tex(,3538) @cindex Parallelization
examples.tex(,3539) @cindex MPtcp
examples.tex(,3540) @cindex link
examples.tex(,3541) In this example, we demonstrate how MPtcp links can be used to
examples.tex(,3542) parallelize computations.
examples.tex(,3543) 
examples.tex(,3544) To compute a standard basis for a zero-dimensional ideal in the
examples.tex(,3545) lexicographical ordering, one of the two powerful routines
examples.tex(,3546) @code{stdhilb}
examples.tex(,3548) (see @ref{stdhilb})
examples.tex(,3550) and @code{stdfglm}
examples.tex(,3552) (see @ref{stdfglm})
examples.tex(,3554) should be used. However, a priory one can not predict
examples.tex(,3555) which one of the two commands is faster. This very much depends on the
examples.tex(,3556) (input) example. Therefore, we use MPtcp links to let both commands
examples.tex(,3557) work on the problem independently and in parallel, so that the one which
examples.tex(,3558) finishes first delivers the result.
examples.tex(,3559) 
examples.tex(,3560) The example we use is the so-called "omdi example". See @i{Tim
examples.tex(,3561) Wichmann; Der FGLM-Algorithmus: verallgemeinert und implementiert in
examples.tex(,3562) Singular; Diplomarbeit Fachbereich Mathematik, Universitaet
examples.tex(,3563) Kaiserslautern; 1997} for more details.
examples.tex(,3564) 
examples.tex(,3565) @smallexample
examples.tex(,3566) @c computed example Parallelization_with_MPtcp_links examples.doc:2464 
examples.tex(,3567) ring r=0,(a,b,c,u,v,w,x,y,z),lp;
examples.tex(,3568) ideal i=a+c+v+2x-1, ab+cu+2vw+2xy+2xz-2/3,  ab2+cu2+2vw2+2xy2+2xz2-2/5,
examples.tex(,3569) ab3+cu3+2vw3+2xy3+2xz3-2/7, ab4+cu4+2vw4+2xy4+2xz4-2/9, vw2+2xyz-1/9,
examples.tex(,3570) vw4+2xy2z2-1/25, vw3+xyz2+xy2z-1/15, vw4+xyz3+xy3z-1/21;
examples.tex(,3571) 
examples.tex(,3572) link l_hilb,l_fglm = "MPtcp:fork","MPtcp:fork";         // 1.
examples.tex(,3573) 
examples.tex(,3574) open(l_fglm); open(l_hilb);
examples.tex(,3575) 
examples.tex(,3576) write(l_hilb, quote(system("pid")));                    // 2.
examples.tex(,3577) write(l_fglm, quote(system("pid")));
examples.tex(,3578) int pid_hilb,pid_fglm = read(l_hilb),read(l_fglm);
examples.tex(,3579) 
examples.tex(,3580) write(l_hilb, quote(stdhilb(i)));                       // 3.
examples.tex(,3581) write(l_fglm, quote(stdfglm(eval(i))));
examples.tex(,3582) 
examples.tex(,3583) while ((! status(l_hilb, "read", "ready", 1)) &&        // 4.
examples.tex(,3584)        (! status(l_fglm, "read", "ready", 1))) @{@}
examples.tex(,3585) 
examples.tex(,3586) if (status(l_hilb, "read", "ready"))
examples.tex(,3587) @{
examples.tex(,3588)   "stdhilb won !!!!"; size(read(l_hilb));
examples.tex(,3589)   close(l_hilb); pid_fglm = system("sh","kill "+string(pid_fglm));
examples.tex(,3590) @}
examples.tex(,3591) else                                                    // 5.
examples.tex(,3592) @{
examples.tex(,3593)   "stdfglm won !!!!"; size(read(l_fglm));
examples.tex(,3594)   close(l_fglm); pid_hilb = system("sh","kill "+string(pid_hilb));
examples.tex(,3595) @}
examples.tex(,3596) @expansion{} stdfglm won !!!!
examples.tex(,3597) @expansion{} 9
examples.tex(,3598) @c end example Parallelization_with_MPtcp_links examples.doc:2464
examples.tex(,3599) @end smallexample
examples.tex(,3600) Some explanatory remarks are in order:
examples.tex(,3601) @enumerate
examples.tex(,3602) @item
examples.tex(,3603) Instead of using links of the type @code{MPtcp:fork}, we alternatively
examples.tex(,3604) could use @code{MPtcp:launch} links such that the two "competing"
examples.tex(,3605) @sc{Singular} processes run on different machines. This has the
examples.tex(,3606) advantage of "true" parallel computing since no resource sharing is
examples.tex(,3607) involved (as it usually is with forked processes).
examples.tex(,3608) 
examples.tex(,3609) @item
examples.tex(,3610) Unfortunately, MPtcp links do not offer means to (asynchronously)
examples.tex(,3611) interrupt or kill an attached (i.e., launched or forked)
examples.tex(,3612) process. Therefore, we explicitly need to get the process id numbers of
examples.tex(,3613) the competing @sc{Singular} processes, so that we can "kill" the
examples.tex(,3614) looser later.
examples.tex(,3615) 
examples.tex(,3616) @item
examples.tex(,3617) Notice how quoting is used in order to prevent local evaluation
examples.tex(,3618) (i.e., local computation of results). Since we "forked" the two
examples.tex(,3619) competing processes, the identifier @code{i} is defined and has
examples.tex(,3620) identical values in both child processes. Therefore, the innermost
examples.tex(,3621) @code{eval} can be omitted (as is done for the @code{l_hilb} link),
examples.tex(,3622) and only the identifier @code{i} needs to be communicated to the
examples.tex(,3623) children. However, when @code{MPtcp:launch} links are used, the inner
examples.tex(,3624) evaluation must be applied so that actual values, and not the
examples.tex(,3625) identifiers are communicated (as is done for the @code{l_fglm} link).
examples.tex(,3626) 
examples.tex(,3627) @item
examples.tex(,3628) We go into a "sleepy" loop and wait until one of the two children
examples.tex(,3629) finished the computation. That is, the current process checks approximately
examples.tex(,3630) once per second the status of one of the connecting links, and sleeps
examples.tex(,3631) (i.e., suspends its execution) in the intermediate time.
examples.tex(,3632) 
examples.tex(,3633) @item
examples.tex(,3634) The child which has won delivers the result and is terminated with the usual
examples.tex(,3635) @code{close} command. The other child which is still computing needs to
examples.tex(,3636) be terminated by an explicit (i.e., system) kill command, since it can
examples.tex(,3637) not be terminated through the link while it is still computing.
examples.tex(,3638) @end enumerate
examples.tex(,3640) 
examples.tex(,3641) @c --------------------------------------------------------------------
singular.texi(,157) 
singular.texi(,158) @c ----------------------------------------------------------------------------
singular.texi(,159) @node Polynomial data,Mathematical background, Examples, Top
singular.texi(,160) @appendix Polynomial data
singular.texi(,161) @cindex Polynomial data
pdata.tex(,1) @comment -*-texinfo-*-
pdata.tex(,2) @comment This file was generated by doc2tex.pl from pdata.doc
pdata.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT pdata.doc INSTEAD
pdata.tex(,4) @comment Id: pdata.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
pdata.tex(,5) @comment this file contains the "Polynomial data" appendix.
pdata.tex(,6) 
pdata.tex(,7) @c The following directives are necessary for proper compilation
pdata.tex(,8) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
pdata.tex(,9) @c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
pdata.tex(,10) @c `makeinfo' but is a great help in editing this file (emacs
pdata.tex(,11) @c ignores the `@ignore').
pdata.tex(,24) 
pdata.tex(,25) @menu
pdata.tex(,26) * Representation of mathematical objects::
pdata.tex(,27) * Monomial orderings::
pdata.tex(,28) @end menu
pdata.tex(,29) 
pdata.tex(,30) @c -----------------------------------------------------------------
pdata.tex(,31) @node Representation of mathematical objects,Monomial orderings,,Polynomial data
pdata.tex(,32) @section Representation of mathematical objects
pdata.tex(,33) @cindex mathematical objects
pdata.tex(,34) @cindex representation, math objects
pdata.tex(,35) 
pdata.tex(,36) @sc{Singular} distinguishes between objects which do not belong to a ring
pdata.tex(,37) and those which belong to a specific ring (see @ref{Rings and orderings}).
pdata.tex(,38) We comment only on the latter ones.
pdata.tex(,39) 
pdata.tex(,40) Internally all ring-dependent objects are polynomials or structures built from
pdata.tex(,41) polynomials (and some additional information).
pdata.tex(,42) Note that @sc{Singular} stores (and hence prints) a polynomial automatically
pdata.tex(,43) w.r.t@:. the monomial ordering.
pdata.tex(,44) 
pdata.tex(,45) Hence, in order to define such an object in @sc{Singular},
pdata.tex(,46) one has to give a list of polynomials in a specific format.
pdata.tex(,47) 
pdata.tex(,48) For ideals, resp.@: matrices, this is straight forward:
pdata.tex(,49) The user gives a list of polynomials
pdata.tex(,50) which generate the ideal, resp.@: which are the entries of the matrix.
pdata.tex(,51) (The number of rows and columns has to be given when creating the matrix.)
pdata.tex(,52) 
pdata.tex(,53) A vector  in @sc{Singular} is always an element of a free module over the
pdata.tex(,54) basering. It is given as a list of polynomials in one of the following
pdata.tex(,55) formats
pdata.tex(,62) denotes the i-th canonical generator of a free module (with 1 at place i and
pdata.tex(,63) 0 everywhere else).
pdata.tex(,64) Both forms are equivalent. A vector is internally represented in
pdata.tex(,65) the second form with the
pdata.tex(,72) being "special" ring variables, ordered accordingly to the monomial ordering.
pdata.tex(,73) Therefore, the form
pdata.tex(,80) is given as output only if the monomial ordering gives priority to the
pdata.tex(,81) component, i.e@:., is of the form @code{(c,...)} (see @ref{Module
pdata.tex(,82) orderings}).  However, in any case the procedure @code{show} from the
pdata.tex(,83) library @code{inout.lib} displays the bracket format.
pdata.tex(,84) 
pdata.tex(,85) A vector
pdata.tex(,92) should always be considered as a column vector in a free module
pdata.tex(,93) of rank equal to
pdata.tex(,100) where 
pdata.tex(,107) is equal to the maximal index 
pdata.tex(,114) such that
pdata.tex(,121) This is due to the fact, that internally 
pdata.tex(,128) is a polynomial in a sparse representation, i.e.,
pdata.tex(,135) is not stored if
pdata.tex(,142) (for reasons of efficiency), hence the last 0-entries of 
pdata.tex(,149) are lost.
pdata.tex(,150) Only more complex structures are able to keep the rank.
pdata.tex(,151) 
pdata.tex(,152) A module 
pdata.tex(,159) in @sc{Singular} is given by a list of vectors
pdata.tex(,166) which generate the module as a submodule of the free module of rank
pdata.tex(,167) equal to 
pdata.tex(,174) which is the maximum of
pdata.tex(,181) 
pdata.tex(,182) If one wants to create a module with a larger rank than given by its
pdata.tex(,183) generators, one has to use the command @code{attrib(M,"rank",r)} (see
pdata.tex(,184) @ref{attrib}, @ref{nrows}) or to define a matrix first, then converting it
pdata.tex(,185) into a module.  Modules in @sc{Singular} are almost the same as
pdata.tex(,186) matrices, they may be considered as sparse representations of matrices.
pdata.tex(,187) A module of a matrix is generated by the columns of the matrix and a
pdata.tex(,188) matrix of a module has as columns the generators of the module.  These
pdata.tex(,189) conversions preserve the rank and the number of generators, resp@:. the
pdata.tex(,190) number of rows and columns.
pdata.tex(,191) 
pdata.tex(,192) By the above remarks it might appear that @sc{Singular} is only able to handle
pdata.tex(,193) submodules of a free module. However, this is not true. @sc{Singular}
pdata.tex(,194) can compute with any finitely generated module over the basering 
pdata.tex(,201) Such a module, say 
pdata.tex(,208) is not represented by its generators but by its
pdata.tex(,209) (generators and) relations. This means that
pdata.tex(,216) is the number of generators of 
pdata.tex(,223) is the module of relations.
pdata.tex(,224) In other words, defining  a module 
pdata.tex(,231) as a submodule of a free module
pdata.tex(,238) can also be considered as the definition of
pdata.tex(,245) 
pdata.tex(,246) Note that most functions, when applied to a module 
pdata.tex(,253) really deal with
pdata.tex(,260) However, there are some functions which deal with 
pdata.tex(,267) 
pdata.tex(,268) For example, @code{std(M)} computes a standard basis of 
pdata.tex(,275) (and thus gives another representation of 
pdata.tex(,282) However, @code{dim(M)}, resp.@: @code{vdim(M)}, returns
pdata.tex(,289) (if M is given by a standard basis).
pdata.tex(,290) 
pdata.tex(,291) The function @code{syz(M)}  returns the first syzygy module of 
pdata.tex(,298) i.e@:., the module 
pdata.tex(,299) of relations of the given generators of 
pdata.tex(,306) which is equal to the second syzygy module of 
pdata.tex(,313) Refer to the description of each function in
pdata.tex(,314) @ref{Functions} to get information which module the function deals with.
pdata.tex(,315) 
pdata.tex(,316) The numbering in @code{res} and other commands for computing resolutions
pdata.tex(,317) refers to a resolution of
pdata.tex(,324) (see @ref{res}; @ref{Syzygies and resolutions}).
pdata.tex(,325) 
pdata.tex(,326) It is possible to compute in any field which is a valid ground field in
pdata.tex(,327) @sc{Singular}.  For doing so, one has to define a ring with the desired
pdata.tex(,328) ground field and at least one variable. The elements of the field are of
pdata.tex(,329) type number, but may also be considered as polynomials (of degree
pdata.tex(,330) 0). Large computations should be faster if the elements of the field are
pdata.tex(,331) defined as numbers.
pdata.tex(,332) 
pdata.tex(,333) The above remarks do also apply to quotient rings. Polynomial data are
pdata.tex(,334) stored internally in the same manner, the only difference is that this
pdata.tex(,335) polynomial representation is in general not unique. @code{reduce(f,std(0))}
pdata.tex(,336) computes a normal form of a polynomial f in a quotient ring (cf.@:
pdata.tex(,337) @ref{reduce}).
pdata.tex(,338) 
pdata.tex(,339) @c -----------------------------------------------------------------
pdata.tex(,340) @node Monomial orderings,,Representation of mathematical objects,Polynomial data
pdata.tex(,341) @section Monomial orderings
pdata.tex(,342) @cindex Monomial orderings
pdata.tex(,343) 
pdata.tex(,344) @menu
pdata.tex(,345) * Introduction to orderings::
pdata.tex(,346) * General definitions for orderings::
pdata.tex(,347) * Global orderings::
pdata.tex(,348) * Local orderings::
pdata.tex(,349) * Module orderings::
pdata.tex(,350) * Matrix orderings::
pdata.tex(,351) * Product orderings::
pdata.tex(,352) * Extra weight vector::
pdata.tex(,353) @end menu
pdata.tex(,354) 
pdata.tex(,355) @c --------------------------------------------------------------------------
pdata.tex(,356) @node Introduction to orderings, General definitions for orderings, , Monomial orderings
pdata.tex(,357) @subsection Introduction to orderings
pdata.tex(,358) @cindex orderings introduction
pdata.tex(,359) @cindex term orderings introduction
pdata.tex(,360) @cindex monomial orderings introduction
pdata.tex(,361) 
pdata.tex(,362) @sc{Singular} offers a great variety of monomial orderings which provide
pdata.tex(,363) an enormous functionality, if used diligently. However, this
pdata.tex(,364) flexibility might also be confusing for the novice user.  Therefore, we
pdata.tex(,365) recommend to those not familiar with monomial orderings to generally use
pdata.tex(,366) the ordering @code{dp} for computations in the polynomial ring
pdata.tex(,373) resp.@:  @code{ds} for computations in the localization 
pdata.tex(,380) 
pdata.tex(,381) For inhomogeneous input ideals,  standard (resp.@: groebner) bases
pdata.tex(,382) computations are generally faster 
pdata.tex(,383) with the orderings 
pdata.tex(,390) (resp.@: 
pdata.tex(,397) if the input is quasihomogeneous w.r.t. the weights 
pdata.tex(,404) 
pdata.tex(,405) If the output needs to be "triangular" (resp.@: "block-triangular"), the
pdata.tex(,406) lexicographical ordering @code{lp} (resp.@: lexicographical
pdata.tex(,407) block-orderings) need to be used. However, these orderings usually
pdata.tex(,408) result in much less efficient computations.
pdata.tex(,409) 
pdata.tex(,410) 
pdata.tex(,411) @c --------------------------------------------------------------------------
pdata.tex(,412) @node General definitions for orderings, Global orderings, Introduction to orderings, Monomial orderings
pdata.tex(,413) @subsection General definitions for orderings
pdata.tex(,414) @cindex orderings
pdata.tex(,415) @cindex term orderings
pdata.tex(,416) @cindex monomial orderings
pdata.tex(,417) 
pdata.tex(,439)  See the literature cited in @ref{References}.
pdata.tex(,441) 
pdata.tex(,442) It is known that any monomial ordering can be represented by a matrix 
pdata.tex(,449) but, of course, only integer coefficients are of relevance in
pdata.tex(,450) practice.
pdata.tex(,451) 
pdata.tex(,480) 
pdata.tex(,481) Note that the definition of a ring includes the definition of its
pdata.tex(,482) monomial ordering (see 
pdata.tex(,483) @ref{Rings and orderings}). @sc{Singular} offers the monomial orderings
pdata.tex(,484) described in the following sections. 
pdata.tex(,485) 
pdata.tex(,486) 
pdata.tex(,487) @c --------------------------------------------------------------------------
pdata.tex(,488) @node Global orderings, Local orderings, General definitions for orderings, Monomial orderings
pdata.tex(,489) @subsection Global orderings
pdata.tex(,490) @cindex Global orderings
pdata.tex(,491) @cindex orderings, global
pdata.tex(,492) 
pdata.tex(,499) 
pdata.tex(,500) @table @asis
pdata.tex(,501) @item lp:
pdata.tex(,502) lexicographical ordering:
pdata.tex(,503) @cindex lp, global ordering
pdata.tex(,504) @cindex lexicographical ordering
pdata.tex(,505) @*
pdata.tex(,515) @item rp:
pdata.tex(,516) reverse lexicographical ordering:
pdata.tex(,517) @cindex rp, global ordering
pdata.tex(,518) @cindex reverse lexicographical ordering
pdata.tex(,519) @*
pdata.tex(,529) @item dp:
pdata.tex(,530) degree reverse lexicographical ordering:
pdata.tex(,531) @cindex degree reverse lexicographical ordering
pdata.tex(,532) @cindex dp, global ordering
pdata.tex(,533) @*
pdata.tex(,558) @item Dp:
pdata.tex(,559) degree lexicographical ordering:
pdata.tex(,560) @cindex degree lexicographical ordering
pdata.tex(,561) @cindex Dp, global ordering
pdata.tex(,562) @*
pdata.tex(,587) @item wp:
pdata.tex(,588) weighted reverse lexicographical ordering:
pdata.tex(,589) @cindex weighted reverse lexicographical ordering
pdata.tex(,590) @cindex wp, global ordering
pdata.tex(,591) @*
pdata.tex(,599)  is defined as @code{dp}
pdata.tex(,600)  but with
pdata.tex(,607) @item Wp:
pdata.tex(,608) weighted lexicographical ordering:
pdata.tex(,609) @cindex weighted lexicographical ordering
pdata.tex(,610) @cindex WP, global ordering
pdata.tex(,611) @*
pdata.tex(,619)  is defined as @code{Dp}
pdata.tex(,620)  but with
pdata.tex(,627) @end table
pdata.tex(,628) @c --------------------------------------------------------------------------
pdata.tex(,629) @node Local orderings, Module orderings, Global orderings, Monomial orderings
pdata.tex(,630) @subsection Local orderings
pdata.tex(,631) @cindex Local orderings
pdata.tex(,632) @cindex orderings, local
pdata.tex(,633) 
pdata.tex(,634) For ls, ds, Ds and, if the weights are positive integers, also for ws and
pdata.tex(,635) Ws,  we have
pdata.tex(,642)  the localization of 
pdata.tex(,649) at the maximal ideal
pdata.tex(,656) 
pdata.tex(,657) @table @asis
pdata.tex(,658) @item ls:
pdata.tex(,659) negative lexicographical ordering:
pdata.tex(,660) @cindex negative lexicographical ordering
pdata.tex(,661) @cindex ls, local ordering
pdata.tex(,662) @*
pdata.tex(,672) @item ds:
pdata.tex(,673) negative degree reverse lexicographical ordering:
pdata.tex(,674) @cindex negative degree reverse lexicographical ordering
pdata.tex(,675) @cindex ds, local ordering
pdata.tex(,676) @*
pdata.tex(,701) @item Ds:
pdata.tex(,702) negative degree lexicographical ordering:
pdata.tex(,703) @cindex negative degree lexicographical ordering
pdata.tex(,704) @cindex Ds, local ordering
pdata.tex(,705) @*
pdata.tex(,730) @item ws:
pdata.tex(,731) (general) weighted reverse lexicographical ordering:
pdata.tex(,732) @cindex general weighted reverse lexicographical ordering
pdata.tex(,733) @cindex local weighted reverse lexicographical ordering
pdata.tex(,734) @cindex ws, local ordering
pdata.tex(,735) @*
pdata.tex(,742)  a nonzero integer,
pdata.tex(,749)  any integer (including 0),
pdata.tex(,750)  is defined as @code{ds}
pdata.tex(,751)  but with
pdata.tex(,758) @item Ws:
pdata.tex(,759) (general) weighted lexicographical ordering:
pdata.tex(,760) @cindex general weighted lexicographical ordering
pdata.tex(,761) @cindex local weighted lexicographical ordering
pdata.tex(,762) @cindex Ws, local ordering
pdata.tex(,763) @*
pdata.tex(,770)  a nonzero integer,
pdata.tex(,777)  any integer (including 0),
pdata.tex(,778)  is defined as @code{Ds}
pdata.tex(,779)  but with
pdata.tex(,786) @end table
pdata.tex(,787) 
pdata.tex(,788) @c --------------------------------------------------------------------------
pdata.tex(,789) @node Module orderings, Matrix orderings, Local orderings, Monomial orderings
pdata.tex(,790) @subsection Module orderings
pdata.tex(,791) @cindex Module orderings
pdata.tex(,792) 
pdata.tex(,793) @sc{Singular} offers also orderings on the set of ``monomials''
pdata.tex(,806) 
pdata.tex(,807) We have two possibilities: either to give priority to the component of a
pdata.tex(,808) vector in 
pdata.tex(,815) or (which is the default in @sc{Singular}) to give priority
pdata.tex(,816) to the coefficients.
pdata.tex(,817) The orderings @code{(<,c)} and @code{(<,C)} give priority to the
pdata.tex(,818) coefficients; whereas
pdata.tex(,819) @code{(c,<)} and @code{(C,<)} give priority to the components.
pdata.tex(,820) @*Let < be any of the monomial orderings of 
pdata.tex(,827) as above.
pdata.tex(,828) 
pdata.tex(,829) @table @asis
pdata.tex(,830) @item (<,C):
pdata.tex(,831) @cindex C, module ordering
pdata.tex(,832) @cindex module ordering C
pdata.tex(,843) @*
pdata.tex(,848) 
pdata.tex(,849) @strong{Example:}
pdata.tex(,850) @smallexample
pdata.tex(,851) @c computed example Module_orderings pdata.doc:849 
pdata.tex(,852)   ring r = 0, (x,y,z), ds;
pdata.tex(,853)   // the same as ring r = 0, (x,y,z), (ds, C);
pdata.tex(,854)   [x+y2,z3+xy];
pdata.tex(,855) @expansion{} x*gen(1)+xy*gen(2)+y2*gen(1)+z3*gen(2)
pdata.tex(,856)   [x,x,x];
pdata.tex(,857) @expansion{} x*gen(3)+x*gen(2)+x*gen(1)
pdata.tex(,858) @c end example Module_orderings pdata.doc:849
pdata.tex(,859) @end smallexample
pdata.tex(,860) 
pdata.tex(,861) @item (C,<):
pdata.tex(,880) 
pdata.tex(,881) @strong{Example:}
pdata.tex(,882) @smallexample
pdata.tex(,883) @c computed example Module_orderings_1 pdata.doc:879 
pdata.tex(,884)   ring r = 0, (x,y,z), (C,lp);
pdata.tex(,885)   [x+y2,z3+xy];
pdata.tex(,886) @expansion{} xy*gen(2)+z3*gen(2)+x*gen(1)+y2*gen(1)
pdata.tex(,887)   [x,x,x];
pdata.tex(,888) @expansion{} x*gen(3)+x*gen(2)+x*gen(1)
pdata.tex(,889) @c end example Module_orderings_1 pdata.doc:879
pdata.tex(,890) @end smallexample
pdata.tex(,891) 
pdata.tex(,892) @item (<,c):
pdata.tex(,893) @cindex c, module ordering
pdata.tex(,894) @cindex module ordering c
pdata.tex(,912) 
pdata.tex(,913) @strong{Example:}
pdata.tex(,914) @smallexample
pdata.tex(,915) @c computed example Module_orderings_2 pdata.doc:909 
pdata.tex(,916)   ring r = 0, (x,y,z), (lp,c);
pdata.tex(,917)   [x+y2,z3+xy];
pdata.tex(,918) @expansion{} xy*gen(2)+x*gen(1)+y2*gen(1)+z3*gen(2)
pdata.tex(,919)   [x,x,x];
pdata.tex(,920) @expansion{} x*gen(1)+x*gen(2)+x*gen(3)
pdata.tex(,921) @c end example Module_orderings_2 pdata.doc:909
pdata.tex(,922) @end smallexample
pdata.tex(,923) 
pdata.tex(,924) @item (c,<):
pdata.tex(,943) 
pdata.tex(,944) @strong{Example:}
pdata.tex(,945) @smallexample
pdata.tex(,946) @c computed example Module_orderings_3 pdata.doc:938 
pdata.tex(,947)   ring r = 0, (x,y,z), (c,lp);
pdata.tex(,948)   [x+y2,z3+xy];
pdata.tex(,949) @expansion{} [x+y2,xy+z3]
pdata.tex(,950)   [x,x,x];
pdata.tex(,951) @expansion{} [x,x,x]
pdata.tex(,952) @c end example Module_orderings_3 pdata.doc:938
pdata.tex(,953) @end smallexample
pdata.tex(,954) @end table
pdata.tex(,955) 
pdata.tex(,964) (up to permutation) unless the ordering starts with @code{c}.
pdata.tex(,971) In all cases @sc{Singular} can read input in both formats.
pdata.tex(,972) 
pdata.tex(,973) @c --------------------------------------------------------------------------
pdata.tex(,974) @node Matrix orderings, Product orderings, Module orderings, Monomial orderings
pdata.tex(,975) @subsection Matrix orderings
pdata.tex(,976) @cindex Matrix orderings
pdata.tex(,977) @cindex orderings, M
pdata.tex(,978) @cindex M, ordering
pdata.tex(,979) 
pdata.tex(,980) Let 
pdata.tex(,987) be an invertible 
pdata.tex(,994)  with integer coefficients and
pdata.tex(,1001) 
pdata.tex(,1002) The M-ordering < is defined as follows:
pdata.tex(,1003) @*
pdata.tex(,1012) 
pdata.tex(,1013) Thus,
pdata.tex(,1022) with respect to the lexicographical ordering.
pdata.tex(,1023) 
pdata.tex(,1024) The following matrices represent (for 3 variables) the global and
pdata.tex(,1025) local orderings defined above (note that the matrix is not uniquely determined
pdata.tex(,1026) by the ordering):
pdata.tex(,1027) 
pdata.tex(,1138) 
pdata.tex(,1139) Product orderings (see next section) represented by  a matrix:
pdata.tex(,1140) 
pdata.tex(,1180) 
pdata.tex(,1181) Orderings with extra weight vector (see below) represented by  a matrix:
pdata.tex(,1182) 
pdata.tex(,1226) 
pdata.tex(,1227) @*@strong{Example}:
pdata.tex(,1228) @smallexample
pdata.tex(,1229) @c computed example Matrix_orderings pdata.doc:1219 
pdata.tex(,1230)   ring r = 0, (x,y,z), M(1, 0, 0,   0, 1, 0,   0, 0, 1);
pdata.tex(,1231) @c end example Matrix_orderings pdata.doc:1219
pdata.tex(,1232) @end smallexample
pdata.tex(,1233) @*which may also be written as:
pdata.tex(,1234) @smallexample
pdata.tex(,1235) @c computed example Matrix_orderings_1 pdata.doc:1225 
pdata.tex(,1236)   intmat m[3][3]=1, 0, 0, 0, 1, 0, 0, 0, 1;
pdata.tex(,1237)   m;
pdata.tex(,1238) @expansion{} 1,0,0,
pdata.tex(,1239) @expansion{} 0,1,0,
pdata.tex(,1240) @expansion{} 0,0,1 
pdata.tex(,1241)   ring r = 0, (x,y,z), M(m);
pdata.tex(,1242)   r;
pdata.tex(,1243) @expansion{} //   characteristic : 0
pdata.tex(,1244) @expansion{} //   number of vars : 3
pdata.tex(,1245) @expansion{} //        block   1 : ordering M
pdata.tex(,1246) @expansion{} //                  : names    x y z 
pdata.tex(,1247) @expansion{} //                  : weights  1 0 0 
pdata.tex(,1248) @expansion{} //                  : weights  0 1 0 
pdata.tex(,1249) @expansion{} //                  : weights  0 0 1 
pdata.tex(,1250) @expansion{} //        block   2 : ordering C
pdata.tex(,1251) @c end example Matrix_orderings_1 pdata.doc:1225
pdata.tex(,1252) @end smallexample
pdata.tex(,1253) 
pdata.tex(,1254) If the ring has 
pdata.tex(,1261) variables and the matrix contains less than 
pdata.tex(,1268) entries an error message is given, if there are more entries,
pdata.tex(,1269) the last ones are ignored.
pdata.tex(,1270) 
pdata.tex(,1271) @strong{WARNING:} @sc{Singular}
pdata.tex(,1272) does not check whether the matrix has full rank.   In such a case some
pdata.tex(,1273) computations might not terminate, others might give a nonsense result.
pdata.tex(,1274) 
pdata.tex(,1275) Having these matrix orderings @sc{Singular} can compute standard bases for
pdata.tex(,1276) any monomial ordering which is compatible with the natural semigroup structure.
pdata.tex(,1277) In practice the global and local orderings together with block orderings should be
pdata.tex(,1278) sufficient in most cases. These orderings are faster than the corresponding
pdata.tex(,1279) matrix orderings, since evaluating a matrix product is time consuming.
pdata.tex(,1280) 
pdata.tex(,1281) @c --------------------------------------------------------------------------
pdata.tex(,1282) @node Product orderings, Extra weight vector, Matrix orderings, Monomial orderings
pdata.tex(,1283) @subsection Product orderings
pdata.tex(,1284) @cindex Product orderings
pdata.tex(,1285) @cindex orderings, product
pdata.tex(,1286) 
pdata.tex(,1287) Let
pdata.tex(,1295) be two ordered sets of variables,
pdata.tex(,1317) 
pdata.tex(,1318) Inductively one defines the product ordering of more than two monomial
pdata.tex(,1319) orderings.
pdata.tex(,1320) 
pdata.tex(,1321) In @sc{Singular}, any of the above global orderings, local orderings or matrix
pdata.tex(,1322) orderings may be combined (in an arbitrary manner and length) to a product
pdata.tex(,1323) ordering.   E.g., @code{(lp(3), M(1, 2, 3, 1, 1, 1, 1, 0, 0), ds(4),
pdata.tex(,1324) ws(1,2,3))} 
pdata.tex(,1325) defines: @code{lp} on the first 3 variables, the matrix ordering
pdata.tex(,1326) @code{M(1, 2, 3, 1, 1, 1, 1, 0, 0)} on the next 3 variables,
pdata.tex(,1327) @code{ds} on the next 4 variables and
pdata.tex(,1328) @code{ws(1,2,3)} on the last 3 variables.
pdata.tex(,1329) 
pdata.tex(,1330) @c --------------------------------------------------------------
pdata.tex(,1331) @node Extra weight vector,  , Product orderings, Monomial orderings
pdata.tex(,1332) @subsection Extra weight vector
pdata.tex(,1333) @cindex Extra weight vector
pdata.tex(,1334) @cindex a, ordering
pdata.tex(,1335) @cindex orderings, a 
pdata.tex(,1336) 
pdata.tex(,1349) any integers (including 0), defines
pdata.tex(,1356) and
pdata.tex(,1357) @*
pdata.tex(,1371) @*An extra weight vector does not define a monomial ordering by itself:
pdata.tex(,1372) it can only be used in combination with other orderings
pdata.tex(,1373) to insert an extra line of weights into the ordering
pdata.tex(,1374) matrix.
pdata.tex(,1375) 
pdata.tex(,1376) @*@strong{Example}:
pdata.tex(,1377) @smallexample
pdata.tex(,1378) ring r = 0, (x,y,z),  (a(1,2,3),wp(4,5,2));
pdata.tex(,1379) ring s = 0, (x,y,z),  (a(1,2,3),dp);
pdata.tex(,1380) ring q = 0, (a,b,c,d),(lp(1),a(1,2,3),ds);
pdata.tex(,1381) @end smallexample
singular.texi(,163) 
singular.texi(,164) @c ----------------------------------------------------------------------------
singular.texi(,165) @node Mathematical background, SINGULAR libraries, Polynomial data, Top
singular.texi(,166) @appendix Mathematical background
singular.texi(,167) @cindex Mathematical background
math.tex(,1) @comment -*-texinfo-*-
math.tex(,2) @comment This file was generated by doc2tex.pl from math.doc
math.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT math.doc INSTEAD
math.tex(,4) @comment Id: math.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
math.tex(,5) @comment this file contains the mathematical background of Singular
math.tex(,6) 
math.tex(,7) @c The following directives are necessary for proper compilation
math.tex(,8) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
math.tex(,9) @c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
math.tex(,10) @c `makeinfo' but is a great help in editing this file (emacs
math.tex(,11) @c ignores the `@ignore').
math.tex(,24) 
math.tex(,25) This chapter introduces some of the mathematical notions and definitions used
math.tex(,26) throughout the manual. It is mostly a collection of the
math.tex(,27) most prominent definitions and properties. For details, please, refer to
math.tex(,28) some articles or text books (see @ref{References}).
math.tex(,29) 
math.tex(,30) @menu
math.tex(,31) * Standard bases::
math.tex(,32) * Hilbert function::
math.tex(,33) * Syzygies and resolutions::
math.tex(,34) * Characteristic sets::
math.tex(,35) * Gauss-Manin connection::
math.tex(,36) * Toric ideals and integer programming::
math.tex(,37) * References::
math.tex(,38) @end menu
math.tex(,39) @c ---------------------------------------------------------------------------
math.tex(,40) @node Standard bases, Hilbert function, ,Mathematical background
math.tex(,41) @section Standard bases
math.tex(,42) @cindex Standard bases
math.tex(,43) 
math.tex(,44) @subheading Definition
math.tex(,60) 
math.tex(,61) @subheading Properties
math.tex(,62) @table @asis
math.tex(,63) @item normal form:
math.tex(,64) @cindex Normal form
math.tex(,84) @item ideal membership:
math.tex(,85) @cindex Ideal membership
math.tex(,94) @item Hilbert function:
math.tex(,106) @end table
math.tex(,107) 
math.tex(,108) @c ---------------------------------------------------------------------------
math.tex(,109) @node Hilbert function, Syzygies and resolutions, Standard bases, Mathematical background
math.tex(,110) @section Hilbert function
math.tex(,111) @cindex Hilbert function
math.tex(,112) @cindex Hilbert series
math.tex(,156) @*
math.tex(,157) @*
math.tex(,172) 
math.tex(,173) @c ---------------------------------------------------------------------------
math.tex(,174) @node Syzygies and resolutions, Characteristic sets, Hilbert function, Mathematical background
math.tex(,175) @section Syzygies and resolutions
math.tex(,176) @cindex Syzygies and resolutions
math.tex(,177) 
math.tex(,178) @subheading Syzygies
math.tex(,192) 
math.tex(,193) The @strong{k-th syzygy module} is defined inductively to be the module
math.tex(,194) of syzygies of the
math.tex(,201)  syzygy module.
math.tex(,202) 
math.tex(,211) 
math.tex(,212) @table @code
math.tex(,213) @item @strong{Example:}
math.tex(,214) @smallexample
math.tex(,215) @c reused example Syzygies math.doc:213 
math.tex(,216)   ring R= 0,(u,v,x,y,z),dp;
math.tex(,217)   ideal i=ux, vx, uy, vy;
math.tex(,218)   print(syz(i));
math.tex(,219) @expansion{} -y,0, -v,0, 
math.tex(,220) @expansion{} 0, -y,u, 0, 
math.tex(,221) @expansion{} x, 0, 0, -v,
math.tex(,222) @expansion{} 0, x, 0, u  
math.tex(,223) @c end example Syzygies math.doc:213
math.tex(,224) @end smallexample
math.tex(,225) @end table
math.tex(,226) 
math.tex(,227) @subheading Free resolutions
math.tex(,242) @*where the columns of the matrix
math.tex(,249) generate 
math.tex(,256) . Note, that resolutions need not to be finite (i.e., of
math.tex(,257) finite length). The Hilbert Syzygy Theorem states, that for 
math.tex(,264) there exists a ("minimal") resolution of length not exceeding the number of
math.tex(,265) variables.
math.tex(,266) 
math.tex(,267) @table @code
math.tex(,268) @item @strong{Example:}
math.tex(,269) @smallexample
math.tex(,270) @c reused example Free_resolutions math.doc:257 
math.tex(,271)   ring R= 0,(u,v,x,y,z),dp;
math.tex(,272)   ideal I = ux, vx, uy, vy;
math.tex(,273)   resolution resI = mres(I,0); resI;
math.tex(,274) @expansion{}  1      4      4      1      
math.tex(,275) @expansion{} R <--  R <--  R <--  R
math.tex(,276) @expansion{} 
math.tex(,277) @expansion{} 0      1      2      3      
math.tex(,278) @expansion{} 
math.tex(,279)   // The matrix A_1 is given by
math.tex(,280)   print(matrix(resI[1]));
math.tex(,281) @expansion{} vy,uy,vx,ux
math.tex(,282)   // We see that the columns of A_1 generate I.
math.tex(,283)   // The matrix A_2 is given by
math.tex(,284)   print(matrix(resI[3]));
math.tex(,285) @expansion{} u, 
math.tex(,286) @expansion{} -v,
math.tex(,287) @expansion{} -x,
math.tex(,288) @expansion{} y  
math.tex(,289) @c end example Free_resolutions math.doc:257
math.tex(,290) @end smallexample
math.tex(,291) @end table
math.tex(,292) 
math.tex(,293) @subheading Betti numbers and regularity
math.tex(,294) @cindex Betti number
math.tex(,295) @cindex regularity
math.tex(,325) 
math.tex(,326) The @strong{regularity} of 
math.tex(,333)  is the smallest integer 
math.tex(,340) 
math.tex(,341) such that
math.tex(,352) 
math.tex(,353) @table @code
math.tex(,354) @item @strong{Example:}
math.tex(,355) @smallexample
math.tex(,356) @c reused example Betti_numbers_and_regularity math.doc:319 
math.tex(,357)   ring R= 0,(u,v,x,y,z),dp;
math.tex(,358)   ideal I = ux, vx, uy, vy;
math.tex(,359)   resolution resI = mres(I,0); resI;
math.tex(,360) @expansion{}  1      4      4      1      
math.tex(,361) @expansion{} R <--  R <--  R <--  R
math.tex(,362) @expansion{} 
math.tex(,363) @expansion{} 0      1      2      3      
math.tex(,364) @expansion{} 
math.tex(,365)   // the betti number:
math.tex(,366)   print(betti(resI), "betti");
math.tex(,367) @expansion{}            0     1     2     3
math.tex(,368) @expansion{} ------------------------------
math.tex(,369) @expansion{}     0:     1     -     -     -
math.tex(,370) @expansion{}     1:     -     4     4     1
math.tex(,371) @expansion{} ------------------------------
math.tex(,372) @expansion{} total:     1     4     4     1
math.tex(,373)   // the regularity:
math.tex(,374)   regularity(resI);
math.tex(,375) @expansion{} 2
math.tex(,376) @c end example Betti_numbers_and_regularity math.doc:319
math.tex(,377) @end smallexample
math.tex(,378) @end table
math.tex(,379) @c ---------------------------------------------------------------------------
math.tex(,380) @node Characteristic sets, Gauss-Manin connection, Syzygies and resolutions, Mathematical background
math.tex(,381) @section Characteristic sets
math.tex(,382) @cindex Characteristic sets
math.tex(,383) 
math.tex(,456) 
math.tex(,457) @table @code
math.tex(,458) @item @strong{Example:}
math.tex(,459) @smallexample
math.tex(,460) @c reused example Characteristic_sets math.doc:411 
math.tex(,461)   ring R= 0,(x,y,z,u),dp;
math.tex(,462)   ideal i=-3zu+y2-2x+2,
math.tex(,463)           -3x2u-4yz-6xz+2y2+3xy,
math.tex(,464)           -3z2u-xu+y2z+y;
math.tex(,465)   print(char_series(i));
math.tex(,466) @expansion{} _[1,1],3x2z-y2+2yz,3x2u-3xy-2y2+2yu,
math.tex(,467) @expansion{} x,     -y+2z,      -2y2+3yu-4       
math.tex(,468) @c end example Characteristic_sets math.doc:411
math.tex(,469) @end smallexample
math.tex(,470) @end table
math.tex(,471) @c ---------------------------------------------------------------------------
math.tex(,472) @node Gauss-Manin connection, Toric ideals and integer programming, Characteristic sets, Mathematical background
math.tex(,473) @section Gauss-Manin connection
math.tex(,474) @cindex Gauss-Manin connection
math.tex(,475) 
math.tex(,476) @c the following text contain too much math code, so there are
math.tex(,477) @c tex and info versions of it. It end just before the introducing text
math.tex(,478) @c to the first example.
math.tex(,479) 
math.tex(,512) 
math.tex(,545) 
math.tex(,546) Let us consider as an example 
math.tex(,553) .
math.tex(,554) First, we compute a matrix 
math.tex(,561)  such that
math.tex(,568) is a monodromy matrix of 
math.tex(,575)  and the Jordan normal form of 
math.tex(,582) :
math.tex(,583) @smallexample
math.tex(,584) @c reused example Gauss-Manin_connection math.doc:505 
math.tex(,585)   LIB "gaussman.lib";
math.tex(,586)   ring R=0,(x,y),ds;
math.tex(,587)   poly f=x5+x2y2+y5;
math.tex(,588)   list l=monodromy(f);
math.tex(,589)   matrix M=jordanmatrix(l[1],l[2],l[3]);
math.tex(,590)   print(M);
math.tex(,591) @expansion{} 1/2,0,  0,   0,   0,   0,   0,0,    0,    0,    0,   
math.tex(,592) @expansion{} 1,  1/2,0,   0,   0,   0,   0,0,    0,    0,    0,   
math.tex(,593) @expansion{} 0,  0,  7/10,0,   0,   0,   0,0,    0,    0,    0,   
math.tex(,594) @expansion{} 0,  0,  0,   7/10,0,   0,   0,0,    0,    0,    0,   
math.tex(,595) @expansion{} 0,  0,  0,   0,   9/10,0,   0,0,    0,    0,    0,   
math.tex(,596) @expansion{} 0,  0,  0,   0,   0,   9/10,0,0,    0,    0,    0,   
math.tex(,597) @expansion{} 0,  0,  0,   0,   0,   0,   1,0,    0,    0,    0,   
math.tex(,598) @expansion{} 0,  0,  0,   0,   0,   0,   0,11/10,0,    0,    0,   
math.tex(,599) @expansion{} 0,  0,  0,   0,   0,   0,   0,0,    11/10,0,    0,   
math.tex(,600) @expansion{} 0,  0,  0,   0,   0,   0,   0,0,    0,    13/10,0,   
math.tex(,601) @expansion{} 0,  0,  0,   0,   0,   0,   0,0,    0,    0,    13/10
math.tex(,602) @c end example Gauss-Manin_connection math.doc:505
math.tex(,603) @end smallexample
math.tex(,604) 
math.tex(,605) Now, we compute the V-filtration on 
math.tex(,612)  and the spectrum:
math.tex(,613) @smallexample
math.tex(,614) @c reused example Gauss-Manin_connection_1 math.doc:517 
math.tex(,615)   LIB "gaussman.lib";
math.tex(,616)   ring R=0,(x,y),ds;
math.tex(,617)   poly f=x5+x2y2+y5;
math.tex(,618)   list l=vfilt(f);
math.tex(,619)   print(l[1]);
math.tex(,620) @expansion{} -1/2,
math.tex(,621) @expansion{} -3/10,
math.tex(,622) @expansion{} -1/10,
math.tex(,623) @expansion{} 0,
math.tex(,624) @expansion{} 1/10,
math.tex(,625) @expansion{} 3/10,
math.tex(,626) @expansion{} 1/2
math.tex(,627)   print(l[2]);
math.tex(,628) @expansion{} 1,2,2,1,2,2,1
math.tex(,629)   print(l[3]);
math.tex(,630) @expansion{} [1]:
math.tex(,631) @expansion{}    _[1]=gen(11)
math.tex(,632) @expansion{} [2]:
math.tex(,633) @expansion{}    _[1]=gen(10)
math.tex(,634) @expansion{}    _[2]=gen(6)
math.tex(,635) @expansion{} [3]:
math.tex(,636) @expansion{}    _[1]=gen(9)
math.tex(,637) @expansion{}    _[2]=gen(4)
math.tex(,638) @expansion{} [4]:
math.tex(,639) @expansion{}    _[1]=gen(5)
math.tex(,640) @expansion{} [5]:
math.tex(,641) @expansion{}    _[1]=gen(3)
math.tex(,642) @expansion{}    _[2]=gen(8)
math.tex(,643) @expansion{} [6]:
math.tex(,644) @expansion{}    _[1]=gen(2)
math.tex(,645) @expansion{}    _[2]=gen(7)
math.tex(,646) @expansion{} [7]:
math.tex(,647) @expansion{}    _[1]=gen(1)
math.tex(,648)   print(l[4]);
math.tex(,649) @expansion{} y5,
math.tex(,650) @expansion{} y4,
math.tex(,651) @expansion{} y3,
math.tex(,652) @expansion{} y2,
math.tex(,653) @expansion{} xy,
math.tex(,654) @expansion{} y,
math.tex(,655) @expansion{} x4,
math.tex(,656) @expansion{} x3,
math.tex(,657) @expansion{} x2,
math.tex(,658) @expansion{} x,
math.tex(,659) @expansion{} 1
math.tex(,660) @c end example Gauss-Manin_connection_1 math.doc:517
math.tex(,661) @end smallexample
math.tex(,662) Here @code{l[1]} contains the spectral numbers, @code{l[2]} the corresponding multiplicities, @code{l[3]} a 
math.tex(,669) -basis of the V-filtration on 
math.tex(,676)  in terms of the monomial basis of
math.tex(,683) in @code{l[4]}.
math.tex(,684) 
math.tex(,689) 
math.tex(,694) 
math.tex(,695) Let us calculate one specific example, the maximal number 
math.tex(,696) of triple points of type
math.tex(,703) of degree seven.
math.tex(,704) This calculation can be done over the rationals.
math.tex(,705) So choose a local ordering on 
math.tex(,712) . Here we take the
math.tex(,713) negative degree lexicographical ordering which is denoted
math.tex(,714) @code{ds} in @sc{Singular}:
math.tex(,715) 
math.tex(,716) @smallexample
math.tex(,717) @c reused example Gauss-Manin_connection_2 math.doc:562 
math.tex(,718) ring r=0,(x,y,z),ds;
math.tex(,719) LIB "spectrum.lib";
math.tex(,720) poly f=x^7+y^7+z^7;
math.tex(,721) list s1=spectrumnd( f );
math.tex(,722) s1;
math.tex(,723) @expansion{} [1]:
math.tex(,724) @expansion{}    _[1]=-4/7
math.tex(,725) @expansion{}    _[2]=-3/7
math.tex(,726) @expansion{}    _[3]=-2/7
math.tex(,727) @expansion{}    _[4]=-1/7
math.tex(,728) @expansion{}    _[5]=0
math.tex(,729) @expansion{}    _[6]=1/7
math.tex(,730) @expansion{}    _[7]=2/7
math.tex(,731) @expansion{}    _[8]=3/7
math.tex(,732) @expansion{}    _[9]=4/7
math.tex(,733) @expansion{}    _[10]=5/7
math.tex(,734) @expansion{}    _[11]=6/7
math.tex(,735) @expansion{}    _[12]=1
math.tex(,736) @expansion{}    _[13]=8/7
math.tex(,737) @expansion{}    _[14]=9/7
math.tex(,738) @expansion{}    _[15]=10/7
math.tex(,739) @expansion{}    _[16]=11/7
math.tex(,740) @expansion{} [2]:
math.tex(,741) @expansion{}    1,3,6,10,15,21,25,27,27,25,21,15,10,6,3,1
math.tex(,742) @c end example Gauss-Manin_connection_2 math.doc:562
math.tex(,743) @end smallexample
math.tex(,744) 
math.tex(,745) The command @code{spectrumnd(f)} computes the spectrum of 
math.tex(,752)  and
math.tex(,753) returns a list with six entries:
math.tex(,754) The Milnor number
math.tex(,761) and the number of different spectrum numbers.
math.tex(,762) The other three entries are of type @code{intvec}.
math.tex(,763) They contain the numerators, denominators and
math.tex(,764) multiplicities of the spectrum numbers. So
math.tex(,771) has Milnor number 216 and geometrical
math.tex(,772) genus 35. Its spectrum consists of the 16 different rationals
math.tex(,773) @*
math.tex(,784) @*appearing with multiplicities
math.tex(,785) @*1,3,6,10,15,21,25,27,27,25,21,15,10,6,3,1.
math.tex(,786) 
math.tex(,797) Therefore they have all the same spectrum, which we compute
math.tex(,798) for 
math.tex(,805) 
math.tex(,806) @smallexample
math.tex(,807) poly g=x^3+y^3+z^3;
math.tex(,808) list s2=spectrumnd(g);
math.tex(,809) s2;
math.tex(,810) @expansion{} [1]:
math.tex(,811) @expansion{}    8
math.tex(,812) @expansion{} [2]:
math.tex(,813) @expansion{}    1
math.tex(,814) @expansion{} [3]:
math.tex(,815) @expansion{}    4
math.tex(,816) @expansion{} [4]:
math.tex(,817) @expansion{}    1,4,5,2
math.tex(,818) @expansion{} [5]:
math.tex(,819) @expansion{}    1,3,3,1
math.tex(,820) @expansion{} [6]:
math.tex(,821) @expansion{}    1,3,3,1
math.tex(,822) @end smallexample
math.tex(,823) Evaluating semicontinuity is very easy:
math.tex(,824) @smallexample
math.tex(,825) semicont(s1,s2);
math.tex(,826) @expansion{} 18
math.tex(,827) @end smallexample
math.tex(,828) 
math.tex(,829) This tells us that there are at most 18 singularities of type
math.tex(,836) is semiquasihomogeneous (sqh), so we can also apply the stronger
math.tex(,837) form of semicontinuity:
math.tex(,838) 
math.tex(,839) @smallexample
math.tex(,840) semicontsqh(s1,s2);
math.tex(,841) @expansion{} 17
math.tex(,842) @end smallexample
math.tex(,843) 
math.tex(,844) So in fact a septic has at most 17 triple points of type
math.tex(,851) 
math.tex(,852) Note that @code{spectrumnd(f)} works only if 
math.tex(,859)  has nondegenerate
math.tex(,860) principal part. In fact @code{spectrumnd} will detect a degenerate
math.tex(,861) principal part in many cases and print out an error message.
math.tex(,862) However if it is known in advance that 
math.tex(,869)  has nondegenerate
math.tex(,870) principal part, then the spectrum may be computed much faster
math.tex(,871) using @code{spectrumnd(f,1)}.
math.tex(,872) 
math.tex(,873) @c ---------------------------------------------------------------------------
math.tex(,874) @node Toric ideals and integer programming, References, Gauss-Manin connection, Mathematical background
math.tex(,875) @section Toric ideals and integer programming
math.tex(,876) @cindex Toric ideals and integer programming
math.tex(,877) 
ti_ip.tex(,1) @menu
ti_ip.tex(,2) * Toric ideals::                Definition and computation.
ti_ip.tex(,3) * Integer programming::         An algorithm using toric ideals.
ti_ip.tex(,4) * Relevant References::
ti_ip.tex(,5) @end menu
ti_ip.tex(,6) 
ti_ip.tex(,7) @node Toric ideals, Integer programming, , Toric ideals and integer programming
ti_ip.tex(,8) 
ti_ip.tex(,9) @subsection Toric ideals
ti_ip.tex(,10) @cindex toric ideals
ti_ip.tex(,11) @comment This file was generated by doc2tex.pl from ti_ip.doc
ti_ip.tex(,12) @comment DO NOT EDIT DIRECTLY, BUT EDIT ti_ip.doc INSTEAD
ti_ip.tex(,13) @cindex ideal, toric
ti_ip.tex(,14) 
ti_ip.tex(,35) 
ti_ip.tex(,61) 
ti_ip.tex(,62) The required lattice basis can be computed using the LLL-algorithm (@pxref{[Coh93]}). For the computation of the saturation, there are various
ti_ip.tex(,63) possibilities described in the
ti_ip.tex(,70) 
ti_ip.tex(,71) @menu
ti_ip.tex(,72) * Algorithms::             Various algorithms for computing toric ideals.
ti_ip.tex(,73) * Buchberger algorithm::   Specializing it for toric ideals.
ti_ip.tex(,74) @end menu
ti_ip.tex(,75) 
ti_ip.tex(,76) @node Algorithms, Buchberger algorithm, , Toric ideals
ti_ip.tex(,77) @subsection Algorithms
ti_ip.tex(,78) 
ti_ip.tex(,79) The following algorithms are implemented in @ref{toric_lib}.
ti_ip.tex(,80) 
ti_ip.tex(,81) @menu
ti_ip.tex(,82) * Conti and Traverso::
ti_ip.tex(,83) * Pottier::
ti_ip.tex(,84) * Hosten and Sturmfels::
ti_ip.tex(,85) * Di Biase and Urbanke::
ti_ip.tex(,86) * Bigatti and La Scala and Robbiano::
ti_ip.tex(,87) @end menu
ti_ip.tex(,88) 
ti_ip.tex(,89) @node Conti and Traverso, Pottier, , Algorithms
ti_ip.tex(,90) 
ti_ip.tex(,91) @subsubsection The algorithm of Conti and Traverso
ti_ip.tex(,92) @cindex Conti-Traverso algorithm
ti_ip.tex(,93) @cindex algorithm of Conti and Traverso
ti_ip.tex(,94) 
ti_ip.tex(,95) 
ti_ip.tex(,96) The algorithm of Conti and Traverso (@pxref{[CoTr91]})
ti_ip.tex(,131) 
ti_ip.tex(,132) Because of the big number of auxiliary variables needed to compute a
ti_ip.tex(,133) toric ideal, this algorithm is rather slow in practice. However, it has
ti_ip.tex(,134) a special importance in the application to integer programming
ti_ip.tex(,135) (@pxref{Integer programming}).
ti_ip.tex(,136) 
ti_ip.tex(,137) @node Pottier, Hosten and Sturmfels, Conti and Traverso, Algorithms
ti_ip.tex(,138) 
ti_ip.tex(,139) @subsubsection The algorithm of Pottier
ti_ip.tex(,140) @cindex Pottier algorithm
ti_ip.tex(,141) @cindex algorithm of Pottier
ti_ip.tex(,142) 
ti_ip.tex(,143) 
ti_ip.tex(,144) The algorithm of Pottier (@pxref{[Pot94]}) starts by computing a lattice
ti_ip.tex(,167) 
ti_ip.tex(,168) 
ti_ip.tex(,169) @node Hosten and Sturmfels, Di Biase and Urbanke, Pottier, Algorithms
ti_ip.tex(,170) 
ti_ip.tex(,171) @subsubsection The algorithm of Hosten and Sturmfels
ti_ip.tex(,172) @cindex Hosten-Sturmfels algorithm
ti_ip.tex(,173) @cindex algorithm of Hosten and Sturmfels
ti_ip.tex(,174) 
ti_ip.tex(,175) 
ti_ip.tex(,176) The algorithm of Hosten and Sturmfels (@pxref{[HoSt95]}) allows to
ti_ip.tex(,235) (@pxref{[HoSh98]}), and the single
ti_ip.tex(,236) computations -- except from the first one -- show to be easy and fast in
ti_ip.tex(,237) practice.
ti_ip.tex(,238) 
ti_ip.tex(,239) @node Di Biase and Urbanke, Bigatti and La Scala and Robbiano, Hosten and Sturmfels, Algorithms
ti_ip.tex(,240) 
ti_ip.tex(,241) @subsubsection The algorithm of Di Biase and Urbanke
ti_ip.tex(,242) @cindex Di Biase-Urbanke algorithm
ti_ip.tex(,243) @cindex algorithm of Di Biase and Urbanke
ti_ip.tex(,244) 
ti_ip.tex(,245) Like the algorithm of Hosten and Sturmfels, the algorithm of Di Biase
ti_ip.tex(,246) and Urbanke (@pxref{[DBUr95]}) performs up
ti_ip.tex(,316) 
ti_ip.tex(,317) @node Bigatti and La Scala and Robbiano, , Di Biase and Urbanke, Algorithms
ti_ip.tex(,318) 
ti_ip.tex(,319) @subsubsection The algorithm of Bigatti, La Scala and Robbiano
ti_ip.tex(,320) @cindex Bigatti-La Scala-Robbiano algorithm
ti_ip.tex(,321) @cindex algorithm of Bigatti, La Scala and Robbiano
ti_ip.tex(,322) 
ti_ip.tex(,323) The algorithm of Bigatti, La Scala and Robbiano (@pxref{[BLR98]}) combines the ideas of
ti_ip.tex(,324) the algorithms of Pottier and of Hosten and Sturmfels. The
ti_ip.tex(,325) computations are performed on a graded ideal with one auxiliary
ti_ip.tex(,338) 
ti_ip.tex(,339) There is another algorithm of the authors which tries to parallelize
ti_ip.tex(,340) the computations (but which is not implemented in this library).
ti_ip.tex(,341) 
ti_ip.tex(,342) @node Buchberger algorithm, , Algorithms, Toric ideals
ti_ip.tex(,343) 
ti_ip.tex(,344) @subsection The Buchberger algorithm for toric ideals
ti_ip.tex(,345) @cindex Buchberger algorithm for toric ideals
ti_ip.tex(,346) 
ti_ip.tex(,347) Toric ideals have a very special structure that allows us to improve
ti_ip.tex(,348) the Buchberger algorithm in many respects: They are prime ideals and
ti_ip.tex(,349) generated by binomials. Pottier used this fact to describe all
ti_ip.tex(,350) operations of the Buchberger algorithm on the ideal generators in terms
ti_ip.tex(,351) of vector additions and subtractions. Some other strategies like
ti_ip.tex(,352) multiple reduction (@pxref{[CoTr91]}) or the use of bit
ti_ip.tex(,353) vectors to represent the support of a monomial (@pxref{[Big97]}) may be
ti_ip.tex(,354) applied to more general ideals, but show to
ti_ip.tex(,355) be especially useful in the toric case.
ti_ip.tex(,356) 
ti_ip.tex(,357) @node Integer programming, Relevant References, Toric ideals, Toric ideals and integer programming
ti_ip.tex(,358) 
ti_ip.tex(,359) @subsection Integer programming
ti_ip.tex(,360) @cindex integer programming
ti_ip.tex(,361) 
ti_ip.tex(,381) @c \begin{itemize}
ti_ip.tex(,382) @c \item (1) Compute the toric ideal $I_A$ using one of the algorithms in the
ti_ip.tex(,383) @c       previous section.
ti_ip.tex(,384) @c \item (2) Compute the reduced Groebner basis $G_c$ of $I_A$ w.r.t.
ti_ip.tex(,385) @c       $>_c$.
ti_ip.tex(,386) @c \item (3) Reduce $x^v$ modulo $G_c$ using the Hironaka division algorithm.
ti_ip.tex(,387) @c       If the result of this reduction is $x^{v_0}$, then $v_0$ is an
ti_ip.tex(,388) @c       optimal solution of the given instance.
ti_ip.tex(,389) @c \end{itemize}
ti_ip.tex(,390) 
ti_ip.tex(,411) 
ti_ip.tex(,412) @itemize @bullet
ti_ip.tex(,413) @item (1) Compute the toric ideal I(A) using one of the algorithms in the previous section.
ti_ip.tex(,414) @item (2) Compute the reduced Groebner basis G(c) of I(A) w.r.t.@: 
ti_ip.tex(,421) .
ti_ip.tex(,422) @item (3) Reduce 
ti_ip.tex(,429)  modulo G(c) using the Hironaka division algorithm.
ti_ip.tex(,430) If the result of this reduction is 
ti_ip.tex(,437) , then 
ti_ip.tex(,444)  is an optimal
ti_ip.tex(,445) solution of the given instance.
ti_ip.tex(,446) @end itemize
ti_ip.tex(,447) 
ti_ip.tex(,448) If no initial solution is known, we are nevertheless able to solve the
ti_ip.tex(,449) problem with similar techniques. For this purpose we replace our
ti_ip.tex(,450) instance by an extended instance with the matrix used
ti_ip.tex(,451) in the Conti-Traverso algorithm. Indeed, the Conti-Traverso
ti_ip.tex(,452) algorithm offers the possibility to verify solvability of a given
ti_ip.tex(,453) instance and to find an initial solution in the case of existence (but
ti_ip.tex(,454) none of the other algorithms does!). Details can be found in [CoTr91]
ti_ip.tex(,455) and [The99].
ti_ip.tex(,456) 
ti_ip.tex(,457) An implementation of the above algorithm and some examples can be found in @ref{intprog_lib}.
ti_ip.tex(,458) 
ti_ip.tex(,459) Classical methods for solving IP instances like Branch-and-Bound
ti_ip.tex(,460) methods seem to be faster in general than the methods using toric
ti_ip.tex(,461) ideals. But the latter have one great advantage: If one wants to solve
ti_ip.tex(,462) various instances that differ only by the vector 
ti_ip.tex(,469) , one has to
ti_ip.tex(,470) perform steps (1) and (2) above only once. As the running time of step (3)
ti_ip.tex(,471) is very short, solving all the instances is not much harder than
ti_ip.tex(,472) solving one single instance.
ti_ip.tex(,473) 
ti_ip.tex(,474) For a detailed discussion see [The99].
ti_ip.tex(,475) 
ti_ip.tex(,476) @node Relevant References, , Integer programming, Toric ideals and integer programming
ti_ip.tex(,477) @subsection Relevant References
ti_ip.tex(,478) 
ti_ip.tex(,479) @itemize @bullet
ti_ip.tex(,480) @item [Big97]  Bigatti, A.M.: @anchor{[Big97]}
ti_ip.tex(,481)    Computation of Hilbert-Poincare series.
ti_ip.tex(,482)    Journal of Pure and Applied Algebra (1997) 199, 237-253
ti_ip.tex(,483) 
ti_ip.tex(,484) @item [BLR98]  Bigatti, A.M.; La Scala, R.; Robbiano, L.: @anchor{[BLR98]}
ti_ip.tex(,485)    Computing toric ideals.
ti_ip.tex(,486)    Journal of Symbolic Computation (to appear)
ti_ip.tex(,487) 
ti_ip.tex(,488) @item [Coh93]  Cohen, H.: @anchor{[Coh93]}
ti_ip.tex(,489)    A Course in Computational Algebraic Number Theory.
ti_ip.tex(,490)    Springer (1997)
ti_ip.tex(,491) 
ti_ip.tex(,492) @item [CoTr91]  Conti, P.; Traverso, C.: @anchor{[CoTr91]}
ti_ip.tex(,493)    Buchberger algorithm and integer programming.
ti_ip.tex(,494)    Proceedings AAECC-9 (new Orleans), Springer LNCS (1991) 539,
ti_ip.tex(,495)    130-139
ti_ip.tex(,496) 
ti_ip.tex(,497) @item [DBUr95]  Di Biase, F.; Urbanke, R.: @anchor{[DBUr95]}
ti_ip.tex(,498)    An algorithm to calculate the kernel of certain polynomial ring
ti_ip.tex(,499)    homomorphisms.
ti_ip.tex(,500)    Experimental Mathematics (1995) 4, 227-234
ti_ip.tex(,501) 
ti_ip.tex(,502) @item [HoSh98]  Hosten, S.; Shapiro, J.: @anchor{[HoSh98]}
ti_ip.tex(,503)    Primary decomposition of lattice basis ideals.
ti_ip.tex(,504)    (to appear)
ti_ip.tex(,505) 
ti_ip.tex(,506) @item [HoSt95]  Hosten, S.; Sturmfels, B.: @anchor{[HoSt95]}
ti_ip.tex(,507)    GRIN: An implementation of Groebner bases for integer programming.
ti_ip.tex(,508)    in Balas, E.; Clausen, J. (editors): Integer Programming and
ti_ip.tex(,509)    Combinatorial Optimization.
ti_ip.tex(,510)    Springer LNCS (1995) 920, 267-276
ti_ip.tex(,511) 
ti_ip.tex(,512) @item [Pot94]  Pottier, L.: @anchor{[Pot94]}
ti_ip.tex(,513)    Groebner bases of toric ideals.
ti_ip.tex(,514)    Rapport de recherche 2224 (1997), INRIA Sophia Antipolis
ti_ip.tex(,515) 
ti_ip.tex(,516) @item [Stu96]  Sturmfels, B.: @anchor{[Stu96]}
ti_ip.tex(,517)    Groebner Bases and Convex Polytopes.
ti_ip.tex(,518)    University Lecture Series, Volume 8 (1996), American Mathematical
ti_ip.tex(,519)    Society
ti_ip.tex(,520) 
ti_ip.tex(,521) @item [The99]  Theis, C.: @anchor{[The99]}
ti_ip.tex(,522)    Der Buchberger-Algorithmus fuer torische Ideale und seine Anwendung
ti_ip.tex(,523)    in der ganzzahligen Optimierung.
ti_ip.tex(,524)    Diplomarbeit, Universitaet des Saarlandes (1999), Saarbruecken
ti_ip.tex(,525)    (Germany)
ti_ip.tex(,526) 
ti_ip.tex(,527) @end itemize
math.tex(,879) 
math.tex(,880) @c ---------------------------------------------------------------------------
math.tex(,881) @node References, , Toric ideals and integer programming, Mathematical background
math.tex(,882) @section References
math.tex(,883) @cindex References
math.tex(,884) 
math.tex(,885) The Centre for Computer Algebra Kaiserslautern publishes a series of preprints
math.tex(,886) which are electronically available at
math.tex(,887) @code{http://www.mathematik.uni-kl.de/~zca/Reports_on_ca}.
math.tex(,888) Other sources to check are @code{http://symbolicnet.mcs.kent.edu/},
math.tex(,889) @code{http://www.can.nl/},... and the following list of books:
math.tex(,890) 
math.tex(,891) @subheading Text books on computational algebraic geometry
math.tex(,892) @itemize @bullet
math.tex(,893) 
math.tex(,894) @item
math.tex(,895) Adams, W.; Loustaunau, P.: An Introduction to Gr@"obner Bases. Providence, RI,
math.tex(,896) AMS, 1996
math.tex(,897) 
math.tex(,898) @item
math.tex(,899) Becker, T.; Weisspfenning, V.:
math.tex(,900) Gr@"obner Bases - A Computational Approach to Commutative Algebra. Springer, 1993
math.tex(,901) 
math.tex(,902) @item
math.tex(,903) Cohen, H.:
math.tex(,904) A Course in Computational Algebraic Number Theory,
math.tex(,905) Springer, 1995
math.tex(,906) 
math.tex(,907) @item
math.tex(,908) Cox, D.; Little, J.; O'Shea, D.:
math.tex(,909) Ideals, Varieties and Algorithms. Springer, 1996
math.tex(,910) 
math.tex(,911) @item
math.tex(,912) Eisenbud, D.: Commutative Algebra with a View Toward Algebraic Geometry.
math.tex(,913) Springer, 1995
math.tex(,914) 
math.tex(,915) @item
math.tex(,916) Greuel, G.-M.; Pfister, G.: A SINGULAR Introduction to Commuative Algebra, Springer, 2002
math.tex(,917) 
math.tex(,918) @item
math.tex(,919) Mishra, B.: Algorithmic Algebra, Texts and Monographs in Computer Science.
math.tex(,920) Springer, 1993
math.tex(,921) @item
math.tex(,922) Sturmfels, B.: Algorithms in Invariant Theory. Springer 1993
math.tex(,923) 
math.tex(,924) @item
math.tex(,925) Vasconcelos, W.: Computational Methods in Commutative Algebra and Algebraic
math.tex(,926) Geometry. Springer, 1998
math.tex(,927) @end itemize
math.tex(,928) 
math.tex(,929) @subheading Descriptions of algorithms
math.tex(,930) @itemize @bullet
math.tex(,931) @item
math.tex(,932) Bareiss, E.:
math.tex(,933) Sylvester's identity and multistep integer-preserving Gaussian elimination.
math.tex(,934) Math. Comp. 22 (1968), 565-578
math.tex(,935) 
math.tex(,936) @item
math.tex(,937) Campillo, A.: Algebroid curves in positive characteristic. SLN 813, 1980
math.tex(,938) 
math.tex(,939) @item
math.tex(,940) Chou, S.:
math.tex(,941) Mechanical Geometry Theorem Proving.
math.tex(,942) D.Reidel Publishing Company, 1988
math.tex(,943) 
math.tex(,944) @item
math.tex(,945) Decker, W.; Greuel, G.-M.; Pfister, G.:
math.tex(,946) Primary decomposition: algorithms and
math.tex(,947) comparisons.  Preprint, Univ. Kaiserslautern, 1998.
math.tex(,948) To appear in: Greuel, G.-M.; Matzat, B. H.; Hiss, G. (Eds.),
math.tex(,949) Algorithmic Algebra and Number Theory. Springer Verlag, Heidelberg, 1998
math.tex(,950) 
math.tex(,951) @item
math.tex(,952) Decker, W.; Greuel, G.-M.; de Jong, T.; Pfister, G.:
math.tex(,953) The normalization: a new algorithm,
math.tex(,954) implementation and comparisons. Preprint, Univ. Kaiserslautern, 1998
math.tex(,955) 
math.tex(,956) @item
math.tex(,957) Decker, W.; Heydtmann, A.; Schreyer, F. O.: Generating a Noetherian Normalization of
math.tex(,958) the Invariant Ring of a Finite Group, 1997, to appear in Journal of
math.tex(,959) Symbolic Computation
math.tex(,960) 
math.tex(,961) @item
math.tex(,968) J. C.; Gianni, P.; Lazard, D.; Mora, T.: Efficient computation
math.tex(,969) of zero-dimensional
math.tex(,970) Gr@"obner bases by change of ordering. Journal of Symbolic Computation, 1989
math.tex(,971) 
math.tex(,972) @item
math.tex(,973) Gr@"abe, H.-G.: On factorized Gr@"obner bases, Univ. Leipzig, Inst. f@"ur
math.tex(,974) Informatik, 1994
math.tex(,975) 
math.tex(,976) @item
math.tex(,977) Grassmann, H.; Greuel, G.-M.; Martin, B.; Neumann,
math.tex(,978) W.; Pfister, G.; Pohl, W.; Sch@"onemann, H.; Siebert, T.:  On an
math.tex(,979) implementation of standard bases and syzygies in  @sc{Singular}.
math.tex(,980) Proceedings of the Workshop  Computational Methods in Lie theory in AAECC (1995)
math.tex(,981) 
math.tex(,982) @item
math.tex(,983) Greuel, G.-M.; Pfister, G.:
math.tex(,984) Advances and improvements in the theory of standard bases and
math.tex(,985) syzygies. Arch. d. Math. 63(1995)
math.tex(,986) 
math.tex(,987) @item
math.tex(,988) Kemper; Generating Invariant Rings of Finite Groups over Arbitrary
math.tex(,989) Fields. 1996, to appear in Journal of Symbolic Computation
math.tex(,990) 
math.tex(,991) @item
math.tex(,992) Kemper and Steel: Some Algorithms in Invariant Theory of Finite Groups. 1997
math.tex(,993) 
math.tex(,994) @item
math.tex(,995) Lee, H.R.; Saunders, B.D.: Fraction Free Gaussian Elimination for
math.tex(,996) Sparse Matrices. Journal of Symbolic Computation (1995) 19, 393-402
math.tex(,997) 
math.tex(,998) @item
math.tex(,999) Sch@"onemann, H.:
math.tex(,1000) Algorithms in @sc{Singular},
math.tex(,1001) Reports on Computer Algebra 2(1996), Kaiserslautern
math.tex(,1002) 
math.tex(,1003) @item
math.tex(,1004) Siebert, T.:
math.tex(,1005) On strategies and implementations for computations of free resolutions.
math.tex(,1006) Reports on Computer Algebra 8(1996), Kaiserslautern
math.tex(,1007) 
math.tex(,1008) @item
math.tex(,1009) Wang, D.:
math.tex(,1010) Characteristic Sets and Zero Structure of Polynomial Sets.
math.tex(,1011) Lecture Notes, RISC Linz, 1989
math.tex(,1012) @end itemize
math.tex(,1013) 
singular.texi(,169) @c ----------------------------------------------------------------------------
singular.texi(,170) @node SINGULAR libraries, Release Notes, Mathematical background, Top
singular.texi(,171) @appendix SINGULAR libraries
singular.texi(,172) @cindex SINGULAR libraries
singular.texi(,173) @cindex LIBs
singular.texi(,174) 
singular.texi(,175) @sc{Singular} comes with a set of standard libraries. Their content is
singular.texi(,176) described in the following subsections.
singular.texi(,177) 
singular.texi(,178) Use the @ref{LIB} command for loading of single libraries, and the
singular.texi(,179) command @code{LIB "all.lib";} for loading all libraries.
singular.texi(,180) 
singular.texi(,181) @menu
singular.texi(,182) * standard_lib:: extensions of Singular kernel
singular.texi(,183) * General purpose::
singular.texi(,184) * Linear algebra::
singular.texi(,185) * Commutative algebra::
singular.texi(,186) * Singularities::
singular.texi(,187) * Invariant theory::
singular.texi(,188) * Symbolic-numerical solving::
singular.texi(,189) * Visualization::
singular.texi(,190) * Coding theory::
singular.texi(,191) @end menu
singular.texi(,192) @c ----------------------------------------------------------
singular.texi(,193) @node standard_lib, General purpose, SINGULAR libraries, SINGULAR libraries
singular.texi(,194) @section standard_lib
singular.texi(,195) 
singular.texi(,196) The library @code{standard.lib} provides extensions to the
singular.texi(,197) set of built-in commands and is automatically loaded
singular.texi(,198) during the start of @sc{Singular}, unless @sc{Singular} is started up
singular.texi(,199) with the @code{--no-stdlib} command line option (see
singular.texi(,200) @ref{Command line options}).
singular.texi(,201) 
singular.texi(,202) @c start include of docu for standard.lib:LibInfo
singular.texi(,203) @c ---content LibInfo---
singular.texi(,204) @comment This file was generated by doc2tex.pl from d2t_singular/standard_lib.doc
singular.texi(,205) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/standard_lib.doc INSTEAD
singular.texi(,206) @c library version: (1.58.2.9,2003/06/16)
singular.texi(,207) @c library file: ../Singular/LIB/standard.lib
singular.texi(,208) @cindex standard.lib
singular.texi(,209) @cindex standard_lib
singular.texi(,210) @table @asis
singular.texi(,211) @item @strong{Library:}
singular.texi(,212) standard.lib
singular.texi(,213) @item @strong{Purpose:}
singular.texi(,214)    Procedures which are always loaded at Start-up
singular.texi(,215) 
singular.texi(,216) @end table
singular.texi(,217) 
singular.texi(,218) @strong{Procedures:}
singular.texi(,219) @menu
singular.texi(,220) * stdfglm:: standard basis of ideal via fglm [and ordering ord]
singular.texi(,221) * stdhilb:: standard basis of ideal using the Hilbert function
singular.texi(,222) * groebner:: standard basis using a heuristically chosen method
singular.texi(,223) * quot:: quotient using heuristically chosen method
singular.texi(,224) * res:: free resolution of ideal or module
singular.texi(,225) * sprintf:: returns formatted string
singular.texi(,226) * fprintf:: writes formatted string to link
singular.texi(,227) * printf:: displays formatted string
singular.texi(,228) @end menu
singular.texi(,229) @c ---end content LibInfo---
singular.texi(,230) @c generated lib proc docu for standard.lib:LibInfo singular.doc:200 
singular.texi(,231) @c end include of docu for standard.lib:LibInfo
singular.texi(,232) 
singular.texi(,233) @c ----------------------------------------------------------------------------
singular.texi(,234) @node General purpose, Linear algebra, standard_lib, SINGULAR libraries
singular.texi(,235) @section General purpose
singular.texi(,236) @cindex General purpose
singular.texi(,237) 
singular.texi(,238) @menu
singular.texi(,239) * all_lib:: load all other libraries
singular.texi(,240) * general_lib:: procedures of general type
singular.texi(,241) * inout_lib:: procedures for manipulating in- and output
singular.texi(,242) * poly_lib:: procedures for manipulating polynomials and ideals
singular.texi(,243) * random_lib:: procedures of random/sparse  matrix and poly operations
singular.texi(,244) * ring_lib:: procedures for manipulating rings and maps
singular.texi(,245) @end menu
singular.texi(,246) 
singular.texi(,247) @c ----------------------------------------------------------
singular.texi(,248) @node all_lib, general_lib, General purpose, General purpose
singular.texi(,249) @subsection all_lib
singular.texi(,250) @cindex all_lib
singular.texi(,251) @cindex all.lib
singular.texi(,252) 
singular.texi(,253) The library @code{all.lib} provides a convenient way to load all
singular.texi(,254) libraries of the @sc{Singular} distribution.
singular.texi(,255) 
singular.texi(,256) @strong{Example:}
singular.texi(,257) @smallexample
singular.texi(,258) @c reused example all_lib singular.doc:227 
singular.texi(,259) option(loadLib);
singular.texi(,260) LIB "all.lib";
singular.texi(,261) @expansion{} // ** loaded all.lib (1.35.2.4,2003/02/25)
singular.texi(,262) @expansion{} // ** loaded makedbm.lib (1.11,2000/12/22)
singular.texi(,263) @expansion{} // ** loaded brnoeth.lib (1.11.2.5,2002/10/18)
singular.texi(,264) @expansion{} // ** loaded paramet.lib (1.11.2.1,2002/10/21)
singular.texi(,265) @expansion{} // ** loaded surf.lib (1.19.2.6,2002/07/17)
singular.texi(,266) @expansion{} // ** loaded latex.lib (1.19.2.1,2002/02/20)
singular.texi(,267) @expansion{} // ** loaded graphics.lib (1.10,2001/02/19)
singular.texi(,268) @expansion{} // ** loaded zeroset.lib (1.7.2.2,2002/02/20)
singular.texi(,269) @expansion{} // ** loaded ntsolve.lib (1.12.2.1,2002/04/12)
singular.texi(,270) @expansion{} // ** loaded triang.lib (1.7,2001/02/19)
singular.texi(,271) @expansion{} // ** loaded solve.lib (1.21.2.13,2002/10/21)
singular.texi(,272) @expansion{} // ** loaded presolve.lib (1.17.2.6,2003/03/26)
singular.texi(,273) @expansion{} // ** loaded stratify.lib (1.7.2.4,2002/04/11)
singular.texi(,274) @expansion{} // ** loaded rinvar.lib (1.7.2.3,2002/02/20)
singular.texi(,275) @expansion{} // ** loaded finvar.lib (1.32.2.2,2002/08/13)
singular.texi(,276) @expansion{} // ** loaded ainvar.lib (1.6.2.2,2002/04/12)
singular.texi(,277) @expansion{} // ** loaded spectrum.lib (1.12.2.3,2002/03/06)
singular.texi(,278) @expansion{} // ** loaded spcurve.lib (1.15.2.1,2002/02/20)
singular.texi(,279) @expansion{} // ** loaded sing.lib (1.24.2.5,2003/04/15)
singular.texi(,280) @expansion{} // ** loaded qhmoduli.lib (1.0,2000/12/12)
singular.texi(,281) @expansion{} // ** loaded mondromy.lib (1.22.2.2,2002/02/20)
singular.texi(,282) @expansion{} // ** loaded hnoether.lib (1.29.2.14,2002/10/21)
singular.texi(,283) @expansion{} // ** loaded gaussman.lib (1.33.2.26,2003/02/10)
singular.texi(,284) @expansion{} // ** loaded equising.lib (1.7.2.5,2003/02/25)
singular.texi(,285) @expansion{} // ** loaded deform.lib (1.25.2.2,2003/02/24)
singular.texi(,286) @expansion{} // ** loaded classify.lib (1.48.2.4,2002/04/11)
singular.texi(,287) @expansion{} // ** loaded toric.lib (1.11,2001/02/06)
singular.texi(,288) @expansion{} // ** loaded intprog.lib (1.5,2001/02/06)
singular.texi(,289) @expansion{} // ** loaded reesclos.lib (1.50,2001/08/06)
singular.texi(,290) @expansion{} // ** loaded primitiv.lib (1.15,2001/02/05)
singular.texi(,291) @expansion{} // ** loaded primdec.lib (1.98.2.14,2003/04/07)
singular.texi(,292) @expansion{} // ** loaded normal.lib (1.34.2.17,2002/10/21)
singular.texi(,293) @expansion{} // ** loaded mregular.lib (1.6.2.1,2002/02/20)
singular.texi(,294) @expansion{} // ** loaded mprimdec.lib (1.1.2.3,2002/03/19)
singular.texi(,295) @expansion{} // ** loaded homolog.lib (1.15.2.2,2002/10/07)
singular.texi(,296) @expansion{} // ** loaded elim.lib (1.14.2.4,2003/04/16)
singular.texi(,297) @expansion{} // ** loaded algebra.lib (1.9.2.3,2002/04/11)
singular.texi(,298) @expansion{} // ** loaded linalg.lib (1.10.2.15,2003/04/04)
singular.texi(,299) @expansion{} // ** loaded matrix.lib (1.26.2.2,2002/10/07)
singular.texi(,300) @expansion{} // ** loaded ring.lib (1.17.2.1,2002/02/20)
singular.texi(,301) @expansion{} // ** loaded random.lib (1.16.2.1,2002/02/20)
singular.texi(,302) @expansion{} // ** loaded poly.lib (1.33.2.6,2003/02/10)
singular.texi(,303) @expansion{} // ** loaded inout.lib (1.21.2.5,2002/06/12)
singular.texi(,304) @expansion{} // ** loaded general.lib (1.38.2.9,2003/04/04)
singular.texi(,305) @c end example all_lib singular.doc:227
singular.texi(,306) @end smallexample
singular.texi(,307) @c ----------------------------------------------------------
singular.texi(,308) @node general_lib, inout_lib, all_lib, General purpose
singular.texi(,309) @subsection general_lib
singular.texi(,310) @c include of docu for general.lib
general_lib.tex(,1) @c ---content LibInfo---
general_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/general_lib.doc
general_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/general_lib.doc INSTEAD
general_lib.tex(,4) @c library version: (1.38.2.9,2003/04/04)
general_lib.tex(,5) @c library file: ../Singular/LIB/general.lib
general_lib.tex(,6) @cindex general.lib
general_lib.tex(,7) @cindex general_lib
general_lib.tex(,8) @table @asis
general_lib.tex(,9) @item @strong{Library:}
general_lib.tex(,10) general.lib
general_lib.tex(,11) @item @strong{Purpose:}
general_lib.tex(,12)    Elementary Computations of General Type
general_lib.tex(,13) 
general_lib.tex(,14) @end table
general_lib.tex(,15) 
general_lib.tex(,16) @strong{Procedures:}
general_lib.tex(,17) @menu
general_lib.tex(,18) * A_Z:: string a,b,... of n comma separated letters
general_lib.tex(,19) * ASCII:: string of printable ASCII characters (number n to m)
general_lib.tex(,20) * absValue:: absolute value of c
general_lib.tex(,21) * binomial:: n choose m (type int), [type string/type number]
general_lib.tex(,22) * deleteSublist:: delete entries given by iv from list l
general_lib.tex(,23) * factorial:: n factorial (=n!) (type int), [type string/number]
general_lib.tex(,24) * fibonacci:: nth Fibonacci number [char p]
general_lib.tex(,25) * kmemory:: active [allocated] memory in kilobyte
general_lib.tex(,26) * killall:: kill all user-defined variables
general_lib.tex(,27) * number_e:: compute exp(1) up to n decimal digits
general_lib.tex(,28) * number_pi:: compute pi (area of unit circle) up to n digits
general_lib.tex(,29) * primes:: intvec of primes p, n<=p<=m
general_lib.tex(,30) * product:: multiply components of vector/ideal/...[indices v]
general_lib.tex(,31) * sort:: sort generators according to monomial ordering
general_lib.tex(,32) * sum:: add components of vector/ideal/...[with indices v]
general_lib.tex(,33) * watchdog:: only wait for result of command cmd for i seconds
general_lib.tex(,34) * which:: search for command and return absolute path, if found
general_lib.tex(,35) * primecoeffs:: primefactors <= min(p,32003) of coeffs of J
general_lib.tex(,36) * primefactors:: primefactors <= min(p,32003) of n
general_lib.tex(,37) * timeStd:: std(i) if computation finished after d seconds else i
general_lib.tex(,38) * timeFactorize:: works as timeStd with factorization
general_lib.tex(,39) * factorH:: factorizes with good choice of principal variable
general_lib.tex(,40) @end menu
general_lib.tex(,41) @c ---end content LibInfo---
general_lib.tex(,42) 
general_lib.tex(,43) @c ------------------- A_Z -------------
general_lib.tex(,44) @node A_Z, ASCII,, general_lib
general_lib.tex(,45) @subsubsection A_Z
general_lib.tex(,46) @cindex A_Z
general_lib.tex(,47) @c ---content A_Z---
general_lib.tex(,48) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,49) 
general_lib.tex(,50) @table @asis
general_lib.tex(,51) @item @strong{Usage:}
general_lib.tex(,52) A_Z("a",n); a any letter, n integer (-26<= n <=26, !=0)
general_lib.tex(,53) 
general_lib.tex(,54) @item @strong{Return:}
general_lib.tex(,55) string of n small (if a is small) or capital (if a is capital)
general_lib.tex(,56) letters, comma separated, beginning with a, in alphabetical
general_lib.tex(,57) order (or revers alphabetical order if n<0)
general_lib.tex(,58) 
general_lib.tex(,59) @end table
general_lib.tex(,60) @strong{Example:}
general_lib.tex(,61) @smallexample
general_lib.tex(,62) @c computed example A_Z d2t_singular/general_lib.doc:60 
general_lib.tex(,63) LIB "general.lib";
general_lib.tex(,64) A_Z("c",5);
general_lib.tex(,65) @expansion{} c,d,e,f,g
general_lib.tex(,66) A_Z("Z",-5);
general_lib.tex(,67) @expansion{} Z,Y,X,W,V
general_lib.tex(,68) string sR = "ring R = (0,"+A_Z("A",6)+"),("+A_Z("a",10)+"),dp;";
general_lib.tex(,69) sR;
general_lib.tex(,70) @expansion{} ring R = (0,A,B,C,D,E,F),(a,b,c,d,e,f,g,h,i,j),dp;
general_lib.tex(,71) execute(sR);
general_lib.tex(,72) R;
general_lib.tex(,73) @expansion{} //   characteristic : 0
general_lib.tex(,74) @expansion{} //   6 parameter    : A B C D E F 
general_lib.tex(,75) @expansion{} //   minpoly        : 0
general_lib.tex(,76) @expansion{} //   number of vars : 10
general_lib.tex(,77) @expansion{} //        block   1 : ordering dp
general_lib.tex(,78) @expansion{} //                  : names    a b c d e f g h i j 
general_lib.tex(,79) @expansion{} //        block   2 : ordering C
general_lib.tex(,80) @c end example A_Z d2t_singular/general_lib.doc:60
general_lib.tex(,81) @end smallexample
general_lib.tex(,82) @c ---end content A_Z---
general_lib.tex(,83) 
general_lib.tex(,84) @c ------------------- ASCII -------------
general_lib.tex(,85) @node ASCII, absValue, A_Z, general_lib
general_lib.tex(,86) @subsubsection ASCII
general_lib.tex(,87) @cindex ASCII
general_lib.tex(,88) @c ---content ASCII---
general_lib.tex(,89) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,90) 
general_lib.tex(,91) @table @asis
general_lib.tex(,92) @item @strong{Usage:}
general_lib.tex(,93) ASCII([n,m]); n,m= integers (32 <= n <= m <= 126)
general_lib.tex(,94) 
general_lib.tex(,95) @item @strong{Return:}
general_lib.tex(,96) string of printable ASCII characters (no native language support)
general_lib.tex(,97) ASCII(): string of all ASCII characters with its numbers,
general_lib.tex(,98) ASCII(n): n-th ASCII character
general_lib.tex(,99) @*ASCII(n,m): n-th up to m-th ASCII character (inclusive)
general_lib.tex(,100) 
general_lib.tex(,101) @end table
general_lib.tex(,102) @strong{Example:}
general_lib.tex(,103) @smallexample
general_lib.tex(,104) @c computed example ASCII d2t_singular/general_lib.doc:92 
general_lib.tex(,105) LIB "general.lib";
general_lib.tex(,106) ASCII();"";
general_lib.tex(,107) @expansion{}      !    "    #    $    %    &    '    (    )    *    +    ,    -    .
general_lib.tex(,108) @expansion{} 32   33   34   35   36   37   38   39   40   41   42   43   44   45   46
general_lib.tex(,109) @expansion{} /    0    1    2    3    4    5    6    7    8    9    :    ;    <    =
general_lib.tex(,110) @expansion{} 47   48   49   50   51   52   53   54   55   56   57   58   59   60   61
general_lib.tex(,111) @expansion{} >    ?    @@    A    B    C    D    E    F    G    H    I    J    K    L
general_lib.tex(,112) @expansion{} 62   63   64   65   66   67   68   69   70   71   72   73   74   75   76
general_lib.tex(,113) @expansion{} M    N    O    P    Q    R    S    T    U    V    W    X    Y    Z    [
general_lib.tex(,114) @expansion{} 77   78   79   80   81   82   83   84   85   86   87   88   89   90   91
general_lib.tex(,115) @expansion{} \    ]    ^    _    `    a    b    c    d    e    f    g    h    i    j
general_lib.tex(,116) @expansion{} 92   93   94   95   96   97   98   99  100  101  102  103  104  105  10
general_lib.tex(,117) @expansion{} k    l    m    n    o    p    q    r    s    t    u    v    w    x    y
general_lib.tex(,118) @expansion{} 107  108  109  110  111  112  113  114  115  116  117  118  119  120  121
general_lib.tex(,119) @expansion{} z    @{    |    @}    ~
general_lib.tex(,120) @expansion{} 122  123  124  125  126 
general_lib.tex(,121) @expansion{} 
general_lib.tex(,122) ASCII(42);
general_lib.tex(,123) @expansion{} *
general_lib.tex(,124) ASCII(32,126);
general_lib.tex(,125) @expansion{}  !"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh\
general_lib.tex(,126)    ijklmnopqrstuvwxyz@{|@}~
general_lib.tex(,127) @c end example ASCII d2t_singular/general_lib.doc:92
general_lib.tex(,128) @end smallexample
general_lib.tex(,129) @c ---end content ASCII---
general_lib.tex(,130) 
general_lib.tex(,131) @c ------------------- absValue -------------
general_lib.tex(,132) @node absValue, binomial, ASCII, general_lib
general_lib.tex(,133) @subsubsection absValue
general_lib.tex(,134) @cindex absValue
general_lib.tex(,135) @c ---content absValue---
general_lib.tex(,136) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,137) 
general_lib.tex(,138) @table @asis
general_lib.tex(,139) @item @strong{Usage:}
general_lib.tex(,140) absValue(c); c int, number or poly
general_lib.tex(,141) 
general_lib.tex(,142) @item @strong{Return:}
general_lib.tex(,143) absValue(c); the absolute value of c
general_lib.tex(,144) 
general_lib.tex(,145) @item @strong{Note:}
general_lib.tex(,146) absValue(c)=c if c>=0; absValue=-c if c<=0.
general_lib.tex(,147) @* So the function can be applied to any type, for which comparison
general_lib.tex(,148) @* operators are defined.
general_lib.tex(,149) 
general_lib.tex(,150) @end table
general_lib.tex(,151) @strong{Example:}
general_lib.tex(,152) @smallexample
general_lib.tex(,153) @c computed example absValue d2t_singular/general_lib.doc:123 
general_lib.tex(,154) LIB "general.lib";
general_lib.tex(,155) ring r1 = 0,x,dp;
general_lib.tex(,156) absValue(-2002);
general_lib.tex(,157) @expansion{} 2002
general_lib.tex(,158) poly f=-4;
general_lib.tex(,159) absValue(f);
general_lib.tex(,160) @expansion{} 4
general_lib.tex(,161) @c end example absValue d2t_singular/general_lib.doc:123
general_lib.tex(,162) @end smallexample
general_lib.tex(,163) @c inserted refs from d2t_singular/general_lib.doc:131
general_lib.tex(,174) @c end inserted refs from d2t_singular/general_lib.doc:131
general_lib.tex(,175) 
general_lib.tex(,176) @c ---end content absValue---
general_lib.tex(,177) 
general_lib.tex(,178) @c ------------------- binomial -------------
general_lib.tex(,179) @node binomial, deleteSublist, absValue, general_lib
general_lib.tex(,180) @subsubsection binomial
general_lib.tex(,181) @cindex binomial
general_lib.tex(,182) @c ---content binomial---
general_lib.tex(,183) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,184) 
general_lib.tex(,185) @table @asis
general_lib.tex(,186) @item @strong{Usage:}
general_lib.tex(,187) binomial(n,k[,p]); n,k,p integers
general_lib.tex(,188) 
general_lib.tex(,189) @item @strong{Return:}
general_lib.tex(,190) binomial(n,k); binomial coefficient n choose k
general_lib.tex(,191) @* - of type string (computed in characteristic 0)
general_lib.tex(,192) @* binomial(n,k,p); n choose k, computed in characteristic 0 or prime(p)
general_lib.tex(,193) @* - of type number if a basering, say R, is present and p=0=char(R)
general_lib.tex(,194) or if prime(p)=char(R)
general_lib.tex(,195) @* - of type string else
general_lib.tex(,196) 
general_lib.tex(,197) @item @strong{Note:}
general_lib.tex(,198) In any characteristic, binomial(n,k) = coefficient of x^k in (1+x)^n
general_lib.tex(,199) 
general_lib.tex(,200) @end table
general_lib.tex(,201) @strong{Example:}
general_lib.tex(,202) @smallexample
general_lib.tex(,203) @c computed example binomial d2t_singular/general_lib.doc:162 
general_lib.tex(,204) LIB "general.lib";
general_lib.tex(,205) binomial(200,100);"";                   //type string, computed in char 0
general_lib.tex(,206) @expansion{} 90548514656103281165404177077484163874504589675413336841320
general_lib.tex(,207) @expansion{} 
general_lib.tex(,208) binomial(200,100,3);"";                 //type string, computed in char 3
general_lib.tex(,209) @expansion{} 0
general_lib.tex(,210) @expansion{} 
general_lib.tex(,211) int n,k = 200,100;
general_lib.tex(,212) ring r = 0,x,dp;
general_lib.tex(,213) number b1 = binomial(n,k,0);            //type number, computed in ring r
general_lib.tex(,214) poly b2 = coeffs((x+1)^n,x)[k+1,1];     //coefficient of x^k in (x+1)^n
general_lib.tex(,215) b1-b2;                                  //b1 and b2 should coincide
general_lib.tex(,216) @expansion{} 0
general_lib.tex(,217) @c end example binomial d2t_singular/general_lib.doc:162
general_lib.tex(,218) @end smallexample
general_lib.tex(,219) @c inserted refs from d2t_singular/general_lib.doc:173
general_lib.tex(,230) @c end inserted refs from d2t_singular/general_lib.doc:173
general_lib.tex(,231) 
general_lib.tex(,232) @c ---end content binomial---
general_lib.tex(,233) 
general_lib.tex(,234) @c ------------------- deleteSublist -------------
general_lib.tex(,235) @node deleteSublist, factorial, binomial, general_lib
general_lib.tex(,236) @subsubsection deleteSublist
general_lib.tex(,237) @cindex deleteSublist
general_lib.tex(,238) @c ---content deleteSublist---
general_lib.tex(,239) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,240) 
general_lib.tex(,241) @table @asis
general_lib.tex(,242) @item @strong{Usage:}
general_lib.tex(,243) deleteSublist(v,l); intvec v; list l
general_lib.tex(,244) @*where the entries of the integer vector v correspond to the
general_lib.tex(,245) positions of the elements to be deleted
general_lib.tex(,246) 
general_lib.tex(,247) @item @strong{Return:}
general_lib.tex(,248) list without the deleted elements
general_lib.tex(,249) 
general_lib.tex(,250) @end table
general_lib.tex(,251) @strong{Example:}
general_lib.tex(,252) @smallexample
general_lib.tex(,253) @c computed example deleteSublist d2t_singular/general_lib.doc:198 
general_lib.tex(,254) LIB "general.lib";
general_lib.tex(,255) list l=1,2,3,4,5;
general_lib.tex(,256) intvec v=1,3,4;
general_lib.tex(,257) l=deleteSublist(v,l);
general_lib.tex(,258) l;
general_lib.tex(,259) @expansion{} [1]:
general_lib.tex(,260) @expansion{}    2
general_lib.tex(,261) @expansion{} [2]:
general_lib.tex(,262) @expansion{}    5
general_lib.tex(,263) @c end example deleteSublist d2t_singular/general_lib.doc:198
general_lib.tex(,264) @end smallexample
general_lib.tex(,265) @c ---end content deleteSublist---
general_lib.tex(,266) 
general_lib.tex(,267) @c ------------------- factorial -------------
general_lib.tex(,268) @node factorial, fibonacci, deleteSublist, general_lib
general_lib.tex(,269) @subsubsection factorial
general_lib.tex(,270) @cindex factorial
general_lib.tex(,271) @c ---content factorial---
general_lib.tex(,272) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,273) 
general_lib.tex(,274) @table @asis
general_lib.tex(,275) @item @strong{Usage:}
general_lib.tex(,276) factorial(n[,p]); n,p integers
general_lib.tex(,277) 
general_lib.tex(,278) @item @strong{Return:}
general_lib.tex(,279) factorial(n): n! (computed in characteristic 0), of type string.
general_lib.tex(,280) @* factorial(n,p): n! computed in characteristic 0 or prime(p)
general_lib.tex(,281) @* - of type number if a basering is present and 0=p=char(basering)
general_lib.tex(,282) or if prime(p)=char(basering)
general_lib.tex(,283) @* - of type string else
general_lib.tex(,284) 
general_lib.tex(,285) @end table
general_lib.tex(,286) @strong{Example:}
general_lib.tex(,287) @smallexample
general_lib.tex(,288) @c computed example factorial d2t_singular/general_lib.doc:229 
general_lib.tex(,289) LIB "general.lib";
general_lib.tex(,290) factorial(37);"";                 //37! of type string (as long integer)
general_lib.tex(,291) @expansion{} 13763753091226345046315979581580902400000000
general_lib.tex(,292) @expansion{} 
general_lib.tex(,293) ring r1 = 0,x,dp;
general_lib.tex(,294) number p = factorial(37,0);       //37! of type number, computed in r
general_lib.tex(,295) p;
general_lib.tex(,296) @expansion{} 13763753091226345046315979581580902400000000
general_lib.tex(,297) @c end example factorial d2t_singular/general_lib.doc:229
general_lib.tex(,298) @end smallexample
general_lib.tex(,299) @c inserted refs from d2t_singular/general_lib.doc:237
general_lib.tex(,310) @c end inserted refs from d2t_singular/general_lib.doc:237
general_lib.tex(,311) 
general_lib.tex(,312) @c ---end content factorial---
general_lib.tex(,313) 
general_lib.tex(,314) @c ------------------- fibonacci -------------
general_lib.tex(,315) @node fibonacci, kmemory, factorial, general_lib
general_lib.tex(,316) @subsubsection fibonacci
general_lib.tex(,317) @cindex fibonacci
general_lib.tex(,318) @c ---content fibonacci---
general_lib.tex(,319) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,320) 
general_lib.tex(,321) @table @asis
general_lib.tex(,322) @item @strong{Usage:}
general_lib.tex(,323) fibonacci(n); n,p integers
general_lib.tex(,324) 
general_lib.tex(,325) @item @strong{Return:}
general_lib.tex(,326) fibonacci(n): nth Fibonacci number, f(0)=f(1)=1, f(i+1)=f(i-1)+f(i)
general_lib.tex(,327) @* - computed in characteristic 0, of type string
general_lib.tex(,328) @* fibonacci(n,p): f(n) computed in characteristic 0 or prime(p)
general_lib.tex(,329) @* - of type number if a basering is present and p=0=char(basering)
general_lib.tex(,330) or if prime(p)=char(basering)
general_lib.tex(,331) @* - of type string else
general_lib.tex(,332) 
general_lib.tex(,333) @end table
general_lib.tex(,334) @strong{Example:}
general_lib.tex(,335) @smallexample
general_lib.tex(,336) @c computed example fibonacci d2t_singular/general_lib.doc:265 
general_lib.tex(,337) LIB "general.lib";
general_lib.tex(,338) fibonacci(42); "";             //f(42) of type string (as long integer)
general_lib.tex(,339) @expansion{} 267914296
general_lib.tex(,340) @expansion{} 
general_lib.tex(,341) ring r = 2,x,dp;
general_lib.tex(,342) number b = fibonacci(42,2);    //f(42) of type number, computed in r
general_lib.tex(,343) b;
general_lib.tex(,344) @expansion{} 0
general_lib.tex(,345) @c end example fibonacci d2t_singular/general_lib.doc:265
general_lib.tex(,346) @end smallexample
general_lib.tex(,347) @c inserted refs from d2t_singular/general_lib.doc:273
general_lib.tex(,358) @c end inserted refs from d2t_singular/general_lib.doc:273
general_lib.tex(,359) 
general_lib.tex(,360) @c ---end content fibonacci---
general_lib.tex(,361) 
general_lib.tex(,362) @c ------------------- kmemory -------------
general_lib.tex(,363) @node kmemory, killall, fibonacci, general_lib
general_lib.tex(,364) @subsubsection kmemory
general_lib.tex(,365) @cindex kmemory
general_lib.tex(,366) @c ---content kmemory---
general_lib.tex(,367) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,368) 
general_lib.tex(,369) @table @asis
general_lib.tex(,370) @item @strong{Usage:}
general_lib.tex(,371) kmemory([n,[v]]); n,v integers
general_lib.tex(,372) 
general_lib.tex(,373) @item @strong{Return:}
general_lib.tex(,374) memory in kilobyte of type int
general_lib.tex(,375) @* n=0: memory used by active variables (same as no parameters)
general_lib.tex(,376) @* n=1: total memory allocated by Singular
general_lib.tex(,377) @* n=2: difference between top and init memory address (sbrk memory)
general_lib.tex(,378) @* n!=0,1,2: 0
general_lib.tex(,379) 
general_lib.tex(,380) @item @strong{Display:}
general_lib.tex(,381) detailed information about allocated and used memory if v!=0
general_lib.tex(,382) 
general_lib.tex(,383) @item @strong{Note:}
general_lib.tex(,384) kmemory uses internal function 'memory' to compute kilobyte, and
general_lib.tex(,385) is the same as 'memory' for n!=0,1,2
general_lib.tex(,386) 
general_lib.tex(,387) @end table
general_lib.tex(,388) @strong{Example:}
general_lib.tex(,389) @smallexample
general_lib.tex(,390) @c computed example kmemory d2t_singular/general_lib.doc:307 
general_lib.tex(,391) LIB "general.lib";
general_lib.tex(,392) kmemory();
general_lib.tex(,393) @expansion{} 152
general_lib.tex(,394) kmemory(1,1);
general_lib.tex(,395) @expansion{} // total memory allocated, at the moment, by SINGULAR (kilobyte):
general_lib.tex(,396) @expansion{} 650
general_lib.tex(,397) @c end example kmemory d2t_singular/general_lib.doc:307
general_lib.tex(,398) @end smallexample
general_lib.tex(,399) @c ---end content kmemory---
general_lib.tex(,400) 
general_lib.tex(,401) @c ------------------- killall -------------
general_lib.tex(,402) @node killall, number_e, kmemory, general_lib
general_lib.tex(,403) @subsubsection killall
general_lib.tex(,404) @cindex killall
general_lib.tex(,405) @c ---content killall---
general_lib.tex(,406) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,407) 
general_lib.tex(,408) @table @asis
general_lib.tex(,409) @item @strong{Usage:}
general_lib.tex(,410) killall(); (no parameter)
general_lib.tex(,411) @*killall("type_name");
general_lib.tex(,412) @*killall("not", "type_name");
general_lib.tex(,413) 
general_lib.tex(,414) @item @strong{Return:}
general_lib.tex(,415) killall(); kills all user-defined variables except loaded procedures,
general_lib.tex(,416) no return value.
general_lib.tex(,417) @* - killall("type_name"); kills all user-defined variables,
general_lib.tex(,418) of type "type_name"
general_lib.tex(,419) @* - killall("not", "type_name"); kills all user-defined variables,
general_lib.tex(,420) except those of type "type_name" and except loaded procedures
general_lib.tex(,421) @* - killall("not", "name_1", "name_2", ...);
general_lib.tex(,422) kills all user-defined variables, except those of name "name_i"
general_lib.tex(,423) and except loaded procedures
general_lib.tex(,424) 
general_lib.tex(,425) @item @strong{Note:}
general_lib.tex(,426) killall should never be used inside a procedure
general_lib.tex(,427) 
general_lib.tex(,428) @end table
general_lib.tex(,429) @strong{Example:}
general_lib.tex(,430) @smallexample
general_lib.tex(,431) @c computed example killall d2t_singular/general_lib.doc:345 
general_lib.tex(,432) LIB "general.lib";
general_lib.tex(,433) ring rtest; ideal i=x,y,z; string str="hi"; int j = 3;
general_lib.tex(,434) export rtest,i,str,j;       //this makes the local variables global
general_lib.tex(,435) @expansion{} // ** `rtest` is already global
general_lib.tex(,436) @expansion{} // ** `i` is already global
general_lib.tex(,437) @expansion{} // ** `str` is already global
general_lib.tex(,438) @expansion{} // ** `j` is already global
general_lib.tex(,439) listvar();
general_lib.tex(,440) @expansion{} // j                    [0]  int 3
general_lib.tex(,441) @expansion{} // str                  [0]  string hi
general_lib.tex(,442) @expansion{} // rtest                [0]  *ring
general_lib.tex(,443) @expansion{} //      i                    [0]  ideal, 3 generator(s)
general_lib.tex(,444) @expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
general_lib.tex(,445) killall("ring");            // kills all rings
general_lib.tex(,446) @expansion{} // ** killing the basering for level 0
general_lib.tex(,447) listvar();
general_lib.tex(,448) @expansion{} // j                    [0]  int 3
general_lib.tex(,449) @expansion{} // str                  [0]  string hi
general_lib.tex(,450) @expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
general_lib.tex(,451) killall("not", "int");      // kills all variables except int's (and procs)
general_lib.tex(,452) listvar();
general_lib.tex(,453) @expansion{} // j                    [0]  int 3
general_lib.tex(,454) @expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
general_lib.tex(,455) killall();                  // kills all vars except loaded procs
general_lib.tex(,456) listvar();
general_lib.tex(,457) @expansion{} // j                    [0]  int 3
general_lib.tex(,458) @expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
general_lib.tex(,459) @c end example killall d2t_singular/general_lib.doc:345
general_lib.tex(,460) @end smallexample
general_lib.tex(,461) @c ---end content killall---
general_lib.tex(,462) 
general_lib.tex(,463) @c ------------------- number_e -------------
general_lib.tex(,464) @node number_e, number_pi, killall, general_lib
general_lib.tex(,465) @subsubsection number_e
general_lib.tex(,466) @cindex number_e
general_lib.tex(,467) @c ---content number_e---
general_lib.tex(,468) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,469) 
general_lib.tex(,470) @table @asis
general_lib.tex(,471) @item @strong{Usage:}
general_lib.tex(,472) number_e(n); n integer
general_lib.tex(,473) 
general_lib.tex(,474) @item @strong{Return:}
general_lib.tex(,475) Euler number e=exp(1) up to n decimal digits (no rounding)
general_lib.tex(,476) @* - of type string if no basering of char 0 is defined
general_lib.tex(,477) @* - of type number if a basering of char 0 is defined
general_lib.tex(,478) 
general_lib.tex(,479) @item @strong{Display:}
general_lib.tex(,480) decimal format of e if printlevel > 0 (default:printlevel=0 )
general_lib.tex(,481) 
general_lib.tex(,482) @item @strong{Note:}
general_lib.tex(,483) procedure uses algorithm of A.H.J. Sale
general_lib.tex(,484) 
general_lib.tex(,485) @end table
general_lib.tex(,486) @strong{Example:}
general_lib.tex(,487) @smallexample
general_lib.tex(,488) @c computed example number_e d2t_singular/general_lib.doc:385 
general_lib.tex(,489) LIB "general.lib";
general_lib.tex(,490) number_e(30);"";
general_lib.tex(,491) @expansion{} 2.71828182845904523536028747135
general_lib.tex(,492) @expansion{} 
general_lib.tex(,493) ring R = 0,t,lp;
general_lib.tex(,494) number e = number_e(30);
general_lib.tex(,495) e;
general_lib.tex(,496) @expansion{} 13591409142295226176801437356763/5000000000000000000000000000000
general_lib.tex(,497) @c end example number_e d2t_singular/general_lib.doc:385
general_lib.tex(,498) @end smallexample
general_lib.tex(,499) @c ---end content number_e---
general_lib.tex(,500) 
general_lib.tex(,501) @c ------------------- number_pi -------------
general_lib.tex(,502) @node number_pi, primes, number_e, general_lib
general_lib.tex(,503) @subsubsection number_pi
general_lib.tex(,504) @cindex number_pi
general_lib.tex(,505) @c ---content number_pi---
general_lib.tex(,506) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,507) 
general_lib.tex(,508) @table @asis
general_lib.tex(,509) @item @strong{Usage:}
general_lib.tex(,510) number_pi(n); n positive integer
general_lib.tex(,511) 
general_lib.tex(,512) @item @strong{Return:}
general_lib.tex(,513) pi (area of unit circle) up to n decimal digits (no rounding)
general_lib.tex(,514) @* - of type string if no basering of char 0 is defined,
general_lib.tex(,515) @* - of type number, if a basering of char 0 is defined
general_lib.tex(,516) 
general_lib.tex(,517) @item @strong{Display:}
general_lib.tex(,518) decimal format of pi if printlevel > 0 (default:printlevel=0 )
general_lib.tex(,519) 
general_lib.tex(,520) @item @strong{Note:}
general_lib.tex(,521) procedure uses algorithm of S. Rabinowitz
general_lib.tex(,522) 
general_lib.tex(,523) @end table
general_lib.tex(,524) @strong{Example:}
general_lib.tex(,525) @smallexample
general_lib.tex(,526) @c computed example number_pi d2t_singular/general_lib.doc:420 
general_lib.tex(,527) LIB "general.lib";
general_lib.tex(,528) number_pi(11);"";
general_lib.tex(,529) @expansion{} 3.1415926535
general_lib.tex(,530) @expansion{} 
general_lib.tex(,531) ring r = (real,10),t,dp;
general_lib.tex(,532) number pi = number_pi(11); pi;
general_lib.tex(,533) @expansion{} 3.1415926536
general_lib.tex(,534) @c end example number_pi d2t_singular/general_lib.doc:420
general_lib.tex(,535) @end smallexample
general_lib.tex(,536) @c ---end content number_pi---
general_lib.tex(,537) 
general_lib.tex(,538) @c ------------------- primes -------------
general_lib.tex(,539) @node primes, product, number_pi, general_lib
general_lib.tex(,540) @subsubsection primes
general_lib.tex(,541) @cindex primes
general_lib.tex(,542) @c ---content primes---
general_lib.tex(,543) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,544) 
general_lib.tex(,545) @table @asis
general_lib.tex(,546) @item @strong{Usage:}
general_lib.tex(,547) primes(n,m); n,m integers
general_lib.tex(,548) 
general_lib.tex(,549) @item @strong{Return:}
general_lib.tex(,550) intvec, consisting of all primes p, prime(n)<=p<=m, in increasing
general_lib.tex(,551) order if n<=m, resp. prime(m)<=p<=n, in decreasing order if m<n.
general_lib.tex(,552) 
general_lib.tex(,553) @item @strong{Note:}
general_lib.tex(,554) prime(n); returns the biggest prime number <= min(n,32003)
general_lib.tex(,555) if n>=2, else 2
general_lib.tex(,556) 
general_lib.tex(,557) @end table
general_lib.tex(,558) @strong{Example:}
general_lib.tex(,559) @smallexample
general_lib.tex(,560) @c computed example primes d2t_singular/general_lib.doc:451 
general_lib.tex(,561) LIB "general.lib";
general_lib.tex(,562) primes(50,100);"";
general_lib.tex(,563) @expansion{} 47,53,59,61,67,71,73,79,83,89,97
general_lib.tex(,564) @expansion{} 
general_lib.tex(,565) intvec v = primes(37,1); v;
general_lib.tex(,566) @expansion{} 37,31,29,23,19,17,13,11,7,5,3,2
general_lib.tex(,567) @c end example primes d2t_singular/general_lib.doc:451
general_lib.tex(,568) @end smallexample
general_lib.tex(,569) @c ---end content primes---
general_lib.tex(,570) 
general_lib.tex(,571) @c ------------------- product -------------
general_lib.tex(,572) @node product, sort, primes, general_lib
general_lib.tex(,573) @subsubsection product
general_lib.tex(,574) @cindex product
general_lib.tex(,575) @c ---content product---
general_lib.tex(,576) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,577) 
general_lib.tex(,578) @table @asis
general_lib.tex(,579) @item @strong{Usage:}
general_lib.tex(,580) product(id[,v]); id ideal/vector/module/matrix/intvec/intmat/list,
general_lib.tex(,581) v intvec (default: v=1..number of entries of id)
general_lib.tex(,582) 
general_lib.tex(,583) @item @strong{Assume:}
general_lib.tex(,584) list members can be multiplied.
general_lib.tex(,585) 
general_lib.tex(,586) @item @strong{Return:}
general_lib.tex(,587) The product of all entries of id [with index given by v] of type
general_lib.tex(,588) depending on the entries of id.
general_lib.tex(,589) 
general_lib.tex(,590) @item @strong{Note:}
general_lib.tex(,591) If id is not a list, id is treated as a list of polys resp. integers.
general_lib.tex(,592) A module m is identified with the corresponding matrix M (columns
general_lib.tex(,593) of M generate m).
general_lib.tex(,594) @* If v is outside the range of id, we have the empty product and the
general_lib.tex(,595) result will be 1 (of type int).
general_lib.tex(,596) 
general_lib.tex(,597) @end table
general_lib.tex(,598) @strong{Example:}
general_lib.tex(,599) @smallexample
general_lib.tex(,600) @c computed example product d2t_singular/general_lib.doc:488 
general_lib.tex(,601) LIB "general.lib";
general_lib.tex(,602) ring r= 0,(x,y,z),dp;
general_lib.tex(,603) ideal m = maxideal(1);
general_lib.tex(,604) product(m);
general_lib.tex(,605) @expansion{} xyz
general_lib.tex(,606) product(m[2..3]);
general_lib.tex(,607) @expansion{} yz
general_lib.tex(,608) matrix M[2][3] = 1,x,2,y,3,z;
general_lib.tex(,609) product(M);
general_lib.tex(,610) @expansion{} 6xyz
general_lib.tex(,611) intvec v=2,4,6;
general_lib.tex(,612) product(M,v);
general_lib.tex(,613) @expansion{} xyz
general_lib.tex(,614) intvec iv = 1,2,3,4,5,6,7,8,9;
general_lib.tex(,615) v=1..5,7,9;
general_lib.tex(,616) product(iv,v);
general_lib.tex(,617) @expansion{} 7560
general_lib.tex(,618) intmat A[2][3] = 1,1,1,2,2,2;
general_lib.tex(,619) product(A,3..5);
general_lib.tex(,620) @expansion{} 4
general_lib.tex(,621) @c end example product d2t_singular/general_lib.doc:488
general_lib.tex(,622) @end smallexample
general_lib.tex(,623) @c ---end content product---
general_lib.tex(,624) 
general_lib.tex(,625) @c ------------------- sort -------------
general_lib.tex(,626) @node sort, sum, product, general_lib
general_lib.tex(,627) @subsubsection sort
general_lib.tex(,628) @cindex sort
general_lib.tex(,629) @c ---content sort---
general_lib.tex(,630) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,631) 
general_lib.tex(,632) @table @asis
general_lib.tex(,633) @item @strong{Usage:}
general_lib.tex(,634) sort(id[v,o,n]); id = ideal/module/intvec/list(of intvec's or int's)
general_lib.tex(,635) @* sort may be called with 1, 2 or 3 arguments in the following way:
general_lib.tex(,636) @* sort(id[v,n]); v=intvec of positive integers, n=integer,
general_lib.tex(,637) @* sort(id[o,n]); o=string (any allowed ordstr of a ring), n=integer
general_lib.tex(,638) 
general_lib.tex(,639) @item @strong{Return:}
general_lib.tex(,640) a list l of two elements:
general_lib.tex(,641) @format
general_lib.tex(,642)         l[1]: object of same type as input but sorted in the following way:
general_lib.tex(,643)            - if id=ideal/module: generators of id are sorted w.r.t. intvec v
general_lib.tex(,644)              (id[v[1]] becomes 1-st, id[v[2]]  2-nd element, etc.). If no v is
general_lib.tex(,645)              present, id is sorted w.r.t. ordering o (if o is given) or w.r.t.
general_lib.tex(,646)              actual monomial ordering (if no o is given):
general_lib.tex(,647)              NOTE: generators with SMALLER(!) leading term come FIRST
general_lib.tex(,648)              (e.g. sort(id); sorts backwards to actual monomial ordering)
general_lib.tex(,649)            - if id=list of intvec's or int's: consider a list element, say
general_lib.tex(,650)              id[1]=3,2,5, as exponent vector of the monomial x^3*y^2*z^5;
general_lib.tex(,651)              the corresponding monomials are ordered w.r.t. intvec v (s.a.).
general_lib.tex(,652)              If no v is present, the monomials are sorted w.r.t. ordering o
general_lib.tex(,653)              (if o is given) or w.r.t. lexicographical ordering (if no o is
general_lib.tex(,654)              given). The corresponding ordered list of exponent vectors is
general_lib.tex(,655)              returned.
general_lib.tex(,656)              (e.g. sort(id); sorts lexicographically, smaller int's come first)
general_lib.tex(,657)              WARNING: Since negative exponents create the 0 polynomial in
general_lib.tex(,658)              Singular, id should not contain negative integers: the result
general_lib.tex(,659)              might not be as expected
general_lib.tex(,660)            - if id=intvec: id is treated as list of integers
general_lib.tex(,661)            - if n!=0 the ordering is inverse, i.e. w.r.t. v(size(v)..1)
general_lib.tex(,662)              default: n=0
general_lib.tex(,663)          l[2]: intvec, describing the permutation of the input (hence l[2]=v
general_lib.tex(,664)              if v is given (with positive integers))
general_lib.tex(,665) @end format
general_lib.tex(,666) 
general_lib.tex(,667) @item @strong{Note:}
general_lib.tex(,668) If v is given id may be any simply indexed object (e.g. any list or
general_lib.tex(,669) string); if v[i]<0 and i<=size(id) v[i] is set internally to i;
general_lib.tex(,670) entries of v must be pairwise distinct to get a permutation if id.
general_lib.tex(,671) Zero generators of ideal/module are deleted
general_lib.tex(,672) 
general_lib.tex(,673) @end table
general_lib.tex(,674) @strong{Example:}
general_lib.tex(,675) @smallexample
general_lib.tex(,676) @c computed example sort d2t_singular/general_lib.doc:558 
general_lib.tex(,677) LIB "general.lib";
general_lib.tex(,678) ring r0 = 0,(x,y,z,t),lp;
general_lib.tex(,679) ideal i = x3,z3,xyz;
general_lib.tex(,680) sort(i);            //sorts using lex ordering, smaller polys come first
general_lib.tex(,681) @expansion{} [1]:
general_lib.tex(,682) @expansion{}    _[1]=z3
general_lib.tex(,683) @expansion{}    _[2]=xyz
general_lib.tex(,684) @expansion{}    _[3]=x3
general_lib.tex(,685) @expansion{} [2]:
general_lib.tex(,686) @expansion{}    2,3,1
general_lib.tex(,687) sort(i,3..1);
general_lib.tex(,688) @expansion{} [1]:
general_lib.tex(,689) @expansion{}    _[1]=xyz
general_lib.tex(,690) @expansion{}    _[2]=z3
general_lib.tex(,691) @expansion{}    _[3]=x3
general_lib.tex(,692) @expansion{} [2]:
general_lib.tex(,693) @expansion{}    3,2,1
general_lib.tex(,694) sort(i,"ls")[1];     //sort w.r.t. negative lex ordering
general_lib.tex(,695) @expansion{} _[1]=x3
general_lib.tex(,696) @expansion{} _[2]=xyz
general_lib.tex(,697) @expansion{} _[3]=z3
general_lib.tex(,698) intvec v =1,10..5,2..4;v;
general_lib.tex(,699) @expansion{} 1,10,9,8,7,6,5,2,3,4
general_lib.tex(,700) sort(v)[1];          // sort v lexicographically
general_lib.tex(,701) @expansion{} 1,2,3,4,5,6,7,8,9,10
general_lib.tex(,702) sort(v,"Dp",1)[1];   // sort v w.r.t (total sum, reverse lex)
general_lib.tex(,703) @expansion{} 10,9,8,7,6,5,4,3,2,1
general_lib.tex(,704) @c end example sort d2t_singular/general_lib.doc:558
general_lib.tex(,705) @end smallexample
general_lib.tex(,706) @c ---end content sort---
general_lib.tex(,707) 
general_lib.tex(,708) @c ------------------- sum -------------
general_lib.tex(,709) @node sum, watchdog, sort, general_lib
general_lib.tex(,710) @subsubsection sum
general_lib.tex(,711) @cindex sum
general_lib.tex(,712) @c ---content sum---
general_lib.tex(,713) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,714) 
general_lib.tex(,715) @table @asis
general_lib.tex(,716) @item @strong{Usage:}
general_lib.tex(,717) sum(id[,v]); id ideal/vector/module/matrix/intvec/intmat/list,
general_lib.tex(,718) v intvec (default: v=1..number of entries of id)
general_lib.tex(,719) 
general_lib.tex(,720) @item @strong{Assume:}
general_lib.tex(,721) list members can be added.
general_lib.tex(,722) 
general_lib.tex(,723) @item @strong{Return:}
general_lib.tex(,724) The sum of all entries of id [with index given by v] of type
general_lib.tex(,725) depending on the entries of id.
general_lib.tex(,726) 
general_lib.tex(,727) @item @strong{Note:}
general_lib.tex(,728) If id is not a list, id is treated as a list of polys resp. integers.
general_lib.tex(,729) A module m is identified with the corresponding matrix M (columns
general_lib.tex(,730) of M generate m).
general_lib.tex(,731) @* If v is outside the range of id, we have the empty sum and the
general_lib.tex(,732) result will be 0 (of type int).
general_lib.tex(,733) 
general_lib.tex(,734) @end table
general_lib.tex(,735) @strong{Example:}
general_lib.tex(,736) @smallexample
general_lib.tex(,737) @c computed example sum d2t_singular/general_lib.doc:601 
general_lib.tex(,738) LIB "general.lib";
general_lib.tex(,739) ring r= 0,(x,y,z),dp;
general_lib.tex(,740) vector pv = [xy,xz,yz,x2,y2,z2];
general_lib.tex(,741) sum(pv);
general_lib.tex(,742) @expansion{} x2+xy+y2+xz+yz+z2
general_lib.tex(,743) sum(pv,2..5);
general_lib.tex(,744) @expansion{} x2+y2+xz+yz
general_lib.tex(,745) matrix M[2][3] = 1,x,2,y,3,z;
general_lib.tex(,746) intvec w=2,4,6;
general_lib.tex(,747) sum(M,w);
general_lib.tex(,748) @expansion{} x+y+z
general_lib.tex(,749) intvec iv = 1,2,3,4,5,6,7,8,9;
general_lib.tex(,750) sum(iv,2..4);
general_lib.tex(,751) @expansion{} 9
general_lib.tex(,752) @c end example sum d2t_singular/general_lib.doc:601
general_lib.tex(,753) @end smallexample
general_lib.tex(,754) @c ---end content sum---
general_lib.tex(,755) 
general_lib.tex(,756) @c ------------------- watchdog -------------
general_lib.tex(,757) @node watchdog, which, sum, general_lib
general_lib.tex(,758) @subsubsection watchdog
general_lib.tex(,759) @cindex watchdog
general_lib.tex(,760) @c ---content watchdog---
general_lib.tex(,761) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,762) 
general_lib.tex(,763) @table @asis
general_lib.tex(,764) @item @strong{Return:}
general_lib.tex(,765) Result of cmd, if the result can be computed in i seconds.
general_lib.tex(,766) Otherwise the computation is interrupted after i seconds,
general_lib.tex(,767) the string "Killed" is returned and the global variable
general_lib.tex(,768) 'watchdog_interrupt' is defined.
general_lib.tex(,769) 
general_lib.tex(,770) @item @strong{Note:}
general_lib.tex(,771) * the MP package must be enabled
general_lib.tex(,772) @** the current basering should not be watchdog_rneu, since
general_lib.tex(,773) watchdog_rneu will be killed
general_lib.tex(,774) @** if there are variable names of the structure x(i) all
general_lib.tex(,775) polynomials have to be put into eval(...) in order to be
general_lib.tex(,776) interpreted correctly
general_lib.tex(,777) @** a second Singular process is started by this procedure
general_lib.tex(,778) 
general_lib.tex(,779) @end table
general_lib.tex(,780) @strong{Example:}
general_lib.tex(,781) @smallexample
general_lib.tex(,782) @c computed example watchdog d2t_singular/general_lib.doc:642 
general_lib.tex(,783) LIB "general.lib";
general_lib.tex(,784) ring r=0,(x,y,z),dp;
general_lib.tex(,785) poly f=x^30+y^30;
general_lib.tex(,786) watchdog(1,"factorize(eval("+string(f)+"))");
general_lib.tex(,787) @expansion{} [1]:
general_lib.tex(,788) @expansion{}    _[1]=1
general_lib.tex(,789) @expansion{}    _[2]=x16+x14y2-x10y6-x8y8-x6y10+x2y14+y16
general_lib.tex(,790) @expansion{}    _[3]=x8-x6y2+x4y4-x2y6+y8
general_lib.tex(,791) @expansion{}    _[4]=x4-x2y2+y4
general_lib.tex(,792) @expansion{}    _[5]=x2+y2
general_lib.tex(,793) @expansion{} [2]:
general_lib.tex(,794) @expansion{}    1,1,1,1,1
general_lib.tex(,795) watchdog(100,"factorize(eval("+string(f)+"))");
general_lib.tex(,796) @expansion{} [1]:
general_lib.tex(,797) @expansion{}    _[1]=1
general_lib.tex(,798) @expansion{}    _[2]=x16+x14y2-x10y6-x8y8-x6y10+x2y14+y16
general_lib.tex(,799) @expansion{}    _[3]=x8-x6y2+x4y4-x2y6+y8
general_lib.tex(,800) @expansion{}    _[4]=x4-x2y2+y4
general_lib.tex(,801) @expansion{}    _[5]=x2+y2
general_lib.tex(,802) @expansion{} [2]:
general_lib.tex(,803) @expansion{}    1,1,1,1,1
general_lib.tex(,804) @c end example watchdog d2t_singular/general_lib.doc:642
general_lib.tex(,805) @end smallexample
general_lib.tex(,806) @c ---end content watchdog---
general_lib.tex(,807) 
general_lib.tex(,808) @c ------------------- which -------------
general_lib.tex(,809) @node which, primecoeffs, watchdog, general_lib
general_lib.tex(,810) @subsubsection which
general_lib.tex(,811) @cindex which
general_lib.tex(,812) @c ---content which---
general_lib.tex(,813) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,814) 
general_lib.tex(,815) @table @asis
general_lib.tex(,816) @item @strong{Usage:}
general_lib.tex(,817) which(command); command = string expression
general_lib.tex(,818) 
general_lib.tex(,819) @item @strong{Return:}
general_lib.tex(,820) Absolute pathname of command, if found in search path.
general_lib.tex(,821) Empty string, otherwise.
general_lib.tex(,822) 
general_lib.tex(,823) @item @strong{Note:}
general_lib.tex(,824) Based on the Unix command 'which'.
general_lib.tex(,825) 
general_lib.tex(,826) @end table
general_lib.tex(,827) @strong{Example:}
general_lib.tex(,828) @smallexample
general_lib.tex(,829) @c computed example which d2t_singular/general_lib.doc:673 
general_lib.tex(,830) LIB "general.lib";
general_lib.tex(,831) which("sh");
general_lib.tex(,832) @expansion{} /bin/sh
general_lib.tex(,833) @c end example which d2t_singular/general_lib.doc:673
general_lib.tex(,834) @end smallexample
general_lib.tex(,835) @c ---end content which---
general_lib.tex(,836) 
general_lib.tex(,837) @c ------------------- primecoeffs -------------
general_lib.tex(,838) @node primecoeffs, primefactors, which, general_lib
general_lib.tex(,839) @subsubsection primecoeffs
general_lib.tex(,840) @cindex primecoeffs
general_lib.tex(,841) @c ---content primecoeffs---
general_lib.tex(,842) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,843) 
general_lib.tex(,844) @table @asis
general_lib.tex(,845) @item @strong{Usage:}
general_lib.tex(,846) primecoeffs(J[,q]); J any type which can be converted to a matrix
general_lib.tex(,847) e.g. ideal, matrix, vector, module, int, intvec
general_lib.tex(,848) @*q = intger
general_lib.tex(,849) 
general_lib.tex(,850) @item @strong{Compute:}
general_lib.tex(,851) primefactors <= min(p,32003) of coeffs of J (default p = 32003)
general_lib.tex(,852) 
general_lib.tex(,853) @item @strong{Return:}
general_lib.tex(,854) a list, say l, of two intvectors:
general_lib.tex(,855) @*l[1] : the different primefactors of all coefficients of J
general_lib.tex(,856) l[2] : the different remaining factors
general_lib.tex(,857) 
general_lib.tex(,858) @item @strong{Note:}
general_lib.tex(,859) the procedure works for small integers only, just by testing all
general_lib.tex(,860) primes (not to be considerd as serious prime factorization!)
general_lib.tex(,861) 
general_lib.tex(,862) @end table
general_lib.tex(,863) @strong{Example:}
general_lib.tex(,864) @smallexample
general_lib.tex(,865) @c computed example primecoeffs d2t_singular/general_lib.doc:708 
general_lib.tex(,866) LIB "general.lib";
general_lib.tex(,867) primecoeffs(intvec(7*8*121,7*8));"";
general_lib.tex(,868) @expansion{} [1]:
general_lib.tex(,869) @expansion{}    2,7,11
general_lib.tex(,870) @expansion{} [2]:
general_lib.tex(,871) @expansion{}    1
general_lib.tex(,872) @expansion{} 
general_lib.tex(,873) ring r = 0,(b,c,t),dp;
general_lib.tex(,874) ideal I = -13b6c3t+4b5c4t,-10b4c2t-5b4ct2;
general_lib.tex(,875) primecoeffs(I);
general_lib.tex(,876) @expansion{} [1]:
general_lib.tex(,877) @expansion{}    2,5,13
general_lib.tex(,878) @expansion{} [2]:
general_lib.tex(,879) @expansion{}    _[1]=1
general_lib.tex(,880) @c end example primecoeffs d2t_singular/general_lib.doc:708
general_lib.tex(,881) @end smallexample
general_lib.tex(,882) @c ---end content primecoeffs---
general_lib.tex(,883) 
general_lib.tex(,884) @c ------------------- primefactors -------------
general_lib.tex(,885) @node primefactors, timeStd, primecoeffs, general_lib
general_lib.tex(,886) @subsubsection primefactors
general_lib.tex(,887) @cindex primefactors
general_lib.tex(,888) @c ---content primefactors---
general_lib.tex(,889) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,890) 
general_lib.tex(,891) @table @asis
general_lib.tex(,892) @item @strong{Usage:}
general_lib.tex(,893) primefactors(n [,p]); n = int or number, p = integer
general_lib.tex(,894) 
general_lib.tex(,895) @item @strong{Compute:}
general_lib.tex(,896) primefactors <= min(p,32003) of n (default p = 32003)
general_lib.tex(,897) 
general_lib.tex(,898) @item @strong{Return:}
general_lib.tex(,899) a list, say l,
general_lib.tex(,900) @*l[1] : primefactors <= min(p,32003) of n
general_lib.tex(,901) @*l[2] : l[2][i] = multiplicity of l[1][i]
general_lib.tex(,902) @*l[3] : remaining factor ( n=product@{ (l[1][i]^l[2][i])*l[3]@} )
general_lib.tex(,903) type(l[3])=typeof(n)
general_lib.tex(,904) 
general_lib.tex(,905) @item @strong{Note:}
general_lib.tex(,906) If n is a long integer (of type number) then the procedure
general_lib.tex(,907) finds primefactors <= min(p,32003) but n may be larger as
general_lib.tex(,908) 2147483647 (max. integer representation)
general_lib.tex(,909) 
general_lib.tex(,910) @item @strong{Warning:}
general_lib.tex(,911) the procedure works for small integers only, just by testing all
general_lib.tex(,912) primes (not to be considerd as serious prime factorization!)
general_lib.tex(,913) 
general_lib.tex(,914) @end table
general_lib.tex(,915) @strong{Example:}
general_lib.tex(,916) @smallexample
general_lib.tex(,917) @c computed example primefactors d2t_singular/general_lib.doc:751 
general_lib.tex(,918) LIB "general.lib";
general_lib.tex(,919) primefactors(7*8*121);
general_lib.tex(,920) @expansion{} [1]:
general_lib.tex(,921) @expansion{}    2,7,11
general_lib.tex(,922) @expansion{} [2]:
general_lib.tex(,923) @expansion{}    3,1,2
general_lib.tex(,924) @expansion{} [3]:
general_lib.tex(,925) @expansion{}    1
general_lib.tex(,926) ring r = 0,x,dp;
general_lib.tex(,927) primefactors(123456789100);
general_lib.tex(,928) @expansion{} [1]:
general_lib.tex(,929) @expansion{}    2,5
general_lib.tex(,930) @expansion{} [2]:
general_lib.tex(,931) @expansion{}    2,2
general_lib.tex(,932) @expansion{} [3]:
general_lib.tex(,933) @expansion{}    1234567891
general_lib.tex(,934) @c end example primefactors d2t_singular/general_lib.doc:751
general_lib.tex(,935) @end smallexample
general_lib.tex(,936) @c ---end content primefactors---
general_lib.tex(,937) 
general_lib.tex(,938) @c ------------------- timeStd -------------
general_lib.tex(,939) @node timeStd, timeFactorize, primefactors, general_lib
general_lib.tex(,940) @subsubsection timeStd
general_lib.tex(,941) @cindex timeStd
general_lib.tex(,942) @c ---content timeStd---
general_lib.tex(,943) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,944) 
general_lib.tex(,945) @table @asis
general_lib.tex(,946) @item @strong{Usage:}
general_lib.tex(,947) timeStd(i,d), i ideal, d integer
general_lib.tex(,948) 
general_lib.tex(,949) @item @strong{Return:}
general_lib.tex(,950) std(i) if the standard basis computation finished after
general_lib.tex(,951) d-1 seconds and i otherwise
general_lib.tex(,952) 
general_lib.tex(,953) @end table
general_lib.tex(,954) @strong{Example:}
general_lib.tex(,955) @smallexample
general_lib.tex(,956) @c computed example timeStd d2t_singular/general_lib.doc:778 
general_lib.tex(,957) LIB "general.lib";
general_lib.tex(,958) ring r=32003,(a,b,c,d,e),dp;
general_lib.tex(,959) int n=6;
general_lib.tex(,960) ideal i=
general_lib.tex(,961) a^n-b^n,
general_lib.tex(,962) b^n-c^n,
general_lib.tex(,963) c^n-d^n,
general_lib.tex(,964) d^n-e^n,
general_lib.tex(,965) a^(n-1)*b+b^(n-1)*c+c^(n-1)*d+d^(n-1)*e+e^(n-1)*a;
general_lib.tex(,966) ideal j=timeStd(i,2);
general_lib.tex(,967) j;
general_lib.tex(,968) @expansion{} j[1]=a6-b6
general_lib.tex(,969) @expansion{} j[2]=b6-c6
general_lib.tex(,970) @expansion{} j[3]=c6-d6
general_lib.tex(,971) @expansion{} j[4]=d6-e6
general_lib.tex(,972) @expansion{} j[5]=a5b+b5c+c5d+d5e+ae5
general_lib.tex(,973) @c end example timeStd d2t_singular/general_lib.doc:778
general_lib.tex(,974) @end smallexample
general_lib.tex(,975) @c ---end content timeStd---
general_lib.tex(,976) 
general_lib.tex(,977) @c ------------------- timeFactorize -------------
general_lib.tex(,978) @node timeFactorize, factorH, timeStd, general_lib
general_lib.tex(,979) @subsubsection timeFactorize
general_lib.tex(,980) @cindex timeFactorize
general_lib.tex(,981) @c ---content timeFactorize---
general_lib.tex(,982) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,983) 
general_lib.tex(,984) @table @asis
general_lib.tex(,985) @item @strong{Usage:}
general_lib.tex(,986) timeFactorize(p,d) poly p , integer d
general_lib.tex(,987) 
general_lib.tex(,988) @item @strong{Return:}
general_lib.tex(,989) factorize(p) if the factorization finished after d-1
general_lib.tex(,990) @*seconds otherwise f is considered to be irreducible
general_lib.tex(,991) 
general_lib.tex(,992) @end table
general_lib.tex(,993) @strong{Example:}
general_lib.tex(,994) @smallexample
general_lib.tex(,995) @c computed example timeFactorize d2t_singular/general_lib.doc:812 
general_lib.tex(,996) LIB "general.lib";
general_lib.tex(,997) ring r=0,(x,y),dp;
general_lib.tex(,998) poly p=((x2+y3)^2+xy6)*((x3+y2)^2+x10y);
general_lib.tex(,999) p=p^2;
general_lib.tex(,1000) list l=timeFactorize(p,2);
general_lib.tex(,1001) l;
general_lib.tex(,1002) @expansion{} [1]:
general_lib.tex(,1003) @expansion{}    [1]:
general_lib.tex(,1004) @expansion{}       1
general_lib.tex(,1005) @expansion{}    [2]:
general_lib.tex(,1006) @expansion{}       x22y14+2x21y14+4x23y11+x20y14+2x25y8+4x22y11+6x24y8+4x26y5+2x18y13+\
general_lib.tex(,1007)    x28y2+4x17y13+4x15y15+8x19y10+2x16y13+8x14y15+2x12y17+4x21y7+8x18y10+16x1\
general_lib.tex(,1008)    6y12+4x13y15+4x11y17+12x20y7+8x18y9+16x15y12+8x13y14+2x10y17+8x22y4+24x17\
general_lib.tex(,1009)    y9+4x15y11+x14y12+8x12y14+2x24y+16x19y6+12x14y11+2x13y12+4x11y14+4x21y3+8\
general_lib.tex(,1010)    x16y8+4x15y9+x12y12+8x10y14+6x8y16+2x18y5+2x17y6+4x14y9+16x12y11+4x9y14+1\
general_lib.tex(,1011)    2x7y16+4x5y18+6x16y6+8x14y8+16x11y11+24x9y13+6x6y16+8x4y18+x2y20+4x18y3+2\
general_lib.tex(,1012)    4x13y8+12x11y10+24x8y13+16x6y15+4x3y18+2xy20+x20+16x15y5+36x10y10+8x8y12+\
general_lib.tex(,1013)    16x5y15+4x3y17+y20+4x17y2+24x12y7+24x7y12+2x5y14+4x2y17+6x14y4+16x9y9+6x4\
general_lib.tex(,1014)    y14+4x11y6+4x6y11+x8y8
general_lib.tex(,1015) @expansion{} [2]:
general_lib.tex(,1016) @expansion{}    1,1
general_lib.tex(,1017) @c end example timeFactorize d2t_singular/general_lib.doc:812
general_lib.tex(,1018) @end smallexample
general_lib.tex(,1019) @c ---end content timeFactorize---
general_lib.tex(,1020) 
general_lib.tex(,1021) @c ------------------- factorH -------------
general_lib.tex(,1022) @node factorH,, timeFactorize, general_lib
general_lib.tex(,1023) @subsubsection factorH
general_lib.tex(,1024) @cindex factorH
general_lib.tex(,1025) @c ---content factorH---
general_lib.tex(,1026) Procedure from library @code{general.lib} (@pxref{general_lib}).
general_lib.tex(,1027) 
general_lib.tex(,1028) @table @asis
general_lib.tex(,1029) @item @strong{Usage:}
general_lib.tex(,1030) factorH(p) p poly
general_lib.tex(,1031) 
general_lib.tex(,1032) @item @strong{Return:}
general_lib.tex(,1033) factorize(p)
general_lib.tex(,1034) 
general_lib.tex(,1035) @item @strong{Note:}
general_lib.tex(,1036) changes variables to become the last variable the principal
general_lib.tex(,1037) one in the multivariate factorization and factorizes then
general_lib.tex(,1038) the polynomial
general_lib.tex(,1039) 
general_lib.tex(,1040) @end table
general_lib.tex(,1041) @strong{Example:}
general_lib.tex(,1042) @smallexample
general_lib.tex(,1043) @c computed example factorH d2t_singular/general_lib.doc:845 
general_lib.tex(,1044) LIB "general.lib";
general_lib.tex(,1045) system("random",992851144);
general_lib.tex(,1046) ring r=32003,(x,y,z,w,t),lp;
general_lib.tex(,1047) poly p=y2w9+yz7t-yz5w4-z2w4t4-w8t3;
general_lib.tex(,1048) //factorize(p);  //fast
general_lib.tex(,1049) //system("random",992851262);
general_lib.tex(,1050) //factorize(p);  //slow
general_lib.tex(,1051) //system("random",992851262);
general_lib.tex(,1052) factorH(p);
general_lib.tex(,1053) @expansion{} [1]:
general_lib.tex(,1054) @expansion{}    _[1]=1
general_lib.tex(,1055) @expansion{}    _[2]=y2w9+yz7t-yz5w4-z2w4t4-w8t3
general_lib.tex(,1056) @expansion{} [2]:
general_lib.tex(,1057) @expansion{}    1,1
general_lib.tex(,1058) @c end example factorH d2t_singular/general_lib.doc:845
general_lib.tex(,1059) @end smallexample
general_lib.tex(,1060) @c ---end content factorH---
singular.texi(,312) @c ----------------------------------------------------------
singular.texi(,313) @node inout_lib, poly_lib, general_lib, General purpose
singular.texi(,314) @subsection inout_lib
singular.texi(,315) @c include of docu for inout.lib
inout_lib.tex(,1) @c ---content LibInfo---
inout_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/inout_lib.doc
inout_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/inout_lib.doc INSTEAD
inout_lib.tex(,4) @c library version: (1.21.2.5,2002/06/12)
inout_lib.tex(,5) @c library file: ../Singular/LIB/inout.lib
inout_lib.tex(,6) @cindex inout.lib
inout_lib.tex(,7) @cindex inout_lib
inout_lib.tex(,8) @table @asis
inout_lib.tex(,9) @item @strong{Library:}
inout_lib.tex(,10) inout.lib
inout_lib.tex(,11) @item @strong{Purpose:}
inout_lib.tex(,12)      Printing and Manipulating In- and Output
inout_lib.tex(,13) 
inout_lib.tex(,14) @end table
inout_lib.tex(,15) 
inout_lib.tex(,16) @strong{Procedures:}
inout_lib.tex(,17) @menu
inout_lib.tex(,18) * allprint:: print list if ALLprint is defined, with pause if >0
inout_lib.tex(,19) * lprint:: display poly/... fitting to pagewidth [size n]
inout_lib.tex(,20) * pmat:: print form-matrix [first n chars of each column]
inout_lib.tex(,21) * rMacaulay:: read Macaulay_1 output and return its Singular format
inout_lib.tex(,22) * show:: display any object in a compact format
inout_lib.tex(,23) * showrecursive:: display id recursively with respect to variables in p
inout_lib.tex(,24) * split:: split given string into lines of length n
inout_lib.tex(,25) * tab:: string of n space tabs
inout_lib.tex(,26) * writelist:: write a list into a file and keep the list structure
inout_lib.tex(,27) * pause:: stop the computation until user input
inout_lib.tex(,28) @end menu
inout_lib.tex(,29) @c ---end content LibInfo---
inout_lib.tex(,30) 
inout_lib.tex(,31) @c ------------------- allprint -------------
inout_lib.tex(,32) @node allprint, lprint,, inout_lib
inout_lib.tex(,33) @subsubsection allprint
inout_lib.tex(,34) @cindex allprint
inout_lib.tex(,35) @c ---content allprint---
inout_lib.tex(,36) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,37) 
inout_lib.tex(,38) @table @asis
inout_lib.tex(,39) @item @strong{Usage:}
inout_lib.tex(,40) allprint(L); L list
inout_lib.tex(,41) 
inout_lib.tex(,42) @item @strong{Display:}
inout_lib.tex(,43) prints L[1], L[2], ... if an integer with name ALLprint is defined.
inout_lib.tex(,44) @* makes "pause", if ALLprint > 0
inout_lib.tex(,45) @* listvar(matrix), if ALLprint = 2
inout_lib.tex(,46) 
inout_lib.tex(,47) @item @strong{Return:}
inout_lib.tex(,48) no return value
inout_lib.tex(,49) 
inout_lib.tex(,50) @end table
inout_lib.tex(,51) @strong{Example:}
inout_lib.tex(,52) @smallexample
inout_lib.tex(,53) @c computed example allprint d2t_singular/inout_lib.doc:51 
inout_lib.tex(,54) LIB "inout.lib";
inout_lib.tex(,55) ring S;
inout_lib.tex(,56) matrix M=matrix(freemodule(2),3,3);
inout_lib.tex(,57) int ALLprint; export ALLprint;
inout_lib.tex(,58) @expansion{} // ** `ALLprint` is already global
inout_lib.tex(,59) allprint("M =",M);
inout_lib.tex(,60) @expansion{} M =
inout_lib.tex(,61) @expansion{} 1,0,0,
inout_lib.tex(,62) @expansion{} 0,1,0,
inout_lib.tex(,63) @expansion{} 0,0,0 
inout_lib.tex(,64) kill ALLprint;
inout_lib.tex(,65) @c end example allprint d2t_singular/inout_lib.doc:51
inout_lib.tex(,66) @end smallexample
inout_lib.tex(,67) @c ---end content allprint---
inout_lib.tex(,68) 
inout_lib.tex(,69) @c ------------------- lprint -------------
inout_lib.tex(,70) @node lprint, pmat, allprint, inout_lib
inout_lib.tex(,71) @subsubsection lprint
inout_lib.tex(,72) @cindex lprint
inout_lib.tex(,73) @c ---content lprint---
inout_lib.tex(,74) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,75) 
inout_lib.tex(,76) @table @asis
inout_lib.tex(,77) @item @strong{Usage:}
inout_lib.tex(,78) lprint(id[,n]); id poly/ideal/vector/module/matrix, n integer
inout_lib.tex(,79) 
inout_lib.tex(,80) @item @strong{Return:}
inout_lib.tex(,81) string of id in a format fitting into lines of size n, such that no
inout_lib.tex(,82) monomial is destroyed, i.e. the new line starts with + or -;
inout_lib.tex(,83) (default: n = pagewidth).
inout_lib.tex(,84) 
inout_lib.tex(,85) @item @strong{Note:}
inout_lib.tex(,86) id is printed columnwise, each column separated by a blank line;
inout_lib.tex(,87) hence lprint(transpose(id)); displays a matrix id in a format which
inout_lib.tex(,88) can be used as input.
inout_lib.tex(,89) 
inout_lib.tex(,90) @end table
inout_lib.tex(,91) @strong{Example:}
inout_lib.tex(,92) @smallexample
inout_lib.tex(,93) @c computed example lprint d2t_singular/inout_lib.doc:86 
inout_lib.tex(,94) LIB "inout.lib";
inout_lib.tex(,95) ring r= 0,(x,y,z),ds;
inout_lib.tex(,96) poly f=((x+y)*(x-y)*(x+z)*(y+z)^2);
inout_lib.tex(,97) lprint(f,40);
inout_lib.tex(,98) @expansion{}   x3y2-xy4+2x3yz+x2y2z-2xy3z-y4z+x3z2
inout_lib.tex(,99) @expansion{} +2x2yz2-xy2z2-2y3z2+x2z3-y2z3
inout_lib.tex(,100) module m = [f*(x-y)],[0,f*(x-y)];
inout_lib.tex(,101) string s=lprint(m); s;"";
inout_lib.tex(,102) @expansion{}   x4y2-x3y3-x2y4+xy5+2x4yz-x3y2z-3x2y3z+xy4z+y5z+x4z2+x3yz2-3x2y2z2-xy3z2
inout_lib.tex(,103) @expansion{} +2y4z2+x3z3-x2yz3-xy2z3+y3z3,
inout_lib.tex(,104) @expansion{}   0,
inout_lib.tex(,105) @expansion{} 
inout_lib.tex(,106) @expansion{}   0,
inout_lib.tex(,107) @expansion{}   x4y2-x3y3-x2y4+xy5+2x4yz-x3y2z-3x2y3z+xy4z+y5z+x4z2+x3yz2-3x2y2z2-xy3z2
inout_lib.tex(,108) @expansion{} +2y4z2+x3z3-x2yz3-xy2z3+y3z3
inout_lib.tex(,109) @expansion{} 
inout_lib.tex(,110) execute("matrix M[2][2]="+s+";");      //use the string s as input
inout_lib.tex(,111) module m1 = transpose(M);	          //should be the same as m
inout_lib.tex(,112) print(m-m1);
inout_lib.tex(,113) @expansion{} 0,0,
inout_lib.tex(,114) @expansion{} 0,0 
inout_lib.tex(,115) @c end example lprint d2t_singular/inout_lib.doc:86
inout_lib.tex(,116) @end smallexample
inout_lib.tex(,117) @c ---end content lprint---
inout_lib.tex(,118) 
inout_lib.tex(,119) @c ------------------- pmat -------------
inout_lib.tex(,120) @node pmat, rMacaulay, lprint, inout_lib
inout_lib.tex(,121) @subsubsection pmat
inout_lib.tex(,122) @cindex pmat
inout_lib.tex(,123) @c ---content pmat---
inout_lib.tex(,124) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,125) 
inout_lib.tex(,126) @table @asis
inout_lib.tex(,127) @item @strong{Usage:}
inout_lib.tex(,128) pmat(M,[n]); M matrix, n integer
inout_lib.tex(,129) 
inout_lib.tex(,130) @item @strong{Display:}
inout_lib.tex(,131) display M in array format if it fits into pagewidth; if n is given,
inout_lib.tex(,132) only the first n characters of each column are shown
inout_lib.tex(,133) 
inout_lib.tex(,134) @item @strong{Return:}
inout_lib.tex(,135) no return value
inout_lib.tex(,136) 
inout_lib.tex(,137) @end table
inout_lib.tex(,138) @strong{Example:}
inout_lib.tex(,139) @smallexample
inout_lib.tex(,140) @c computed example pmat d2t_singular/inout_lib.doc:121 
inout_lib.tex(,141) LIB "inout.lib";
inout_lib.tex(,142) ring r=0,(x,y,z),ls;
inout_lib.tex(,143) ideal i= x,z+3y,x+y,z;
inout_lib.tex(,144) matrix m[3][3]=i^2;
inout_lib.tex(,145) pmat(m);
inout_lib.tex(,146) @expansion{} x2,     xz+3xy,     xy+x2,         
inout_lib.tex(,147) @expansion{} xz,     z2+6yz+9y2, yz+3y2+xz+3xy, 
inout_lib.tex(,148) @expansion{} z2+3yz, y2+2xy+x2,  yz+xz
inout_lib.tex(,149) pmat(m,3);
inout_lib.tex(,150) @expansion{} x2  xz+ xy+ 
inout_lib.tex(,151) @expansion{} xz  z2+ yz+ 
inout_lib.tex(,152) @expansion{} z2+ y2+ yz+ 
inout_lib.tex(,153) @c end example pmat d2t_singular/inout_lib.doc:121
inout_lib.tex(,154) @end smallexample
inout_lib.tex(,155) @c ---end content pmat---
inout_lib.tex(,156) 
inout_lib.tex(,157) @c ------------------- rMacaulay -------------
inout_lib.tex(,158) @node rMacaulay, show, pmat, inout_lib
inout_lib.tex(,159) @subsubsection rMacaulay
inout_lib.tex(,160) @cindex rMacaulay
inout_lib.tex(,161) @c ---content rMacaulay---
inout_lib.tex(,162) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,163) 
inout_lib.tex(,164) @table @asis
inout_lib.tex(,165) @item @strong{Usage:}
inout_lib.tex(,166) rMacaulay(s[,n]); s string, n integer
inout_lib.tex(,167) 
inout_lib.tex(,168) @item @strong{Return:}
inout_lib.tex(,169) A string which should be readable by Singular if s is a string which
inout_lib.tex(,170) was produced by Macaulay. If a second argument is present the first
inout_lib.tex(,171) n lines of the file are deleted (which is useful if the file was
inout_lib.tex(,172) produced e.g. by the putstd command of Macaulay).
inout_lib.tex(,173) 
inout_lib.tex(,174) @item @strong{Note:}
inout_lib.tex(,175) This does not always work with 'cut and paste' since the character
inout_lib.tex(,176) \ is treated differently
inout_lib.tex(,177) 
inout_lib.tex(,178) @end table
inout_lib.tex(,179) @strong{Example:}
inout_lib.tex(,180) @smallexample
inout_lib.tex(,181) @c computed example rMacaulay d2t_singular/inout_lib.doc:156 
inout_lib.tex(,182) LIB "inout.lib";
inout_lib.tex(,183) // Assume there exists a file 'Macid' with the following ideal in
inout_lib.tex(,184) // Macaulay format:"
inout_lib.tex(,185) // x[0]3-101/74x[0]2x[1]+7371x[0]x[1]2-13/83x[1]3-x[0]2x[2] \
inout_lib.tex(,186) //     -4/71x[0]x[1]x[2]
inout_lib.tex(,187) // Read this file into Singular and assign it to the string s1 by:
inout_lib.tex(,188) // string s1 = read("Macid");
inout_lib.tex(,189) // This is equivalent to";
inout_lib.tex(,190) string s1 =
inout_lib.tex(,191) "x[0]3-101/74x[0]2x[1]+7371x[0]x[1]2-13/83x[1]3-x[0]2x[2]-4/71x[0]x[1]x[2]";
inout_lib.tex(,192) rMacaulay(s1);
inout_lib.tex(,193) @expansion{} x(0)^3-101/74*x(0)^2*x(1)+7371*x(0)*x(1)^2-13/83*x(1)^3-x(0)^2*x(2)-4/71*\
inout_lib.tex(,194)    x(0)*x(1)*x(2)
inout_lib.tex(,195) // You may wish to assign s1 to a Singular ideal id:
inout_lib.tex(,196) string sid = "ideal id =",rMacaulay(s1),";";
inout_lib.tex(,197) ring r = 0,x(0..3),dp;
inout_lib.tex(,198) execute(sid);
inout_lib.tex(,199) id; "";
inout_lib.tex(,200) @expansion{} id[1]=x(0)^3-101/74*x(0)^2*x(1)+7371*x(0)*x(1)^2-13/83*x(1)^3-x(0)^2*x(2)\
inout_lib.tex(,201)    -4/71*x(0)*x(1)*x(2)
inout_lib.tex(,202) @expansion{} 
inout_lib.tex(,203) // Now treat a matrix in Macaulay format. Using the execute
inout_lib.tex(,204) // command, this could be assinged to a Singular matrix as above.
inout_lib.tex(,205) string s2 = "
inout_lib.tex(,206) 0  0  0  0  0
inout_lib.tex(,207) a3 0  0  0  0
inout_lib.tex(,208) 0  b3 0  0  0
inout_lib.tex(,209) 0  0  c3 0  0
inout_lib.tex(,210) 0  0  0  d3 0
inout_lib.tex(,211) 0  0  0  0  e3 ";
inout_lib.tex(,212) rMacaulay(s2);
inout_lib.tex(,213) @expansion{} 0, 0, 0, 0, 0,
inout_lib.tex(,214) @expansion{} a3,0, 0, 0, 0,
inout_lib.tex(,215) @expansion{} 0, b3,0, 0, 0,
inout_lib.tex(,216) @expansion{} 0, 0, c3,0, 0,
inout_lib.tex(,217) @expansion{} 0, 0, 0, d3,0,
inout_lib.tex(,218) @expansion{} 0, 0, 0, 0, e3
inout_lib.tex(,219) @c end example rMacaulay d2t_singular/inout_lib.doc:156
inout_lib.tex(,220) @end smallexample
inout_lib.tex(,221) @c ---end content rMacaulay---
inout_lib.tex(,222) 
inout_lib.tex(,223) @c ------------------- show -------------
inout_lib.tex(,224) @node show, showrecursive, rMacaulay, inout_lib
inout_lib.tex(,225) @subsubsection show
inout_lib.tex(,226) @cindex show
inout_lib.tex(,227) @c ---content show---
inout_lib.tex(,228) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,229) 
inout_lib.tex(,230) @table @asis
inout_lib.tex(,231) @item @strong{Usage:}
inout_lib.tex(,232) show(id); id any object of basering or of type ring/qring
inout_lib.tex(,233) @* show(R,s); R=ring, s=string (s = name of an object belonging to R)
inout_lib.tex(,234) 
inout_lib.tex(,235) @item @strong{Display:}
inout_lib.tex(,236) display id/s in a compact format together with some information
inout_lib.tex(,237) 
inout_lib.tex(,238) @item @strong{Return:}
inout_lib.tex(,239) no return value
inout_lib.tex(,240) 
inout_lib.tex(,241) @item @strong{Note:}
inout_lib.tex(,242) objects of type string, int, intvec, intmat belong to any ring.
inout_lib.tex(,243) id may be a ring or a qring. In this case the minimal polynomial is
inout_lib.tex(,244) displayed, and, for a qring, also the defining ideal.
inout_lib.tex(,245) @*id may be of type list but the list must not contain a ring.
inout_lib.tex(,246) @* show(R,s) does not work inside a procedure!
inout_lib.tex(,247) 
inout_lib.tex(,248) @end table
inout_lib.tex(,249) @strong{Example:}
inout_lib.tex(,250) @smallexample
inout_lib.tex(,251) @c computed example show d2t_singular/inout_lib.doc:215 
inout_lib.tex(,252) LIB "inout.lib";
inout_lib.tex(,253) ring r;
inout_lib.tex(,254) show(r);
inout_lib.tex(,255) @expansion{} // ring: (32003),(x,y,z),(dp(3),C);
inout_lib.tex(,256) @expansion{} // minpoly = 0
inout_lib.tex(,257) @expansion{} // objects belonging to this ring:
inout_lib.tex(,258) ideal i=x^3+y^5-6*z^3,xy,x3-y2;
inout_lib.tex(,259) show(i,3);            // introduce 3 space tabs before information
inout_lib.tex(,260) @expansion{}    // ideal, 3 generator(s)
inout_lib.tex(,261) @expansion{} y5+x3-6z3,
inout_lib.tex(,262) @expansion{} xy,
inout_lib.tex(,263) @expansion{} x3-y2
inout_lib.tex(,264) vector v=x*gen(1)+y*gen(3);
inout_lib.tex(,265) module m=v,2*v+gen(4);
inout_lib.tex(,266) list L = i,v,m;
inout_lib.tex(,267) show(L);
inout_lib.tex(,268) @expansion{} // list, 3 element(s):
inout_lib.tex(,269) @expansion{} [1]:
inout_lib.tex(,270) @expansion{}    // ideal, 3 generator(s)
inout_lib.tex(,271) @expansion{} y5+x3-6z3,
inout_lib.tex(,272) @expansion{} xy,
inout_lib.tex(,273) @expansion{} x3-y2
inout_lib.tex(,274) @expansion{} [2]:
inout_lib.tex(,275) @expansion{}    // vector
inout_lib.tex(,276) @expansion{} [x,0,y]
inout_lib.tex(,277) @expansion{} [3]:
inout_lib.tex(,278) @expansion{}    // module, 2 generator(s)
inout_lib.tex(,279) @expansion{} [x,0,y]
inout_lib.tex(,280) @expansion{} [2x,0,2y,1]
inout_lib.tex(,281) ring S=(0,T),(a,b,c,d),ws(1,2,3,4);
inout_lib.tex(,282) minpoly = T^2+1;
inout_lib.tex(,283) ideal i=a2+b,c2+T^2*d2; i=std(i);
inout_lib.tex(,284) qring Q=i;
inout_lib.tex(,285) show(Q);
inout_lib.tex(,286) @expansion{} // qring: (0,T),(a,b,c,d),(ws(1,2,3,4),C);
inout_lib.tex(,287) @expansion{} // minpoly = (T2+1)
inout_lib.tex(,288) @expansion{} // quotient ring from ideal:
inout_lib.tex(,289) @expansion{} _[1]=a2+b
inout_lib.tex(,290) @expansion{} _[2]=c2-d2
inout_lib.tex(,291) map F=r,a2,b^2,3*c3;
inout_lib.tex(,292) show(F);
inout_lib.tex(,293) @expansion{} // i-th variable of preimage ring is mapped to @@map[i]
inout_lib.tex(,294) @expansion{} // @@map                 [1]  map from r
inout_lib.tex(,295) @expansion{} @@map[1]=a2
inout_lib.tex(,296) @expansion{} @@map[2]=b2
inout_lib.tex(,297) @expansion{} @@map[3]=3*c3
inout_lib.tex(,298) // Apply 'show' to i (which does not belong to the basering) by typing
inout_lib.tex(,299) // ring r; ideal i=xy,x3-y2; ring Q; show(r,"i");
inout_lib.tex(,300) @c end example show d2t_singular/inout_lib.doc:215
inout_lib.tex(,301) @end smallexample
inout_lib.tex(,302) @c ---end content show---
inout_lib.tex(,303) 
inout_lib.tex(,304) @c ------------------- showrecursive -------------
inout_lib.tex(,305) @node showrecursive, split, show, inout_lib
inout_lib.tex(,306) @subsubsection showrecursive
inout_lib.tex(,307) @cindex showrecursive
inout_lib.tex(,308) @c ---content showrecursive---
inout_lib.tex(,309) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,310) 
inout_lib.tex(,311) @table @asis
inout_lib.tex(,312) @item @strong{Usage:}
inout_lib.tex(,313) showrecursive(id,p[ord]); id= any object of basering, p= product of
inout_lib.tex(,314) variables and ord=string (any allowed ordstr)
inout_lib.tex(,315) 
inout_lib.tex(,316) @item @strong{Display:}
inout_lib.tex(,317) display 'id' in a recursive format as a polynomial in the variables
inout_lib.tex(,318) occurring in p with coefficients in the remaining variables. This is
inout_lib.tex(,319) done by mapping to a ring with parameters [and ordering 'ord',
inout_lib.tex(,320) if a 3rd argument is present (default: ord="dp")] and applying
inout_lib.tex(,321) procedure 'show'
inout_lib.tex(,322) 
inout_lib.tex(,323) @item @strong{Return:}
inout_lib.tex(,324) no return value
inout_lib.tex(,325) 
inout_lib.tex(,326) @end table
inout_lib.tex(,327) @strong{Example:}
inout_lib.tex(,328) @smallexample
inout_lib.tex(,329) @c computed example showrecursive d2t_singular/inout_lib.doc:263 
inout_lib.tex(,330) LIB "inout.lib";
inout_lib.tex(,331) ring r=2,(a,b,c,d,x,y),ds;
inout_lib.tex(,332) poly f=y+ax2+bx3+cx2y2+dxy3;
inout_lib.tex(,333) showrecursive(f,x);
inout_lib.tex(,334) @expansion{} // poly, 4 monomial(s)
inout_lib.tex(,335) @expansion{} (b)*x3+(a+cy2)*x2+(dy3)*x+(y)
inout_lib.tex(,336) showrecursive(f,xy,"lp");
inout_lib.tex(,337) @expansion{} // poly, 5 monomial(s)
inout_lib.tex(,338) @expansion{} (b)*x3+(c)*x2y2+(a)*x2+(d)*xy3+y
inout_lib.tex(,339) @c end example showrecursive d2t_singular/inout_lib.doc:263
inout_lib.tex(,340) @end smallexample
inout_lib.tex(,341) @c ---end content showrecursive---
inout_lib.tex(,342) 
inout_lib.tex(,343) @c ------------------- split -------------
inout_lib.tex(,344) @node split, tab, showrecursive, inout_lib
inout_lib.tex(,345) @subsubsection split
inout_lib.tex(,346) @cindex split
inout_lib.tex(,347) @c ---content split---
inout_lib.tex(,348) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,349) 
inout_lib.tex(,350) @table @asis
inout_lib.tex(,351) @item @strong{Usage:}
inout_lib.tex(,352) split(s[,n]); s string, n integer
inout_lib.tex(,353) 
inout_lib.tex(,354) @item @strong{Return:}
inout_lib.tex(,355) same string, split into lines of length n separated by \
inout_lib.tex(,356) (default: n=pagewidth)
inout_lib.tex(,357) 
inout_lib.tex(,358) @item @strong{Note:}
inout_lib.tex(,359) may be used in connection with lprint
inout_lib.tex(,360) 
inout_lib.tex(,361) @end table
inout_lib.tex(,362) @strong{Example:}
inout_lib.tex(,363) @smallexample
inout_lib.tex(,364) @c computed example split d2t_singular/inout_lib.doc:294 
inout_lib.tex(,365) LIB "inout.lib";
inout_lib.tex(,366) ring r= 0,(x,y,z),ds;
inout_lib.tex(,367) poly f = (x+y+z)^4;
inout_lib.tex(,368) split(string(f),50);
inout_lib.tex(,369) @expansion{} x4+4x3y+6x2y2+4xy3+y4+4x3z+12x2yz+12xy2z+4y3z+6x\
inout_lib.tex(,370) @expansion{} 2z2+12xyz2+6y2z2+4xz3+4yz3+z4
inout_lib.tex(,371) split(lprint(f));
inout_lib.tex(,372) @expansion{}   x4+4x3y+6x2y2+4xy3+y4+4x3z+12x2yz+12xy2z+4y3z+6x2z2+12xyz2+6y2z2+4xz3+4\
inout_lib.tex(,373)    yz3\
inout_lib.tex(,374) @expansion{} +z4
inout_lib.tex(,375) @c end example split d2t_singular/inout_lib.doc:294
inout_lib.tex(,376) @end smallexample
inout_lib.tex(,377) @c ---end content split---
inout_lib.tex(,378) 
inout_lib.tex(,379) @c ------------------- tab -------------
inout_lib.tex(,380) @node tab, writelist, split, inout_lib
inout_lib.tex(,381) @subsubsection tab
inout_lib.tex(,382) @cindex tab
inout_lib.tex(,383) @c ---content tab---
inout_lib.tex(,384) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,385) 
inout_lib.tex(,386) @table @asis
inout_lib.tex(,387) @item @strong{Usage:}
inout_lib.tex(,388) tab(n); n integer
inout_lib.tex(,389) 
inout_lib.tex(,390) @item @strong{Return:}
inout_lib.tex(,391) string of n space tabs
inout_lib.tex(,392) 
inout_lib.tex(,393) @end table
inout_lib.tex(,394) @strong{Example:}
inout_lib.tex(,395) @smallexample
inout_lib.tex(,396) @c computed example tab d2t_singular/inout_lib.doc:321 
inout_lib.tex(,397) LIB "inout.lib";
inout_lib.tex(,398) for(int n=0; n<=5; n=n+1)
inout_lib.tex(,399) @{ tab(5-n)+"*"+tab(n)+"+"+tab(n)+"*"; @}
inout_lib.tex(,400) @expansion{}      *+*
inout_lib.tex(,401) @expansion{}     * + *
inout_lib.tex(,402) @expansion{}    *  +  *
inout_lib.tex(,403) @expansion{}   *   +   *
inout_lib.tex(,404) @expansion{}  *    +    *
inout_lib.tex(,405) @expansion{} *     +     *
inout_lib.tex(,406) @c end example tab d2t_singular/inout_lib.doc:321
inout_lib.tex(,407) @end smallexample
inout_lib.tex(,408) @c ---end content tab---
inout_lib.tex(,409) 
inout_lib.tex(,410) @c ------------------- writelist -------------
inout_lib.tex(,411) @node writelist, pause, tab, inout_lib
inout_lib.tex(,412) @subsubsection writelist
inout_lib.tex(,413) @cindex writelist
inout_lib.tex(,414) @c ---content writelist---
inout_lib.tex(,415) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,416) 
inout_lib.tex(,417) @table @asis
inout_lib.tex(,418) @item @strong{Usage:}
inout_lib.tex(,419) writelist(file,name,L); file,name strings (file-name, list-name),
inout_lib.tex(,420) L a list.
inout_lib.tex(,421) 
inout_lib.tex(,422) @item @strong{Create:}
inout_lib.tex(,423) a file with name `file`, write the content of the list L into it and
inout_lib.tex(,424) call the list `name`, keeping the list structure
inout_lib.tex(,425) 
inout_lib.tex(,426) @item @strong{Return:}
inout_lib.tex(,427) no return value
inout_lib.tex(,428) 
inout_lib.tex(,429) @item @strong{Note:}
inout_lib.tex(,430) The syntax of writelist uses and is similar to the syntax of the
inout_lib.tex(,431) write command of Singular which does not manage lists properly.
inout_lib.tex(,432) If (file,name) = ("listfile","L1"), writelist creates (resp.
inout_lib.tex(,433) appends if listfile exists) a file with name listfile and stores
inout_lib.tex(,434) there the list L under the name L1. The Singular command
inout_lib.tex(,435) execute(read("listfile")); assigns the content of L (stored in
inout_lib.tex(,436) listfile) to a list L1.
inout_lib.tex(,437) @* On a UNIX system, write(">file",...) overwrites an existing file
inout_lib.tex(,438) `file` while write("file",...) and write(">>file",...) append.
inout_lib.tex(,439) 
inout_lib.tex(,440) @end table
inout_lib.tex(,441) @strong{Example:}
inout_lib.tex(,442) @smallexample
inout_lib.tex(,443) @c computed example writelist d2t_singular/inout_lib.doc:362 
inout_lib.tex(,444) LIB "inout.lib";
inout_lib.tex(,445) ring r;
inout_lib.tex(,446) ideal i=x,y,z;
inout_lib.tex(,447) list k="Hi",nameof(basering),i,37;
inout_lib.tex(,448) writelist("zumSpass","lustig",k);
inout_lib.tex(,449) read("zumSpass");
inout_lib.tex(,450) @expansion{} list lustig;
inout_lib.tex(,451) @expansion{}    lustig[1]=
inout_lib.tex(,452) @expansion{} Hi;
inout_lib.tex(,453) @expansion{}    lustig[2]=
inout_lib.tex(,454) @expansion{} r;
inout_lib.tex(,455) @expansion{}    lustig[3]=
inout_lib.tex(,456) @expansion{} x,y,z;
inout_lib.tex(,457) @expansion{}    lustig[4]=
inout_lib.tex(,458) @expansion{} 37;
inout_lib.tex(,459) @expansion{} 
inout_lib.tex(,460) list L=res(i,0);                    //resolution of the ideal i
inout_lib.tex(,461) writelist("res_list","res-name",L); "";
inout_lib.tex(,462) @expansion{} 
inout_lib.tex(,463) read("res_list");
inout_lib.tex(,464) @expansion{} list res-name;
inout_lib.tex(,465) @expansion{}    res-name[1]=
inout_lib.tex(,466) @expansion{} z,y,x;
inout_lib.tex(,467) @expansion{}    res-name[2]=
inout_lib.tex(,468) @expansion{} -y*gen(1)+z*gen(2),-x*gen(1)+z*gen(3),-x*gen(2)+y*gen(3);
inout_lib.tex(,469) @expansion{}    res-name[3]=
inout_lib.tex(,470) @expansion{} x*gen(1)-y*gen(2)+z*gen(3);
inout_lib.tex(,471) @expansion{} 
inout_lib.tex(,472) // execute(read("res_list")); would create a list with name res-name,
inout_lib.tex(,473) // which is the resolution of i (the same content as L)
inout_lib.tex(,474) system("sh","/bin/rm res_list zumSpass");
inout_lib.tex(,475) @expansion{} 0
inout_lib.tex(,476) // Under UNIX, this removes the files 'res_list' and 'zumSpass'
inout_lib.tex(,477) // Type help system; to get more information about the shell escape
inout_lib.tex(,478) // If your operating system does not accept the shell escape, you
inout_lib.tex(,479) // must remove the just created files 'zumSpass' and 'res_list' directly
inout_lib.tex(,480) @c end example writelist d2t_singular/inout_lib.doc:362
inout_lib.tex(,481) @end smallexample
inout_lib.tex(,482) @c ---end content writelist---
inout_lib.tex(,483) 
inout_lib.tex(,484) @c ------------------- pause -------------
inout_lib.tex(,485) @node pause,, writelist, inout_lib
inout_lib.tex(,486) @subsubsection pause
inout_lib.tex(,487) @cindex pause
inout_lib.tex(,488) @c ---content pause---
inout_lib.tex(,489) Procedure from library @code{inout.lib} (@pxref{inout_lib}).
inout_lib.tex(,490) 
inout_lib.tex(,491) @table @asis
inout_lib.tex(,492) @item @strong{Usage:}
inout_lib.tex(,493) pause([ prompt ]) prompt string
inout_lib.tex(,494) 
inout_lib.tex(,495) @item @strong{Return:}
inout_lib.tex(,496) none
inout_lib.tex(,497) 
inout_lib.tex(,498) @item @strong{Purpose:}
inout_lib.tex(,499) interrupt the execution of commands until user input
inout_lib.tex(,500) 
inout_lib.tex(,501) @item @strong{Note:}
inout_lib.tex(,502) pause is useful in procedures in connection with printlevel to
inout_lib.tex(,503) interrupt the computation and to display intermediate results.
inout_lib.tex(,504) 
inout_lib.tex(,505) @end table
inout_lib.tex(,506) @strong{Example:}
inout_lib.tex(,507) @smallexample
inout_lib.tex(,508) @c computed example pause d2t_singular/inout_lib.doc:407 
inout_lib.tex(,509) LIB "inout.lib";
inout_lib.tex(,510) // can only be shown interactively, try the following commands:
inout_lib.tex(,511) // pause("press <return> to continue");
inout_lib.tex(,512) // pause();
inout_lib.tex(,513) // In the following pocedure TTT, xxx is printed and the execution of
inout_lib.tex(,514) // TTT is stopped until the return-key is pressed, if printlevel>0.
inout_lib.tex(,515) // xxx may be any result of a previous computation or a comment, etc:
inout_lib.tex(,516) //
inout_lib.tex(,517) // proc TTT
inout_lib.tex(,518) // @{ int pp = printlevel-voice+2;  //pp=0 if printlevel=0 and if TTT is
inout_lib.tex(,519) //    ....                         //not called from another procedure
inout_lib.tex(,520) //    if( pp>0 )
inout_lib.tex(,521) //    @{
inout_lib.tex(,522) //       print( xxx );
inout_lib.tex(,523) //       pause("press <return> to continue");
inout_lib.tex(,524) //    @}
inout_lib.tex(,525) //     ....
inout_lib.tex(,526) // @}
inout_lib.tex(,527) @c end example pause d2t_singular/inout_lib.doc:407
inout_lib.tex(,528) @end smallexample
inout_lib.tex(,529) @c inserted refs from d2t_singular/inout_lib.doc:428
inout_lib.tex(,542) @c end inserted refs from d2t_singular/inout_lib.doc:428
inout_lib.tex(,543) 
inout_lib.tex(,544) @c ---end content pause---
singular.texi(,317) @c ----------------------------------------------------------
singular.texi(,318) @node poly_lib, random_lib, inout_lib, General purpose
singular.texi(,319) @subsection poly_lib
singular.texi(,320) @c include of docu for poly.lib
poly_lib.tex(,1) @c ---content LibInfo---
poly_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/poly_lib.doc
poly_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/poly_lib.doc INSTEAD
poly_lib.tex(,4) @c library version: (1.33.2.6,2003/02/10)
poly_lib.tex(,5) @c library file: ../Singular/LIB/poly.lib
poly_lib.tex(,6) @cindex poly.lib
poly_lib.tex(,7) @cindex poly_lib
poly_lib.tex(,8) @table @asis
poly_lib.tex(,9) @item @strong{Library:}
poly_lib.tex(,10) poly.lib
poly_lib.tex(,11) @item @strong{Purpose:}
poly_lib.tex(,12)       Procedures for Manipulating Polys, Ideals, Modules
poly_lib.tex(,13) @item @strong{Authors:}
poly_lib.tex(,14) O. Bachmann, G.-M: Greuel, A. Fruehbis
poly_lib.tex(,15) 
poly_lib.tex(,16) @end table
poly_lib.tex(,17) 
poly_lib.tex(,18) @strong{Procedures:}
poly_lib.tex(,19) @menu
poly_lib.tex(,20) * cyclic:: ideal of cyclic n-roots
poly_lib.tex(,21) * katsura:: katsura [i] ideal
poly_lib.tex(,22) * freerank:: rank of coker(input) if coker is free else -1
poly_lib.tex(,23) * is_homog:: int, =1 resp. =0 if input is homogeneous resp. not
poly_lib.tex(,24) * is_zero:: int, =1 resp. =0 if coker(input) is 0 resp. not
poly_lib.tex(,25) * lcm:: lcm of given generators of ideal
poly_lib.tex(,26) * maxcoef:: maximal length of coefficient occurring in poly/...
poly_lib.tex(,27) * maxdeg:: int/intmat = degree/s of terms of maximal order
poly_lib.tex(,28) * maxdeg1:: int = [weighted] maximal degree of input
poly_lib.tex(,29) * mindeg:: int/intmat = degree/s of terms of minimal order
poly_lib.tex(,30) * mindeg1:: int = [weighted] minimal degree of input
poly_lib.tex(,31) * normalize:: normalize poly/... such that leading coefficient is 1
poly_lib.tex(,32) * rad_con:: check radical containment of poly p in ideal I
poly_lib.tex(,33) * content:: content of polynomial/vector f
poly_lib.tex(,34) * numerator:: numerator of number n
poly_lib.tex(,35) * denominator:: denominator of number n
poly_lib.tex(,36) * mod2id:: conversion of a module M to an ideal
poly_lib.tex(,37) * id2mod:: conversion inverse to mod2id
poly_lib.tex(,38) * substitute:: substitute in I variables by polynomials
poly_lib.tex(,39) * subrInterred:: interred w.r.t. a subset of variables
poly_lib.tex(,40) * hilbPoly:: Hilbert polynomial of basering/I
poly_lib.tex(,41) @end menu
poly_lib.tex(,42) @c ---end content LibInfo---
poly_lib.tex(,43) 
poly_lib.tex(,44) @c ------------------- cyclic -------------
poly_lib.tex(,45) @node cyclic, katsura,, poly_lib
poly_lib.tex(,46) @subsubsection cyclic
poly_lib.tex(,47) @cindex cyclic
poly_lib.tex(,48) @c ---content cyclic---
poly_lib.tex(,49) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,50) 
poly_lib.tex(,51) @table @asis
poly_lib.tex(,52) @item @strong{Usage:}
poly_lib.tex(,53) cyclic(n); n integer
poly_lib.tex(,54) 
poly_lib.tex(,55) @item @strong{Return:}
poly_lib.tex(,56) ideal of cyclic n-roots from 1-st n variables of basering
poly_lib.tex(,57) 
poly_lib.tex(,58) @end table
poly_lib.tex(,59) @strong{Example:}
poly_lib.tex(,60) @smallexample
poly_lib.tex(,61) @c computed example cyclic d2t_singular/poly_lib.doc:59 
poly_lib.tex(,62) LIB "poly.lib";
poly_lib.tex(,63) ring r=0,(u,v,w,x,y,z),lp;
poly_lib.tex(,64) cyclic(nvars(basering));
poly_lib.tex(,65) @expansion{} _[1]=u+v+w+x+y+z
poly_lib.tex(,66) @expansion{} _[2]=uv+uz+vw+wx+xy+yz
poly_lib.tex(,67) @expansion{} _[3]=uvw+uvz+uyz+vwx+wxy+xyz
poly_lib.tex(,68) @expansion{} _[4]=uvwx+uvwz+uvyz+uxyz+vwxy+wxyz
poly_lib.tex(,69) @expansion{} _[5]=uvwxy+uvwxz+uvwyz+uvxyz+uwxyz+vwxyz
poly_lib.tex(,70) @expansion{} _[6]=uvwxyz-1
poly_lib.tex(,71) homog(cyclic(5),z);
poly_lib.tex(,72) @expansion{} _[1]=u+v+w+x+y
poly_lib.tex(,73) @expansion{} _[2]=uv+uy+vw+wx+xy
poly_lib.tex(,74) @expansion{} _[3]=uvw+uvy+uxy+vwx+wxy
poly_lib.tex(,75) @expansion{} _[4]=uvwx+uvwy+uvxy+uwxy+vwxy
poly_lib.tex(,76) @expansion{} _[5]=uvwxy-z5
poly_lib.tex(,77) @c end example cyclic d2t_singular/poly_lib.doc:59
poly_lib.tex(,78) @end smallexample
poly_lib.tex(,79) @c ---end content cyclic---
poly_lib.tex(,80) 
poly_lib.tex(,81) @c ------------------- katsura -------------
poly_lib.tex(,82) @node katsura, freerank, cyclic, poly_lib
poly_lib.tex(,83) @subsubsection katsura
poly_lib.tex(,84) @cindex katsura
poly_lib.tex(,85) @c ---content katsura---
poly_lib.tex(,86) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,87) 
poly_lib.tex(,88) @table @asis
poly_lib.tex(,89) @item @strong{Usage:}
poly_lib.tex(,90) katsura([n]): n integer
poly_lib.tex(,91) 
poly_lib.tex(,92) @item @strong{Return:}
poly_lib.tex(,93) katsura(n) : n-th katsura ideal of
poly_lib.tex(,94) @*(1) newly created and set ring (32003, x(0..n), dp), if
poly_lib.tex(,95) nvars(basering) < n
poly_lib.tex(,96) @*(2) basering, if nvars(basering) >= n
poly_lib.tex(,97) @*katsura() : katsura ideal of basering
poly_lib.tex(,98) 
poly_lib.tex(,99) @end table
poly_lib.tex(,100) @strong{Example:}
poly_lib.tex(,101) @smallexample
poly_lib.tex(,102) @c computed example katsura d2t_singular/poly_lib.doc:89 
poly_lib.tex(,103) LIB "poly.lib";
poly_lib.tex(,104) ring r; basering;
poly_lib.tex(,105) @expansion{} //   characteristic : 32003
poly_lib.tex(,106) @expansion{} //   number of vars : 3
poly_lib.tex(,107) @expansion{} //        block   1 : ordering dp
poly_lib.tex(,108) @expansion{} //                  : names    x y z 
poly_lib.tex(,109) @expansion{} //        block   2 : ordering C
poly_lib.tex(,110) katsura();
poly_lib.tex(,111) @expansion{} _[1]=x+2y+2z-1
poly_lib.tex(,112) @expansion{} _[2]=x2+2y2+2z2-x
poly_lib.tex(,113) @expansion{} _[3]=2xy+2yz-y
poly_lib.tex(,114) katsura(4); basering;
poly_lib.tex(,115) @expansion{} _[1]=x(0)+2*x(1)+2*x(2)+2*x(3)-1
poly_lib.tex(,116) @expansion{} _[2]=x(0)^2+2*x(1)^2+2*x(2)^2+2*x(3)^2-x(0)
poly_lib.tex(,117) @expansion{} _[3]=2*x(0)*x(1)+2*x(1)*x(2)+2*x(2)*x(3)-x(1)
poly_lib.tex(,118) @expansion{} _[4]=x(1)^2+2*x(0)*x(2)+2*x(1)*x(3)-x(2)
poly_lib.tex(,119) @expansion{} //   characteristic : 32003
poly_lib.tex(,120) @expansion{} //   number of vars : 5
poly_lib.tex(,121) @expansion{} //        block   1 : ordering dp
poly_lib.tex(,122) @expansion{} //                  : names    x(0) x(1) x(2) x(3) x(4) 
poly_lib.tex(,123) @expansion{} //        block   2 : ordering C
poly_lib.tex(,124) @c end example katsura d2t_singular/poly_lib.doc:89
poly_lib.tex(,125) @end smallexample
poly_lib.tex(,126) @c ---end content katsura---
poly_lib.tex(,127) 
poly_lib.tex(,128) @c ------------------- freerank -------------
poly_lib.tex(,129) @node freerank, is_homog, katsura, poly_lib
poly_lib.tex(,130) @subsubsection freerank
poly_lib.tex(,131) @cindex freerank
poly_lib.tex(,132) @c ---content freerank---
poly_lib.tex(,133) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,134) 
poly_lib.tex(,135) @table @asis
poly_lib.tex(,136) @item @strong{Usage:}
poly_lib.tex(,137) freerank(M[,any]); M=poly/ideal/vector/module/matrix
poly_lib.tex(,138) 
poly_lib.tex(,139) @item @strong{Compute:}
poly_lib.tex(,140) rank of module presented by M in case it is free.
poly_lib.tex(,141) @*By definition this is vdim(coker(M)/m*coker(M)) if coker(M)
poly_lib.tex(,142) is free, where m = maximal ideal of the variables of the
poly_lib.tex(,143) basering and M is considered as matrix.
poly_lib.tex(,144) @*(the 0-module is free of rank 0)
poly_lib.tex(,145) 
poly_lib.tex(,146) @item @strong{Return:}
poly_lib.tex(,147) rank of coker(M) if coker(M) is free and -1 else;
poly_lib.tex(,148) @*in case of a second argument return a list:
poly_lib.tex(,149) @*L[1] = rank of coker(M) or -1
poly_lib.tex(,150) @*L[2] = minbase(M)
poly_lib.tex(,151) 
poly_lib.tex(,152) @item @strong{Note:}
poly_lib.tex(,153) freerank(syz(M)); computes the rank of M if M is free (and -1 else)
poly_lib.tex(,154) 
poly_lib.tex(,155) @end table
poly_lib.tex(,156) @strong{Example:}
poly_lib.tex(,157) @smallexample
poly_lib.tex(,158) @c computed example freerank d2t_singular/poly_lib.doc:128 
poly_lib.tex(,159) LIB "poly.lib";
poly_lib.tex(,160) ring r;
poly_lib.tex(,161) ideal i=x;
poly_lib.tex(,162) module M=[x,0,1],[-x,0,-1];
poly_lib.tex(,163) freerank(M);          // should be 2, coker(M) is not free
poly_lib.tex(,164) @expansion{} 2
poly_lib.tex(,165) freerank(syz (M),"");
poly_lib.tex(,166) @expansion{} [1]:
poly_lib.tex(,167) @expansion{}    1
poly_lib.tex(,168) @expansion{} [2]:
poly_lib.tex(,169) @expansion{}    _[1]=gen(2)+gen(1)
poly_lib.tex(,170) // [1] should be 1, coker(syz(M))=M is free of rank 1
poly_lib.tex(,171) // [2] should be gen(2)+gen(1) (minimal relation of M)
poly_lib.tex(,172) freerank(i);
poly_lib.tex(,173) @expansion{} -1
poly_lib.tex(,174) freerank(syz(i));     // should be 1, coker(syz(i))=i is free of rank 1
poly_lib.tex(,175) @expansion{} 1
poly_lib.tex(,176) @c end example freerank d2t_singular/poly_lib.doc:128
poly_lib.tex(,177) @end smallexample
poly_lib.tex(,178) @c ---end content freerank---
poly_lib.tex(,179) 
poly_lib.tex(,180) @c ------------------- is_homog -------------
poly_lib.tex(,181) @node is_homog, is_zero, freerank, poly_lib
poly_lib.tex(,182) @subsubsection is_homog
poly_lib.tex(,183) @cindex is_homog
poly_lib.tex(,184) @c ---content is_homog---
poly_lib.tex(,185) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,186) 
poly_lib.tex(,187) @table @asis
poly_lib.tex(,188) @item @strong{Usage:}
poly_lib.tex(,189) is_homog(id); id poly/ideal/vector/module/matrix
poly_lib.tex(,190) 
poly_lib.tex(,191) @item @strong{Return:}
poly_lib.tex(,192) integer which is 1 if input is homogeneous (resp. weighted homogeneous
poly_lib.tex(,193) if the monomial ordering consists of one block of type ws,Ws,wp or Wp,
poly_lib.tex(,194) assuming that all weights are positive) and 0 otherwise
poly_lib.tex(,195) 
poly_lib.tex(,196) @item @strong{Note:}
poly_lib.tex(,197) A vector is homogeneous, if the components are homogeneous of same
poly_lib.tex(,198) degree, a module/matrix is homogeneous if all column vectors are
poly_lib.tex(,199) homogeneous
poly_lib.tex(,200) @*//*** ergaenzen, wenn Matrizen-Spalten Gewichte haben
poly_lib.tex(,201) 
poly_lib.tex(,202) @end table
poly_lib.tex(,203) @strong{Example:}
poly_lib.tex(,204) @smallexample
poly_lib.tex(,205) @c computed example is_homog d2t_singular/poly_lib.doc:168 
poly_lib.tex(,206) LIB "poly.lib";
poly_lib.tex(,207) ring r = 0,(x,y,z),wp(1,2,3);
poly_lib.tex(,208) is_homog(x5-yz+y3);
poly_lib.tex(,209) @expansion{} 0
poly_lib.tex(,210) ideal i = x6+y3+z2, x9-z3;
poly_lib.tex(,211) is_homog(i);
poly_lib.tex(,212) @expansion{} 1
poly_lib.tex(,213) ring s = 0,(a,b,c),ds;
poly_lib.tex(,214) vector v = [a2,0,ac+bc];
poly_lib.tex(,215) vector w = [a3,b3,c4];
poly_lib.tex(,216) is_homog(v);
poly_lib.tex(,217) @expansion{} 1
poly_lib.tex(,218) is_homog(w);
poly_lib.tex(,219) @expansion{} 0
poly_lib.tex(,220) @c end example is_homog d2t_singular/poly_lib.doc:168
poly_lib.tex(,221) @end smallexample
poly_lib.tex(,222) @c ---end content is_homog---
poly_lib.tex(,223) 
poly_lib.tex(,224) @c ------------------- is_zero -------------
poly_lib.tex(,225) @node is_zero, lcm, is_homog, poly_lib
poly_lib.tex(,226) @subsubsection is_zero
poly_lib.tex(,227) @cindex is_zero
poly_lib.tex(,228) @c ---content is_zero---
poly_lib.tex(,229) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,230) 
poly_lib.tex(,231) @table @asis
poly_lib.tex(,232) @item @strong{Usage:}
poly_lib.tex(,233) is_zero(M[,any]); M=poly/ideal/vector/module/matrix
poly_lib.tex(,234) 
poly_lib.tex(,235) @item @strong{Return:}
poly_lib.tex(,236) integer, 1 if coker(M)=0 resp. 0 if coker(M)!=0, where M is
poly_lib.tex(,237) considered as matrix.
poly_lib.tex(,238) @*If a second argument is given, return a list:
poly_lib.tex(,239) @*L[1] = 1 if coker(M)=0 resp. 0 if coker(M)!=0
poly_lib.tex(,240) @*L[2] = dim(M)
poly_lib.tex(,241) 
poly_lib.tex(,242) @end table
poly_lib.tex(,243) @strong{Example:}
poly_lib.tex(,244) @smallexample
poly_lib.tex(,245) @c computed example is_zero d2t_singular/poly_lib.doc:204 
poly_lib.tex(,246) LIB "poly.lib";
poly_lib.tex(,247) ring r;
poly_lib.tex(,248) module m = [x],[y],[1,z];
poly_lib.tex(,249) is_zero(m,1);
poly_lib.tex(,250) @expansion{} [1]:
poly_lib.tex(,251) @expansion{}    0
poly_lib.tex(,252) @expansion{} [2]:
poly_lib.tex(,253) @expansion{}    2
poly_lib.tex(,254) qring q = std(ideal(x2+y3+z2));
poly_lib.tex(,255) ideal j = x2+y3+z2-37;
poly_lib.tex(,256) is_zero(j);
poly_lib.tex(,257) @expansion{} 1
poly_lib.tex(,258) @c end example is_zero d2t_singular/poly_lib.doc:204
poly_lib.tex(,259) @end smallexample
poly_lib.tex(,260) @c ---end content is_zero---
poly_lib.tex(,261) 
poly_lib.tex(,262) @c ------------------- lcm -------------
poly_lib.tex(,263) @node lcm, maxcoef, is_zero, poly_lib
poly_lib.tex(,264) @subsubsection lcm
poly_lib.tex(,265) @cindex lcm
poly_lib.tex(,266) @c ---content lcm---
poly_lib.tex(,267) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,268) 
poly_lib.tex(,269) @table @asis
poly_lib.tex(,270) @item @strong{Usage:}
poly_lib.tex(,271) lcm(p[,q]); p int/intvec q a list of integers or
poly_lib.tex(,272) @*p poly/ideal q a list of polynomials
poly_lib.tex(,273) 
poly_lib.tex(,274) @item @strong{Return:}
poly_lib.tex(,275) the least common multiple of the common entries of p and q:
poly_lib.tex(,276) @* - of type int if p is an int/intvec
poly_lib.tex(,277) @* - of type poly if p is a poly/ideal
poly_lib.tex(,278) 
poly_lib.tex(,279) @end table
poly_lib.tex(,280) @strong{Example:}
poly_lib.tex(,281) @smallexample
poly_lib.tex(,282) @c computed example lcm d2t_singular/poly_lib.doc:236 
poly_lib.tex(,283) LIB "poly.lib";
poly_lib.tex(,284) ring  r = 0,(x,y,z),lp;
poly_lib.tex(,285) poly  p = (x+y)*(y+z);
poly_lib.tex(,286) poly  q = (z4+2)*(y+z);
poly_lib.tex(,287) lcm(p,q);
poly_lib.tex(,288) @expansion{} xyz4+2xy+xz5+2xz+y2z4+2y2+yz5+2yz
poly_lib.tex(,289) ideal i=p,q,y+z;
poly_lib.tex(,290) lcm(i,p);
poly_lib.tex(,291) @expansion{} xyz4+2xy+xz5+2xz+y2z4+2y2+yz5+2yz
poly_lib.tex(,292) lcm(2,3,6);
poly_lib.tex(,293) @expansion{} 6
poly_lib.tex(,294) lcm(2..6);
poly_lib.tex(,295) @expansion{} 60
poly_lib.tex(,296) @c end example lcm d2t_singular/poly_lib.doc:236
poly_lib.tex(,297) @end smallexample
poly_lib.tex(,298) @c ---end content lcm---
poly_lib.tex(,299) 
poly_lib.tex(,300) @c ------------------- maxcoef -------------
poly_lib.tex(,301) @node maxcoef, maxdeg, lcm, poly_lib
poly_lib.tex(,302) @subsubsection maxcoef
poly_lib.tex(,303) @cindex maxcoef
poly_lib.tex(,304) @c ---content maxcoef---
poly_lib.tex(,305) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,306) 
poly_lib.tex(,307) @table @asis
poly_lib.tex(,308) @item @strong{Usage:}
poly_lib.tex(,309) maxcoef(f); f poly/ideal/vector/module/matrix
poly_lib.tex(,310) 
poly_lib.tex(,311) @item @strong{Return:}
poly_lib.tex(,312) maximal length of coefficient of f of type int (by counting the
poly_lib.tex(,313) length of the string of each coefficient)
poly_lib.tex(,314) 
poly_lib.tex(,315) @end table
poly_lib.tex(,316) @strong{Example:}
poly_lib.tex(,317) @smallexample
poly_lib.tex(,318) @c computed example maxcoef d2t_singular/poly_lib.doc:268 
poly_lib.tex(,319) LIB "poly.lib";
poly_lib.tex(,320) ring r= 0,(x,y,z),ds;
poly_lib.tex(,321) poly g = 345x2-1234567890y+7/4z;
poly_lib.tex(,322) maxcoef(g);
poly_lib.tex(,323) @expansion{} 10
poly_lib.tex(,324) ideal i = g,10/1234567890;
poly_lib.tex(,325) maxcoef(i);
poly_lib.tex(,326) @expansion{} 11
poly_lib.tex(,327) // since i[2]=1/123456789
poly_lib.tex(,328) @c end example maxcoef d2t_singular/poly_lib.doc:268
poly_lib.tex(,329) @end smallexample
poly_lib.tex(,330) @c ---end content maxcoef---
poly_lib.tex(,331) 
poly_lib.tex(,332) @c ------------------- maxdeg -------------
poly_lib.tex(,333) @node maxdeg, maxdeg1, maxcoef, poly_lib
poly_lib.tex(,334) @subsubsection maxdeg
poly_lib.tex(,335) @cindex maxdeg
poly_lib.tex(,336) @c ---content maxdeg---
poly_lib.tex(,337) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,338) 
poly_lib.tex(,339) @table @asis
poly_lib.tex(,340) @item @strong{Usage:}
poly_lib.tex(,341) maxdeg(id); id poly/ideal/vector/module/matrix
poly_lib.tex(,342) 
poly_lib.tex(,343) @item @strong{Return:}
poly_lib.tex(,344) int/intmat, each component equals maximal degree of monomials in the
poly_lib.tex(,345) corresponding component of id, independent of ring ordering
poly_lib.tex(,346) (maxdeg of each var is 1).
poly_lib.tex(,347) @*Of type int if id is of type poly, of type intmat else
poly_lib.tex(,348) 
poly_lib.tex(,349) @item @strong{Note:}
poly_lib.tex(,350) proc maxdeg1 returns 1 integer, the absolute maximum; moreover, it has
poly_lib.tex(,351) an option for computing weighted degrees
poly_lib.tex(,352) 
poly_lib.tex(,353) @end table
poly_lib.tex(,354) @strong{Example:}
poly_lib.tex(,355) @smallexample
poly_lib.tex(,356) @c computed example maxdeg d2t_singular/poly_lib.doc:304 
poly_lib.tex(,357) LIB "poly.lib";
poly_lib.tex(,358) ring r = 0,(x,y,z),wp(1,2,3);
poly_lib.tex(,359) poly f = x+y2+z3;
poly_lib.tex(,360) deg(f);             //deg; returns weighted degree (in case of 1 block)!
poly_lib.tex(,361) @expansion{} 9
poly_lib.tex(,362) maxdeg(f);
poly_lib.tex(,363) @expansion{} 3
poly_lib.tex(,364) matrix m[2][2]=f+x10,1,0,f^2;
poly_lib.tex(,365) maxdeg(m);
poly_lib.tex(,366) @expansion{} 10,0,
poly_lib.tex(,367) @expansion{} -1,6 
poly_lib.tex(,368) @c end example maxdeg d2t_singular/poly_lib.doc:304
poly_lib.tex(,369) @end smallexample
poly_lib.tex(,370) @c ---end content maxdeg---
poly_lib.tex(,371) 
poly_lib.tex(,372) @c ------------------- maxdeg1 -------------
poly_lib.tex(,373) @node maxdeg1, mindeg, maxdeg, poly_lib
poly_lib.tex(,374) @subsubsection maxdeg1
poly_lib.tex(,375) @cindex maxdeg1
poly_lib.tex(,376) @c ---content maxdeg1---
poly_lib.tex(,377) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,378) 
poly_lib.tex(,379) @table @asis
poly_lib.tex(,380) @item @strong{Usage:}
poly_lib.tex(,381) maxdeg1(id[,v]); id=poly/ideal/vector/module/matrix, v=intvec
poly_lib.tex(,382) 
poly_lib.tex(,383) @item @strong{Return:}
poly_lib.tex(,384) integer, maximal [weighted] degree of monomials of id independent of
poly_lib.tex(,385) ring ordering, maxdeg1 of i-th variable is v[i] (default: v=1..1).
poly_lib.tex(,386) 
poly_lib.tex(,387) @item @strong{Note:}
poly_lib.tex(,388) This proc returns one integer while maxdeg returns, in general,
poly_lib.tex(,389) a matrix of integers. For one polynomial and if no intvec v is given
poly_lib.tex(,390) maxdeg is faster
poly_lib.tex(,391) 
poly_lib.tex(,392) @end table
poly_lib.tex(,393) @strong{Example:}
poly_lib.tex(,394) @smallexample
poly_lib.tex(,395) @c computed example maxdeg1 d2t_singular/poly_lib.doc:339 
poly_lib.tex(,396) LIB "poly.lib";
poly_lib.tex(,397) ring r = 0,(x,y,z),wp(1,2,3);
poly_lib.tex(,398) poly f = x+y2+z3;
poly_lib.tex(,399) deg(f);            //deg returns weighted degree (in case of 1 block)!
poly_lib.tex(,400) @expansion{} 9
poly_lib.tex(,401) maxdeg1(f);
poly_lib.tex(,402) @expansion{} 3
poly_lib.tex(,403) intvec v = ringweights(r);
poly_lib.tex(,404) maxdeg1(f,v);                        //weighted maximal degree
poly_lib.tex(,405) @expansion{} 9
poly_lib.tex(,406) matrix m[2][2]=f+x10,1,0,f^2;
poly_lib.tex(,407) maxdeg1(m,v);                        //absolute weighted maximal degree
poly_lib.tex(,408) @expansion{} 18
poly_lib.tex(,409) @c end example maxdeg1 d2t_singular/poly_lib.doc:339
poly_lib.tex(,410) @end smallexample
poly_lib.tex(,411) @c ---end content maxdeg1---
poly_lib.tex(,412) 
poly_lib.tex(,413) @c ------------------- mindeg -------------
poly_lib.tex(,414) @node mindeg, mindeg1, maxdeg1, poly_lib
poly_lib.tex(,415) @subsubsection mindeg
poly_lib.tex(,416) @cindex mindeg
poly_lib.tex(,417) @c ---content mindeg---
poly_lib.tex(,418) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,419) 
poly_lib.tex(,420) @table @asis
poly_lib.tex(,421) @item @strong{Usage:}
poly_lib.tex(,422) mindeg(id); id poly/ideal/vector/module/matrix
poly_lib.tex(,423) 
poly_lib.tex(,424) @item @strong{Return:}
poly_lib.tex(,425) minimal degree/s of monomials of id, independent of ring ordering
poly_lib.tex(,426) (mindeg of each variable is 1) of type int if id of type poly, else
poly_lib.tex(,427) of type intmat.
poly_lib.tex(,428) 
poly_lib.tex(,429) @item @strong{Note:}
poly_lib.tex(,430) proc mindeg1 returns one integer, the absolute minimum; moreover it
poly_lib.tex(,431) has an option for computing weighted degrees.
poly_lib.tex(,432) 
poly_lib.tex(,433) @end table
poly_lib.tex(,434) @strong{Example:}
poly_lib.tex(,435) @smallexample
poly_lib.tex(,436) @c computed example mindeg d2t_singular/poly_lib.doc:376 
poly_lib.tex(,437) LIB "poly.lib";
poly_lib.tex(,438) ring r = 0,(x,y,z),ls;
poly_lib.tex(,439) poly f = x5+y2+z3;
poly_lib.tex(,440) ord(f);                  // ord returns weighted order of leading term!
poly_lib.tex(,441) @expansion{} 3
poly_lib.tex(,442) mindeg(f);               // computes minimal degree
poly_lib.tex(,443) @expansion{} 2
poly_lib.tex(,444) matrix m[2][2]=x10,1,0,f^2;
poly_lib.tex(,445) mindeg(m);               // computes matrix of minimum degrees
poly_lib.tex(,446) @expansion{} 10,0,
poly_lib.tex(,447) @expansion{} -1,4 
poly_lib.tex(,448) @c end example mindeg d2t_singular/poly_lib.doc:376
poly_lib.tex(,449) @end smallexample
poly_lib.tex(,450) @c ---end content mindeg---
poly_lib.tex(,451) 
poly_lib.tex(,452) @c ------------------- mindeg1 -------------
poly_lib.tex(,453) @node mindeg1, normalize, mindeg, poly_lib
poly_lib.tex(,454) @subsubsection mindeg1
poly_lib.tex(,455) @cindex mindeg1
poly_lib.tex(,456) @c ---content mindeg1---
poly_lib.tex(,457) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,458) 
poly_lib.tex(,459) @table @asis
poly_lib.tex(,460) @item @strong{Usage:}
poly_lib.tex(,461) mindeg1(id[,v]); id=poly/ideal/vector/module/matrix, v=intvec
poly_lib.tex(,462) 
poly_lib.tex(,463) @item @strong{Return:}
poly_lib.tex(,464) integer, minimal [weighted] degree of monomials of id independent of
poly_lib.tex(,465) ring ordering, mindeg1 of i-th variable is v[i] (default v=1..1).
poly_lib.tex(,466) 
poly_lib.tex(,467) @item @strong{Note:}
poly_lib.tex(,468) This proc returns one integer while mindeg returns, in general,
poly_lib.tex(,469) a matrix of integers. For one polynomial and if no intvec v is given
poly_lib.tex(,470) mindeg is faster.
poly_lib.tex(,471) 
poly_lib.tex(,472) @end table
poly_lib.tex(,473) @strong{Example:}
poly_lib.tex(,474) @smallexample
poly_lib.tex(,475) @c computed example mindeg1 d2t_singular/poly_lib.doc:411 
poly_lib.tex(,476) LIB "poly.lib";
poly_lib.tex(,477) ring r = 0,(x,y,z),ls;
poly_lib.tex(,478) poly f = x5+y2+z3;
poly_lib.tex(,479) ord(f);                  // ord returns weighted order of leading term!
poly_lib.tex(,480) @expansion{} 3
poly_lib.tex(,481) intvec v = 1,-3,2;
poly_lib.tex(,482) mindeg1(f,v);            // computes minimal weighted degree
poly_lib.tex(,483) @expansion{} -6
poly_lib.tex(,484) matrix m[2][2]=x10,1,0,f^2;
poly_lib.tex(,485) mindeg1(m,1..3);         // computes absolute minimum of weighted degrees
poly_lib.tex(,486) @expansion{} -1
poly_lib.tex(,487) @c end example mindeg1 d2t_singular/poly_lib.doc:411
poly_lib.tex(,488) @end smallexample
poly_lib.tex(,489) @c ---end content mindeg1---
poly_lib.tex(,490) 
poly_lib.tex(,491) @c ------------------- normalize -------------
poly_lib.tex(,492) @node normalize, rad_con, mindeg1, poly_lib
poly_lib.tex(,493) @subsubsection normalize
poly_lib.tex(,494) @cindex normalize
poly_lib.tex(,495) @c ---content normalize---
poly_lib.tex(,496) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,497) 
poly_lib.tex(,498) @table @asis
poly_lib.tex(,499) @item @strong{Usage:}
poly_lib.tex(,500) normalize(id); id=poly/vector/ideal/module
poly_lib.tex(,501) 
poly_lib.tex(,502) @item @strong{Return:}
poly_lib.tex(,503) object of same type with leading coefficient equal to 1
poly_lib.tex(,504) 
poly_lib.tex(,505) @end table
poly_lib.tex(,506) @strong{Example:}
poly_lib.tex(,507) @smallexample
poly_lib.tex(,508) @c computed example normalize d2t_singular/poly_lib.doc:441 
poly_lib.tex(,509) LIB "poly.lib";
poly_lib.tex(,510) ring r = 0,(x,y,z),ls;
poly_lib.tex(,511) poly f = 2x5+3y2+4z3;
poly_lib.tex(,512) normalize(f);
poly_lib.tex(,513) @expansion{} z3+3/4y2+1/2x5
poly_lib.tex(,514) module m=[9xy,0,3z3],[4z,6y,2x];
poly_lib.tex(,515) normalize(m);
poly_lib.tex(,516) @expansion{} _[1]=z3*gen(3)+3xy*gen(1)
poly_lib.tex(,517) @expansion{} _[2]=z*gen(1)+3/2y*gen(2)+1/2x*gen(3)
poly_lib.tex(,518) ring s = 0,(x,y,z),(c,ls);
poly_lib.tex(,519) module m=[9xy,0,3z3],[4z,6y,2x];
poly_lib.tex(,520) normalize(m);
poly_lib.tex(,521) @expansion{} _[1]=[xy,0,1/3z3]
poly_lib.tex(,522) @expansion{} _[2]=[z,3/2y,1/2x]
poly_lib.tex(,523) @c end example normalize d2t_singular/poly_lib.doc:441
poly_lib.tex(,524) @end smallexample
poly_lib.tex(,525) @c ---end content normalize---
poly_lib.tex(,526) 
poly_lib.tex(,527) @c ------------------- rad_con -------------
poly_lib.tex(,528) @node rad_con, content, normalize, poly_lib
poly_lib.tex(,529) @subsubsection rad_con
poly_lib.tex(,530) @cindex rad_con
poly_lib.tex(,531) @c ---content rad_con---
poly_lib.tex(,532) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,533) 
poly_lib.tex(,534) @table @asis
poly_lib.tex(,535) @item @strong{Usage:}
poly_lib.tex(,536) rad_con(g,I); g polynomial, I ideal
poly_lib.tex(,537) 
poly_lib.tex(,538) @item @strong{Return:}
poly_lib.tex(,539) 1 (TRUE) (type int) if g is contained in the radical of I
poly_lib.tex(,540) @* 0 (FALSE) (type int) otherwise
poly_lib.tex(,541) 
poly_lib.tex(,542) @end table
poly_lib.tex(,543) @strong{Example:}
poly_lib.tex(,544) @smallexample
poly_lib.tex(,545) @c computed example rad_con d2t_singular/poly_lib.doc:473 
poly_lib.tex(,546) LIB "poly.lib";
poly_lib.tex(,547) ring R=0,(x,y,z),dp;
poly_lib.tex(,548) ideal I=x2+y2,z2;
poly_lib.tex(,549) poly f=x4+y4;
poly_lib.tex(,550) rad_con(f,I);
poly_lib.tex(,551) @expansion{} 0
poly_lib.tex(,552) ideal J=x2+y2,z2,x4+y4;
poly_lib.tex(,553) poly g=z;
poly_lib.tex(,554) rad_con(g,I);
poly_lib.tex(,555) @expansion{} 1
poly_lib.tex(,556) @c end example rad_con d2t_singular/poly_lib.doc:473
poly_lib.tex(,557) @end smallexample
poly_lib.tex(,558) @c ---end content rad_con---
poly_lib.tex(,559) 
poly_lib.tex(,560) @c ------------------- content -------------
poly_lib.tex(,561) @node content, numerator, rad_con, poly_lib
poly_lib.tex(,562) @subsubsection content
poly_lib.tex(,563) @cindex content
poly_lib.tex(,564) @c ---content content---
poly_lib.tex(,565) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,566) 
poly_lib.tex(,567) @table @asis
poly_lib.tex(,568) @item @strong{Usage:}
poly_lib.tex(,569) content(f); f polynomial/vector
poly_lib.tex(,570) 
poly_lib.tex(,571) @item @strong{Return:}
poly_lib.tex(,572) number, the content (greatest common factor of coefficients)
poly_lib.tex(,573) of the polynomial/vector f
poly_lib.tex(,574) 
poly_lib.tex(,575) @end table
poly_lib.tex(,576) @strong{Example:}
poly_lib.tex(,577) @smallexample
poly_lib.tex(,578) @c computed example content d2t_singular/poly_lib.doc:504 
poly_lib.tex(,579) LIB "poly.lib";
poly_lib.tex(,580) ring r=0,(x,y,z),(c,lp);
poly_lib.tex(,581) content(3x2+18xy-27xyz);
poly_lib.tex(,582) @expansion{} 3
poly_lib.tex(,583) vector v=[3x2+18xy-27xyz,15x2+12y4,3];
poly_lib.tex(,584) content(v);
poly_lib.tex(,585) @expansion{} 3
poly_lib.tex(,586) @c end example content d2t_singular/poly_lib.doc:504
poly_lib.tex(,587) @end smallexample
poly_lib.tex(,588) @c ---end content content---
poly_lib.tex(,589) 
poly_lib.tex(,590) @c ------------------- numerator -------------
poly_lib.tex(,591) @node numerator, denominator, content, poly_lib
poly_lib.tex(,592) @subsubsection numerator
poly_lib.tex(,593) @cindex numerator
poly_lib.tex(,594) @c ---content numerator---
poly_lib.tex(,595) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,596) 
poly_lib.tex(,597) @table @asis
poly_lib.tex(,598) @item @strong{Usage:}
poly_lib.tex(,599) numerator(n); n number
poly_lib.tex(,600) 
poly_lib.tex(,601) @item @strong{Return:}
poly_lib.tex(,602) number, the numerator of n
poly_lib.tex(,603) 
poly_lib.tex(,604) @end table
poly_lib.tex(,605) @strong{Example:}
poly_lib.tex(,606) @smallexample
poly_lib.tex(,607) @c computed example numerator d2t_singular/poly_lib.doc:531 
poly_lib.tex(,608) LIB "poly.lib";
poly_lib.tex(,609) ring r = 0,x, dp;
poly_lib.tex(,610) number n = 3/2;
poly_lib.tex(,611) numerator(n);
poly_lib.tex(,612) @expansion{} 3
poly_lib.tex(,613) @c end example numerator d2t_singular/poly_lib.doc:531
poly_lib.tex(,614) @end smallexample
poly_lib.tex(,615) @c inserted refs from d2t_singular/poly_lib.doc:538
poly_lib.tex(,630) @c end inserted refs from d2t_singular/poly_lib.doc:538
poly_lib.tex(,631) 
poly_lib.tex(,632) @c ---end content numerator---
poly_lib.tex(,633) 
poly_lib.tex(,634) @c ------------------- denominator -------------
poly_lib.tex(,635) @node denominator, mod2id, numerator, poly_lib
poly_lib.tex(,636) @subsubsection denominator
poly_lib.tex(,637) @cindex denominator
poly_lib.tex(,638) @c ---content denominator---
poly_lib.tex(,639) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,640) 
poly_lib.tex(,641) @table @asis
poly_lib.tex(,642) @item @strong{Usage:}
poly_lib.tex(,643) denominator(n); n number
poly_lib.tex(,644) 
poly_lib.tex(,645) @item @strong{Return:}
poly_lib.tex(,646) number, the denominator of n
poly_lib.tex(,647) 
poly_lib.tex(,648) @end table
poly_lib.tex(,649) @strong{Example:}
poly_lib.tex(,650) @smallexample
poly_lib.tex(,651) @c computed example denominator d2t_singular/poly_lib.doc:561 
poly_lib.tex(,652) LIB "poly.lib";
poly_lib.tex(,653) ring r = 0,x, dp;
poly_lib.tex(,654) number n = 3/2;
poly_lib.tex(,655) denominator(n);
poly_lib.tex(,656) @expansion{} 2
poly_lib.tex(,657) @c end example denominator d2t_singular/poly_lib.doc:561
poly_lib.tex(,658) @end smallexample
poly_lib.tex(,659) @c inserted refs from d2t_singular/poly_lib.doc:568
poly_lib.tex(,674) @c end inserted refs from d2t_singular/poly_lib.doc:568
poly_lib.tex(,675) 
poly_lib.tex(,676) @c ---end content denominator---
poly_lib.tex(,677) 
poly_lib.tex(,678) @c ------------------- mod2id -------------
poly_lib.tex(,679) @node mod2id, id2mod, denominator, poly_lib
poly_lib.tex(,680) @subsubsection mod2id
poly_lib.tex(,681) @cindex mod2id
poly_lib.tex(,682) @c ---content mod2id---
poly_lib.tex(,683) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,684) 
poly_lib.tex(,685) @table @asis
poly_lib.tex(,686) @item @strong{Usage:}
poly_lib.tex(,687) mod2id(M,vpos); M matrix, vpos intvec
poly_lib.tex(,688) 
poly_lib.tex(,689) @item @strong{Assume:}
poly_lib.tex(,690) vpos is an integer vector such that gen(i) corresponds
poly_lib.tex(,691) to var(vpos[i]).
poly_lib.tex(,692) @*The basering contains variables var(vpos[i]) which do not occur
poly_lib.tex(,693) in M.
poly_lib.tex(,694) 
poly_lib.tex(,695) @item @strong{Return:}
poly_lib.tex(,696) ideal I in which each gen(i) from the module is replaced by
poly_lib.tex(,697) var(vpos[i]) and all monomials var(vpos[i])*var(vpos[j]) have
poly_lib.tex(,698) been added to the generating set of I.
poly_lib.tex(,699) 
poly_lib.tex(,700) @item @strong{Note:}
poly_lib.tex(,701) This procedure should be used in the following situation:
poly_lib.tex(,702) one wants to pass to a ring with new variables, say e(1),..,e(s),
poly_lib.tex(,703) which correspond to the components gen(1),..,gen(s) of the
poly_lib.tex(,704) module M such that e(i)*e(j)=0 for all i,j.
poly_lib.tex(,705) @*The new ring should already exist and be the current ring
poly_lib.tex(,706) 
poly_lib.tex(,707) @end table
poly_lib.tex(,708) @strong{Example:}
poly_lib.tex(,709) @smallexample
poly_lib.tex(,710) @c computed example mod2id d2t_singular/poly_lib.doc:606 
poly_lib.tex(,711) LIB "poly.lib";
poly_lib.tex(,712) ring r=0,(e(1),e(2),x,y,z),(dp(2),ds(3));
poly_lib.tex(,713) module mo=x*gen(1)+y*gen(2);
poly_lib.tex(,714) intvec iv=2,1;
poly_lib.tex(,715) mod2id(mo,iv);
poly_lib.tex(,716) @expansion{} _[1]=e(2)^2
poly_lib.tex(,717) @expansion{} _[2]=e(1)*e(2)
poly_lib.tex(,718) @expansion{} _[3]=e(1)^2
poly_lib.tex(,719) @expansion{} _[4]=e(1)*y+e(2)*x
poly_lib.tex(,720) @c end example mod2id d2t_singular/poly_lib.doc:606
poly_lib.tex(,721) @end smallexample
poly_lib.tex(,722) @c ---end content mod2id---
poly_lib.tex(,723) 
poly_lib.tex(,724) @c ------------------- id2mod -------------
poly_lib.tex(,725) @node id2mod, substitute, mod2id, poly_lib
poly_lib.tex(,726) @subsubsection id2mod
poly_lib.tex(,727) @cindex id2mod
poly_lib.tex(,728) @c ---content id2mod---
poly_lib.tex(,729) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,730) 
poly_lib.tex(,731) @table @asis
poly_lib.tex(,732) @item @strong{Usage:}
poly_lib.tex(,733) id2mod(I,vpos); I ideal, vpos intvec
poly_lib.tex(,734) 
poly_lib.tex(,735) @item @strong{Return:}
poly_lib.tex(,736) module corresponding to the ideal by replacing var(vpos[i]) by
poly_lib.tex(,737) gen(i) and omitting all generators var(vpos[i])*var(vpos[j])
poly_lib.tex(,738) 
poly_lib.tex(,739) @item @strong{Note:}
poly_lib.tex(,740) * This procedure only makes sense if the ideal contains
poly_lib.tex(,741) all var(vpos[i])*var(vpos[j]) as monomial generators and
poly_lib.tex(,742) all other generators of I are linear combinations of the
poly_lib.tex(,743) var(vpos[i]) over the ring in the other variables.
poly_lib.tex(,744) @** This is the inverse procedure to mod2id and should be applied
poly_lib.tex(,745) only to ideals created by mod2id using the same intvec vpos
poly_lib.tex(,746) (possibly after a standard basis computation)
poly_lib.tex(,747) 
poly_lib.tex(,748) @end table
poly_lib.tex(,749) @strong{Example:}
poly_lib.tex(,750) @smallexample
poly_lib.tex(,751) @c computed example id2mod d2t_singular/poly_lib.doc:643 
poly_lib.tex(,752) LIB "poly.lib";
poly_lib.tex(,753) ring r=0,(e(1),e(2),x,y,z),(dp(2),ds(3));
poly_lib.tex(,754) ideal i=e(2)^2,e(1)*e(2),e(1)^2,e(1)*y+e(2)*x;
poly_lib.tex(,755) intvec iv=2,1;
poly_lib.tex(,756) id2mod(i,iv);
poly_lib.tex(,757) @expansion{} _[1]=x*gen(1)+y*gen(2)
poly_lib.tex(,758) @c end example id2mod d2t_singular/poly_lib.doc:643
poly_lib.tex(,759) @end smallexample
poly_lib.tex(,760) @c ---end content id2mod---
poly_lib.tex(,761) 
poly_lib.tex(,762) @c ------------------- substitute -------------
poly_lib.tex(,763) @node substitute, subrInterred, id2mod, poly_lib
poly_lib.tex(,764) @subsubsection substitute
poly_lib.tex(,765) @cindex substitute
poly_lib.tex(,766) @c ---content substitute---
poly_lib.tex(,767) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,768) 
poly_lib.tex(,769) @table @asis
poly_lib.tex(,770) @item @strong{Usage:}
poly_lib.tex(,771) - case 1: typeof(#[1])==poly:
poly_lib.tex(,772) @*substitute (I,v,f[,v1,f1,v2,f2,...]); I object of basering which
poly_lib.tex(,773) can be mapped, v,v1,v2,.. ring variables, f,f1,f2,... poly
poly_lib.tex(,774) @* - case 2: typeof(#[1])==ideal:
poly_lib.tex(,775) substitute1 (I,v,f); I object of basering which can be mapped,
poly_lib.tex(,776) v ideal of ring variables, f ideal
poly_lib.tex(,777) 
poly_lib.tex(,778) @item @strong{Return:}
poly_lib.tex(,779) object of same type as I,
poly_lib.tex(,780) @* - case 1: ring variable v,v1,v2,... substituted by polynomials
poly_lib.tex(,781) f,f1,f2,..., in this order
poly_lib.tex(,782) @* - case 2: ring variables in v substituted by polynomials in f:
poly_lib.tex(,783) v[i] is substituted by f[i], i=1,...,i=min(size(v),ncols(f))
poly_lib.tex(,784) 
poly_lib.tex(,785) @item @strong{Note:}
poly_lib.tex(,786) this procedure extends the built-in command subst which substitutes
poly_lib.tex(,787) ring variables only by monomials
poly_lib.tex(,788) 
poly_lib.tex(,789) @end table
poly_lib.tex(,790) @strong{Example:}
poly_lib.tex(,791) @smallexample
poly_lib.tex(,792) @c computed example substitute d2t_singular/poly_lib.doc:683 
poly_lib.tex(,793) LIB "poly.lib";
poly_lib.tex(,794) ring r = 0,(b,c,t),dp;
poly_lib.tex(,795) ideal I = -bc+4b2c2t,bc2t-5b2c;
poly_lib.tex(,796) substitute(I,c,b+c,t,0,b,b-1);
poly_lib.tex(,797) @expansion{} _[1]=-b2-bc+2b+c-1
poly_lib.tex(,798) @expansion{} _[2]=-5b3-5b2c+15b2+10bc-15b-5c+5
poly_lib.tex(,799) ideal v = c,t,b;
poly_lib.tex(,800) ideal f = b+c,0,b-1;
poly_lib.tex(,801) substitute(I,v,f);
poly_lib.tex(,802) @expansion{} _[1]=-b2-bc+2b+c-1
poly_lib.tex(,803) @expansion{} _[2]=-5b3-5b2c+15b2+10bc-15b-5c+5
poly_lib.tex(,804) @c end example substitute d2t_singular/poly_lib.doc:683
poly_lib.tex(,805) @end smallexample
poly_lib.tex(,806) @c ---end content substitute---
poly_lib.tex(,807) 
poly_lib.tex(,808) @c ------------------- subrInterred -------------
poly_lib.tex(,809) @node subrInterred, hilbPoly, substitute, poly_lib
poly_lib.tex(,810) @subsubsection subrInterred
poly_lib.tex(,811) @cindex subrInterred
poly_lib.tex(,812) @c ---content subrInterred---
poly_lib.tex(,813) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,814) 
poly_lib.tex(,815) @table @asis
poly_lib.tex(,816) @item @strong{Usage:}
poly_lib.tex(,817) subrInterred(mon,sm,iv);
poly_lib.tex(,818) @*sm: ideal in a ring r with n + s variables,
poly_lib.tex(,819) @*e.g. x_1,..,x_n and t_1,..,t_s
poly_lib.tex(,820) @*mon: ideal with monomial generators (not divisible by
poly_lib.tex(,821) any of the t_i) such that sm is contained in the module
poly_lib.tex(,822) k[t_1,..,t_s]*mon[1]+..+k[t_1,..,t_s]*mon[size(mon)]
poly_lib.tex(,823) @*iv: intvec listing the variables which are supposed to be used
poly_lib.tex(,824) as x_i
poly_lib.tex(,825) 
poly_lib.tex(,826) @item @strong{Return:}
poly_lib.tex(,827) list l:
poly_lib.tex(,828) @*l[1]=the monomials from mon in the order used
poly_lib.tex(,829) @*l[2]=their coefficients after interreduction
poly_lib.tex(,830) @*l[3]=l[1]*l[2]
poly_lib.tex(,831) 
poly_lib.tex(,832) @item @strong{Purpose:}
poly_lib.tex(,833) Do interred only w.r.t. a subset of variables.
poly_lib.tex(,834) @*The procedure returns an interreduced system of generators of
poly_lib.tex(,835) sm considered as a k[t_1,..,t_s]-submodule of the free module
poly_lib.tex(,836) k[t_1,..,t_s]*mon[1]+..+k[t_1,..,t_s]*mon[size(mon)]).
poly_lib.tex(,837) 
poly_lib.tex(,838) @end table
poly_lib.tex(,839) @strong{Example:}
poly_lib.tex(,840) @smallexample
poly_lib.tex(,841) @c computed example subrInterred d2t_singular/poly_lib.doc:728 
poly_lib.tex(,842) LIB "poly.lib";
poly_lib.tex(,843) ring r=0,(x,y,z),dp;
poly_lib.tex(,844) ideal i=x^2+x*y^2,x*y+x^2*y,z;
poly_lib.tex(,845) ideal j=x^2+x*y^2,x*y,z;
poly_lib.tex(,846) ideal mon=x^2,z,x*y;
poly_lib.tex(,847) intvec iv=1,3;
poly_lib.tex(,848) subrInterred(mon,i,iv);
poly_lib.tex(,849) @expansion{} [1]:
poly_lib.tex(,850) @expansion{}    _[1,1]=z
poly_lib.tex(,851) @expansion{}    _[1,2]=xy
poly_lib.tex(,852) @expansion{}    _[1,3]=x2
poly_lib.tex(,853) @expansion{} [2]:
poly_lib.tex(,854) @expansion{}    _[1]=gen(1)
poly_lib.tex(,855) @expansion{}    _[2]=y2*gen(2)-gen(2)
poly_lib.tex(,856) @expansion{}    _[3]=y*gen(2)+gen(3)
poly_lib.tex(,857) @expansion{} [3]:
poly_lib.tex(,858) @expansion{}    _[1,1]=z
poly_lib.tex(,859) @expansion{}    _[1,2]=xy3-xy
poly_lib.tex(,860) @expansion{}    _[1,3]=xy2+x2
poly_lib.tex(,861) subrInterred(mon,j,iv);
poly_lib.tex(,862) @expansion{} [1]:
poly_lib.tex(,863) @expansion{}    _[1,1]=z
poly_lib.tex(,864) @expansion{}    _[1,2]=xy
poly_lib.tex(,865) @expansion{}    _[1,3]=x2
poly_lib.tex(,866) @expansion{} [2]:
poly_lib.tex(,867) @expansion{}    _[1]=gen(1)
poly_lib.tex(,868) @expansion{}    _[2]=gen(2)
poly_lib.tex(,869) @expansion{}    _[3]=gen(3)
poly_lib.tex(,870) @expansion{} [3]:
poly_lib.tex(,871) @expansion{}    _[1,1]=z
poly_lib.tex(,872) @expansion{}    _[1,2]=xy
poly_lib.tex(,873) @expansion{}    _[1,3]=x2
poly_lib.tex(,874) @c end example subrInterred d2t_singular/poly_lib.doc:728
poly_lib.tex(,875) @end smallexample
poly_lib.tex(,876) @c ---end content subrInterred---
poly_lib.tex(,877) 
poly_lib.tex(,878) @c ------------------- hilbPoly -------------
poly_lib.tex(,879) @node hilbPoly,, subrInterred, poly_lib
poly_lib.tex(,880) @subsubsection hilbPoly
poly_lib.tex(,881) @cindex hilbPoly
poly_lib.tex(,882) @c ---content hilbPoly---
poly_lib.tex(,883) Procedure from library @code{poly.lib} (@pxref{poly_lib}).
poly_lib.tex(,884) 
poly_lib.tex(,885) @table @asis
poly_lib.tex(,886) @item @strong{Usage:}
poly_lib.tex(,887) hilbPoly(I) I a homogeneous ideal
poly_lib.tex(,888) 
poly_lib.tex(,889) @item @strong{Return:}
poly_lib.tex(,890) the Hilbert polynomial of basering/I as an intvec v=v_0,...,v_r
poly_lib.tex(,891) such that the Hilbert polynomial is (v_0+v_1*t+...v_r*t^r)/r!
poly_lib.tex(,892) 
poly_lib.tex(,893) @end table
poly_lib.tex(,894) @strong{Example:}
poly_lib.tex(,895) @smallexample
poly_lib.tex(,896) @c computed example hilbPoly d2t_singular/poly_lib.doc:759 
poly_lib.tex(,897) LIB "poly.lib";
poly_lib.tex(,898) ring r = 0,(b,c,t,h),dp;
poly_lib.tex(,899) ideal I=
poly_lib.tex(,900) bct-t2h+2th2+h3,
poly_lib.tex(,901) bt3-ct3-t4+b2th+c2th-2bt2h+2ct2h+2t3h-bch2-2bth2+2cth2+2th3,
poly_lib.tex(,902) b2c2+bt2h-ct2h-t3h+b2h2+2bch2+c2h2-2bth2+2cth2+t2h2-2bh3+2ch3+2th3+3h4,
poly_lib.tex(,903) c2t3+ct4-c3th-2c2t2h-2ct3h-t4h+bc2h2-2c2th2-bt2h2+4t3h2+2bth3-2cth3-t2h3
poly_lib.tex(,904) +bh4-6th4-2h5;
poly_lib.tex(,905) hilbPoly(I);
poly_lib.tex(,906) @expansion{} -11,10
poly_lib.tex(,907) @c end example hilbPoly d2t_singular/poly_lib.doc:759
poly_lib.tex(,908) @end smallexample
poly_lib.tex(,909) @c ---end content hilbPoly---
singular.texi(,322) @c ----------------------------------------------------------
singular.texi(,323) @node random_lib, ring_lib, poly_lib, General purpose
singular.texi(,324) @subsection random_lib
singular.texi(,325) @c include of docu for random.lib
random_lib.tex(,1) @c ---content LibInfo---
random_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/random_lib.doc
random_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/random_lib.doc INSTEAD
random_lib.tex(,4) @c library version: (1.16.2.1,2002/02/20)
random_lib.tex(,5) @c library file: ../Singular/LIB/random.lib
random_lib.tex(,6) @cindex random.lib
random_lib.tex(,7) @cindex random_lib
random_lib.tex(,8) @table @asis
random_lib.tex(,9) @item @strong{Library:}
random_lib.tex(,10) random.lib
random_lib.tex(,11) @item @strong{Purpose:}
random_lib.tex(,12)     Creating Random and Sparse Matrices, Ideals, Polys
random_lib.tex(,13) 
random_lib.tex(,14) @end table
random_lib.tex(,15) 
random_lib.tex(,16) @strong{Procedures:}
random_lib.tex(,17) @menu
random_lib.tex(,18) * genericid:: generic sparse linear combinations of generators of i
random_lib.tex(,19) * randomid:: random linear combinations of generators of id
random_lib.tex(,20) * randommat:: nxm matrix of random linear combinations of id
random_lib.tex(,21) * sparseid:: ideal of k random sparse poly's of degree d [u<=d<=o]
random_lib.tex(,22) * sparsematrix:: nxm sparse matrix of polynomials of degree<=o
random_lib.tex(,23) * sparsemat:: nxm sparse integer matrix with random coefficients
random_lib.tex(,24) * sparsepoly:: random sparse polynomial with terms of degree in [u,o]
random_lib.tex(,25) * sparsetriag:: nxm sparse lower-triag intmat with random coefficients
random_lib.tex(,26) * triagmatrix:: nxm sparse lower-triag matrix of poly's of degree<=o
random_lib.tex(,27) * randomLast:: random transformation of the last variable
random_lib.tex(,28) * randomBinomial:: binomial ideal, k random generators of degree >=u
random_lib.tex(,29) @end menu
random_lib.tex(,30) @c ---end content LibInfo---
random_lib.tex(,31) 
random_lib.tex(,32) @c ------------------- genericid -------------
random_lib.tex(,33) @node genericid, randomid,, random_lib
random_lib.tex(,34) @subsubsection genericid
random_lib.tex(,35) @cindex genericid
random_lib.tex(,36) @c ---content genericid---
random_lib.tex(,37) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,38) 
random_lib.tex(,39) @table @asis
random_lib.tex(,40) @item @strong{Usage:}
random_lib.tex(,41) genericid(id,[,p,b]); id ideal/module, k,p,b integers
random_lib.tex(,42) 
random_lib.tex(,43) @item @strong{Return:}
random_lib.tex(,44) system of generators of id which are generic, sparse, triagonal linear
random_lib.tex(,45) combinations of given generators with coefficients in [1,b] and
random_lib.tex(,46) sparseness p percent, bigger p being sparser (default: p=75, b=30000)
random_lib.tex(,47) 
random_lib.tex(,48) @item @strong{Note:}
random_lib.tex(,49) For performance reasons try small bound b in characteristic 0
random_lib.tex(,50) 
random_lib.tex(,51) @end table
random_lib.tex(,52) @strong{Example:}
random_lib.tex(,53) @smallexample
random_lib.tex(,54) @c computed example genericid d2t_singular/random_lib.doc:52 
random_lib.tex(,55) LIB "random.lib";
random_lib.tex(,56) ring r=0,(t,x,y,z),ds;
random_lib.tex(,57) ideal i= x3+y4,z4+yx,t+x+y+z;
random_lib.tex(,58) genericid(i,0,10);
random_lib.tex(,59) @expansion{} _[1]=3t+3x+3y+3z+2xy+x3+y4+2z4
random_lib.tex(,60) @expansion{} _[2]=4t+4x+4y+4z+xy+z4
random_lib.tex(,61) @expansion{} _[3]=t+x+y+z
random_lib.tex(,62) module m=[x,0,0,0],[0,y2,0,0],[0,0,z3,0],[0,0,0,t4];
random_lib.tex(,63) print(genericid(m));
random_lib.tex(,64) @expansion{} x,      0,      0, 0,
random_lib.tex(,65) @expansion{} 17904y2,y2,     0, 0,
random_lib.tex(,66) @expansion{} 0,      24170z3,z3,0,
random_lib.tex(,67) @expansion{} 0,      0,      0, t4
random_lib.tex(,68) @c end example genericid d2t_singular/random_lib.doc:52
random_lib.tex(,69) @end smallexample
random_lib.tex(,70) @c ---end content genericid---
random_lib.tex(,71) 
random_lib.tex(,72) @c ------------------- randomid -------------
random_lib.tex(,73) @node randomid, randommat, genericid, random_lib
random_lib.tex(,74) @subsubsection randomid
random_lib.tex(,75) @cindex randomid
random_lib.tex(,76) @c ---content randomid---
random_lib.tex(,77) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,78) 
random_lib.tex(,79) @table @asis
random_lib.tex(,80) @item @strong{Usage:}
random_lib.tex(,81) randomid(id,[k,b]); id ideal/module, b,k integers
random_lib.tex(,82) 
random_lib.tex(,83) @item @strong{Return:}
random_lib.tex(,84) ideal/module having k generators which are random linear combinations
random_lib.tex(,85) of generators of id with coefficients in the interval [-b,b]
random_lib.tex(,86) (default: b=30000, k=size(id))
random_lib.tex(,87) 
random_lib.tex(,88) @item @strong{Note:}
random_lib.tex(,89) For performance reasons try small bound b in characteristic 0
random_lib.tex(,90) 
random_lib.tex(,91) @end table
random_lib.tex(,92) @strong{Example:}
random_lib.tex(,93) @smallexample
random_lib.tex(,94) @c computed example randomid d2t_singular/random_lib.doc:85 
random_lib.tex(,95) LIB "random.lib";
random_lib.tex(,96) ring r=0,(x,y,z),dp;
random_lib.tex(,97) randomid(maxideal(2),2,9);
random_lib.tex(,98) @expansion{} _[1]=-5x2-9xy+6y2-8xz-8yz+4z2
random_lib.tex(,99) @expansion{} _[2]=-9xy+2y2+xz+yz-z2
random_lib.tex(,100) module m=[x,0,1],[0,y2,0],[y,0,z3];
random_lib.tex(,101) show(randomid(m));
random_lib.tex(,102) @expansion{} // module, 3 generator(s)
random_lib.tex(,103) @expansion{} [1369x-11685y,-4481y2,-11685z3+1369]
random_lib.tex(,104) @expansion{} [-642x-13756y,25342y2,-13756z3-642]
random_lib.tex(,105) @expansion{} [2536x-6355y,8285y2,-6355z3+2536]
random_lib.tex(,106) @c end example randomid d2t_singular/random_lib.doc:85
random_lib.tex(,107) @end smallexample
random_lib.tex(,108) @c ---end content randomid---
random_lib.tex(,109) 
random_lib.tex(,110) @c ------------------- randommat -------------
random_lib.tex(,111) @node randommat, sparseid, randomid, random_lib
random_lib.tex(,112) @subsubsection randommat
random_lib.tex(,113) @cindex randommat
random_lib.tex(,114) @c ---content randommat---
random_lib.tex(,115) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,116) 
random_lib.tex(,117) @table @asis
random_lib.tex(,118) @item @strong{Usage:}
random_lib.tex(,119) randommat(n,m[,id,b]); n,m,b integers, id ideal
random_lib.tex(,120) 
random_lib.tex(,121) @item @strong{Return:}
random_lib.tex(,122) nxm matrix, entries are random linear combinations of elements
random_lib.tex(,123) of id and coefficients in [-b,b]
random_lib.tex(,124) @*[default: (id,b) = (maxideal(1),30000)]
random_lib.tex(,125) 
random_lib.tex(,126) @item @strong{Note:}
random_lib.tex(,127) For performance reasons try small bound b in char 0
random_lib.tex(,128) 
random_lib.tex(,129) @end table
random_lib.tex(,130) @strong{Example:}
random_lib.tex(,131) @smallexample
random_lib.tex(,132) @c computed example randommat d2t_singular/random_lib.doc:117 
random_lib.tex(,133) LIB "random.lib";
random_lib.tex(,134) ring r=0,(x,y,z),dp;
random_lib.tex(,135) matrix A=randommat(3,3,maxideal(2),9);
random_lib.tex(,136) print(A);
random_lib.tex(,137) @expansion{} 9x2-2xy-8y2-9xz+yz+4z2, 9x2-4xy+y2-5xz+6yz-z2,   8x2+xy-9y2+2yz-8z2,    
random_lib.tex(,138) @expansion{} -x2+5xy-8y2-7xz+4yz-3z2,x2+xy-4y2-xz+5z2,        5x2-8xy+8y2+6xz+yz+7z2,
random_lib.tex(,139) @expansion{} 4x2-5xy-6y2-4yz-5z2,    -4x2-6xy-4y2-8xz+3yz+5z2,2x2+3xy+y2+4xz-3yz+2z2 
random_lib.tex(,140) A=randommat(2,3);
random_lib.tex(,141) print(A);
random_lib.tex(,142) @expansion{} 15276x+9897y+7526z,  6495x-24178y+11295z,-5745x-14754y+15979z,
random_lib.tex(,143) @expansion{} 20788x-28366y-20283z,24911x-10978y+3341z,12412x+11216y+15344z 
random_lib.tex(,144) @c end example randommat d2t_singular/random_lib.doc:117
random_lib.tex(,145) @end smallexample
random_lib.tex(,146) @c ---end content randommat---
random_lib.tex(,147) 
random_lib.tex(,148) @c ------------------- sparseid -------------
random_lib.tex(,149) @node sparseid, sparsematrix, randommat, random_lib
random_lib.tex(,150) @subsubsection sparseid
random_lib.tex(,151) @cindex sparseid
random_lib.tex(,152) @c ---content sparseid---
random_lib.tex(,153) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,154) 
random_lib.tex(,155) @table @asis
random_lib.tex(,156) @item @strong{Usage:}
random_lib.tex(,157) sparseid(k,u[,o,p,b]); k,u,o,p,b integers
random_lib.tex(,158) 
random_lib.tex(,159) @item @strong{Return:}
random_lib.tex(,160) ideal having k generators, each of degree d, u<=d<=o, p percent of
random_lib.tex(,161) terms in degree d are 0, the remaining have random coefficients
random_lib.tex(,162) in the interval [1,b], (default: o=u=d, p=75, b=30000)
random_lib.tex(,163) 
random_lib.tex(,164) @end table
random_lib.tex(,165) @strong{Example:}
random_lib.tex(,166) @smallexample
random_lib.tex(,167) @c computed example sparseid d2t_singular/random_lib.doc:147 
random_lib.tex(,168) LIB "random.lib";
random_lib.tex(,169) ring r = 0,(a,b,c,d),ds;
random_lib.tex(,170) sparseid(2,3);"";
random_lib.tex(,171) @expansion{} _[1]=12773a3+24263a2c+20030abc+17904b2c+26359c3
random_lib.tex(,172) @expansion{} _[2]=24004a3+6204b2c+24170bc2+19505c2d+21962bd2
random_lib.tex(,173) @expansion{} 
random_lib.tex(,174) sparseid(3,0,4,90,9);
random_lib.tex(,175) @expansion{} _[1]=1+4a2+8b2c+3c3+4a3b+4a2b2+5abc2+3ac3
random_lib.tex(,176) @expansion{} _[2]=a+a2+7ab2+6a2c+3c3+5a3b+9ab3+2c4+3c3d+8ad3
random_lib.tex(,177) @expansion{} _[3]=5a+ab+2ac2+2b3c+8abcd
random_lib.tex(,178) @c end example sparseid d2t_singular/random_lib.doc:147
random_lib.tex(,179) @end smallexample
random_lib.tex(,180) @c ---end content sparseid---
random_lib.tex(,181) 
random_lib.tex(,182) @c ------------------- sparsematrix -------------
random_lib.tex(,183) @node sparsematrix, sparsemat, sparseid, random_lib
random_lib.tex(,184) @subsubsection sparsematrix
random_lib.tex(,185) @cindex sparsematrix
random_lib.tex(,186) @c ---content sparsematrix---
random_lib.tex(,187) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,188) 
random_lib.tex(,189) @table @asis
random_lib.tex(,190) @item @strong{Usage:}
random_lib.tex(,191) sparsematrix(n,m,o[,u,pe,pp,b]); n,m,o,u,pe,pp,b integers
random_lib.tex(,192) 
random_lib.tex(,193) @item @strong{Return:}
random_lib.tex(,194) nxm matrix, about pe percent of the entries are 0, the remaining
random_lib.tex(,195) are random polynomials of degree d, u<=d<=o, with pp percent of
random_lib.tex(,196) the terms being 0, the remaining have random coefficients
random_lib.tex(,197) in the interval [1,b] [default: (pe,u,pp,b) = (0,50,75,100)]
random_lib.tex(,198) 
random_lib.tex(,199) @end table
random_lib.tex(,200) @strong{Example:}
random_lib.tex(,201) @smallexample
random_lib.tex(,202) @c computed example sparsematrix d2t_singular/random_lib.doc:176 
random_lib.tex(,203) LIB "random.lib";
random_lib.tex(,204) ring r = 0,(a,b,c,d),dp;
random_lib.tex(,205) // sparse matrix of sparse polys of degree <=2:
random_lib.tex(,206) print(sparsematrix(3,4,2));"";
random_lib.tex(,207) @expansion{} 14ab+20bc+79cd+30b,    32a2+97bc+5b,      0,             0,
random_lib.tex(,208) @expansion{} 0,                     0,                 6c2+16b+64c+76,0,
random_lib.tex(,209) @expansion{} 17a2+30ab+94bc+19b+45d,88a2+44bc+13d2+31a,59ac,          0 
random_lib.tex(,210) @expansion{} 
random_lib.tex(,211) // dense matrix of sparse linear forms:
random_lib.tex(,212) print(sparsematrix(3,3,1,1,0,55,9));
random_lib.tex(,213) @expansion{} 9b+7c+8d,9b+9d,5a,   
random_lib.tex(,214) @expansion{} 7c+d,    a+6b, 2b+2d,
random_lib.tex(,215) @expansion{} 9a+5b+9c,2a+9d,2d    
random_lib.tex(,216) @c end example sparsematrix d2t_singular/random_lib.doc:176
random_lib.tex(,217) @end smallexample
random_lib.tex(,218) @c ---end content sparsematrix---
random_lib.tex(,219) 
random_lib.tex(,220) @c ------------------- sparsemat -------------
random_lib.tex(,221) @node sparsemat, sparsepoly, sparsematrix, random_lib
random_lib.tex(,222) @subsubsection sparsemat
random_lib.tex(,223) @cindex sparsemat
random_lib.tex(,224) @c ---content sparsemat---
random_lib.tex(,225) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,226) 
random_lib.tex(,227) @table @asis
random_lib.tex(,228) @item @strong{Usage:}
random_lib.tex(,229) sparsemat(n,m[,p,b]); n,m,p,b integers
random_lib.tex(,230) 
random_lib.tex(,231) @item @strong{Return:}
random_lib.tex(,232) nxm integer matrix, p percent of the entries are 0, the remaining
random_lib.tex(,233) are random coefficients >=1 and <= b; [defaults: (p,b) = (75,1)]
random_lib.tex(,234) 
random_lib.tex(,235) @end table
random_lib.tex(,236) @strong{Example:}
random_lib.tex(,237) @smallexample
random_lib.tex(,238) @c computed example sparsemat d2t_singular/random_lib.doc:205 
random_lib.tex(,239) LIB "random.lib";
random_lib.tex(,240) sparsemat(5,5);"";
random_lib.tex(,241) @expansion{} 0,0,0,0,0,
random_lib.tex(,242) @expansion{} 0,1,0,0,1,
random_lib.tex(,243) @expansion{} 0,0,0,1,0,
random_lib.tex(,244) @expansion{} 0,1,0,0,0,
random_lib.tex(,245) @expansion{} 0,1,0,1,1 
random_lib.tex(,246) @expansion{} 
random_lib.tex(,247) sparsemat(5,5,95);"";
random_lib.tex(,248) @expansion{} 1,0,0,0,0,
random_lib.tex(,249) @expansion{} 0,0,0,0,0,
random_lib.tex(,250) @expansion{} 0,0,0,0,0,
random_lib.tex(,251) @expansion{} 0,0,0,0,0,
random_lib.tex(,252) @expansion{} 0,0,0,1,0 
random_lib.tex(,253) @expansion{} 
random_lib.tex(,254) sparsemat(5,5,5);"";
random_lib.tex(,255) @expansion{} 1,1,1,1,1,
random_lib.tex(,256) @expansion{} 1,1,1,1,1,
random_lib.tex(,257) @expansion{} 1,1,1,1,1,
random_lib.tex(,258) @expansion{} 1,0,1,1,1,
random_lib.tex(,259) @expansion{} 1,1,1,1,0 
random_lib.tex(,260) @expansion{} 
random_lib.tex(,261) sparsemat(5,5,50,100);
random_lib.tex(,262) @expansion{} 0,17,24,80,0,
random_lib.tex(,263) @expansion{} 0,13,30,45,0,
random_lib.tex(,264) @expansion{} 19,0,0,0,0,
random_lib.tex(,265) @expansion{} 93,0,23,0,69,
random_lib.tex(,266) @expansion{} 0,88,44,31,0 
random_lib.tex(,267) @c end example sparsemat d2t_singular/random_lib.doc:205
random_lib.tex(,268) @end smallexample
random_lib.tex(,269) @c ---end content sparsemat---
random_lib.tex(,270) 
random_lib.tex(,271) @c ------------------- sparsepoly -------------
random_lib.tex(,272) @node sparsepoly, sparsetriag, sparsemat, random_lib
random_lib.tex(,273) @subsubsection sparsepoly
random_lib.tex(,274) @cindex sparsepoly
random_lib.tex(,275) @c ---content sparsepoly---
random_lib.tex(,276) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,277) 
random_lib.tex(,278) @table @asis
random_lib.tex(,279) @item @strong{Usage:}
random_lib.tex(,280) sparsepoly(u[,o,p,b]); u,o,p,b integers
random_lib.tex(,281) 
random_lib.tex(,282) @item @strong{Return:}
random_lib.tex(,283) poly having only terms in degree d, u<=d<=o, p percent of the terms
random_lib.tex(,284) in degree d are 0, the remaining have random coefficients in [1,b),
random_lib.tex(,285) (defaults: o=u=d, p=75, b=30000)
random_lib.tex(,286) 
random_lib.tex(,287) @end table
random_lib.tex(,288) @strong{Example:}
random_lib.tex(,289) @smallexample
random_lib.tex(,290) @c computed example sparsepoly d2t_singular/random_lib.doc:234 
random_lib.tex(,291) LIB "random.lib";
random_lib.tex(,292) ring r=0,(x,y,z),dp;
random_lib.tex(,293) sparsepoly(5);"";
random_lib.tex(,294) @expansion{} 24263xy4+24170x4z+21962x3yz+26642xy3z+5664xy2z2+17904xz4
random_lib.tex(,295) @expansion{} 
random_lib.tex(,296) sparsepoly(3,5,90,9);
random_lib.tex(,297) @expansion{} 8x3z2+2y3z2+3xyz3+2xy3+yz3+xy2
random_lib.tex(,298) @c end example sparsepoly d2t_singular/random_lib.doc:234
random_lib.tex(,299) @end smallexample
random_lib.tex(,300) @c ---end content sparsepoly---
random_lib.tex(,301) 
random_lib.tex(,302) @c ------------------- sparsetriag -------------
random_lib.tex(,303) @node sparsetriag, triagmatrix, sparsepoly, random_lib
random_lib.tex(,304) @subsubsection sparsetriag
random_lib.tex(,305) @cindex sparsetriag
random_lib.tex(,306) @c ---content sparsetriag---
random_lib.tex(,307) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,308) 
random_lib.tex(,309) @table @asis
random_lib.tex(,310) @item @strong{Usage:}
random_lib.tex(,311) sparsetriag(n,m[,p,b]); n,m,p,b integers
random_lib.tex(,312) 
random_lib.tex(,313) @item @strong{Return:}
random_lib.tex(,314) nxm lower triagonal integer matrix, diagonal entries equal to 1, about
random_lib.tex(,315) p percent of lower diagonal entries are 0, the remaining are random
random_lib.tex(,316) integers >=1 and <= b; [defaults: (p,b) = (75,1)]
random_lib.tex(,317) 
random_lib.tex(,318) @end table
random_lib.tex(,319) @strong{Example:}
random_lib.tex(,320) @smallexample
random_lib.tex(,321) @c computed example sparsetriag d2t_singular/random_lib.doc:262 
random_lib.tex(,322) LIB "random.lib";
random_lib.tex(,323) sparsetriag(5,7);"";
random_lib.tex(,324) @expansion{} 1,0,0,0,0,0,0,
random_lib.tex(,325) @expansion{} 0,1,0,0,0,0,0,
random_lib.tex(,326) @expansion{} 0,1,1,0,0,0,0,
random_lib.tex(,327) @expansion{} 0,0,0,1,0,0,0,
random_lib.tex(,328) @expansion{} 1,1,0,0,1,0,0 
random_lib.tex(,329) @expansion{} 
random_lib.tex(,330) sparsetriag(7,5,90);"";
random_lib.tex(,331) @expansion{} 1,0,0,0,0,
random_lib.tex(,332) @expansion{} 0,1,0,0,0,
random_lib.tex(,333) @expansion{} 0,1,1,0,0,
random_lib.tex(,334) @expansion{} 0,0,0,1,0,
random_lib.tex(,335) @expansion{} 0,0,0,0,1,
random_lib.tex(,336) @expansion{} 0,0,0,1,0,
random_lib.tex(,337) @expansion{} 0,1,0,0,0 
random_lib.tex(,338) @expansion{} 
random_lib.tex(,339) sparsetriag(5,5,0);"";
random_lib.tex(,340) @expansion{} 1,0,0,0,0,
random_lib.tex(,341) @expansion{} 1,1,0,0,0,
random_lib.tex(,342) @expansion{} 1,1,1,0,0,
random_lib.tex(,343) @expansion{} 1,1,1,1,0,
random_lib.tex(,344) @expansion{} 1,1,1,1,1 
random_lib.tex(,345) @expansion{} 
random_lib.tex(,346) sparsetriag(5,5,50,100);
random_lib.tex(,347) @expansion{} 1,0,0,0,0,
random_lib.tex(,348) @expansion{} 73,1,0,0,0,
random_lib.tex(,349) @expansion{} 0,79,1,0,0,
random_lib.tex(,350) @expansion{} 14,0,0,1,0,
random_lib.tex(,351) @expansion{} 0,48,23,0,1 
random_lib.tex(,352) @c end example sparsetriag d2t_singular/random_lib.doc:262
random_lib.tex(,353) @end smallexample
random_lib.tex(,354) @c ---end content sparsetriag---
random_lib.tex(,355) 
random_lib.tex(,356) @c ------------------- triagmatrix -------------
random_lib.tex(,357) @node triagmatrix, randomLast, sparsetriag, random_lib
random_lib.tex(,358) @subsubsection triagmatrix
random_lib.tex(,359) @cindex triagmatrix
random_lib.tex(,360) @c ---content triagmatrix---
random_lib.tex(,361) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,362) 
random_lib.tex(,363) @table @asis
random_lib.tex(,364) @item @strong{Usage:}
random_lib.tex(,365) triagmatrix(n,m,o[,u,pe,pp,b]); n,m,o,u,pe,pp,b integers
random_lib.tex(,366) 
random_lib.tex(,367) @item @strong{Return:}
random_lib.tex(,368) nxm lower triagonal matrix, diagonal entries equal to 1, about
random_lib.tex(,369) p percent of lower diagonal entries are 0, the remaining
random_lib.tex(,370) are random polynomials of degree d, u<=d<=o, with pp percent of
random_lib.tex(,371) the terms being 0, the remaining have random coefficients
random_lib.tex(,372) in the interval [1,b] [default: (pe,u,pp,b) = (0,50,75,100)]
random_lib.tex(,373) 
random_lib.tex(,374) @end table
random_lib.tex(,375) @strong{Example:}
random_lib.tex(,376) @smallexample
random_lib.tex(,377) @c computed example triagmatrix d2t_singular/random_lib.doc:293 
random_lib.tex(,378) LIB "random.lib";
random_lib.tex(,379) ring r = 0,(a,b,c,d),dp;
random_lib.tex(,380) // sparse triagonal matrix of sparse polys of degree <=2:
random_lib.tex(,381) print(triagmatrix(3,4,2));"";
random_lib.tex(,382) @expansion{} 1,                                 0,0,0,
random_lib.tex(,383) @expansion{} 52ac+54cd+14c,                     1,0,0,
random_lib.tex(,384) @expansion{} 17a2+19b2+45ac+94bc+50b+87c+54d+21,0,1,0 
random_lib.tex(,385) @expansion{} 
random_lib.tex(,386) // dense triagonal matrix of sparse linear forms:
random_lib.tex(,387) print(triagmatrix(3,3,1,1,0,55,9));
random_lib.tex(,388) @expansion{} 1,       0,    0,
random_lib.tex(,389) @expansion{} 7a+8d,   1,    0,
random_lib.tex(,390) @expansion{} 9b+7c+4d,7b+9d,1 
random_lib.tex(,391) @c end example triagmatrix d2t_singular/random_lib.doc:293
random_lib.tex(,392) @end smallexample
random_lib.tex(,393) @c ---end content triagmatrix---
random_lib.tex(,394) 
random_lib.tex(,395) @c ------------------- randomLast -------------
random_lib.tex(,396) @node randomLast, randomBinomial, triagmatrix, random_lib
random_lib.tex(,397) @subsubsection randomLast
random_lib.tex(,398) @cindex randomLast
random_lib.tex(,399) @c ---content randomLast---
random_lib.tex(,400) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,401) 
random_lib.tex(,402) @table @asis
random_lib.tex(,403) @item @strong{Usage:}
random_lib.tex(,404) randomLast(b); b int
random_lib.tex(,405) 
random_lib.tex(,406) @item @strong{Return:}
random_lib.tex(,407) ideal = maxideal(1), but the last variable is exchanged by a random
random_lib.tex(,408) linear combination of all variables, with coefficients in the
random_lib.tex(,409) interval [-b,b].
random_lib.tex(,410) 
random_lib.tex(,411) @end table
random_lib.tex(,412) @strong{Example:}
random_lib.tex(,413) @smallexample
random_lib.tex(,414) @c computed example randomLast d2t_singular/random_lib.doc:323 
random_lib.tex(,415) LIB "random.lib";
random_lib.tex(,416) ring  r = 0,(x,y,z),lp;
random_lib.tex(,417) ideal i = randomLast(10);
random_lib.tex(,418) i;
random_lib.tex(,419) @expansion{} i[1]=x
random_lib.tex(,420) @expansion{} i[2]=y
random_lib.tex(,421) @expansion{} i[3]=-x+z
random_lib.tex(,422) @c end example randomLast d2t_singular/random_lib.doc:323
random_lib.tex(,423) @end smallexample
random_lib.tex(,424) @c ---end content randomLast---
random_lib.tex(,425) 
random_lib.tex(,426) @c ------------------- randomBinomial -------------
random_lib.tex(,427) @node randomBinomial,, randomLast, random_lib
random_lib.tex(,428) @subsubsection randomBinomial
random_lib.tex(,429) @cindex randomBinomial
random_lib.tex(,430) @c ---content randomBinomial---
random_lib.tex(,431) Procedure from library @code{random.lib} (@pxref{random_lib}).
random_lib.tex(,432) 
random_lib.tex(,433) @table @asis
random_lib.tex(,434) @item @strong{Usage:}
random_lib.tex(,435) randomBinomial(k,u[,o,b]); k,u,o,b integers
random_lib.tex(,436) 
random_lib.tex(,437) @item @strong{Return:}
random_lib.tex(,438) binomial ideal, k homogeneous generators of degree d, u<=d<=o, with
random_lib.tex(,439) randomly chosen monomials and coefficients in the interval [-b,b]
random_lib.tex(,440) (default: u=o, b=10).
random_lib.tex(,441) 
random_lib.tex(,442) @end table
random_lib.tex(,443) @strong{Example:}
random_lib.tex(,444) @smallexample
random_lib.tex(,445) @c computed example randomBinomial d2t_singular/random_lib.doc:351 
random_lib.tex(,446) LIB "random.lib";
random_lib.tex(,447) ring  r = 0,(x,y,z),lp;
random_lib.tex(,448) ideal i = randomBinomial(4,5,6);
random_lib.tex(,449) i;
random_lib.tex(,450) @expansion{} i[1]=-x4z-xz4
random_lib.tex(,451) @expansion{} i[2]=8x2y3+8xy3z
random_lib.tex(,452) @expansion{} i[3]=-4x2y2z2-4xy5
random_lib.tex(,453) @expansion{} i[4]=5x3yz2+5xz5
random_lib.tex(,454) @c end example randomBinomial d2t_singular/random_lib.doc:351
random_lib.tex(,455) @end smallexample
random_lib.tex(,456) @c ---end content randomBinomial---
singular.texi(,327) @c ----------------------------------------------------------
singular.texi(,328) @node ring_lib, , random_lib, General purpose
singular.texi(,329) @subsection ring_lib
singular.texi(,330) @c include of docu for ring.lib
ring_lib.tex(,1) @c ---content LibInfo---
ring_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/ring_lib.doc
ring_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/ring_lib.doc INSTEAD
ring_lib.tex(,4) @c library version: (1.17.2.1,2002/02/20)
ring_lib.tex(,5) @c library file: ../Singular/LIB/ring.lib
ring_lib.tex(,6) @cindex ring.lib
ring_lib.tex(,7) @cindex ring_lib
ring_lib.tex(,8) @table @asis
ring_lib.tex(,9) @item @strong{Library:}
ring_lib.tex(,10) ring.lib
ring_lib.tex(,11) @item @strong{Purpose:}
ring_lib.tex(,12)       Manipulating Rings and Maps
ring_lib.tex(,13) 
ring_lib.tex(,14) @end table
ring_lib.tex(,15) 
ring_lib.tex(,16) @strong{Procedures:}
ring_lib.tex(,17) @menu
ring_lib.tex(,18) * changechar:: make a copy R of basering [ring r] with new char c
ring_lib.tex(,19) * changeord:: make a copy R of basering [ring r] with new ord o
ring_lib.tex(,20) * changevar:: make a copy R of basering [ring r] with new vars v
ring_lib.tex(,21) * defring:: define a ring R in specified char c, n vars v, ord o
ring_lib.tex(,22) * defrings:: define ring Sn in n vars, char 32003 [p], ord ds
ring_lib.tex(,23) * defringp:: define ring Pn in n vars, char 32003 [p], ord dp
ring_lib.tex(,24) * extendring:: extend given ring by n vars v, ord o and name it R
ring_lib.tex(,25) * fetchall:: fetch all objects of ring R to basering
ring_lib.tex(,26) * imapall:: imap all objects of ring R to basering
ring_lib.tex(,27) * mapall:: map all objects of ring R via ideal i to basering
ring_lib.tex(,28) * ord_test:: test whether ordering of R is global, local or mixed
ring_lib.tex(,29) * ringtensor:: create ring R, tensor product of rings s,t,...
ring_lib.tex(,30) * ringweights:: intvec of weights of ring variables of ring r
ring_lib.tex(,31) @end menu
ring_lib.tex(,32) @c ---end content LibInfo---
ring_lib.tex(,33) 
ring_lib.tex(,34) @c ------------------- changechar -------------
ring_lib.tex(,35) @node changechar, changeord,, ring_lib
ring_lib.tex(,36) @subsubsection changechar
ring_lib.tex(,37) @cindex changechar
ring_lib.tex(,38) @c ---content changechar---
ring_lib.tex(,39) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,40) 
ring_lib.tex(,41) @table @asis
ring_lib.tex(,42) @item @strong{Usage:}
ring_lib.tex(,43) changechar(newr,c[,r]); newr,c=strings, r=ring
ring_lib.tex(,44) 
ring_lib.tex(,45) @item @strong{Create:}
ring_lib.tex(,46) create a new ring with name `newr` and make it the basering if r is
ring_lib.tex(,47) an existing ring [default: r=basering].
ring_lib.tex(,48) @*The new ring differs from the old ring only in the characteristic.
ring_lib.tex(,49) If, say, (newr,c) = ("R","0,A") and the ring r exists, the new
ring_lib.tex(,50) basering will have name R, characteristic 0 and one parameter A.
ring_lib.tex(,51) 
ring_lib.tex(,52) @item @strong{Return:}
ring_lib.tex(,53) No return value
ring_lib.tex(,54) 
ring_lib.tex(,55) @item @strong{Note:}
ring_lib.tex(,56) Works for qrings if map from old_char to new_char is implemented
ring_lib.tex(,57) This proc uses 'execute' or calls a procedure using 'execute'.
ring_lib.tex(,58) If you use it in your own proc, let the local names of your proc
ring_lib.tex(,59) start with @@.
ring_lib.tex(,60) 
ring_lib.tex(,61) @end table
ring_lib.tex(,62) @strong{Example:}
ring_lib.tex(,63) @smallexample
ring_lib.tex(,64) @c computed example changechar d2t_singular/ring_lib.doc:62 
ring_lib.tex(,65) LIB "ring.lib";
ring_lib.tex(,66) ring r=0,(x,y,u,v),(dp(2),ds);
ring_lib.tex(,67) changechar("R","2,A"); R;"";
ring_lib.tex(,68) @expansion{} // basering is now R
ring_lib.tex(,69) @expansion{} //   characteristic : 2
ring_lib.tex(,70) @expansion{} //   1 parameter    : A 
ring_lib.tex(,71) @expansion{} //   minpoly        : 0
ring_lib.tex(,72) @expansion{} //   number of vars : 4
ring_lib.tex(,73) @expansion{} //        block   1 : ordering dp
ring_lib.tex(,74) @expansion{} //                  : names    x y 
ring_lib.tex(,75) @expansion{} //        block   2 : ordering ds
ring_lib.tex(,76) @expansion{} //                  : names    u v 
ring_lib.tex(,77) @expansion{} //        block   3 : ordering C
ring_lib.tex(,78) @expansion{} 
ring_lib.tex(,79) changechar("R1","32003",R); R1;
ring_lib.tex(,80) @expansion{} // basering is now R1
ring_lib.tex(,81) @expansion{} //   characteristic : 32003
ring_lib.tex(,82) @expansion{} //   number of vars : 4
ring_lib.tex(,83) @expansion{} //        block   1 : ordering dp
ring_lib.tex(,84) @expansion{} //                  : names    x y 
ring_lib.tex(,85) @expansion{} //        block   2 : ordering ds
ring_lib.tex(,86) @expansion{} //                  : names    u v 
ring_lib.tex(,87) @expansion{} //        block   3 : ordering C
ring_lib.tex(,88) kill R,R1;
ring_lib.tex(,89) if(system("with","Namespaces")) @{
ring_lib.tex(,90) if( nameof(Current) == "Ring" ) @{
ring_lib.tex(,91) kill Top::R,Top::R1;
ring_lib.tex(,92) @} else @{
ring_lib.tex(,93) kill Ring::R,Ring::R1;
ring_lib.tex(,94) @}
ring_lib.tex(,95) @}
ring_lib.tex(,96) @c end example changechar d2t_singular/ring_lib.doc:62
ring_lib.tex(,97) @end smallexample
ring_lib.tex(,98) @c ---end content changechar---
ring_lib.tex(,99) 
ring_lib.tex(,100) @c ------------------- changeord -------------
ring_lib.tex(,101) @node changeord, changevar, changechar, ring_lib
ring_lib.tex(,102) @subsubsection changeord
ring_lib.tex(,103) @cindex changeord
ring_lib.tex(,104) @c ---content changeord---
ring_lib.tex(,105) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,106) 
ring_lib.tex(,107) @table @asis
ring_lib.tex(,108) @item @strong{Usage:}
ring_lib.tex(,109) changeord(newr,o[,r]); newr,o=strings, r=ring/qring
ring_lib.tex(,110) 
ring_lib.tex(,111) @item @strong{Create:}
ring_lib.tex(,112) create a new ring with name `newr` and make it the basering if r is
ring_lib.tex(,113) an existing ring/qring [default: r=basering].
ring_lib.tex(,114) @*The new ring differs from the old ring only in the ordering. If, say,
ring_lib.tex(,115) (newr,o) = ("R","wp(2,3),dp") and the ring r exists and has >=3
ring_lib.tex(,116) variables, the new basering will have name R and ordering wp(2,3),dp.
ring_lib.tex(,117) 
ring_lib.tex(,118) @item @strong{Return:}
ring_lib.tex(,119) No return value
ring_lib.tex(,120) 
ring_lib.tex(,121) @item @strong{Note:}
ring_lib.tex(,122) This proc uses 'execute' or calls a procedure using 'execute'.
ring_lib.tex(,123) If you use it in your own proc, let the local names of your proc
ring_lib.tex(,124) start with @@.
ring_lib.tex(,125) 
ring_lib.tex(,126) @end table
ring_lib.tex(,127) @strong{Example:}
ring_lib.tex(,128) @smallexample
ring_lib.tex(,129) @c computed example changeord d2t_singular/ring_lib.doc:108 
ring_lib.tex(,130) LIB "ring.lib";
ring_lib.tex(,131) ring r=0,(x,y,u,v),(dp(2),ds);
ring_lib.tex(,132) changeord("R","wp(2,3),dp"); R; "";
ring_lib.tex(,133) @expansion{} // basering is now R
ring_lib.tex(,134) @expansion{} //   characteristic : 0
ring_lib.tex(,135) @expansion{} //   number of vars : 4
ring_lib.tex(,136) @expansion{} //        block   1 : ordering wp
ring_lib.tex(,137) @expansion{} //                  : names    x y 
ring_lib.tex(,138) @expansion{} //                  : weights  2 3 
ring_lib.tex(,139) @expansion{} //        block   2 : ordering dp
ring_lib.tex(,140) @expansion{} //                  : names    u v 
ring_lib.tex(,141) @expansion{} //        block   3 : ordering C
ring_lib.tex(,142) @expansion{} 
ring_lib.tex(,143) ideal i = x^2,y^2-u^3,v;
ring_lib.tex(,144) qring Q = std(i);
ring_lib.tex(,145) changeord("Q'","lp",Q); Q';
ring_lib.tex(,146) @expansion{} // basering is now Q'
ring_lib.tex(,147) @expansion{} //   characteristic : 0
ring_lib.tex(,148) @expansion{} //   number of vars : 4
ring_lib.tex(,149) @expansion{} //        block   1 : ordering lp
ring_lib.tex(,150) @expansion{} //                  : names    x y u v 
ring_lib.tex(,151) @expansion{} //        block   2 : ordering C
ring_lib.tex(,152) @expansion{} // quotient ring from ideal
ring_lib.tex(,153) @expansion{} _[1]=v
ring_lib.tex(,154) @expansion{} _[2]=x2
ring_lib.tex(,155) @expansion{} _[3]=y2-u3
ring_lib.tex(,156) kill R,Q,Q';
ring_lib.tex(,157) if(system("with","Namespaces")) @{
ring_lib.tex(,158) if( nameof(Current) == "Ring" ) @{
ring_lib.tex(,159) kill Top::R,Top::Q';
ring_lib.tex(,160) @} else @{
ring_lib.tex(,161) kill Ring::R,Ring::Q';
ring_lib.tex(,162) @}
ring_lib.tex(,163) @}
ring_lib.tex(,164) @c end example changeord d2t_singular/ring_lib.doc:108
ring_lib.tex(,165) @end smallexample
ring_lib.tex(,166) @c ---end content changeord---
ring_lib.tex(,167) 
ring_lib.tex(,168) @c ------------------- changevar -------------
ring_lib.tex(,169) @node changevar, defring, changeord, ring_lib
ring_lib.tex(,170) @subsubsection changevar
ring_lib.tex(,171) @cindex changevar
ring_lib.tex(,172) @c ---content changevar---
ring_lib.tex(,173) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,174) 
ring_lib.tex(,175) @table @asis
ring_lib.tex(,176) @item @strong{Usage:}
ring_lib.tex(,177) changevar(newr,vars[,r]); newr,vars=strings, r=ring/qring
ring_lib.tex(,178) 
ring_lib.tex(,179) @item @strong{Create:}
ring_lib.tex(,180) creates a new ring with name `newr` and makes it the basering if r
ring_lib.tex(,181) is an existing ring/qring [default: r=basering].
ring_lib.tex(,182) @*The new ring differs from the old ring only in the variables. If,
ring_lib.tex(,183) say, (newr,vars) = ("R","t()") and the ring r exists and has n
ring_lib.tex(,184) variables, the new basering will have name R and variables
ring_lib.tex(,185) t(1),...,t(n).
ring_lib.tex(,186) @*If vars = "a,b,c,d", the new ring will have the variables a,b,c,d.
ring_lib.tex(,187) 
ring_lib.tex(,188) @item @strong{Return:}
ring_lib.tex(,189) No return value
ring_lib.tex(,190) 
ring_lib.tex(,191) @item @strong{Note:}
ring_lib.tex(,192) This procedure is useful in connection with the procedure ringtensor,
ring_lib.tex(,193) when a conflict between variable names must be avoided.
ring_lib.tex(,194) This proc uses 'execute' or calls a procedure using 'execute'.
ring_lib.tex(,195) If you use it in your own proc, let the local names of your proc
ring_lib.tex(,196) start with @@.
ring_lib.tex(,197) 
ring_lib.tex(,198) @end table
ring_lib.tex(,199) @strong{Example:}
ring_lib.tex(,200) @smallexample
ring_lib.tex(,201) @c computed example changevar d2t_singular/ring_lib.doc:160 
ring_lib.tex(,202) LIB "ring.lib";
ring_lib.tex(,203) ring r=0,(x,y,u,v),(dp(2),ds);
ring_lib.tex(,204) ideal i = x^2,y^2-u^3,v;
ring_lib.tex(,205) qring Q = std(i);
ring_lib.tex(,206) setring(r);
ring_lib.tex(,207) changevar("R","A()"); R; "";
ring_lib.tex(,208) @expansion{} // basering is now R
ring_lib.tex(,209) @expansion{} //   characteristic : 0
ring_lib.tex(,210) @expansion{} //   number of vars : 4
ring_lib.tex(,211) @expansion{} //        block   1 : ordering dp
ring_lib.tex(,212) @expansion{} //                  : names    A(1) A(2) 
ring_lib.tex(,213) @expansion{} //        block   2 : ordering ds
ring_lib.tex(,214) @expansion{} //                  : names    A(3) A(4) 
ring_lib.tex(,215) @expansion{} //        block   3 : ordering C
ring_lib.tex(,216) @expansion{} 
ring_lib.tex(,217) changevar("Q'","a,b,c,d",Q); Q';
ring_lib.tex(,218) @expansion{} // basering is now Q'
ring_lib.tex(,219) @expansion{} //   characteristic : 0
ring_lib.tex(,220) @expansion{} //   number of vars : 4
ring_lib.tex(,221) @expansion{} //        block   1 : ordering dp
ring_lib.tex(,222) @expansion{} //                  : names    a b 
ring_lib.tex(,223) @expansion{} //        block   2 : ordering ds
ring_lib.tex(,224) @expansion{} //                  : names    c d 
ring_lib.tex(,225) @expansion{} //        block   3 : ordering C
ring_lib.tex(,226) @expansion{} // quotient ring from ideal
ring_lib.tex(,227) @expansion{} _[1]=d
ring_lib.tex(,228) @expansion{} _[2]=a2
ring_lib.tex(,229) @expansion{} _[3]=b2-c3
ring_lib.tex(,230) kill R,Q,Q';
ring_lib.tex(,231) if(system("with","Namespaces")) @{
ring_lib.tex(,232) if( nameof(Current) == "Ring" ) @{
ring_lib.tex(,233) kill Top::R,Top::Q';
ring_lib.tex(,234) @} else @{
ring_lib.tex(,235) kill Ring::R,Ring::Q';
ring_lib.tex(,236) @}
ring_lib.tex(,237) @}
ring_lib.tex(,238) @c end example changevar d2t_singular/ring_lib.doc:160
ring_lib.tex(,239) @end smallexample
ring_lib.tex(,240) @c ---end content changevar---
ring_lib.tex(,241) 
ring_lib.tex(,242) @c ------------------- defring -------------
ring_lib.tex(,243) @node defring, defrings, changevar, ring_lib
ring_lib.tex(,244) @subsubsection defring
ring_lib.tex(,245) @cindex defring
ring_lib.tex(,246) @c ---content defring---
ring_lib.tex(,247) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,248) 
ring_lib.tex(,249) @table @asis
ring_lib.tex(,250) @item @strong{Usage:}
ring_lib.tex(,251) defring(s1,s2,n,s3,s4); s1..s4=strings, n=integer
ring_lib.tex(,252) 
ring_lib.tex(,253) @item @strong{Create:}
ring_lib.tex(,254) Define a ring with name 's1', characteristic 's2', ordering 's4' and
ring_lib.tex(,255) n variables with names derived from s3 and make it the basering.
ring_lib.tex(,256) If s3 is a single letter, say s3="a", and if n<=26 then a and the
ring_lib.tex(,257) following n-1 letters from the alphabet (cyclic order) are taken as
ring_lib.tex(,258) variables. If n>26 or if s3 is a single letter followed by (, say
ring_lib.tex(,259) s3="T(", the variables are T(1),...,T(n).
ring_lib.tex(,260) 
ring_lib.tex(,261) @item @strong{Return:}
ring_lib.tex(,262) No return value
ring_lib.tex(,263) 
ring_lib.tex(,264) @item @strong{Note:}
ring_lib.tex(,265) This proc is useful for defining a ring in a procedure.
ring_lib.tex(,266) This proc uses 'execute' or calls a procedure using 'execute'.
ring_lib.tex(,267) If you use it in your own proc, let the local names of your proc
ring_lib.tex(,268) start with @@.
ring_lib.tex(,269) 
ring_lib.tex(,270) @end table
ring_lib.tex(,271) @strong{Example:}
ring_lib.tex(,272) @smallexample
ring_lib.tex(,273) @c computed example defring d2t_singular/ring_lib.doc:211 
ring_lib.tex(,274) LIB "ring.lib";
ring_lib.tex(,275) defring("r","0",5,"u","ls"); r; "";
ring_lib.tex(,276) @expansion{} // basering is now: r
ring_lib.tex(,277) @expansion{} //   characteristic : 0
ring_lib.tex(,278) @expansion{} //   number of vars : 5
ring_lib.tex(,279) @expansion{} //        block   1 : ordering ls
ring_lib.tex(,280) @expansion{} //                  : names    u v w x y 
ring_lib.tex(,281) @expansion{} //        block   2 : ordering C
ring_lib.tex(,282) @expansion{} 
ring_lib.tex(,283) defring("R","2,A",10,"x(","dp(3),ws(1,2,3),ds"); R;
ring_lib.tex(,284) @expansion{} // basering is now: R
ring_lib.tex(,285) @expansion{} //   characteristic : 2
ring_lib.tex(,286) @expansion{} //   1 parameter    : A 
ring_lib.tex(,287) @expansion{} //   minpoly        : 0
ring_lib.tex(,288) @expansion{} //   number of vars : 10
ring_lib.tex(,289) @expansion{} //        block   1 : ordering dp
ring_lib.tex(,290) @expansion{} //                  : names    x(1) x(2) x(3) 
ring_lib.tex(,291) @expansion{} //        block   2 : ordering ws
ring_lib.tex(,292) @expansion{} //                  : names    x(4) x(5) x(6) 
ring_lib.tex(,293) @expansion{} //                  : weights     1    2    3 
ring_lib.tex(,294) @expansion{} //        block   3 : ordering ds
ring_lib.tex(,295) @expansion{} //                  : names    x(7) x(8) x(9) x(10) 
ring_lib.tex(,296) @expansion{} //        block   4 : ordering C
ring_lib.tex(,297) kill r,R;
ring_lib.tex(,298) if(system("with","Namespaces")) @{
ring_lib.tex(,299) if( nameof(Current) == "Ring" ) @{
ring_lib.tex(,300) kill Top::r,Top::R;
ring_lib.tex(,301) @} else @{
ring_lib.tex(,302) kill Ring::r,Ring::R;
ring_lib.tex(,303) @}
ring_lib.tex(,304) @}
ring_lib.tex(,305) @c end example defring d2t_singular/ring_lib.doc:211
ring_lib.tex(,306) @end smallexample
ring_lib.tex(,307) @c ---end content defring---
ring_lib.tex(,308) 
ring_lib.tex(,309) @c ------------------- defrings -------------
ring_lib.tex(,310) @node defrings, defringp, defring, ring_lib
ring_lib.tex(,311) @subsubsection defrings
ring_lib.tex(,312) @cindex defrings
ring_lib.tex(,313) @c ---content defrings---
ring_lib.tex(,314) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,315) 
ring_lib.tex(,316) @table @asis
ring_lib.tex(,317) @item @strong{Usage:}
ring_lib.tex(,318) defrings(n,[p]); n,p integers
ring_lib.tex(,319) 
ring_lib.tex(,320) @item @strong{Create:}
ring_lib.tex(,321) Defines a ring with name Sn, characteristic p, ordering ds and n
ring_lib.tex(,322) variables x,y,z,a,b,...if n<=26 (resp. x(1..n) if n>26) and makes it
ring_lib.tex(,323) the basering (default: p=32003)
ring_lib.tex(,324) 
ring_lib.tex(,325) @item @strong{Return:}
ring_lib.tex(,326) No return value
ring_lib.tex(,327) 
ring_lib.tex(,328) @end table
ring_lib.tex(,329) @strong{Example:}
ring_lib.tex(,330) @smallexample
ring_lib.tex(,331) @c computed example defrings d2t_singular/ring_lib.doc:249 
ring_lib.tex(,332) LIB "ring.lib";
ring_lib.tex(,333) defrings(5,0); S5; "";
ring_lib.tex(,334) @expansion{} // basering is now: ring S5=0,(x,y,z,a,b),ds;
ring_lib.tex(,335) @expansion{} //   characteristic : 0
ring_lib.tex(,336) @expansion{} //   number of vars : 5
ring_lib.tex(,337) @expansion{} //        block   1 : ordering ds
ring_lib.tex(,338) @expansion{} //                  : names    x y z a b 
ring_lib.tex(,339) @expansion{} //        block   2 : ordering C
ring_lib.tex(,340) @expansion{} 
ring_lib.tex(,341) defrings(30); S30;
ring_lib.tex(,342) @expansion{} // basering is now: ring S30=32003,x(1..30),ds;
ring_lib.tex(,343) @expansion{} //   characteristic : 32003
ring_lib.tex(,344) @expansion{} //   number of vars : 30
ring_lib.tex(,345) @expansion{} //        block   1 : ordering ds
ring_lib.tex(,346) @expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(\
ring_lib.tex(,347)    9) x(10) x(11) x(12) x(13) x(14) x(15) x(16) x(17) x(18) x(19) x(20) x(21\
ring_lib.tex(,348)    ) x(22) x(23) x(24) x(25) x(26) x(27) x(28) x(29) x(30) 
ring_lib.tex(,349) @expansion{} //        block   2 : ordering C
ring_lib.tex(,350) kill S5, S30;
ring_lib.tex(,351) if(system("with","Namespaces")) @{
ring_lib.tex(,352) if( nameof(Current) == "Ring" ) @{
ring_lib.tex(,353) kill Top::S5,Top::S30;
ring_lib.tex(,354) @} else @{
ring_lib.tex(,355) kill Ring::S5,Ring::S30;
ring_lib.tex(,356) @}
ring_lib.tex(,357) @}
ring_lib.tex(,358) @c end example defrings d2t_singular/ring_lib.doc:249
ring_lib.tex(,359) @end smallexample
ring_lib.tex(,360) @c ---end content defrings---
ring_lib.tex(,361) 
ring_lib.tex(,362) @c ------------------- defringp -------------
ring_lib.tex(,363) @node defringp, extendring, defrings, ring_lib
ring_lib.tex(,364) @subsubsection defringp
ring_lib.tex(,365) @cindex defringp
ring_lib.tex(,366) @c ---content defringp---
ring_lib.tex(,367) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,368) 
ring_lib.tex(,369) @table @asis
ring_lib.tex(,370) @item @strong{Usage:}
ring_lib.tex(,371) defringp(n,[p]); n,p=integers
ring_lib.tex(,372) 
ring_lib.tex(,373) @item @strong{Create:}
ring_lib.tex(,374) defines a ring with name Pn, characteristic p, ordering dp and n
ring_lib.tex(,375) variables x,y,z,a,b,...if n<=26 (resp. x(1..n) if n>26) and makes it
ring_lib.tex(,376) the basering (default: p=32003)
ring_lib.tex(,377) 
ring_lib.tex(,378) @item @strong{Return:}
ring_lib.tex(,379) No return value
ring_lib.tex(,380) 
ring_lib.tex(,381) @end table
ring_lib.tex(,382) @strong{Example:}
ring_lib.tex(,383) @smallexample
ring_lib.tex(,384) @c computed example defringp d2t_singular/ring_lib.doc:287 
ring_lib.tex(,385) LIB "ring.lib";
ring_lib.tex(,386) defringp(5,0); P5; "";
ring_lib.tex(,387) @expansion{} // basering is now: ring P5=0,(x,y,z,a,b),dp;
ring_lib.tex(,388) @expansion{} //   characteristic : 0
ring_lib.tex(,389) @expansion{} //   number of vars : 5
ring_lib.tex(,390) @expansion{} //        block   1 : ordering dp
ring_lib.tex(,391) @expansion{} //                  : names    x y z a b 
ring_lib.tex(,392) @expansion{} //        block   2 : ordering C
ring_lib.tex(,393) @expansion{} 
ring_lib.tex(,394) defringp(30); P30;
ring_lib.tex(,395) @expansion{} // basering is now: ring P30=32003,x(1..30),dp;
ring_lib.tex(,396) @expansion{} //   characteristic : 32003
ring_lib.tex(,397) @expansion{} //   number of vars : 30
ring_lib.tex(,398) @expansion{} //        block   1 : ordering dp
ring_lib.tex(,399) @expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(\
ring_lib.tex(,400)    9) x(10) x(11) x(12) x(13) x(14) x(15) x(16) x(17) x(18) x(19) x(20) x(21\
ring_lib.tex(,401)    ) x(22) x(23) x(24) x(25) x(26) x(27) x(28) x(29) x(30) 
ring_lib.tex(,402) @expansion{} //        block   2 : ordering C
ring_lib.tex(,403) kill P5, P30;
ring_lib.tex(,404) if(system("with","Namespaces")) @{
ring_lib.tex(,405) if( nameof(Current) == "Ring" ) @{
ring_lib.tex(,406) kill Top::P5,Top::P30;
ring_lib.tex(,407) @} else @{
ring_lib.tex(,408) kill Ring::P5,Ring::P30;
ring_lib.tex(,409) @}
ring_lib.tex(,410) @}
ring_lib.tex(,411) @c end example defringp d2t_singular/ring_lib.doc:287
ring_lib.tex(,412) @end smallexample
ring_lib.tex(,413) @c ---end content defringp---
ring_lib.tex(,414) 
ring_lib.tex(,415) @c ------------------- extendring -------------
ring_lib.tex(,416) @node extendring, fetchall, defringp, ring_lib
ring_lib.tex(,417) @subsubsection extendring
ring_lib.tex(,418) @cindex extendring
ring_lib.tex(,419) @c ---content extendring---
ring_lib.tex(,420) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,421) 
ring_lib.tex(,422) @table @asis
ring_lib.tex(,423) @item @strong{Usage:}
ring_lib.tex(,424) extendring(na,n,va,o[iv,i,r]); na,va,o=strings,
ring_lib.tex(,425) @*n,i=integers, r=ring, iv=intvec of positive integers or iv=0
ring_lib.tex(,426) 
ring_lib.tex(,427) @item @strong{Create:}
ring_lib.tex(,428) Define a ring with name `na` which extends the ring r by adding n new
ring_lib.tex(,429) variables in front of [after, if i!=0] the old variables and make it
ring_lib.tex(,430) the basering [default: (i,r)=(0,basering)].
ring_lib.tex(,431) @* -- The characteristic is the characteristic of r.
ring_lib.tex(,432) @* -- The new vars are derived from va. If va is a single letter, say
ring_lib.tex(,433) va="T", and if n<=26 then T and the following n-1 letters from
ring_lib.tex(,434) T..Z..T (resp. T(1..n) if n>26) are taken as additional variables.
ring_lib.tex(,435) If va is a single letter followed by (, say va="x(", the new
ring_lib.tex(,436) variables are x(1),...,x(n).
ring_lib.tex(,437) @* -- The ordering is the product ordering between the ordering of r and
ring_lib.tex(,438) an ordering derived from `o` [and iv].
ring_lib.tex(,439) @* - If o contains a 'c' or a 'C' in front resp. at the end this is
ring_lib.tex(,440) taken for the whole ordering in front resp. at the end. If o does
ring_lib.tex(,441) not contain a 'c' or a 'C' the same rule applies to ordstr(r).
ring_lib.tex(,442) @* - If no intvec iv is given, or if iv=0, o may be any allowed ordstr,
ring_lib.tex(,443) like "ds" or "dp(2),wp(1,2,3),Ds(2)" or "ds(a),dp(b),ls" if
ring_lib.tex(,444) a and b are globally (!) defined integers and if a+b+1<=n.
ring_lib.tex(,445) If, however, a and b are local to a proc calling extendring, the
ring_lib.tex(,446) intvec iv must be used to let extendring know the values of a and b
ring_lib.tex(,447) @* - If an intvec iv !=0 is given, iv[1],iv[2],... is taken for the
ring_lib.tex(,448) 1st, 2nd,... block of o, if o contains no substring "w" or "W"
ring_lib.tex(,449) i.e. no weighted ordering (in the above case o="ds,dp,ls"
ring_lib.tex(,450) and iv=a,b).
ring_lib.tex(,451) @*If o contains a weighted ordering (only one (!) weighted block is
ring_lib.tex(,452) allowed) iv[1] is taken as size for the weight-vector, the next
ring_lib.tex(,453) iv[1] values of iv are taken as weights and the remaining values of
ring_lib.tex(,454) iv as block-size for the remaining non-weighted blocks.
ring_lib.tex(,455) e.g. o="dp,ws,Dp,ds", iv=3,2,3,4,2,5 creates the ordering
ring_lib.tex(,456) dp(2),ws(2,3,4),Dp(5),ds
ring_lib.tex(,457) 
ring_lib.tex(,458) @item @strong{Return:}
ring_lib.tex(,459) No return value
ring_lib.tex(,460) 
ring_lib.tex(,461) @item @strong{Note:}
ring_lib.tex(,462) This proc is useful for adding deformation parameters.
ring_lib.tex(,463) @*This proc uses 'execute' or calls a procedure using 'execute'.
ring_lib.tex(,464) If you use it in your own proc, let the local names of your proc
ring_lib.tex(,465) start with @@ (see the file HelpForProc)
ring_lib.tex(,466) 
ring_lib.tex(,467) @end table
ring_lib.tex(,468) @strong{Example:}
ring_lib.tex(,469) @smallexample
ring_lib.tex(,470) @c computed example extendring d2t_singular/ring_lib.doc:358 
ring_lib.tex(,471) LIB "ring.lib";
ring_lib.tex(,472) ring r=0,(x,y,z),ds;
ring_lib.tex(,473) show(r);"";
ring_lib.tex(,474) @expansion{} // ring: (0),(x,y,z),(ds(3),C);
ring_lib.tex(,475) @expansion{} // minpoly = 0
ring_lib.tex(,476) @expansion{} // objects belonging to this ring:
ring_lib.tex(,477) @expansion{} 
ring_lib.tex(,478) //blocksize is derived from no of vars:
ring_lib.tex(,479) int t=5;
ring_lib.tex(,480) extendring("R1",t,"a","dp");         //t global: "dp" -> "dp(5)"
ring_lib.tex(,481) @expansion{} // basering is now R1
ring_lib.tex(,482) show(R1); "";
ring_lib.tex(,483) @expansion{} // ring: (0),(a,b,c,d,e,x,y,z),(dp(5),ds(3),C);
ring_lib.tex(,484) @expansion{} // minpoly = 0
ring_lib.tex(,485) @expansion{} // objects belonging to this ring:
ring_lib.tex(,486) @expansion{} 
ring_lib.tex(,487) extendring("R2",4,"T(","c,dp",1,r);    //"dp" -> "c,..,dp(4)"
ring_lib.tex(,488) @expansion{} // basering is now R2
ring_lib.tex(,489) show(R2);"";
ring_lib.tex(,490) @expansion{} // ring: (0),(x,y,z,T(1),T(2),T(3),T(4)),(c,ds(3),dp(4));
ring_lib.tex(,491) @expansion{} // minpoly = 0
ring_lib.tex(,492) @expansion{} // objects belonging to this ring:
ring_lib.tex(,493) @expansion{} 
ring_lib.tex(,494) //no intvec given, blocksize given: given blocksize is used:
ring_lib.tex(,495) extendring("R3",4,"T(","dp(2)",0,r);   // "dp(2)" -> "dp(2)"
ring_lib.tex(,496) @expansion{} // basering is now R3
ring_lib.tex(,497) show(R3);"";
ring_lib.tex(,498) @expansion{} // ring: (0),(T(1),T(2),T(3),T(4),x,y,z),(dp(2),ds(5),C);
ring_lib.tex(,499) @expansion{} // minpoly = 0
ring_lib.tex(,500) @expansion{} // objects belonging to this ring:
ring_lib.tex(,501) @expansion{} 
ring_lib.tex(,502) //intvec given: weights and blocksize is derived from given intvec
ring_lib.tex(,503) //(no specification of a blocksize in the given ordstr is allowed!)
ring_lib.tex(,504) //if intvec does not cover all given blocks, the last block is used
ring_lib.tex(,505) //for the remaining variables, if intvec has too many components,
ring_lib.tex(,506) //the last ones are ignored
ring_lib.tex(,507) intvec v=3,2,3,4,1,3;
ring_lib.tex(,508) extendring("R4",10,"A","ds,ws,Dp,dp",v,0,r);
ring_lib.tex(,509) @expansion{} // basering is now R4
ring_lib.tex(,510) //v covers 3 blocks: v[1] (=3) : no of components of ws
ring_lib.tex(,511) //next v[1] values (=v[2..4]) give weights
ring_lib.tex(,512) //remaining components of v are used for the remaining blocks
ring_lib.tex(,513) show(R4);
ring_lib.tex(,514) @expansion{} // ring: (0),(A,B,C,D,E,F,G,H,I,J,x,y,z),(ds(1),ws(2,3,4),Dp(3),dp(3),ds(\
ring_lib.tex(,515)    3),C);
ring_lib.tex(,516) @expansion{} // minpoly = 0
ring_lib.tex(,517) @expansion{} // objects belonging to this ring:
ring_lib.tex(,518) kill r,R1,R2,R3,R4;
ring_lib.tex(,519) if(system("with","Namespaces")) @{
ring_lib.tex(,520) if( nameof(Current) == "Ring" ) @{
ring_lib.tex(,521) kill Top::R1,Top::R2,Top::R3,Top::R4;
ring_lib.tex(,522) @} else @{
ring_lib.tex(,523) kill Ring::R1,Ring::R2,Ring::R3,Ring::R4;
ring_lib.tex(,524) @}
ring_lib.tex(,525) @}
ring_lib.tex(,526) @c end example extendring d2t_singular/ring_lib.doc:358
ring_lib.tex(,527) @end smallexample
ring_lib.tex(,528) @c ---end content extendring---
ring_lib.tex(,529) 
ring_lib.tex(,530) @c ------------------- fetchall -------------
ring_lib.tex(,531) @node fetchall, imapall, extendring, ring_lib
ring_lib.tex(,532) @subsubsection fetchall
ring_lib.tex(,533) @cindex fetchall
ring_lib.tex(,534) @c ---content fetchall---
ring_lib.tex(,535) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,536) 
ring_lib.tex(,537) @table @asis
ring_lib.tex(,538) @item @strong{Usage:}
ring_lib.tex(,539) fetchall(R[,s]); R=ring/qring, s=string
ring_lib.tex(,540) 
ring_lib.tex(,541) @item @strong{Create:}
ring_lib.tex(,542) fetch all objects of ring R (of type poly/ideal/vector/module/number/
ring_lib.tex(,543) matrix) into the basering.
ring_lib.tex(,544) @*If no 3rd argument is present, the names are the same as in R. If,
ring_lib.tex(,545) say, f is a poly in R and the 3rd argument is the string "R", then f
ring_lib.tex(,546) is mapped to f_R etc.
ring_lib.tex(,547) 
ring_lib.tex(,548) @item @strong{Return:}
ring_lib.tex(,549) no return value
ring_lib.tex(,550) 
ring_lib.tex(,551) @item @strong{Note:}
ring_lib.tex(,552) As fetch, this procedure maps the 1st, 2nd, ... variable of R to the
ring_lib.tex(,553) 1st, 2nd, ... variable of the basering.
ring_lib.tex(,554) @*The 3rd argument is useful in order to avoid conflicts of names, the
ring_lib.tex(,555) empty string is allowed
ring_lib.tex(,556) 
ring_lib.tex(,557) @item @strong{Caution:}
ring_lib.tex(,558) fetchall does not work inside a procedure.
ring_lib.tex(,559) @*It does not work if R contains a map.
ring_lib.tex(,560) 
ring_lib.tex(,561) @end table
ring_lib.tex(,562) @strong{Example:}
ring_lib.tex(,563) @smallexample
ring_lib.tex(,564) @c computed example fetchall d2t_singular/ring_lib.doc:428 
ring_lib.tex(,565) LIB "ring.lib";
ring_lib.tex(,566) // The example is not shown since fetchall does not work in a procedure;
ring_lib.tex(,567) // (and hence not in the example procedure). Try the following commands:
ring_lib.tex(,568) //   ring R=0,(x,y,z),dp;
ring_lib.tex(,569) //   ideal j=x,y2,z2;
ring_lib.tex(,570) //   matrix M[2][3]=1,2,3,x,y,z;
ring_lib.tex(,571) //   j; print(M);
ring_lib.tex(,572) //   ring S=0,(a,b,c),ds;
ring_lib.tex(,573) //   fetchall(R);       //map from R to S: x->a, y->b, z->c;
ring_lib.tex(,574) //   names(S);
ring_lib.tex(,575) //   j; print(M);
ring_lib.tex(,576) //   fetchall(S,"1");   //identity map of S: copy objects, change names
ring_lib.tex(,577) //   names(S);
ring_lib.tex(,578) //   kill R,S;
ring_lib.tex(,579) @c end example fetchall d2t_singular/ring_lib.doc:428
ring_lib.tex(,580) @end smallexample
ring_lib.tex(,581) @c ---end content fetchall---
ring_lib.tex(,582) 
ring_lib.tex(,583) @c ------------------- imapall -------------
ring_lib.tex(,584) @node imapall, mapall, fetchall, ring_lib
ring_lib.tex(,585) @subsubsection imapall
ring_lib.tex(,586) @cindex imapall
ring_lib.tex(,587) @c ---content imapall---
ring_lib.tex(,588) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,589) 
ring_lib.tex(,590) @table @asis
ring_lib.tex(,591) @item @strong{Usage:}
ring_lib.tex(,592) imapall(R[,s]); R=ring/qring, s=string
ring_lib.tex(,593) 
ring_lib.tex(,594) @item @strong{Create:}
ring_lib.tex(,595) map all objects of ring R (of type poly/ideal/vector/module/number/
ring_lib.tex(,596) matrix) into the basering, by applying imap to all objects of R.
ring_lib.tex(,597) If no 3rd argument is present, the names are the same as in R. If,
ring_lib.tex(,598) say, f is a poly in R and the 3rd argument is the string "R", then f
ring_lib.tex(,599) is mapped to f_R etc.
ring_lib.tex(,600) 
ring_lib.tex(,601) @item @strong{Return:}
ring_lib.tex(,602) no return value
ring_lib.tex(,603) 
ring_lib.tex(,604) @item @strong{Note:}
ring_lib.tex(,605) As imap, this procedure maps the variables of R to the variables with
ring_lib.tex(,606) the same name in the basering, the other variables are mapped to 0.
ring_lib.tex(,607) The 3rd argument is useful in order to avoid conflicts of names, the
ring_lib.tex(,608) empty string is allowed
ring_lib.tex(,609) 
ring_lib.tex(,610) @item @strong{Caution:}
ring_lib.tex(,611) imapall does not work inside a procedure
ring_lib.tex(,612) @*It does not work if R contains a map
ring_lib.tex(,613) 
ring_lib.tex(,614) @end table
ring_lib.tex(,615) @strong{Example:}
ring_lib.tex(,616) @smallexample
ring_lib.tex(,617) @c computed example imapall d2t_singular/ring_lib.doc:481 
ring_lib.tex(,618) LIB "ring.lib";
ring_lib.tex(,619) // The example is not shown since imapall does not work in a procedure
ring_lib.tex(,620) // (and hence not in the example procedure). Try the following commands:
ring_lib.tex(,621) //   ring R=0,(x,y,z,u),dp;
ring_lib.tex(,622) //   ideal j=x,y,z,u2+ux+z;
ring_lib.tex(,623) //   matrix M[2][3]=1,2,3,x,y,uz;
ring_lib.tex(,624) //   j; print(M);
ring_lib.tex(,625) //   ring S=0,(a,b,c,x,z,y),ds;
ring_lib.tex(,626) //   imapall(R);         //map from R to S: x->x, y->y, z->z, u->0
ring_lib.tex(,627) //   names(S);
ring_lib.tex(,628) //   j; print(M);
ring_lib.tex(,629) //   imapall(S,"1");     //identity map of S: copy objects, change names
ring_lib.tex(,630) //   names(S);
ring_lib.tex(,631) //   kill R,S;
ring_lib.tex(,632) @c end example imapall d2t_singular/ring_lib.doc:481
ring_lib.tex(,633) @end smallexample
ring_lib.tex(,634) @c ---end content imapall---
ring_lib.tex(,635) 
ring_lib.tex(,636) @c ------------------- mapall -------------
ring_lib.tex(,637) @node mapall, ord_test, imapall, ring_lib
ring_lib.tex(,638) @subsubsection mapall
ring_lib.tex(,639) @cindex mapall
ring_lib.tex(,640) @c ---content mapall---
ring_lib.tex(,641) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,642) 
ring_lib.tex(,643) @table @asis
ring_lib.tex(,644) @item @strong{Usage:}
ring_lib.tex(,645) mapall(R,i[,s]); R=ring/qring, i=ideal of basering, s=string
ring_lib.tex(,646) 
ring_lib.tex(,647) @item @strong{Create:}
ring_lib.tex(,648) map all objects of ring R (of type poly/ideal/vector/module/number/
ring_lib.tex(,649) matrix, map) into the basering, by mapping the j-th variable of R to
ring_lib.tex(,650) the j-th generator of the ideal i. If no 3rd argument is present, the
ring_lib.tex(,651) names are the same as in R. If, say, f is a poly in R and the 3rd
ring_lib.tex(,652) argument is the string "R", then f is mapped to f_R etc.
ring_lib.tex(,653) 
ring_lib.tex(,654) @item @strong{Return:}
ring_lib.tex(,655) no return value.
ring_lib.tex(,656) 
ring_lib.tex(,657) @item @strong{Note:}
ring_lib.tex(,658) This procedure has the same effect as defining a map, say psi, by
ring_lib.tex(,659) map psi=R,i; and then applying psi to all objects of R. In particular,
ring_lib.tex(,660) maps from R to some ring S are composed with psi, creating thus a map
ring_lib.tex(,661) from the basering to S.
ring_lib.tex(,662) @*mapall may be combined with copyring to change vars for all objects.
ring_lib.tex(,663) The 3rd argument is useful in order to avoid conflicts of names, the
ring_lib.tex(,664) empty string is allowed.
ring_lib.tex(,665) 
ring_lib.tex(,666) @item @strong{Caution:}
ring_lib.tex(,667) mapall does not work inside a procedure.
ring_lib.tex(,668) 
ring_lib.tex(,669) @end table
ring_lib.tex(,670) @strong{Example:}
ring_lib.tex(,671) @smallexample
ring_lib.tex(,672) @c computed example mapall d2t_singular/ring_lib.doc:536 
ring_lib.tex(,673) LIB "ring.lib";
ring_lib.tex(,674) // The example is not shown since mapall does not work in a procedure
ring_lib.tex(,675) // (and hence not in the example procedure). Try the following commands:
ring_lib.tex(,676) //   ring R=0,(x,y,z),dp;
ring_lib.tex(,677) //   ideal j=x,y,z;
ring_lib.tex(,678) //   matrix M[2][3]=1,2,3,x,y,z;
ring_lib.tex(,679) //   map phi=R,x2,y2,z2;
ring_lib.tex(,680) //   ring S=0,(a,b,c),ds;
ring_lib.tex(,681) //   ideal i=c,a,b;
ring_lib.tex(,682) //   mapall(R,i);         //map from R to S: x->c, y->a, z->b
ring_lib.tex(,683) //   names(S);
ring_lib.tex(,684) //   j; print(M); phi;    //phi maps R to S: x->c2, y->a2, z->b2
ring_lib.tex(,685) //   ideal i1=a2,a+b,1;
ring_lib.tex(,686) //   mapall(R,i1,"");   //map from R to S: x->a2, y->a+b, z->1
ring_lib.tex(,687) //   names(S);
ring_lib.tex(,688) //   j_; print(M_); phi_;
ring_lib.tex(,689) //   changevar("T","x()",R);  //change vars in R and call result T
ring_lib.tex(,690) //   mapall(R,maxideal(1));       //identity map from R to T
ring_lib.tex(,691) //   names(T);
ring_lib.tex(,692) //   j; print(M); phi;
ring_lib.tex(,693) //   kill R,S,T;
ring_lib.tex(,694) @c end example mapall d2t_singular/ring_lib.doc:536
ring_lib.tex(,695) @end smallexample
ring_lib.tex(,696) @c ---end content mapall---
ring_lib.tex(,697) 
ring_lib.tex(,698) @c ------------------- ord_test -------------
ring_lib.tex(,699) @node ord_test, ringtensor, mapall, ring_lib
ring_lib.tex(,700) @subsubsection ord_test
ring_lib.tex(,701) @cindex ord_test
ring_lib.tex(,702) @c ---content ord_test---
ring_lib.tex(,703) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,704) 
ring_lib.tex(,705) @table @asis
ring_lib.tex(,706) @item @strong{Usage:}
ring_lib.tex(,707) ord_test(r); r ring
ring_lib.tex(,708) 
ring_lib.tex(,709) @item @strong{Return:}
ring_lib.tex(,710) int 1 (resp. -1, resp. 0) if ordering of r is global (resp. local,
ring_lib.tex(,711) resp. mixed)
ring_lib.tex(,712) 
ring_lib.tex(,713) @end table
ring_lib.tex(,714) @strong{Example:}
ring_lib.tex(,715) @smallexample
ring_lib.tex(,716) @c computed example ord_test d2t_singular/ring_lib.doc:580 
ring_lib.tex(,717) LIB "ring.lib";
ring_lib.tex(,718) ring R = 0,(x,y),dp;
ring_lib.tex(,719) ring S = 0,(u,v),ls;
ring_lib.tex(,720) ord_test(R);
ring_lib.tex(,721) @expansion{} 1
ring_lib.tex(,722) ord_test(S);
ring_lib.tex(,723) @expansion{} -1
ring_lib.tex(,724) ord_test(R+S);
ring_lib.tex(,725) @expansion{} 0
ring_lib.tex(,726) @c end example ord_test d2t_singular/ring_lib.doc:580
ring_lib.tex(,727) @end smallexample
ring_lib.tex(,728) @c ---end content ord_test---
ring_lib.tex(,729) 
ring_lib.tex(,730) @c ------------------- ringtensor -------------
ring_lib.tex(,731) @node ringtensor, ringweights, ord_test, ring_lib
ring_lib.tex(,732) @subsubsection ringtensor
ring_lib.tex(,733) @cindex ringtensor
ring_lib.tex(,734) @c ---content ringtensor---
ring_lib.tex(,735) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,736) 
ring_lib.tex(,737) @table @asis
ring_lib.tex(,738) @item @strong{Usage:}
ring_lib.tex(,739) ringtensor(s,r1,r2,...); s=string, r1,r2,...=rings
ring_lib.tex(,740) 
ring_lib.tex(,741) @item @strong{Create:}
ring_lib.tex(,742) A new base ring with name `s` if r1,r2,... are existing rings.
ring_lib.tex(,743) If, say, s = "R" and the rings r1,r2,... exist, the new ring will
ring_lib.tex(,744) have name R, variables from all rings r1,r2,... and as monomial
ring_lib.tex(,745) ordering the block (product) ordering of r1,r2,... . Hence, R
ring_lib.tex(,746) is the tensor product of the rings r1,r2,... with ordering matrix
ring_lib.tex(,747) equal to the direct sum of the ordering matrices of r1,r2,...
ring_lib.tex(,748) 
ring_lib.tex(,749) @item @strong{Return:}
ring_lib.tex(,750) no return value
ring_lib.tex(,751) 
ring_lib.tex(,752) @item @strong{Note:}
ring_lib.tex(,753) The characteristic of the new ring will be that of r1. The names of
ring_lib.tex(,754) variables in the rings r1,r2,... should differ (if a name, say x,
ring_lib.tex(,755) occurs in r1 and r2, then, in the new ring r, x always refers to the
ring_lib.tex(,756) variable with name x in r1, there is no access to x in r2).
ring_lib.tex(,757) The procedure works also for quotient rings ri, if the characteristic
ring_lib.tex(,758) of ri is compatible with the characteristic of r1 (i.e. if imap from
ring_lib.tex(,759) ri to r1 is implemented)
ring_lib.tex(,760) @*This proc uses 'execute' or calls a procedure using 'execute'.
ring_lib.tex(,761) If you use it in your own proc, let the local names of your proc
ring_lib.tex(,762) start with @@ (see the file HelpForProc)
ring_lib.tex(,763) 
ring_lib.tex(,764) @end table
ring_lib.tex(,765) @strong{Example:}
ring_lib.tex(,766) @smallexample
ring_lib.tex(,767) @c computed example ringtensor d2t_singular/ring_lib.doc:628 
ring_lib.tex(,768) LIB "ring.lib";
ring_lib.tex(,769) ring r=32003,(x,y,u,v),dp;
ring_lib.tex(,770) ring s=0,(a,b,c),wp(1,2,3);
ring_lib.tex(,771) ring t=0,x(1..5),(c,ls);
ring_lib.tex(,772) ringtensor("R",r,s,t);
ring_lib.tex(,773) @expansion{} // basering is now R
ring_lib.tex(,774) type R;
ring_lib.tex(,775) @expansion{} // R                    [0]  *ring
ring_lib.tex(,776) @expansion{} //   characteristic : 32003
ring_lib.tex(,777) @expansion{} //   number of vars : 12
ring_lib.tex(,778) @expansion{} //        block   1 : ordering dp
ring_lib.tex(,779) @expansion{} //                  : names    x y u v 
ring_lib.tex(,780) @expansion{} //        block   2 : ordering wp
ring_lib.tex(,781) @expansion{} //                  : names    a b c 
ring_lib.tex(,782) @expansion{} //                  : weights  1 2 3 
ring_lib.tex(,783) @expansion{} //        block   3 : ordering ls
ring_lib.tex(,784) @expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) 
ring_lib.tex(,785) @expansion{} //        block   4 : ordering C
ring_lib.tex(,786) setring s;
ring_lib.tex(,787) ideal i = a2+b3+c5;
ring_lib.tex(,788) changevar("S","x,y,z");       //change vars of sand make S the basering
ring_lib.tex(,789) @expansion{} // basering is now S
ring_lib.tex(,790) qring qS =std(fetch(s,i));    //create qring of S mod i (mapped to S)
ring_lib.tex(,791) changevar("T","d,e,f,g,h",t); //change vars of t and make T the basering
ring_lib.tex(,792) @expansion{} // basering is now T
ring_lib.tex(,793) qring qT=std(d2+e2-f3);       //create qring of T mod d2+e2-f3
ring_lib.tex(,794) ringtensor("Q",s,qS,t,qT);
ring_lib.tex(,795) @expansion{} // basering is now Q
ring_lib.tex(,796) type Q;
ring_lib.tex(,797) @expansion{} // Q                    [0]  *qring
ring_lib.tex(,798) @expansion{} //   characteristic : 0
ring_lib.tex(,799) @expansion{} //   number of vars : 16
ring_lib.tex(,800) @expansion{} //        block   1 : ordering wp
ring_lib.tex(,801) @expansion{} //                  : names    a b c 
ring_lib.tex(,802) @expansion{} //                  : weights  1 2 3 
ring_lib.tex(,803) @expansion{} //        block   2 : ordering wp
ring_lib.tex(,804) @expansion{} //                  : names    x y z 
ring_lib.tex(,805) @expansion{} //                  : weights  1 2 3 
ring_lib.tex(,806) @expansion{} //        block   3 : ordering ls
ring_lib.tex(,807) @expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) 
ring_lib.tex(,808) @expansion{} //        block   4 : ordering ls
ring_lib.tex(,809) @expansion{} //                  : names    d e f g h 
ring_lib.tex(,810) @expansion{} //        block   5 : ordering C
ring_lib.tex(,811) @expansion{} // quotient ring from ideal
ring_lib.tex(,812) @expansion{} _[1]=f3-e2-d2
ring_lib.tex(,813) @expansion{} _[2]=z5+y3+x2
ring_lib.tex(,814) kill R,Q,S,T;
ring_lib.tex(,815) if(system("with","Namespaces")) @{
ring_lib.tex(,816) if( nameof(Current) == "Ring" ) @{
ring_lib.tex(,817) kill Top::R,Top::Q,Top::S,Top::T;
ring_lib.tex(,818) @} else @{
ring_lib.tex(,819) kill Ring::R,Ring::Q,Ring::S,Ring::T;
ring_lib.tex(,820) @}
ring_lib.tex(,821) @}
ring_lib.tex(,822) @c end example ringtensor d2t_singular/ring_lib.doc:628
ring_lib.tex(,823) @end smallexample
ring_lib.tex(,824) @c ---end content ringtensor---
ring_lib.tex(,825) 
ring_lib.tex(,826) @c ------------------- ringweights -------------
ring_lib.tex(,827) @node ringweights,, ringtensor, ring_lib
ring_lib.tex(,828) @subsubsection ringweights
ring_lib.tex(,829) @cindex ringweights
ring_lib.tex(,830) @c ---content ringweights---
ring_lib.tex(,831) Procedure from library @code{ring.lib} (@pxref{ring_lib}).
ring_lib.tex(,832) 
ring_lib.tex(,833) @table @asis
ring_lib.tex(,834) @item @strong{Usage:}
ring_lib.tex(,835) ringweights(P); P=name of an existing ring (true name, not a string)
ring_lib.tex(,836) 
ring_lib.tex(,837) @item @strong{Return:}
ring_lib.tex(,838) intvec consisting of the weights of the variables of P, as they
ring_lib.tex(,839) appear when typing P;.
ring_lib.tex(,840) 
ring_lib.tex(,841) @item @strong{Note:}
ring_lib.tex(,842) This is useful when enlarging P but keeping the weights of the old
ring_lib.tex(,843) variables.
ring_lib.tex(,844) 
ring_lib.tex(,845) @end table
ring_lib.tex(,846) @strong{Example:}
ring_lib.tex(,847) @smallexample
ring_lib.tex(,848) @c computed example ringweights d2t_singular/ring_lib.doc:677 
ring_lib.tex(,849) LIB "ring.lib";
ring_lib.tex(,850) ring r0 = 0,(x,y,z),dp;
ring_lib.tex(,851) ringweights(r0);
ring_lib.tex(,852) @expansion{} 1,1,1
ring_lib.tex(,853) ring r1 = 0,x(1..5),(ds(3),wp(2,3));
ring_lib.tex(,854) ringweights(r1);"";
ring_lib.tex(,855) @expansion{} 1,1,1,2,3
ring_lib.tex(,856) @expansion{} 
ring_lib.tex(,857) // an example for enlarging the ring, keeping the first weights:
ring_lib.tex(,858) intvec v = ringweights(r1),6,2,3,4,5;
ring_lib.tex(,859) ring R = 0,x(1..10),(a(v),dp);
ring_lib.tex(,860) ordstr(R);
ring_lib.tex(,861) @expansion{} a(1,1,1,2,3,6,2,3,4,5),dp(10),C
ring_lib.tex(,862) @c end example ringweights d2t_singular/ring_lib.doc:677
ring_lib.tex(,863) @end smallexample
ring_lib.tex(,864) @c ---end content ringweights---
singular.texi(,332) @c ----------------------------------------------------------------------------
singular.texi(,333) @node Linear algebra, Commutative algebra, General purpose, SINGULAR libraries
singular.texi(,334) @section Linear algebra
singular.texi(,335) @cindex Linear algebra
singular.texi(,336) 
singular.texi(,337) @menu
singular.texi(,338) * matrix_lib:: procedures for matrix operations
singular.texi(,339) * linalg_lib:: procedures for algorithmic linear algebra
singular.texi(,340) @end menu
singular.texi(,341) 
singular.texi(,342) @c ----------------------------------------------------------
singular.texi(,343) @node matrix_lib, linalg_lib,  Linear algebra, Linear algebra
singular.texi(,344) @subsection matrix_lib
singular.texi(,345) @c include of docu for matrix.lib
matrix_lib.tex(,1) @c ---content LibInfo---
matrix_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/matrix_lib.doc
matrix_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/matrix_lib.doc INSTEAD
matrix_lib.tex(,4) @c library version: (1.26.2.3,2003/05/14)
matrix_lib.tex(,5) @c library file: ../Singular/LIB/matrix.lib
matrix_lib.tex(,6) @cindex matrix.lib
matrix_lib.tex(,7) @cindex matrix_lib
matrix_lib.tex(,8) @table @asis
matrix_lib.tex(,9) @item @strong{Library:}
matrix_lib.tex(,10) matrix.lib
matrix_lib.tex(,11) @item @strong{Purpose:}
matrix_lib.tex(,12)     Elementary Matrix Operations
matrix_lib.tex(,13) 
matrix_lib.tex(,14) @end table
matrix_lib.tex(,15) 
matrix_lib.tex(,16) @strong{Procedures:}
matrix_lib.tex(,17) @menu
matrix_lib.tex(,18) * compress:: matrix, zero columns from A deleted
matrix_lib.tex(,19) * concat:: matrix, concatenation of matrices A1,A2,...
matrix_lib.tex(,20) * diag:: matrix, nxn diagonal matrix with entries poly p
matrix_lib.tex(,21) * dsum:: matrix, direct sum of matrices A1,A2,...
matrix_lib.tex(,22) * flatten:: ideal, generated by entries of matrix A
matrix_lib.tex(,23) * genericmat:: generic nxm matrix [entries from id]
matrix_lib.tex(,24) * is_complex:: 1 if list c is a complex, 0 if not
matrix_lib.tex(,25) * outer:: matrix, outer product of matrices A and B
matrix_lib.tex(,26) * power:: matrix/intmat, n-th power of matrix/intmat A
matrix_lib.tex(,27) * skewmat:: generic skew-symmetric nxn matrix [entries from id]
matrix_lib.tex(,28) * submat:: submatrix of A with rows/cols specified by intvec r/c
matrix_lib.tex(,29) * symmat:: generic symmetric nxn matrix [entries from id]
matrix_lib.tex(,30) * tensor:: matrix, tensor product of matrices A nd B
matrix_lib.tex(,31) * unitmat:: unit square matrix of size n
matrix_lib.tex(,32) * gauss_col:: transform a matrix into col-reduced Gauss normal form
matrix_lib.tex(,33) * gauss_row:: transform a matrix into row-reduced Gauss normal form
matrix_lib.tex(,34) * addcol:: add p*(c1-th col) to c2-th column of matrix A, p poly
matrix_lib.tex(,35) * addrow:: add p*(r1-th row) to r2-th row of matrix A, p poly
matrix_lib.tex(,36) * multcol:: multiply c-th column of A with poly p
matrix_lib.tex(,37) * multrow:: multiply r-th row of A with poly p
matrix_lib.tex(,38) * permcol:: permute i-th and j-th columns
matrix_lib.tex(,39) * permrow:: permute i-th and j-th rows
matrix_lib.tex(,40) * rowred:: reduction of matrix A with elementary row-operations
matrix_lib.tex(,41) * colred:: reduction of matrix A with elementary col-operations
matrix_lib.tex(,42) * rm_unitrow:: remove unit rows and associated columns of A
matrix_lib.tex(,43) * rm_unitcol:: remove unit columns and associated rows of A
matrix_lib.tex(,44) * headStand:: A[n-i+1,m-j+1]=headStand(A[i,j])
matrix_lib.tex(,45) @end menu
matrix_lib.tex(,46) @c ---end content LibInfo---
matrix_lib.tex(,47) 
matrix_lib.tex(,48) @c ------------------- compress -------------
matrix_lib.tex(,49) @node compress, concat,, matrix_lib
matrix_lib.tex(,50) @subsubsection compress
matrix_lib.tex(,51) @cindex compress
matrix_lib.tex(,52) @c ---content compress---
matrix_lib.tex(,53) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,54) 
matrix_lib.tex(,55) @table @asis
matrix_lib.tex(,56) @item @strong{Usage:}
matrix_lib.tex(,57) compress(A); A matrix/ideal/module/intmat/intvec
matrix_lib.tex(,58) 
matrix_lib.tex(,59) @item @strong{Return:}
matrix_lib.tex(,60) same type, zero columns/generators from A deleted
matrix_lib.tex(,61) @*(if A=intvec, zero elements are deleted)
matrix_lib.tex(,62) 
matrix_lib.tex(,63) @end table
matrix_lib.tex(,64) @strong{Example:}
matrix_lib.tex(,65) @smallexample
matrix_lib.tex(,66) @c reused example compress d2t_singular/matrix_lib.doc:64 
matrix_lib.tex(,67) LIB "matrix.lib";
matrix_lib.tex(,68) ring r=0,(x,y,z),ds;
matrix_lib.tex(,69) matrix A[3][4]=1,0,3,0,x,0,z,0,x2,0,z2,0;
matrix_lib.tex(,70) print(A);
matrix_lib.tex(,71) @expansion{} 1, 0,3, 0,
matrix_lib.tex(,72) @expansion{} x, 0,z, 0,
matrix_lib.tex(,73) @expansion{} x2,0,z2,0 
matrix_lib.tex(,74) print(compress(A));
matrix_lib.tex(,75) @expansion{} 1, 3,
matrix_lib.tex(,76) @expansion{} x, z,
matrix_lib.tex(,77) @expansion{} x2,z2
matrix_lib.tex(,78) module m=module(A); show(m);
matrix_lib.tex(,79) @expansion{} // module, 4 generator(s)
matrix_lib.tex(,80) @expansion{} [1,x,x2]
matrix_lib.tex(,81) @expansion{} [0]
matrix_lib.tex(,82) @expansion{} [3,z,z2]
matrix_lib.tex(,83) @expansion{} [0]
matrix_lib.tex(,84) show(compress(m));
matrix_lib.tex(,85) @expansion{} // module, 2 generator(s)
matrix_lib.tex(,86) @expansion{} [1,x,x2]
matrix_lib.tex(,87) @expansion{} [3,z,z2]
matrix_lib.tex(,88) intmat B[3][4]=1,0,3,0,4,0,5,0,6,0,7,0;
matrix_lib.tex(,89) compress(B);
matrix_lib.tex(,90) @expansion{} 1,3,
matrix_lib.tex(,91) @expansion{} 4,5,
matrix_lib.tex(,92) @expansion{} 6,7 
matrix_lib.tex(,93) intvec C=0,0,1,2,0,3;
matrix_lib.tex(,94) compress(C);
matrix_lib.tex(,95) @expansion{} 1,2,3
matrix_lib.tex(,96) @c end example compress d2t_singular/matrix_lib.doc:64
matrix_lib.tex(,97) @end smallexample
matrix_lib.tex(,98) @c ---end content compress---
matrix_lib.tex(,99) 
matrix_lib.tex(,100) @c ------------------- concat -------------
matrix_lib.tex(,101) @node concat, diag, compress, matrix_lib
matrix_lib.tex(,102) @subsubsection concat
matrix_lib.tex(,103) @cindex concat
matrix_lib.tex(,104) @c ---content concat---
matrix_lib.tex(,105) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,106) 
matrix_lib.tex(,107) @table @asis
matrix_lib.tex(,108) @item @strong{Usage:}
matrix_lib.tex(,109) concat(A1,A2,..); A1,A2,... matrices
matrix_lib.tex(,110) 
matrix_lib.tex(,111) @item @strong{Return:}
matrix_lib.tex(,112) matrix, concatenation of A1,A2,.... Number of rows of result matrix
matrix_lib.tex(,113) is max(nrows(A1),nrows(A2),...)
matrix_lib.tex(,114) 
matrix_lib.tex(,115) @end table
matrix_lib.tex(,116) @strong{Example:}
matrix_lib.tex(,117) @smallexample
matrix_lib.tex(,118) @c reused example concat d2t_singular/matrix_lib.doc:98 
matrix_lib.tex(,119) LIB "matrix.lib";
matrix_lib.tex(,120) ring r=0,(x,y,z),ds;
matrix_lib.tex(,121) matrix A[3][3]=1,2,3,x,y,z,x2,y2,z2;
matrix_lib.tex(,122) matrix B[2][2]=1,0,2,0; matrix C[1][4]=4,5,x,y;
matrix_lib.tex(,123) print(A);
matrix_lib.tex(,124) @expansion{} 1, 2, 3,
matrix_lib.tex(,125) @expansion{} x, y, z,
matrix_lib.tex(,126) @expansion{} x2,y2,z2
matrix_lib.tex(,127) print(B);
matrix_lib.tex(,128) @expansion{} 1,0,
matrix_lib.tex(,129) @expansion{} 2,0 
matrix_lib.tex(,130) print(C);
matrix_lib.tex(,131) @expansion{} 4,5,x,y
matrix_lib.tex(,132) print(concat(A,B,C));
matrix_lib.tex(,133) @expansion{} 1, 2, 3, 1,0,4,5,x,y,
matrix_lib.tex(,134) @expansion{} x, y, z, 2,0,0,0,0,0,
matrix_lib.tex(,135) @expansion{} x2,y2,z2,0,0,0,0,0,0 
matrix_lib.tex(,136) @c end example concat d2t_singular/matrix_lib.doc:98
matrix_lib.tex(,137) @end smallexample
matrix_lib.tex(,138) @c ---end content concat---
matrix_lib.tex(,139) 
matrix_lib.tex(,140) @c ------------------- diag -------------
matrix_lib.tex(,141) @node diag, dsum, concat, matrix_lib
matrix_lib.tex(,142) @subsubsection diag
matrix_lib.tex(,143) @cindex diag
matrix_lib.tex(,144) @c ---content diag---
matrix_lib.tex(,145) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,146) 
matrix_lib.tex(,147) @table @asis
matrix_lib.tex(,148) @item @strong{Usage:}
matrix_lib.tex(,149) diag(p,n); p poly, n integer
matrix_lib.tex(,150) @*diag(A); A matrix
matrix_lib.tex(,151) 
matrix_lib.tex(,152) @item @strong{Return:}
matrix_lib.tex(,153) diag(p,n): diagonal matrix, p times unit matrix of size n.
matrix_lib.tex(,154) @* diag(A) : n*m x n*m diagonal matrix with entries all the entries of
matrix_lib.tex(,155) the nxm matrix A, taken from the 1st row, 2nd row etc of A
matrix_lib.tex(,156) 
matrix_lib.tex(,157) @end table
matrix_lib.tex(,158) @strong{Example:}
matrix_lib.tex(,159) @smallexample
matrix_lib.tex(,160) @c reused example diag d2t_singular/matrix_lib.doc:131 
matrix_lib.tex(,161) LIB "matrix.lib";
matrix_lib.tex(,162) ring r = 0,(x,y,z),ds;
matrix_lib.tex(,163) print(diag(xy,4));
matrix_lib.tex(,164) @expansion{} xy,0, 0, 0,
matrix_lib.tex(,165) @expansion{} 0, xy,0, 0,
matrix_lib.tex(,166) @expansion{} 0, 0, xy,0,
matrix_lib.tex(,167) @expansion{} 0, 0, 0, xy
matrix_lib.tex(,168) matrix A[3][2] = 1,2,3,4,5,6;
matrix_lib.tex(,169) print(A);
matrix_lib.tex(,170) @expansion{} 1,2,
matrix_lib.tex(,171) @expansion{} 3,4,
matrix_lib.tex(,172) @expansion{} 5,6 
matrix_lib.tex(,173) print(diag(A));
matrix_lib.tex(,174) @expansion{} 1,0,0,0,0,0,
matrix_lib.tex(,175) @expansion{} 0,2,0,0,0,0,
matrix_lib.tex(,176) @expansion{} 0,0,3,0,0,0,
matrix_lib.tex(,177) @expansion{} 0,0,0,4,0,0,
matrix_lib.tex(,178) @expansion{} 0,0,0,0,5,0,
matrix_lib.tex(,179) @expansion{} 0,0,0,0,0,6 
matrix_lib.tex(,180) @c end example diag d2t_singular/matrix_lib.doc:131
matrix_lib.tex(,181) @end smallexample
matrix_lib.tex(,182) @c ---end content diag---
matrix_lib.tex(,183) 
matrix_lib.tex(,184) @c ------------------- dsum -------------
matrix_lib.tex(,185) @node dsum, flatten, diag, matrix_lib
matrix_lib.tex(,186) @subsubsection dsum
matrix_lib.tex(,187) @cindex dsum
matrix_lib.tex(,188) @c ---content dsum---
matrix_lib.tex(,189) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,190) 
matrix_lib.tex(,191) @table @asis
matrix_lib.tex(,192) @item @strong{Usage:}
matrix_lib.tex(,193) dsum(A1,A2,..); A1,A2,... matrices
matrix_lib.tex(,194) 
matrix_lib.tex(,195) @item @strong{Return:}
matrix_lib.tex(,196) matrix, direct sum of A1,A2,...
matrix_lib.tex(,197) 
matrix_lib.tex(,198) @end table
matrix_lib.tex(,199) @strong{Example:}
matrix_lib.tex(,200) @smallexample
matrix_lib.tex(,201) @c reused example dsum d2t_singular/matrix_lib.doc:159 
matrix_lib.tex(,202) LIB "matrix.lib";
matrix_lib.tex(,203) ring r = 0,(x,y,z),ds;
matrix_lib.tex(,204) matrix A[3][3] = 1,2,3,4,5,6,7,8,9;
matrix_lib.tex(,205) matrix B[2][2] = 1,x,y,z;
matrix_lib.tex(,206) print(A);
matrix_lib.tex(,207) @expansion{} 1,2,3,
matrix_lib.tex(,208) @expansion{} 4,5,6,
matrix_lib.tex(,209) @expansion{} 7,8,9 
matrix_lib.tex(,210) print(B);
matrix_lib.tex(,211) @expansion{} 1,x,
matrix_lib.tex(,212) @expansion{} y,z 
matrix_lib.tex(,213) print(dsum(A,B));
matrix_lib.tex(,214) @expansion{} 1,2,3,0,0,
matrix_lib.tex(,215) @expansion{} 4,5,6,0,0,
matrix_lib.tex(,216) @expansion{} 7,8,9,0,0,
matrix_lib.tex(,217) @expansion{} 0,0,0,1,x,
matrix_lib.tex(,218) @expansion{} 0,0,0,y,z 
matrix_lib.tex(,219) @c end example dsum d2t_singular/matrix_lib.doc:159
matrix_lib.tex(,220) @end smallexample
matrix_lib.tex(,221) @c ---end content dsum---
matrix_lib.tex(,222) 
matrix_lib.tex(,223) @c ------------------- flatten -------------
matrix_lib.tex(,224) @node flatten, genericmat, dsum, matrix_lib
matrix_lib.tex(,225) @subsubsection flatten
matrix_lib.tex(,226) @cindex flatten
matrix_lib.tex(,227) @c ---content flatten---
matrix_lib.tex(,228) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,229) 
matrix_lib.tex(,230) @table @asis
matrix_lib.tex(,231) @item @strong{Usage:}
matrix_lib.tex(,232) flatten(A); A matrix
matrix_lib.tex(,233) 
matrix_lib.tex(,234) @item @strong{Return:}
matrix_lib.tex(,235) ideal, generated by all entries from A
matrix_lib.tex(,236) 
matrix_lib.tex(,237) @end table
matrix_lib.tex(,238) @strong{Example:}
matrix_lib.tex(,239) @smallexample
matrix_lib.tex(,240) @c reused example flatten d2t_singular/matrix_lib.doc:188 
matrix_lib.tex(,241) LIB "matrix.lib";
matrix_lib.tex(,242) ring r = 0,(x,y,z),ds;
matrix_lib.tex(,243) matrix A[2][3] = 1,2,x,y,z,7;
matrix_lib.tex(,244) print(A);
matrix_lib.tex(,245) @expansion{} 1,2,x,
matrix_lib.tex(,246) @expansion{} y,z,7 
matrix_lib.tex(,247) flatten(A);
matrix_lib.tex(,248) @expansion{} _[1]=1
matrix_lib.tex(,249) @expansion{} _[2]=2
matrix_lib.tex(,250) @expansion{} _[3]=x
matrix_lib.tex(,251) @expansion{} _[4]=y
matrix_lib.tex(,252) @expansion{} _[5]=z
matrix_lib.tex(,253) @expansion{} _[6]=7
matrix_lib.tex(,254) @c end example flatten d2t_singular/matrix_lib.doc:188
matrix_lib.tex(,255) @end smallexample
matrix_lib.tex(,256) @c ---end content flatten---
matrix_lib.tex(,257) 
matrix_lib.tex(,258) @c ------------------- genericmat -------------
matrix_lib.tex(,259) @node genericmat, is_complex, flatten, matrix_lib
matrix_lib.tex(,260) @subsubsection genericmat
matrix_lib.tex(,261) @cindex genericmat
matrix_lib.tex(,262) @c ---content genericmat---
matrix_lib.tex(,263) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,264) 
matrix_lib.tex(,265) @table @asis
matrix_lib.tex(,266) @item @strong{Usage:}
matrix_lib.tex(,267) genericmat(n,m[,id]); n,m=integers, id=ideal
matrix_lib.tex(,268) 
matrix_lib.tex(,269) @item @strong{Return:}
matrix_lib.tex(,270) nxm matrix, with entries from id.
matrix_lib.tex(,271) 
matrix_lib.tex(,272) @item @strong{Note:}
matrix_lib.tex(,273) if id has less than nxm elements, the matrix is filled with 0's,
matrix_lib.tex(,274) (default: id=maxideal(1)).
matrix_lib.tex(,275) @*genericmat(n,m); creates the generic nxm matrix
matrix_lib.tex(,276) 
matrix_lib.tex(,277) @end table
matrix_lib.tex(,278) @strong{Example:}
matrix_lib.tex(,279) @smallexample
matrix_lib.tex(,280) @c reused example genericmat d2t_singular/matrix_lib.doc:220 
matrix_lib.tex(,281) LIB "matrix.lib";
matrix_lib.tex(,282) ring R = 0,x(1..16),lp;
matrix_lib.tex(,283) print(genericmat(3,3));      // the generic 3x3 matrix
matrix_lib.tex(,284) @expansion{} x(1),x(2),x(3),
matrix_lib.tex(,285) @expansion{} x(4),x(5),x(6),
matrix_lib.tex(,286) @expansion{} x(7),x(8),x(9) 
matrix_lib.tex(,287) ring R1 = 0,(a,b,c,d),dp;
matrix_lib.tex(,288) matrix A = genericmat(3,4,maxideal(1)^3);
matrix_lib.tex(,289) print(A);
matrix_lib.tex(,290) @expansion{} a3, a2b,a2c,a2d,
matrix_lib.tex(,291) @expansion{} ab2,abc,abd,ac2,
matrix_lib.tex(,292) @expansion{} acd,ad2,b3, b2c 
matrix_lib.tex(,293) int n,m = 3,2;
matrix_lib.tex(,294) ideal i = ideal(randommat(1,n*m,maxideal(1),9));
matrix_lib.tex(,295) print(genericmat(n,m,i));    // matrix of generic linear forms
matrix_lib.tex(,296) @expansion{} 4a-8b-2c-3d,-a+b-4c+5d,
matrix_lib.tex(,297) @expansion{} -8a-9b+c+7d,a-9b+9c+4d,
matrix_lib.tex(,298) @expansion{} 6a-5b+9c,   2a+8c+d    
matrix_lib.tex(,299) @c end example genericmat d2t_singular/matrix_lib.doc:220
matrix_lib.tex(,300) @end smallexample
matrix_lib.tex(,301) @c ---end content genericmat---
matrix_lib.tex(,302) 
matrix_lib.tex(,303) @c ------------------- is_complex -------------
matrix_lib.tex(,304) @node is_complex, outer, genericmat, matrix_lib
matrix_lib.tex(,305) @subsubsection is_complex
matrix_lib.tex(,306) @cindex is_complex
matrix_lib.tex(,307) @c ---content is_complex---
matrix_lib.tex(,308) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,309) 
matrix_lib.tex(,310) @table @asis
matrix_lib.tex(,311) @item @strong{Usage:}
matrix_lib.tex(,312) is_complex(c); c = list of size-compatible modules or matrices
matrix_lib.tex(,313) 
matrix_lib.tex(,314) @item @strong{Return:}
matrix_lib.tex(,315) 1 if c[i]*c[i+1]=0 for all i, 0 if not, hence checking whether the
matrix_lib.tex(,316) list of matrices forms a complex.
matrix_lib.tex(,317) 
matrix_lib.tex(,318) @item @strong{Note:}
matrix_lib.tex(,319) Ideals are treated internally as 1-line matrices.
matrix_lib.tex(,320) @*If printlevel > 0, the position where c is not a complex is shown.
matrix_lib.tex(,321) 
matrix_lib.tex(,322) @end table
matrix_lib.tex(,323) @strong{Example:}
matrix_lib.tex(,324) @smallexample
matrix_lib.tex(,325) @c reused example is_complex d2t_singular/matrix_lib.doc:256 
matrix_lib.tex(,326) LIB "matrix.lib";
matrix_lib.tex(,327) ring r  = 32003,(x,y,z),ds;
matrix_lib.tex(,328) ideal i = x4+y5+z6,xyz,yx2+xz2+zy7;
matrix_lib.tex(,329) list L  = nres(i,0);
matrix_lib.tex(,330) is_complex(L);
matrix_lib.tex(,331) @expansion{} 1
matrix_lib.tex(,332) L[4]    = matrix(i);
matrix_lib.tex(,333) is_complex(L);
matrix_lib.tex(,334) @expansion{} 0
matrix_lib.tex(,335) @c end example is_complex d2t_singular/matrix_lib.doc:256
matrix_lib.tex(,336) @end smallexample
matrix_lib.tex(,337) @c ---end content is_complex---
matrix_lib.tex(,338) 
matrix_lib.tex(,339) @c ------------------- outer -------------
matrix_lib.tex(,340) @node outer, power, is_complex, matrix_lib
matrix_lib.tex(,341) @subsubsection outer
matrix_lib.tex(,342) @cindex outer
matrix_lib.tex(,343) @c ---content outer---
matrix_lib.tex(,344) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,345) 
matrix_lib.tex(,346) @table @asis
matrix_lib.tex(,347) @item @strong{Usage:}
matrix_lib.tex(,348) outer(A,B); A,B matrices
matrix_lib.tex(,349) 
matrix_lib.tex(,350) @item @strong{Return:}
matrix_lib.tex(,351) matrix, outer (tensor) product of A and B
matrix_lib.tex(,352) 
matrix_lib.tex(,353) @end table
matrix_lib.tex(,354) @strong{Example:}
matrix_lib.tex(,355) @smallexample
matrix_lib.tex(,356) @c reused example outer d2t_singular/matrix_lib.doc:285 
matrix_lib.tex(,357) LIB "matrix.lib";
matrix_lib.tex(,358) ring r=32003,(x,y,z),ds;
matrix_lib.tex(,359) matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix_lib.tex(,360) matrix B[2][2]=x,y,0,z;
matrix_lib.tex(,361) print(A);
matrix_lib.tex(,362) @expansion{} 1,2,3,
matrix_lib.tex(,363) @expansion{} 4,5,6,
matrix_lib.tex(,364) @expansion{} 7,8,9 
matrix_lib.tex(,365) print(B);
matrix_lib.tex(,366) @expansion{} x,y,
matrix_lib.tex(,367) @expansion{} 0,z 
matrix_lib.tex(,368) print(outer(A,B));
matrix_lib.tex(,369) @expansion{} x, y, 2x,2y,3x,3y,
matrix_lib.tex(,370) @expansion{} 0, z, 0, 2z,0, 3z,
matrix_lib.tex(,371) @expansion{} 4x,4y,5x,5y,6x,6y,
matrix_lib.tex(,372) @expansion{} 0, 4z,0, 5z,0, 6z,
matrix_lib.tex(,373) @expansion{} 7x,7y,8x,8y,9x,9y,
matrix_lib.tex(,374) @expansion{} 0, 7z,0, 8z,0, 9z 
matrix_lib.tex(,375) @c end example outer d2t_singular/matrix_lib.doc:285
matrix_lib.tex(,376) @end smallexample
matrix_lib.tex(,377) @c ---end content outer---
matrix_lib.tex(,378) 
matrix_lib.tex(,379) @c ------------------- power -------------
matrix_lib.tex(,380) @node power, skewmat, outer, matrix_lib
matrix_lib.tex(,381) @subsubsection power
matrix_lib.tex(,382) @cindex power
matrix_lib.tex(,383) @c ---content power---
matrix_lib.tex(,384) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,385) 
matrix_lib.tex(,386) @table @asis
matrix_lib.tex(,387) @item @strong{Usage:}
matrix_lib.tex(,388) power(A,n); A a square-matrix of type intmat or matrix, n=integer
matrix_lib.tex(,389) 
matrix_lib.tex(,390) @item @strong{Return:}
matrix_lib.tex(,391) intmat resp. matrix, the n-th power of A
matrix_lib.tex(,392) 
matrix_lib.tex(,393) @item @strong{Note:}
matrix_lib.tex(,394) for A=intmat and big n the result may be wrong because of int overflow
matrix_lib.tex(,395) 
matrix_lib.tex(,396) @end table
matrix_lib.tex(,397) @strong{Example:}
matrix_lib.tex(,398) @smallexample
matrix_lib.tex(,399) @c reused example power d2t_singular/matrix_lib.doc:317 
matrix_lib.tex(,400) LIB "matrix.lib";
matrix_lib.tex(,401) intmat A[3][3]=1,2,3,4,5,6,7,8,9;
matrix_lib.tex(,402) print(power(A,3));"";
matrix_lib.tex(,403) @expansion{}    468   576   684
matrix_lib.tex(,404) @expansion{}   1062  1305  1548
matrix_lib.tex(,405) @expansion{}   1656  2034  2412
matrix_lib.tex(,406) @expansion{} 
matrix_lib.tex(,407) ring r=0,(x,y,z),dp;
matrix_lib.tex(,408) matrix B[3][3]=0,x,y,z,0,0,y,z,0;
matrix_lib.tex(,409) print(power(B,3));"";
matrix_lib.tex(,410) @expansion{} yz2,    xy2+x2z,y3+xyz,
matrix_lib.tex(,411) @expansion{} y2z+xz2,yz2,    0,     
matrix_lib.tex(,412) @expansion{} y3+xyz, y2z+xz2,yz2    
matrix_lib.tex(,413) @expansion{} 
matrix_lib.tex(,414) @c end example power d2t_singular/matrix_lib.doc:317
matrix_lib.tex(,415) @end smallexample
matrix_lib.tex(,416) @c ---end content power---
matrix_lib.tex(,417) 
matrix_lib.tex(,418) @c ------------------- skewmat -------------
matrix_lib.tex(,419) @node skewmat, submat, power, matrix_lib
matrix_lib.tex(,420) @subsubsection skewmat
matrix_lib.tex(,421) @cindex skewmat
matrix_lib.tex(,422) @c ---content skewmat---
matrix_lib.tex(,423) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,424) 
matrix_lib.tex(,425) @table @asis
matrix_lib.tex(,426) @item @strong{Usage:}
matrix_lib.tex(,427) skewmat(n[,id]); n integer, id ideal
matrix_lib.tex(,428) 
matrix_lib.tex(,429) @item @strong{Return:}
matrix_lib.tex(,430) skew-symmetric nxn matrix, with entries from id
matrix_lib.tex(,431) @*(default: id=maxideal(1))
matrix_lib.tex(,432) @*skewmat(n); creates the generic skew-symmetric matrix
matrix_lib.tex(,433) 
matrix_lib.tex(,434) @item @strong{Note:}
matrix_lib.tex(,435) if id has less than n*(n-1)/2 elements, the matrix is
matrix_lib.tex(,436) @*filled with 0's,
matrix_lib.tex(,437) 
matrix_lib.tex(,438) @end table
matrix_lib.tex(,439) @strong{Example:}
matrix_lib.tex(,440) @smallexample
matrix_lib.tex(,441) @c reused example skewmat d2t_singular/matrix_lib.doc:351 
matrix_lib.tex(,442) LIB "matrix.lib";
matrix_lib.tex(,443) ring R=0,x(1..5),lp;
matrix_lib.tex(,444) print(skewmat(4));    // the generic skew-symmetric matrix
matrix_lib.tex(,445) @expansion{} 0,    x(1), x(2),x(3),
matrix_lib.tex(,446) @expansion{} -x(1),0,    x(4),x(5),
matrix_lib.tex(,447) @expansion{} -x(2),-x(4),0,   0,   
matrix_lib.tex(,448) @expansion{} -x(3),-x(5),0,   0    
matrix_lib.tex(,449) ring R1 = 0,(a,b,c),dp;
matrix_lib.tex(,450) matrix A=skewmat(4,maxideal(1)^2);
matrix_lib.tex(,451) print(A);
matrix_lib.tex(,452) @expansion{} 0,  a2, ab, ac,
matrix_lib.tex(,453) @expansion{} -a2,0,  b2, bc,
matrix_lib.tex(,454) @expansion{} -ab,-b2,0,  c2,
matrix_lib.tex(,455) @expansion{} -ac,-bc,-c2,0  
matrix_lib.tex(,456) int n=3;
matrix_lib.tex(,457) ideal i = ideal(randommat(1,n*(n-1) div 2,maxideal(1),9));
matrix_lib.tex(,458) print(skewmat(n,i));  // skew matrix of generic linear forms
matrix_lib.tex(,459) @expansion{} 0,       4a+b-8c, -a+6b+c,  
matrix_lib.tex(,460) @expansion{} -4a-b+8c,0,       -8a+2b-9c,
matrix_lib.tex(,461) @expansion{} a-6b-c,  8a-2b+9c,0         
matrix_lib.tex(,462) kill R1;
matrix_lib.tex(,463) @c end example skewmat d2t_singular/matrix_lib.doc:351
matrix_lib.tex(,464) @end smallexample
matrix_lib.tex(,465) @c ---end content skewmat---
matrix_lib.tex(,466) 
matrix_lib.tex(,467) @c ------------------- submat -------------
matrix_lib.tex(,468) @node submat, symmat, skewmat, matrix_lib
matrix_lib.tex(,469) @subsubsection submat
matrix_lib.tex(,470) @cindex submat
matrix_lib.tex(,471) @c ---content submat---
matrix_lib.tex(,472) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,473) 
matrix_lib.tex(,474) @table @asis
matrix_lib.tex(,475) @item @strong{Usage:}
matrix_lib.tex(,476) submat(A,r,c); A=matrix, r,c=intvec
matrix_lib.tex(,477) 
matrix_lib.tex(,478) @item @strong{Return:}
matrix_lib.tex(,479) matrix, submatrix of A with rows specified by intvec r
matrix_lib.tex(,480) and columns specified by intvec c.
matrix_lib.tex(,481) 
matrix_lib.tex(,482) @end table
matrix_lib.tex(,483) @strong{Example:}
matrix_lib.tex(,484) @smallexample
matrix_lib.tex(,485) @c reused example submat d2t_singular/matrix_lib.doc:384 
matrix_lib.tex(,486) LIB "matrix.lib";
matrix_lib.tex(,487) ring R=32003,(x,y,z),lp;
matrix_lib.tex(,488) matrix A[4][4]=x,y,z,0,1,2,3,4,5,6,7,8,9,x2,y2,z2;
matrix_lib.tex(,489) print(A);
matrix_lib.tex(,490) @expansion{} x,y, z, 0,
matrix_lib.tex(,491) @expansion{} 1,2, 3, 4,
matrix_lib.tex(,492) @expansion{} 5,6, 7, 8,
matrix_lib.tex(,493) @expansion{} 9,x2,y2,z2
matrix_lib.tex(,494) intvec v=1,3,4;
matrix_lib.tex(,495) matrix B=submat(A,v,1..3);
matrix_lib.tex(,496) print(B);
matrix_lib.tex(,497) @expansion{} x,y, z,
matrix_lib.tex(,498) @expansion{} 5,6, 7,
matrix_lib.tex(,499) @expansion{} 9,x2,y2
matrix_lib.tex(,500) @c end example submat d2t_singular/matrix_lib.doc:384
matrix_lib.tex(,501) @end smallexample
matrix_lib.tex(,502) @c ---end content submat---
matrix_lib.tex(,503) 
matrix_lib.tex(,504) @c ------------------- symmat -------------
matrix_lib.tex(,505) @node symmat, tensor, submat, matrix_lib
matrix_lib.tex(,506) @subsubsection symmat
matrix_lib.tex(,507) @cindex symmat
matrix_lib.tex(,508) @c ---content symmat---
matrix_lib.tex(,509) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,510) 
matrix_lib.tex(,511) @table @asis
matrix_lib.tex(,512) @item @strong{Usage:}
matrix_lib.tex(,513) symmat(n[,id]); n integer, id ideal
matrix_lib.tex(,514) 
matrix_lib.tex(,515) @item @strong{Return:}
matrix_lib.tex(,516) symmetric nxn matrix, with entries from id (default: id=maxideal(1))
matrix_lib.tex(,517) 
matrix_lib.tex(,518) @item @strong{Note:}
matrix_lib.tex(,519) if id has less than n*(n+1)/2 elements, the matrix is filled with 0's,
matrix_lib.tex(,520) symmat(n); creates the generic symmetric matrix
matrix_lib.tex(,521) 
matrix_lib.tex(,522) @end table
matrix_lib.tex(,523) @strong{Example:}
matrix_lib.tex(,524) @smallexample
matrix_lib.tex(,525) @c reused example symmat d2t_singular/matrix_lib.doc:417 
matrix_lib.tex(,526) LIB "matrix.lib";
matrix_lib.tex(,527) ring R=0,x(1..10),lp;
matrix_lib.tex(,528) print(symmat(4));    // the generic symmetric matrix
matrix_lib.tex(,529) @expansion{} x(1),x(2),x(3),x(4),
matrix_lib.tex(,530) @expansion{} x(2),x(5),x(6),x(7),
matrix_lib.tex(,531) @expansion{} x(3),x(6),x(8),x(9),
matrix_lib.tex(,532) @expansion{} x(4),x(7),x(9),x(10)
matrix_lib.tex(,533) ring R1 = 0,(a,b,c),dp;
matrix_lib.tex(,534) matrix A=symmat(4,maxideal(1)^3);
matrix_lib.tex(,535) print(A);
matrix_lib.tex(,536) @expansion{} a3, a2b,a2c,ab2,
matrix_lib.tex(,537) @expansion{} a2b,abc,ac2,b3, 
matrix_lib.tex(,538) @expansion{} a2c,ac2,b2c,bc2,
matrix_lib.tex(,539) @expansion{} ab2,b3, bc2,c3  
matrix_lib.tex(,540) int n=3;
matrix_lib.tex(,541) ideal i = ideal(randommat(1,n*(n+1) div 2,maxideal(1),9));
matrix_lib.tex(,542) print(symmat(n,i));  // symmetric matrix of generic linear forms
matrix_lib.tex(,543) @expansion{} 4a-8b-2c,-a+b-4c, -8a-9b+c,
matrix_lib.tex(,544) @expansion{} -a+b-4c, a-9b+9c, 6a-5b+9c,
matrix_lib.tex(,545) @expansion{} -8a-9b+c,6a-5b+9c,2a+8c    
matrix_lib.tex(,546) kill R1;
matrix_lib.tex(,547) @c end example symmat d2t_singular/matrix_lib.doc:417
matrix_lib.tex(,548) @end smallexample
matrix_lib.tex(,549) @c ---end content symmat---
matrix_lib.tex(,550) 
matrix_lib.tex(,551) @c ------------------- tensor -------------
matrix_lib.tex(,552) @node tensor, unitmat, symmat, matrix_lib
matrix_lib.tex(,553) @subsubsection tensor
matrix_lib.tex(,554) @cindex tensor
matrix_lib.tex(,555) @c ---content tensor---
matrix_lib.tex(,556) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,557) 
matrix_lib.tex(,558) @table @asis
matrix_lib.tex(,559) @item @strong{Usage:}
matrix_lib.tex(,560) tensor(A,B); A,B matrices
matrix_lib.tex(,561) 
matrix_lib.tex(,562) @item @strong{Return:}
matrix_lib.tex(,563) matrix, tensor product of A and B
matrix_lib.tex(,564) 
matrix_lib.tex(,565) @end table
matrix_lib.tex(,566) @strong{Example:}
matrix_lib.tex(,567) @smallexample
matrix_lib.tex(,568) @c reused example tensor d2t_singular/matrix_lib.doc:449 
matrix_lib.tex(,569) LIB "matrix.lib";
matrix_lib.tex(,570) ring r=32003,(x,y,z),(c,ds);
matrix_lib.tex(,571) matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix_lib.tex(,572) matrix B[2][2]=x,y,0,z;
matrix_lib.tex(,573) print(A);
matrix_lib.tex(,574) @expansion{} 1,2,3,
matrix_lib.tex(,575) @expansion{} 4,5,6,
matrix_lib.tex(,576) @expansion{} 7,8,9 
matrix_lib.tex(,577) print(B);
matrix_lib.tex(,578) @expansion{} x,y,
matrix_lib.tex(,579) @expansion{} 0,z 
matrix_lib.tex(,580) print(tensor(A,B));
matrix_lib.tex(,581) @expansion{} x, y, 2x,2y,3x,3y,
matrix_lib.tex(,582) @expansion{} 0, z, 0, 2z,0, 3z,
matrix_lib.tex(,583) @expansion{} 4x,4y,5x,5y,6x,6y,
matrix_lib.tex(,584) @expansion{} 0, 4z,0, 5z,0, 6z,
matrix_lib.tex(,585) @expansion{} 7x,7y,8x,8y,9x,9y,
matrix_lib.tex(,586) @expansion{} 0, 7z,0, 8z,0, 9z 
matrix_lib.tex(,587) @c end example tensor d2t_singular/matrix_lib.doc:449
matrix_lib.tex(,588) @end smallexample
matrix_lib.tex(,589) @c ---end content tensor---
matrix_lib.tex(,590) 
matrix_lib.tex(,591) @c ------------------- unitmat -------------
matrix_lib.tex(,592) @node unitmat, gauss_col, tensor, matrix_lib
matrix_lib.tex(,593) @subsubsection unitmat
matrix_lib.tex(,594) @cindex unitmat
matrix_lib.tex(,595) @c ---content unitmat---
matrix_lib.tex(,596) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,597) 
matrix_lib.tex(,598) @table @asis
matrix_lib.tex(,599) @item @strong{Usage:}
matrix_lib.tex(,600) unitmat(n); n integer >= 0
matrix_lib.tex(,601) 
matrix_lib.tex(,602) @item @strong{Return:}
matrix_lib.tex(,603) nxn unit matrix
matrix_lib.tex(,604) 
matrix_lib.tex(,605) @item @strong{Note:}
matrix_lib.tex(,606) needs a basering, diagonal entries are numbers (=1) in the basering
matrix_lib.tex(,607) 
matrix_lib.tex(,608) @end table
matrix_lib.tex(,609) @strong{Example:}
matrix_lib.tex(,610) @smallexample
matrix_lib.tex(,611) @c reused example unitmat d2t_singular/matrix_lib.doc:481 
matrix_lib.tex(,612) LIB "matrix.lib";
matrix_lib.tex(,613) ring r=32003,(x,y,z),lp;
matrix_lib.tex(,614) print(xyz*unitmat(4));
matrix_lib.tex(,615) @expansion{} xyz,0,  0,  0, 
matrix_lib.tex(,616) @expansion{} 0,  xyz,0,  0, 
matrix_lib.tex(,617) @expansion{} 0,  0,  xyz,0, 
matrix_lib.tex(,618) @expansion{} 0,  0,  0,  xyz
matrix_lib.tex(,619) print(unitmat(5));
matrix_lib.tex(,620) @expansion{} 1,0,0,0,0,
matrix_lib.tex(,621) @expansion{} 0,1,0,0,0,
matrix_lib.tex(,622) @expansion{} 0,0,1,0,0,
matrix_lib.tex(,623) @expansion{} 0,0,0,1,0,
matrix_lib.tex(,624) @expansion{} 0,0,0,0,1 
matrix_lib.tex(,625) @c end example unitmat d2t_singular/matrix_lib.doc:481
matrix_lib.tex(,626) @end smallexample
matrix_lib.tex(,627) @c ---end content unitmat---
matrix_lib.tex(,628) 
matrix_lib.tex(,629) @c ------------------- gauss_col -------------
matrix_lib.tex(,630) @node gauss_col, gauss_row, unitmat, matrix_lib
matrix_lib.tex(,631) @subsubsection gauss_col
matrix_lib.tex(,632) @cindex gauss_col
matrix_lib.tex(,633) @c ---content gauss_col---
matrix_lib.tex(,634) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,635) 
matrix_lib.tex(,636) @table @asis
matrix_lib.tex(,637) @item @strong{Usage:}
matrix_lib.tex(,638) gauss_col(A[,e]); A a matrix, e any type
matrix_lib.tex(,639) 
matrix_lib.tex(,640) @item @strong{Return:}
matrix_lib.tex(,641) - a matrix B, if called with one argument; B is the complete column-
matrix_lib.tex(,642) reduced upper-triangular normal form of A if A is constant,
matrix_lib.tex(,643) (resp. as far as this is possible if A is a polynomial matrix;
matrix_lib.tex(,644) no division by polynomials).
matrix_lib.tex(,645) @* - a list L of two matrices, if called with two arguments;
matrix_lib.tex(,646) L satisfies L[1] = A * L[2] with L[1] the column-reduced form of A
matrix_lib.tex(,647) and L[2] the transformation matrix.
matrix_lib.tex(,648) 
matrix_lib.tex(,649) @item @strong{Note:}
matrix_lib.tex(,650) * The procedure just applies interred to A with ordering (C,dp).
matrix_lib.tex(,651) The transformation matrix is obtained by applying 'lift'.
matrix_lib.tex(,652) This should be faster than the procedure colred.
matrix_lib.tex(,653) @* * It should only be used with exact coefficient field (there is no
matrix_lib.tex(,654) pivoting and rounding error treatment).
matrix_lib.tex(,655) @* * Parameters are allowed. Hence, if the entries of A are parameters,
matrix_lib.tex(,656) B is the column-reduced form of A over the rational function field.
matrix_lib.tex(,657) 
matrix_lib.tex(,658) @end table
matrix_lib.tex(,659) @strong{Example:}
matrix_lib.tex(,660) @smallexample
matrix_lib.tex(,661) @c reused example gauss_col d2t_singular/matrix_lib.doc:522 
matrix_lib.tex(,662) LIB "matrix.lib";
matrix_lib.tex(,663) ring r=(0,a,b),(A,B,C),dp;
matrix_lib.tex(,664) matrix m[8][6]=
matrix_lib.tex(,665) 0,    2*C, 0,    0,  0,   0,
matrix_lib.tex(,666) 0,    -4*C,a*A,  0,  0,   0,
matrix_lib.tex(,667) b*B,  -A,  0,    0,  0,   0,
matrix_lib.tex(,668) -A,   B,   0,    0,  0,   0,
matrix_lib.tex(,669) -4*C, 0,   B,    2,  0,   0,
matrix_lib.tex(,670) 2*A,  B,   0,    0,  0,   0,
matrix_lib.tex(,671) 0,    3*B, 0,    0,  2b,  0,
matrix_lib.tex(,672) 0,    AB,  0,    2*A,A,   2a;"";
matrix_lib.tex(,673) @expansion{} 
matrix_lib.tex(,674) list L=gauss_col(m,1);
matrix_lib.tex(,675) print(L[1]);
matrix_lib.tex(,676) @expansion{} 0,0,2*C, 0,       0,0,
matrix_lib.tex(,677) @expansion{} A,0,-4*C,0,       0,0,
matrix_lib.tex(,678) @expansion{} 0,0,-A,  (1/2b)*B,0,0,
matrix_lib.tex(,679) @expansion{} 0,0,B,   -1/2*A,  0,0,
matrix_lib.tex(,680) @expansion{} 0,1,0,   0,       0,0,
matrix_lib.tex(,681) @expansion{} 0,0,B,   A,       0,0,
matrix_lib.tex(,682) @expansion{} 0,0,0,   0,       1,0,
matrix_lib.tex(,683) @expansion{} 0,0,0,   0,       0,1 
matrix_lib.tex(,684) print(L[2]);
matrix_lib.tex(,685) @expansion{} 0,         0,        0,               1/2,      0,         0,    
matrix_lib.tex(,686) @expansion{} 0,         0,        1,               0,        0,         0,    
matrix_lib.tex(,687) @expansion{} 1/(a),     0,        0,               0,        0,         0,    
matrix_lib.tex(,688) @expansion{} -1/(2a)*B, 1/2,      0,               C,        0,         0,    
matrix_lib.tex(,689) @expansion{} 0,         0,        -3/(2b)*B,       0,        1/(2b),    0,    
matrix_lib.tex(,690) @expansion{} 1/(2a2)*AB,-1/(2a)*A,(-2b+3)/(4ab)*AB,-1/(a)*AC,-1/(4ab)*A,1/(2a)
matrix_lib.tex(,691) ring S=0,x,(c,dp);
matrix_lib.tex(,692) matrix A[5][4] =
matrix_lib.tex(,693) 3, 1, 1, 1,
matrix_lib.tex(,694) 13, 8, 6,-7,
matrix_lib.tex(,695) 14,10, 6,-7,
matrix_lib.tex(,696) 7, 4, 3,-3,
matrix_lib.tex(,697) 2, 1, 0, 3;
matrix_lib.tex(,698) print(gauss_col(A));
matrix_lib.tex(,699) @expansion{} 8/9,-5/9,-1/3,7/9,
matrix_lib.tex(,700) @expansion{} 1,  0,   0,   0,  
matrix_lib.tex(,701) @expansion{} 0,  1,   0,   0,  
matrix_lib.tex(,702) @expansion{} 0,  0,   1,   0,  
matrix_lib.tex(,703) @expansion{} 0,  0,   0,   1   
matrix_lib.tex(,704) @c end example gauss_col d2t_singular/matrix_lib.doc:522
matrix_lib.tex(,705) @end smallexample
matrix_lib.tex(,706) @c inserted refs from d2t_singular/matrix_lib.doc:547
matrix_lib.tex(,717) @c end inserted refs from d2t_singular/matrix_lib.doc:547
matrix_lib.tex(,718) 
matrix_lib.tex(,719) @c ---end content gauss_col---
matrix_lib.tex(,720) 
matrix_lib.tex(,721) @c ------------------- gauss_row -------------
matrix_lib.tex(,722) @node gauss_row, addcol, gauss_col, matrix_lib
matrix_lib.tex(,723) @subsubsection gauss_row
matrix_lib.tex(,724) @cindex gauss_row
matrix_lib.tex(,725) @c ---content gauss_row---
matrix_lib.tex(,726) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,727) 
matrix_lib.tex(,728) @table @asis
matrix_lib.tex(,729) @item @strong{Usage:}
matrix_lib.tex(,730) gauss_row(A [,e]); A matrix, e any type
matrix_lib.tex(,731) 
matrix_lib.tex(,732) @item @strong{Return:}
matrix_lib.tex(,733) - a matrix B, if called with one argument; B is the complete row-
matrix_lib.tex(,734) reduced lower-triangular normal form of A if A is constant,
matrix_lib.tex(,735) (resp. as far as this is possible if A is a polynomial matrix;
matrix_lib.tex(,736) no division by polynomials).
matrix_lib.tex(,737) @* - a list L of two matrices, if called with two arguments;
matrix_lib.tex(,738) L satisfies L[1] = L[2] * A with L[1] the row-reduced form of A
matrix_lib.tex(,739) and L[2] the transformation matrix.
matrix_lib.tex(,740) 
matrix_lib.tex(,741) @item @strong{Note:}
matrix_lib.tex(,742) * This procedure just applies gauss_col to the transposed matrix.
matrix_lib.tex(,743) The transformation matrix is obtained by applying lift.
matrix_lib.tex(,744) This should be faster than the procedure rowred.
matrix_lib.tex(,745) @* * It should only be used with exact coefficient field (there is no
matrix_lib.tex(,746) pivoting and rounding error treatment).
matrix_lib.tex(,747) @* * Parameters are allowed. Hence, if the entries of A are parameters,
matrix_lib.tex(,748) B is the row-reduced form of A over the rational function field.
matrix_lib.tex(,749) 
matrix_lib.tex(,750) @end table
matrix_lib.tex(,751) @strong{Example:}
matrix_lib.tex(,752) @smallexample
matrix_lib.tex(,753) @c reused example gauss_row d2t_singular/matrix_lib.doc:585 
matrix_lib.tex(,754) LIB "matrix.lib";
matrix_lib.tex(,755) ring r=(0,a,b),(A,B,C),dp;
matrix_lib.tex(,756) matrix m[6][8]=
matrix_lib.tex(,757) 0, 0,  b*B, -A,-4C,2A,0, 0,
matrix_lib.tex(,758) 2C,-4C,-A,B, 0,  B, 3B,AB,
matrix_lib.tex(,759) 0,a*A,  0, 0, B,  0, 0, 0,
matrix_lib.tex(,760) 0, 0,  0, 0, 2,  0, 0, 2A,
matrix_lib.tex(,761) 0, 0,  0, 0, 0,  0, 2b, A,
matrix_lib.tex(,762) 0, 0,  0, 0, 0,  0, 0, 2a;"";
matrix_lib.tex(,763) @expansion{} 
matrix_lib.tex(,764) print(gauss_row(m));"";
matrix_lib.tex(,765) @expansion{} 0,  A,   0,       0,     0,0,0,0,
matrix_lib.tex(,766) @expansion{} 0,  0,   0,       0,     1,0,0,0,
matrix_lib.tex(,767) @expansion{} 2*C,-4*C,-A,      B,     0,B,0,0,
matrix_lib.tex(,768) @expansion{} 0,  0,   (1/2b)*B,-1/2*A,0,A,0,0,
matrix_lib.tex(,769) @expansion{} 0,  0,   0,       0,     0,0,1,0,
matrix_lib.tex(,770) @expansion{} 0,  0,   0,       0,     0,0,0,1 
matrix_lib.tex(,771) @expansion{} 
matrix_lib.tex(,772) ring S=0,x,dp;
matrix_lib.tex(,773) matrix A[4][5] =  3, 1,1,-1,2,
matrix_lib.tex(,774) 13, 8,6,-7,1,
matrix_lib.tex(,775) 14,10,6,-7,1,
matrix_lib.tex(,776) 7, 4,3,-3,3;
matrix_lib.tex(,777) list L=gauss_row(A,1);
matrix_lib.tex(,778) print(L[1]);
matrix_lib.tex(,779) @expansion{} 1/2,-7/3,-19/6,5/6,
matrix_lib.tex(,780) @expansion{} 1,  0,   0,    0,  
matrix_lib.tex(,781) @expansion{} 0,  1,   0,    0,  
matrix_lib.tex(,782) @expansion{} 0,  0,   1,    0,  
matrix_lib.tex(,783) @expansion{} 0,  0,   0,    1   
matrix_lib.tex(,784) print(L[2]);
matrix_lib.tex(,785) @expansion{} 0,   -6,  -5,  1,   
matrix_lib.tex(,786) @expansion{} -1/2,2/3, -1/6,-1/6,
matrix_lib.tex(,787) @expansion{} 1/2, -5/3,-5/6,1/6, 
matrix_lib.tex(,788) @expansion{} 0,   13/3,11/3,-1/3 
matrix_lib.tex(,789) @c end example gauss_row d2t_singular/matrix_lib.doc:585
matrix_lib.tex(,790) @end smallexample
matrix_lib.tex(,791) @c inserted refs from d2t_singular/matrix_lib.doc:606
matrix_lib.tex(,802) @c end inserted refs from d2t_singular/matrix_lib.doc:606
matrix_lib.tex(,803) 
matrix_lib.tex(,804) @c ---end content gauss_row---
matrix_lib.tex(,805) 
matrix_lib.tex(,806) @c ------------------- addcol -------------
matrix_lib.tex(,807) @node addcol, addrow, gauss_row, matrix_lib
matrix_lib.tex(,808) @subsubsection addcol
matrix_lib.tex(,809) @cindex addcol
matrix_lib.tex(,810) @c ---content addcol---
matrix_lib.tex(,811) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,812) 
matrix_lib.tex(,813) @table @asis
matrix_lib.tex(,814) @item @strong{Usage:}
matrix_lib.tex(,815) addcol(A,c1,p,c2); A matrix, p poly, c1, c2 positive integers
matrix_lib.tex(,816) 
matrix_lib.tex(,817) @item @strong{Return:}
matrix_lib.tex(,818) matrix, A being modified by adding p times column c1 to column c2
matrix_lib.tex(,819) 
matrix_lib.tex(,820) @end table
matrix_lib.tex(,821) @strong{Example:}
matrix_lib.tex(,822) @smallexample
matrix_lib.tex(,823) @c reused example addcol d2t_singular/matrix_lib.doc:629 
matrix_lib.tex(,824) LIB "matrix.lib";
matrix_lib.tex(,825) ring r=32003,(x,y,z),lp;
matrix_lib.tex(,826) matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix_lib.tex(,827) print(A);
matrix_lib.tex(,828) @expansion{} 1,2,3,
matrix_lib.tex(,829) @expansion{} 4,5,6,
matrix_lib.tex(,830) @expansion{} 7,8,9 
matrix_lib.tex(,831) print(addcol(A,1,xy,2));
matrix_lib.tex(,832) @expansion{} 1,xy+2, 3,
matrix_lib.tex(,833) @expansion{} 4,4xy+5,6,
matrix_lib.tex(,834) @expansion{} 7,7xy+8,9 
matrix_lib.tex(,835) @c end example addcol d2t_singular/matrix_lib.doc:629
matrix_lib.tex(,836) @end smallexample
matrix_lib.tex(,837) @c ---end content addcol---
matrix_lib.tex(,838) 
matrix_lib.tex(,839) @c ------------------- addrow -------------
matrix_lib.tex(,840) @node addrow, multcol, addcol, matrix_lib
matrix_lib.tex(,841) @subsubsection addrow
matrix_lib.tex(,842) @cindex addrow
matrix_lib.tex(,843) @c ---content addrow---
matrix_lib.tex(,844) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,845) 
matrix_lib.tex(,846) @table @asis
matrix_lib.tex(,847) @item @strong{Usage:}
matrix_lib.tex(,848) addcol(A,r1,p,r2); A matrix, p poly, r1, r2 positive integers
matrix_lib.tex(,849) 
matrix_lib.tex(,850) @item @strong{Return:}
matrix_lib.tex(,851) matrix, A being modified by adding p times row r1 to row r2
matrix_lib.tex(,852) 
matrix_lib.tex(,853) @end table
matrix_lib.tex(,854) @strong{Example:}
matrix_lib.tex(,855) @smallexample
matrix_lib.tex(,856) @c reused example addrow d2t_singular/matrix_lib.doc:656 
matrix_lib.tex(,857) LIB "matrix.lib";
matrix_lib.tex(,858) ring r=32003,(x,y,z),lp;
matrix_lib.tex(,859) matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix_lib.tex(,860) print(A);
matrix_lib.tex(,861) @expansion{} 1,2,3,
matrix_lib.tex(,862) @expansion{} 4,5,6,
matrix_lib.tex(,863) @expansion{} 7,8,9 
matrix_lib.tex(,864) print(addrow(A,1,xy,3));
matrix_lib.tex(,865) @expansion{} 1,   2,    3,   
matrix_lib.tex(,866) @expansion{} 4,   5,    6,   
matrix_lib.tex(,867) @expansion{} xy+7,2xy+8,3xy+9
matrix_lib.tex(,868) @c end example addrow d2t_singular/matrix_lib.doc:656
matrix_lib.tex(,869) @end smallexample
matrix_lib.tex(,870) @c ---end content addrow---
matrix_lib.tex(,871) 
matrix_lib.tex(,872) @c ------------------- multcol -------------
matrix_lib.tex(,873) @node multcol, multrow, addrow, matrix_lib
matrix_lib.tex(,874) @subsubsection multcol
matrix_lib.tex(,875) @cindex multcol
matrix_lib.tex(,876) @c ---content multcol---
matrix_lib.tex(,877) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,878) 
matrix_lib.tex(,879) @table @asis
matrix_lib.tex(,880) @item @strong{Usage:}
matrix_lib.tex(,881) addcol(A,c,p); A matrix, p poly, c positive integer
matrix_lib.tex(,882) 
matrix_lib.tex(,883) @item @strong{Return:}
matrix_lib.tex(,884) matrix, A being modified by multiplying column c with p
matrix_lib.tex(,885) 
matrix_lib.tex(,886) @end table
matrix_lib.tex(,887) @strong{Example:}
matrix_lib.tex(,888) @smallexample
matrix_lib.tex(,889) @c reused example multcol d2t_singular/matrix_lib.doc:683 
matrix_lib.tex(,890) LIB "matrix.lib";
matrix_lib.tex(,891) ring r=32003,(x,y,z),lp;
matrix_lib.tex(,892) matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix_lib.tex(,893) print(A);
matrix_lib.tex(,894) @expansion{} 1,2,3,
matrix_lib.tex(,895) @expansion{} 4,5,6,
matrix_lib.tex(,896) @expansion{} 7,8,9 
matrix_lib.tex(,897) print(multcol(A,2,xy));
matrix_lib.tex(,898) @expansion{} 1,2xy,3,
matrix_lib.tex(,899) @expansion{} 4,5xy,6,
matrix_lib.tex(,900) @expansion{} 7,8xy,9 
matrix_lib.tex(,901) @c end example multcol d2t_singular/matrix_lib.doc:683
matrix_lib.tex(,902) @end smallexample
matrix_lib.tex(,903) @c ---end content multcol---
matrix_lib.tex(,904) 
matrix_lib.tex(,905) @c ------------------- multrow -------------
matrix_lib.tex(,906) @node multrow, permcol, multcol, matrix_lib
matrix_lib.tex(,907) @subsubsection multrow
matrix_lib.tex(,908) @cindex multrow
matrix_lib.tex(,909) @c ---content multrow---
matrix_lib.tex(,910) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,911) 
matrix_lib.tex(,912) @table @asis
matrix_lib.tex(,913) @item @strong{Usage:}
matrix_lib.tex(,914) multrow(A,r,p); A matrix, p poly, r positive integer
matrix_lib.tex(,915) 
matrix_lib.tex(,916) @item @strong{Return:}
matrix_lib.tex(,917) matrix, A being modified by multiplying row r with p
matrix_lib.tex(,918) 
matrix_lib.tex(,919) @end table
matrix_lib.tex(,920) @strong{Example:}
matrix_lib.tex(,921) @smallexample
matrix_lib.tex(,922) @c reused example multrow d2t_singular/matrix_lib.doc:710 
matrix_lib.tex(,923) LIB "matrix.lib";
matrix_lib.tex(,924) ring r=32003,(x,y,z),lp;
matrix_lib.tex(,925) matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix_lib.tex(,926) print(A);
matrix_lib.tex(,927) @expansion{} 1,2,3,
matrix_lib.tex(,928) @expansion{} 4,5,6,
matrix_lib.tex(,929) @expansion{} 7,8,9 
matrix_lib.tex(,930) print(multrow(A,2,xy));
matrix_lib.tex(,931) @expansion{} 1,  2,  3,  
matrix_lib.tex(,932) @expansion{} 4xy,5xy,6xy,
matrix_lib.tex(,933) @expansion{} 7,  8,  9   
matrix_lib.tex(,934) @c end example multrow d2t_singular/matrix_lib.doc:710
matrix_lib.tex(,935) @end smallexample
matrix_lib.tex(,936) @c ---end content multrow---
matrix_lib.tex(,937) 
matrix_lib.tex(,938) @c ------------------- permcol -------------
matrix_lib.tex(,939) @node permcol, permrow, multrow, matrix_lib
matrix_lib.tex(,940) @subsubsection permcol
matrix_lib.tex(,941) @cindex permcol
matrix_lib.tex(,942) @c ---content permcol---
matrix_lib.tex(,943) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,944) 
matrix_lib.tex(,945) @table @asis
matrix_lib.tex(,946) @item @strong{Usage:}
matrix_lib.tex(,947) permcol(A,c1,c2); A matrix, c1,c2 positive integers
matrix_lib.tex(,948) 
matrix_lib.tex(,949) @item @strong{Return:}
matrix_lib.tex(,950) matrix, A being modified by permuting column c1 and c2
matrix_lib.tex(,951) 
matrix_lib.tex(,952) @end table
matrix_lib.tex(,953) @strong{Example:}
matrix_lib.tex(,954) @smallexample
matrix_lib.tex(,955) @c reused example permcol d2t_singular/matrix_lib.doc:737 
matrix_lib.tex(,956) LIB "matrix.lib";
matrix_lib.tex(,957) ring r=32003,(x,y,z),lp;
matrix_lib.tex(,958) matrix A[3][3]=1,x,3,4,y,6,7,z,9;
matrix_lib.tex(,959) print(A);
matrix_lib.tex(,960) @expansion{} 1,x,3,
matrix_lib.tex(,961) @expansion{} 4,y,6,
matrix_lib.tex(,962) @expansion{} 7,z,9 
matrix_lib.tex(,963) print(permcol(A,2,3));
matrix_lib.tex(,964) @expansion{} 1,3,x,
matrix_lib.tex(,965) @expansion{} 4,6,y,
matrix_lib.tex(,966) @expansion{} 7,9,z 
matrix_lib.tex(,967) @c end example permcol d2t_singular/matrix_lib.doc:737
matrix_lib.tex(,968) @end smallexample
matrix_lib.tex(,969) @c ---end content permcol---
matrix_lib.tex(,970) 
matrix_lib.tex(,971) @c ------------------- permrow -------------
matrix_lib.tex(,972) @node permrow, rowred, permcol, matrix_lib
matrix_lib.tex(,973) @subsubsection permrow
matrix_lib.tex(,974) @cindex permrow
matrix_lib.tex(,975) @c ---content permrow---
matrix_lib.tex(,976) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,977) 
matrix_lib.tex(,978) @table @asis
matrix_lib.tex(,979) @item @strong{Usage:}
matrix_lib.tex(,980) permrow(A,r1,r2); A matrix, r1,r2 positive integers
matrix_lib.tex(,981) 
matrix_lib.tex(,982) @item @strong{Return:}
matrix_lib.tex(,983) matrix, A being modified by permuting row r1 and r2
matrix_lib.tex(,984) 
matrix_lib.tex(,985) @end table
matrix_lib.tex(,986) @strong{Example:}
matrix_lib.tex(,987) @smallexample
matrix_lib.tex(,988) @c reused example permrow d2t_singular/matrix_lib.doc:764 
matrix_lib.tex(,989) LIB "matrix.lib";
matrix_lib.tex(,990) ring r=32003,(x,y,z),lp;
matrix_lib.tex(,991) matrix A[3][3]=1,2,3,x,y,z,7,8,9;
matrix_lib.tex(,992) print(A);
matrix_lib.tex(,993) @expansion{} 1,2,3,
matrix_lib.tex(,994) @expansion{} x,y,z,
matrix_lib.tex(,995) @expansion{} 7,8,9 
matrix_lib.tex(,996) print(permrow(A,2,1));
matrix_lib.tex(,997) @expansion{} x,y,z,
matrix_lib.tex(,998) @expansion{} 1,2,3,
matrix_lib.tex(,999) @expansion{} 7,8,9 
matrix_lib.tex(,1000) @c end example permrow d2t_singular/matrix_lib.doc:764
matrix_lib.tex(,1001) @end smallexample
matrix_lib.tex(,1002) @c ---end content permrow---
matrix_lib.tex(,1003) 
matrix_lib.tex(,1004) @c ------------------- rowred -------------
matrix_lib.tex(,1005) @node rowred, colred, permrow, matrix_lib
matrix_lib.tex(,1006) @subsubsection rowred
matrix_lib.tex(,1007) @cindex rowred
matrix_lib.tex(,1008) @c ---content rowred---
matrix_lib.tex(,1009) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,1010) 
matrix_lib.tex(,1011) @table @asis
matrix_lib.tex(,1012) @item @strong{Usage:}
matrix_lib.tex(,1013) rowred(A[,e]); A matrix, e any type
matrix_lib.tex(,1014) 
matrix_lib.tex(,1015) @item @strong{Return:}
matrix_lib.tex(,1016) - a matrix B, being the row reduced form of A, if rowred is called
matrix_lib.tex(,1017) with one argument.
matrix_lib.tex(,1018) @*(as far as this is possible over the polynomial ring; no division
matrix_lib.tex(,1019) by polynomials)
matrix_lib.tex(,1020) @* - a list L of two matrices, such that L[1] = L[2] * A with L[1]
matrix_lib.tex(,1021) the row-reduced form of A and L[2] the transformation matrix
matrix_lib.tex(,1022) (if rowred is called with two arguments).
matrix_lib.tex(,1023) 
matrix_lib.tex(,1024) @item @strong{Note:}
matrix_lib.tex(,1025) * This procedure is designed for teaching purposes mainly.
matrix_lib.tex(,1026) @* * The straight forward Gaussian algorithm is implemented in the
matrix_lib.tex(,1027) library (no standard basis computation).
matrix_lib.tex(,1028) @*The transformation matrix is obtained by concatenating a unit
matrix_lib.tex(,1029) matrix to A. proc gauss_row should be faster.
matrix_lib.tex(,1030) @* * It should only be used with exact coefficient field (there is no
matrix_lib.tex(,1031) pivoting) over the polynomial ring (ordering lp or dp).
matrix_lib.tex(,1032) @* * Parameters are allowed. Hence, if the entries of A are parameters
matrix_lib.tex(,1033) the computation takes place over the field of rational functions.
matrix_lib.tex(,1034) 
matrix_lib.tex(,1035) @end table
matrix_lib.tex(,1036) @strong{Example:}
matrix_lib.tex(,1037) @smallexample
matrix_lib.tex(,1038) @c reused example rowred d2t_singular/matrix_lib.doc:808 
matrix_lib.tex(,1039) LIB "matrix.lib";
matrix_lib.tex(,1040) ring r=(0,a,b),(A,B,C),dp;
matrix_lib.tex(,1041) matrix m[6][8]=
matrix_lib.tex(,1042) 0, 0,  b*B, -A,-4C,2A,0, 0,
matrix_lib.tex(,1043) 2C,-4C,-A,B, 0,  B, 3B,AB,
matrix_lib.tex(,1044) 0,a*A,  0, 0, B,  0, 0, 0,
matrix_lib.tex(,1045) 0, 0,  0, 0, 2,  0, 0, 2A,
matrix_lib.tex(,1046) 0, 0,  0, 0, 0,  0, 2b, A,
matrix_lib.tex(,1047) 0, 0,  0, 0, 0,  0, 0, 2a;"";
matrix_lib.tex(,1048) @expansion{} 
matrix_lib.tex(,1049) print(rowred(m));"";
matrix_lib.tex(,1050) @expansion{} 0,  0,    0,    0, 1,0,  0,0,
matrix_lib.tex(,1051) @expansion{} 0,  0,    0,    0, 0,0,  1,0,
matrix_lib.tex(,1052) @expansion{} 0,  0,    0,    0, 0,0,  0,1,
matrix_lib.tex(,1053) @expansion{} 0,  0,    (b)*B,-A,0,2*A,0,0,
matrix_lib.tex(,1054) @expansion{} 2*C,-4*C, -A,   B, 0,B,  0,0,
matrix_lib.tex(,1055) @expansion{} 0,  (a)*A,0,    0, 0,0,  0,0 
matrix_lib.tex(,1056) @expansion{} 
matrix_lib.tex(,1057) list L=rowred(m,1);
matrix_lib.tex(,1058) print(L[1]);
matrix_lib.tex(,1059) @expansion{} 0,  0,    0,    0, 1,0,  0,0,
matrix_lib.tex(,1060) @expansion{} 0,  0,    0,    0, 0,0,  1,0,
matrix_lib.tex(,1061) @expansion{} 0,  0,    0,    0, 0,0,  0,1,
matrix_lib.tex(,1062) @expansion{} 0,  0,    (b)*B,-A,0,2*A,0,0,
matrix_lib.tex(,1063) @expansion{} 2*C,-4*C, -A,   B, 0,B,  0,0,
matrix_lib.tex(,1064) @expansion{} 0,  (a)*A,0,    0, 0,0,  0,0 
matrix_lib.tex(,1065) print(L[2]);
matrix_lib.tex(,1066) @expansion{} 0,0,0,1/2,   0,        -1/(2a)*A,       
matrix_lib.tex(,1067) @expansion{} 0,0,0,0,     1/(2b),   -1/(4ab)*A,      
matrix_lib.tex(,1068) @expansion{} 0,0,0,0,     0,        1/(2a),          
matrix_lib.tex(,1069) @expansion{} 1,0,0,2*C,   0,        -2/(a)*AC,       
matrix_lib.tex(,1070) @expansion{} 0,1,0,0,     -3/(2b)*B,(-2b+3)/(4ab)*AB,
matrix_lib.tex(,1071) @expansion{} 0,0,1,-1/2*B,0,        1/(2a)*AB        
matrix_lib.tex(,1072) @c end example rowred d2t_singular/matrix_lib.doc:808
matrix_lib.tex(,1073) @end smallexample
matrix_lib.tex(,1074) @c inserted refs from d2t_singular/matrix_lib.doc:824
matrix_lib.tex(,1085) @c end inserted refs from d2t_singular/matrix_lib.doc:824
matrix_lib.tex(,1086) 
matrix_lib.tex(,1087) @c ---end content rowred---
matrix_lib.tex(,1088) 
matrix_lib.tex(,1089) @c ------------------- colred -------------
matrix_lib.tex(,1090) @node colred, rm_unitrow, rowred, matrix_lib
matrix_lib.tex(,1091) @subsubsection colred
matrix_lib.tex(,1092) @cindex colred
matrix_lib.tex(,1093) @c ---content colred---
matrix_lib.tex(,1094) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,1095) 
matrix_lib.tex(,1096) @table @asis
matrix_lib.tex(,1097) @item @strong{Usage:}
matrix_lib.tex(,1098) colred(A[,e]); A matrix, e any type
matrix_lib.tex(,1099) 
matrix_lib.tex(,1100) @item @strong{Return:}
matrix_lib.tex(,1101) - a matrix B, being the column reduced form of A, if colred is
matrix_lib.tex(,1102) called with one argument.
matrix_lib.tex(,1103) @*(as far as this is possible over the polynomial ring;
matrix_lib.tex(,1104) no division by polynomials)
matrix_lib.tex(,1105) @* - a list L of two matrices, such that L[1] = A * L[2] with L[1]
matrix_lib.tex(,1106) the column-reduced form of A and L[2] the transformation matrix
matrix_lib.tex(,1107) (if colred is called with two arguments).
matrix_lib.tex(,1108) 
matrix_lib.tex(,1109) @item @strong{Note:}
matrix_lib.tex(,1110) * This procedure is designed for teaching purposes mainly.
matrix_lib.tex(,1111) @* * It applies rowred to the transposed matrix.
matrix_lib.tex(,1112) proc gauss_col should be faster.
matrix_lib.tex(,1113) @* * It should only be used with exact coefficient field (there is no
matrix_lib.tex(,1114) pivoting) over the polynomial ring (ordering lp or dp).
matrix_lib.tex(,1115) @* * Parameters are allowed. Hence, if the entries of A are parameters
matrix_lib.tex(,1116) the computation takes place over the field of rational functions.
matrix_lib.tex(,1117) 
matrix_lib.tex(,1118) @end table
matrix_lib.tex(,1119) @strong{Example:}
matrix_lib.tex(,1120) @smallexample
matrix_lib.tex(,1121) @c reused example colred d2t_singular/matrix_lib.doc:862 
matrix_lib.tex(,1122) LIB "matrix.lib";
matrix_lib.tex(,1123) ring r=(0,a,b),(A,B,C),dp;
matrix_lib.tex(,1124) matrix m[8][6]=
matrix_lib.tex(,1125) 0,    2*C, 0,    0,  0,   0,
matrix_lib.tex(,1126) 0,    -4*C,a*A,  0,  0,   0,
matrix_lib.tex(,1127) b*B,  -A,  0,    0,  0,   0,
matrix_lib.tex(,1128) -A,   B,   0,    0,  0,   0,
matrix_lib.tex(,1129) -4*C, 0,   B,    2,  0,   0,
matrix_lib.tex(,1130) 2*A,  B,   0,    0,  0,   0,
matrix_lib.tex(,1131) 0,    3*B, 0,    0,  2b,  0,
matrix_lib.tex(,1132) 0,    AB,  0,    2*A,A,   2a;"";
matrix_lib.tex(,1133) @expansion{} 
matrix_lib.tex(,1134) print(colred(m));"";
matrix_lib.tex(,1135) @expansion{} 0,0,0,0,    2*C, 0,    
matrix_lib.tex(,1136) @expansion{} 0,0,0,0,    -4*C,(a)*A,
matrix_lib.tex(,1137) @expansion{} 0,0,0,(b)*B,-A,  0,    
matrix_lib.tex(,1138) @expansion{} 0,0,0,-A,   B,   0,    
matrix_lib.tex(,1139) @expansion{} 1,0,0,0,    0,   0,    
matrix_lib.tex(,1140) @expansion{} 0,0,0,2*A,  B,   0,    
matrix_lib.tex(,1141) @expansion{} 0,1,0,0,    0,   0,    
matrix_lib.tex(,1142) @expansion{} 0,0,1,0,    0,   0     
matrix_lib.tex(,1143) @expansion{} 
matrix_lib.tex(,1144) list L=colred(m,1);
matrix_lib.tex(,1145) print(L[1]);
matrix_lib.tex(,1146) @expansion{} 0,0,0,0,    2*C, 0,    
matrix_lib.tex(,1147) @expansion{} 0,0,0,0,    -4*C,(a)*A,
matrix_lib.tex(,1148) @expansion{} 0,0,0,(b)*B,-A,  0,    
matrix_lib.tex(,1149) @expansion{} 0,0,0,-A,   B,   0,    
matrix_lib.tex(,1150) @expansion{} 1,0,0,0,    0,   0,    
matrix_lib.tex(,1151) @expansion{} 0,0,0,2*A,  B,   0,    
matrix_lib.tex(,1152) @expansion{} 0,1,0,0,    0,   0,    
matrix_lib.tex(,1153) @expansion{} 0,0,1,0,    0,   0     
matrix_lib.tex(,1154) print(L[2]);
matrix_lib.tex(,1155) @expansion{} 0,        0,         0,     1,        0,               0,       
matrix_lib.tex(,1156) @expansion{} 0,        0,         0,     0,        1,               0,       
matrix_lib.tex(,1157) @expansion{} 0,        0,         0,     0,        0,               1,       
matrix_lib.tex(,1158) @expansion{} 1/2,      0,         0,     2*C,      0,               -1/2*B,  
matrix_lib.tex(,1159) @expansion{} 0,        1/(2b),    0,     0,        -3/(2b)*B,       0,       
matrix_lib.tex(,1160) @expansion{} -1/(2a)*A,-1/(4ab)*A,1/(2a),-2/(a)*AC,(-2b+3)/(4ab)*AB,1/(2a)*AB
matrix_lib.tex(,1161) @c end example colred d2t_singular/matrix_lib.doc:862
matrix_lib.tex(,1162) @end smallexample
matrix_lib.tex(,1163) @c inserted refs from d2t_singular/matrix_lib.doc:880
matrix_lib.tex(,1174) @c end inserted refs from d2t_singular/matrix_lib.doc:880
matrix_lib.tex(,1175) 
matrix_lib.tex(,1176) @c ---end content colred---
matrix_lib.tex(,1177) 
matrix_lib.tex(,1178) @c ------------------- rm_unitrow -------------
matrix_lib.tex(,1179) @node rm_unitrow, rm_unitcol, colred, matrix_lib
matrix_lib.tex(,1180) @subsubsection rm_unitrow
matrix_lib.tex(,1181) @cindex rm_unitrow
matrix_lib.tex(,1182) @c ---content rm_unitrow---
matrix_lib.tex(,1183) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,1184) 
matrix_lib.tex(,1185) @table @asis
matrix_lib.tex(,1186) @item @strong{Usage:}
matrix_lib.tex(,1187) rm_unitrow(A); A matrix (being col-reduced)
matrix_lib.tex(,1188) 
matrix_lib.tex(,1189) @item @strong{Return:}
matrix_lib.tex(,1190) matrix, obtained from A by deleting unit rows (having just one 1
matrix_lib.tex(,1191) and else 0 as entries) and associated columns
matrix_lib.tex(,1192) 
matrix_lib.tex(,1193) @end table
matrix_lib.tex(,1194) @strong{Example:}
matrix_lib.tex(,1195) @smallexample
matrix_lib.tex(,1196) @c reused example rm_unitrow d2t_singular/matrix_lib.doc:904 
matrix_lib.tex(,1197) LIB "matrix.lib";
matrix_lib.tex(,1198) ring r=0,(A,B,C),dp;
matrix_lib.tex(,1199) matrix m[8][6]=
matrix_lib.tex(,1200) 0,0,  0,   0, 2C, 0,
matrix_lib.tex(,1201) 0,0,  0,   0, -4C,A,
matrix_lib.tex(,1202) A,-C2,0,   B, -A, 0,
matrix_lib.tex(,1203) 0,0,  1/2B,-A,B,  0,
matrix_lib.tex(,1204) 1,0,  0,   0, 0,  0,
matrix_lib.tex(,1205) 0,0,  0,   2A,B,  0,
matrix_lib.tex(,1206) 0,1,  0,   0, 0,  0,
matrix_lib.tex(,1207) 0,0,  1,   0, 0,  0;
matrix_lib.tex(,1208) print(rm_unitrow(m));
matrix_lib.tex(,1209) @expansion{} 0, 2C, 0,
matrix_lib.tex(,1210) @expansion{} 0, -4C,A,
matrix_lib.tex(,1211) @expansion{} B, -A, 0,
matrix_lib.tex(,1212) @expansion{} -A,B,  0,
matrix_lib.tex(,1213) @expansion{} 2A,B,  0 
matrix_lib.tex(,1214) @c end example rm_unitrow d2t_singular/matrix_lib.doc:904
matrix_lib.tex(,1215) @end smallexample
matrix_lib.tex(,1216) @c ---end content rm_unitrow---
matrix_lib.tex(,1217) 
matrix_lib.tex(,1218) @c ------------------- rm_unitcol -------------
matrix_lib.tex(,1219) @node rm_unitcol, headStand, rm_unitrow, matrix_lib
matrix_lib.tex(,1220) @subsubsection rm_unitcol
matrix_lib.tex(,1221) @cindex rm_unitcol
matrix_lib.tex(,1222) @c ---content rm_unitcol---
matrix_lib.tex(,1223) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,1224) 
matrix_lib.tex(,1225) @table @asis
matrix_lib.tex(,1226) @item @strong{Usage:}
matrix_lib.tex(,1227) rm_unitcol(A); A matrix (being row-reduced)
matrix_lib.tex(,1228) 
matrix_lib.tex(,1229) @item @strong{Return:}
matrix_lib.tex(,1230) matrix, obtained from A by deleting unit columns (having just one 1
matrix_lib.tex(,1231) and else 0 as entries) and associated rows
matrix_lib.tex(,1232) 
matrix_lib.tex(,1233) @end table
matrix_lib.tex(,1234) @strong{Example:}
matrix_lib.tex(,1235) @smallexample
matrix_lib.tex(,1236) @c reused example rm_unitcol d2t_singular/matrix_lib.doc:939 
matrix_lib.tex(,1237) LIB "matrix.lib";
matrix_lib.tex(,1238) ring r=0,(A,B,C),dp;
matrix_lib.tex(,1239) matrix m[6][8]=
matrix_lib.tex(,1240) 0,  0,    A,   0, 1,0,  0,0,
matrix_lib.tex(,1241) 0,  0,  -C2,   0, 0,0,  1,0,
matrix_lib.tex(,1242) 0,  0,    0,1/2B, 0,0,  0,1,
matrix_lib.tex(,1243) 0,  0,    B,  -A, 0,2A, 0,0,
matrix_lib.tex(,1244) 2C,-4C,  -A,   B, 0,B,  0,0,
matrix_lib.tex(,1245) 0,  A,    0,   0, 0,0,  0,0;
matrix_lib.tex(,1246) print(rm_unitcol(m));
matrix_lib.tex(,1247) @expansion{} 0, 0,  B, -A,2A,
matrix_lib.tex(,1248) @expansion{} 2C,-4C,-A,B, B, 
matrix_lib.tex(,1249) @expansion{} 0, A,  0, 0, 0  
matrix_lib.tex(,1250) @c end example rm_unitcol d2t_singular/matrix_lib.doc:939
matrix_lib.tex(,1251) @end smallexample
matrix_lib.tex(,1252) @c ---end content rm_unitcol---
matrix_lib.tex(,1253) 
matrix_lib.tex(,1254) @c ------------------- headStand -------------
matrix_lib.tex(,1255) @node headStand,, rm_unitcol, matrix_lib
matrix_lib.tex(,1256) @subsubsection headStand
matrix_lib.tex(,1257) @cindex headStand
matrix_lib.tex(,1258) @c ---content headStand---
matrix_lib.tex(,1259) Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).
matrix_lib.tex(,1260) 
matrix_lib.tex(,1261) @table @asis
matrix_lib.tex(,1262) @end table
matrix_lib.tex(,1263) @c ---end content headStand---
singular.texi(,347) @c ---------------------------------------------------------
singular.texi(,348) @node linalg_lib, , matrix_lib, Linear algebra
singular.texi(,349) @subsection linalg_lib
singular.texi(,350) @c include of docu for linalg.lib
linalg_lib_noEx.tex(,1) @c ---content LibInfo---
linalg_lib_noEx.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/linalg_lib.doc
linalg_lib_noEx.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/linalg_lib.doc INSTEAD
linalg_lib_noEx.tex(,4) @c library version: (1.10.2.15,2003/04/04)
linalg_lib_noEx.tex(,5) @c library file: ../Singular/LIB/linalg.lib
linalg_lib_noEx.tex(,6) @cindex linalg.lib
linalg_lib_noEx.tex(,7) @cindex linalg_lib
linalg_lib_noEx.tex(,8) @table @asis
linalg_lib_noEx.tex(,9) @item @strong{Library:}
linalg_lib_noEx.tex(,10) linalg.lib
linalg_lib_noEx.tex(,11) @item @strong{Purpose:}
linalg_lib_noEx.tex(,12)   Algorithmic Linear Algebra
linalg_lib_noEx.tex(,13) @item @strong{Authors:}
linalg_lib_noEx.tex(,14) Ivor Saynisch (ivs@@math.tu-cottbus.de)
linalg_lib_noEx.tex(,15) @* Mathias Schulze (mschulze@@mathematik.uni-kl.de)
linalg_lib_noEx.tex(,16) 
linalg_lib_noEx.tex(,17) @end table
linalg_lib_noEx.tex(,18) 
linalg_lib_noEx.tex(,19) @strong{Procedures:}
linalg_lib_noEx.tex(,20) @menu
linalg_lib_noEx.tex(,21) * inverse:: matrix, the inverse of A
linalg_lib_noEx.tex(,22) * inverse_B:: list(matrix Inv,poly p),Inv*A=p*En ( using busadj(A) )
linalg_lib_noEx.tex(,23) * inverse_L:: list(matrix Inv,poly p),Inv*A=p*En ( using lift )
linalg_lib_noEx.tex(,24) * sym_gauss:: symmetric gaussian algorithm
linalg_lib_noEx.tex(,25) * orthogonalize:: Gram-Schmidt orthogonalization
linalg_lib_noEx.tex(,26) * diag_test:: test whether A can be diagonalized
linalg_lib_noEx.tex(,27) * busadj:: coefficients of Adj(E*t-A) and coefficients of det(E*t-A)
linalg_lib_noEx.tex(,28) * charpoly:: characteristic polynomial of A ( using busadj(A) )
linalg_lib_noEx.tex(,29) * adjoint:: adjoint of A ( using busadj(A) )
linalg_lib_noEx.tex(,30) * det_B:: determinant of A ( using busadj(A) )
linalg_lib_noEx.tex(,31) * gaussred:: gaussian reduction: P*A=U*S, S a row reduced form of A
linalg_lib_noEx.tex(,32) * gaussred_pivot:: gaussian reduction: P*A=U*S, uses row pivoting
linalg_lib_noEx.tex(,33) * gauss_nf:: gaussian normal form of A
linalg_lib_noEx.tex(,34) * mat_rk:: rank of constant matrix A
linalg_lib_noEx.tex(,35) * U_D_O:: P*A=U*D*O, P,D,U,O=permutation,diag,lower-,upper-triang
linalg_lib_noEx.tex(,36) * pos_def:: test symmetric matrix for positive definiteness
linalg_lib_noEx.tex(,37) * hessenberg:: Hessenberg form of M
linalg_lib_noEx.tex(,38) * evnf:: eigenvalues normal form of (e[,m])
linalg_lib_noEx.tex(,39) * eigenvals:: eigenvalues with multiplicities of M
linalg_lib_noEx.tex(,40) * minipoly:: minimal polynomial of M
linalg_lib_noEx.tex(,41) * jordan:: Jordan data of M
linalg_lib_noEx.tex(,42) * jordanbasis:: Jordan basis and weight filtration of M
linalg_lib_noEx.tex(,43) * jordanmatrix:: Jordan matrix with Jordan data (e,s,m)
linalg_lib_noEx.tex(,44) * jordannf:: Jordan normal form of M
linalg_lib_noEx.tex(,45) @end menu
linalg_lib_noEx.tex(,46) @c ---end content LibInfo---
linalg_lib_noEx.tex(,47) 
linalg_lib_noEx.tex(,48) @c ------------------- inverse -------------
linalg_lib_noEx.tex(,49) @node inverse, inverse_B,, linalg_lib
linalg_lib_noEx.tex(,50) @subsubsection inverse
linalg_lib_noEx.tex(,51) @cindex inverse
linalg_lib_noEx.tex(,52) @c ---content inverse---
linalg_lib_noEx.tex(,53) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,54) 
linalg_lib_noEx.tex(,55) @table @asis
linalg_lib_noEx.tex(,56) @item @strong{Usage:}
linalg_lib_noEx.tex(,57) inverse(A [,opt]); A a square matrix, opt integer
linalg_lib_noEx.tex(,58) 
linalg_lib_noEx.tex(,59) @item @strong{Return:}
linalg_lib_noEx.tex(,60) @format
linalg_lib_noEx.tex(,61)           a matrix:
linalg_lib_noEx.tex(,62)           - the inverse matrix of A, if A is invertible;
linalg_lib_noEx.tex(,63)           - the 1x1 0-matrix if A is not invertible (in the polynomial ring!).
linalg_lib_noEx.tex(,64)           There are the following options:
linalg_lib_noEx.tex(,65)           - opt=0 or not given: heuristically best option from below
linalg_lib_noEx.tex(,66)           - opt=1 : apply std to (transpose(E,A)), ordering (C,dp).
linalg_lib_noEx.tex(,67)           - opt=2 : apply interred (transpose(E,A)), ordering (C,dp).
linalg_lib_noEx.tex(,68)           - opt=3 : apply lift(A,E), ordering (C,dp).
linalg_lib_noEx.tex(,69) @end format
linalg_lib_noEx.tex(,70) 
linalg_lib_noEx.tex(,71) @item @strong{Note:}
linalg_lib_noEx.tex(,72) parameters and minpoly are allowed; opt=2 is only correct for
linalg_lib_noEx.tex(,73) matrices with entries in a field
linalg_lib_noEx.tex(,74) 
linalg_lib_noEx.tex(,75) @end table
linalg_lib_noEx.tex(,76) @strong{Example:}
linalg_lib_noEx.tex(,77) @smallexample
linalg_lib_noEx.tex(,78) @c skipped computation of example inverse d2t_singular/linalg_lib.doc:76 
linalg_lib_noEx.tex(,79) LIB "linalg.lib";
linalg_lib_noEx.tex(,80) ring r=0,(x,y,z),lp;
linalg_lib_noEx.tex(,81) matrix A[3][3]=
linalg_lib_noEx.tex(,82) 1,4,3,
linalg_lib_noEx.tex(,83) 1,5,7,
linalg_lib_noEx.tex(,84) 0,4,17;
linalg_lib_noEx.tex(,85) print(inverse(A));"";
linalg_lib_noEx.tex(,86) matrix B[3][3]=
linalg_lib_noEx.tex(,87) y+1,  x+y,    y,
linalg_lib_noEx.tex(,88) z,    z+1,    z,
linalg_lib_noEx.tex(,89) y+z+2,x+y+z+2,y+z+1;
linalg_lib_noEx.tex(,90) print(inverse(B));
linalg_lib_noEx.tex(,91) print(B*inverse(B));
linalg_lib_noEx.tex(,92) @end smallexample
linalg_lib_noEx.tex(,93) @c inserted refs from d2t_singular/linalg_lib.doc:92
linalg_lib_noEx.tex(,106) @c end inserted refs from d2t_singular/linalg_lib.doc:92
linalg_lib_noEx.tex(,107) 
linalg_lib_noEx.tex(,108) @c ---end content inverse---
linalg_lib_noEx.tex(,109) 
linalg_lib_noEx.tex(,110) @c ------------------- inverse_B -------------
linalg_lib_noEx.tex(,111) @node inverse_B, inverse_L, inverse, linalg_lib
linalg_lib_noEx.tex(,112) @subsubsection inverse_B
linalg_lib_noEx.tex(,113) @cindex inverse_B
linalg_lib_noEx.tex(,114) @c ---content inverse_B---
linalg_lib_noEx.tex(,115) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,116) 
linalg_lib_noEx.tex(,117) @table @asis
linalg_lib_noEx.tex(,118) @item @strong{Usage:}
linalg_lib_noEx.tex(,119) inverse_B(A); A = square matrix
linalg_lib_noEx.tex(,120) 
linalg_lib_noEx.tex(,121) @item @strong{Return:}
linalg_lib_noEx.tex(,122) list Inv with
linalg_lib_noEx.tex(,123) @*- Inv[1] = matrix I and
linalg_lib_noEx.tex(,124) @*- Inv[2] = poly p
linalg_lib_noEx.tex(,125) @*such that I*A = unitmat(n)*p;
linalg_lib_noEx.tex(,126) 
linalg_lib_noEx.tex(,127) @item @strong{Note:}
linalg_lib_noEx.tex(,128) p=1 if 1/det(A) is computable and p=det(A) if not;
linalg_lib_noEx.tex(,129) @*the computation uses busadj.
linalg_lib_noEx.tex(,130) 
linalg_lib_noEx.tex(,131) @end table
linalg_lib_noEx.tex(,132) @strong{Example:}
linalg_lib_noEx.tex(,133) @smallexample
linalg_lib_noEx.tex(,134) @c skipped computation of example inverse_B d2t_singular/linalg_lib.doc:122 
linalg_lib_noEx.tex(,135) LIB "linalg.lib";
linalg_lib_noEx.tex(,136) ring r=0,(x,y),lp;
linalg_lib_noEx.tex(,137) matrix A[3][3]=x,y,1,1,x2,y,x,6,0;
linalg_lib_noEx.tex(,138) print(A);
linalg_lib_noEx.tex(,139) list Inv=inverse_B(A);
linalg_lib_noEx.tex(,140) print(Inv[1]);
linalg_lib_noEx.tex(,141) print(Inv[2]);
linalg_lib_noEx.tex(,142) print(Inv[1]*A);
linalg_lib_noEx.tex(,143) @end smallexample
linalg_lib_noEx.tex(,144) @c inserted refs from d2t_singular/linalg_lib.doc:133
linalg_lib_noEx.tex(,157) @c end inserted refs from d2t_singular/linalg_lib.doc:133
linalg_lib_noEx.tex(,158) 
linalg_lib_noEx.tex(,159) @c ---end content inverse_B---
linalg_lib_noEx.tex(,160) 
linalg_lib_noEx.tex(,161) @c ------------------- inverse_L -------------
linalg_lib_noEx.tex(,162) @node inverse_L, sym_gauss, inverse_B, linalg_lib
linalg_lib_noEx.tex(,163) @subsubsection inverse_L
linalg_lib_noEx.tex(,164) @cindex inverse_L
linalg_lib_noEx.tex(,165) @c ---content inverse_L---
linalg_lib_noEx.tex(,166) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,167) 
linalg_lib_noEx.tex(,168) @table @asis
linalg_lib_noEx.tex(,169) @item @strong{Usage:}
linalg_lib_noEx.tex(,170) inverse_L(A); A = square matrix
linalg_lib_noEx.tex(,171) 
linalg_lib_noEx.tex(,172) @item @strong{Return:}
linalg_lib_noEx.tex(,173) list Inv representing a left inverse of A, i.e
linalg_lib_noEx.tex(,174) @*- Inv[1] = matrix I and
linalg_lib_noEx.tex(,175) @*- Inv[2] = poly p
linalg_lib_noEx.tex(,176) @*such that I*A = unitmat(n)*p;
linalg_lib_noEx.tex(,177) 
linalg_lib_noEx.tex(,178) @item @strong{Note:}
linalg_lib_noEx.tex(,179) p=1 if 1/det(A) is computable and p=det(A) if not;
linalg_lib_noEx.tex(,180) @*the computation computes first det(A) and then uses lift
linalg_lib_noEx.tex(,181) 
linalg_lib_noEx.tex(,182) @end table
linalg_lib_noEx.tex(,183) @strong{Example:}
linalg_lib_noEx.tex(,184) @smallexample
linalg_lib_noEx.tex(,185) @c skipped computation of example inverse_L d2t_singular/linalg_lib.doc:163 
linalg_lib_noEx.tex(,186) LIB "linalg.lib";
linalg_lib_noEx.tex(,187) ring r=0,(x,y),lp;
linalg_lib_noEx.tex(,188) matrix A[3][3]=x,y,1,1,x2,y,x,6,0;
linalg_lib_noEx.tex(,189) print(A);
linalg_lib_noEx.tex(,190) list Inv=inverse_L(A);
linalg_lib_noEx.tex(,191) print(Inv[1]);
linalg_lib_noEx.tex(,192) print(Inv[2]);
linalg_lib_noEx.tex(,193) print(Inv[1]*A);
linalg_lib_noEx.tex(,194) @end smallexample
linalg_lib_noEx.tex(,195) @c inserted refs from d2t_singular/linalg_lib.doc:174
linalg_lib_noEx.tex(,208) @c end inserted refs from d2t_singular/linalg_lib.doc:174
linalg_lib_noEx.tex(,209) 
linalg_lib_noEx.tex(,210) @c ---end content inverse_L---
linalg_lib_noEx.tex(,211) 
linalg_lib_noEx.tex(,212) @c ------------------- sym_gauss -------------
linalg_lib_noEx.tex(,213) @node sym_gauss, orthogonalize, inverse_L, linalg_lib
linalg_lib_noEx.tex(,214) @subsubsection sym_gauss
linalg_lib_noEx.tex(,215) @cindex sym_gauss
linalg_lib_noEx.tex(,216) @c ---content sym_gauss---
linalg_lib_noEx.tex(,217) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,218) 
linalg_lib_noEx.tex(,219) @table @asis
linalg_lib_noEx.tex(,220) @item @strong{Usage:}
linalg_lib_noEx.tex(,221) sym_gauss(A); A = symmetric matrix
linalg_lib_noEx.tex(,222) 
linalg_lib_noEx.tex(,223) @item @strong{Return:}
linalg_lib_noEx.tex(,224) matrix, diagonalisation with symmetric gauss algorithm
linalg_lib_noEx.tex(,225) 
linalg_lib_noEx.tex(,226) @end table
linalg_lib_noEx.tex(,227) @strong{Example:}
linalg_lib_noEx.tex(,228) @smallexample
linalg_lib_noEx.tex(,229) @c skipped computation of example sym_gauss d2t_singular/linalg_lib.doc:197 
linalg_lib_noEx.tex(,230) LIB "linalg.lib";
linalg_lib_noEx.tex(,231) ring r=0,(x),lp;
linalg_lib_noEx.tex(,232) matrix A[2][2]=1,4,4,15;
linalg_lib_noEx.tex(,233) print(A);
linalg_lib_noEx.tex(,234) print(sym_gauss(A));
linalg_lib_noEx.tex(,235) @end smallexample
linalg_lib_noEx.tex(,236) @c ---end content sym_gauss---
linalg_lib_noEx.tex(,237) 
linalg_lib_noEx.tex(,238) @c ------------------- orthogonalize -------------
linalg_lib_noEx.tex(,239) @node orthogonalize, diag_test, sym_gauss, linalg_lib
linalg_lib_noEx.tex(,240) @subsubsection orthogonalize
linalg_lib_noEx.tex(,241) @cindex orthogonalize
linalg_lib_noEx.tex(,242) @c ---content orthogonalize---
linalg_lib_noEx.tex(,243) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,244) 
linalg_lib_noEx.tex(,245) @table @asis
linalg_lib_noEx.tex(,246) @item @strong{Usage:}
linalg_lib_noEx.tex(,247) orthogonalize(A); A = constant matrix
linalg_lib_noEx.tex(,248) 
linalg_lib_noEx.tex(,249) @item @strong{Return:}
linalg_lib_noEx.tex(,250) matrix, orthogonal basis of the column space of A
linalg_lib_noEx.tex(,251) 
linalg_lib_noEx.tex(,252) @end table
linalg_lib_noEx.tex(,253) @strong{Example:}
linalg_lib_noEx.tex(,254) @smallexample
linalg_lib_noEx.tex(,255) @c skipped computation of example orthogonalize d2t_singular/linalg_lib.doc:224 
linalg_lib_noEx.tex(,256) LIB "linalg.lib";
linalg_lib_noEx.tex(,257) ring r=0,(x),lp;
linalg_lib_noEx.tex(,258) matrix A[4][4]=5,6,12,4,7,3,2,6,12,1,1,2,6,4,2,10;
linalg_lib_noEx.tex(,259) print(A);
linalg_lib_noEx.tex(,260) print(orthogonalize(A));
linalg_lib_noEx.tex(,261) @end smallexample
linalg_lib_noEx.tex(,262) @c ---end content orthogonalize---
linalg_lib_noEx.tex(,263) 
linalg_lib_noEx.tex(,264) @c ------------------- diag_test -------------
linalg_lib_noEx.tex(,265) @node diag_test, busadj, orthogonalize, linalg_lib
linalg_lib_noEx.tex(,266) @subsubsection diag_test
linalg_lib_noEx.tex(,267) @cindex diag_test
linalg_lib_noEx.tex(,268) @c ---content diag_test---
linalg_lib_noEx.tex(,269) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,270) 
linalg_lib_noEx.tex(,271) @table @asis
linalg_lib_noEx.tex(,272) @item @strong{Usage:}
linalg_lib_noEx.tex(,273) diag_test(A); A = const square matrix
linalg_lib_noEx.tex(,274) 
linalg_lib_noEx.tex(,275) @item @strong{Return:}
linalg_lib_noEx.tex(,276) int, 1 if A is diagonalisable, 0 if not
linalg_lib_noEx.tex(,277) @*-1 no statement is possible, since A does not split.
linalg_lib_noEx.tex(,278) 
linalg_lib_noEx.tex(,279) @item @strong{Note:}
linalg_lib_noEx.tex(,280) The test works only for split matrices, i.e if eigenvalues of A
linalg_lib_noEx.tex(,281) are in the ground field.
linalg_lib_noEx.tex(,282) @*Does not work with parameters (uses factorize,gcd).
linalg_lib_noEx.tex(,283) 
linalg_lib_noEx.tex(,284) @end table
linalg_lib_noEx.tex(,285) @strong{Example:}
linalg_lib_noEx.tex(,286) @smallexample
linalg_lib_noEx.tex(,287) @c skipped computation of example diag_test d2t_singular/linalg_lib.doc:257 
linalg_lib_noEx.tex(,288) LIB "linalg.lib";
linalg_lib_noEx.tex(,289) ring r=0,(x),dp;
linalg_lib_noEx.tex(,290) matrix A[4][4]=6,0,0,0,0,0,6,0,0,6,0,0,0,0,0,6;
linalg_lib_noEx.tex(,291) print(A);
linalg_lib_noEx.tex(,292) diag_test(A);
linalg_lib_noEx.tex(,293) @end smallexample
linalg_lib_noEx.tex(,294) @c ---end content diag_test---
linalg_lib_noEx.tex(,295) 
linalg_lib_noEx.tex(,296) @c ------------------- busadj -------------
linalg_lib_noEx.tex(,297) @node busadj, charpoly, diag_test, linalg_lib
linalg_lib_noEx.tex(,298) @subsubsection busadj
linalg_lib_noEx.tex(,299) @cindex busadj
linalg_lib_noEx.tex(,300) @c ---content busadj---
linalg_lib_noEx.tex(,301) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,302) 
linalg_lib_noEx.tex(,303) @table @asis
linalg_lib_noEx.tex(,304) @item @strong{Usage:}
linalg_lib_noEx.tex(,305) busadj(A); A = square matrix (of size nxn)
linalg_lib_noEx.tex(,306) 
linalg_lib_noEx.tex(,307) @item @strong{Return:}
linalg_lib_noEx.tex(,308) list L:
linalg_lib_noEx.tex(,309) @format
linalg_lib_noEx.tex(,310)          L[1] contains the (n+1) coefficients of the characteristic
linalg_lib_noEx.tex(,311)               polynomial X of A, i.e.
linalg_lib_noEx.tex(,312)               X = L[1][1]+..+L[1][k]*t^(k-1)+..+(L[1][n+1])*t^n
linalg_lib_noEx.tex(,313)          L[2] contains the n (nxn)-matrices Hk which are the coefficients of
linalg_lib_noEx.tex(,314)               the busadjoint bA = adjoint(E*t-A) of A, i.e.
linalg_lib_noEx.tex(,315)               bA = (Hn-1)*t^(n-1)+...+Hk*t^k+...+H0,  ( Hk=L[2][k+1] )
linalg_lib_noEx.tex(,316) @end format
linalg_lib_noEx.tex(,317) 
linalg_lib_noEx.tex(,318) @end table
linalg_lib_noEx.tex(,319) @strong{Example:}
linalg_lib_noEx.tex(,320) @smallexample
linalg_lib_noEx.tex(,321) @c skipped computation of example busadj d2t_singular/linalg_lib.doc:292 
linalg_lib_noEx.tex(,322) LIB "linalg.lib";
linalg_lib_noEx.tex(,323) ring r = 0,(t,x),lp;
linalg_lib_noEx.tex(,324) matrix A[2][2] = 1,x2,x,x2+3x;
linalg_lib_noEx.tex(,325) print(A);
linalg_lib_noEx.tex(,326) list L = busadj(A);
linalg_lib_noEx.tex(,327) poly X = L[1][1]+L[1][2]*t+L[1][3]*t2; X;
linalg_lib_noEx.tex(,328) matrix bA[2][2] = L[2][1]+L[2][2]*t;
linalg_lib_noEx.tex(,329) print(bA);               //the busadjoint of A;
linalg_lib_noEx.tex(,330) print(bA*(t*unitmat(2)-A));
linalg_lib_noEx.tex(,331) @end smallexample
linalg_lib_noEx.tex(,332) @c ---end content busadj---
linalg_lib_noEx.tex(,333) 
linalg_lib_noEx.tex(,334) @c ------------------- charpoly -------------
linalg_lib_noEx.tex(,335) @node charpoly, adjoint, busadj, linalg_lib
linalg_lib_noEx.tex(,336) @subsubsection charpoly
linalg_lib_noEx.tex(,337) @cindex charpoly
linalg_lib_noEx.tex(,338) @c ---content charpoly---
linalg_lib_noEx.tex(,339) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,340) 
linalg_lib_noEx.tex(,341) @table @asis
linalg_lib_noEx.tex(,342) @item @strong{Usage:}
linalg_lib_noEx.tex(,343) charpoly(A[,v]); A square matrix, v string, name of a variable
linalg_lib_noEx.tex(,344) 
linalg_lib_noEx.tex(,345) @item @strong{Return:}
linalg_lib_noEx.tex(,346) poly, the characteristic polynomial det(E*v-A)
linalg_lib_noEx.tex(,347) @*(default: v=name of last variable)
linalg_lib_noEx.tex(,348) 
linalg_lib_noEx.tex(,349) @item @strong{Note:}
linalg_lib_noEx.tex(,350) A must be independent of the variable v. The computation uses det.
linalg_lib_noEx.tex(,351) If printlevel>0, det(E*v-A) is diplayed recursively.
linalg_lib_noEx.tex(,352) 
linalg_lib_noEx.tex(,353) @end table
linalg_lib_noEx.tex(,354) @strong{Example:}
linalg_lib_noEx.tex(,355) @smallexample
linalg_lib_noEx.tex(,356) @c skipped computation of example charpoly d2t_singular/linalg_lib.doc:328 
linalg_lib_noEx.tex(,357) LIB "linalg.lib";
linalg_lib_noEx.tex(,358) ring r=0,(x,t),dp;
linalg_lib_noEx.tex(,359) matrix A[3][3]=1,x2,x,x2,6,4,x,4,1;
linalg_lib_noEx.tex(,360) print(A);
linalg_lib_noEx.tex(,361) charpoly(A,"t");
linalg_lib_noEx.tex(,362) @end smallexample
linalg_lib_noEx.tex(,363) @c ---end content charpoly---
linalg_lib_noEx.tex(,364) 
linalg_lib_noEx.tex(,365) @c ------------------- adjoint -------------
linalg_lib_noEx.tex(,366) @node adjoint, det_B, charpoly, linalg_lib
linalg_lib_noEx.tex(,367) @subsubsection adjoint
linalg_lib_noEx.tex(,368) @cindex adjoint
linalg_lib_noEx.tex(,369) @c ---content adjoint---
linalg_lib_noEx.tex(,370) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,371) 
linalg_lib_noEx.tex(,372) @table @asis
linalg_lib_noEx.tex(,373) @item @strong{Usage:}
linalg_lib_noEx.tex(,374) adjoint(A); A = square matrix
linalg_lib_noEx.tex(,375) 
linalg_lib_noEx.tex(,376) @item @strong{Return:}
linalg_lib_noEx.tex(,377) adjoint matrix of A, i.e. Adj*A=det(A)*E
linalg_lib_noEx.tex(,378) 
linalg_lib_noEx.tex(,379) @item @strong{Note:}
linalg_lib_noEx.tex(,380) computation uses busadj(A)
linalg_lib_noEx.tex(,381) 
linalg_lib_noEx.tex(,382) @end table
linalg_lib_noEx.tex(,383) @strong{Example:}
linalg_lib_noEx.tex(,384) @smallexample
linalg_lib_noEx.tex(,385) @c skipped computation of example adjoint d2t_singular/linalg_lib.doc:358 
linalg_lib_noEx.tex(,386) LIB "linalg.lib";
linalg_lib_noEx.tex(,387) ring r=0,(t,x),lp;
linalg_lib_noEx.tex(,388) matrix A[2][2]=1,x2,x,x2+3x;
linalg_lib_noEx.tex(,389) print(A);
linalg_lib_noEx.tex(,390) matrix Adj[2][2]=adjoint(A);
linalg_lib_noEx.tex(,391) print(Adj);                    //Adj*A=det(A)*E
linalg_lib_noEx.tex(,392) print(Adj*A);
linalg_lib_noEx.tex(,393) @end smallexample
linalg_lib_noEx.tex(,394) @c ---end content adjoint---
linalg_lib_noEx.tex(,395) 
linalg_lib_noEx.tex(,396) @c ------------------- det_B -------------
linalg_lib_noEx.tex(,397) @node det_B, gaussred, adjoint, linalg_lib
linalg_lib_noEx.tex(,398) @subsubsection det_B
linalg_lib_noEx.tex(,399) @cindex det_B
linalg_lib_noEx.tex(,400) @c ---content det_B---
linalg_lib_noEx.tex(,401) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,402) 
linalg_lib_noEx.tex(,403) @table @asis
linalg_lib_noEx.tex(,404) @item @strong{Usage:}
linalg_lib_noEx.tex(,405) det_B(A); A any matrix
linalg_lib_noEx.tex(,406) 
linalg_lib_noEx.tex(,407) @item @strong{Return:}
linalg_lib_noEx.tex(,408) returns the determinant of A
linalg_lib_noEx.tex(,409) 
linalg_lib_noEx.tex(,410) @item @strong{Note:}
linalg_lib_noEx.tex(,411) the computation uses the busadj algorithm
linalg_lib_noEx.tex(,412) 
linalg_lib_noEx.tex(,413) @end table
linalg_lib_noEx.tex(,414) @strong{Example:}
linalg_lib_noEx.tex(,415) @smallexample
linalg_lib_noEx.tex(,416) @c skipped computation of example det_B d2t_singular/linalg_lib.doc:390 
linalg_lib_noEx.tex(,417) LIB "linalg.lib";
linalg_lib_noEx.tex(,418) ring r=0,(x),dp;
linalg_lib_noEx.tex(,419) matrix A[10][10]=random(2,10,10)+unitmat(10)*x;
linalg_lib_noEx.tex(,420) print(A);
linalg_lib_noEx.tex(,421) det_B(A);
linalg_lib_noEx.tex(,422) @end smallexample
linalg_lib_noEx.tex(,423) @c ---end content det_B---
linalg_lib_noEx.tex(,424) 
linalg_lib_noEx.tex(,425) @c ------------------- gaussred -------------
linalg_lib_noEx.tex(,426) @node gaussred, gaussred_pivot, det_B, linalg_lib
linalg_lib_noEx.tex(,427) @subsubsection gaussred
linalg_lib_noEx.tex(,428) @cindex gaussred
linalg_lib_noEx.tex(,429) @c ---content gaussred---
linalg_lib_noEx.tex(,430) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,431) 
linalg_lib_noEx.tex(,432) @table @asis
linalg_lib_noEx.tex(,433) @item @strong{Usage:}
linalg_lib_noEx.tex(,434) gaussred(A); A any constant matrix
linalg_lib_noEx.tex(,435) 
linalg_lib_noEx.tex(,436) @item @strong{Return:}
linalg_lib_noEx.tex(,437) list Z: Z[1]=P , Z[2]=U , Z[3]=S , Z[4]=rank(A)
linalg_lib_noEx.tex(,438) @*gives a row reduced matrix S, a permutation matrix P and a
linalg_lib_noEx.tex(,439) normalized lower triangular matrix U, with P*A=U*S
linalg_lib_noEx.tex(,440) 
linalg_lib_noEx.tex(,441) @item @strong{Note:}
linalg_lib_noEx.tex(,442) This procedure is designed for teaching purposes mainly.
linalg_lib_noEx.tex(,443) The straight forward implementation in the interpreted library
linalg_lib_noEx.tex(,444) is not very efficient (no standard basis computation).
linalg_lib_noEx.tex(,445) 
linalg_lib_noEx.tex(,446) @end table
linalg_lib_noEx.tex(,447) @strong{Example:}
linalg_lib_noEx.tex(,448) @smallexample
linalg_lib_noEx.tex(,449) @c skipped computation of example gaussred d2t_singular/linalg_lib.doc:424 
linalg_lib_noEx.tex(,450) LIB "linalg.lib";
linalg_lib_noEx.tex(,451) ring r=0,(x),dp;
linalg_lib_noEx.tex(,452) matrix A[5][4]=1,3,-1,4,2,5,-1,3,1,3,-1,4,0,4,-3,1,-3,1,-5,-2;
linalg_lib_noEx.tex(,453) print(A);
linalg_lib_noEx.tex(,454) list Z=gaussred(A);   //construct P,U,S s.t. P*A=U*S
linalg_lib_noEx.tex(,455) print(Z[1]);          //P
linalg_lib_noEx.tex(,456) print(Z[2]);          //U
linalg_lib_noEx.tex(,457) print(Z[3]);          //S
linalg_lib_noEx.tex(,458) print(Z[4]);          //rank
linalg_lib_noEx.tex(,459) print(Z[1]*A);        //P*A
linalg_lib_noEx.tex(,460) print(Z[2]*Z[3]);     //U*S
linalg_lib_noEx.tex(,461) @end smallexample
linalg_lib_noEx.tex(,462) @c ---end content gaussred---
linalg_lib_noEx.tex(,463) 
linalg_lib_noEx.tex(,464) @c ------------------- gaussred_pivot -------------
linalg_lib_noEx.tex(,465) @node gaussred_pivot, gauss_nf, gaussred, linalg_lib
linalg_lib_noEx.tex(,466) @subsubsection gaussred_pivot
linalg_lib_noEx.tex(,467) @cindex gaussred_pivot
linalg_lib_noEx.tex(,468) @c ---content gaussred_pivot---
linalg_lib_noEx.tex(,469) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,470) 
linalg_lib_noEx.tex(,471) @table @asis
linalg_lib_noEx.tex(,472) @item @strong{Usage:}
linalg_lib_noEx.tex(,473) gaussred_pivot(A); A any constant matrix
linalg_lib_noEx.tex(,474) 
linalg_lib_noEx.tex(,475) @item @strong{Return:}
linalg_lib_noEx.tex(,476) list Z: Z[1]=P , Z[2]=U , Z[3]=S , Z[4]=rank(A)
linalg_lib_noEx.tex(,477) @*gives n row reduced matrix S, a permutation matrix P and a
linalg_lib_noEx.tex(,478) normalized lower triangular matrix U, with P*A=U*S
linalg_lib_noEx.tex(,479) 
linalg_lib_noEx.tex(,480) @item @strong{Note:}
linalg_lib_noEx.tex(,481) with row pivoting
linalg_lib_noEx.tex(,482) 
linalg_lib_noEx.tex(,483) @end table
linalg_lib_noEx.tex(,484) @strong{Example:}
linalg_lib_noEx.tex(,485) @smallexample
linalg_lib_noEx.tex(,486) @c skipped computation of example gaussred_pivot d2t_singular/linalg_lib.doc:462 
linalg_lib_noEx.tex(,487) LIB "linalg.lib";
linalg_lib_noEx.tex(,488) ring r=0,(x),dp;
linalg_lib_noEx.tex(,489) matrix A[5][4] = 1, 3,-1,4,
linalg_lib_noEx.tex(,490) 2, 5,-1,3,
linalg_lib_noEx.tex(,491) 1, 3,-1,4,
linalg_lib_noEx.tex(,492) 0, 4,-3,1,
linalg_lib_noEx.tex(,493) -3,1,-5,-2;
linalg_lib_noEx.tex(,494) list Z=gaussred_pivot(A);  //construct P,U,S s.t. P*A=U*S
linalg_lib_noEx.tex(,495) print(Z[1]);               //P
linalg_lib_noEx.tex(,496) print(Z[2]);               //U
linalg_lib_noEx.tex(,497) print(Z[3]);               //S
linalg_lib_noEx.tex(,498) print(Z[4]);               //rank
linalg_lib_noEx.tex(,499) print(Z[1]*A);             //P*A
linalg_lib_noEx.tex(,500) print(Z[2]*Z[3]);          //U*S
linalg_lib_noEx.tex(,501) @end smallexample
linalg_lib_noEx.tex(,502) @c ---end content gaussred_pivot---
linalg_lib_noEx.tex(,503) 
linalg_lib_noEx.tex(,504) @c ------------------- gauss_nf -------------
linalg_lib_noEx.tex(,505) @node gauss_nf, mat_rk, gaussred_pivot, linalg_lib
linalg_lib_noEx.tex(,506) @subsubsection gauss_nf
linalg_lib_noEx.tex(,507) @cindex gauss_nf
linalg_lib_noEx.tex(,508) @c ---content gauss_nf---
linalg_lib_noEx.tex(,509) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,510) 
linalg_lib_noEx.tex(,511) @table @asis
linalg_lib_noEx.tex(,512) @item @strong{Usage:}
linalg_lib_noEx.tex(,513) gauss_nf(A); A any constant matrix
linalg_lib_noEx.tex(,514) 
linalg_lib_noEx.tex(,515) @item @strong{Return:}
linalg_lib_noEx.tex(,516) matrix; gauss normal form of A (uses gaussred)
linalg_lib_noEx.tex(,517) 
linalg_lib_noEx.tex(,518) @end table
linalg_lib_noEx.tex(,519) @strong{Example:}
linalg_lib_noEx.tex(,520) @smallexample
linalg_lib_noEx.tex(,521) @c skipped computation of example gauss_nf d2t_singular/linalg_lib.doc:498 
linalg_lib_noEx.tex(,522) LIB "linalg.lib";
linalg_lib_noEx.tex(,523) ring r = 0,(x),dp;
linalg_lib_noEx.tex(,524) matrix A[4][4] = 1,4,4,7,2,5,5,4,4,1,1,3,0,2,2,7;
linalg_lib_noEx.tex(,525) print(gauss_nf(A));
linalg_lib_noEx.tex(,526) @end smallexample
linalg_lib_noEx.tex(,527) @c ---end content gauss_nf---
linalg_lib_noEx.tex(,528) 
linalg_lib_noEx.tex(,529) @c ------------------- mat_rk -------------
linalg_lib_noEx.tex(,530) @node mat_rk, U_D_O, gauss_nf, linalg_lib
linalg_lib_noEx.tex(,531) @subsubsection mat_rk
linalg_lib_noEx.tex(,532) @cindex mat_rk
linalg_lib_noEx.tex(,533) @c ---content mat_rk---
linalg_lib_noEx.tex(,534) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,535) 
linalg_lib_noEx.tex(,536) @table @asis
linalg_lib_noEx.tex(,537) @item @strong{Usage:}
linalg_lib_noEx.tex(,538) mat_rk(A); A any constant matrix
linalg_lib_noEx.tex(,539) 
linalg_lib_noEx.tex(,540) @item @strong{Return:}
linalg_lib_noEx.tex(,541) int, rank of A
linalg_lib_noEx.tex(,542) 
linalg_lib_noEx.tex(,543) @end table
linalg_lib_noEx.tex(,544) @strong{Example:}
linalg_lib_noEx.tex(,545) @smallexample
linalg_lib_noEx.tex(,546) @c skipped computation of example mat_rk d2t_singular/linalg_lib.doc:524 
linalg_lib_noEx.tex(,547) LIB "linalg.lib";
linalg_lib_noEx.tex(,548) ring r = 0,(x),dp;
linalg_lib_noEx.tex(,549) matrix A[4][4] = 1,4,4,7,2,5,5,4,4,1,1,3,0,2,2,7;
linalg_lib_noEx.tex(,550) mat_rk(A);
linalg_lib_noEx.tex(,551) @end smallexample
linalg_lib_noEx.tex(,552) @c ---end content mat_rk---
linalg_lib_noEx.tex(,553) 
linalg_lib_noEx.tex(,554) @c ------------------- U_D_O -------------
linalg_lib_noEx.tex(,555) @node U_D_O, pos_def, mat_rk, linalg_lib
linalg_lib_noEx.tex(,556) @subsubsection U_D_O
linalg_lib_noEx.tex(,557) @cindex U_D_O
linalg_lib_noEx.tex(,558) @c ---content U_D_O---
linalg_lib_noEx.tex(,559) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,560) 
linalg_lib_noEx.tex(,561) @table @asis
linalg_lib_noEx.tex(,562) @item @strong{Usage:}
linalg_lib_noEx.tex(,563) U_D_O(A); constant invertible matrix A
linalg_lib_noEx.tex(,564) 
linalg_lib_noEx.tex(,565) @item @strong{Return:}
linalg_lib_noEx.tex(,566) list Z: Z[1]=P , Z[2]=U , Z[3]=D , Z[4]=O
linalg_lib_noEx.tex(,567) @*gives a permutation matrix P,
linalg_lib_noEx.tex(,568) @*a normalized lower triangular matrix U ,
linalg_lib_noEx.tex(,569) @*a diagonal matrix D, and
linalg_lib_noEx.tex(,570) @*a normalized upper triangular matrix O
linalg_lib_noEx.tex(,571) @*with P*A=U*D*O
linalg_lib_noEx.tex(,572) 
linalg_lib_noEx.tex(,573) @item @strong{Note:}
linalg_lib_noEx.tex(,574) Z[1]=-1 means that A is not regular (proc uses gaussred)
linalg_lib_noEx.tex(,575) 
linalg_lib_noEx.tex(,576) @end table
linalg_lib_noEx.tex(,577) @strong{Example:}
linalg_lib_noEx.tex(,578) @smallexample
linalg_lib_noEx.tex(,579) @c skipped computation of example U_D_O d2t_singular/linalg_lib.doc:558 
linalg_lib_noEx.tex(,580) LIB "linalg.lib";
linalg_lib_noEx.tex(,581) ring r = 0,(x),dp;
linalg_lib_noEx.tex(,582) matrix A[5][5] = 10, 4,  0, -9,  8,
linalg_lib_noEx.tex(,583) -3, 6, -6, -4,  9,
linalg_lib_noEx.tex(,584) 0, 3, -1, -9, -8,
linalg_lib_noEx.tex(,585) -4,-2, -6, -10,10,
linalg_lib_noEx.tex(,586) -9, 5, -1, -6,  5;
linalg_lib_noEx.tex(,587) list Z = U_D_O(A);              //construct P,U,D,O s.t. P*A=U*D*O
linalg_lib_noEx.tex(,588) print(Z[1]);                    //P
linalg_lib_noEx.tex(,589) print(Z[2]);                    //U
linalg_lib_noEx.tex(,590) print(Z[3]);                    //D
linalg_lib_noEx.tex(,591) print(Z[4]);                    //O
linalg_lib_noEx.tex(,592) print(Z[1]*A);                  //P*A
linalg_lib_noEx.tex(,593) print(Z[2]*Z[3]*Z[4]);          //U*D*O
linalg_lib_noEx.tex(,594) @end smallexample
linalg_lib_noEx.tex(,595) @c ---end content U_D_O---
linalg_lib_noEx.tex(,596) 
linalg_lib_noEx.tex(,597) @c ------------------- pos_def -------------
linalg_lib_noEx.tex(,598) @node pos_def, hessenberg, U_D_O, linalg_lib
linalg_lib_noEx.tex(,599) @subsubsection pos_def
linalg_lib_noEx.tex(,600) @cindex pos_def
linalg_lib_noEx.tex(,601) @c ---content pos_def---
linalg_lib_noEx.tex(,602) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,603) 
linalg_lib_noEx.tex(,604) @table @asis
linalg_lib_noEx.tex(,605) @item @strong{Usage:}
linalg_lib_noEx.tex(,606) pos_def(A); A = constant, symmetric square matrix
linalg_lib_noEx.tex(,607) 
linalg_lib_noEx.tex(,608) @item @strong{Return:}
linalg_lib_noEx.tex(,609) int:
linalg_lib_noEx.tex(,610) @*1 if A is positive definit ,
linalg_lib_noEx.tex(,611) @*0 if not,
linalg_lib_noEx.tex(,612) @*-1 if unknown
linalg_lib_noEx.tex(,613) 
linalg_lib_noEx.tex(,614) @end table
linalg_lib_noEx.tex(,615) @strong{Example:}
linalg_lib_noEx.tex(,616) @smallexample
linalg_lib_noEx.tex(,617) @c skipped computation of example pos_def d2t_singular/linalg_lib.doc:597 
linalg_lib_noEx.tex(,618) LIB "linalg.lib";
linalg_lib_noEx.tex(,619) ring r = 0,(x),dp;
linalg_lib_noEx.tex(,620) matrix A[5][5] = 20,  4,  0, -9,   8,
linalg_lib_noEx.tex(,621) 4, 12, -6, -4,   9,
linalg_lib_noEx.tex(,622) 0, -6, -2, -9,  -8,
linalg_lib_noEx.tex(,623) -9, -4, -9, -20, 10,
linalg_lib_noEx.tex(,624) 8,  9, -8,  10, 10;
linalg_lib_noEx.tex(,625) pos_def(A);
linalg_lib_noEx.tex(,626) matrix B[3][3] =  3,  2,  0,
linalg_lib_noEx.tex(,627) 2, 12,  4,
linalg_lib_noEx.tex(,628) 0,  4,  2;
linalg_lib_noEx.tex(,629) pos_def(B);
linalg_lib_noEx.tex(,630) @end smallexample
linalg_lib_noEx.tex(,631) @c ---end content pos_def---
linalg_lib_noEx.tex(,632) 
linalg_lib_noEx.tex(,633) @c ------------------- hessenberg -------------
linalg_lib_noEx.tex(,634) @node hessenberg, evnf, pos_def, linalg_lib
linalg_lib_noEx.tex(,635) @subsubsection hessenberg
linalg_lib_noEx.tex(,636) @cindex hessenberg
linalg_lib_noEx.tex(,637) @c ---content hessenberg---
linalg_lib_noEx.tex(,638) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,639) 
linalg_lib_noEx.tex(,640) @table @asis
linalg_lib_noEx.tex(,641) @item @strong{Usage:}
linalg_lib_noEx.tex(,642) hessenberg(M); matrix M
linalg_lib_noEx.tex(,643) 
linalg_lib_noEx.tex(,644) @item @strong{Assume:}
linalg_lib_noEx.tex(,645) M constant square matrix
linalg_lib_noEx.tex(,646) 
linalg_lib_noEx.tex(,647) @item @strong{Return:}
linalg_lib_noEx.tex(,648) matrix H; Hessenberg form of M
linalg_lib_noEx.tex(,649) 
linalg_lib_noEx.tex(,650) @end table
linalg_lib_noEx.tex(,651) @strong{Example:}
linalg_lib_noEx.tex(,652) @smallexample
linalg_lib_noEx.tex(,653) @c skipped computation of example hessenberg d2t_singular/linalg_lib.doc:634 
linalg_lib_noEx.tex(,654) LIB "linalg.lib";
linalg_lib_noEx.tex(,655) ring R=0,x,dp;
linalg_lib_noEx.tex(,656) matrix M[3][3]=3,2,1,0,2,1,0,0,3;
linalg_lib_noEx.tex(,657) print(M);
linalg_lib_noEx.tex(,658) print(hessenberg(M));
linalg_lib_noEx.tex(,659) @end smallexample
linalg_lib_noEx.tex(,660) @c ---end content hessenberg---
linalg_lib_noEx.tex(,661) 
linalg_lib_noEx.tex(,662) @c ------------------- evnf -------------
linalg_lib_noEx.tex(,663) @node evnf, eigenvals, hessenberg, linalg_lib
linalg_lib_noEx.tex(,664) @subsubsection evnf
linalg_lib_noEx.tex(,665) @cindex evnf
linalg_lib_noEx.tex(,666) @c ---content evnf---
linalg_lib_noEx.tex(,667) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,668) 
linalg_lib_noEx.tex(,669) @table @asis
linalg_lib_noEx.tex(,670) @item @strong{Usage:}
linalg_lib_noEx.tex(,671) evnf(e[,m]); ideal e, intvec m
linalg_lib_noEx.tex(,672) 
linalg_lib_noEx.tex(,673) @item @strong{Assume:}
linalg_lib_noEx.tex(,674) ncols(e)==size(m)
linalg_lib_noEx.tex(,675) 
linalg_lib_noEx.tex(,676) @item @strong{Return:}
linalg_lib_noEx.tex(,677) order eigenvalues e with multiplicities m
linalg_lib_noEx.tex(,678) 
linalg_lib_noEx.tex(,679) @end table
linalg_lib_noEx.tex(,680) @c ---end content evnf---
linalg_lib_noEx.tex(,681) 
linalg_lib_noEx.tex(,682) @c ------------------- eigenvals -------------
linalg_lib_noEx.tex(,683) @node eigenvals, minipoly, evnf, linalg_lib
linalg_lib_noEx.tex(,684) @subsubsection eigenvals
linalg_lib_noEx.tex(,685) @cindex eigenvals
linalg_lib_noEx.tex(,686) @c ---content eigenvals---
linalg_lib_noEx.tex(,687) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,688) 
linalg_lib_noEx.tex(,689) @table @asis
linalg_lib_noEx.tex(,690) @item @strong{Usage:}
linalg_lib_noEx.tex(,691) eigenvals(M); matrix M
linalg_lib_noEx.tex(,692) 
linalg_lib_noEx.tex(,693) @item @strong{Assume:}
linalg_lib_noEx.tex(,694) eigenvalues of M in basefield
linalg_lib_noEx.tex(,695) 
linalg_lib_noEx.tex(,696) @item @strong{Return:}
linalg_lib_noEx.tex(,697) @format
linalg_lib_noEx.tex(,698) list l; 
linalg_lib_noEx.tex(,699)   ideal l[1];
linalg_lib_noEx.tex(,700)     number l[1][i];  i-th eigenvalue of M
linalg_lib_noEx.tex(,701)   intvec l[2]; 
linalg_lib_noEx.tex(,702)     int l[2][i];  multiplicity of i-th eigenvalue of M
linalg_lib_noEx.tex(,703) @end format
linalg_lib_noEx.tex(,704) 
linalg_lib_noEx.tex(,705) @end table
linalg_lib_noEx.tex(,706) @strong{Example:}
linalg_lib_noEx.tex(,707) @smallexample
linalg_lib_noEx.tex(,708) @c skipped computation of example eigenvals d2t_singular/linalg_lib.doc:690 
linalg_lib_noEx.tex(,709) LIB "linalg.lib";
linalg_lib_noEx.tex(,710) ring R=0,x,dp;
linalg_lib_noEx.tex(,711) matrix M[3][3]=3,2,1,0,2,1,0,0,3;
linalg_lib_noEx.tex(,712) print(M);
linalg_lib_noEx.tex(,713) eigenvals(M);
linalg_lib_noEx.tex(,714) @end smallexample
linalg_lib_noEx.tex(,715) @c ---end content eigenvals---
linalg_lib_noEx.tex(,716) 
linalg_lib_noEx.tex(,717) @c ------------------- minipoly -------------
linalg_lib_noEx.tex(,718) @node minipoly, jordan, eigenvals, linalg_lib
linalg_lib_noEx.tex(,719) @subsubsection minipoly
linalg_lib_noEx.tex(,720) @cindex minipoly
linalg_lib_noEx.tex(,721) @c ---content minipoly---
linalg_lib_noEx.tex(,722) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,723) 
linalg_lib_noEx.tex(,724) @table @asis
linalg_lib_noEx.tex(,725) @item @strong{Usage:}
linalg_lib_noEx.tex(,726) minpoly(M); matrix M
linalg_lib_noEx.tex(,727) 
linalg_lib_noEx.tex(,728) @item @strong{Assume:}
linalg_lib_noEx.tex(,729) eigenvalues of M in basefield
linalg_lib_noEx.tex(,730) 
linalg_lib_noEx.tex(,731) @item @strong{Return:}
linalg_lib_noEx.tex(,732) @format
linalg_lib_noEx.tex(,733) list l;  minimal polynomial of M
linalg_lib_noEx.tex(,734)   ideal l[1]; 
linalg_lib_noEx.tex(,735)     number l[1][i];  i-th root of minimal polynomial of M
linalg_lib_noEx.tex(,736)   intvec l[2]; 
linalg_lib_noEx.tex(,737)     int l[2][i];  multiplicity of i-th root of minimal polynomial of M
linalg_lib_noEx.tex(,738) @end format
linalg_lib_noEx.tex(,739) 
linalg_lib_noEx.tex(,740) @end table
linalg_lib_noEx.tex(,741) @strong{Example:}
linalg_lib_noEx.tex(,742) @smallexample
linalg_lib_noEx.tex(,743) @c skipped computation of example minipoly d2t_singular/linalg_lib.doc:726 
linalg_lib_noEx.tex(,744) LIB "linalg.lib";
linalg_lib_noEx.tex(,745) ring R=0,x,dp;
linalg_lib_noEx.tex(,746) matrix M[3][3]=3,2,1,0,2,1,0,0,3;
linalg_lib_noEx.tex(,747) print(M);
linalg_lib_noEx.tex(,748) minipoly(M);
linalg_lib_noEx.tex(,749) @end smallexample
linalg_lib_noEx.tex(,750) @c ---end content minipoly---
linalg_lib_noEx.tex(,751) 
linalg_lib_noEx.tex(,752) @c ------------------- jordan -------------
linalg_lib_noEx.tex(,753) @node jordan, jordanbasis, minipoly, linalg_lib
linalg_lib_noEx.tex(,754) @subsubsection jordan
linalg_lib_noEx.tex(,755) @cindex jordan
linalg_lib_noEx.tex(,756) @c ---content jordan---
linalg_lib_noEx.tex(,757) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,758) 
linalg_lib_noEx.tex(,759) @table @asis
linalg_lib_noEx.tex(,760) @item @strong{Usage:}
linalg_lib_noEx.tex(,761) jordan(M); matrix M
linalg_lib_noEx.tex(,762) 
linalg_lib_noEx.tex(,763) @item @strong{Assume:}
linalg_lib_noEx.tex(,764) eigenvalues of M in basefield
linalg_lib_noEx.tex(,765) 
linalg_lib_noEx.tex(,766) @item @strong{Return:}
linalg_lib_noEx.tex(,767) @format
linalg_lib_noEx.tex(,768) list l;  Jordan data of M
linalg_lib_noEx.tex(,769)   ideal l[1]; 
linalg_lib_noEx.tex(,770)     number l[1][i];  eigenvalue of i-th Jordan block of M
linalg_lib_noEx.tex(,771)   intvec l[2]; 
linalg_lib_noEx.tex(,772)     int l[2][i];  size of i-th Jordan block of M
linalg_lib_noEx.tex(,773)   intvec l[3]; 
linalg_lib_noEx.tex(,774)     int l[3][i];  multiplicity of i-th Jordan block of M
linalg_lib_noEx.tex(,775) @end format
linalg_lib_noEx.tex(,776) 
linalg_lib_noEx.tex(,777) @end table
linalg_lib_noEx.tex(,778) @strong{Example:}
linalg_lib_noEx.tex(,779) @smallexample
linalg_lib_noEx.tex(,780) @c skipped computation of example jordan d2t_singular/linalg_lib.doc:764 
linalg_lib_noEx.tex(,781) LIB "linalg.lib";
linalg_lib_noEx.tex(,782) ring R=0,x,dp;
linalg_lib_noEx.tex(,783) matrix M[3][3]=3,2,1,0,2,1,0,0,3;
linalg_lib_noEx.tex(,784) print(M);
linalg_lib_noEx.tex(,785) jordan(M);
linalg_lib_noEx.tex(,786) @end smallexample
linalg_lib_noEx.tex(,787) @c ---end content jordan---
linalg_lib_noEx.tex(,788) 
linalg_lib_noEx.tex(,789) @c ------------------- jordanbasis -------------
linalg_lib_noEx.tex(,790) @node jordanbasis, jordanmatrix, jordan, linalg_lib
linalg_lib_noEx.tex(,791) @subsubsection jordanbasis
linalg_lib_noEx.tex(,792) @cindex jordanbasis
linalg_lib_noEx.tex(,793) @c ---content jordanbasis---
linalg_lib_noEx.tex(,794) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,795) 
linalg_lib_noEx.tex(,796) @table @asis
linalg_lib_noEx.tex(,797) @item @strong{Usage:}
linalg_lib_noEx.tex(,798) jordanbasis(M); matrix M
linalg_lib_noEx.tex(,799) 
linalg_lib_noEx.tex(,800) @item @strong{Assume:}
linalg_lib_noEx.tex(,801) eigenvalues of M in basefield
linalg_lib_noEx.tex(,802) 
linalg_lib_noEx.tex(,803) @item @strong{Return:}
linalg_lib_noEx.tex(,804) @format
linalg_lib_noEx.tex(,805) list l:
linalg_lib_noEx.tex(,806)   module l[1];  inverse(l[1])*M*l[1] in Jordan normal form
linalg_lib_noEx.tex(,807)   intvec l[2]; 
linalg_lib_noEx.tex(,808)     int l[2][i];  weight filtration index of l[1][i]
linalg_lib_noEx.tex(,809) @end format
linalg_lib_noEx.tex(,810) 
linalg_lib_noEx.tex(,811) @end table
linalg_lib_noEx.tex(,812) @strong{Example:}
linalg_lib_noEx.tex(,813) @smallexample
linalg_lib_noEx.tex(,814) @c skipped computation of example jordanbasis d2t_singular/linalg_lib.doc:799 
linalg_lib_noEx.tex(,815) LIB "linalg.lib";
linalg_lib_noEx.tex(,816) ring R=0,x,dp;
linalg_lib_noEx.tex(,817) matrix M[3][3]=3,2,1,0,2,1,0,0,3;
linalg_lib_noEx.tex(,818) print(M);
linalg_lib_noEx.tex(,819) list l=jordanbasis(M);
linalg_lib_noEx.tex(,820) print(l[1]);
linalg_lib_noEx.tex(,821) print(l[2]);
linalg_lib_noEx.tex(,822) print(inverse(l[1])*M*l[1]);
linalg_lib_noEx.tex(,823) @end smallexample
linalg_lib_noEx.tex(,824) @c ---end content jordanbasis---
linalg_lib_noEx.tex(,825) 
linalg_lib_noEx.tex(,826) @c ------------------- jordanmatrix -------------
linalg_lib_noEx.tex(,827) @node jordanmatrix, jordannf, jordanbasis, linalg_lib
linalg_lib_noEx.tex(,828) @subsubsection jordanmatrix
linalg_lib_noEx.tex(,829) @cindex jordanmatrix
linalg_lib_noEx.tex(,830) @c ---content jordanmatrix---
linalg_lib_noEx.tex(,831) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,832) 
linalg_lib_noEx.tex(,833) @table @asis
linalg_lib_noEx.tex(,834) @item @strong{Usage:}
linalg_lib_noEx.tex(,835) jordanmatrix(e,s,m); ideal e, intvec s, intvec m
linalg_lib_noEx.tex(,836) 
linalg_lib_noEx.tex(,837) @item @strong{Assume:}
linalg_lib_noEx.tex(,838) ncols(e)==size(s)==size(m)
linalg_lib_noEx.tex(,839) 
linalg_lib_noEx.tex(,840) @item @strong{Return:}
linalg_lib_noEx.tex(,841) @format
linalg_lib_noEx.tex(,842) matrix J;  Jordan matrix with list(e,s,m)==jordan(J)
linalg_lib_noEx.tex(,843) @end format
linalg_lib_noEx.tex(,844) 
linalg_lib_noEx.tex(,845) @end table
linalg_lib_noEx.tex(,846) @strong{Example:}
linalg_lib_noEx.tex(,847) @smallexample
linalg_lib_noEx.tex(,848) @c skipped computation of example jordanmatrix d2t_singular/linalg_lib.doc:834 
linalg_lib_noEx.tex(,849) LIB "linalg.lib";
linalg_lib_noEx.tex(,850) ring R=0,x,dp;
linalg_lib_noEx.tex(,851) ideal e=ideal(2,3);
linalg_lib_noEx.tex(,852) intvec s=1,2;
linalg_lib_noEx.tex(,853) intvec m=1,1;
linalg_lib_noEx.tex(,854) print(jordanmatrix(e,s,m));
linalg_lib_noEx.tex(,855) @end smallexample
linalg_lib_noEx.tex(,856) @c ---end content jordanmatrix---
linalg_lib_noEx.tex(,857) 
linalg_lib_noEx.tex(,858) @c ------------------- jordannf -------------
linalg_lib_noEx.tex(,859) @node jordannf,, jordanmatrix, linalg_lib
linalg_lib_noEx.tex(,860) @subsubsection jordannf
linalg_lib_noEx.tex(,861) @cindex jordannf
linalg_lib_noEx.tex(,862) @c ---content jordannf---
linalg_lib_noEx.tex(,863) Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).
linalg_lib_noEx.tex(,864) 
linalg_lib_noEx.tex(,865) @table @asis
linalg_lib_noEx.tex(,866) @item @strong{Usage:}
linalg_lib_noEx.tex(,867) jordannf(M); matrix M
linalg_lib_noEx.tex(,868) 
linalg_lib_noEx.tex(,869) @item @strong{Assume:}
linalg_lib_noEx.tex(,870) eigenvalues of M in basefield
linalg_lib_noEx.tex(,871) 
linalg_lib_noEx.tex(,872) @item @strong{Return:}
linalg_lib_noEx.tex(,873) matrix J; Jordan normal form of M
linalg_lib_noEx.tex(,874) 
linalg_lib_noEx.tex(,875) @end table
linalg_lib_noEx.tex(,876) @strong{Example:}
linalg_lib_noEx.tex(,877) @smallexample
linalg_lib_noEx.tex(,878) @c skipped computation of example jordannf d2t_singular/linalg_lib.doc:865 
linalg_lib_noEx.tex(,879) LIB "linalg.lib";
linalg_lib_noEx.tex(,880) ring R=0,x,dp;
linalg_lib_noEx.tex(,881) matrix M[3][3]=3,2,1,0,2,1,0,0,3;
linalg_lib_noEx.tex(,882) print(M);
linalg_lib_noEx.tex(,883) print(jordannf(M));
linalg_lib_noEx.tex(,884) @end smallexample
linalg_lib_noEx.tex(,885) @c ---end content jordannf---
singular.texi(,352) @c ----------------------------------------------------------------------------
singular.texi(,353) @node Commutative algebra, Singularities, Linear algebra, SINGULAR libraries
singular.texi(,354) @section Commutative algebra
singular.texi(,355) @cindex Commutative algebra
singular.texi(,356) 
singular.texi(,357) @menu
singular.texi(,358) * algebra_lib:: procedures for computing with algebras and maps
singular.texi(,359) * elim_lib:: procedures for elimination, saturation and blowing up
singular.texi(,360) * homolog_lib:: procedures for homological algebra
singular.texi(,361) * mprimdec_lib:: procedures for primary decomposition of modules
singular.texi(,362) * mregular_lib:: procedures for Castelnuovo-Mumford regularity
singular.texi(,363) * normal_lib:: procedure for normalization
singular.texi(,364) * primdec_lib:: procedures for primary decomposition
singular.texi(,365) * primitiv_lib:: procedures for finding a primitive element
singular.texi(,366) * reesclos_lib:: Rees Algebra and integral closure of an ideal
singular.texi(,367) * intprog_lib:: Integer Programming
singular.texi(,368) * toric_lib:: toric ideals
singular.texi(,369) @end menu
singular.texi(,370) 
singular.texi(,371) @c ---------------------------------------------------------
singular.texi(,372) @node algebra_lib, elim_lib, Commutative algebra, Commutative algebra
singular.texi(,373) @subsection algebra_lib
singular.texi(,374) @c include of docu for algebra.lib
algebra_lib.tex(,1) @c ---content LibInfo---
algebra_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/algebra_lib.doc
algebra_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/algebra_lib.doc INSTEAD
algebra_lib.tex(,4) @c library version: (1.9.2.3,2002/04/11)
algebra_lib.tex(,5) @c library file: ../Singular/LIB/algebra.lib
algebra_lib.tex(,6) @cindex algebra.lib
algebra_lib.tex(,7) @cindex algebra_lib
algebra_lib.tex(,8) @table @asis
algebra_lib.tex(,9) @item @strong{Library:}
algebra_lib.tex(,10) algebra.lib
algebra_lib.tex(,11) @item @strong{Purpose:}
algebra_lib.tex(,12)    Compute with Algebras and Algebra Maps
algebra_lib.tex(,13) @item @strong{Authors:}
algebra_lib.tex(,14) Gert-Martin Greuel, greuel@@mathematik.uni-kl.de,
algebra_lib.tex(,15) @* Agnes Eileen Heydtmann, agnes@@math.uni-sb.de,
algebra_lib.tex(,16) @* Gerhard Pfister, pfister@@mathematik.uni-kl.de
algebra_lib.tex(,17) 
algebra_lib.tex(,18) @end table
algebra_lib.tex(,19) 
algebra_lib.tex(,20) @strong{Procedures:}
algebra_lib.tex(,21) @menu
algebra_lib.tex(,22) * algebra_containment:: query of algebra containment
algebra_lib.tex(,23) * module_containment:: query of module containment over a subalgebra
algebra_lib.tex(,24) * inSubring:: test whether poly p is in subring generated by I
algebra_lib.tex(,25) * algDependent:: computes algebraic relations between generators of I
algebra_lib.tex(,26) * alg_kernel:: computes the kernel of the ring map phi
algebra_lib.tex(,27) * is_injective:: test for injectivity of ring map phi
algebra_lib.tex(,28) * is_surjective:: test for surjectivity of ring map phi
algebra_lib.tex(,29) * is_bijective:: test for bijectivity of ring map phi
algebra_lib.tex(,30) * noetherNormal:: noether normalization of ideal id
algebra_lib.tex(,31) * mapIsFinite:: query for finiteness of map phi:R --> basering/I
algebra_lib.tex(,32) * finitenessTest:: find variables which occur as pure power in lead(i)
algebra_lib.tex(,33) @end menu
algebra_lib.tex(,34) @c ---end content LibInfo---
algebra_lib.tex(,35) 
algebra_lib.tex(,36) @c ------------------- algebra_containment -------------
algebra_lib.tex(,37) @node algebra_containment, module_containment,, algebra_lib
algebra_lib.tex(,38) @subsubsection algebra_containment
algebra_lib.tex(,39) @cindex algebra_containment
algebra_lib.tex(,40) @c ---content algebra_containment---
algebra_lib.tex(,41) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,42) 
algebra_lib.tex(,43) @table @asis
algebra_lib.tex(,44) @item @strong{Usage:}
algebra_lib.tex(,45) algebra_containment(p,A[,k]); p poly, A ideal, k integer.
algebra_lib.tex(,46) @* A = A[1],...,A[m] generators of subalgebra of the basering
algebra_lib.tex(,47) 
algebra_lib.tex(,48) @item @strong{Return:}
algebra_lib.tex(,49) @format
algebra_lib.tex(,50)          - k=0 (or if k is not given) an integer:
algebra_lib.tex(,51)            1  : if p is contained in the subalgebra K[A[1],...,A[m]]
algebra_lib.tex(,52)            0  : if p is not contained in K[A[1],...,A[m]]
algebra_lib.tex(,53)          - k=1 : a list, say l, of size 2, l[1] integer, l[2] ring, satisfying
algebra_lib.tex(,54)            l[1]=1 if p is in the subalgebra K[A[1],...,A[m]] and then the ring
algebra_lib.tex(,55)            l[2] contains poly check = h(y(1),...,y(m)) if p=h(A[1],...,A[m])
algebra_lib.tex(,56)            l[1]=0 if p is in not the subalgebra K[A[1],...,A[m]] and then
algebra_lib.tex(,57)            l[2] contains the poly check = h(x,y(1),...,y(m)) if p satisfies
algebra_lib.tex(,58)            the nonlinear relation p = h(x,A[1],...,A[m]) where
algebra_lib.tex(,59)            x = x(1),...,x(n) denote the variables of the basering
algebra_lib.tex(,60) @end format
algebra_lib.tex(,61) 
algebra_lib.tex(,62) @item @strong{Display:}
algebra_lib.tex(,63) if k=0 and printlevel >= voice+1 (default) display the poly check
algebra_lib.tex(,64) 
algebra_lib.tex(,65) @item @strong{Note:}
algebra_lib.tex(,66) The proc inSubring uses a different algorithm which is sometimes
algebra_lib.tex(,67) faster.
algebra_lib.tex(,68) 
algebra_lib.tex(,69) @item @strong{Theory:}
algebra_lib.tex(,70) The ideal of algebraic relations of the algebra generators A[1],...,
algebra_lib.tex(,71) A[m] is computed introducing new variables y(i) and the product
algebra_lib.tex(,72) order with x(i) >> y(i).
algebra_lib.tex(,73) @*p reduces to a polynomial only in the y(i) <=> p is contained in the
algebra_lib.tex(,74) subring generated by the polynomials A[1],...,A[m].
algebra_lib.tex(,75) 
algebra_lib.tex(,76) @end table
algebra_lib.tex(,77) @strong{Example:}
algebra_lib.tex(,78) @smallexample
algebra_lib.tex(,79) @c computed example algebra_containment d2t_singular/algebra_lib.doc:77 
algebra_lib.tex(,80) LIB "algebra.lib";
algebra_lib.tex(,81) int p = printlevel; printlevel = 1;
algebra_lib.tex(,82) ring R = 0,(x,y,z),dp;
algebra_lib.tex(,83) ideal A=x2+y2,z2,x4+y4,1,x2z-1y2z,xyz,x3y-1xy3;
algebra_lib.tex(,84) poly p1=z;
algebra_lib.tex(,85) poly p2=
algebra_lib.tex(,86) x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
algebra_lib.tex(,87) algebra_containment(p1,A);
algebra_lib.tex(,88) @expansion{} // x(3)
algebra_lib.tex(,89) @expansion{} 0
algebra_lib.tex(,90) algebra_containment(p2,A);
algebra_lib.tex(,91) @expansion{} // y(1)*y(2)*y(5)^2+y(3)*y(5)^3+4*y(1)*y(2)*y(6)^2+4*y(6)^3*y(7)+2*y(2)*y\
algebra_lib.tex(,92)    (5)*y(7)^2
algebra_lib.tex(,93) @expansion{} 1
algebra_lib.tex(,94) list L = algebra_containment(p2,A,1);
algebra_lib.tex(,95) @expansion{} 
algebra_lib.tex(,96) @expansion{} // 'algebra_containment' created a ring as 2nd element of the list.
algebra_lib.tex(,97) @expansion{} // The ring contains the poly check which defines the algebraic relation.
algebra_lib.tex(,98) @expansion{} // To access to the ring and see check you must give the ring a name,
algebra_lib.tex(,99) @expansion{} // e.g.:
algebra_lib.tex(,100) @expansion{}                def S = l[2]; setring S; check;
algebra_lib.tex(,101) @expansion{} 	
algebra_lib.tex(,102) L[1];
algebra_lib.tex(,103) @expansion{} 1
algebra_lib.tex(,104) def S = L[2]; setring S;
algebra_lib.tex(,105) check;
algebra_lib.tex(,106) @expansion{} y(1)*y(2)*y(5)^2+y(3)*y(5)^3+4*y(1)*y(2)*y(6)^2+4*y(6)^3*y(7)+2*y(2)*y(5)\
algebra_lib.tex(,107)    *y(7)^2
algebra_lib.tex(,108) printlevel = p;
algebra_lib.tex(,109) @c end example algebra_containment d2t_singular/algebra_lib.doc:77
algebra_lib.tex(,110) @end smallexample
algebra_lib.tex(,111) @c ---end content algebra_containment---
algebra_lib.tex(,112) 
algebra_lib.tex(,113) @c ------------------- module_containment -------------
algebra_lib.tex(,114) @node module_containment, inSubring, algebra_containment, algebra_lib
algebra_lib.tex(,115) @subsubsection module_containment
algebra_lib.tex(,116) @cindex module_containment
algebra_lib.tex(,117) @c ---content module_containment---
algebra_lib.tex(,118) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,119) 
algebra_lib.tex(,120) @table @asis
algebra_lib.tex(,121) @item @strong{Usage:}
algebra_lib.tex(,122) module_containment(p,P,M[,k]); p poly, P ideal, M ideal, k int
algebra_lib.tex(,123) @* P = P[1],...,P[n] generators of a subalgebra of the basering,
algebra_lib.tex(,124) @* M = M[1],...,M[m] generators of a module over the subalgebra K[P]
algebra_lib.tex(,125) 
algebra_lib.tex(,126) @item @strong{Assume:}
algebra_lib.tex(,127) ncols(P) = nvars(basering), the P[i] are algebraically independent
algebra_lib.tex(,128) 
algebra_lib.tex(,129) @item @strong{Return:}
algebra_lib.tex(,130) @format
algebra_lib.tex(,131)          - k=0 (or if k is not given), an integer:
algebra_lib.tex(,132)            1    : if p is contained in the module <M[1],...,M[m]> over K[P]
algebra_lib.tex(,133)            0    : if p is not contained in <M[1],...,M[m]>
algebra_lib.tex(,134)          - k=1, a list, say l, of size 2, l[1] integer, l[2] ring:
algebra_lib.tex(,135)            l[1]=1 : if p is in <M[1],...,M[m]> and then the ring l[2] contains
algebra_lib.tex(,136)              the polynomial check = h(y(1),...,y(m),z(1),...,z(n)) if
algebra_lib.tex(,137)              p = h(M[1],...,M[m],P[1],...,P[n])
algebra_lib.tex(,138)            l[1]=0 : if p is in not in <M[1],...,M[m]>, then l[2] contains the
algebra_lib.tex(,139)              poly check = h(x,y(1),...,y(m),z(1),...,z(n)) if p satisfies
algebra_lib.tex(,140)              the nonlinear relation p = h(x,M[1],...,M[m],P[1],...,P[n]) where
algebra_lib.tex(,141)              x = x(1),...,x(n) denote the variables of the basering
algebra_lib.tex(,142) @end format
algebra_lib.tex(,143) 
algebra_lib.tex(,144) @item @strong{Display:}
algebra_lib.tex(,145) the polynomial h(y(1),...,y(m),z(1),...,z(n)) if k=0, resp.
algebra_lib.tex(,146) a comment how to access the relation check if k=1, provided
algebra_lib.tex(,147) printlevel >= voice+1 (default).
algebra_lib.tex(,148) 
algebra_lib.tex(,149) @item @strong{Theory:}
algebra_lib.tex(,150) The ideal of algebraic relations of all the generators p1,...,pn,
algebra_lib.tex(,151) s1,...,st given by P and S is computed introducing new variables y(j),
algebra_lib.tex(,152) z(i) and the product order: x^a*y^b*z^c > x^d*y^e*z^f if x^a > x^d
algebra_lib.tex(,153) with respect to the lp ordering or else if z^c > z^f with respect to
algebra_lib.tex(,154) the dp ordering or else if y^b > y^e with respect to the lp ordering
algebra_lib.tex(,155) again. p reduces to a polynomial only in the y(j) and z(i), linear in
algebra_lib.tex(,156) the z(i) <=> p is contained in the module.
algebra_lib.tex(,157) 
algebra_lib.tex(,158) @end table
algebra_lib.tex(,159) @strong{Example:}
algebra_lib.tex(,160) @smallexample
algebra_lib.tex(,161) @c computed example module_containment d2t_singular/algebra_lib.doc:144 
algebra_lib.tex(,162) LIB "algebra.lib";
algebra_lib.tex(,163) int p = printlevel; printlevel = 1;
algebra_lib.tex(,164) ring R=0,(x,y,z),dp;
algebra_lib.tex(,165) ideal P = x2+y2,z2,x4+y4;           //algebra generators
algebra_lib.tex(,166) ideal M = 1,x2z-1y2z,xyz,x3y-1xy3;  //module generators
algebra_lib.tex(,167) poly p1=
algebra_lib.tex(,168) x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
algebra_lib.tex(,169) module_containment(p1,P,M);
algebra_lib.tex(,170) @expansion{} // y(2)*z(2)*z(3)^2+z(1)^3*z(2)^2
algebra_lib.tex(,171) @expansion{} 1
algebra_lib.tex(,172) poly p2=z;
algebra_lib.tex(,173) list l = module_containment(p2,P,M,1);
algebra_lib.tex(,174) @expansion{} 
algebra_lib.tex(,175) @expansion{} // 'module_containment' created a ring as 2nd element of the list. The
algebra_lib.tex(,176) @expansion{} // ring contains the poly check which defines the algebraic relation
algebra_lib.tex(,177) @expansion{} // for p. To access to the ring and see check you must give the ring
algebra_lib.tex(,178) @expansion{} // a name, e.g.:
algebra_lib.tex(,179) @expansion{}      def S = l[2]; setring S; check;
algebra_lib.tex(,180) @expansion{}       
algebra_lib.tex(,181) l[1];
algebra_lib.tex(,182) @expansion{} 0
algebra_lib.tex(,183) def S = l[2]; setring S; check;
algebra_lib.tex(,184) @expansion{} x(3)
algebra_lib.tex(,185) printlevel=p;
algebra_lib.tex(,186) @c end example module_containment d2t_singular/algebra_lib.doc:144
algebra_lib.tex(,187) @end smallexample
algebra_lib.tex(,188) @c ---end content module_containment---
algebra_lib.tex(,189) 
algebra_lib.tex(,190) @c ------------------- inSubring -------------
algebra_lib.tex(,191) @node inSubring, algDependent, module_containment, algebra_lib
algebra_lib.tex(,192) @subsubsection inSubring
algebra_lib.tex(,193) @cindex inSubring
algebra_lib.tex(,194) @c ---content inSubring---
algebra_lib.tex(,195) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,196) 
algebra_lib.tex(,197) @table @asis
algebra_lib.tex(,198) @item @strong{Usage:}
algebra_lib.tex(,199) inSubring(p,i); p poly, i ideal
algebra_lib.tex(,200) 
algebra_lib.tex(,201) @item @strong{Return:}
algebra_lib.tex(,202) @format
algebra_lib.tex(,203)          a list l of size 2, l[1] integer, l[2] string
algebra_lib.tex(,204)          l[1]=1 iff p is in the subring generated by i=i[1],...,i[k],
algebra_lib.tex(,205)                 and then l[2] = y(0)-h(y(1),...,y(k)) if p = h(i[1],...,i[k])
algebra_lib.tex(,206)          l[1]=0 iff p is in not the subring generated by i,
algebra_lib.tex(,207)                 and then l[2] = h(y(0),y(1),...,y(k) where p satisfies the
algebra_lib.tex(,208)                 nonlinear relation h(p,i[1],...,i[k])=0.
algebra_lib.tex(,209) @end format
algebra_lib.tex(,210) 
algebra_lib.tex(,211) @item @strong{Note:}
algebra_lib.tex(,212) the proc algebra_containment tests the same with a different
algebra_lib.tex(,213) algorithm, which is often faster
algebra_lib.tex(,214) 
algebra_lib.tex(,215) @end table
algebra_lib.tex(,216) @strong{Example:}
algebra_lib.tex(,217) @smallexample
algebra_lib.tex(,218) @c computed example inSubring d2t_singular/algebra_lib.doc:190 
algebra_lib.tex(,219) LIB "algebra.lib";
algebra_lib.tex(,220) ring q=0,(x,y,z,u,v,w),dp;
algebra_lib.tex(,221) poly p=xyzu2w-1yzu2w2+u4w2-1xu2vw+u2vw2+xyz-1yzw+2u2w-1xv+vw+2;
algebra_lib.tex(,222) ideal I =x-w,u2w+1,yz-v;
algebra_lib.tex(,223) inSubring(p,I);
algebra_lib.tex(,224) @expansion{} [1]:
algebra_lib.tex(,225) @expansion{}    1
algebra_lib.tex(,226) @expansion{} [2]:
algebra_lib.tex(,227) @expansion{}    y(1)*y(2)*y(3)+y(2)^2-y(0)+1
algebra_lib.tex(,228) @c end example inSubring d2t_singular/algebra_lib.doc:190
algebra_lib.tex(,229) @end smallexample
algebra_lib.tex(,230) @c ---end content inSubring---
algebra_lib.tex(,231) 
algebra_lib.tex(,232) @c ------------------- algDependent -------------
algebra_lib.tex(,233) @node algDependent, alg_kernel, inSubring, algebra_lib
algebra_lib.tex(,234) @subsubsection algDependent
algebra_lib.tex(,235) @cindex algDependent
algebra_lib.tex(,236) @c ---content algDependent---
algebra_lib.tex(,237) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,238) 
algebra_lib.tex(,239) @table @asis
algebra_lib.tex(,240) @item @strong{Usage:}
algebra_lib.tex(,241) algDependent(f[,c]); f ideal (say, f = f1,...,fm), c integer
algebra_lib.tex(,242) 
algebra_lib.tex(,243) @item @strong{Return:}
algebra_lib.tex(,244) @format	
algebra_lib.tex(,245)          a list l  of size 2, l[1] integer, l[2] ring:
algebra_lib.tex(,246)          - l[1] = 1 if f1,...,fm are algebraic dependent, 0 if not
algebra_lib.tex(,247)          - l[2] is a ring with variables x(1),...,x(n),y(1),...,y(m) if the
algebra_lib.tex(,248)            basering has n variables. It contains the ideal 'ker', depending
algebra_lib.tex(,249)            only on the y(i) and generating the algebraic relations between the
algebra_lib.tex(,250)            f[i], i.e. substituting y(i) by fi yields 0. Of course, ker is
algebra_lib.tex(,251)            nothing but the kernel of the ring map
algebra_lib.tex(,252)               K[y(1),...,y(m)] ---> basering,  y(i) --> fi.
algebra_lib.tex(,253) @end format
algebra_lib.tex(,254) 
algebra_lib.tex(,255) @item @strong{Note:}
algebra_lib.tex(,256) Three different algorithms are used depending on c = 1,2,3.
algebra_lib.tex(,257) If c is not given or c=0, a heuristically best method is chosen.
algebra_lib.tex(,258) The basering may be a quotient ring.
algebra_lib.tex(,259) @*To access to the ring l[2] and see ker you must give the ring a name,
algebra_lib.tex(,260) e.g. def S=l[2]; setring S; ker;
algebra_lib.tex(,261) 
algebra_lib.tex(,262) @item @strong{Display:}
algebra_lib.tex(,263) The above comment is displayed if printlevel >= 0 (default).
algebra_lib.tex(,264) 
algebra_lib.tex(,265) @end table
algebra_lib.tex(,266) @strong{Example:}
algebra_lib.tex(,267) @smallexample
algebra_lib.tex(,268) @c computed example algDependent d2t_singular/algebra_lib.doc:236 
algebra_lib.tex(,269) LIB "algebra.lib";
algebra_lib.tex(,270) int p = printlevel; printlevel = 1;
algebra_lib.tex(,271) ring R = 0,(x,y,z,u,v,w),dp;
algebra_lib.tex(,272) ideal I = xyzu2w-1yzu2w2+u4w2-1xu2vw+u2vw2+xyz-1yzw+2u2w-1xv+vw+2,
algebra_lib.tex(,273) x-w, u2w+1, yz-v;
algebra_lib.tex(,274) list l = algDependent(I);
algebra_lib.tex(,275) @expansion{} 
algebra_lib.tex(,276) @expansion{} // The 2nd element of the list l is a ring with variables x(1),...,x(n),
algebra_lib.tex(,277) @expansion{} // and y(1),...,y(m) if the basering has n variables and if the ideal
algebra_lib.tex(,278) @expansion{} // is f[1],...,f[m]. The ring contains the ideal ker which depends only
algebra_lib.tex(,279) @expansion{} // on the y(i) and generates the relations between the f[i].
algebra_lib.tex(,280) @expansion{} // I.e. substituting y(i) by f[i] yields 0.
algebra_lib.tex(,281) @expansion{} // To access to the ring and see ker you must give the ring a name,
algebra_lib.tex(,282) @expansion{} // e.g.:
algebra_lib.tex(,283) @expansion{}              def S = l[2]; setring S; ker;
algebra_lib.tex(,284) @expansion{} 	
algebra_lib.tex(,285) l[1];
algebra_lib.tex(,286) @expansion{} 1
algebra_lib.tex(,287) def S = l[2]; setring S;
algebra_lib.tex(,288) ker;
algebra_lib.tex(,289) @expansion{} ker[1]=y(2)*y(3)*y(4)+y(3)^2-y(1)+1
algebra_lib.tex(,290) printlevel = p;
algebra_lib.tex(,291) @c end example algDependent d2t_singular/algebra_lib.doc:236
algebra_lib.tex(,292) @end smallexample
algebra_lib.tex(,293) @c ---end content algDependent---
algebra_lib.tex(,294) 
algebra_lib.tex(,295) @c ------------------- alg_kernel -------------
algebra_lib.tex(,296) @node alg_kernel, is_injective, algDependent, algebra_lib
algebra_lib.tex(,297) @subsubsection alg_kernel
algebra_lib.tex(,298) @cindex alg_kernel
algebra_lib.tex(,299) @c ---content alg_kernel---
algebra_lib.tex(,300) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,301) 
algebra_lib.tex(,302) @table @asis
algebra_lib.tex(,303) @item @strong{Usage:}
algebra_lib.tex(,304) alg_kernel(phi,pr[,s,c]); phi map to basering, pr preimage ring,
algebra_lib.tex(,305) s string (name of kernel in pr), c integer.
algebra_lib.tex(,306) 
algebra_lib.tex(,307) @item @strong{Return:}
algebra_lib.tex(,308) a string, the kernel of phi as string.
algebra_lib.tex(,309) @*If, moreover, a string s is given, the algorithm creates, in the
algebra_lib.tex(,310) preimage ring pr the kernel of phi with name s.
algebra_lib.tex(,311) @*Three different algorithms are used depending on c = 1,2,3.
algebra_lib.tex(,312) If c is not given or c=0, a heuristically best method is chosen.
algebra_lib.tex(,313) (algorithm 1 uses the preimage command)
algebra_lib.tex(,314) 
algebra_lib.tex(,315) @item @strong{Note:}
algebra_lib.tex(,316) Since the kernel of phi lives in pr, it cannot be returned to the
algebra_lib.tex(,317) basering. If s is given, the user has access to it in pr via s.
algebra_lib.tex(,318) The basering may be a quotient ring.
algebra_lib.tex(,319) 
algebra_lib.tex(,320) @end table
algebra_lib.tex(,321) @strong{Example:}
algebra_lib.tex(,322) @smallexample
algebra_lib.tex(,323) @c computed example alg_kernel d2t_singular/algebra_lib.doc:279 
algebra_lib.tex(,324) LIB "algebra.lib";
algebra_lib.tex(,325) ring r = 0,(a,b,c),ds;
algebra_lib.tex(,326) ring s = 0,(x,y,z,u,v,w),dp;
algebra_lib.tex(,327) ideal I = x-w,u2w+1,yz-v;
algebra_lib.tex(,328) map phi = r,I;                // a map from r to s:
algebra_lib.tex(,329) alg_kernel(phi,r);            // a,b,c ---> x-w,u2w+1,yz-v
algebra_lib.tex(,330) @expansion{} 0
algebra_lib.tex(,331) ring S = 0,(a,b,c),ds;
algebra_lib.tex(,332) ring R = 0,(x,y,z),dp;
algebra_lib.tex(,333) qring Q = std(x-y);
algebra_lib.tex(,334) ideal i = x, y, x2-y3;
algebra_lib.tex(,335) map phi = S,i;                 // a map to a quotient ring
algebra_lib.tex(,336) alg_kernel(phi,S,"ker",3);     // uses algorithm 3
algebra_lib.tex(,337) @expansion{} a-b,b^3-b^2+c
algebra_lib.tex(,338) setring S;                     // you have access to kernel in preimage
algebra_lib.tex(,339) ker;
algebra_lib.tex(,340) @expansion{} ker[1]=a-b
algebra_lib.tex(,341) @expansion{} ker[2]=c-b2+b3
algebra_lib.tex(,342) @c end example alg_kernel d2t_singular/algebra_lib.doc:279
algebra_lib.tex(,343) @end smallexample
algebra_lib.tex(,344) @c ---end content alg_kernel---
algebra_lib.tex(,345) 
algebra_lib.tex(,346) @c ------------------- is_injective -------------
algebra_lib.tex(,347) @node is_injective, is_surjective, alg_kernel, algebra_lib
algebra_lib.tex(,348) @subsubsection is_injective
algebra_lib.tex(,349) @cindex is_injective
algebra_lib.tex(,350) @c ---content is_injective---
algebra_lib.tex(,351) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,352) 
algebra_lib.tex(,353) @table @asis
algebra_lib.tex(,354) @item @strong{Usage:}
algebra_lib.tex(,355) is_injective(phi,pr[,c,s]); phi map, pr preimage ring, c int, s string
algebra_lib.tex(,356) 
algebra_lib.tex(,357) @item @strong{Return:}
algebra_lib.tex(,358) @format	
algebra_lib.tex(,359)          - 1 (type int) if phi is injective, 0 if not (if s is not given).
algebra_lib.tex(,360)          - If s is given, return a list l of size 2, l[1] int, l[2] ring:
algebra_lib.tex(,361)            l[1] is 1 if phi is injective, 0 if not
algebra_lib.tex(,362)            l[2] is a ring with variables x(1),...,x(n),y(1),...,y(m) if the
algebra_lib.tex(,363)            basering has n variables and the map m components, it contains the
algebra_lib.tex(,364)            ideal 'ker', depending only on the y(i), the kernel of the given map
algebra_lib.tex(,365) @end format
algebra_lib.tex(,366) 
algebra_lib.tex(,367) @item @strong{Note:}
algebra_lib.tex(,368) Three different algorithms are used depending on c = 1,2,3.
algebra_lib.tex(,369) If c is not given or c=0, a heuristically best method is chosen.
algebra_lib.tex(,370) The basering may be a quotient ring. However, if the preimage ring is
algebra_lib.tex(,371) a quotient ring, say pr = P/I, consider phi as a map from P and then
algebra_lib.tex(,372) the algorithm returns 1 if the kernel of phi is 0 mod I.
algebra_lib.tex(,373) To access to the ring l[2] and see ker you must give the ring a name,
algebra_lib.tex(,374) e.g. def S=l[2]; setring S; ker;
algebra_lib.tex(,375) 
algebra_lib.tex(,376) @item @strong{Display:}
algebra_lib.tex(,377) The above comment is displayed if printlevel >= 0 (default).
algebra_lib.tex(,378) 
algebra_lib.tex(,379) @end table
algebra_lib.tex(,380) @strong{Example:}
algebra_lib.tex(,381) @smallexample
algebra_lib.tex(,382) @c computed example is_injective d2t_singular/algebra_lib.doc:334 
algebra_lib.tex(,383) LIB "algebra.lib";
algebra_lib.tex(,384) int p = printlevel;
algebra_lib.tex(,385) ring r = 0,(a,b,c),ds;
algebra_lib.tex(,386) ring s = 0,(x,y,z,u,v,w),dp;
algebra_lib.tex(,387) ideal I = x-w,u2w+1,yz-v;
algebra_lib.tex(,388) map phi = r,I;                    // a map from r to s:
algebra_lib.tex(,389) is_injective(phi,r);              // a,b,c ---> x-w,u2w+1,yz-v
algebra_lib.tex(,390) @expansion{} 1
algebra_lib.tex(,391) ring R = 0,(x,y,z),dp;
algebra_lib.tex(,392) ideal i = x, y, x2-y3;
algebra_lib.tex(,393) map phi = R,i;                    // a map from R to itself, z --> x2-y3
algebra_lib.tex(,394) list l = is_injective(phi,R,"");
algebra_lib.tex(,395) @expansion{} 
algebra_lib.tex(,396) @expansion{} // The 2nd element of the list is a ring with variables x(1),...,x(n),
algebra_lib.tex(,397) @expansion{} // y(1),...,y(m) if the basering has n variables and the map is
algebra_lib.tex(,398) @expansion{} // F[1],...,F[m].
algebra_lib.tex(,399) @expansion{} // It contains the ideal ker, the kernel of the given map y(i) --> F[i].
algebra_lib.tex(,400) @expansion{} // To access to the ring and see ker you must give the ring a name,
algebra_lib.tex(,401) @expansion{} // e.g.:
algebra_lib.tex(,402) @expansion{}      def S = l[2]; setring S; ker;
algebra_lib.tex(,403) @expansion{} 	
algebra_lib.tex(,404) l[1];
algebra_lib.tex(,405) @expansion{} 0
algebra_lib.tex(,406) def S = l[2]; setring S;
algebra_lib.tex(,407) ker;
algebra_lib.tex(,408) @expansion{} ker[1]=y(2)^3-y(1)^2+y(3)
algebra_lib.tex(,409) @c end example is_injective d2t_singular/algebra_lib.doc:334
algebra_lib.tex(,410) @end smallexample
algebra_lib.tex(,411) @c ---end content is_injective---
algebra_lib.tex(,412) 
algebra_lib.tex(,413) @c ------------------- is_surjective -------------
algebra_lib.tex(,414) @node is_surjective, is_bijective, is_injective, algebra_lib
algebra_lib.tex(,415) @subsubsection is_surjective
algebra_lib.tex(,416) @cindex is_surjective
algebra_lib.tex(,417) @c ---content is_surjective---
algebra_lib.tex(,418) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,419) 
algebra_lib.tex(,420) @table @asis
algebra_lib.tex(,421) @item @strong{Usage:}
algebra_lib.tex(,422) is_surjective(phi); phi map to basering, or ideal defining it
algebra_lib.tex(,423) 
algebra_lib.tex(,424) @item @strong{Return:}
algebra_lib.tex(,425) an integer, 1 if phi is surjective, 0 if not
algebra_lib.tex(,426) 
algebra_lib.tex(,427) @item @strong{Note:}
algebra_lib.tex(,428) The algorithm returns 1 iff all the variables of the basering are
algebra_lib.tex(,429) contained in the polynomial subalgebra generated by the polynomials
algebra_lib.tex(,430) defining phi. Hence, if the basering has local or mixed ordering
algebra_lib.tex(,431) or if the preimage ring is a quotient ring (in which case the map
algebra_lib.tex(,432) may not be well defined) then the return value 1 means
algebra_lib.tex(,433) @*"surjectivity" in this sense.
algebra_lib.tex(,434) 
algebra_lib.tex(,435) @end table
algebra_lib.tex(,436) @strong{Example:}
algebra_lib.tex(,437) @smallexample
algebra_lib.tex(,438) @c computed example is_surjective d2t_singular/algebra_lib.doc:378 
algebra_lib.tex(,439) LIB "algebra.lib";
algebra_lib.tex(,440) ring R = 0,(x,y,z),dp;
algebra_lib.tex(,441) ideal i = x, y, x2-y3;
algebra_lib.tex(,442) map phi = R,i;                    // a map from R to itself, z->x2-y3
algebra_lib.tex(,443) is_surjective(phi);
algebra_lib.tex(,444) @expansion{} 0
algebra_lib.tex(,445) qring Q = std(ideal(z-x37));
algebra_lib.tex(,446) map psi = R, x,y,x2-y3;           // the same map to the quotient ring
algebra_lib.tex(,447) is_surjective(psi);
algebra_lib.tex(,448) @expansion{} 1
algebra_lib.tex(,449) ring S = 0,(a,b,c),dp;
algebra_lib.tex(,450) map psi = R,ideal(a,a+b,c-a2+b3); // a map from R to S,
algebra_lib.tex(,451) is_surjective(psi);               // x->a, y->a+b, z->c-a2+b3
algebra_lib.tex(,452) @expansion{} 1
algebra_lib.tex(,453) @c end example is_surjective d2t_singular/algebra_lib.doc:378
algebra_lib.tex(,454) @end smallexample
algebra_lib.tex(,455) @c ---end content is_surjective---
algebra_lib.tex(,456) 
algebra_lib.tex(,457) @c ------------------- is_bijective -------------
algebra_lib.tex(,458) @node is_bijective, noetherNormal, is_surjective, algebra_lib
algebra_lib.tex(,459) @subsubsection is_bijective
algebra_lib.tex(,460) @cindex is_bijective
algebra_lib.tex(,461) @c ---content is_bijective---
algebra_lib.tex(,462) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,463) 
algebra_lib.tex(,464) @table @asis
algebra_lib.tex(,465) @item @strong{Usage:}
algebra_lib.tex(,466) is_bijective(phi,pr); phi map to basering, pr preimage ring
algebra_lib.tex(,467) 
algebra_lib.tex(,468) @item @strong{Return:}
algebra_lib.tex(,469) an integer, 1 if phi is bijective, 0 if not
algebra_lib.tex(,470) 
algebra_lib.tex(,471) @item @strong{Note:}
algebra_lib.tex(,472) The algorithm checks first injectivity and then surjectivity
algebra_lib.tex(,473) To interpret this for local/mixed orderings, or for quotient rings
algebra_lib.tex(,474) type help is_surjective; and help is_injective;
algebra_lib.tex(,475) 
algebra_lib.tex(,476) @item @strong{Display:}
algebra_lib.tex(,477) A comment if printlevel >= voice-1 (default)
algebra_lib.tex(,478) 
algebra_lib.tex(,479) @end table
algebra_lib.tex(,480) @strong{Example:}
algebra_lib.tex(,481) @smallexample
algebra_lib.tex(,482) @c computed example is_bijective d2t_singular/algebra_lib.doc:419 
algebra_lib.tex(,483) LIB "algebra.lib";
algebra_lib.tex(,484) int p = printlevel;  printlevel = 1;
algebra_lib.tex(,485) ring R = 0,(x,y,z),dp;
algebra_lib.tex(,486) ideal i = x, y, x2-y3;
algebra_lib.tex(,487) map phi = R,i;                      // a map from R to itself, z->x2-y3
algebra_lib.tex(,488) is_bijective(phi,R);
algebra_lib.tex(,489) @expansion{} // map not injective
algebra_lib.tex(,490) @expansion{} 0
algebra_lib.tex(,491) qring Q = std(z-x2+y3);
algebra_lib.tex(,492) is_bijective(ideal(x,y,x2-y3),Q);
algebra_lib.tex(,493) @expansion{} 1
algebra_lib.tex(,494) ring S = 0,(a,b,c,d),dp;
algebra_lib.tex(,495) map psi = R,ideal(a,a+b,c-a2+b3,0); // a map from R to S,
algebra_lib.tex(,496) is_bijective(psi,R);                // x->a, y->a+b, z->c-a2+b3
algebra_lib.tex(,497) @expansion{} // map injective, but not surjective
algebra_lib.tex(,498) @expansion{} 0
algebra_lib.tex(,499) qring T = std(d,c-a2+b3);
algebra_lib.tex(,500) @expansion{} // ** _ is no standardbasis
algebra_lib.tex(,501) map chi = Q,a,b,a2-b3;              // amap between two quotient rings
algebra_lib.tex(,502) is_bijective(chi,Q);
algebra_lib.tex(,503) @expansion{} 1
algebra_lib.tex(,504) printlevel = p;
algebra_lib.tex(,505) @c end example is_bijective d2t_singular/algebra_lib.doc:419
algebra_lib.tex(,506) @end smallexample
algebra_lib.tex(,507) @c ---end content is_bijective---
algebra_lib.tex(,508) 
algebra_lib.tex(,509) @c ------------------- noetherNormal -------------
algebra_lib.tex(,510) @node noetherNormal, mapIsFinite, is_bijective, algebra_lib
algebra_lib.tex(,511) @subsubsection noetherNormal
algebra_lib.tex(,512) @cindex noetherNormal
algebra_lib.tex(,513) @c ---content noetherNormal---
algebra_lib.tex(,514) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,515) 
algebra_lib.tex(,516) @table @asis
algebra_lib.tex(,517) @item @strong{Usage:}
algebra_lib.tex(,518) noetherNormal(id[,p]); id ideal, p integer
algebra_lib.tex(,519) 
algebra_lib.tex(,520) @item @strong{Return:}
algebra_lib.tex(,521) @format	
algebra_lib.tex(,522)          a list l two ideals, say I,J:
algebra_lib.tex(,523)          - I is generated by a subset of the variables with size(I) = dim(id)
algebra_lib.tex(,524)          - J defines a map (coordinate change in the basering), such that:
algebra_lib.tex(,525)            if we define  map phi=basering,J;
algebra_lib.tex(,526)            then k[var(1),...,var(n)]/phi(id) is finite over k[I].
algebra_lib.tex(,527)          If p is given, 0<=p<=100, a sparse coordinate change with p percent
algebra_lib.tex(,528)          of the matrix entries being 0 (default: p=0 i.e. dense)
algebra_lib.tex(,529) @end format
algebra_lib.tex(,530) 
algebra_lib.tex(,531) @item @strong{Note:}
algebra_lib.tex(,532) Designed for characteristic 0.It works also in char k > 0 if it
algebra_lib.tex(,533) terminates,but may result in an infinite loop in small characteristic
algebra_lib.tex(,534) 
algebra_lib.tex(,535) @end table
algebra_lib.tex(,536) @strong{Example:}
algebra_lib.tex(,537) @smallexample
algebra_lib.tex(,538) @c computed example noetherNormal d2t_singular/algebra_lib.doc:468 
algebra_lib.tex(,539) LIB "algebra.lib";
algebra_lib.tex(,540) ring r=0,(x,y,z),dp;
algebra_lib.tex(,541) ideal i= xy,xz;
algebra_lib.tex(,542) noetherNormal(i);
algebra_lib.tex(,543) @expansion{} [1]:
algebra_lib.tex(,544) @expansion{}    _[1]=x
algebra_lib.tex(,545) @expansion{}    _[2]=2x+y
algebra_lib.tex(,546) @expansion{}    _[3]=3x+4y+z
algebra_lib.tex(,547) @expansion{} [2]:
algebra_lib.tex(,548) @expansion{}    _[1]=y
algebra_lib.tex(,549) @expansion{}    _[2]=z
algebra_lib.tex(,550) @c end example noetherNormal d2t_singular/algebra_lib.doc:468
algebra_lib.tex(,551) @end smallexample
algebra_lib.tex(,552) @c ---end content noetherNormal---
algebra_lib.tex(,553) 
algebra_lib.tex(,554) @c ------------------- mapIsFinite -------------
algebra_lib.tex(,555) @node mapIsFinite, finitenessTest, noetherNormal, algebra_lib
algebra_lib.tex(,556) @subsubsection mapIsFinite
algebra_lib.tex(,557) @cindex mapIsFinite
algebra_lib.tex(,558) @c ---content mapIsFinite---
algebra_lib.tex(,559) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,560) 
algebra_lib.tex(,561) @table @asis
algebra_lib.tex(,562) @item @strong{Usage:}
algebra_lib.tex(,563) mapIsFinite(phi,R[,J]); R a ring, phi: R ---> basering a map
algebra_lib.tex(,564) J an ideal in the basering, J = 0 if not given
algebra_lib.tex(,565) 
algebra_lib.tex(,566) @item @strong{Return:}
algebra_lib.tex(,567) 1 if R ---> basering/J is finite and 0 else
algebra_lib.tex(,568) 
algebra_lib.tex(,569) @end table
algebra_lib.tex(,570) @strong{Example:}
algebra_lib.tex(,571) @smallexample
algebra_lib.tex(,572) @c computed example mapIsFinite d2t_singular/algebra_lib.doc:495 
algebra_lib.tex(,573) LIB "algebra.lib";
algebra_lib.tex(,574) ring r = 0,(a,b,c),dp;
algebra_lib.tex(,575) ring s = 0,(x,y,z),dp;
algebra_lib.tex(,576) ideal i= xy;
algebra_lib.tex(,577) map phi= r,(xy)^3+x2+z,y2-1,z3;
algebra_lib.tex(,578) mapIsFinite(phi,r,i);
algebra_lib.tex(,579) @expansion{} 1
algebra_lib.tex(,580) @c end example mapIsFinite d2t_singular/algebra_lib.doc:495
algebra_lib.tex(,581) @end smallexample
algebra_lib.tex(,582) @c ---end content mapIsFinite---
algebra_lib.tex(,583) 
algebra_lib.tex(,584) @c ------------------- finitenessTest -------------
algebra_lib.tex(,585) @node finitenessTest,, mapIsFinite, algebra_lib
algebra_lib.tex(,586) @subsubsection finitenessTest
algebra_lib.tex(,587) @cindex finitenessTest
algebra_lib.tex(,588) @c ---content finitenessTest---
algebra_lib.tex(,589) Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).
algebra_lib.tex(,590) 
algebra_lib.tex(,591) @table @asis
algebra_lib.tex(,592) @item @strong{Usage:}
algebra_lib.tex(,593) finitenessTest(J[,v]); J ideal, v intvec (say v1,...,vr with vi>0)
algebra_lib.tex(,594) 
algebra_lib.tex(,595) @item @strong{Return:}
algebra_lib.tex(,596) @format
algebra_lib.tex(,597)          a list l with l[1] integer, l[2], l[3], l[4] ideals
algebra_lib.tex(,598)          - l[1] = 1 if var(v1),...,var(vr) are in l[2] and 0 else
algebra_lib.tex(,599)          - l[2] (resp. l[3]) contains those variables which occur,
algebra_lib.tex(,600)            (resp. occur not) as pure power in the leading term of one of the
algebra_lib.tex(,601)            generators of J,
algebra_lib.tex(,602)          - l[4] contains those J[i] for which the leading term is a pure power
algebra_lib.tex(,603)            of a variable (which is then in l[2])
algebra_lib.tex(,604)          (default: v = [1,2,..,nvars(basering)])
algebra_lib.tex(,605) @end format
algebra_lib.tex(,606) 
algebra_lib.tex(,607) @item @strong{Theory:}
algebra_lib.tex(,608) If J is a standard basis of an ideal generated by x_1 - f_1(y),...,
algebra_lib.tex(,609) x_n - f_n with y_j ordered lexicographically and y_j >> x_i, then,
algebra_lib.tex(,610) if y_i appears as pure power in the leading term of J[k]. J[k] defines
algebra_lib.tex(,611) an integral relation for y_i over the y_(i+1),... and the f's.
algebra_lib.tex(,612) Moreover, in this situation, if l[2] = y_1,...,y_r, then K[y_1,...y_r]
algebra_lib.tex(,613) is finite over K[f_1..f_n]. If J contains furthermore polynomials
algebra_lib.tex(,614) h_j(y), then K[y_1,...y_z]/<h_j> is finite over K[f_1..f_n].
algebra_lib.tex(,615) 
algebra_lib.tex(,616) @end table
algebra_lib.tex(,617) @strong{Example:}
algebra_lib.tex(,618) @smallexample
algebra_lib.tex(,619) @c computed example finitenessTest d2t_singular/algebra_lib.doc:541 
algebra_lib.tex(,620) LIB "algebra.lib";
algebra_lib.tex(,621) ring s = 0,(x,y,z,a,b,c),(lp(3),dp);
algebra_lib.tex(,622) ideal i= a -(xy)^3+x2-z, b -y2-1, c -z3;
algebra_lib.tex(,623) ideal j = a -(xy)^3+x2-z, b -y2-1, c -z3, xy;
algebra_lib.tex(,624) finitenessTest(std(i),1..3);
algebra_lib.tex(,625) @expansion{} [1]:
algebra_lib.tex(,626) @expansion{}    0
algebra_lib.tex(,627) @expansion{} [2]:
algebra_lib.tex(,628) @expansion{}    _[1]=y
algebra_lib.tex(,629) @expansion{}    _[2]=z
algebra_lib.tex(,630) @expansion{} [3]:
algebra_lib.tex(,631) @expansion{}    _[1]=x
algebra_lib.tex(,632) @expansion{}    _[2]=a
algebra_lib.tex(,633) @expansion{}    _[3]=b
algebra_lib.tex(,634) @expansion{}    _[4]=c
algebra_lib.tex(,635) @expansion{} [4]:
algebra_lib.tex(,636) @expansion{}    _[1]=z3-c
algebra_lib.tex(,637) @expansion{}    _[2]=y2-b+1
algebra_lib.tex(,638) finitenessTest(std(j),1..3);
algebra_lib.tex(,639) @expansion{} [1]:
algebra_lib.tex(,640) @expansion{}    1
algebra_lib.tex(,641) @expansion{} [2]:
algebra_lib.tex(,642) @expansion{}    _[1]=x
algebra_lib.tex(,643) @expansion{}    _[2]=y
algebra_lib.tex(,644) @expansion{}    _[3]=z
algebra_lib.tex(,645) @expansion{} [3]:
algebra_lib.tex(,646) @expansion{}    _[1]=a
algebra_lib.tex(,647) @expansion{}    _[2]=b
algebra_lib.tex(,648) @expansion{}    _[3]=c
algebra_lib.tex(,649) @expansion{} [4]:
algebra_lib.tex(,650) @expansion{}    _[1]=z3-c
algebra_lib.tex(,651) @expansion{}    _[2]=y2-b+1
algebra_lib.tex(,652) @expansion{}    _[3]=x2-z+a
algebra_lib.tex(,653) @c end example finitenessTest d2t_singular/algebra_lib.doc:541
algebra_lib.tex(,654) @end smallexample
algebra_lib.tex(,655) @c ---end content finitenessTest---
singular.texi(,376) @c ----------------------------------------------------------
singular.texi(,377) @node elim_lib, homolog_lib, algebra_lib, Commutative algebra
singular.texi(,378) @subsection elim_lib
singular.texi(,379) @c include of docu for elim.lib
elim_lib.tex(,1) @c ---content LibInfo---
elim_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/elim_lib.doc
elim_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/elim_lib.doc INSTEAD
elim_lib.tex(,4) @c library version: (1.14.2.4,2003/04/16)
elim_lib.tex(,5) @c library file: ../Singular/LIB/elim.lib
elim_lib.tex(,6) @cindex elim.lib
elim_lib.tex(,7) @cindex elim_lib
elim_lib.tex(,8) @table @asis
elim_lib.tex(,9) @item @strong{Library:}
elim_lib.tex(,10) elim.lib
elim_lib.tex(,11) @item @strong{Purpose:}
elim_lib.tex(,12)       Elimination, Saturation and Blowing up
elim_lib.tex(,13) 
elim_lib.tex(,14) @end table
elim_lib.tex(,15) 
elim_lib.tex(,16) @strong{Procedures:}
elim_lib.tex(,17) @menu
elim_lib.tex(,18) * blowup0:: create presentation of blownup ring of ideal j
elim_lib.tex(,19) * elim:: variable n..m eliminated from id (ideal/module)
elim_lib.tex(,20) * elim1:: p=product of vars to be eliminated from id
elim_lib.tex(,21) * nselect:: select generators not containing n-th [..m-th] variable
elim_lib.tex(,22) * sat:: saturated quotient of ideal/module id by ideal j
elim_lib.tex(,23) * select:: select generators containing all variables n...m
elim_lib.tex(,24) * select1:: select generators containing one variable n...m
elim_lib.tex(,25) @end menu
elim_lib.tex(,26) @c ---end content LibInfo---
elim_lib.tex(,27) 
elim_lib.tex(,28) @c ------------------- blowup0 -------------
elim_lib.tex(,29) @node blowup0, elim,, elim_lib
elim_lib.tex(,30) @subsubsection blowup0
elim_lib.tex(,31) @cindex blowup0
elim_lib.tex(,32) @c ---content blowup0---
elim_lib.tex(,33) Procedure from library @code{elim.lib} (@pxref{elim_lib}).
elim_lib.tex(,34) 
elim_lib.tex(,35) @table @asis
elim_lib.tex(,36) @item @strong{Usage:}
elim_lib.tex(,37) blowup0(j[,s1,s2]); j ideal, s1,s2 nonempty strings
elim_lib.tex(,38) 
elim_lib.tex(,39) @item @strong{Create:}
elim_lib.tex(,40) Create a presentation of the blowup ring of j
elim_lib.tex(,41) 
elim_lib.tex(,42) @item @strong{Return:}
elim_lib.tex(,43) no return value
elim_lib.tex(,44) 
elim_lib.tex(,45) @item @strong{Note:}
elim_lib.tex(,46) s1 and s2 are used to give names to the blownup ring and the blownup
elim_lib.tex(,47) ideal (default: s1="j", s2="A")
elim_lib.tex(,48) @*Assume R = char,x(1..n),ord is the basering of j, and s1="j", s2="A"
elim_lib.tex(,49) then the procedure creates a new ring with name Bl_jR
elim_lib.tex(,50) @*(equal to R[A,B,...])
elim_lib.tex(,51) @*Bl_jR = char,(A,B,...,x(1..n)),(dp(k),ord)
elim_lib.tex(,52) @*with k=ncols(j) new variables A,B,... and ordering wp(d1..dk) if j is
elim_lib.tex(,53) homogeneous with deg(j[i])=di resp. dp otherwise for these vars.
elim_lib.tex(,54) If k>26 or size(s2)>1, say s2="A()", the new vars are A(1),...,A(k).
elim_lib.tex(,55) Let j_ be the kernel of the ring map Bl_jR -> R defined by A(i)->j[i],
elim_lib.tex(,56) x(i)->x(i), then the quotient ring Bl_jR/j_ is the blowup ring of j
elim_lib.tex(,57) in R (being isomorphic to R+j+j^2+...). Moreover the procedure creates
elim_lib.tex(,58) a std basis of j_ with name j_ in Bl_jR.
elim_lib.tex(,59) @*This proc uses 'execute' or calls a procedure using 'execute'.
elim_lib.tex(,60) 
elim_lib.tex(,61) @item @strong{Display:}
elim_lib.tex(,62) printlevel >=0: explain created objects (default)
elim_lib.tex(,63) 
elim_lib.tex(,64) @end table
elim_lib.tex(,65) @strong{Example:}
elim_lib.tex(,66) @smallexample
elim_lib.tex(,67) @c computed example blowup0 d2t_singular/elim_lib.doc:65 
elim_lib.tex(,68) LIB "elim.lib";
elim_lib.tex(,69) ring R=0,(x,y),dp;
elim_lib.tex(,70) poly f=y2+x3; ideal j=jacob(f);
elim_lib.tex(,71) blowup0(j);
elim_lib.tex(,72) @expansion{} 
elim_lib.tex(,73) @expansion{} // The proc created the ring Bl_jR (equal to R[A,B])
elim_lib.tex(,74) @expansion{} // it contains the ideal j_ , such that
elim_lib.tex(,75) @expansion{} //             Bl_jR/j_ is the blowup ring
elim_lib.tex(,76) @expansion{} // show(Bl_jR); shows this ring.
elim_lib.tex(,77) @expansion{} // Make Bl_jR the basering and see j_ by typing:
elim_lib.tex(,78) @expansion{}    setring Bl_jR;
elim_lib.tex(,79) @expansion{}    j_;
elim_lib.tex(,80) show(Bl_jR);
elim_lib.tex(,81) @expansion{} // ring: (0),(A,B,x,y),(wp(2,1),dp(2),C);
elim_lib.tex(,82) @expansion{} // minpoly = 0
elim_lib.tex(,83) @expansion{} // objects belonging to this ring:
elim_lib.tex(,84) @expansion{} // j_                   [0]  ideal, 1 generator(s)
elim_lib.tex(,85) setring Bl_jR;
elim_lib.tex(,86) j_;"";
elim_lib.tex(,87) @expansion{} j_[1]=2Ay-3Bx2
elim_lib.tex(,88) @expansion{} 
elim_lib.tex(,89) ring r=32003,(x,y,z),ds;
elim_lib.tex(,90) blowup0(maxideal(1),"m","T()");
elim_lib.tex(,91) @expansion{} 
elim_lib.tex(,92) @expansion{} // The proc created the ring Bl_mr (equal to r[T(1..3)])
elim_lib.tex(,93) @expansion{} // it contains the ideal m_ , such that
elim_lib.tex(,94) @expansion{} //             Bl_mr/m_ is the blowup ring
elim_lib.tex(,95) @expansion{} // show(Bl_mr); shows this ring.
elim_lib.tex(,96) @expansion{} // Make Bl_mr the basering and see m_ by typing:
elim_lib.tex(,97) @expansion{}    setring Bl_mr;
elim_lib.tex(,98) @expansion{}    m_;
elim_lib.tex(,99) show(Bl_mr);
elim_lib.tex(,100) @expansion{} // ring: (32003),(T(1),T(2),T(3),x,y,z),(wp(1,1,1),ds(3),C);
elim_lib.tex(,101) @expansion{} // minpoly = 0
elim_lib.tex(,102) @expansion{} // objects belonging to this ring:
elim_lib.tex(,103) @expansion{} // m_                   [0]  ideal, 3 generator(s)
elim_lib.tex(,104) setring Bl_mr;
elim_lib.tex(,105) m_;
elim_lib.tex(,106) @expansion{} m_[1]=T(1)y-T(2)x
elim_lib.tex(,107) @expansion{} m_[2]=T(1)z-T(3)x
elim_lib.tex(,108) @expansion{} m_[3]=T(2)z-T(3)y
elim_lib.tex(,109) kill Bl_jR, Bl_mr;
elim_lib.tex(,110) @c end example blowup0 d2t_singular/elim_lib.doc:65
elim_lib.tex(,111) @end smallexample
elim_lib.tex(,112) @c ---end content blowup0---
elim_lib.tex(,113) 
elim_lib.tex(,114) @c ------------------- elim -------------
elim_lib.tex(,115) @node elim, elim1, blowup0, elim_lib
elim_lib.tex(,116) @subsubsection elim
elim_lib.tex(,117) @cindex elim
elim_lib.tex(,118) @c ---content elim---
elim_lib.tex(,119) Procedure from library @code{elim.lib} (@pxref{elim_lib}).
elim_lib.tex(,120) 
elim_lib.tex(,121) @table @asis
elim_lib.tex(,122) @item @strong{Usage:}
elim_lib.tex(,123) elim(id,n,m); id ideal/module, n,m integers
elim_lib.tex(,124) 
elim_lib.tex(,125) @item @strong{Returns:}
elim_lib.tex(,126) ideal/module obtained from id by eliminating variables n..m
elim_lib.tex(,127) 
elim_lib.tex(,128) @item @strong{Note:}
elim_lib.tex(,129) no special monomial ordering is required, result is a SB with
elim_lib.tex(,130) respect to ordering dp (resp. ls) if the first var not to be
elim_lib.tex(,131) eliminated belongs to a -p (resp. -s) block ordering
elim_lib.tex(,132) @*This proc uses 'execute' or calls a procedure using 'execute'.
elim_lib.tex(,133) 
elim_lib.tex(,134) @end table
elim_lib.tex(,135) @strong{Example:}
elim_lib.tex(,136) @smallexample
elim_lib.tex(,137) @c computed example elim d2t_singular/elim_lib.doc:106 
elim_lib.tex(,138) LIB "elim.lib";
elim_lib.tex(,139) ring r=0,(x,y,u,v,w),dp;
elim_lib.tex(,140) ideal i=x-u,y-u2,w-u3,v-x+y3;
elim_lib.tex(,141) elim(i,3,4);
elim_lib.tex(,142) @expansion{} _[1]=y2-xw
elim_lib.tex(,143) @expansion{} _[2]=xy-w
elim_lib.tex(,144) @expansion{} _[3]=x2-y
elim_lib.tex(,145) module m=i*gen(1)+i*gen(2);
elim_lib.tex(,146) m=elim(m,3,4);show(m);
elim_lib.tex(,147) @expansion{} // module, 6 generator(s)
elim_lib.tex(,148) @expansion{} [y2-xw]
elim_lib.tex(,149) @expansion{} [0,y2-xw]
elim_lib.tex(,150) @expansion{} [xy-w]
elim_lib.tex(,151) @expansion{} [0,xy-w]
elim_lib.tex(,152) @expansion{} [x2-y]
elim_lib.tex(,153) @expansion{} [0,x2-y]
elim_lib.tex(,154) @c end example elim d2t_singular/elim_lib.doc:106
elim_lib.tex(,155) @end smallexample
elim_lib.tex(,156) @c inserted refs from d2t_singular/elim_lib.doc:115
elim_lib.tex(,169) @c end inserted refs from d2t_singular/elim_lib.doc:115
elim_lib.tex(,170) 
elim_lib.tex(,171) @c ---end content elim---
elim_lib.tex(,172) 
elim_lib.tex(,173) @c ------------------- elim1 -------------
elim_lib.tex(,174) @node elim1, nselect, elim, elim_lib
elim_lib.tex(,175) @subsubsection elim1
elim_lib.tex(,176) @cindex elim1
elim_lib.tex(,177) @c ---content elim1---
elim_lib.tex(,178) Procedure from library @code{elim.lib} (@pxref{elim_lib}).
elim_lib.tex(,179) 
elim_lib.tex(,180) @table @asis
elim_lib.tex(,181) @item @strong{Usage:}
elim_lib.tex(,182) elim1(id,p); id ideal/module, p product of vars to be eliminated
elim_lib.tex(,183) 
elim_lib.tex(,184) @item @strong{Return:}
elim_lib.tex(,185) ideal/module obtained from id by eliminating vars occurring in poly
elim_lib.tex(,186) 
elim_lib.tex(,187) @item @strong{Note:}
elim_lib.tex(,188) no special monomial ordering is required, result is a SB with
elim_lib.tex(,189) respect to ordering dp (resp. ls) if the first var not to be
elim_lib.tex(,190) eliminated belongs to a -p (resp. -s) block ordering
elim_lib.tex(,191) @*This proc uses 'execute' or calls a procedure using 'execute'.
elim_lib.tex(,192) 
elim_lib.tex(,193) @end table
elim_lib.tex(,194) @strong{Example:}
elim_lib.tex(,195) @smallexample
elim_lib.tex(,196) @c computed example elim1 d2t_singular/elim_lib.doc:144 
elim_lib.tex(,197) LIB "elim.lib";
elim_lib.tex(,198) ring r=0,(x,y,t,s,z),dp;
elim_lib.tex(,199) ideal i=x-t,y-t2,z-t3,s-x+y3;
elim_lib.tex(,200) elim1(i,ts);
elim_lib.tex(,201) @expansion{} _[1]=y2-xz
elim_lib.tex(,202) @expansion{} _[2]=xy-z
elim_lib.tex(,203) @expansion{} _[3]=x2-y
elim_lib.tex(,204) module m=i*gen(1)+i*gen(2);
elim_lib.tex(,205) m=elim1(m,st); show(m);
elim_lib.tex(,206) @expansion{} // module, 6 generator(s)
elim_lib.tex(,207) @expansion{} [y2-xz]
elim_lib.tex(,208) @expansion{} [0,y2-xz]
elim_lib.tex(,209) @expansion{} [xy-z]
elim_lib.tex(,210) @expansion{} [0,xy-z]
elim_lib.tex(,211) @expansion{} [x2-y]
elim_lib.tex(,212) @expansion{} [0,x2-y]
elim_lib.tex(,213) @c end example elim1 d2t_singular/elim_lib.doc:144
elim_lib.tex(,214) @end smallexample
elim_lib.tex(,215) @c inserted refs from d2t_singular/elim_lib.doc:153
elim_lib.tex(,228) @c end inserted refs from d2t_singular/elim_lib.doc:153
elim_lib.tex(,229) 
elim_lib.tex(,230) @c ---end content elim1---
elim_lib.tex(,231) 
elim_lib.tex(,232) @c ------------------- nselect -------------
elim_lib.tex(,233) @node nselect, sat, elim1, elim_lib
elim_lib.tex(,234) @subsubsection nselect
elim_lib.tex(,235) @cindex nselect
elim_lib.tex(,236) @c ---content nselect---
elim_lib.tex(,237) Procedure from library @code{elim.lib} (@pxref{elim_lib}).
elim_lib.tex(,238) 
elim_lib.tex(,239) @table @asis
elim_lib.tex(,240) @item @strong{Usage:}
elim_lib.tex(,241) nselect(id,n[,m]); id a module or ideal, n, m integers
elim_lib.tex(,242) 
elim_lib.tex(,243) @item @strong{Return:}
elim_lib.tex(,244) generators of id not containing the variable n [up to m]
elim_lib.tex(,245) 
elim_lib.tex(,246) @end table
elim_lib.tex(,247) @strong{Example:}
elim_lib.tex(,248) @smallexample
elim_lib.tex(,249) @c computed example nselect d2t_singular/elim_lib.doc:176 
elim_lib.tex(,250) LIB "elim.lib";
elim_lib.tex(,251) ring r=0,(x,y,t,s,z),(c,dp);
elim_lib.tex(,252) ideal i=x-y,y-z2,z-t3,s-x+y3;
elim_lib.tex(,253) nselect(i,3);
elim_lib.tex(,254) @expansion{} _[1]=x-y
elim_lib.tex(,255) @expansion{} _[2]=-z2+y
elim_lib.tex(,256) @expansion{} _[3]=y3-x+s
elim_lib.tex(,257) module m=i*(gen(1)+gen(2));
elim_lib.tex(,258) show(m);
elim_lib.tex(,259) @expansion{} // module, 4 generator(s)
elim_lib.tex(,260) @expansion{} [x-y,x-y]
elim_lib.tex(,261) @expansion{} [-z2+y,-z2+y]
elim_lib.tex(,262) @expansion{} [-t3+z,-t3+z]
elim_lib.tex(,263) @expansion{} [y3-x+s,y3-x+s]
elim_lib.tex(,264) show(nselect(m,3,4));
elim_lib.tex(,265) @expansion{} // module, 2 generator(s)
elim_lib.tex(,266) @expansion{} [x-y,x-y]
elim_lib.tex(,267) @expansion{} [-z2+y,-z2+y]
elim_lib.tex(,268) @c end example nselect d2t_singular/elim_lib.doc:176
elim_lib.tex(,269) @end smallexample
elim_lib.tex(,270) @c inserted refs from d2t_singular/elim_lib.doc:186
elim_lib.tex(,283) @c end inserted refs from d2t_singular/elim_lib.doc:186
elim_lib.tex(,284) 
elim_lib.tex(,285) @c ---end content nselect---
elim_lib.tex(,286) 
elim_lib.tex(,287) @c ------------------- sat -------------
elim_lib.tex(,288) @node sat, select, nselect, elim_lib
elim_lib.tex(,289) @subsubsection sat
elim_lib.tex(,290) @cindex sat
elim_lib.tex(,291) @c ---content sat---
elim_lib.tex(,292) Procedure from library @code{elim.lib} (@pxref{elim_lib}).
elim_lib.tex(,293) 
elim_lib.tex(,294) @table @asis
elim_lib.tex(,295) @item @strong{Usage:}
elim_lib.tex(,296) sat(id,j); id=ideal/module, j=ideal
elim_lib.tex(,297) 
elim_lib.tex(,298) @item @strong{Return:}
elim_lib.tex(,299) list of an ideal/module [1] and an integer [2]:
elim_lib.tex(,300) @*[1] = saturation of id with respect to j (= union_(k=1...) of id:j^k)
elim_lib.tex(,301) [2] = saturation exponent (= min( k | id:j^k = id:j^(k+1) ))
elim_lib.tex(,302) 
elim_lib.tex(,303) @item @strong{Note:}
elim_lib.tex(,304) [1] is a standard basis in the basering
elim_lib.tex(,305) 
elim_lib.tex(,306) @item @strong{Display:}
elim_lib.tex(,307) saturation exponent during computation if printlevel >=1
elim_lib.tex(,308) 
elim_lib.tex(,309) @end table
elim_lib.tex(,310) @strong{Example:}
elim_lib.tex(,311) @smallexample
elim_lib.tex(,312) @c computed example sat d2t_singular/elim_lib.doc:217 
elim_lib.tex(,313) LIB "elim.lib";
elim_lib.tex(,314) int p      = printlevel;
elim_lib.tex(,315) ring r     = 2,(x,y,z),dp;
elim_lib.tex(,316) poly F     = x5+y5+(x-y)^2*xyz;
elim_lib.tex(,317) ideal j    = jacob(F);
elim_lib.tex(,318) sat(j,maxideal(1));
elim_lib.tex(,319) @expansion{} [1]:
elim_lib.tex(,320) @expansion{}    _[1]=x3+x2y+xy2+y3
elim_lib.tex(,321) @expansion{}    _[2]=y4+x2yz+y3z
elim_lib.tex(,322) @expansion{}    _[3]=x2y2+x2yz+y3z
elim_lib.tex(,323) @expansion{} [2]:
elim_lib.tex(,324) @expansion{}    4
elim_lib.tex(,325) printlevel = 2;
elim_lib.tex(,326) sat(j,maxideal(2));
elim_lib.tex(,327) @expansion{} // compute quotient 1
elim_lib.tex(,328) @expansion{} // compute quotient 2
elim_lib.tex(,329) @expansion{} // compute quotient 3
elim_lib.tex(,330) @expansion{} // saturation becomes stable after 2 iteration(s)
elim_lib.tex(,331) @expansion{} 
elim_lib.tex(,332) @expansion{} [1]:
elim_lib.tex(,333) @expansion{}    _[1]=x3+x2y+xy2+y3
elim_lib.tex(,334) @expansion{}    _[2]=y4+x2yz+y3z
elim_lib.tex(,335) @expansion{}    _[3]=x2y2+x2yz+y3z
elim_lib.tex(,336) @expansion{} [2]:
elim_lib.tex(,337) @expansion{}    2
elim_lib.tex(,338) printlevel = p;
elim_lib.tex(,339) @c end example sat d2t_singular/elim_lib.doc:217
elim_lib.tex(,340) @end smallexample
elim_lib.tex(,341) @c ---end content sat---
elim_lib.tex(,342) 
elim_lib.tex(,343) @c ------------------- select -------------
elim_lib.tex(,344) @node select, select1, sat, elim_lib
elim_lib.tex(,345) @subsubsection select
elim_lib.tex(,346) @cindex select
elim_lib.tex(,347) @c ---content select---
elim_lib.tex(,348) Procedure from library @code{elim.lib} (@pxref{elim_lib}).
elim_lib.tex(,349) 
elim_lib.tex(,350) @table @asis
elim_lib.tex(,351) @item @strong{Usage:}
elim_lib.tex(,352) select(id,n[,m]); id ideal/module, n, m integers
elim_lib.tex(,353) 
elim_lib.tex(,354) @item @strong{Return:}
elim_lib.tex(,355) generators of id containing the variable n [all variables up to m]
elim_lib.tex(,356) 
elim_lib.tex(,357) @item @strong{Note:}
elim_lib.tex(,358) use 'select1' for selecting generators containing at least one of the
elim_lib.tex(,359) variables between n and m
elim_lib.tex(,360) 
elim_lib.tex(,361) @end table
elim_lib.tex(,362) @strong{Example:}
elim_lib.tex(,363) @smallexample
elim_lib.tex(,364) @c computed example select d2t_singular/elim_lib.doc:252 
elim_lib.tex(,365) LIB "elim.lib";
elim_lib.tex(,366) ring r=0,(x,y,t,s,z),(c,dp);
elim_lib.tex(,367) ideal i=x-y,y-z2,z-t3,s-x+y3;
elim_lib.tex(,368) ideal j=select(i,1);
elim_lib.tex(,369) j;
elim_lib.tex(,370) @expansion{} j[1]=x-y
elim_lib.tex(,371) @expansion{} j[2]=y3-x+s
elim_lib.tex(,372) module m=i*(gen(1)+gen(2));
elim_lib.tex(,373) m;
elim_lib.tex(,374) @expansion{} m[1]=[x-y,x-y]
elim_lib.tex(,375) @expansion{} m[2]=[-z2+y,-z2+y]
elim_lib.tex(,376) @expansion{} m[3]=[-t3+z,-t3+z]
elim_lib.tex(,377) @expansion{} m[4]=[y3-x+s,y3-x+s]
elim_lib.tex(,378) select(m,1,2);
elim_lib.tex(,379) @expansion{} _[1]=[x-y,x-y]
elim_lib.tex(,380) @expansion{} _[2]=[y3-x+s,y3-x+s]
elim_lib.tex(,381) @c end example select d2t_singular/elim_lib.doc:252
elim_lib.tex(,382) @end smallexample
elim_lib.tex(,383) @c inserted refs from d2t_singular/elim_lib.doc:263
elim_lib.tex(,396) @c end inserted refs from d2t_singular/elim_lib.doc:263
elim_lib.tex(,397) 
elim_lib.tex(,398) @c ---end content select---
elim_lib.tex(,399) 
elim_lib.tex(,400) @c ------------------- select1 -------------
elim_lib.tex(,401) @node select1,, select, elim_lib
elim_lib.tex(,402) @subsubsection select1
elim_lib.tex(,403) @cindex select1
elim_lib.tex(,404) @c ---content select1---
elim_lib.tex(,405) Procedure from library @code{elim.lib} (@pxref{elim_lib}).
elim_lib.tex(,406) 
elim_lib.tex(,407) @table @asis
elim_lib.tex(,408) @item @strong{Usage:}
elim_lib.tex(,409) select1(id,n[,m]); id ideal/module, n, m integers
elim_lib.tex(,410) 
elim_lib.tex(,411) @item @strong{Return:}
elim_lib.tex(,412) generators of id containing the variable n
elim_lib.tex(,413) @*[at least one of the variables up to m]
elim_lib.tex(,414) 
elim_lib.tex(,415) @item @strong{Note:}
elim_lib.tex(,416) use 'select' for selecting generators containing all the
elim_lib.tex(,417) variables between n and m
elim_lib.tex(,418) 
elim_lib.tex(,419) @end table
elim_lib.tex(,420) @strong{Example:}
elim_lib.tex(,421) @smallexample
elim_lib.tex(,422) @c computed example select1 d2t_singular/elim_lib.doc:291 
elim_lib.tex(,423) LIB "elim.lib";
elim_lib.tex(,424) ring r=0,(x,y,t,s,z),(c,dp);
elim_lib.tex(,425) ideal i=x-y,y-z2,z-t3,s-x+y3;
elim_lib.tex(,426) ideal j=select1(i,1);
elim_lib.tex(,427) j;
elim_lib.tex(,428) @expansion{} j[1]=x-y
elim_lib.tex(,429) @expansion{} j[2]=y3-x+s
elim_lib.tex(,430) module m=i*(gen(1)+gen(2));
elim_lib.tex(,431) m;
elim_lib.tex(,432) @expansion{} m[1]=[x-y,x-y]
elim_lib.tex(,433) @expansion{} m[2]=[-z2+y,-z2+y]
elim_lib.tex(,434) @expansion{} m[3]=[-t3+z,-t3+z]
elim_lib.tex(,435) @expansion{} m[4]=[y3-x+s,y3-x+s]
elim_lib.tex(,436) select1(m,1,2);
elim_lib.tex(,437) @expansion{} _[1]=[x-y,x-y]
elim_lib.tex(,438) @expansion{} _[2]=[-z2+y,-z2+y]
elim_lib.tex(,439) @expansion{} _[3]=[y3-x+s,y3-x+s]
elim_lib.tex(,440) @c end example select1 d2t_singular/elim_lib.doc:291
elim_lib.tex(,441) @end smallexample
elim_lib.tex(,442) @c inserted refs from d2t_singular/elim_lib.doc:302
elim_lib.tex(,455) @c end inserted refs from d2t_singular/elim_lib.doc:302
elim_lib.tex(,456) 
elim_lib.tex(,457) @c ---end content select1---
singular.texi(,381) @c ----------------------------------------------------------
singular.texi(,382) @node homolog_lib, mprimdec_lib, elim_lib, Commutative algebra
singular.texi(,383) @subsection homolog_lib
singular.texi(,384) @c include of docu for homolog.lib
homolog_lib.tex(,1) @c ---content LibInfo---
homolog_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/homolog_lib.doc
homolog_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/homolog_lib.doc INSTEAD
homolog_lib.tex(,4) @c library version: (1.15.2.2,2002/10/07)
homolog_lib.tex(,5) @c library file: ../Singular/LIB/homolog.lib
homolog_lib.tex(,6) @cindex homolog.lib
homolog_lib.tex(,7) @cindex homolog_lib
homolog_lib.tex(,8) @table @asis
homolog_lib.tex(,9) @item @strong{Library:}
homolog_lib.tex(,10) homolog.lib
homolog_lib.tex(,11) @item @strong{Purpose:}
homolog_lib.tex(,12)    Procedures for Homological Algebra
homolog_lib.tex(,13) @item @strong{Authors:}
homolog_lib.tex(,14) Gert-Martin Greuel, greuel@@mathematik.uni-kl.de,
homolog_lib.tex(,15) @* Bernd Martin, martin@@math.tu-cottbus.de
homolog_lib.tex(,16) @* Christoph Lossen, lossen@@mathematik.uni-kl.de
homolog_lib.tex(,17) 
homolog_lib.tex(,18) @end table
homolog_lib.tex(,19) 
homolog_lib.tex(,20) @strong{Procedures:}
homolog_lib.tex(,21) @menu
homolog_lib.tex(,22) * cup:: cup: Ext^1(M',M') x Ext^1() --> Ext^2()
homolog_lib.tex(,23) * cupproduct:: cup: Ext^p(M',N') x Ext^q(N',P') --> Ext^p+q(M',P')
homolog_lib.tex(,24) * depth:: depth(I,M'), I ideal, M module, M'=coker(M)
homolog_lib.tex(,25) * Ext_R:: Ext^k(M',R), M module, R basering, M'=coker(M)
homolog_lib.tex(,26) * Ext:: Ext^k(M',N'), M,N modules, M'=coker(M), N'=coker(N)
homolog_lib.tex(,27) * fitting:: n-th Fitting ideal of M'=coker(M), M module, n int
homolog_lib.tex(,28) * flatteningStrat:: Flattening stratification of M'=coker(M), M module
homolog_lib.tex(,29) * Hom:: Hom(M',N'), M,N modules, M'=coker(M), N'=coker(N)
homolog_lib.tex(,30) * homology:: ker(B)/im(A), homology of complex R^k--A->M'--B->N'
homolog_lib.tex(,31) * isCM:: test if coker(M) is Cohen-Macaulay, M module
homolog_lib.tex(,32) * isFlat:: test if coker(M) is flat, M module
homolog_lib.tex(,33) * isLocallyFree:: test if coker(M) is locally free of constant rank r
homolog_lib.tex(,34) * isReg:: test if I is coker(M)-sequence, I ideal, M module
homolog_lib.tex(,35) * kernel:: ker(M'--A->N') M,N modules, A matrix
homolog_lib.tex(,36) * kohom:: Hom(R^k,A), A matrix over basering R
homolog_lib.tex(,37) * kontrahom:: Hom(A,R^k), A matrix over basering R
homolog_lib.tex(,38) * KoszulHomology:: n-th Koszul homology H_n(I,coker(M)), I=ideal
homolog_lib.tex(,39) * tensorMod:: Tensor product of modules M'=coker(M), N'=coker(N)
homolog_lib.tex(,40) * Tor:: Tor_k(M',N'), M,N modules, M'=coker(M), N'=coker(N)
homolog_lib.tex(,41) @end menu
homolog_lib.tex(,42) @c ---end content LibInfo---
homolog_lib.tex(,43) 
homolog_lib.tex(,44) @c ------------------- cup -------------
homolog_lib.tex(,45) @node cup, cupproduct,, homolog_lib
homolog_lib.tex(,46) @subsubsection cup
homolog_lib.tex(,47) @cindex cup
homolog_lib.tex(,48) @c ---content cup---
homolog_lib.tex(,49) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,50) 
homolog_lib.tex(,51) @table @asis
homolog_lib.tex(,52) @item @strong{Usage:}
homolog_lib.tex(,53) cup(M,[,any,any]); M=module
homolog_lib.tex(,54) 
homolog_lib.tex(,55) @item @strong{Compute:}
homolog_lib.tex(,56) cup-product Ext^1(M',M') x Ext^1(M',M') ---> Ext^2(M',M'), where
homolog_lib.tex(,57) M':=R^m/M, if M in R^m, R basering (i.e. M':=coker(matrix(M))).
homolog_lib.tex(,58) @* If called with >= 2 arguments: compute symmetrized cup-product
homolog_lib.tex(,59) 
homolog_lib.tex(,60) @item @strong{Assume:}
homolog_lib.tex(,61) all Ext's are finite dimensional
homolog_lib.tex(,62) 
homolog_lib.tex(,63) @item @strong{Return:}
homolog_lib.tex(,64) - if called with 1 argument: matrix, the columns of the output present
homolog_lib.tex(,65) the coordinates of b_i&b_j with respect to a kbase of Ext^2, where
homolog_lib.tex(,66) b_1,b_2,... is a kbase of Ext^1 and & denotes cup product;@*
homolog_lib.tex(,67) - if called with 2 arguments: matrix, the columns of the output
homolog_lib.tex(,68) present the coordinates of (1/2)(b_i&b_j + b_j&b_i) with respect to
homolog_lib.tex(,69) a kbase of Ext^2;
homolog_lib.tex(,70) @*- if called with 3 arguments: list,
homolog_lib.tex(,71) @format
homolog_lib.tex(,72)       L[1] = matrix see above (symmetric case, for >=2 arguments)
homolog_lib.tex(,73)       L[2] = matrix of kbase of Ext^1
homolog_lib.tex(,74)       L[3] = matrix of kbase of Ext^2
homolog_lib.tex(,75) @end format
homolog_lib.tex(,76) 
homolog_lib.tex(,77) @item @strong{Note:}
homolog_lib.tex(,78) printlevel >=1; shows what is going on.
homolog_lib.tex(,79) @*printlevel >=2; shows result in another representation.
homolog_lib.tex(,80) @* For computing cupproduct of M itself, apply proc to syz(M)!
homolog_lib.tex(,81) 
homolog_lib.tex(,82) @end table
homolog_lib.tex(,83) @strong{Example:}
homolog_lib.tex(,84) @smallexample
homolog_lib.tex(,85) @c computed example cup d2t_singular/homolog_lib.doc:83 
homolog_lib.tex(,86) LIB "homolog.lib";
homolog_lib.tex(,87) int p      = printlevel;
homolog_lib.tex(,88) ring  rr   = 32003,(x,y,z),(dp,C);
homolog_lib.tex(,89) ideal  I   = x4+y3+z2;
homolog_lib.tex(,90) qring  o   = std(I);
homolog_lib.tex(,91) module M   = [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
homolog_lib.tex(,92) print(cup(M));
homolog_lib.tex(,93) @expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
homolog_lib.tex(,94) @expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
homolog_lib.tex(,95) @expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
homolog_lib.tex(,96) @expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
homolog_lib.tex(,97) print(cup(M,1));
homolog_lib.tex(,98) @expansion{} 0,1,0,0,0,0,0,0,0,0,0,
homolog_lib.tex(,99) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
homolog_lib.tex(,100) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
homolog_lib.tex(,101) @expansion{} 0,0,0,0,1,0,0,0,0,0,0 
homolog_lib.tex(,102) // 2nd EXAMPLE  (shows what is going on)
homolog_lib.tex(,103) printlevel = 3;
homolog_lib.tex(,104) ring   r   = 0,(x,y),(dp,C);
homolog_lib.tex(,105) ideal  i   = x2-y3;
homolog_lib.tex(,106) qring  q   = std(i);
homolog_lib.tex(,107) module M   = [-x,y],[-y2,x];
homolog_lib.tex(,108) print(cup(M));
homolog_lib.tex(,109) @expansion{} // vdim (Ext^1) = 2
homolog_lib.tex(,110) @expansion{} // kbase of Ext^1(M,M)
homolog_lib.tex(,111) @expansion{} //  - the columns present the kbase elements in Hom(F(1),F(0))
homolog_lib.tex(,112) @expansion{} //  - F(*) a free resolution of M
homolog_lib.tex(,113) @expansion{} -1,0,
homolog_lib.tex(,114) @expansion{} 0, y,
homolog_lib.tex(,115) @expansion{} 0, 1,
homolog_lib.tex(,116) @expansion{} -1,0 
homolog_lib.tex(,117) @expansion{} // lift kbase of Ext^1:
homolog_lib.tex(,118) @expansion{} //  - the columns present liftings of kbase elements into Hom(F(2),F(1))
homolog_lib.tex(,119) @expansion{} //  - F(*) a free resolution of M 
homolog_lib.tex(,120) @expansion{} 1,0,
homolog_lib.tex(,121) @expansion{} 0,y,
homolog_lib.tex(,122) @expansion{} 0,1,
homolog_lib.tex(,123) @expansion{} 1,0 
homolog_lib.tex(,124) @expansion{} // vdim (Ext^2) = 2
homolog_lib.tex(,125) @expansion{} // kbase of Ext^2(M,M)
homolog_lib.tex(,126) @expansion{} //  - the columns present the kbase elements in Hom(F(2),F(0))
homolog_lib.tex(,127) @expansion{} //  - F(*) is a a free resolution of M 
homolog_lib.tex(,128) @expansion{} -1,0,
homolog_lib.tex(,129) @expansion{} 0, y,
homolog_lib.tex(,130) @expansion{} 0, 1,
homolog_lib.tex(,131) @expansion{} -1,0 
homolog_lib.tex(,132) @expansion{} // matrix of cup-products (in Ext^2)
homolog_lib.tex(,133) @expansion{} 0,-1,0, 0,y,
homolog_lib.tex(,134) @expansion{} 0,0, -y,y,0,
homolog_lib.tex(,135) @expansion{} 0,0, -1,1,0,
homolog_lib.tex(,136) @expansion{} 0,-1,0, 0,y 
homolog_lib.tex(,137) @expansion{} ////// end level 2 //////
homolog_lib.tex(,138) @expansion{} // the associated matrices of the bilinear mapping 'cup' 
homolog_lib.tex(,139) @expansion{} // corresponding to the kbase elements of Ext^2(M,M) are shown,
homolog_lib.tex(,140) @expansion{} //  i.e. the rows of the final matrix are written as matrix of
homolog_lib.tex(,141) @expansion{} //  a bilinear form on Ext^1 x Ext^1
homolog_lib.tex(,142) @expansion{} //-----component 1:
homolog_lib.tex(,143) @expansion{} 0,1,
homolog_lib.tex(,144) @expansion{} 0,0 
homolog_lib.tex(,145) @expansion{} //-----component 2:
homolog_lib.tex(,146) @expansion{} 0, 0,
homolog_lib.tex(,147) @expansion{} -1,1 
homolog_lib.tex(,148) @expansion{} ////// end level 3 //////
homolog_lib.tex(,149) @expansion{} 0,1,0, 0,0,
homolog_lib.tex(,150) @expansion{} 0,0,-1,1,0 
homolog_lib.tex(,151) printlevel = p;
homolog_lib.tex(,152) @c end example cup d2t_singular/homolog_lib.doc:83
homolog_lib.tex(,153) @end smallexample
homolog_lib.tex(,154) @c ---end content cup---
homolog_lib.tex(,155) 
homolog_lib.tex(,156) @c ------------------- cupproduct -------------
homolog_lib.tex(,157) @node cupproduct, depth, cup, homolog_lib
homolog_lib.tex(,158) @subsubsection cupproduct
homolog_lib.tex(,159) @cindex cupproduct
homolog_lib.tex(,160) @c ---content cupproduct---
homolog_lib.tex(,161) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,162) 
homolog_lib.tex(,163) @table @asis
homolog_lib.tex(,164) @item @strong{Usage:}
homolog_lib.tex(,165) cupproduct(M,N,P,p,q[,any]); M,N,P modules, p,q integers
homolog_lib.tex(,166) 
homolog_lib.tex(,167) @item @strong{Compute:}
homolog_lib.tex(,168) cup-product Ext^p(M',N') x Ext^q(N',P') ---> Ext^p+q(M',P'),
homolog_lib.tex(,169) where M':=R^m/M, if M in R^m, R basering (i.e. M':=coker(matrix(M)))
homolog_lib.tex(,170) 
homolog_lib.tex(,171) @item @strong{Assume:}
homolog_lib.tex(,172) all Ext's are of finite dimension
homolog_lib.tex(,173) 
homolog_lib.tex(,174) @item @strong{Return:}
homolog_lib.tex(,175) - if called with 5 arguments: matrix of the associated linear map
homolog_lib.tex(,176) Ext^p (tensor) Ext^q --> Ext^p+q, i.e. the columns of <matrix>
homolog_lib.tex(,177) present the coordinates of the cup products (b_i & c_j) with respect
homolog_lib.tex(,178) to a kbase of Ext^p+q (b_i resp. c_j are the choosen bases of Ext^p,
homolog_lib.tex(,179) resp. Ext^q).@*
homolog_lib.tex(,180) - if called with 6 arguments: list L,
homolog_lib.tex(,181) @format
homolog_lib.tex(,182)       L[1] = matrix (see above)
homolog_lib.tex(,183)       L[2] = matrix of kbase of Ext^p(M',N')
homolog_lib.tex(,184)       L[3] = matrix of kbase of Ext^q(N',P')
homolog_lib.tex(,185)       L[4] = matrix of kbase of Ext^p+q(N',P')
homolog_lib.tex(,186) @end format
homolog_lib.tex(,187) 
homolog_lib.tex(,188) @item @strong{Note:}
homolog_lib.tex(,189) printlevel >=1; shows what is going on.
homolog_lib.tex(,190) @*printlevel >=2; shows the result in another representation.@*
homolog_lib.tex(,191) For computing the cupproduct of M,N itself, apply proc to syz(M),
homolog_lib.tex(,192) syz(N)!
homolog_lib.tex(,193) 
homolog_lib.tex(,194) @end table
homolog_lib.tex(,195) @strong{Example:}
homolog_lib.tex(,196) @smallexample
homolog_lib.tex(,197) @c computed example cupproduct d2t_singular/homolog_lib.doc:145 
homolog_lib.tex(,198) LIB "homolog.lib";
homolog_lib.tex(,199) int p      = printlevel;
homolog_lib.tex(,200) ring  rr   = 32003,(x,y,z),(dp,C);
homolog_lib.tex(,201) ideal  I   = x4+y3+z2;
homolog_lib.tex(,202) qring  o   = std(I);
homolog_lib.tex(,203) module M   = [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
homolog_lib.tex(,204) print(cupproduct(M,M,M,1,3));
homolog_lib.tex(,205) @expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
homolog_lib.tex(,206) @expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
homolog_lib.tex(,207) @expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
homolog_lib.tex(,208) @expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
homolog_lib.tex(,209) printlevel = 3;
homolog_lib.tex(,210) list l     = (cupproduct(M,M,M,1,3,"any"));
homolog_lib.tex(,211) @expansion{} // vdim Ext(M,N) = 4
homolog_lib.tex(,212) @expansion{} // kbase of Ext^p(M,N)
homolog_lib.tex(,213) @expansion{} //  - the columns present the kbase elements in Hom(F(p),G(0))
homolog_lib.tex(,214) @expansion{} //  - F(*),G(*) are free resolutions of M and N
homolog_lib.tex(,215) @expansion{} 0, 0, 1, 0,  
homolog_lib.tex(,216) @expansion{} 0, y, 0, 0,  
homolog_lib.tex(,217) @expansion{} 1, 0, 0, 0,  
homolog_lib.tex(,218) @expansion{} 0, 0, 0, y,  
homolog_lib.tex(,219) @expansion{} 0, -1,0, 0,  
homolog_lib.tex(,220) @expansion{} 0, 0, x2,0,  
homolog_lib.tex(,221) @expansion{} 0, 0, 0, -x2,
homolog_lib.tex(,222) @expansion{} 1, 0, 0, 0,  
homolog_lib.tex(,223) @expansion{} 0, 0, 0, -1, 
homolog_lib.tex(,224) @expansion{} -1,0, 0, 0,  
homolog_lib.tex(,225) @expansion{} 0, 1, 0, 0,  
homolog_lib.tex(,226) @expansion{} 0, 0, 1, 0,  
homolog_lib.tex(,227) @expansion{} -1,0, 0, 0,  
homolog_lib.tex(,228) @expansion{} 0, 0, 0, x2y,
homolog_lib.tex(,229) @expansion{} 0, 0, x2,0,  
homolog_lib.tex(,230) @expansion{} 0, -y,0, 0   
homolog_lib.tex(,231) @expansion{} // vdim Ext(N,P) = 4
homolog_lib.tex(,232) @expansion{} // kbase of Ext(N,P):
homolog_lib.tex(,233) @expansion{} 0, 0, 1,  0,  
homolog_lib.tex(,234) @expansion{} 0, 0, 0,  y,  
homolog_lib.tex(,235) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,236) @expansion{} 0, -y,0,  0,  
homolog_lib.tex(,237) @expansion{} 0, -1,0,  0,  
homolog_lib.tex(,238) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,239) @expansion{} 0, 0, 0,  -x2,
homolog_lib.tex(,240) @expansion{} 0, 0, -x2,0,  
homolog_lib.tex(,241) @expansion{} 0, 0, 0,  -1, 
homolog_lib.tex(,242) @expansion{} 0, 0, 1,  0,  
homolog_lib.tex(,243) @expansion{} 0, 1, 0,  0,  
homolog_lib.tex(,244) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,245) @expansion{} -1,0, 0,  0,  
homolog_lib.tex(,246) @expansion{} 0, -y,0,  0,  
homolog_lib.tex(,247) @expansion{} 0, 0, x2, 0,  
homolog_lib.tex(,248) @expansion{} 0, 0, 0,  -x2y
homolog_lib.tex(,249) @expansion{} // kbase of Ext^q(N,P)
homolog_lib.tex(,250) @expansion{} //  - the columns present the kbase elements in Hom(G(q),H(0))
homolog_lib.tex(,251) @expansion{} //  - G(*),H(*) are free resolutions of N and P
homolog_lib.tex(,252) @expansion{} 0, 0, 1,  0,  
homolog_lib.tex(,253) @expansion{} 0, 0, 0,  y,  
homolog_lib.tex(,254) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,255) @expansion{} 0, -y,0,  0,  
homolog_lib.tex(,256) @expansion{} 0, -1,0,  0,  
homolog_lib.tex(,257) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,258) @expansion{} 0, 0, 0,  -x2,
homolog_lib.tex(,259) @expansion{} 0, 0, -x2,0,  
homolog_lib.tex(,260) @expansion{} 0, 0, 0,  -1, 
homolog_lib.tex(,261) @expansion{} 0, 0, 1,  0,  
homolog_lib.tex(,262) @expansion{} 0, 1, 0,  0,  
homolog_lib.tex(,263) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,264) @expansion{} -1,0, 0,  0,  
homolog_lib.tex(,265) @expansion{} 0, -y,0,  0,  
homolog_lib.tex(,266) @expansion{} 0, 0, x2, 0,  
homolog_lib.tex(,267) @expansion{} 0, 0, 0,  -x2y
homolog_lib.tex(,268) @expansion{} // vdim Ext(M,P) = 4
homolog_lib.tex(,269) @expansion{} // kbase of Ext^p+q(M,P)
homolog_lib.tex(,270) @expansion{} //  - the columns present the kbase elements in Hom(F(p+q),H(0))
homolog_lib.tex(,271) @expansion{} //  - F(*),H(*) are free resolutions of M and P
homolog_lib.tex(,272) @expansion{} 0, 0, 1,  0,  
homolog_lib.tex(,273) @expansion{} 0, 0, 0,  y,  
homolog_lib.tex(,274) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,275) @expansion{} 0, -y,0,  0,  
homolog_lib.tex(,276) @expansion{} 0, -1,0,  0,  
homolog_lib.tex(,277) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,278) @expansion{} 0, 0, 0,  -x2,
homolog_lib.tex(,279) @expansion{} 0, 0, -x2,0,  
homolog_lib.tex(,280) @expansion{} 0, 0, 0,  -1, 
homolog_lib.tex(,281) @expansion{} 0, 0, 1,  0,  
homolog_lib.tex(,282) @expansion{} 0, 1, 0,  0,  
homolog_lib.tex(,283) @expansion{} 1, 0, 0,  0,  
homolog_lib.tex(,284) @expansion{} -1,0, 0,  0,  
homolog_lib.tex(,285) @expansion{} 0, -y,0,  0,  
homolog_lib.tex(,286) @expansion{} 0, 0, x2, 0,  
homolog_lib.tex(,287) @expansion{} 0, 0, 0,  -x2y
homolog_lib.tex(,288) @expansion{} // lifting of kbase of Ext^p(M,N)
homolog_lib.tex(,289) @expansion{} //  - the columns present liftings of kbase elements in Hom(F(p+q),G(q))
homolog_lib.tex(,290) @expansion{} 1,0, 0, 0,  
homolog_lib.tex(,291) @expansion{} 0,-y,0, 0,  
homolog_lib.tex(,292) @expansion{} 0,0, x2,0,  
homolog_lib.tex(,293) @expansion{} 0,0, 0, x2y,
homolog_lib.tex(,294) @expansion{} 0,1, 0, 0,  
homolog_lib.tex(,295) @expansion{} 1,0, 0, 0,  
homolog_lib.tex(,296) @expansion{} 0,0, 0, -x2,
homolog_lib.tex(,297) @expansion{} 0,0, x2,0,  
homolog_lib.tex(,298) @expansion{} 0,0, -1,0,  
homolog_lib.tex(,299) @expansion{} 0,0, 0, y,  
homolog_lib.tex(,300) @expansion{} 1,0, 0, 0,  
homolog_lib.tex(,301) @expansion{} 0,y, 0, 0,  
homolog_lib.tex(,302) @expansion{} 0,0, 0, -1, 
homolog_lib.tex(,303) @expansion{} 0,0, -1,0,  
homolog_lib.tex(,304) @expansion{} 0,-1,0, 0,  
homolog_lib.tex(,305) @expansion{} 1,0, 0, 0   
homolog_lib.tex(,306) @expansion{} // matrix of cup-products (in Ext^p+q)
homolog_lib.tex(,307) @expansion{} 0,0, 0, -1, 0,   0, 0, 0,   y,   1,  0,  0,  0,  0,   y,   0,  0,   
homolog_lib.tex(,308) @expansion{} 0,0, 0, 0,  y,   0, 0, y,   0,   0,  -y, 0,  0,  y,   0,   0,  0,   
homolog_lib.tex(,309) @expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
homolog_lib.tex(,310) @expansion{} 0,0, y, 0,  0,   -y,0, 0,   0,   0,  0,  0,  x2y,0,   0,   x2y,0,   
homolog_lib.tex(,311) @expansion{} 0,0, 1, 0,  0,   -1,0, 0,   0,   0,  0,  0,  x2, 0,   0,   x2, 0,   
homolog_lib.tex(,312) @expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
homolog_lib.tex(,313) @expansion{} 0,0, 0, 0,  -x2, 0, 0, -x2, 0,   0,  x2, 0,  0,  -x2, 0,   0,  0,   
homolog_lib.tex(,314) @expansion{} 0,0, 0, x2, 0,   0, 0, 0,   -x2y,-x2,0,  0,  0,  0,   -x2y,0,  0,   
homolog_lib.tex(,315) @expansion{} 0,0, 0, 0,  -1,  0, 0, -1,  0,   0,  1,  0,  0,  -1,  0,   0,  0,   
homolog_lib.tex(,316) @expansion{} 0,0, 0, -1, 0,   0, 0, 0,   y,   1,  0,  0,  0,  0,   y,   0,  0,   
homolog_lib.tex(,317) @expansion{} 0,0, -1,0,  0,   1, 0, 0,   0,   0,  0,  0,  -x2,0,   0,   -x2,0,   
homolog_lib.tex(,318) @expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
homolog_lib.tex(,319) @expansion{} 0,-1,0, 0,  0,   0, -y,0,   0,   0,  0,  -x2,0,  0,   0,   0,  x2y, 
homolog_lib.tex(,320) @expansion{} 0,0, y, 0,  0,   -y,0, 0,   0,   0,  0,  0,  x2y,0,   0,   x2y,0,   
homolog_lib.tex(,321) @expansion{} 0,0, 0, -x2,0,   0, 0, 0,   x2y, x2, 0,  0,  0,  0,   x2y, 0,  0,   
homolog_lib.tex(,322) @expansion{} 0,0, 0, 0,  -x2y,0, 0, -x2y,0,   0,  x2y,0,  0,  -x2y,0,   0,  0    
homolog_lib.tex(,323) @expansion{} ////// end level 2 //////
homolog_lib.tex(,324) @expansion{} // the associated matrices of the bilinear mapping 'cup' 
homolog_lib.tex(,325) @expansion{} // corresponding to the kbase elements of Ext^p+q(M,P) are shown,
homolog_lib.tex(,326) @expansion{} //  i.e. the rows of the final matrix are written as matrix of
homolog_lib.tex(,327) @expansion{} //  a bilinear form on Ext^p x Ext^q
homolog_lib.tex(,328) @expansion{} //----component 1:
homolog_lib.tex(,329) @expansion{} 0,1,0,0,
homolog_lib.tex(,330) @expansion{} 0,0,0,0,
homolog_lib.tex(,331) @expansion{} 0,0,0,0,
homolog_lib.tex(,332) @expansion{} 0,0,0,0 
homolog_lib.tex(,333) @expansion{} //----component 2:
homolog_lib.tex(,334) @expansion{} 0,0,-1,0,
homolog_lib.tex(,335) @expansion{} 0,1,0, 0,
homolog_lib.tex(,336) @expansion{} 0,0,0, 0,
homolog_lib.tex(,337) @expansion{} 0,0,0, 0 
homolog_lib.tex(,338) @expansion{} //----component 3:
homolog_lib.tex(,339) @expansion{} 0,0,0,-1,
homolog_lib.tex(,340) @expansion{} 0,0,0,0, 
homolog_lib.tex(,341) @expansion{} 0,1,0,0, 
homolog_lib.tex(,342) @expansion{} 0,0,0,0  
homolog_lib.tex(,343) @expansion{} //----component 4:
homolog_lib.tex(,344) @expansion{} 0,0,0, 0,
homolog_lib.tex(,345) @expansion{} 1,0,0, 1,
homolog_lib.tex(,346) @expansion{} 0,0,-1,0,
homolog_lib.tex(,347) @expansion{} 0,1,0, 0 
homolog_lib.tex(,348) @expansion{} ////// end level 3 //////
homolog_lib.tex(,349) show(l[1]);show(l[2]);
homolog_lib.tex(,350) @expansion{} // matrix, 4x17
homolog_lib.tex(,351) @expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
homolog_lib.tex(,352) @expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
homolog_lib.tex(,353) @expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
homolog_lib.tex(,354) @expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
homolog_lib.tex(,355) @expansion{} // matrix, 16x4
homolog_lib.tex(,356) @expansion{} 0, 0, 1, 0,  
homolog_lib.tex(,357) @expansion{} 0, y, 0, 0,  
homolog_lib.tex(,358) @expansion{} 1, 0, 0, 0,  
homolog_lib.tex(,359) @expansion{} 0, 0, 0, y,  
homolog_lib.tex(,360) @expansion{} 0, -1,0, 0,  
homolog_lib.tex(,361) @expansion{} 0, 0, x2,0,  
homolog_lib.tex(,362) @expansion{} 0, 0, 0, -x2,
homolog_lib.tex(,363) @expansion{} 1, 0, 0, 0,  
homolog_lib.tex(,364) @expansion{} 0, 0, 0, -1, 
homolog_lib.tex(,365) @expansion{} -1,0, 0, 0,  
homolog_lib.tex(,366) @expansion{} 0, 1, 0, 0,  
homolog_lib.tex(,367) @expansion{} 0, 0, 1, 0,  
homolog_lib.tex(,368) @expansion{} -1,0, 0, 0,  
homolog_lib.tex(,369) @expansion{} 0, 0, 0, x2y,
homolog_lib.tex(,370) @expansion{} 0, 0, x2,0,  
homolog_lib.tex(,371) @expansion{} 0, -y,0, 0   
homolog_lib.tex(,372) printlevel = p;
homolog_lib.tex(,373) @c end example cupproduct d2t_singular/homolog_lib.doc:145
homolog_lib.tex(,374) @end smallexample
homolog_lib.tex(,375) @c ---end content cupproduct---
homolog_lib.tex(,376) 
homolog_lib.tex(,377) @c ------------------- depth -------------
homolog_lib.tex(,378) @node depth, Ext_R, cupproduct, homolog_lib
homolog_lib.tex(,379) @subsubsection depth
homolog_lib.tex(,380) @cindex depth
homolog_lib.tex(,381) @c ---content depth---
homolog_lib.tex(,382) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,383) 
homolog_lib.tex(,384) @table @asis
homolog_lib.tex(,385) @item @strong{Usage:}
homolog_lib.tex(,386) depth(M,[I]); M module, I ideal
homolog_lib.tex(,387) 
homolog_lib.tex(,388) @item @strong{Return:}
homolog_lib.tex(,389) int,
homolog_lib.tex(,390) @*- if called with 1 argument: the depth of M'=coker(M) w.r.t. the
homolog_lib.tex(,391) maxideal in the basering (which is then assumed to be local)@*
homolog_lib.tex(,392) - if called with 2 arguments: the depth of M'=coker(M) w.r.t. the
homolog_lib.tex(,393) ideal I.
homolog_lib.tex(,394) 
homolog_lib.tex(,395) @item @strong{Note:}
homolog_lib.tex(,396) procedure makes use of KoszulHomology.
homolog_lib.tex(,397) 
homolog_lib.tex(,398) @end table
homolog_lib.tex(,399) @strong{Example:}
homolog_lib.tex(,400) @smallexample
homolog_lib.tex(,401) @c computed example depth d2t_singular/homolog_lib.doc:185 
homolog_lib.tex(,402) LIB "homolog.lib";
homolog_lib.tex(,403) ring R=0,(x,y,z),dp;
homolog_lib.tex(,404) ideal I=x2,xy,yz;
homolog_lib.tex(,405) module M=0;
homolog_lib.tex(,406) depth(M,I);   // depth(<x2,xy,yz>,Q[x,y,z])
homolog_lib.tex(,407) @expansion{} 2
homolog_lib.tex(,408) ring r=0,(x,y,z),ds;  // local ring
homolog_lib.tex(,409) matrix M[2][2]=x,xy,1+yz,0;
homolog_lib.tex(,410) print(M);
homolog_lib.tex(,411) @expansion{} x,   xy,
homolog_lib.tex(,412) @expansion{} 1+yz,0  
homolog_lib.tex(,413) depth(M);     // depth(maxideal,coker(M))
homolog_lib.tex(,414) @expansion{} 2
homolog_lib.tex(,415) ideal I=x;
homolog_lib.tex(,416) depth(M,I);   // depth(<x>,coker(M))
homolog_lib.tex(,417) @expansion{} 0
homolog_lib.tex(,418) I=x+z;
homolog_lib.tex(,419) depth(M,I);   // depth(<x+z>,coker(M))
homolog_lib.tex(,420) @expansion{} 1
homolog_lib.tex(,421) @c end example depth d2t_singular/homolog_lib.doc:185
homolog_lib.tex(,422) @end smallexample
homolog_lib.tex(,423) @c ---end content depth---
homolog_lib.tex(,424) 
homolog_lib.tex(,425) @c ------------------- Ext_R -------------
homolog_lib.tex(,426) @node Ext_R, Ext, depth, homolog_lib
homolog_lib.tex(,427) @subsubsection Ext_R
homolog_lib.tex(,428) @cindex Ext_R
homolog_lib.tex(,429) @c ---content Ext_R---
homolog_lib.tex(,430) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,431) 
homolog_lib.tex(,432) @table @asis
homolog_lib.tex(,433) @item @strong{Usage:}
homolog_lib.tex(,434) Ext_R(v,M[,p]); v int resp. intvec , M module, p int
homolog_lib.tex(,435) 
homolog_lib.tex(,436) @item @strong{Compute:}
homolog_lib.tex(,437) A presentation of Ext^k(M',R); for k=v[1],v[2],..., M'=coker(M).
homolog_lib.tex(,438) Let
homolog_lib.tex(,439) @smallexample
homolog_lib.tex(,440)   0 <-- M' <-- F0 <-M-- F1 <-- F2 <-- ...
homolog_lib.tex(,441) @end smallexample
homolog_lib.tex(,442) be a free resolution of M'. If
homolog_lib.tex(,443) @smallexample
homolog_lib.tex(,444)         0 --> F0* -A1-> F1* -A2-> F2* -A3-> ...
homolog_lib.tex(,445) @end smallexample
homolog_lib.tex(,446) is the dual sequence, Fi*=Hom(Fi,R), then Ext^k = ker(Ak+1)/im(Ak)
homolog_lib.tex(,447) is presented as in the following exact sequences:
homolog_lib.tex(,448) @smallexample
homolog_lib.tex(,449)     R^p --syz(Ak+1)-> Fk* ---Ak+1---->  Fk+1* ,
homolog_lib.tex(,450)     R^q ----Ext^k---> R^p --syz(Ak+1)-> Fk*/im(Ak).
homolog_lib.tex(,451) @end smallexample
homolog_lib.tex(,452) Hence, Ext^k=modulo(syz(Ak+1),Ak) presents Ext^k(M',R).
homolog_lib.tex(,453) 
homolog_lib.tex(,454) @item @strong{Return:}
homolog_lib.tex(,455) - module Ext, a presentation of Ext^k(M',R) if v is of type int@*
homolog_lib.tex(,456) - a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.@*
homolog_lib.tex(,457) - In case of a third argument of type int return a list l:
homolog_lib.tex(,458) @format
homolog_lib.tex(,459)      l[1] = module Ext^k resp. list of Ext^k
homolog_lib.tex(,460)      l[2] = SB of Ext^k resp. list of SB of Ext^k
homolog_lib.tex(,461)      l[3] = matrix resp. list of matrices, each representing a kbase of Ext^k 
homolog_lib.tex(,462)               (if finite dimensional)
homolog_lib.tex(,463) @end format
homolog_lib.tex(,464) 
homolog_lib.tex(,465) @item @strong{Display:}
homolog_lib.tex(,466) printlevel >=0: (affine) dimension of Ext^k for each k (default)
homolog_lib.tex(,467) printlevel >=1: Ak, Ak+1 and kbase of Ext^k in Fk*
homolog_lib.tex(,468) 
homolog_lib.tex(,469) @item @strong{Note:}
homolog_lib.tex(,470) In order to compute Ext^k(M,R) use the command Ext_R(k,syz(M));
homolog_lib.tex(,471) or the 2 commands: list L=mres(M,2); Ext_R(k,L[2]);
homolog_lib.tex(,472) 
homolog_lib.tex(,473) @end table
homolog_lib.tex(,474) @strong{Example:}
homolog_lib.tex(,475) @smallexample
homolog_lib.tex(,476) @c computed example Ext_R d2t_singular/homolog_lib.doc:254 
homolog_lib.tex(,477) LIB "homolog.lib";
homolog_lib.tex(,478) int p      = printlevel;
homolog_lib.tex(,479) printlevel = 1;
homolog_lib.tex(,480) ring r     = 0,(x,y,z),dp;
homolog_lib.tex(,481) ideal i    = x2y,y2z,z3x;
homolog_lib.tex(,482) module E   = Ext_R(1,i);    //computes Ext^1(r/i,r)
homolog_lib.tex(,483) @expansion{} // Computing Ext^1:
homolog_lib.tex(,484) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
homolog_lib.tex(,485) @expansion{} // then F1*-->F2* is given by:
homolog_lib.tex(,486) @expansion{} x2, -yz,0,  
homolog_lib.tex(,487) @expansion{} 0,  z3, -xy,
homolog_lib.tex(,488) @expansion{} xz2,0,  -y2 
homolog_lib.tex(,489) @expansion{} // and F0*-->F1* is given by:
homolog_lib.tex(,490) @expansion{} y2z,
homolog_lib.tex(,491) @expansion{} x2y,
homolog_lib.tex(,492) @expansion{} xz3 
homolog_lib.tex(,493) @expansion{} 
homolog_lib.tex(,494) @expansion{} // dimension of Ext^1:  -1
homolog_lib.tex(,495) @expansion{} 
homolog_lib.tex(,496) is_zero(E);
homolog_lib.tex(,497) @expansion{} 1
homolog_lib.tex(,498) qring R    = std(x2+yz);
homolog_lib.tex(,499) intvec v   = 0,2;
homolog_lib.tex(,500) printlevel = 2;             //shows what is going on
homolog_lib.tex(,501) ideal i    = x,y,z;         //computes Ext^i(r/(x,y,z),r/(x2+yz)), i=0,2
homolog_lib.tex(,502) list L     = Ext_R(v,i,1);  //over the qring R=r/(x2+yz), std and kbase
homolog_lib.tex(,503) @expansion{} // Computing Ext^0:
homolog_lib.tex(,504) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
homolog_lib.tex(,505) @expansion{} // then F0*-->F1* is given by:
homolog_lib.tex(,506) @expansion{} z,
homolog_lib.tex(,507) @expansion{} y,
homolog_lib.tex(,508) @expansion{} x 
homolog_lib.tex(,509) @expansion{} // and F-1*-->F0* is given by:
homolog_lib.tex(,510) @expansion{} 0
homolog_lib.tex(,511) @expansion{} 
homolog_lib.tex(,512) @expansion{} // dimension of Ext^0:  -1
homolog_lib.tex(,513) @expansion{} 
homolog_lib.tex(,514) @expansion{} // columns of matrix are kbase of Ext^0 in F0*:
homolog_lib.tex(,515) @expansion{} 0
homolog_lib.tex(,516) @expansion{} 
homolog_lib.tex(,517) @expansion{} // Computing Ext^2:
homolog_lib.tex(,518) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
homolog_lib.tex(,519) @expansion{} // then F2*-->F3* is given by:
homolog_lib.tex(,520) @expansion{} x,-y,z, 0,
homolog_lib.tex(,521) @expansion{} z,x, 0, z,
homolog_lib.tex(,522) @expansion{} 0,0, x, y,
homolog_lib.tex(,523) @expansion{} 0,0, -z,x 
homolog_lib.tex(,524) @expansion{} // and F1*-->F2* is given by:
homolog_lib.tex(,525) @expansion{} y,-z,0, 
homolog_lib.tex(,526) @expansion{} x,0, -z,
homolog_lib.tex(,527) @expansion{} 0,x, -y,
homolog_lib.tex(,528) @expansion{} 0,z, x  
homolog_lib.tex(,529) @expansion{} 
homolog_lib.tex(,530) @expansion{} // dimension of Ext^2:  0
homolog_lib.tex(,531) @expansion{} // vdim of Ext^2:       1
homolog_lib.tex(,532) @expansion{} 
homolog_lib.tex(,533) @expansion{} // columns of matrix are kbase of Ext^2 in F2*:
homolog_lib.tex(,534) @expansion{} x, 
homolog_lib.tex(,535) @expansion{} -z,
homolog_lib.tex(,536) @expansion{} 0, 
homolog_lib.tex(,537) @expansion{} 0  
homolog_lib.tex(,538) @expansion{} 
homolog_lib.tex(,539) printlevel = p;
homolog_lib.tex(,540) @c end example Ext_R d2t_singular/homolog_lib.doc:254
homolog_lib.tex(,541) @end smallexample
homolog_lib.tex(,542) @c ---end content Ext_R---
homolog_lib.tex(,543) 
homolog_lib.tex(,544) @c ------------------- Ext -------------
homolog_lib.tex(,545) @node Ext, fitting, Ext_R, homolog_lib
homolog_lib.tex(,546) @subsubsection Ext
homolog_lib.tex(,547) @cindex Ext
homolog_lib.tex(,548) @c ---content Ext---
homolog_lib.tex(,549) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,550) 
homolog_lib.tex(,551) @table @asis
homolog_lib.tex(,552) @item @strong{Usage:}
homolog_lib.tex(,553) Ext(v,M,N[,any]); v int resp. intvec, M,N modules
homolog_lib.tex(,554) 
homolog_lib.tex(,555) @item @strong{Compute:}
homolog_lib.tex(,556) A presentation of Ext^k(M',N'); for k=v[1],v[2],... where
homolog_lib.tex(,557) M'=coker(M) and N'=coker(N). Let
homolog_lib.tex(,558) @smallexample
homolog_lib.tex(,559)        0 <-- M' <-- F0 <-M-- F1 <-- F2 <--... ,   
homolog_lib.tex(,560)        0 <-- N' <-- G0 <--N- G1
homolog_lib.tex(,561) @end smallexample
homolog_lib.tex(,562) be a free resolution of M', resp. a presentation of N'. Consider
homolog_lib.tex(,563) the commutative diagram
homolog_lib.tex(,564) @smallexample
homolog_lib.tex(,565)            0                  0                  0
homolog_lib.tex(,566)            |^                 |^                 |^
homolog_lib.tex(,567)    --> Hom(Fk-1,N') -Ak-> Hom(Fk,N') -Ak+1-> Hom(Fk+1,N')
homolog_lib.tex(,568)            |^                 |^                 |^
homolog_lib.tex(,569)    --> Hom(Fk-1,G0) -Ak-> Hom(Fk,G0) -Ak+1-> Hom(Fk+1,G0)
homolog_lib.tex(,570)                               |^                 |^
homolog_lib.tex(,571)                               |C                 |B
homolog_lib.tex(,572)                           Hom(Fk,G1) ------> Hom(Fk+1,G1)
homolog_lib.tex(,573) 
homolog_lib.tex(,574)       (Ak,Ak+1 induced by M and B,C induced by N).
homolog_lib.tex(,575) @end smallexample
homolog_lib.tex(,576) Let K=modulo(Ak+1,B), J=module(Ak)+module(C) and Ext=modulo(K,J),
homolog_lib.tex(,577) then we have exact sequences
homolog_lib.tex(,578) @smallexample
homolog_lib.tex(,579)     R^p --K-> Hom(Fk,G0) --Ak+1-> Hom(Fk+1,G0)/im(B),
homolog_lib.tex(,580) 
homolog_lib.tex(,581)     R^q -Ext-> R^p --K-> Hom(Fk,G0)/(im(Ak)+im(C)).
homolog_lib.tex(,582) @end smallexample
homolog_lib.tex(,583) Hence, Ext presents Ext^k(M',N').
homolog_lib.tex(,584) 
homolog_lib.tex(,585) @item @strong{Return:}
homolog_lib.tex(,586) - module Ext, a presentation of Ext^k(M',N') if v is of type int@*
homolog_lib.tex(,587) - a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.@*
homolog_lib.tex(,588) - In case of a third argument of any type return a list l:
homolog_lib.tex(,589) @format
homolog_lib.tex(,590)              l[1] = module Ext/list of Ext^k
homolog_lib.tex(,591)              l[2] = SB of Ext/list of SB of Ext^k
homolog_lib.tex(,592)              l[3] = matrix/list of matrices, each representing a kbase of Ext^k
homolog_lib.tex(,593)                        (if finite dimensional)
homolog_lib.tex(,594) @end format
homolog_lib.tex(,595) 
homolog_lib.tex(,596) @item @strong{Display:}
homolog_lib.tex(,597) printlevel >=0: dimension, vdim of Ext^k for each k (default).
homolog_lib.tex(,598) @* printlevel >=1: matrices Ak, Ak+1 and kbase of Ext^k in Hom(Fk,G0)
homolog_lib.tex(,599) (if finite dimensional)
homolog_lib.tex(,600) 
homolog_lib.tex(,601) @item @strong{Note:}
homolog_lib.tex(,602) In order to compute Ext^k(M,N) use the command Ext(k,syz(M),syz(N));
homolog_lib.tex(,603) or: list P=mres(M,2); list Q=mres(N,2); Ext(k,P[2],Q[2]);
homolog_lib.tex(,604) 
homolog_lib.tex(,605) @end table
homolog_lib.tex(,606) @strong{Example:}
homolog_lib.tex(,607) @smallexample
homolog_lib.tex(,608) @c computed example Ext d2t_singular/homolog_lib.doc:336 
homolog_lib.tex(,609) LIB "homolog.lib";
homolog_lib.tex(,610) int p      = printlevel;
homolog_lib.tex(,611) printlevel = 1;
homolog_lib.tex(,612) ring r     = 0,(x,y),dp;
homolog_lib.tex(,613) ideal i    = x2-y3;
homolog_lib.tex(,614) ideal j    = x2-y5;
homolog_lib.tex(,615) list E     = Ext(0..2,i,j);    // Ext^k(r/i,r/j) for k=0,1,2 over r
homolog_lib.tex(,616) @expansion{} // Computing Ext^0 (help Ext; gives an explanation):
homolog_lib.tex(,617) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
homolog_lib.tex(,618) @expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
homolog_lib.tex(,619) @expansion{} // then Hom(F0,G0)-->Hom(F1,G0) is given by:
homolog_lib.tex(,620) @expansion{} y3-x2
homolog_lib.tex(,621) @expansion{} // and Hom(F-1,G0) + Hom(F0,G1)-->Hom(F0,G0) is given by:
homolog_lib.tex(,622) @expansion{} 0,-y5+x2
homolog_lib.tex(,623) @expansion{} 
homolog_lib.tex(,624) @expansion{} // dimension of Ext^0:  -1
homolog_lib.tex(,625) @expansion{} 
homolog_lib.tex(,626) @expansion{} // Computing Ext^1 (help Ext; gives an explanation):
homolog_lib.tex(,627) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
homolog_lib.tex(,628) @expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
homolog_lib.tex(,629) @expansion{} // then Hom(F1,G0)-->Hom(F2,G0) is given by:
homolog_lib.tex(,630) @expansion{} 0
homolog_lib.tex(,631) @expansion{} // and Hom(F0,G0) + Hom(F1,G1)-->Hom(F1,G0) is given by:
homolog_lib.tex(,632) @expansion{} y3-x2,-y5+x2
homolog_lib.tex(,633) @expansion{} 
homolog_lib.tex(,634) @expansion{} // dimension of Ext^1:  0
homolog_lib.tex(,635) @expansion{} // vdim of Ext^1:       10
homolog_lib.tex(,636) @expansion{} 
homolog_lib.tex(,637) @expansion{} // Computing Ext^2 (help Ext; gives an explanation):
homolog_lib.tex(,638) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
homolog_lib.tex(,639) @expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
homolog_lib.tex(,640) @expansion{} // then Hom(F2,G0)-->Hom(F3,G0) is given by:
homolog_lib.tex(,641) @expansion{} 1
homolog_lib.tex(,642) @expansion{} // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
homolog_lib.tex(,643) @expansion{} 0,-y5+x2
homolog_lib.tex(,644) @expansion{} 
homolog_lib.tex(,645) @expansion{} // dimension of Ext^2:  -1
homolog_lib.tex(,646) @expansion{} 
homolog_lib.tex(,647) qring R    = std(i);
homolog_lib.tex(,648) ideal j    = fetch(r,j);
homolog_lib.tex(,649) module M   = [-x,y],[-y2,x];
homolog_lib.tex(,650) printlevel = 2;
homolog_lib.tex(,651) module E1  = Ext(1,M,j);       // Ext^1(R^2/M,R/j) over R=r/i
homolog_lib.tex(,652) @expansion{} // Computing Ext^1 (help Ext; gives an explanation):
homolog_lib.tex(,653) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
homolog_lib.tex(,654) @expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
homolog_lib.tex(,655) @expansion{} // then Hom(F1,G0)-->Hom(F2,G0) is given by:
homolog_lib.tex(,656) @expansion{} x, -y,
homolog_lib.tex(,657) @expansion{} y2,-x 
homolog_lib.tex(,658) @expansion{} // and Hom(F0,G0) + Hom(F1,G1)-->Hom(F1,G0) is given by:
homolog_lib.tex(,659) @expansion{} x, -y,-y5+x2,0,    
homolog_lib.tex(,660) @expansion{} y2,-x,0,     -y5+x2
homolog_lib.tex(,661) @expansion{} 
homolog_lib.tex(,662) @expansion{} // dimension of Ext^1:  -1
homolog_lib.tex(,663) @expansion{} 
homolog_lib.tex(,664) list l     = Ext(4,M,M,1);     // Ext^4(R^2/M,R^2/M) over R=r/i
homolog_lib.tex(,665) @expansion{} // Computing Ext^4 (help Ext; gives an explanation):
homolog_lib.tex(,666) @expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
homolog_lib.tex(,667) @expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
homolog_lib.tex(,668) @expansion{} // then Hom(F4,G0)-->Hom(F5,G0) is given by:
homolog_lib.tex(,669) @expansion{} x, -y,0, 0, 
homolog_lib.tex(,670) @expansion{} y2,-x,0, 0, 
homolog_lib.tex(,671) @expansion{} 0, 0, x, -y,
homolog_lib.tex(,672) @expansion{} 0, 0, y2,-x 
homolog_lib.tex(,673) @expansion{} // and Hom(F3,G0) + Hom(F4,G1)-->Hom(F4,G0) is given by:
homolog_lib.tex(,674) @expansion{} x, -y,0, 0, -x,0, -y2,0,  
homolog_lib.tex(,675) @expansion{} y2,-x,0, 0, 0, -x,0,  -y2,
homolog_lib.tex(,676) @expansion{} 0, 0, x, -y,y, 0, x,  0,  
homolog_lib.tex(,677) @expansion{} 0, 0, y2,-x,0, y, 0,  x   
homolog_lib.tex(,678) @expansion{} 
homolog_lib.tex(,679) @expansion{} // dimension of Ext^4:  0
homolog_lib.tex(,680) @expansion{} // vdim of Ext^4:       2
homolog_lib.tex(,681) @expansion{} 
homolog_lib.tex(,682) @expansion{} // columns of matrix are kbase of Ext^4 in Hom(F4,G0)
homolog_lib.tex(,683) @expansion{} 1,0,
homolog_lib.tex(,684) @expansion{} 0,y,
homolog_lib.tex(,685) @expansion{} 0,1,
homolog_lib.tex(,686) @expansion{} 1,0 
homolog_lib.tex(,687) @expansion{} 
homolog_lib.tex(,688) @expansion{} // element 1 of kbase of Ext^4 in Hom(F4,G0)
homolog_lib.tex(,689) @expansion{} // as matrix: F4-->G0
homolog_lib.tex(,690) @expansion{} 1,0,
homolog_lib.tex(,691) @expansion{} 0,1 
homolog_lib.tex(,692) @expansion{} // element 2 of kbase of Ext^4 in Hom(F4,G0)
homolog_lib.tex(,693) @expansion{} // as matrix: F4-->G0
homolog_lib.tex(,694) @expansion{} 0,y,
homolog_lib.tex(,695) @expansion{} 1,0 
homolog_lib.tex(,696) @expansion{} 
homolog_lib.tex(,697) printlevel = p;
homolog_lib.tex(,698) @c end example Ext d2t_singular/homolog_lib.doc:336
homolog_lib.tex(,699) @end smallexample
homolog_lib.tex(,700) @c ---end content Ext---
homolog_lib.tex(,701) 
homolog_lib.tex(,702) @c ------------------- fitting -------------
homolog_lib.tex(,703) @node fitting, flatteningStrat, Ext, homolog_lib
homolog_lib.tex(,704) @subsubsection fitting
homolog_lib.tex(,705) @cindex fitting
homolog_lib.tex(,706) @c ---content fitting---
homolog_lib.tex(,707) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,708) 
homolog_lib.tex(,709) @table @asis
homolog_lib.tex(,710) @item @strong{Usage:}
homolog_lib.tex(,711) fitting (M,n); M module, n int
homolog_lib.tex(,712) 
homolog_lib.tex(,713) @item @strong{Return:}
homolog_lib.tex(,714) ideal, (standard basis of) n-th Fitting ideal of M'=coker(M).
homolog_lib.tex(,715) 
homolog_lib.tex(,716) @end table
homolog_lib.tex(,717) @strong{Example:}
homolog_lib.tex(,718) @smallexample
homolog_lib.tex(,719) @c computed example fitting d2t_singular/homolog_lib.doc:372 
homolog_lib.tex(,720) LIB "homolog.lib";
homolog_lib.tex(,721) ring R=0,x(0..4),dp;
homolog_lib.tex(,722) matrix M[2][4]=x(0),x(1),x(2),x(3),x(1),x(2),x(3),x(4);
homolog_lib.tex(,723) print(M);
homolog_lib.tex(,724) @expansion{} x(0),x(1),x(2),x(3),
homolog_lib.tex(,725) @expansion{} x(1),x(2),x(3),x(4) 
homolog_lib.tex(,726) fitting(M,-1);
homolog_lib.tex(,727) @expansion{} _[1]=0
homolog_lib.tex(,728) fitting(M,0);
homolog_lib.tex(,729) @expansion{} _[1]=x(3)^2-x(2)*x(4)
homolog_lib.tex(,730) @expansion{} _[2]=x(2)*x(3)-x(1)*x(4)
homolog_lib.tex(,731) @expansion{} _[3]=x(1)*x(3)-x(0)*x(4)
homolog_lib.tex(,732) @expansion{} _[4]=x(2)^2-x(0)*x(4)
homolog_lib.tex(,733) @expansion{} _[5]=x(1)*x(2)-x(0)*x(3)
homolog_lib.tex(,734) @expansion{} _[6]=x(1)^2-x(0)*x(2)
homolog_lib.tex(,735) fitting(M,1);
homolog_lib.tex(,736) @expansion{} _[1]=x(4)
homolog_lib.tex(,737) @expansion{} _[2]=x(3)
homolog_lib.tex(,738) @expansion{} _[3]=x(2)
homolog_lib.tex(,739) @expansion{} _[4]=x(1)
homolog_lib.tex(,740) @expansion{} _[5]=x(0)
homolog_lib.tex(,741) fitting(M,2);
homolog_lib.tex(,742) @expansion{} _[1]=1
homolog_lib.tex(,743) @c end example fitting d2t_singular/homolog_lib.doc:372
homolog_lib.tex(,744) @end smallexample
homolog_lib.tex(,745) @c ---end content fitting---
homolog_lib.tex(,746) 
homolog_lib.tex(,747) @c ------------------- flatteningStrat -------------
homolog_lib.tex(,748) @node flatteningStrat, Hom, fitting, homolog_lib
homolog_lib.tex(,749) @subsubsection flatteningStrat
homolog_lib.tex(,750) @cindex flatteningStrat
homolog_lib.tex(,751) @c ---content flatteningStrat---
homolog_lib.tex(,752) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,753) 
homolog_lib.tex(,754) @table @asis
homolog_lib.tex(,755) @item @strong{Usage:}
homolog_lib.tex(,756) flatteningStrat(M); M module
homolog_lib.tex(,757) 
homolog_lib.tex(,758) @item @strong{Return:}
homolog_lib.tex(,759) list of ideals.
homolog_lib.tex(,760) @*The list entries L[1],...,L[r] describe the flattening stratification
homolog_lib.tex(,761) of M'=coker(M): setting L[0]=0, L[r+1]=1, the flattening
homolog_lib.tex(,762) stratification is given by the open sets Spec(A/V(L[i-1])) \ V(L[i]),
homolog_lib.tex(,763) i=1,...,r+1 (A = basering).
homolog_lib.tex(,764) 
homolog_lib.tex(,765) @item @strong{Note:}
homolog_lib.tex(,766) for more information see the book 'A Singular Introduction to
homolog_lib.tex(,767) Commutative Algebra' (by Greuel/Pfister, Springer 2002).
homolog_lib.tex(,768) 
homolog_lib.tex(,769) @end table
homolog_lib.tex(,770) @strong{Example:}
homolog_lib.tex(,771) @smallexample
homolog_lib.tex(,772) @c computed example flatteningStrat d2t_singular/homolog_lib.doc:410 
homolog_lib.tex(,773) LIB "homolog.lib";
homolog_lib.tex(,774) ring A = 0,x(0..4),dp;
homolog_lib.tex(,775) // presentation matrix:
homolog_lib.tex(,776) matrix M[2][4] = x(0),x(1),x(2),x(3),x(1),x(2),x(3),x(4);
homolog_lib.tex(,777) list L = flatteningStrat(M);
homolog_lib.tex(,778) L;
homolog_lib.tex(,779) @expansion{} [1]:
homolog_lib.tex(,780) @expansion{}    _[1]=x(3)^2-x(2)*x(4)
homolog_lib.tex(,781) @expansion{}    _[2]=x(2)*x(3)-x(1)*x(4)
homolog_lib.tex(,782) @expansion{}    _[3]=x(1)*x(3)-x(0)*x(4)
homolog_lib.tex(,783) @expansion{}    _[4]=x(2)^2-x(0)*x(4)
homolog_lib.tex(,784) @expansion{}    _[5]=x(1)*x(2)-x(0)*x(3)
homolog_lib.tex(,785) @expansion{}    _[6]=x(1)^2-x(0)*x(2)
homolog_lib.tex(,786) @expansion{} [2]:
homolog_lib.tex(,787) @expansion{}    _[1]=x(4)
homolog_lib.tex(,788) @expansion{}    _[2]=x(3)
homolog_lib.tex(,789) @expansion{}    _[3]=x(2)
homolog_lib.tex(,790) @expansion{}    _[4]=x(1)
homolog_lib.tex(,791) @expansion{}    _[5]=x(0)
homolog_lib.tex(,792) @c end example flatteningStrat d2t_singular/homolog_lib.doc:410
homolog_lib.tex(,793) @end smallexample
homolog_lib.tex(,794) @c ---end content flatteningStrat---
homolog_lib.tex(,795) 
homolog_lib.tex(,796) @c ------------------- Hom -------------
homolog_lib.tex(,797) @node Hom, homology, flatteningStrat, homolog_lib
homolog_lib.tex(,798) @subsubsection Hom
homolog_lib.tex(,799) @cindex Hom
homolog_lib.tex(,800) @c ---content Hom---
homolog_lib.tex(,801) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,802) 
homolog_lib.tex(,803) @table @asis
homolog_lib.tex(,804) @item @strong{Usage:}
homolog_lib.tex(,805) Hom(M,N,[any]); M,N=modules
homolog_lib.tex(,806) 
homolog_lib.tex(,807) @item @strong{Compute:}
homolog_lib.tex(,808) A presentation of Hom(M',N'), M'=coker(M), N'=coker(N) as follows:
homolog_lib.tex(,809) let
homolog_lib.tex(,810) @smallexample
homolog_lib.tex(,811)    F1 --M-> F0 -->M' --> 0,    G1 --N-> G0 --> N' --> 0  
homolog_lib.tex(,812) @end smallexample
homolog_lib.tex(,813) be presentations of M' and N'. Consider
homolog_lib.tex(,814) @smallexample
homolog_lib.tex(,815)                                   0               0
homolog_lib.tex(,816)                                   |^              |^
homolog_lib.tex(,817)        0 --> Hom(M',N') ----> Hom(F0,N') ----> Hom(F1,N')
homolog_lib.tex(,818)                                   |^              |^
homolog_lib.tex(,819)   (A:  induced by M)          Hom(F0,G0) --A-> Hom(F1,G0)
homolog_lib.tex(,820)                                   |^              |^
homolog_lib.tex(,821)   (B,C:induced by N)              |C              |B
homolog_lib.tex(,822)                               Hom(F0,G1) ----> Hom(F1,G1)
homolog_lib.tex(,823) 
homolog_lib.tex(,824) @end smallexample
homolog_lib.tex(,825) Let D=modulo(A,B) and Hom=modulo(D,C), then we have exact sequences
homolog_lib.tex(,826) @smallexample
homolog_lib.tex(,827)    R^p  --D-> Hom(F0,G0) --A-> Hom(F1,G0)/im(B),
homolog_lib.tex(,828) 
homolog_lib.tex(,829)  R^q -Hom-> R^p --D-> Hom(F0,G0)/im(C) --A-> Hom(F1,G0)/im(B).
homolog_lib.tex(,830) @end smallexample
homolog_lib.tex(,831) Hence Hom presents Hom(M',N')
homolog_lib.tex(,832) 
homolog_lib.tex(,833) @item @strong{Return:}
homolog_lib.tex(,834) module Hom, a presentation of Hom(M',N'), resp., in case of
homolog_lib.tex(,835) 3 arguments, a list l (of size <=3):
homolog_lib.tex(,836) @format
homolog_lib.tex(,837)            - l[1] = Hom
homolog_lib.tex(,838)            - l[2] = SB of Hom
homolog_lib.tex(,839)            - l[3] = kbase of coker(Hom) (if finite dimensional, not 0),
homolog_lib.tex(,840)                     represented by elements in Hom(F0,G0) via mapping D
homolog_lib.tex(,841) @end format
homolog_lib.tex(,842) 
homolog_lib.tex(,843) @item @strong{Display:}
homolog_lib.tex(,844) printlevel >=0: (affine) dimension of Hom (default)
homolog_lib.tex(,845) @* printlevel >=1: D and C and kbase of coker(Hom) in Hom(F0,G0)
homolog_lib.tex(,846) @* printlevel >=2: elements of kbase of coker(Hom) as matrix :F0-->G0
homolog_lib.tex(,847) 
homolog_lib.tex(,848) @item @strong{Note:}
homolog_lib.tex(,849) DISPLAY is as described only for a direct call of 'Hom'. Calling 'Hom'
homolog_lib.tex(,850) from another proc has the same effect as decreasing printlevel by 1.
homolog_lib.tex(,851) 
homolog_lib.tex(,852) @end table
homolog_lib.tex(,853) @strong{Example:}
homolog_lib.tex(,854) @smallexample
homolog_lib.tex(,855) @c computed example Hom d2t_singular/homolog_lib.doc:480 
homolog_lib.tex(,856) LIB "homolog.lib";
homolog_lib.tex(,857) int p     = printlevel;
homolog_lib.tex(,858) printlevel= 1;   //in 'example proc' printlevel has to be increased by 1
homolog_lib.tex(,859) ring r    = 0,(x,y),dp;
homolog_lib.tex(,860) ideal i   = x2-y3,xy;
homolog_lib.tex(,861) qring q   = std(i);
homolog_lib.tex(,862) ideal i   = fetch(r,i);
homolog_lib.tex(,863) module M  = [-x,y],[-y2,x],[x3];
homolog_lib.tex(,864) module H  = Hom(M,i);
homolog_lib.tex(,865) @expansion{} // dimension of Hom:  0
homolog_lib.tex(,866) @expansion{} // vdim of Hom:       5
homolog_lib.tex(,867) @expansion{} 
homolog_lib.tex(,868) @expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
homolog_lib.tex(,869) @expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
homolog_lib.tex(,870) @expansion{} y,x, 0,
homolog_lib.tex(,871) @expansion{} x,y2,x2
homolog_lib.tex(,872) @expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
homolog_lib.tex(,873) @expansion{} -y3+x2,0,     xy,0,
homolog_lib.tex(,874) @expansion{} 0,     -y3+x2,0, xy
homolog_lib.tex(,875) @expansion{} 
homolog_lib.tex(,876) print(H);
homolog_lib.tex(,877) @expansion{} 0, x, 0,y2,0, 
homolog_lib.tex(,878) @expansion{} y, 0, 0,-x,x2,
homolog_lib.tex(,879) @expansion{} -1,-1,x,0, 0  
homolog_lib.tex(,880) printlevel= 2;
homolog_lib.tex(,881) list L    = Hom(M,i,1);"";
homolog_lib.tex(,882) @expansion{} // dimension of Hom:  0
homolog_lib.tex(,883) @expansion{} // vdim of Hom:       5
homolog_lib.tex(,884) @expansion{} 
homolog_lib.tex(,885) @expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
homolog_lib.tex(,886) @expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
homolog_lib.tex(,887) @expansion{} y,x, 0,
homolog_lib.tex(,888) @expansion{} x,y2,x2
homolog_lib.tex(,889) @expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
homolog_lib.tex(,890) @expansion{} -y3+x2,0,     xy,0,
homolog_lib.tex(,891) @expansion{} 0,     -y3+x2,0, xy
homolog_lib.tex(,892) @expansion{} 
homolog_lib.tex(,893) @expansion{} // element 1 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
homolog_lib.tex(,894) @expansion{} y2,xy
homolog_lib.tex(,895) @expansion{} // element 2 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
homolog_lib.tex(,896) @expansion{} y,x
homolog_lib.tex(,897) @expansion{} // element 3 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
homolog_lib.tex(,898) @expansion{} x2,xy2
homolog_lib.tex(,899) @expansion{} // element 4 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
homolog_lib.tex(,900) @expansion{} x,y2
homolog_lib.tex(,901) @expansion{} // element 5 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
homolog_lib.tex(,902) @expansion{} 0,x2
homolog_lib.tex(,903) @expansion{} 
homolog_lib.tex(,904) printlevel=1;
homolog_lib.tex(,905) ring s    = 3,(x,y,z),(c,dp);
homolog_lib.tex(,906) ideal i   = jacob(ideal(x2+y5+z4));
homolog_lib.tex(,907) qring rq=std(i);
homolog_lib.tex(,908) matrix M[2][2]=xy,x3,5y,4z,x2;
homolog_lib.tex(,909) matrix N[3][2]=x2,x,y3,3xz,x2z,z;
homolog_lib.tex(,910) print(M);
homolog_lib.tex(,911) @expansion{} xy,x3,
homolog_lib.tex(,912) @expansion{} -y,z  
homolog_lib.tex(,913) print(N);
homolog_lib.tex(,914) @expansion{} x2, x,
homolog_lib.tex(,915) @expansion{} y3, 0,
homolog_lib.tex(,916) @expansion{} x2z,z 
homolog_lib.tex(,917) list l=Hom(M,N,1);
homolog_lib.tex(,918) @expansion{} // dimension of Hom:  0
homolog_lib.tex(,919) @expansion{} // vdim of Hom:       16
homolog_lib.tex(,920) @expansion{} 
homolog_lib.tex(,921) @expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
homolog_lib.tex(,922) @expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
homolog_lib.tex(,923) @expansion{} 0,0, 0,0, 0,   0,0,   1,
homolog_lib.tex(,924) @expansion{} 0,0, 0,0, 0,   0,y3z2,0,
homolog_lib.tex(,925) @expansion{} 0,0, 0,0, 0,   1,0,   0,
homolog_lib.tex(,926) @expansion{} 0,0, 0,y3,y2z2,0,0,   0,
homolog_lib.tex(,927) @expansion{} 0,0, 1,0, 0,   0,0,   0,
homolog_lib.tex(,928) @expansion{} z,y3,0,0, 0,   0,0,   0 
homolog_lib.tex(,929) @expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
homolog_lib.tex(,930) @expansion{} x2, 0,  x,0,
homolog_lib.tex(,931) @expansion{} 0,  x2, 0,x,
homolog_lib.tex(,932) @expansion{} y3, 0,  0,0,
homolog_lib.tex(,933) @expansion{} 0,  y3, 0,0,
homolog_lib.tex(,934) @expansion{} x2z,0,  z,0,
homolog_lib.tex(,935) @expansion{} 0,  x2z,0,z 
homolog_lib.tex(,936) @expansion{} 
homolog_lib.tex(,937) @expansion{} // columns of matrix are kbase of Hom in Hom(F0,G0)
homolog_lib.tex(,938) @expansion{} 0, 0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,0,   
homolog_lib.tex(,939) @expansion{} 0, 0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,y3z2,
homolog_lib.tex(,940) @expansion{} 0, 0, 0, 0,0,0,   y2z2,yz2,z2,y2z,yz,z,y2,y,1,0,   
homolog_lib.tex(,941) @expansion{} 0, 0, 0, 0,0,y2z2,0,   0,  0, 0,  0, 0,0, 0,0,0,   
homolog_lib.tex(,942) @expansion{} 0, y3,y2,y,1,0,   0,   0,  0, 0,  0, 0,0, 0,0,0,   
homolog_lib.tex(,943) @expansion{} y3,0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,0    
homolog_lib.tex(,944) printlevel = p;
homolog_lib.tex(,945) @c end example Hom d2t_singular/homolog_lib.doc:480
homolog_lib.tex(,946) @end smallexample
homolog_lib.tex(,947) @c ---end content Hom---
homolog_lib.tex(,948) 
homolog_lib.tex(,949) @c ------------------- homology -------------
homolog_lib.tex(,950) @node homology, isCM, Hom, homolog_lib
homolog_lib.tex(,951) @subsubsection homology
homolog_lib.tex(,952) @cindex homology
homolog_lib.tex(,953) @c ---content homology---
homolog_lib.tex(,954) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,955) 
homolog_lib.tex(,956) @table @asis
homolog_lib.tex(,957) @item @strong{Usage:}
homolog_lib.tex(,958) homology(A,B,M,N);
homolog_lib.tex(,959) 
homolog_lib.tex(,960) @item @strong{Compute:}
homolog_lib.tex(,961) Let M and N be submodules of R^m and R^n presenting M'=R^m/M, N'=R^n/N
homolog_lib.tex(,962) (R=basering) and let A,B matrices inducing maps
homolog_lib.tex(,963) @smallexample
homolog_lib.tex(,964)     R^k --A--> R^m --B--> R^n.
homolog_lib.tex(,965) @end smallexample
homolog_lib.tex(,966) Compute a presentation of the module
homolog_lib.tex(,967) @smallexample
homolog_lib.tex(,968)     ker(B)/im(A) := ker(M'/im(A) --B--> N'/im(BM)+im(BA)).
homolog_lib.tex(,969) @end smallexample
homolog_lib.tex(,970) If B induces a map M'-->N' (i.e BM=0) and if im(A) is contained in
homolog_lib.tex(,971) ker(B) (that is, BA=0) then ker(B)/im(A) is the homology of the
homolog_lib.tex(,972) complex
homolog_lib.tex(,973) @smallexample
homolog_lib.tex(,974)     R^k--A-->M'--B-->N'. 
homolog_lib.tex(,975) @end smallexample
homolog_lib.tex(,976) 
homolog_lib.tex(,977) @item @strong{Return:}
homolog_lib.tex(,978) module H, a presentation of ker(B)/im(A).
homolog_lib.tex(,979) 
homolog_lib.tex(,980) @item @strong{Note:}
homolog_lib.tex(,981) homology returns a free module of rank m if ker(B)=im(A).
homolog_lib.tex(,982) 
homolog_lib.tex(,983) @end table
homolog_lib.tex(,984) @strong{Example:}
homolog_lib.tex(,985) @smallexample
homolog_lib.tex(,986) @c computed example homology d2t_singular/homolog_lib.doc:544 
homolog_lib.tex(,987) LIB "homolog.lib";
homolog_lib.tex(,988) ring r;
homolog_lib.tex(,989) ideal id=maxideal(4);
homolog_lib.tex(,990) qring qr=std(id);
homolog_lib.tex(,991) module N=maxideal(3)*freemodule(2);
homolog_lib.tex(,992) module M=maxideal(2)*freemodule(2);
homolog_lib.tex(,993) module B=[2x,0],[x,y],[z2,y];
homolog_lib.tex(,994) module A=M;
homolog_lib.tex(,995) module H=homology(A,B,M,N);
homolog_lib.tex(,996) H=std(H);
homolog_lib.tex(,997) // dimension of homology:
homolog_lib.tex(,998) dim(H);
homolog_lib.tex(,999) @expansion{} 0
homolog_lib.tex(,1000) // vector space dimension: 
homolog_lib.tex(,1001) vdim(H);
homolog_lib.tex(,1002) @expansion{} 19
homolog_lib.tex(,1003) ring s=0,x,ds;
homolog_lib.tex(,1004) qring qs=std(x4);
homolog_lib.tex(,1005) module A=[x];
homolog_lib.tex(,1006) module B=A;
homolog_lib.tex(,1007) module M=[x3];
homolog_lib.tex(,1008) module N=M;
homolog_lib.tex(,1009) homology(A,B,M,N);
homolog_lib.tex(,1010) @expansion{} _[1]=gen(1)
homolog_lib.tex(,1011) @c end example homology d2t_singular/homolog_lib.doc:544
homolog_lib.tex(,1012) @end smallexample
homolog_lib.tex(,1013) @c ---end content homology---
homolog_lib.tex(,1014) 
homolog_lib.tex(,1015) @c ------------------- isCM -------------
homolog_lib.tex(,1016) @node isCM, isFlat, homology, homolog_lib
homolog_lib.tex(,1017) @subsubsection isCM
homolog_lib.tex(,1018) @cindex isCM
homolog_lib.tex(,1019) @c ---content isCM---
homolog_lib.tex(,1020) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1021) 
homolog_lib.tex(,1022) @table @asis
homolog_lib.tex(,1023) @item @strong{Usage:}
homolog_lib.tex(,1024) isCM(M); M module
homolog_lib.tex(,1025) 
homolog_lib.tex(,1026) @item @strong{Return:}
homolog_lib.tex(,1027) 1 if M'=coker(M) is Cohen-Macaulay;@*
homolog_lib.tex(,1028) 0 if this is not the case.
homolog_lib.tex(,1029) 
homolog_lib.tex(,1030) @item @strong{Assume:}
homolog_lib.tex(,1031) basering is local.
homolog_lib.tex(,1032) 
homolog_lib.tex(,1033) @end table
homolog_lib.tex(,1034) @strong{Example:}
homolog_lib.tex(,1035) @smallexample
homolog_lib.tex(,1036) @c computed example isCM d2t_singular/homolog_lib.doc:591 
homolog_lib.tex(,1037) LIB "homolog.lib";
homolog_lib.tex(,1038) ring R=0,(x,y,z),ds;  // local ring R = Q[x,y,z]_<x,y,z>
homolog_lib.tex(,1039) module M=xz,yz,z2;   
homolog_lib.tex(,1040) isCM(M);             // test if R/<xz,yz,z2> is Cohen-Macaulay
homolog_lib.tex(,1041) @expansion{} 0
homolog_lib.tex(,1042) M=x2+y2,z7;          // test if R/<x2+y2,z7> is Cohen-Macaulay
homolog_lib.tex(,1043) isCM(M);
homolog_lib.tex(,1044) @expansion{} 1
homolog_lib.tex(,1045) @c end example isCM d2t_singular/homolog_lib.doc:591
homolog_lib.tex(,1046) @end smallexample
homolog_lib.tex(,1047) @c ---end content isCM---
homolog_lib.tex(,1048) 
homolog_lib.tex(,1049) @c ------------------- isFlat -------------
homolog_lib.tex(,1050) @node isFlat, isLocallyFree, isCM, homolog_lib
homolog_lib.tex(,1051) @subsubsection isFlat
homolog_lib.tex(,1052) @cindex isFlat
homolog_lib.tex(,1053) @c ---content isFlat---
homolog_lib.tex(,1054) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1055) 
homolog_lib.tex(,1056) @table @asis
homolog_lib.tex(,1057) @item @strong{Usage:}
homolog_lib.tex(,1058) isFlat(M); M module
homolog_lib.tex(,1059) 
homolog_lib.tex(,1060) @item @strong{Return:}
homolog_lib.tex(,1061) 1 if M'=coker(M) is flat;@*
homolog_lib.tex(,1062) 0 if this is not the case.
homolog_lib.tex(,1063) 
homolog_lib.tex(,1064) @end table
homolog_lib.tex(,1065) @strong{Example:}
homolog_lib.tex(,1066) @smallexample
homolog_lib.tex(,1067) @c computed example isFlat d2t_singular/homolog_lib.doc:620 
homolog_lib.tex(,1068) LIB "homolog.lib";
homolog_lib.tex(,1069) ring A = 0,(x,y),dp;
homolog_lib.tex(,1070) matrix M[3][3] = x-1,y,x,x,x+1,y,x2,xy+x+1,x2+y;
homolog_lib.tex(,1071) print(M);
homolog_lib.tex(,1072) @expansion{} x-1,y,     x,  
homolog_lib.tex(,1073) @expansion{} x,  x+1,   y,  
homolog_lib.tex(,1074) @expansion{} x2, xy+x+1,x2+y
homolog_lib.tex(,1075) isFlat(M);             // coker(M) is not flat over A=Q[x,y]
homolog_lib.tex(,1076) @expansion{} 0
homolog_lib.tex(,1077) qring B = std(x2+x-y);   // the ring B=Q[x,y]/<x2+x-y>
homolog_lib.tex(,1078) matrix M = fetch(A,M);
homolog_lib.tex(,1079) isFlat(M);             // coker(M) is flat over B
homolog_lib.tex(,1080) @expansion{} 1
homolog_lib.tex(,1081) setring A;
homolog_lib.tex(,1082) qring C = std(x2+x+y);   // the ring C=Q[x,y]/<x2+x+y>
homolog_lib.tex(,1083) matrix M = fetch(A,M);
homolog_lib.tex(,1084) isFlat(M);             // coker(M) is not flat over C
homolog_lib.tex(,1085) @expansion{} 0
homolog_lib.tex(,1086) @c end example isFlat d2t_singular/homolog_lib.doc:620
homolog_lib.tex(,1087) @end smallexample
homolog_lib.tex(,1088) @c ---end content isFlat---
homolog_lib.tex(,1089) 
homolog_lib.tex(,1090) @c ------------------- isLocallyFree -------------
homolog_lib.tex(,1091) @node isLocallyFree, isReg, isFlat, homolog_lib
homolog_lib.tex(,1092) @subsubsection isLocallyFree
homolog_lib.tex(,1093) @cindex isLocallyFree
homolog_lib.tex(,1094) @c ---content isLocallyFree---
homolog_lib.tex(,1095) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1096) 
homolog_lib.tex(,1097) @table @asis
homolog_lib.tex(,1098) @item @strong{Usage:}
homolog_lib.tex(,1099) isLocallyFree(M,r); M module, r int
homolog_lib.tex(,1100) 
homolog_lib.tex(,1101) @item @strong{Return:}
homolog_lib.tex(,1102) 1 if M'=coker(M) is locally free of constant rank r;@*
homolog_lib.tex(,1103) 0 if this is not the case.
homolog_lib.tex(,1104) 
homolog_lib.tex(,1105) @end table
homolog_lib.tex(,1106) @strong{Example:}
homolog_lib.tex(,1107) @smallexample
homolog_lib.tex(,1108) @c computed example isLocallyFree d2t_singular/homolog_lib.doc:655 
homolog_lib.tex(,1109) LIB "homolog.lib";
homolog_lib.tex(,1110) ring R=0,(x,y,z),dp;
homolog_lib.tex(,1111) matrix M[2][3];     // the presentation matrix
homolog_lib.tex(,1112) M=x-1,y-1,z,y-1,x-2,x;
homolog_lib.tex(,1113) ideal I=fitting(M,0); // 0-th Fitting ideal of coker(M)
homolog_lib.tex(,1114) qring Q=I;
homolog_lib.tex(,1115) matrix M=fetch(R,M);
homolog_lib.tex(,1116) isLocallyFree(M,1); // as R/I-module, coker(M) is locally free of rk 1
homolog_lib.tex(,1117) @expansion{} 1
homolog_lib.tex(,1118) isLocallyFree(M,0);
homolog_lib.tex(,1119) @expansion{} 0
homolog_lib.tex(,1120) @c end example isLocallyFree d2t_singular/homolog_lib.doc:655
homolog_lib.tex(,1121) @end smallexample
homolog_lib.tex(,1122) @c ---end content isLocallyFree---
homolog_lib.tex(,1123) 
homolog_lib.tex(,1124) @c ------------------- isReg -------------
homolog_lib.tex(,1125) @node isReg, kernel, isLocallyFree, homolog_lib
homolog_lib.tex(,1126) @subsubsection isReg
homolog_lib.tex(,1127) @cindex isReg
homolog_lib.tex(,1128) @c ---content isReg---
homolog_lib.tex(,1129) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1130) 
homolog_lib.tex(,1131) @table @asis
homolog_lib.tex(,1132) @item @strong{Usage:}
homolog_lib.tex(,1133) isReg(I,M); I ideal, M module
homolog_lib.tex(,1134) 
homolog_lib.tex(,1135) @item @strong{Return:}
homolog_lib.tex(,1136) 1 if given (ordered) list of generators for I is coker(M)-sequence;@*
homolog_lib.tex(,1137) 0 if this is not the case.
homolog_lib.tex(,1138) 
homolog_lib.tex(,1139) @end table
homolog_lib.tex(,1140) @strong{Example:}
homolog_lib.tex(,1141) @smallexample
homolog_lib.tex(,1142) @c computed example isReg d2t_singular/homolog_lib.doc:687 
homolog_lib.tex(,1143) LIB "homolog.lib";
homolog_lib.tex(,1144) ring R = 0,(x,y,z),dp;
homolog_lib.tex(,1145) ideal I = x*(y-1),y,z*(y-1);
homolog_lib.tex(,1146) isReg(I,0);             // given list of generators is Q[x,y,z]-sequence
homolog_lib.tex(,1147) @expansion{} 1
homolog_lib.tex(,1148) I = x*(y-1),z*(y-1),y;  // change sorting of generators 
homolog_lib.tex(,1149) isReg(I,0);
homolog_lib.tex(,1150) @expansion{} 0
homolog_lib.tex(,1151) ring r = 0,(x,y,z),ds;  // local ring
homolog_lib.tex(,1152) ideal I=fetch(R,I);
homolog_lib.tex(,1153) isReg(I,0);             // result independent of sorting of generators
homolog_lib.tex(,1154) @expansion{} 1
homolog_lib.tex(,1155) @c end example isReg d2t_singular/homolog_lib.doc:687
homolog_lib.tex(,1156) @end smallexample
homolog_lib.tex(,1157) @c ---end content isReg---
homolog_lib.tex(,1158) 
homolog_lib.tex(,1159) @c ------------------- kernel -------------
homolog_lib.tex(,1160) @node kernel, kohom, isReg, homolog_lib
homolog_lib.tex(,1161) @subsubsection kernel
homolog_lib.tex(,1162) @cindex kernel
homolog_lib.tex(,1163) @c ---content kernel---
homolog_lib.tex(,1164) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1165) 
homolog_lib.tex(,1166) @table @asis
homolog_lib.tex(,1167) @item @strong{Usage:}
homolog_lib.tex(,1168) kernel(A,M,N);
homolog_lib.tex(,1169) 
homolog_lib.tex(,1170) @item @strong{Compute:}
homolog_lib.tex(,1171) Let M and N be submodules of R^m and R^n, presenting M'=R^m/M,
homolog_lib.tex(,1172) N'=R^n/N (R=basering), and let A:R^m-->R^n be a matrix inducing a
homolog_lib.tex(,1173) map A':M'-->N'. Then kernel(A,M,N); computes a presentation K of
homolog_lib.tex(,1174) ker(A') as in the commutative diagram:
homolog_lib.tex(,1175) @smallexample
homolog_lib.tex(,1176)           ker(A') --->  M' --A'--> N'
homolog_lib.tex(,1177)              |^         |^         |^
homolog_lib.tex(,1178)              |          |          |
homolog_lib.tex(,1179)              R^r  ---> R^m --A--> R^n
homolog_lib.tex(,1180)              |^         |^         |^
homolog_lib.tex(,1181)              |K         |M         |N
homolog_lib.tex(,1182)              |          |          |
homolog_lib.tex(,1183)              R^s  ---> R^p -----> R^q
homolog_lib.tex(,1184) @end smallexample
homolog_lib.tex(,1185) 
homolog_lib.tex(,1186) @item @strong{Return:}
homolog_lib.tex(,1187) module K, a presentation of ker(A':coker(M)->coker(N)).
homolog_lib.tex(,1188) 
homolog_lib.tex(,1189) @end table
homolog_lib.tex(,1190) @strong{Example:}
homolog_lib.tex(,1191) @smallexample
homolog_lib.tex(,1192) @c computed example kernel d2t_singular/homolog_lib.doc:734 
homolog_lib.tex(,1193) LIB "homolog.lib";
homolog_lib.tex(,1194) ring r;
homolog_lib.tex(,1195) module N=[2x,x],[0,y];
homolog_lib.tex(,1196) module M=maxideal(1)*freemodule(2);
homolog_lib.tex(,1197) matrix A[2][2]=2x,0,x,y,z2,y;
homolog_lib.tex(,1198) module K=kernel(A,M,N);
homolog_lib.tex(,1199) // dimension of kernel:  
homolog_lib.tex(,1200) dim(std(K));
homolog_lib.tex(,1201) @expansion{} 0
homolog_lib.tex(,1202) // vector space dimension of kernel: 
homolog_lib.tex(,1203) vdim(std(K));
homolog_lib.tex(,1204) @expansion{} 2
homolog_lib.tex(,1205) print(K);
homolog_lib.tex(,1206) @expansion{} z,0,y,0,x,0,
homolog_lib.tex(,1207) @expansion{} 0,z,0,y,0,x 
homolog_lib.tex(,1208) @c end example kernel d2t_singular/homolog_lib.doc:734
homolog_lib.tex(,1209) @end smallexample
homolog_lib.tex(,1210) @c ---end content kernel---
homolog_lib.tex(,1211) 
homolog_lib.tex(,1212) @c ------------------- kohom -------------
homolog_lib.tex(,1213) @node kohom, kontrahom, kernel, homolog_lib
homolog_lib.tex(,1214) @subsubsection kohom
homolog_lib.tex(,1215) @cindex kohom
homolog_lib.tex(,1216) @c ---content kohom---
homolog_lib.tex(,1217) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1218) 
homolog_lib.tex(,1219) @table @asis
homolog_lib.tex(,1220) @item @strong{Usage:}
homolog_lib.tex(,1221) kohom(A,k); A=matrix, k=integer
homolog_lib.tex(,1222) 
homolog_lib.tex(,1223) @item @strong{Return:}
homolog_lib.tex(,1224) matrix Hom(R^k,A), i.e. let A be a matrix defining a map F1-->F2
homolog_lib.tex(,1225) of free R-modules, then the matrix of Hom(R^k,F1)-->Hom(R^k,F2)
homolog_lib.tex(,1226) is computed (R=basering).
homolog_lib.tex(,1227) 
homolog_lib.tex(,1228) @end table
homolog_lib.tex(,1229) @strong{Example:}
homolog_lib.tex(,1230) @smallexample
homolog_lib.tex(,1231) @c computed example kohom d2t_singular/homolog_lib.doc:769 
homolog_lib.tex(,1232) LIB "homolog.lib";
homolog_lib.tex(,1233) ring r;
homolog_lib.tex(,1234) matrix n[2][3]=x,y,5,z,77,33;
homolog_lib.tex(,1235) print(kohom(n,3));
homolog_lib.tex(,1236) @expansion{} x,0,0,y, 0, 0, 5, 0, 0,
homolog_lib.tex(,1237) @expansion{} 0,x,0,0, y, 0, 0, 5, 0,
homolog_lib.tex(,1238) @expansion{} 0,0,x,0, 0, y, 0, 0, 5,
homolog_lib.tex(,1239) @expansion{} z,0,0,77,0, 0, 33,0, 0,
homolog_lib.tex(,1240) @expansion{} 0,z,0,0, 77,0, 0, 33,0,
homolog_lib.tex(,1241) @expansion{} 0,0,z,0, 0, 77,0, 0, 33
homolog_lib.tex(,1242) @c end example kohom d2t_singular/homolog_lib.doc:769
homolog_lib.tex(,1243) @end smallexample
homolog_lib.tex(,1244) @c ---end content kohom---
homolog_lib.tex(,1245) 
homolog_lib.tex(,1246) @c ------------------- kontrahom -------------
homolog_lib.tex(,1247) @node kontrahom, KoszulHomology, kohom, homolog_lib
homolog_lib.tex(,1248) @subsubsection kontrahom
homolog_lib.tex(,1249) @cindex kontrahom
homolog_lib.tex(,1250) @c ---content kontrahom---
homolog_lib.tex(,1251) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1252) 
homolog_lib.tex(,1253) @table @asis
homolog_lib.tex(,1254) @item @strong{Usage:}
homolog_lib.tex(,1255) kontrahom(A,k); A=matrix, k=integer
homolog_lib.tex(,1256) 
homolog_lib.tex(,1257) @item @strong{Return:}
homolog_lib.tex(,1258) matrix Hom(A,R^k), i.e. let A be a matrix defining a map F1-->F2 of
homolog_lib.tex(,1259) free R-modules, then the matrix of Hom(F2,R^k)-->Hom(F1,R^k) is
homolog_lib.tex(,1260) computed (R=basering).
homolog_lib.tex(,1261) 
homolog_lib.tex(,1262) @end table
homolog_lib.tex(,1263) @strong{Example:}
homolog_lib.tex(,1264) @smallexample
homolog_lib.tex(,1265) @c computed example kontrahom d2t_singular/homolog_lib.doc:797 
homolog_lib.tex(,1266) LIB "homolog.lib";
homolog_lib.tex(,1267) ring r;
homolog_lib.tex(,1268) matrix n[2][3]=x,y,5,z,77,33;
homolog_lib.tex(,1269) print(kontrahom(n,3));
homolog_lib.tex(,1270) @expansion{} x,z, 0,0, 0,0, 
homolog_lib.tex(,1271) @expansion{} y,77,0,0, 0,0, 
homolog_lib.tex(,1272) @expansion{} 5,33,0,0, 0,0, 
homolog_lib.tex(,1273) @expansion{} 0,0, x,z, 0,0, 
homolog_lib.tex(,1274) @expansion{} 0,0, y,77,0,0, 
homolog_lib.tex(,1275) @expansion{} 0,0, 5,33,0,0, 
homolog_lib.tex(,1276) @expansion{} 0,0, 0,0, x,z, 
homolog_lib.tex(,1277) @expansion{} 0,0, 0,0, y,77,
homolog_lib.tex(,1278) @expansion{} 0,0, 0,0, 5,33 
homolog_lib.tex(,1279) @c end example kontrahom d2t_singular/homolog_lib.doc:797
homolog_lib.tex(,1280) @end smallexample
homolog_lib.tex(,1281) @c ---end content kontrahom---
homolog_lib.tex(,1282) 
homolog_lib.tex(,1283) @c ------------------- KoszulHomology -------------
homolog_lib.tex(,1284) @node KoszulHomology, tensorMod, kontrahom, homolog_lib
homolog_lib.tex(,1285) @subsubsection KoszulHomology
homolog_lib.tex(,1286) @cindex KoszulHomology
homolog_lib.tex(,1287) @c ---content KoszulHomology---
homolog_lib.tex(,1288) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1289) 
homolog_lib.tex(,1290) @table @asis
homolog_lib.tex(,1291) @item @strong{Compute:}
homolog_lib.tex(,1292) A presentation of the p-th Koszul homology module H_p(f_1,...,f_k;M'),
homolog_lib.tex(,1293) where M'=coker(M) and f_1,...,f_k are the given (ordered list
homolog_lib.tex(,1294) of generators of the) ideal I. The computed presentation is minimized
homolog_lib.tex(,1295) via prune. In particular, if H_p(f_1,...,f_k;M')=0 then the
homolog_lib.tex(,1296) return value is 0.
homolog_lib.tex(,1297) 
homolog_lib.tex(,1298) @item @strong{Return:}
homolog_lib.tex(,1299) module H, s.th. coker(H) = H_p(f_1,...,f_k;M').
homolog_lib.tex(,1300) 
homolog_lib.tex(,1301) @item @strong{Note:}
homolog_lib.tex(,1302) size of input ideal has to be <= 20.
homolog_lib.tex(,1303) 
homolog_lib.tex(,1304) @end table
homolog_lib.tex(,1305) @strong{Example:}
homolog_lib.tex(,1306) @smallexample
homolog_lib.tex(,1307) @c computed example KoszulHomology d2t_singular/homolog_lib.doc:830 
homolog_lib.tex(,1308) LIB "homolog.lib";
homolog_lib.tex(,1309) ring R=0,x(1..3),dp;
homolog_lib.tex(,1310) ideal x=maxideal(1);
homolog_lib.tex(,1311) module M=0;
homolog_lib.tex(,1312) KoszulHomology(x,M,0);  // H_0(x,R), x=(x_1,x_2,x_3)
homolog_lib.tex(,1313) @expansion{} _[1]=x(3)*gen(1)
homolog_lib.tex(,1314) @expansion{} _[2]=x(2)*gen(1)
homolog_lib.tex(,1315) @expansion{} _[3]=x(1)*gen(1)
homolog_lib.tex(,1316) KoszulHomology(x,M,1);  // H_1(x,R), x=(x_1,x_2,x_3)
homolog_lib.tex(,1317) @expansion{} _[1]=0
homolog_lib.tex(,1318) qring S=std(x(1)*x(2));
homolog_lib.tex(,1319) module M=0;
homolog_lib.tex(,1320) ideal x=maxideal(1);
homolog_lib.tex(,1321) KoszulHomology(x,M,1);
homolog_lib.tex(,1322) @expansion{} _[1]=-x(3)*gen(1)
homolog_lib.tex(,1323) @expansion{} _[2]=-x(2)*gen(1)
homolog_lib.tex(,1324) @expansion{} _[3]=-x(1)*gen(1)
homolog_lib.tex(,1325) KoszulHomology(x,M,2);
homolog_lib.tex(,1326) @expansion{} _[1]=0
homolog_lib.tex(,1327) @c end example KoszulHomology d2t_singular/homolog_lib.doc:830
homolog_lib.tex(,1328) @end smallexample
homolog_lib.tex(,1329) @c ---end content KoszulHomology---
homolog_lib.tex(,1330) 
homolog_lib.tex(,1331) @c ------------------- tensorMod -------------
homolog_lib.tex(,1332) @node tensorMod, Tor, KoszulHomology, homolog_lib
homolog_lib.tex(,1333) @subsubsection tensorMod
homolog_lib.tex(,1334) @cindex tensorMod
homolog_lib.tex(,1335) @c ---content tensorMod---
homolog_lib.tex(,1336) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1337) 
homolog_lib.tex(,1338) @table @asis
homolog_lib.tex(,1339) @item @strong{Usage:}
homolog_lib.tex(,1340) tensorMod(M,N); M,N modules
homolog_lib.tex(,1341) 
homolog_lib.tex(,1342) @item @strong{Compute:}
homolog_lib.tex(,1343) presentation matrix A of the tensor product T of the modules
homolog_lib.tex(,1344) M'=coker(M), N'=coker(N): if matrix(M) defines a map M: R^r-->R^s and
homolog_lib.tex(,1345) matrix(N) defines a map N: R^p-->R^q, then A defines a presentation
homolog_lib.tex(,1346) @smallexample
homolog_lib.tex(,1347)          R^(sp+rq) --A-> R^(sq)  --> T --> 0 .
homolog_lib.tex(,1348) @end smallexample
homolog_lib.tex(,1349) 
homolog_lib.tex(,1350) @item @strong{Return:}
homolog_lib.tex(,1351) matrix A satisfying coker(A) = tensorprod(coker(M),coker(N)) .
homolog_lib.tex(,1352) 
homolog_lib.tex(,1353) @end table
homolog_lib.tex(,1354) @strong{Example:}
homolog_lib.tex(,1355) @smallexample
homolog_lib.tex(,1356) @c computed example tensorMod d2t_singular/homolog_lib.doc:871 
homolog_lib.tex(,1357) LIB "homolog.lib";
homolog_lib.tex(,1358) ring A=0,(x,y,z),dp;
homolog_lib.tex(,1359) matrix M[3][3]=1,2,3,4,5,6,7,8,9;
homolog_lib.tex(,1360) matrix N[2][2]=x,y,0,z;
homolog_lib.tex(,1361) print(M);
homolog_lib.tex(,1362) @expansion{} 1,2,3,
homolog_lib.tex(,1363) @expansion{} 4,5,6,
homolog_lib.tex(,1364) @expansion{} 7,8,9 
homolog_lib.tex(,1365) print(N);
homolog_lib.tex(,1366) @expansion{} x,y,
homolog_lib.tex(,1367) @expansion{} 0,z 
homolog_lib.tex(,1368) print(tensorMod(M,N));
homolog_lib.tex(,1369) @expansion{} x,y,0,0,0,0,1,0,2,0,3,0,
homolog_lib.tex(,1370) @expansion{} 0,z,0,0,0,0,0,1,0,2,0,3,
homolog_lib.tex(,1371) @expansion{} 0,0,x,y,0,0,4,0,5,0,6,0,
homolog_lib.tex(,1372) @expansion{} 0,0,0,z,0,0,0,4,0,5,0,6,
homolog_lib.tex(,1373) @expansion{} 0,0,0,0,x,y,7,0,8,0,9,0,
homolog_lib.tex(,1374) @expansion{} 0,0,0,0,0,z,0,7,0,8,0,9 
homolog_lib.tex(,1375) @c end example tensorMod d2t_singular/homolog_lib.doc:871
homolog_lib.tex(,1376) @end smallexample
homolog_lib.tex(,1377) @c ---end content tensorMod---
homolog_lib.tex(,1378) 
homolog_lib.tex(,1379) @c ------------------- Tor -------------
homolog_lib.tex(,1380) @node Tor,, tensorMod, homolog_lib
homolog_lib.tex(,1381) @subsubsection Tor
homolog_lib.tex(,1382) @cindex Tor
homolog_lib.tex(,1383) @c ---content Tor---
homolog_lib.tex(,1384) Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).
homolog_lib.tex(,1385) 
homolog_lib.tex(,1386) @table @asis
homolog_lib.tex(,1387) @item @strong{Compute:}
homolog_lib.tex(,1388) a presentation of Tor_k(M',N'), for k=v[1],v[2],... , where
homolog_lib.tex(,1389) M'=coker(M) and N'=coker(N): let
homolog_lib.tex(,1390) @smallexample
homolog_lib.tex(,1391)        0 <-- M' <-- G0 <-M-- G1                
homolog_lib.tex(,1392)        0 <-- N' <-- F0 <--N- F1 <-- F2 <--...  
homolog_lib.tex(,1393) @end smallexample
homolog_lib.tex(,1394) be a presentation of M', resp. a free resolution of N', and consider
homolog_lib.tex(,1395) the commutative diagram
homolog_lib.tex(,1396) @smallexample
homolog_lib.tex(,1397)           0                    0                    0
homolog_lib.tex(,1398)           |^                   |^                   |^
homolog_lib.tex(,1399)   Tensor(M',Fk+1) -Ak+1-> Tensor(M',Fk) -Ak-> Tensor(M',Fk-1)
homolog_lib.tex(,1400)           |^                   |^                   |^
homolog_lib.tex(,1401)   Tensor(G0,Fk+1) -Ak+1-> Tensor(G0,Fk) -Ak-> Tensor(G0,Fk-1)
homolog_lib.tex(,1402)                                |^                   |^
homolog_lib.tex(,1403)                                |C                   |B
homolog_lib.tex(,1404)                           Tensor(G1,Fk) ----> Tensor(G1,Fk-1)
homolog_lib.tex(,1405) 
homolog_lib.tex(,1406)        (Ak,Ak+1 induced by N and B,C induced by M).
homolog_lib.tex(,1407) @end smallexample
homolog_lib.tex(,1408) Let K=modulo(Ak,B), J=module(C)+module(Ak+1) and Tor=modulo(K,J),
homolog_lib.tex(,1409) then we have exact sequences
homolog_lib.tex(,1410) @smallexample
homolog_lib.tex(,1411)     R^p  --K-> Tensor(G0,Fk) --Ak-> Tensor(G0,Fk-1)/im(B),
homolog_lib.tex(,1412) 
homolog_lib.tex(,1413)     R^q -Tor-> R^p --K-> Tensor(G0,Fk)/(im(C)+im(Ak+1)). 
homolog_lib.tex(,1414) @end smallexample
homolog_lib.tex(,1415) Hence, Tor presents Tor_k(M',N').
homolog_lib.tex(,1416) 
homolog_lib.tex(,1417) @item @strong{Return:}
homolog_lib.tex(,1418) - if v is of type int: module Tor, a presentation of Tor_k(M',N');@*
homolog_lib.tex(,1419) - if v is of type intvec: a list of Tor_k(M',N') (k=v[1],v[2],...);@*
homolog_lib.tex(,1420) - in case of a third argument of any type: list l with
homolog_lib.tex(,1421) @format
homolog_lib.tex(,1422)      l[1] = module Tor/list of Tor_k(M',N'),
homolog_lib.tex(,1423)      l[2] = SB of Tor/list of SB of Tor_k(M',N'),
homolog_lib.tex(,1424)      l[3] = matrix/list of matrices, each representing a kbase of Tor_k(M',N')
homolog_lib.tex(,1425)                 (if finite dimensional), or 0.
homolog_lib.tex(,1426) @end format
homolog_lib.tex(,1427) 
homolog_lib.tex(,1428) @item @strong{Display:}
homolog_lib.tex(,1429) printlevel >=0: (affine) dimension of Tor_k for each k (default).
homolog_lib.tex(,1430) @* printlevel >=1: matrices Ak, Ak+1 and kbase of Tor_k in Tensor(G0,Fk)
homolog_lib.tex(,1431) (if finite dimensional).
homolog_lib.tex(,1432) 
homolog_lib.tex(,1433) @item @strong{Note:}
homolog_lib.tex(,1434) In order to compute Tor_k(M,N) use the command Tor(k,syz(M),syz(N));
homolog_lib.tex(,1435) or: list P=mres(M,2); list Q=mres(N,2); Tor(k,P[2],Q[2]);
homolog_lib.tex(,1436) 
homolog_lib.tex(,1437) @end table
homolog_lib.tex(,1438) @strong{Example:}
homolog_lib.tex(,1439) @smallexample
homolog_lib.tex(,1440) @c computed example Tor d2t_singular/homolog_lib.doc:944 
homolog_lib.tex(,1441) LIB "homolog.lib";
homolog_lib.tex(,1442) int p      = printlevel;
homolog_lib.tex(,1443) printlevel = 1;
homolog_lib.tex(,1444) ring r     = 0,(x,y),dp;
homolog_lib.tex(,1445) ideal i    = x2,y;
homolog_lib.tex(,1446) ideal j    = x;
homolog_lib.tex(,1447) list E     = Tor(0..2,i,j);    // Tor_k(r/i,r/j) for k=0,1,2 over r
homolog_lib.tex(,1448) @expansion{} // dimension of Tor_0:  0
homolog_lib.tex(,1449) @expansion{} // vdim of Tor_0:       1
homolog_lib.tex(,1450) @expansion{} 
homolog_lib.tex(,1451) @expansion{} // Computing Tor_1 (help Tor; gives an explanation):
homolog_lib.tex(,1452) @expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
homolog_lib.tex(,1453) @expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
homolog_lib.tex(,1454) @expansion{} // coker(N), then Tensor(G0,F1)-->Tensor(G0,F0) is given by:
homolog_lib.tex(,1455) @expansion{} x
homolog_lib.tex(,1456) @expansion{} // and Tensor(G0,F2) + Tensor(G1,F1)-->Tensor(G0,F1) is given by:
homolog_lib.tex(,1457) @expansion{} 0,x2,y
homolog_lib.tex(,1458) @expansion{} 
homolog_lib.tex(,1459) @expansion{} // dimension of Tor_1:  0
homolog_lib.tex(,1460) @expansion{} // vdim of Tor_1:       1
homolog_lib.tex(,1461) @expansion{} 
homolog_lib.tex(,1462) @expansion{} // Computing Tor_2 (help Tor; gives an explanation):
homolog_lib.tex(,1463) @expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
homolog_lib.tex(,1464) @expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
homolog_lib.tex(,1465) @expansion{} // coker(N), then Tensor(G0,F2)-->Tensor(G0,F1) is given by:
homolog_lib.tex(,1466) @expansion{} 0
homolog_lib.tex(,1467) @expansion{} // and Tensor(G0,F3) + Tensor(G1,F2)-->Tensor(G0,F2) is given by:
homolog_lib.tex(,1468) @expansion{} 1,x2,y
homolog_lib.tex(,1469) @expansion{} 
homolog_lib.tex(,1470) @expansion{} // dimension of Tor_2:  -1
homolog_lib.tex(,1471) @expansion{} 
homolog_lib.tex(,1472) qring R    = std(i);
homolog_lib.tex(,1473) ideal j    = fetch(r,j);
homolog_lib.tex(,1474) module M   = [x,0],[0,x];
homolog_lib.tex(,1475) printlevel = 2;
homolog_lib.tex(,1476) module E1  = Tor(1,M,j);       // Tor_1(R^2/M,R/j) over R=r/i
homolog_lib.tex(,1477) @expansion{} // Computing Tor_1 (help Tor; gives an explanation):
homolog_lib.tex(,1478) @expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
homolog_lib.tex(,1479) @expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
homolog_lib.tex(,1480) @expansion{} // coker(N), then Tensor(G0,F1)-->Tensor(G0,F0) is given by:
homolog_lib.tex(,1481) @expansion{} x,0,
homolog_lib.tex(,1482) @expansion{} 0,x 
homolog_lib.tex(,1483) @expansion{} // and Tensor(G0,F2) + Tensor(G1,F1)-->Tensor(G0,F1) is given by:
homolog_lib.tex(,1484) @expansion{} x,0,x,0,
homolog_lib.tex(,1485) @expansion{} 0,x,0,x 
homolog_lib.tex(,1486) @expansion{} 
homolog_lib.tex(,1487) @expansion{} // dimension of Tor_1:  0
homolog_lib.tex(,1488) @expansion{} // vdim of Tor_1:       2
homolog_lib.tex(,1489) @expansion{} 
homolog_lib.tex(,1490) list l     = Tor(3,M,M,1);     // Tor_3(R^2/M,R^2/M) over R=r/i
homolog_lib.tex(,1491) @expansion{} // Computing Tor_3 (help Tor; gives an explanation):
homolog_lib.tex(,1492) @expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
homolog_lib.tex(,1493) @expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
homolog_lib.tex(,1494) @expansion{} // coker(N), then Tensor(G0,F3)-->Tensor(G0,F2) is given by:
homolog_lib.tex(,1495) @expansion{} x,0,0,0,
homolog_lib.tex(,1496) @expansion{} 0,x,0,0,
homolog_lib.tex(,1497) @expansion{} 0,0,x,0,
homolog_lib.tex(,1498) @expansion{} 0,0,0,x 
homolog_lib.tex(,1499) @expansion{} // and Tensor(G0,F4) + Tensor(G1,F3)-->Tensor(G0,F3) is given by:
homolog_lib.tex(,1500) @expansion{} x,0,0,0,x,0,0,0,
homolog_lib.tex(,1501) @expansion{} 0,x,0,0,0,x,0,0,
homolog_lib.tex(,1502) @expansion{} 0,0,x,0,0,0,x,0,
homolog_lib.tex(,1503) @expansion{} 0,0,0,x,0,0,0,x 
homolog_lib.tex(,1504) @expansion{} 
homolog_lib.tex(,1505) @expansion{} // dimension of Tor_3:  0
homolog_lib.tex(,1506) @expansion{} // vdim of Tor_3:       4
homolog_lib.tex(,1507) @expansion{} 
homolog_lib.tex(,1508) @expansion{} // columns of matrix are kbase of Tor_3 in Tensor(G0,F3)
homolog_lib.tex(,1509) @expansion{} 1,0,0,0,
homolog_lib.tex(,1510) @expansion{} 0,1,0,0,
homolog_lib.tex(,1511) @expansion{} 0,0,1,0,
homolog_lib.tex(,1512) @expansion{} 0,0,0,1 
homolog_lib.tex(,1513) @expansion{} 
homolog_lib.tex(,1514) printlevel = p;
homolog_lib.tex(,1515) @c end example Tor d2t_singular/homolog_lib.doc:944
homolog_lib.tex(,1516) @end smallexample
homolog_lib.tex(,1517) @c ---end content Tor---
singular.texi(,386) @c ----------------------------------------------------------
singular.texi(,387) @node mprimdec_lib, mregular_lib, homolog_lib, Commutative algebra
singular.texi(,388) @subsection mprimdec_lib
singular.texi(,389) @c include of docu for mprimdec.lib
mprimdec_lib.tex(,1) @c ---content LibInfo---
mprimdec_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/mprimdec_lib.doc
mprimdec_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/mprimdec_lib.doc INSTEAD
mprimdec_lib.tex(,4) @c library version: (1.1.2.3,2002/03/19)
mprimdec_lib.tex(,5) @c library file: ../Singular/LIB/mprimdec.lib
mprimdec_lib.tex(,6) @cindex mprimdec.lib
mprimdec_lib.tex(,7) @cindex mprimdec_lib
mprimdec_lib.tex(,8) @table @asis
mprimdec_lib.tex(,9) @item @strong{Library:}
mprimdec_lib.tex(,10) mprimdec.lib
mprimdec_lib.tex(,11) @item @strong{Purpose:}
mprimdec_lib.tex(,12)    procedures for primary decomposition of modules
mprimdec_lib.tex(,13) @item @strong{Authors:}
mprimdec_lib.tex(,14) Alexander Dreyer, dreyer@@mathematik.uni-kl.de; adreyer@@web.de
mprimdec_lib.tex(,15) 
mprimdec_lib.tex(,16) @item @strong{Remark:}
mprimdec_lib.tex(,17) These procedures are implemented to be used in characteristic 0.
mprimdec_lib.tex(,18) @*They also work in positive characteristic >> 0.
mprimdec_lib.tex(,19) @*In small characteristic and for algebraic extensions, the
mprimdec_lib.tex(,20) procedures via Gianni, Trager, Zacharias may not terminate.
mprimdec_lib.tex(,21) 
mprimdec_lib.tex(,22) @end table
mprimdec_lib.tex(,23) 
mprimdec_lib.tex(,24) @strong{Procedures:}
mprimdec_lib.tex(,25) @menu
mprimdec_lib.tex(,26) * separator:: computes a list of separators of prime ideals
mprimdec_lib.tex(,27) * PrimdecA:: (not necessarily minimal) primary decomposition via Shimoyama/Yokoyama (suggested by Graebe)
mprimdec_lib.tex(,28) * PrimdecB:: (not necessarily minimal) primary decomposition for pseudo-primary ideals
mprimdec_lib.tex(,29) * modDec:: minimal primary decomposition via Shimoyama/Yokoyama (suggested by Graebe)
mprimdec_lib.tex(,30) * zeroMod:: minimal zero-dimensional primary decomposition via Gianni, Trager and Zacharias
mprimdec_lib.tex(,31) * GTZmod:: minimal primary decomposition via Gianni, Trager and Zacharias
mprimdec_lib.tex(,32) * dec1var:: primary decomposition for one variable
mprimdec_lib.tex(,33) * annil:: the annihilator of M/N in the basering
mprimdec_lib.tex(,34) * splitting:: splitting to simpler modules
mprimdec_lib.tex(,35) * primTest:: tests whether i is prime or homogeneous
mprimdec_lib.tex(,36) * preComp:: enhanced Version of splitting
mprimdec_lib.tex(,37) * indSet:: lists with varstrings of(in)dependent variables
mprimdec_lib.tex(,38) * GTZopt:: a faster version of GTZmod
mprimdec_lib.tex(,39) * zeroOpt:: a faster version of zeroMod
mprimdec_lib.tex(,40) * clrSBmod:: extracts an minimal SB from a SB
mprimdec_lib.tex(,41) * minSatMod:: minimal saturation of N w.r.t. I
mprimdec_lib.tex(,42) * specialModulesEqual:: checks for equality of standard bases of modules if N1 is contained in N2 or vice versa
mprimdec_lib.tex(,43) * stdModulesEqual:: checks for equality of standard bases
mprimdec_lib.tex(,44) * modulesEqual:: checks for equality of modules
mprimdec_lib.tex(,45) * getData:: extracts oldData and computes the remaining data
mprimdec_lib.tex(,46) @end menu
mprimdec_lib.tex(,47) @c ---end content LibInfo---
mprimdec_lib.tex(,48) 
mprimdec_lib.tex(,49) @c ------------------- separator -------------
mprimdec_lib.tex(,50) @node separator, PrimdecA,, mprimdec_lib
mprimdec_lib.tex(,51) @subsubsection separator
mprimdec_lib.tex(,52) @cindex separator
mprimdec_lib.tex(,53) @c ---content separator---
mprimdec_lib.tex(,54) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,55) 
mprimdec_lib.tex(,56) @table @asis
mprimdec_lib.tex(,57) @item @strong{Usage:}
mprimdec_lib.tex(,58) separator(l); list l of prime ideals
mprimdec_lib.tex(,59) 
mprimdec_lib.tex(,60) @item @strong{Return:}
mprimdec_lib.tex(,61) list sepList;
mprimdec_lib.tex(,62) @*a list of separators of the prime ideals in l,
mprimdec_lib.tex(,63) @*i.e. polynomials p_ij, s.th. p_ij is in l[j],
mprimdec_lib.tex(,64) @*for all l[j] not contained in l[i]
mprimdec_lib.tex(,65) @*but p_ij is not in l[i]
mprimdec_lib.tex(,66) 
mprimdec_lib.tex(,67) @end table
mprimdec_lib.tex(,68) @strong{Example:}
mprimdec_lib.tex(,69) @smallexample
mprimdec_lib.tex(,70) @c computed example separator d2t_singular/mprimdec_lib.doc:68 
mprimdec_lib.tex(,71) LIB "mprimdec.lib";
mprimdec_lib.tex(,72) ring r=0,(x,y,z),dp;
mprimdec_lib.tex(,73) ideal i=(x2y,xz2,y2z,z3);
mprimdec_lib.tex(,74) list l=minAssGTZ(i);
mprimdec_lib.tex(,75) list sepL=separator(l);
mprimdec_lib.tex(,76) sepL;
mprimdec_lib.tex(,77) @expansion{} [1]:
mprimdec_lib.tex(,78) @expansion{}    x
mprimdec_lib.tex(,79) @expansion{} [2]:
mprimdec_lib.tex(,80) @expansion{}    y
mprimdec_lib.tex(,81) @c end example separator d2t_singular/mprimdec_lib.doc:68
mprimdec_lib.tex(,82) @end smallexample
mprimdec_lib.tex(,83) @c ---end content separator---
mprimdec_lib.tex(,84) 
mprimdec_lib.tex(,85) @c ------------------- PrimdecA -------------
mprimdec_lib.tex(,86) @node PrimdecA, PrimdecB, separator, mprimdec_lib
mprimdec_lib.tex(,87) @subsubsection PrimdecA
mprimdec_lib.tex(,88) @cindex PrimdecA
mprimdec_lib.tex(,89) @c ---content PrimdecA---
mprimdec_lib.tex(,90) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,91) 
mprimdec_lib.tex(,92) @table @asis
mprimdec_lib.tex(,93) @item @strong{Usage:}
mprimdec_lib.tex(,94) PrimdecA (N[, i]); module N, int i
mprimdec_lib.tex(,95) 
mprimdec_lib.tex(,96) @item @strong{Return:}
mprimdec_lib.tex(,97) list l
mprimdec_lib.tex(,98) @*a (not necessarily minimal) primary decomposition of N
mprimdec_lib.tex(,99) computed by a generalized version of
mprimdec_lib.tex(,100) @*the algorithm of Schimoyama/Yokoyama,
mprimdec_lib.tex(,101) @*if i=1 is given, the factorizing Groebner is used
mprimdec_lib.tex(,102) @*to compute the isolated primes.
mprimdec_lib.tex(,103) 
mprimdec_lib.tex(,104) @end table
mprimdec_lib.tex(,105) @strong{Example:}
mprimdec_lib.tex(,106) @smallexample
mprimdec_lib.tex(,107) @c computed example PrimdecA d2t_singular/mprimdec_lib.doc:101 
mprimdec_lib.tex(,108) LIB "mprimdec.lib";
mprimdec_lib.tex(,109) ring r=0,(x,y,z),dp;
mprimdec_lib.tex(,110) module N=x*gen(1)+ y*gen(2),
mprimdec_lib.tex(,111) x*gen(1)-x2*gen(2);
mprimdec_lib.tex(,112) list l=PrimdecA(N);
mprimdec_lib.tex(,113) l;
mprimdec_lib.tex(,114) @expansion{} [1]:
mprimdec_lib.tex(,115) @expansion{}    [1]:
mprimdec_lib.tex(,116) @expansion{}       _[1]=x*gen(1)+y*gen(2)
mprimdec_lib.tex(,117) @expansion{}       _[2]=x*gen(2)-gen(1)
mprimdec_lib.tex(,118) @expansion{}    [2]:
mprimdec_lib.tex(,119) @expansion{}       _[1]=x2+y
mprimdec_lib.tex(,120) @expansion{} [2]:
mprimdec_lib.tex(,121) @expansion{}    [1]:
mprimdec_lib.tex(,122) @expansion{}       _[1]=gen(2)
mprimdec_lib.tex(,123) @expansion{}       _[2]=x*gen(1)
mprimdec_lib.tex(,124) @expansion{}    [2]:
mprimdec_lib.tex(,125) @expansion{}       _[1]=x
mprimdec_lib.tex(,126) @expansion{} [3]:
mprimdec_lib.tex(,127) @expansion{}    [1]:
mprimdec_lib.tex(,128) @expansion{}       _[1]=y*gen(1)
mprimdec_lib.tex(,129) @expansion{}       _[2]=y*gen(2)
mprimdec_lib.tex(,130) @expansion{}       _[3]=x*gen(1)
mprimdec_lib.tex(,131) @expansion{}       _[4]=x*gen(2)
mprimdec_lib.tex(,132) @expansion{}    [2]:
mprimdec_lib.tex(,133) @expansion{}       _[1]=y
mprimdec_lib.tex(,134) @expansion{}       _[2]=x
mprimdec_lib.tex(,135) @c end example PrimdecA d2t_singular/mprimdec_lib.doc:101
mprimdec_lib.tex(,136) @end smallexample
mprimdec_lib.tex(,137) @c ---end content PrimdecA---
mprimdec_lib.tex(,138) 
mprimdec_lib.tex(,139) @c ------------------- PrimdecB -------------
mprimdec_lib.tex(,140) @node PrimdecB, modDec, PrimdecA, mprimdec_lib
mprimdec_lib.tex(,141) @subsubsection PrimdecB
mprimdec_lib.tex(,142) @cindex PrimdecB
mprimdec_lib.tex(,143) @c ---content PrimdecB---
mprimdec_lib.tex(,144) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,145) 
mprimdec_lib.tex(,146) @table @asis
mprimdec_lib.tex(,147) @item @strong{Usage:}
mprimdec_lib.tex(,148) PrimdecB (N, p); pseudo-primary module N, isolated prime ideal p
mprimdec_lib.tex(,149) 
mprimdec_lib.tex(,150) @item @strong{Return:}
mprimdec_lib.tex(,151) list l
mprimdec_lib.tex(,152) @*a (not necessarily minimal) primary decomposition of N
mprimdec_lib.tex(,153) 
mprimdec_lib.tex(,154) @end table
mprimdec_lib.tex(,155) @strong{Example:}
mprimdec_lib.tex(,156) @smallexample
mprimdec_lib.tex(,157) @c computed example PrimdecB d2t_singular/mprimdec_lib.doc:130 
mprimdec_lib.tex(,158) LIB "mprimdec.lib";
mprimdec_lib.tex(,159) ring r=0,(x,y,z),dp;
mprimdec_lib.tex(,160) module N=y*gen(1),y2*gen(2),yz*gen(2),yx*gen(2);
mprimdec_lib.tex(,161) ideal p=y;
mprimdec_lib.tex(,162) list l=PrimdecB(N,p);
mprimdec_lib.tex(,163) l;
mprimdec_lib.tex(,164) @expansion{} [1]:
mprimdec_lib.tex(,165) @expansion{}    [1]:
mprimdec_lib.tex(,166) @expansion{}       _[1]=y*gen(1)
mprimdec_lib.tex(,167) @expansion{}       _[2]=y*gen(2)
mprimdec_lib.tex(,168) @expansion{}    [2]:
mprimdec_lib.tex(,169) @expansion{}       _[1]=y
mprimdec_lib.tex(,170) @expansion{} [2]:
mprimdec_lib.tex(,171) @expansion{}    [1]:
mprimdec_lib.tex(,172) @expansion{}       _[1]=y*gen(1)
mprimdec_lib.tex(,173) @expansion{}       _[2]=y*gen(2)
mprimdec_lib.tex(,174) @expansion{}       _[3]=x*gen(1)
mprimdec_lib.tex(,175) @expansion{}       _[4]=x*gen(2)
mprimdec_lib.tex(,176) @expansion{}    [2]:
mprimdec_lib.tex(,177) @expansion{}       _[1]=y
mprimdec_lib.tex(,178) @expansion{}       _[2]=x
mprimdec_lib.tex(,179) @expansion{} [3]:
mprimdec_lib.tex(,180) @expansion{}    [1]:
mprimdec_lib.tex(,181) @expansion{}       _[1]=z*gen(1)
mprimdec_lib.tex(,182) @expansion{}       _[2]=z*gen(2)
mprimdec_lib.tex(,183) @expansion{}       _[3]=y*gen(1)
mprimdec_lib.tex(,184) @expansion{}       _[4]=x*gen(1)
mprimdec_lib.tex(,185) @expansion{}       _[5]=x*gen(2)
mprimdec_lib.tex(,186) @expansion{}       _[6]=y2*gen(2)
mprimdec_lib.tex(,187) @expansion{}    [2]:
mprimdec_lib.tex(,188) @expansion{}       _[1]=z
mprimdec_lib.tex(,189) @expansion{}       _[2]=y
mprimdec_lib.tex(,190) @expansion{}       _[3]=x
mprimdec_lib.tex(,191) @c end example PrimdecB d2t_singular/mprimdec_lib.doc:130
mprimdec_lib.tex(,192) @end smallexample
mprimdec_lib.tex(,193) @c ---end content PrimdecB---
mprimdec_lib.tex(,194) 
mprimdec_lib.tex(,195) @c ------------------- modDec -------------
mprimdec_lib.tex(,196) @node modDec, zeroMod, PrimdecB, mprimdec_lib
mprimdec_lib.tex(,197) @subsubsection modDec
mprimdec_lib.tex(,198) @cindex modDec
mprimdec_lib.tex(,199) @c ---content modDec---
mprimdec_lib.tex(,200) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,201) 
mprimdec_lib.tex(,202) @table @asis
mprimdec_lib.tex(,203) @item @strong{Usage:}
mprimdec_lib.tex(,204) modDec (N[, i]); module N, int i
mprimdec_lib.tex(,205) 
mprimdec_lib.tex(,206) @item @strong{Return:}
mprimdec_lib.tex(,207) list l
mprimdec_lib.tex(,208) @*a minimal primary decomposition of N
mprimdec_lib.tex(,209) @*computed by an generalized version of
mprimdec_lib.tex(,210) @*the algorithm of Schimoyama/Yokoyama,
mprimdec_lib.tex(,211) @*if i=1 is given, the factorizing Groebner is used
mprimdec_lib.tex(,212) 
mprimdec_lib.tex(,213) @end table
mprimdec_lib.tex(,214) @strong{Example:}
mprimdec_lib.tex(,215) @smallexample
mprimdec_lib.tex(,216) @c computed example modDec d2t_singular/mprimdec_lib.doc:162 
mprimdec_lib.tex(,217) LIB "mprimdec.lib";
mprimdec_lib.tex(,218) ring r=0,(x,y,z),dp;
mprimdec_lib.tex(,219) module N=x*gen(1)+ y*gen(2),
mprimdec_lib.tex(,220) x*gen(1)-x2*gen(2);
mprimdec_lib.tex(,221) list l=modDec(N);
mprimdec_lib.tex(,222) l;
mprimdec_lib.tex(,223) @expansion{} [1]:
mprimdec_lib.tex(,224) @expansion{}    [1]:
mprimdec_lib.tex(,225) @expansion{}       _[1]=x*gen(1)+y*gen(2)
mprimdec_lib.tex(,226) @expansion{}       _[2]=x*gen(2)-gen(1)
mprimdec_lib.tex(,227) @expansion{}    [2]:
mprimdec_lib.tex(,228) @expansion{}       _[1]=x2+y
mprimdec_lib.tex(,229) @expansion{} [2]:
mprimdec_lib.tex(,230) @expansion{}    [1]:
mprimdec_lib.tex(,231) @expansion{}       _[1]=gen(2)
mprimdec_lib.tex(,232) @expansion{}       _[2]=x*gen(1)
mprimdec_lib.tex(,233) @expansion{}    [2]:
mprimdec_lib.tex(,234) @expansion{}       _[1]=x
mprimdec_lib.tex(,235) @c end example modDec d2t_singular/mprimdec_lib.doc:162
mprimdec_lib.tex(,236) @end smallexample
mprimdec_lib.tex(,237) @c ---end content modDec---
mprimdec_lib.tex(,238) 
mprimdec_lib.tex(,239) @c ------------------- zeroMod -------------
mprimdec_lib.tex(,240) @node zeroMod, GTZmod, modDec, mprimdec_lib
mprimdec_lib.tex(,241) @subsubsection zeroMod
mprimdec_lib.tex(,242) @cindex zeroMod
mprimdec_lib.tex(,243) @c ---content zeroMod---
mprimdec_lib.tex(,244) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,245) 
mprimdec_lib.tex(,246) @table @asis
mprimdec_lib.tex(,247) @item @strong{Usage:}
mprimdec_lib.tex(,248) zeroMod (N[, check]); zero-dimensional module N[, module check]
mprimdec_lib.tex(,249) 
mprimdec_lib.tex(,250) @item @strong{Return:}
mprimdec_lib.tex(,251) list l
mprimdec_lib.tex(,252) @*the minimal primary decomposition of a zero-dimensional module N,
mprimdec_lib.tex(,253) computed by a generalized version of the algorithm
mprimdec_lib.tex(,254) @*of Gianni, Trager and Zacharias
mprimdec_lib.tex(,255) 
mprimdec_lib.tex(,256) @item @strong{Note:}
mprimdec_lib.tex(,257) if the parameter check is given, only components
mprimdec_lib.tex(,258) @*not containing check are computed
mprimdec_lib.tex(,259) 
mprimdec_lib.tex(,260) @end table
mprimdec_lib.tex(,261) @strong{Example:}
mprimdec_lib.tex(,262) @smallexample
mprimdec_lib.tex(,263) @c computed example zeroMod d2t_singular/mprimdec_lib.doc:197 
mprimdec_lib.tex(,264) LIB "mprimdec.lib";
mprimdec_lib.tex(,265) ring r=0,z,dp;
mprimdec_lib.tex(,266) module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
mprimdec_lib.tex(,267) list l=zeroMod(N);
mprimdec_lib.tex(,268) @expansion{} 2
mprimdec_lib.tex(,269) l;
mprimdec_lib.tex(,270) @expansion{} [1]:
mprimdec_lib.tex(,271) @expansion{}    [1]:
mprimdec_lib.tex(,272) @expansion{}       _[1]=gen(1)
mprimdec_lib.tex(,273) @expansion{}       _[2]=gen(3)
mprimdec_lib.tex(,274) @expansion{}       _[3]=z*gen(2)-gen(2)
mprimdec_lib.tex(,275) @expansion{}    [2]:
mprimdec_lib.tex(,276) @expansion{}       _[1]=z-1
mprimdec_lib.tex(,277) @expansion{} [2]:
mprimdec_lib.tex(,278) @expansion{}    [1]:
mprimdec_lib.tex(,279) @expansion{}       _[1]=gen(2)
mprimdec_lib.tex(,280) @expansion{}       _[2]=gen(3)
mprimdec_lib.tex(,281) @expansion{}       _[3]=z*gen(1)
mprimdec_lib.tex(,282) @expansion{}    [2]:
mprimdec_lib.tex(,283) @expansion{}       _[1]=z
mprimdec_lib.tex(,284) @expansion{} [3]:
mprimdec_lib.tex(,285) @expansion{}    [1]:
mprimdec_lib.tex(,286) @expansion{}       _[1]=gen(1)
mprimdec_lib.tex(,287) @expansion{}       _[2]=gen(2)
mprimdec_lib.tex(,288) @expansion{}       _[3]=z*gen(3)+gen(3)
mprimdec_lib.tex(,289) @expansion{}    [2]:
mprimdec_lib.tex(,290) @expansion{}       _[1]=z+1
mprimdec_lib.tex(,291) @c end example zeroMod d2t_singular/mprimdec_lib.doc:197
mprimdec_lib.tex(,292) @end smallexample
mprimdec_lib.tex(,293) @c ---end content zeroMod---
mprimdec_lib.tex(,294) 
mprimdec_lib.tex(,295) @c ------------------- GTZmod -------------
mprimdec_lib.tex(,296) @node GTZmod, dec1var, zeroMod, mprimdec_lib
mprimdec_lib.tex(,297) @subsubsection GTZmod
mprimdec_lib.tex(,298) @cindex GTZmod
mprimdec_lib.tex(,299) @c ---content GTZmod---
mprimdec_lib.tex(,300) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,301) 
mprimdec_lib.tex(,302) @table @asis
mprimdec_lib.tex(,303) @item @strong{Usage:}
mprimdec_lib.tex(,304) GTZmod (N[, check]); module N[, module check]
mprimdec_lib.tex(,305) 
mprimdec_lib.tex(,306) @item @strong{Return:}
mprimdec_lib.tex(,307) list l
mprimdec_lib.tex(,308) @*the minimal primary decomposition of the module N,
mprimdec_lib.tex(,309) @*computed by a generalized version of the algorithm
mprimdec_lib.tex(,310) @*of Gianny, Trager and Zacharias
mprimdec_lib.tex(,311) 
mprimdec_lib.tex(,312) @item @strong{Note:}
mprimdec_lib.tex(,313) if the parameter check is given, only components
mprimdec_lib.tex(,314) @*not containing check are computed
mprimdec_lib.tex(,315) 
mprimdec_lib.tex(,316) @end table
mprimdec_lib.tex(,317) @strong{Example:}
mprimdec_lib.tex(,318) @smallexample
mprimdec_lib.tex(,319) @c computed example GTZmod d2t_singular/mprimdec_lib.doc:231 
mprimdec_lib.tex(,320) LIB "mprimdec.lib";
mprimdec_lib.tex(,321) ring r=0,(x,y,z),dp;
mprimdec_lib.tex(,322) module N=x*gen(1)+ y*gen(2),
mprimdec_lib.tex(,323) x*gen(1)-x2*gen(2);
mprimdec_lib.tex(,324) list l=GTZmod(N);
mprimdec_lib.tex(,325) @expansion{} 2
mprimdec_lib.tex(,326) l;
mprimdec_lib.tex(,327) @expansion{} [1]:
mprimdec_lib.tex(,328) @expansion{}    [1]:
mprimdec_lib.tex(,329) @expansion{}       _[1]=x*gen(1)+y*gen(2)
mprimdec_lib.tex(,330) @expansion{}       _[2]=x*gen(2)-gen(1)
mprimdec_lib.tex(,331) @expansion{}    [2]:
mprimdec_lib.tex(,332) @expansion{}       _[1]=x2+y
mprimdec_lib.tex(,333) @expansion{} [2]:
mprimdec_lib.tex(,334) @expansion{}    [1]:
mprimdec_lib.tex(,335) @expansion{}       _[1]=gen(2)
mprimdec_lib.tex(,336) @expansion{}       _[2]=x*gen(1)
mprimdec_lib.tex(,337) @expansion{}    [2]:
mprimdec_lib.tex(,338) @expansion{}       _[1]=x
mprimdec_lib.tex(,339) @c end example GTZmod d2t_singular/mprimdec_lib.doc:231
mprimdec_lib.tex(,340) @end smallexample
mprimdec_lib.tex(,341) @c ---end content GTZmod---
mprimdec_lib.tex(,342) 
mprimdec_lib.tex(,343) @c ------------------- dec1var -------------
mprimdec_lib.tex(,344) @node dec1var, annil, GTZmod, mprimdec_lib
mprimdec_lib.tex(,345) @subsubsection dec1var
mprimdec_lib.tex(,346) @cindex dec1var
mprimdec_lib.tex(,347) @c ---content dec1var---
mprimdec_lib.tex(,348) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,349) 
mprimdec_lib.tex(,350) @table @asis
mprimdec_lib.tex(,351) @item @strong{Usage:}
mprimdec_lib.tex(,352) dec1var (N); zero-dimensional module N[, module check]
mprimdec_lib.tex(,353) 
mprimdec_lib.tex(,354) @item @strong{Return:}
mprimdec_lib.tex(,355) list l
mprimdec_lib.tex(,356) @*the minimal primary decomposition of a submodule N of R^s
mprimdec_lib.tex(,357) if nvars(R)=1
mprimdec_lib.tex(,358) 
mprimdec_lib.tex(,359) @item @strong{Note:}
mprimdec_lib.tex(,360) if the parameter check is given, only components
mprimdec_lib.tex(,361) @*not containing check are computed
mprimdec_lib.tex(,362) 
mprimdec_lib.tex(,363) @end table
mprimdec_lib.tex(,364) @strong{Example:}
mprimdec_lib.tex(,365) @smallexample
mprimdec_lib.tex(,366) @c computed example dec1var d2t_singular/mprimdec_lib.doc:265 
mprimdec_lib.tex(,367) LIB "mprimdec.lib";
mprimdec_lib.tex(,368) ring r=0,z,dp;
mprimdec_lib.tex(,369) module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
mprimdec_lib.tex(,370) list l=dec1var(N);
mprimdec_lib.tex(,371) l;
mprimdec_lib.tex(,372) @expansion{} [1]:
mprimdec_lib.tex(,373) @expansion{}    [1]:
mprimdec_lib.tex(,374) @expansion{}       _[1]=gen(1)
mprimdec_lib.tex(,375) @expansion{}       _[2]=gen(3)
mprimdec_lib.tex(,376) @expansion{}       _[3]=z*gen(2)-gen(2)
mprimdec_lib.tex(,377) @expansion{}    [2]:
mprimdec_lib.tex(,378) @expansion{}       _[1]=z-1
mprimdec_lib.tex(,379) @expansion{} [2]:
mprimdec_lib.tex(,380) @expansion{}    [1]:
mprimdec_lib.tex(,381) @expansion{}       _[1]=gen(2)
mprimdec_lib.tex(,382) @expansion{}       _[2]=gen(3)
mprimdec_lib.tex(,383) @expansion{}       _[3]=z*gen(1)
mprimdec_lib.tex(,384) @expansion{}    [2]:
mprimdec_lib.tex(,385) @expansion{}       _[1]=z
mprimdec_lib.tex(,386) @expansion{} [3]:
mprimdec_lib.tex(,387) @expansion{}    [1]:
mprimdec_lib.tex(,388) @expansion{}       _[1]=gen(1)
mprimdec_lib.tex(,389) @expansion{}       _[2]=gen(2)
mprimdec_lib.tex(,390) @expansion{}       _[3]=z*gen(3)+gen(3)
mprimdec_lib.tex(,391) @expansion{}    [2]:
mprimdec_lib.tex(,392) @expansion{}       _[1]=z+1
mprimdec_lib.tex(,393) @c end example dec1var d2t_singular/mprimdec_lib.doc:265
mprimdec_lib.tex(,394) @end smallexample
mprimdec_lib.tex(,395) @c ---end content dec1var---
mprimdec_lib.tex(,396) 
mprimdec_lib.tex(,397) @c ------------------- annil -------------
mprimdec_lib.tex(,398) @node annil, splitting, dec1var, mprimdec_lib
mprimdec_lib.tex(,399) @subsubsection annil
mprimdec_lib.tex(,400) @cindex annil
mprimdec_lib.tex(,401) @c ---content annil---
mprimdec_lib.tex(,402) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,403) 
mprimdec_lib.tex(,404) @table @asis
mprimdec_lib.tex(,405) @item @strong{Usage:}
mprimdec_lib.tex(,406) annil(N); module N
mprimdec_lib.tex(,407) 
mprimdec_lib.tex(,408) @item @strong{Return:}
mprimdec_lib.tex(,409) ideal ann=std(quotient(N,freemodule(nrows(N))));
mprimdec_lib.tex(,410) @*the annihilator of M/N in the basering
mprimdec_lib.tex(,411) 
mprimdec_lib.tex(,412) @item @strong{Note:}
mprimdec_lib.tex(,413) ann is a std basis in the basering
mprimdec_lib.tex(,414) 
mprimdec_lib.tex(,415) @end table
mprimdec_lib.tex(,416) @strong{Example:}
mprimdec_lib.tex(,417) @smallexample
mprimdec_lib.tex(,418) @c computed example annil d2t_singular/mprimdec_lib.doc:296 
mprimdec_lib.tex(,419) LIB "mprimdec.lib";
mprimdec_lib.tex(,420) ring r=0,(x,y,z),dp;
mprimdec_lib.tex(,421) module N=x*gen(1), y*gen(2);
mprimdec_lib.tex(,422) ideal ann=annil(N);
mprimdec_lib.tex(,423) ann;
mprimdec_lib.tex(,424) @expansion{} ann[1]=xy
mprimdec_lib.tex(,425) @c end example annil d2t_singular/mprimdec_lib.doc:296
mprimdec_lib.tex(,426) @end smallexample
mprimdec_lib.tex(,427) @c ---end content annil---
mprimdec_lib.tex(,428) 
mprimdec_lib.tex(,429) @c ------------------- splitting -------------
mprimdec_lib.tex(,430) @node splitting, primTest, annil, mprimdec_lib
mprimdec_lib.tex(,431) @subsubsection splitting
mprimdec_lib.tex(,432) @cindex splitting
mprimdec_lib.tex(,433) @c ---content splitting---
mprimdec_lib.tex(,434) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,435) 
mprimdec_lib.tex(,436) @table @asis
mprimdec_lib.tex(,437) @item @strong{Usage:}
mprimdec_lib.tex(,438) splitting(N[,check[, ann]]); module N, module check, ideal ann
mprimdec_lib.tex(,439) 
mprimdec_lib.tex(,440) @item @strong{Return:}
mprimdec_lib.tex(,441) (l, check) list l, module check
mprimdec_lib.tex(,442) @*the elements of l consists of a triple with
mprimdec_lib.tex(,443) @*[1] of type module [2] and [3] of type ideal
mprimdec_lib.tex(,444) @*s.th. the intersection of the modules is equal to the
mprimdec_lib.tex(,445) zero-dimensional module N, furthermore l[j][3]=annil(l[j][1])
mprimdec_lib.tex(,446) if l[j][2]!=0 then the module l[j][1] is primary
mprimdec_lib.tex(,447) @*with associated prime l[j][2],
mprimdec_lib.tex(,448) @*and check=intersect(check, l[j][1]) is computed
mprimdec_lib.tex(,449) 
mprimdec_lib.tex(,450) @item @strong{Note:}
mprimdec_lib.tex(,451) if the parameter check is given, only components not containing
mprimdec_lib.tex(,452) check are computed; if ann is given, ann is used instead of annil(N)
mprimdec_lib.tex(,453) 
mprimdec_lib.tex(,454) @end table
mprimdec_lib.tex(,455) @strong{Example:}
mprimdec_lib.tex(,456) @smallexample
mprimdec_lib.tex(,457) @c computed example splitting d2t_singular/mprimdec_lib.doc:334 
mprimdec_lib.tex(,458) LIB "mprimdec.lib";
mprimdec_lib.tex(,459) ring r=0,z,lp;
mprimdec_lib.tex(,460) module N=z*gen(1), (z+1)*gen(2);
mprimdec_lib.tex(,461) N=std(N);
mprimdec_lib.tex(,462) list l; module check;
mprimdec_lib.tex(,463) (l, check)=splitting(N);
mprimdec_lib.tex(,464) l;
mprimdec_lib.tex(,465) @expansion{} [1]:
mprimdec_lib.tex(,466) @expansion{}    [1]:
mprimdec_lib.tex(,467) @expansion{}       _[1]=gen(2)
mprimdec_lib.tex(,468) @expansion{}       _[2]=z*gen(1)
mprimdec_lib.tex(,469) @expansion{}    [2]:
mprimdec_lib.tex(,470) @expansion{}       _[1]=z
mprimdec_lib.tex(,471) @expansion{}    [3]:
mprimdec_lib.tex(,472) @expansion{}       _[1]=z
mprimdec_lib.tex(,473) @expansion{}    [4]:
mprimdec_lib.tex(,474) @expansion{}       _[1]=z
mprimdec_lib.tex(,475) @expansion{} [2]:
mprimdec_lib.tex(,476) @expansion{}    [1]:
mprimdec_lib.tex(,477) @expansion{}       _[1]=gen(1)
mprimdec_lib.tex(,478) @expansion{}       _[2]=z*gen(2)+gen(2)
mprimdec_lib.tex(,479) @expansion{}    [2]:
mprimdec_lib.tex(,480) @expansion{}       _[1]=z+1
mprimdec_lib.tex(,481) @expansion{}    [3]:
mprimdec_lib.tex(,482) @expansion{}       _[1]=z+1
mprimdec_lib.tex(,483) @expansion{}    [4]:
mprimdec_lib.tex(,484) @expansion{}       _[1]=z+1
mprimdec_lib.tex(,485) check;
mprimdec_lib.tex(,486) @expansion{} check[1]=z*gen(2)+gen(2)
mprimdec_lib.tex(,487) @expansion{} check[2]=z*gen(1)
mprimdec_lib.tex(,488) @c end example splitting d2t_singular/mprimdec_lib.doc:334
mprimdec_lib.tex(,489) @end smallexample
mprimdec_lib.tex(,490) @c ---end content splitting---
mprimdec_lib.tex(,491) 
mprimdec_lib.tex(,492) @c ------------------- primTest -------------
mprimdec_lib.tex(,493) @node primTest, preComp, splitting, mprimdec_lib
mprimdec_lib.tex(,494) @subsubsection primTest
mprimdec_lib.tex(,495) @cindex primTest
mprimdec_lib.tex(,496) @c ---content primTest---
mprimdec_lib.tex(,497) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,498) 
mprimdec_lib.tex(,499) @table @asis
mprimdec_lib.tex(,500) @item @strong{Usage:}
mprimdec_lib.tex(,501) primTest(i[, p]); a zero-dimensional ideal i, irreducible poly p in i
mprimdec_lib.tex(,502) 
mprimdec_lib.tex(,503) @item @strong{Return:}
mprimdec_lib.tex(,504) if i neither is prime nor is homogeneous then ideal(0) is returned,
mprimdec_lib.tex(,505) else radical(i)
mprimdec_lib.tex(,506) 
mprimdec_lib.tex(,507) @end table
mprimdec_lib.tex(,508) @strong{Example:}
mprimdec_lib.tex(,509) @smallexample
mprimdec_lib.tex(,510) @c computed example primTest d2t_singular/mprimdec_lib.doc:365 
mprimdec_lib.tex(,511) LIB "mprimdec.lib";
mprimdec_lib.tex(,512) ring r=0,(x,y,z),lp;
mprimdec_lib.tex(,513) ideal i=x+1,y-1,z;
mprimdec_lib.tex(,514) i=std(i);
mprimdec_lib.tex(,515) ideal primId=primTest(i,z);
mprimdec_lib.tex(,516) primId;
mprimdec_lib.tex(,517) @expansion{} primId[1]=z
mprimdec_lib.tex(,518) @expansion{} primId[2]=y-1
mprimdec_lib.tex(,519) @expansion{} primId[3]=x+1
mprimdec_lib.tex(,520) i=x,z2,yz,y2;
mprimdec_lib.tex(,521) i=std(i);
mprimdec_lib.tex(,522) primId=primTest(i);
mprimdec_lib.tex(,523) primId;
mprimdec_lib.tex(,524) @expansion{} primId[1]=x
mprimdec_lib.tex(,525) @expansion{} primId[2]=y
mprimdec_lib.tex(,526) @expansion{} primId[3]=z
mprimdec_lib.tex(,527) @c end example primTest d2t_singular/mprimdec_lib.doc:365
mprimdec_lib.tex(,528) @end smallexample
mprimdec_lib.tex(,529) @c ---end content primTest---
mprimdec_lib.tex(,530) 
mprimdec_lib.tex(,531) @c ------------------- preComp -------------
mprimdec_lib.tex(,532) @node preComp, indSet, primTest, mprimdec_lib
mprimdec_lib.tex(,533) @subsubsection preComp
mprimdec_lib.tex(,534) @cindex preComp
mprimdec_lib.tex(,535) @c ---content preComp---
mprimdec_lib.tex(,536) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,537) 
mprimdec_lib.tex(,538) @table @asis
mprimdec_lib.tex(,539) @item @strong{Usage:}
mprimdec_lib.tex(,540) preComp(N,check[, ann]); module N, module check, ideal ann
mprimdec_lib.tex(,541) 
mprimdec_lib.tex(,542) @item @strong{Return:}
mprimdec_lib.tex(,543) (l, check) list l, module check
mprimdec_lib.tex(,544) @*the elements of l consists of a triple with
mprimdec_lib.tex(,545) @*[1] of type module [2] and [3] of type ideal
mprimdec_lib.tex(,546) @*s.th. the intersection of the modules is equal to the
mprimdec_lib.tex(,547) zero-dimensional module N, furthermore l[j][3]=annil(l[j][1])
mprimdec_lib.tex(,548) if l[j][2]!=0 then the module l[j][1] is primary
mprimdec_lib.tex(,549) @*with associated prime l[j][2],
mprimdec_lib.tex(,550) @*and check=intersect(check, l[j][1]) is computed
mprimdec_lib.tex(,551) 
mprimdec_lib.tex(,552) @item @strong{Note:}
mprimdec_lib.tex(,553) only components not containing check are computed;
mprimdec_lib.tex(,554) @*if ann is given, ann is used instead of annil(N)
mprimdec_lib.tex(,555) 
mprimdec_lib.tex(,556) @end table
mprimdec_lib.tex(,557) @strong{Example:}
mprimdec_lib.tex(,558) @smallexample
mprimdec_lib.tex(,559) @c computed example preComp d2t_singular/mprimdec_lib.doc:408 
mprimdec_lib.tex(,560) LIB "mprimdec.lib";
mprimdec_lib.tex(,561) ring r=0,z,lp;
mprimdec_lib.tex(,562) module N=z*gen(1), (z+1)*gen(2);
mprimdec_lib.tex(,563) N=std(N);
mprimdec_lib.tex(,564) list l; module check;
mprimdec_lib.tex(,565) (l, check)=preComp(N,freemodule(2));
mprimdec_lib.tex(,566) l;
mprimdec_lib.tex(,567) @expansion{} [1]:
mprimdec_lib.tex(,568) @expansion{}    [1]:
mprimdec_lib.tex(,569) @expansion{}       _[1]=z*gen(1)
mprimdec_lib.tex(,570) @expansion{}       _[2]=gen(2)
mprimdec_lib.tex(,571) @expansion{}    [2]:
mprimdec_lib.tex(,572) @expansion{}       _[1]=z
mprimdec_lib.tex(,573) @expansion{}    [3]:
mprimdec_lib.tex(,574) @expansion{}       _[1]=z
mprimdec_lib.tex(,575) @expansion{} [2]:
mprimdec_lib.tex(,576) @expansion{}    [1]:
mprimdec_lib.tex(,577) @expansion{}       _[1]=gen(1)
mprimdec_lib.tex(,578) @expansion{}       _[2]=z*gen(2)+gen(2)
mprimdec_lib.tex(,579) @expansion{}    [2]:
mprimdec_lib.tex(,580) @expansion{}       _[1]=z+1
mprimdec_lib.tex(,581) @expansion{}    [3]:
mprimdec_lib.tex(,582) @expansion{}       _[1]=z+1
mprimdec_lib.tex(,583) check;
mprimdec_lib.tex(,584) @expansion{} check[1]=z*gen(1)
mprimdec_lib.tex(,585) @expansion{} check[2]=z*gen(2)+gen(2)
mprimdec_lib.tex(,586) @c end example preComp d2t_singular/mprimdec_lib.doc:408
mprimdec_lib.tex(,587) @end smallexample
mprimdec_lib.tex(,588) @c ---end content preComp---
mprimdec_lib.tex(,589) 
mprimdec_lib.tex(,590) @c ------------------- indSet -------------
mprimdec_lib.tex(,591) @node indSet, GTZopt, preComp, mprimdec_lib
mprimdec_lib.tex(,592) @subsubsection indSet
mprimdec_lib.tex(,593) @cindex indSet
mprimdec_lib.tex(,594) @c ---content indSet---
mprimdec_lib.tex(,595) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,596) 
mprimdec_lib.tex(,597) @table @asis
mprimdec_lib.tex(,598) @item @strong{Usage:}
mprimdec_lib.tex(,599) indSet(i); i ideal
mprimdec_lib.tex(,600) 
mprimdec_lib.tex(,601) @item @strong{Return:}
mprimdec_lib.tex(,602) list with two entrees
mprimdec_lib.tex(,603) @*both are lists of new varstrings with the dependent variables
mprimdec_lib.tex(,604) the independent set, the ordstring with the corresp. block ordering,
mprimdec_lib.tex(,605) and the integer where the independent set starts in the varstring
mprimdec_lib.tex(,606) 
mprimdec_lib.tex(,607) @item @strong{Note:}
mprimdec_lib.tex(,608) the first entry gives the strings for all maximal independent sets
mprimdec_lib.tex(,609) the second gives the strings for the independent sets,
mprimdec_lib.tex(,610) @*which cannot be enhanced
mprimdec_lib.tex(,611) 
mprimdec_lib.tex(,612) @end table
mprimdec_lib.tex(,613) @strong{Example:}
mprimdec_lib.tex(,614) @smallexample
mprimdec_lib.tex(,615) @c computed example indSet d2t_singular/mprimdec_lib.doc:446 
mprimdec_lib.tex(,616) LIB "mprimdec.lib";
mprimdec_lib.tex(,617) ring s1=(0,x,y),(a,b,c,d,e,f,g),lp;
mprimdec_lib.tex(,618) ideal i=ea-fbg,fa+be,ec-fdg,fc+de;
mprimdec_lib.tex(,619) i=std(i);
mprimdec_lib.tex(,620) list  l=indSet(i);
mprimdec_lib.tex(,621) l;
mprimdec_lib.tex(,622) @expansion{} [1]:
mprimdec_lib.tex(,623) @expansion{}    [1]:
mprimdec_lib.tex(,624) @expansion{}       [1]:
mprimdec_lib.tex(,625) @expansion{}          e,f
mprimdec_lib.tex(,626) @expansion{}       [2]:
mprimdec_lib.tex(,627) @expansion{}          a,b,c,d,g
mprimdec_lib.tex(,628) @expansion{}       [3]:
mprimdec_lib.tex(,629) @expansion{}          (C,dp(2),dp)
mprimdec_lib.tex(,630) @expansion{}       [4]:
mprimdec_lib.tex(,631) @expansion{}          5
mprimdec_lib.tex(,632) @expansion{} [2]:
mprimdec_lib.tex(,633) @expansion{}    [1]:
mprimdec_lib.tex(,634) @expansion{}       [1]:
mprimdec_lib.tex(,635) @expansion{}          a,b,c,d
mprimdec_lib.tex(,636) @expansion{}       [2]:
mprimdec_lib.tex(,637) @expansion{}          e,f,g
mprimdec_lib.tex(,638) @expansion{}       [3]:
mprimdec_lib.tex(,639) @expansion{}          (C,dp(4),dp)
mprimdec_lib.tex(,640) @expansion{}       [4]:
mprimdec_lib.tex(,641) @expansion{}          3
mprimdec_lib.tex(,642) @expansion{}    [2]:
mprimdec_lib.tex(,643) @expansion{}       [1]:
mprimdec_lib.tex(,644) @expansion{}          a,c,e
mprimdec_lib.tex(,645) @expansion{}       [2]:
mprimdec_lib.tex(,646) @expansion{}          b,d,f,g
mprimdec_lib.tex(,647) @expansion{}       [3]:
mprimdec_lib.tex(,648) @expansion{}          (C,dp(3),dp)
mprimdec_lib.tex(,649) @expansion{}       [4]:
mprimdec_lib.tex(,650) @expansion{}          4
mprimdec_lib.tex(,651) @c end example indSet d2t_singular/mprimdec_lib.doc:446
mprimdec_lib.tex(,652) @end smallexample
mprimdec_lib.tex(,653) @c ---end content indSet---
mprimdec_lib.tex(,654) 
mprimdec_lib.tex(,655) @c ------------------- GTZopt -------------
mprimdec_lib.tex(,656) @node GTZopt, zeroOpt, indSet, mprimdec_lib
mprimdec_lib.tex(,657) @subsubsection GTZopt
mprimdec_lib.tex(,658) @cindex GTZopt
mprimdec_lib.tex(,659) @c ---content GTZopt---
mprimdec_lib.tex(,660) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,661) 
mprimdec_lib.tex(,662) @table @asis
mprimdec_lib.tex(,663) @item @strong{Usage:}
mprimdec_lib.tex(,664) GTZopt (N[, check]); module N[, module check]
mprimdec_lib.tex(,665) 
mprimdec_lib.tex(,666) @item @strong{Return:}
mprimdec_lib.tex(,667) list l
mprimdec_lib.tex(,668) @*the minimal primary decomposition of the module N,
mprimdec_lib.tex(,669) @*computed by a generalized and optimized version of
mprimdec_lib.tex(,670) @*the algorithm of Gianny, Trager and Zacharias
mprimdec_lib.tex(,671) 
mprimdec_lib.tex(,672) @item @strong{Note:}
mprimdec_lib.tex(,673) if the parameter check is given, only components
mprimdec_lib.tex(,674) @*not containing check are computed
mprimdec_lib.tex(,675) 
mprimdec_lib.tex(,676) @end table
mprimdec_lib.tex(,677) @strong{Example:}
mprimdec_lib.tex(,678) @smallexample
mprimdec_lib.tex(,679) @c computed example GTZopt d2t_singular/mprimdec_lib.doc:481 
mprimdec_lib.tex(,680) LIB "mprimdec.lib";
mprimdec_lib.tex(,681) ring r=0,(x,y,z),dp;
mprimdec_lib.tex(,682) module N=x*gen(1)+ y*gen(2),
mprimdec_lib.tex(,683) x*gen(1)-x2*gen(2);
mprimdec_lib.tex(,684) list l=GTZopt(N);
mprimdec_lib.tex(,685) l;
mprimdec_lib.tex(,686) @expansion{} [1]:
mprimdec_lib.tex(,687) @expansion{}    [1]:
mprimdec_lib.tex(,688) @expansion{}       _[1]=x*gen(1)+y*gen(2)
mprimdec_lib.tex(,689) @expansion{}       _[2]=x*gen(2)-gen(1)
mprimdec_lib.tex(,690) @expansion{}    [2]:
mprimdec_lib.tex(,691) @expansion{}       _[1]=x2+y
mprimdec_lib.tex(,692) @expansion{} [2]:
mprimdec_lib.tex(,693) @expansion{}    [1]:
mprimdec_lib.tex(,694) @expansion{}       _[1]=gen(2)
mprimdec_lib.tex(,695) @expansion{}       _[2]=x*gen(1)
mprimdec_lib.tex(,696) @expansion{}    [2]:
mprimdec_lib.tex(,697) @expansion{}       _[1]=x
mprimdec_lib.tex(,698) @c end example GTZopt d2t_singular/mprimdec_lib.doc:481
mprimdec_lib.tex(,699) @end smallexample
mprimdec_lib.tex(,700) @c ---end content GTZopt---
mprimdec_lib.tex(,701) 
mprimdec_lib.tex(,702) @c ------------------- zeroOpt -------------
mprimdec_lib.tex(,703) @node zeroOpt, clrSBmod, GTZopt, mprimdec_lib
mprimdec_lib.tex(,704) @subsubsection zeroOpt
mprimdec_lib.tex(,705) @cindex zeroOpt
mprimdec_lib.tex(,706) @c ---content zeroOpt---
mprimdec_lib.tex(,707) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,708) 
mprimdec_lib.tex(,709) @table @asis
mprimdec_lib.tex(,710) @item @strong{Usage:}
mprimdec_lib.tex(,711) zeroOpt (N[, check]); zero-dimensional module N[, module check]
mprimdec_lib.tex(,712) 
mprimdec_lib.tex(,713) @item @strong{Return:}
mprimdec_lib.tex(,714) list l
mprimdec_lib.tex(,715) @*the minimal primary decomposition of a zero-dimensional module N,
mprimdec_lib.tex(,716) computed by a generalized and optimized version of the algorithm
mprimdec_lib.tex(,717) of Gianny, Trager and Zacharias
mprimdec_lib.tex(,718) 
mprimdec_lib.tex(,719) @item @strong{Note:}
mprimdec_lib.tex(,720) if the parameter check is given, only components
mprimdec_lib.tex(,721) @*not containing check are computed
mprimdec_lib.tex(,722) 
mprimdec_lib.tex(,723) @end table
mprimdec_lib.tex(,724) @strong{Example:}
mprimdec_lib.tex(,725) @smallexample
mprimdec_lib.tex(,726) @c computed example zeroOpt d2t_singular/mprimdec_lib.doc:516 
mprimdec_lib.tex(,727) LIB "mprimdec.lib";
mprimdec_lib.tex(,728) ring r=0,z,dp;
mprimdec_lib.tex(,729) module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
mprimdec_lib.tex(,730) list l=zeroOpt(N);
mprimdec_lib.tex(,731) l;
mprimdec_lib.tex(,732) @expansion{} [1]:
mprimdec_lib.tex(,733) @expansion{}    [1]:
mprimdec_lib.tex(,734) @expansion{}       _[1]=gen(1)
mprimdec_lib.tex(,735) @expansion{}       _[2]=z*gen(2)-gen(2)
mprimdec_lib.tex(,736) @expansion{}       _[3]=gen(3)
mprimdec_lib.tex(,737) @expansion{}    [2]:
mprimdec_lib.tex(,738) @expansion{}       _[1]=z-1
mprimdec_lib.tex(,739) @expansion{} [2]:
mprimdec_lib.tex(,740) @expansion{}    [1]:
mprimdec_lib.tex(,741) @expansion{}       _[1]=z*gen(1)
mprimdec_lib.tex(,742) @expansion{}       _[2]=gen(2)
mprimdec_lib.tex(,743) @expansion{}       _[3]=gen(3)
mprimdec_lib.tex(,744) @expansion{}    [2]:
mprimdec_lib.tex(,745) @expansion{}       _[1]=z
mprimdec_lib.tex(,746) @expansion{} [3]:
mprimdec_lib.tex(,747) @expansion{}    [1]:
mprimdec_lib.tex(,748) @expansion{}       _[1]=gen(1)
mprimdec_lib.tex(,749) @expansion{}       _[2]=gen(2)
mprimdec_lib.tex(,750) @expansion{}       _[3]=z*gen(3)+gen(3)
mprimdec_lib.tex(,751) @expansion{}    [2]:
mprimdec_lib.tex(,752) @expansion{}       _[1]=z+1
mprimdec_lib.tex(,753) @c end example zeroOpt d2t_singular/mprimdec_lib.doc:516
mprimdec_lib.tex(,754) @end smallexample
mprimdec_lib.tex(,755) @c ---end content zeroOpt---
mprimdec_lib.tex(,756) 
mprimdec_lib.tex(,757) @c ------------------- clrSBmod -------------
mprimdec_lib.tex(,758) @node clrSBmod, minSatMod, zeroOpt, mprimdec_lib
mprimdec_lib.tex(,759) @subsubsection clrSBmod
mprimdec_lib.tex(,760) @cindex clrSBmod
mprimdec_lib.tex(,761) @c ---content clrSBmod---
mprimdec_lib.tex(,762) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,763) 
mprimdec_lib.tex(,764) @table @asis
mprimdec_lib.tex(,765) @item @strong{Usage:}
mprimdec_lib.tex(,766) clrSBmod(N); N module which is SB ordered by monomial ordering
mprimdec_lib.tex(,767) 
mprimdec_lib.tex(,768) @item @strong{Return:}
mprimdec_lib.tex(,769) module = minimal SB
mprimdec_lib.tex(,770) 
mprimdec_lib.tex(,771) @end table
mprimdec_lib.tex(,772) @strong{Example:}
mprimdec_lib.tex(,773) @smallexample
mprimdec_lib.tex(,774) @c computed example clrSBmod d2t_singular/mprimdec_lib.doc:543 
mprimdec_lib.tex(,775) LIB "mprimdec.lib";
mprimdec_lib.tex(,776) ring  r = (0,a,b),(x,y,z),dp;
mprimdec_lib.tex(,777) module N1=ax2+y,a2x+y,bx;
mprimdec_lib.tex(,778) module N2=clrSBmod(N1);
mprimdec_lib.tex(,779) N2;
mprimdec_lib.tex(,780) @expansion{} N2[1]=(a)*x2*gen(1)+y*gen(1)
mprimdec_lib.tex(,781) @expansion{} N2[2]=(b)*x*gen(1)
mprimdec_lib.tex(,782) @c end example clrSBmod d2t_singular/mprimdec_lib.doc:543
mprimdec_lib.tex(,783) @end smallexample
mprimdec_lib.tex(,784) @c ---end content clrSBmod---
mprimdec_lib.tex(,785) 
mprimdec_lib.tex(,786) @c ------------------- minSatMod -------------
mprimdec_lib.tex(,787) @node minSatMod, specialModulesEqual, clrSBmod, mprimdec_lib
mprimdec_lib.tex(,788) @subsubsection minSatMod
mprimdec_lib.tex(,789) @cindex minSatMod
mprimdec_lib.tex(,790) @c ---content minSatMod---
mprimdec_lib.tex(,791) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,792) 
mprimdec_lib.tex(,793) @table @asis
mprimdec_lib.tex(,794) @item @strong{Usage:}
mprimdec_lib.tex(,795) minSatMod(N, I); module N, ideal I
mprimdec_lib.tex(,796) 
mprimdec_lib.tex(,797) @item @strong{Return:}
mprimdec_lib.tex(,798) list with 2 elements:
mprimdec_lib.tex(,799) @*[1]=sat(N,product(I))[1],
mprimdec_lib.tex(,800) @*[2]=p, the polynomial of minimal degree s.th. [1]=quotient(N,p)
mprimdec_lib.tex(,801) 
mprimdec_lib.tex(,802) @end table
mprimdec_lib.tex(,803) @strong{Example:}
mprimdec_lib.tex(,804) @smallexample
mprimdec_lib.tex(,805) @c computed example minSatMod d2t_singular/mprimdec_lib.doc:572 
mprimdec_lib.tex(,806) LIB "mprimdec.lib";
mprimdec_lib.tex(,807) ring  r = 0,(x,y,z),dp;
mprimdec_lib.tex(,808) module N=xy*gen(1);
mprimdec_lib.tex(,809) ideal h=yz,z2;
mprimdec_lib.tex(,810) list l=minSatMod(N,h);
mprimdec_lib.tex(,811) l;
mprimdec_lib.tex(,812) @expansion{} [1]:
mprimdec_lib.tex(,813) @expansion{}    _[1]=x*gen(1)
mprimdec_lib.tex(,814) @expansion{} [2]:
mprimdec_lib.tex(,815) @expansion{}    y
mprimdec_lib.tex(,816) @c end example minSatMod d2t_singular/mprimdec_lib.doc:572
mprimdec_lib.tex(,817) @end smallexample
mprimdec_lib.tex(,818) @c ---end content minSatMod---
mprimdec_lib.tex(,819) 
mprimdec_lib.tex(,820) @c ------------------- specialModulesEqual -------------
mprimdec_lib.tex(,821) @node specialModulesEqual, stdModulesEqual, minSatMod, mprimdec_lib
mprimdec_lib.tex(,822) @subsubsection specialModulesEqual
mprimdec_lib.tex(,823) @cindex specialModulesEqual
mprimdec_lib.tex(,824) @c ---content specialModulesEqual---
mprimdec_lib.tex(,825) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,826) 
mprimdec_lib.tex(,827) @table @asis
mprimdec_lib.tex(,828) @item @strong{Usage:}
mprimdec_lib.tex(,829) specialModulesEqual(N1, N2) N1, N2 standard bases of modules,
mprimdec_lib.tex(,830) s.th. N1 is contained in N2 or vice versa
mprimdec_lib.tex(,831) 
mprimdec_lib.tex(,832) @item @strong{Return:}
mprimdec_lib.tex(,833) int i
mprimdec_lib.tex(,834) @*if (N1==N2) then i=1
mprimdec_lib.tex(,835) @*else i=0
mprimdec_lib.tex(,836) 
mprimdec_lib.tex(,837) @end table
mprimdec_lib.tex(,838) @strong{Example:}
mprimdec_lib.tex(,839) @smallexample
mprimdec_lib.tex(,840) @c computed example specialModulesEqual d2t_singular/mprimdec_lib.doc:603 
mprimdec_lib.tex(,841) LIB "mprimdec.lib";
mprimdec_lib.tex(,842) ring  r = 0,(x,y,z),dp;
mprimdec_lib.tex(,843) module N1=x*freemodule(2);
mprimdec_lib.tex(,844) module N2=xy*freemodule(2);
mprimdec_lib.tex(,845) int i=specialModulesEqual(N1,N2);
mprimdec_lib.tex(,846) i;
mprimdec_lib.tex(,847) @expansion{} 0
mprimdec_lib.tex(,848) N2=N1;
mprimdec_lib.tex(,849) i=specialModulesEqual(N1,N2);
mprimdec_lib.tex(,850) i;
mprimdec_lib.tex(,851) @expansion{} 1
mprimdec_lib.tex(,852) @c end example specialModulesEqual d2t_singular/mprimdec_lib.doc:603
mprimdec_lib.tex(,853) @end smallexample
mprimdec_lib.tex(,854) @c ---end content specialModulesEqual---
mprimdec_lib.tex(,855) 
mprimdec_lib.tex(,856) @c ------------------- stdModulesEqual -------------
mprimdec_lib.tex(,857) @node stdModulesEqual, modulesEqual, specialModulesEqual, mprimdec_lib
mprimdec_lib.tex(,858) @subsubsection stdModulesEqual
mprimdec_lib.tex(,859) @cindex stdModulesEqual
mprimdec_lib.tex(,860) @c ---content stdModulesEqual---
mprimdec_lib.tex(,861) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,862) 
mprimdec_lib.tex(,863) @table @asis
mprimdec_lib.tex(,864) @item @strong{Usage:}
mprimdec_lib.tex(,865) stdModulesEqual(N1, N2) N1, N2 standard bases of modules,
mprimdec_lib.tex(,866) 
mprimdec_lib.tex(,867) @item @strong{Return:}
mprimdec_lib.tex(,868) int i
mprimdec_lib.tex(,869) @*if (N1==N2) then i=1
mprimdec_lib.tex(,870) @*else i=0
mprimdec_lib.tex(,871) 
mprimdec_lib.tex(,872) @end table
mprimdec_lib.tex(,873) @strong{Example:}
mprimdec_lib.tex(,874) @smallexample
mprimdec_lib.tex(,875) @c computed example stdModulesEqual d2t_singular/mprimdec_lib.doc:636 
mprimdec_lib.tex(,876) LIB "mprimdec.lib";
mprimdec_lib.tex(,877) ring  r = 0,(x,y,z),dp;
mprimdec_lib.tex(,878) module N1=x*freemodule(2);
mprimdec_lib.tex(,879) module N2=xy*freemodule(2);
mprimdec_lib.tex(,880) int i=stdModulesEqual(N1,N2);
mprimdec_lib.tex(,881) i;
mprimdec_lib.tex(,882) @expansion{} 0
mprimdec_lib.tex(,883) N2=N1;
mprimdec_lib.tex(,884) i=stdModulesEqual(N1,N2);
mprimdec_lib.tex(,885) i;
mprimdec_lib.tex(,886) @expansion{} 1
mprimdec_lib.tex(,887) @c end example stdModulesEqual d2t_singular/mprimdec_lib.doc:636
mprimdec_lib.tex(,888) @end smallexample
mprimdec_lib.tex(,889) @c ---end content stdModulesEqual---
mprimdec_lib.tex(,890) 
mprimdec_lib.tex(,891) @c ------------------- modulesEqual -------------
mprimdec_lib.tex(,892) @node modulesEqual, getData, stdModulesEqual, mprimdec_lib
mprimdec_lib.tex(,893) @subsubsection modulesEqual
mprimdec_lib.tex(,894) @cindex modulesEqual
mprimdec_lib.tex(,895) @c ---content modulesEqual---
mprimdec_lib.tex(,896) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,897) 
mprimdec_lib.tex(,898) @table @asis
mprimdec_lib.tex(,899) @item @strong{Usage:}
mprimdec_lib.tex(,900) modulesEqual(N1, N2) N1, N2 modules,
mprimdec_lib.tex(,901) 
mprimdec_lib.tex(,902) @item @strong{Return:}
mprimdec_lib.tex(,903) int i
mprimdec_lib.tex(,904) @*if (N1==N2) then i=1
mprimdec_lib.tex(,905) @*else i=0
mprimdec_lib.tex(,906) 
mprimdec_lib.tex(,907) @end table
mprimdec_lib.tex(,908) @strong{Example:}
mprimdec_lib.tex(,909) @smallexample
mprimdec_lib.tex(,910) @c computed example modulesEqual d2t_singular/mprimdec_lib.doc:669 
mprimdec_lib.tex(,911) LIB "mprimdec.lib";
mprimdec_lib.tex(,912) ring  r = 0,(x,y,z),dp;
mprimdec_lib.tex(,913) module N1=x*freemodule(2);
mprimdec_lib.tex(,914) module N2=xy*freemodule(2);
mprimdec_lib.tex(,915) int i=modulesEqual(N1,N2);
mprimdec_lib.tex(,916) i;
mprimdec_lib.tex(,917) @expansion{} 0
mprimdec_lib.tex(,918) N2=N1;
mprimdec_lib.tex(,919) i=modulesEqual(N1,N2);
mprimdec_lib.tex(,920) i;
mprimdec_lib.tex(,921) @expansion{} 1
mprimdec_lib.tex(,922) @c end example modulesEqual d2t_singular/mprimdec_lib.doc:669
mprimdec_lib.tex(,923) @end smallexample
mprimdec_lib.tex(,924) @c ---end content modulesEqual---
mprimdec_lib.tex(,925) 
mprimdec_lib.tex(,926) @c ------------------- getData -------------
mprimdec_lib.tex(,927) @node getData,, modulesEqual, mprimdec_lib
mprimdec_lib.tex(,928) @subsubsection getData
mprimdec_lib.tex(,929) @cindex getData
mprimdec_lib.tex(,930) @c ---content getData---
mprimdec_lib.tex(,931) Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).
mprimdec_lib.tex(,932) 
mprimdec_lib.tex(,933) @table @asis
mprimdec_lib.tex(,934) @item @strong{Usage:}
mprimdec_lib.tex(,935) getData(N, l[, noCheck]); module N, list l[, int noCheck]
mprimdec_lib.tex(,936) 
mprimdec_lib.tex(,937) @item @strong{Return:}
mprimdec_lib.tex(,938) (ann, check, M, checked)
mprimdec_lib.tex(,939) @*ideal ann, module check, M, int checked
mprimdec_lib.tex(,940) 
mprimdec_lib.tex(,941) if l[1] is contained in N [and noCheck is not given]
mprimdec_lib.tex(,942) @*then checked=1, ann=ideal(0), check=0, M=0;
mprimdec_lib.tex(,943) @*else checked=0, M=freemodule(nrows(N)); check=l[1]
mprimdec_lib.tex(,944) @*(resp. check=M if l is an empty list) and
mprimdec_lib.tex(,945) @*if size(l)>1 then ann=l[2] else ann is the annihilator of M/N.
mprimdec_lib.tex(,946) 
mprimdec_lib.tex(,947) @item @strong{Note:}
mprimdec_lib.tex(,948) ann is a std basis in the basering
mprimdec_lib.tex(,949) 
mprimdec_lib.tex(,950) @end table
mprimdec_lib.tex(,951) @strong{Example:}
mprimdec_lib.tex(,952) @smallexample
mprimdec_lib.tex(,953) @c computed example getData d2t_singular/mprimdec_lib.doc:710 
mprimdec_lib.tex(,954) LIB "mprimdec.lib";
mprimdec_lib.tex(,955) ring  r = 0,(x,y,z),lp;
mprimdec_lib.tex(,956) module N=x*gen(1),y*gen(2);
mprimdec_lib.tex(,957) N=std(N);
mprimdec_lib.tex(,958) ideal ann; module check, M; int checked; list l;
mprimdec_lib.tex(,959) (ann, check, M, checked)=getData(N,l);
mprimdec_lib.tex(,960) ann; check; M; checked;
mprimdec_lib.tex(,961) @expansion{} ann[1]=xy
mprimdec_lib.tex(,962) @expansion{} check[1]=gen(1)
mprimdec_lib.tex(,963) @expansion{} check[2]=gen(2)
mprimdec_lib.tex(,964) @expansion{} M[1]=gen(1)
mprimdec_lib.tex(,965) @expansion{} M[2]=gen(2)
mprimdec_lib.tex(,966) @expansion{} 0
mprimdec_lib.tex(,967) l=list(check,ann);
mprimdec_lib.tex(,968) (ann, check, M, checked)=getData(N,l);
mprimdec_lib.tex(,969) ann; check; M; checked;
mprimdec_lib.tex(,970) @expansion{} ann[1]=xy
mprimdec_lib.tex(,971) @expansion{} check[1]=gen(1)
mprimdec_lib.tex(,972) @expansion{} check[2]=gen(2)
mprimdec_lib.tex(,973) @expansion{} M[1]=gen(1)
mprimdec_lib.tex(,974) @expansion{} M[2]=gen(2)
mprimdec_lib.tex(,975) @expansion{} 0
mprimdec_lib.tex(,976) l=list(N);
mprimdec_lib.tex(,977) (ann, check, M, checked)=getData(N,l);
mprimdec_lib.tex(,978) ann; check; M; checked;
mprimdec_lib.tex(,979) @expansion{} ann[1]=0
mprimdec_lib.tex(,980) @expansion{} check[1]=0
mprimdec_lib.tex(,981) @expansion{} M[1]=0
mprimdec_lib.tex(,982) @expansion{} 1
mprimdec_lib.tex(,983) @c end example getData d2t_singular/mprimdec_lib.doc:710
mprimdec_lib.tex(,984) @end smallexample
mprimdec_lib.tex(,985) @c ---end content getData---
singular.texi(,391) @c ----------------------------------------------------------
singular.texi(,392) @node mregular_lib, normal_lib, mprimdec_lib, Commutative algebra
singular.texi(,393) @subsection mregular_lib
singular.texi(,394) @c include of docu for mregular.lib
mregular_lib.tex(,1) @c ---content LibInfo---
mregular_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/mregular_lib.doc
mregular_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/mregular_lib.doc INSTEAD
mregular_lib.tex(,4) @c library version: (1.6.2.1,2002/02/20)
mregular_lib.tex(,5) @c library file: ../Singular/LIB/mregular.lib
mregular_lib.tex(,6) @cindex mregular.lib
mregular_lib.tex(,7) @cindex mregular_lib
mregular_lib.tex(,8) @table @asis
mregular_lib.tex(,9) @item @strong{Library:}
mregular_lib.tex(,10) mregular.lib
mregular_lib.tex(,11) @item @strong{Purpose:}
mregular_lib.tex(,12)    Castelnuovo-Mumford Regularity of CM-Schemes and Curves
mregular_lib.tex(,13) @item @strong{Authors:}
mregular_lib.tex(,14) I.Bermejo, ibermejo@@ull.es
mregular_lib.tex(,15) @* Ph.Gimenez, pgimenez@@agt.uva.es
mregular_lib.tex(,16) @* G.-M.Greuel, greuel@@mathematik.uni-kl.de
mregular_lib.tex(,17) 
mregular_lib.tex(,18) @item @strong{Overview:}
mregular_lib.tex(,19) A library for computing the Castelnuovo-Mumford regularity of a subscheme of
mregular_lib.tex(,20) the projective n-space that DOES NOT require the computation of a minimal
mregular_lib.tex(,21) graded free resolution of the saturated ideal defining the subscheme.
mregular_lib.tex(,22) The procedures are based on two papers by Isabel Bermejo and Philippe Gimenez:
mregular_lib.tex(,23) 'On Castelnuovo-Mumford regularity of projective curves' Proc.Amer.Math.Soc.
mregular_lib.tex(,24) 128(5) (2000), and 'Computing the Castelnuovo-Mumford regularity of some
mregular_lib.tex(,25) subschemes of Pn using quotients of monomial ideals', Proceedings of
mregular_lib.tex(,26) MEGA-2000, J. Pure Appl. Algebra (to appear).
mregular_lib.tex(,27) @*The algorithm assumes the variables to be in Noether position.
mregular_lib.tex(,28) 
mregular_lib.tex(,29) @end table
mregular_lib.tex(,30) 
mregular_lib.tex(,31) @strong{Procedures:}
mregular_lib.tex(,32) @menu
mregular_lib.tex(,33) * reg_CM:: regularity of arith. C-M subscheme V(id_sat) of Pn
mregular_lib.tex(,34) * reg_curve:: regularity of projective curve V(id_sat) in Pn
mregular_lib.tex(,35) * reg_moncurve:: regularity of projective monomial curve defined by li
mregular_lib.tex(,36) @end menu
mregular_lib.tex(,37) @c ---end content LibInfo---
mregular_lib.tex(,38) 
mregular_lib.tex(,39) @c ------------------- reg_CM -------------
mregular_lib.tex(,40) @node reg_CM, reg_curve,, mregular_lib
mregular_lib.tex(,41) @subsubsection reg_CM
mregular_lib.tex(,42) @cindex reg_CM
mregular_lib.tex(,43) @c ---content reg_CM---
mregular_lib.tex(,44) Procedure from library @code{mregular.lib} (@pxref{mregular_lib}).
mregular_lib.tex(,45) 
mregular_lib.tex(,46) @table @asis
mregular_lib.tex(,47) @item @strong{Usage:}
mregular_lib.tex(,48) reg_CM (i); i ideal
mregular_lib.tex(,49) 
mregular_lib.tex(,50) @item @strong{Return:}
mregular_lib.tex(,51) an integer, the Castelnuovo-Mumford regularity of i-sat.
mregular_lib.tex(,52) 
mregular_lib.tex(,53) @item @strong{Assume:}
mregular_lib.tex(,54) i is a homogeneous ideal of the basering S=K[x(0)..x(n)] where
mregular_lib.tex(,55) the field K is infinite, and S/i-sat is Cohen-Macaulay.
mregular_lib.tex(,56) Assume that K[x(n-d),...,x(n)] is a Noether normalization of S/i-sat
mregular_lib.tex(,57) where d=dim S/i -1. If this is not the case, compute a Noether
mregular_lib.tex(,58) normalization e.g. by using the proc noetherNormal from algebra.lib.
mregular_lib.tex(,59) 
mregular_lib.tex(,60) @item @strong{Note:}
mregular_lib.tex(,61) The output is reg(X)=reg(i-sat) where X is the arithmetically
mregular_lib.tex(,62) Cohen-Macaulay subscheme of the projective n-space defined by i.
mregular_lib.tex(,63) If printlevel > 0 (default = 0) additional information is displayed.
mregular_lib.tex(,64) In particular, the value of the regularity of the Hilbert function of
mregular_lib.tex(,65) S/i-sat is given.
mregular_lib.tex(,66) 
mregular_lib.tex(,67) @end table
mregular_lib.tex(,68) @strong{Example:}
mregular_lib.tex(,69) @smallexample
mregular_lib.tex(,70) @c computed example reg_CM d2t_singular/mregular_lib.doc:68 
mregular_lib.tex(,71) LIB "mregular.lib";
mregular_lib.tex(,72) ring s=0,x(0..5),dp;
mregular_lib.tex(,73) ideal i=x(2)^2-x(4)*x(5),x(1)*x(2)-x(0)*x(5),x(0)*x(2)-x(1)*x(4),
mregular_lib.tex(,74) x(1)^2-x(3)*x(5),x(0)*x(1)-x(2)*x(3),x(0)^2-x(3)*x(4);
mregular_lib.tex(,75) reg_CM(i);
mregular_lib.tex(,76) @expansion{} 2
mregular_lib.tex(,77) // Additional information can be obtained as follows:
mregular_lib.tex(,78) printlevel = 1;
mregular_lib.tex(,79) reg_CM(i);
mregular_lib.tex(,80) @expansion{} // Ideal i of S defining an arithm. Cohen-Macaulay subscheme X of P5:
mregular_lib.tex(,81) @expansion{} //   - dimension of X: 2
mregular_lib.tex(,82) @expansion{} //   - i is saturated: YES
mregular_lib.tex(,83) @expansion{} //   - regularity of the Hilbert function of S/i-sat: -1
mregular_lib.tex(,84) @expansion{} //   - time for computing reg(X): 0 sec.
mregular_lib.tex(,85) @expansion{} // Castelnuovo-Mumford regularity of X:
mregular_lib.tex(,86) @expansion{} 2
mregular_lib.tex(,87) @c end example reg_CM d2t_singular/mregular_lib.doc:68
mregular_lib.tex(,88) @end smallexample
mregular_lib.tex(,89) @c ---end content reg_CM---
mregular_lib.tex(,90) 
mregular_lib.tex(,91) @c ------------------- reg_curve -------------
mregular_lib.tex(,92) @node reg_curve, reg_moncurve, reg_CM, mregular_lib
mregular_lib.tex(,93) @subsubsection reg_curve
mregular_lib.tex(,94) @cindex reg_curve
mregular_lib.tex(,95) @c ---content reg_curve---
mregular_lib.tex(,96) Procedure from library @code{mregular.lib} (@pxref{mregular_lib}).
mregular_lib.tex(,97) 
mregular_lib.tex(,98) @table @asis
mregular_lib.tex(,99) @item @strong{Usage:}
mregular_lib.tex(,100) reg_curve (i[,e]); i ideal, e integer
mregular_lib.tex(,101) 
mregular_lib.tex(,102) @item @strong{Return:}
mregular_lib.tex(,103) an integer, the Castelnuovo-Mumford regularity of i-sat.
mregular_lib.tex(,104) 
mregular_lib.tex(,105) @item @strong{Assume:}
mregular_lib.tex(,106) i is a homogeneous ideal of the basering S=K[x(0)..x(n)] where
mregular_lib.tex(,107) the field K is infinite, and it defines a projective curve C in
mregular_lib.tex(,108) the projective n-space (dim(i)=2). We assume that K[x(n-1),x(n)]
mregular_lib.tex(,109) is a Noether normalization of S/i-sat.
mregular_lib.tex(,110) @*e=0: (default)
mregular_lib.tex(,111) @*Uses a random choice of an element of K when it is necessary.
mregular_lib.tex(,112) This is absolutely safe (if the element is bad, another random
mregular_lib.tex(,113) choice will be done until a good element is found).
mregular_lib.tex(,114) @*e=1: Substitutes the random choice of an element of K by a simple
mregular_lib.tex(,115) transcendental field extension of K.
mregular_lib.tex(,116) 
mregular_lib.tex(,117) @item @strong{Note:}
mregular_lib.tex(,118) The output is the integer reg(C)=reg(i-sat).
mregular_lib.tex(,119) @*If printlevel > 0 (default = 0) additional information is displayed.
mregular_lib.tex(,120) In particular, says if C is arithmetically Cohen-Macaulay or not,
mregular_lib.tex(,121) determines in which step of a minimal graded free resolution of i-sat
mregular_lib.tex(,122) the regularity of C is attained, and sometimes gives the value of the
mregular_lib.tex(,123) regularity of the Hilbert function of S/i-sat (otherwise, an upper
mregular_lib.tex(,124) bound is given).
mregular_lib.tex(,125) 
mregular_lib.tex(,126) @end table
mregular_lib.tex(,127) @strong{Example:}
mregular_lib.tex(,128) @smallexample
mregular_lib.tex(,129) @c computed example reg_curve d2t_singular/mregular_lib.doc:119 
mregular_lib.tex(,130) LIB "mregular.lib";
mregular_lib.tex(,131) ring s = 0,(x,y,z,t),dp;
mregular_lib.tex(,132) // 1st example is Ex.2.5 in [Bermejo-Gimenez], Proc.Amer.Math.Soc. 128(5):
mregular_lib.tex(,133) ideal i  = x17y14-y31, x20y13, x60-y36z24-x20z20t20;
mregular_lib.tex(,134) reg_curve(i);
mregular_lib.tex(,135) @expansion{} 72
mregular_lib.tex(,136) // 2nd example is Ex.2.9 in [Bermejo-Gimenez], Proc.Amer.Math.Soc. 128(5):
mregular_lib.tex(,137) int k=43;
mregular_lib.tex(,138) ideal j=x17y14-y31,x20y13,x60-y36z24-x20z20t20,y41*z^k-y40*z^(k+1);
mregular_lib.tex(,139) reg_curve(j);
mregular_lib.tex(,140) @expansion{} 93
mregular_lib.tex(,141) // Additional information can be obtained as follows:
mregular_lib.tex(,142) printlevel = 1;
mregular_lib.tex(,143) reg_curve(j);
mregular_lib.tex(,144) @expansion{} // Ideal i of S defining a projective curve C in P3:
mregular_lib.tex(,145) @expansion{} //   - i is saturated: YES
mregular_lib.tex(,146) @expansion{} //   - C is arithm. Cohen-Macaulay: NO
mregular_lib.tex(,147) @expansion{} //   - reg(C) attained at the last step of a m.g.f.r. of i-sat: YES
mregular_lib.tex(,148) @expansion{} //   - regularity of the Hilbert function of S/i-sat: 92
mregular_lib.tex(,149) @expansion{} //   - time for computing reg(C): 0 sec.
mregular_lib.tex(,150) @expansion{} // Castelnuovo-Mumford regularity of C:
mregular_lib.tex(,151) @expansion{} 93
mregular_lib.tex(,152) @c end example reg_curve d2t_singular/mregular_lib.doc:119
mregular_lib.tex(,153) @end smallexample
mregular_lib.tex(,154) @c ---end content reg_curve---
mregular_lib.tex(,155) 
mregular_lib.tex(,156) @c ------------------- reg_moncurve -------------
mregular_lib.tex(,157) @node reg_moncurve,, reg_curve, mregular_lib
mregular_lib.tex(,158) @subsubsection reg_moncurve
mregular_lib.tex(,159) @cindex reg_moncurve
mregular_lib.tex(,160) @c ---content reg_moncurve---
mregular_lib.tex(,161) Procedure from library @code{mregular.lib} (@pxref{mregular_lib}).
mregular_lib.tex(,162) 
mregular_lib.tex(,163) @table @asis
mregular_lib.tex(,164) @item @strong{Usage:}
mregular_lib.tex(,165) reg_moncurve (a0,...,an) ; ai integers with a0=0 < a1 < ... < an=:d
mregular_lib.tex(,166) 
mregular_lib.tex(,167) @item @strong{Return:}
mregular_lib.tex(,168) an integer, the Castelnuovo-Mumford regularity of the projective
mregular_lib.tex(,169) monomial curve C in Pn parametrically defined by:
mregular_lib.tex(,170) @*x(0)=t^d , x(1)=s^(a1)t^(d-a1), ... , x(n)=s^d.
mregular_lib.tex(,171) 
mregular_lib.tex(,172) @item @strong{Assume:}
mregular_lib.tex(,173) a0=0 < a1 < ... < an are integers and the base field is infinite.
mregular_lib.tex(,174) 
mregular_lib.tex(,175) @item @strong{Note:}
mregular_lib.tex(,176) The defining ideal I(C) in S is determined using elimination.
mregular_lib.tex(,177) The procedure reg_curve is improved in this case since one
mregular_lib.tex(,178) knows beforehand that the dimension is 2, that the variables are
mregular_lib.tex(,179) in Noether position, that I(C) is prime.
mregular_lib.tex(,180) @*If printlevel > 0 (default = 0) additional information is displayed.
mregular_lib.tex(,181) In particular, says if C is arithmetically Cohen-Macaulay or not,
mregular_lib.tex(,182) determines in which step of a minimal graded free resolution of I(C)
mregular_lib.tex(,183) the regularity is attained, and sometimes gives the value of the
mregular_lib.tex(,184) regularity of the Hilbert function of S/I(C) (otherwise, an upper
mregular_lib.tex(,185) bound is given).
mregular_lib.tex(,186) 
mregular_lib.tex(,187) @end table
mregular_lib.tex(,188) @strong{Example:}
mregular_lib.tex(,189) @smallexample
mregular_lib.tex(,190) @c computed example reg_moncurve d2t_singular/mregular_lib.doc:170 
mregular_lib.tex(,191) LIB "mregular.lib";
mregular_lib.tex(,192) // The 1st example is the twisted cubic:
mregular_lib.tex(,193) reg_moncurve(0,1,2,3);
mregular_lib.tex(,194) @expansion{} 2
mregular_lib.tex(,195) // The 2nd. example is the non arithm. Cohen-Macaulay monomial curve in P4
mregular_lib.tex(,196) // parametrized by: x(0)-s6,x(1)-s5t,x(2)-s3t3,x(3)-st5,x(4)-t6:
mregular_lib.tex(,197) reg_moncurve(0,1,3,5,6);
mregular_lib.tex(,198) @expansion{} 3
mregular_lib.tex(,199) // Additional information can be obtained as follows:
mregular_lib.tex(,200) printlevel = 1;
mregular_lib.tex(,201) reg_moncurve(0,1,3,5,6);
mregular_lib.tex(,202) @expansion{} // Sequence of integers defining a monomial curve C in P4:
mregular_lib.tex(,203) @expansion{} //   - time for computing ideal I(C) of S (elimination): 0 sec.
mregular_lib.tex(,204) @expansion{} //   - C is arithm. Cohen-Macaulay: NO
mregular_lib.tex(,205) @expansion{} //   - reg(C) attained at the last step of a m.g.f.r. of I(C): YES
mregular_lib.tex(,206) @expansion{} //   - reg(C) attained at the second last step of a m.g.f.r. of I(C): YES
mregular_lib.tex(,207) @expansion{} //   - regularity of the Hilbert function of S/I(C): 2
mregular_lib.tex(,208) @expansion{} //   - time for computing reg(C): 0 sec.
mregular_lib.tex(,209) @expansion{} // Castelnuovo-Mumford regularity of C:
mregular_lib.tex(,210) @expansion{} 3
mregular_lib.tex(,211) @c end example reg_moncurve d2t_singular/mregular_lib.doc:170
mregular_lib.tex(,212) @end smallexample
mregular_lib.tex(,213) @c ---end content reg_moncurve---
singular.texi(,396) @c ---------------------------------------------------------
singular.texi(,397) @node normal_lib, primdec_lib, mregular_lib, Commutative algebra
singular.texi(,398) @subsection normal_lib
singular.texi(,399) @c include of docu for normal.lib
normal_lib.tex(,1) @c ---content LibInfo---
normal_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/normal_lib.doc
normal_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/normal_lib.doc INSTEAD
normal_lib.tex(,4) @c library version: (1.34.2.17,2002/10/21)
normal_lib.tex(,5) @c library file: ../Singular/LIB/normal.lib
normal_lib.tex(,6) @cindex normal.lib
normal_lib.tex(,7) @cindex normal_lib
normal_lib.tex(,8) @table @asis
normal_lib.tex(,9) @item @strong{Library:}
normal_lib.tex(,10) normal.lib
normal_lib.tex(,11) @item @strong{Purpose:}
normal_lib.tex(,12)      Normalization of Affine Rings
normal_lib.tex(,13) @item @strong{Authors:}
normal_lib.tex(,14) G.-M. Greuel, greuel@@mathematik.uni-kl.de,
normal_lib.tex(,15) @* G. Pfister, pfister@@mathematik.uni-kl.de
normal_lib.tex(,16) 
normal_lib.tex(,17) @end table
normal_lib.tex(,18) 
normal_lib.tex(,19) @strong{Main procedures:}
normal_lib.tex(,20) @menu
normal_lib.tex(,21) * normal:: computes the normalization of basering/I, resp. computes the normalization of basering/I and the delta invariant
normal_lib.tex(,22) * HomJJ:: presentation of End_R(J) as affine ring, L a list
normal_lib.tex(,23) * genus:: computes genus of the projective curve defined by I
normal_lib.tex(,24) @end menu
normal_lib.tex(,25) @strong{Auxiliary procedure:}
normal_lib.tex(,26) @menu
normal_lib.tex(,27) * deltaLoc:: (sum of) delta invariant(s) at conjugated singular points
normal_lib.tex(,28) @end menu
normal_lib.tex(,29) @c ---end content LibInfo---
normal_lib.tex(,30) 
normal_lib.tex(,31) @c ------------------- normal -------------
normal_lib.tex(,32) @node normal, HomJJ,, normal_lib
normal_lib.tex(,33) @subsubsection normal
normal_lib.tex(,34) @cindex normal
normal_lib.tex(,35) @c ---content normal---
normal_lib.tex(,36) Procedure from library @code{normal.lib} (@pxref{normal_lib}).
normal_lib.tex(,37) 
normal_lib.tex(,38) @table @asis
normal_lib.tex(,39) @item @strong{Usage:}
normal_lib.tex(,40) normal(i [,choose]); i a radical ideal, choose empty, 1 or "wd"
normal_lib.tex(,41) if choose=1 the normalization of the associated primes is computed
normal_lib.tex(,42) (which is sometimes more efficient);
normal_lib.tex(,43) if @code{choose="wd"} the delta invariant is computed
normal_lib.tex(,44) simultaneously; this may take much more time in the reducible case,
normal_lib.tex(,45) since the factorizing standard basis algorithm cannot be used.
normal_lib.tex(,46) 
normal_lib.tex(,47) @item @strong{Assume:}
normal_lib.tex(,48) The ideal must be radical, for non-radical ideals the output may
normal_lib.tex(,49) be wrong (i=radical(i); makes i radical)
normal_lib.tex(,50) 
normal_lib.tex(,51) @item @strong{Return:}
normal_lib.tex(,52) a list of rings, say nor and in case of @code{choose="wd"} an
normal_lib.tex(,53) integer at the end of the list.
normal_lib.tex(,54) Each ring @code{nor[i]} contains two ideals with given names
normal_lib.tex(,55) @code{norid} and @code{normap} such that@*
normal_lib.tex(,56) - the direct sum of the rings @code{nor[i]/norid} is the
normal_lib.tex(,57) normalization of basering/id;@*
normal_lib.tex(,58) - @code{normap} gives the normalization map from basering/id to
normal_lib.tex(,59) @code{nor[i]/norid} (for each i).
normal_lib.tex(,60) 
normal_lib.tex(,61) @item @strong{Note:}
normal_lib.tex(,62) to use the i-th ring type: @code{def R=nor[i]; setring R;}.
normal_lib.tex(,63) @* Increasing printlevel displays more comments (default: printlevel=0).
normal_lib.tex(,64) @* Not implemented for local or mixed orderings.
normal_lib.tex(,65) @* If the input ideal i is weighted homogeneous a weighted ordering may
normal_lib.tex(,66) be used (qhweight(i); computes weights).
normal_lib.tex(,67) 
normal_lib.tex(,68) @cindex normalization
normal_lib.tex(,69) @cindex delta invariant.
normal_lib.tex(,70) @end table
normal_lib.tex(,71) @strong{Example:}
normal_lib.tex(,72) @smallexample
normal_lib.tex(,73) @c computed example normal d2t_singular/normal_lib.doc:71 
normal_lib.tex(,74) LIB "normal.lib";
normal_lib.tex(,75) ring r=32003,(x,y,z),wp(2,1,2);
normal_lib.tex(,76) ideal i=z3-xy4;
normal_lib.tex(,77) list nor=normal(i);
normal_lib.tex(,78) @expansion{} 
normal_lib.tex(,79) @expansion{} // 'normal' created a list of 1 ring(s).
normal_lib.tex(,80) @expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
normal_lib.tex(,81) @expansion{} // To see the rings, type (if the name of your list is nor):
normal_lib.tex(,82) @expansion{}      show( nor);
normal_lib.tex(,83) @expansion{} // To access the 1-st ring and map (similar for the others), type:
normal_lib.tex(,84) @expansion{}      def R = nor[1]; setring R;  norid; normap;
normal_lib.tex(,85) @expansion{} // R/norid is the 1-st ring of the normalization and
normal_lib.tex(,86) @expansion{} // normap the map from the original basering to R/norid
normal_lib.tex(,87) show(nor);
normal_lib.tex(,88) @expansion{} // list, 1 element(s):
normal_lib.tex(,89) @expansion{} [1]:
normal_lib.tex(,90) @expansion{}    // ring: (32003),(T(1),T(2),T(3)),(a(2,1,1),dp(3),C);
normal_lib.tex(,91) @expansion{}    // minpoly = 0
normal_lib.tex(,92) @expansion{} // objects belonging to this ring:
normal_lib.tex(,93) @expansion{} // normap               [0]  ideal, 3 generator(s)
normal_lib.tex(,94) @expansion{} // norid                [0]  ideal, 1 generator(s)
normal_lib.tex(,95) def r1=nor[1];
normal_lib.tex(,96) setring r1;
normal_lib.tex(,97) norid;
normal_lib.tex(,98) @expansion{} norid[1]=T(3)3-T(1)T(2)
normal_lib.tex(,99) normap;
normal_lib.tex(,100) @expansion{} normap[1]=T(1)
normal_lib.tex(,101) @expansion{} normap[2]=T(2)
normal_lib.tex(,102) @expansion{} normap[3]=T(2)T(3)
normal_lib.tex(,103) ring s=0,(x,y),dp;
normal_lib.tex(,104) ideal i=(x-y^2)^2 - y*x^3;
normal_lib.tex(,105) nor=normal(i,"wd");
normal_lib.tex(,106) @expansion{} 
normal_lib.tex(,107) @expansion{} // 'normal' created a list of 1 ring(s).
normal_lib.tex(,108) @expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
normal_lib.tex(,109) @expansion{} // To see the rings, type (if the name of your list is nor):
normal_lib.tex(,110) @expansion{}      show( nor);
normal_lib.tex(,111) @expansion{} // To access the 1-st ring and map (similar for the others), type:
normal_lib.tex(,112) @expansion{}      def R = nor[1]; setring R;  norid; normap;
normal_lib.tex(,113) @expansion{} // R/norid is the 1-st ring of the normalization and
normal_lib.tex(,114) @expansion{} // normap the map from the original basering to R/norid
normal_lib.tex(,115) //the delta-invariant
normal_lib.tex(,116) nor[size(nor)];
normal_lib.tex(,117) @expansion{} 3
normal_lib.tex(,118) @c end example normal d2t_singular/normal_lib.doc:71
normal_lib.tex(,119) @end smallexample
normal_lib.tex(,120) @c ---end content normal---
normal_lib.tex(,121) 
normal_lib.tex(,122) @c ------------------- HomJJ -------------
normal_lib.tex(,123) @node HomJJ, genus, normal, normal_lib
normal_lib.tex(,124) @subsubsection HomJJ
normal_lib.tex(,125) @cindex HomJJ
normal_lib.tex(,126) @c ---content HomJJ---
normal_lib.tex(,127) Procedure from library @code{normal.lib} (@pxref{normal_lib}).
normal_lib.tex(,128) 
normal_lib.tex(,129) @table @asis
normal_lib.tex(,130) @item @strong{Usage:}
normal_lib.tex(,131) HomJJ (Li); Li = list: ideal SBid, ideal id, ideal J, poly p
normal_lib.tex(,132) 
normal_lib.tex(,133) @item @strong{Assume:}
normal_lib.tex(,134) R = P/id, P = basering, a polynomial ring, id an ideal of P,
normal_lib.tex(,135) @* SBid = standard basis of id,
normal_lib.tex(,136) @* J = ideal of P containing the polynomial p,
normal_lib.tex(,137) @* p = nonzero divisor of R
normal_lib.tex(,138) 
normal_lib.tex(,139) @item @strong{Compute:}
normal_lib.tex(,140) Endomorphism ring End_R(J)=Hom_R(J,J) with its ring structure as
normal_lib.tex(,141) affine ring, together with the canonical map R --> Hom_R(J,J),
normal_lib.tex(,142) where R is the quotient ring of P modulo the standard basis SBid.
normal_lib.tex(,143) 
normal_lib.tex(,144) @item @strong{Return:}
normal_lib.tex(,145) a list l of two objects
normal_lib.tex(,146) @format
normal_lib.tex(,147)          l[1] : a polynomial ring, containing two ideals, 'endid' and 'endphi'
normal_lib.tex(,148)                such that l[1]/endid = Hom_R(J,J) and
normal_lib.tex(,149)                endphi describes the canonical map R -> Hom_R(J,J)
normal_lib.tex(,150)          l[2] : an integer which is 1 if phi is an isomorphism, 0 if not
normal_lib.tex(,151)          l[3] : an integer, the contribution to delta
normal_lib.tex(,152) @end format
normal_lib.tex(,153) 
normal_lib.tex(,154) @item @strong{Note:}
normal_lib.tex(,155) printlevel >=1: display comments (default: printlevel=0)
normal_lib.tex(,156) 
normal_lib.tex(,157) @end table
normal_lib.tex(,158) @strong{Example:}
normal_lib.tex(,159) @smallexample
normal_lib.tex(,160) @c computed example HomJJ d2t_singular/normal_lib.doc:128 
normal_lib.tex(,161) LIB "normal.lib";
normal_lib.tex(,162) ring r   = 0,(x,y),wp(2,3);
normal_lib.tex(,163) ideal id = y^2-x^3;
normal_lib.tex(,164) ideal J  = x,y;
normal_lib.tex(,165) poly p   = x;
normal_lib.tex(,166) list Li = std(id),id,J,p;
normal_lib.tex(,167) list L   = HomJJ(Li);
normal_lib.tex(,168) def end = L[1];    // defines ring L[1], containing ideals endid, endphi
normal_lib.tex(,169) setring end;       // makes end the basering
normal_lib.tex(,170) end;
normal_lib.tex(,171) @expansion{} //   characteristic : 0
normal_lib.tex(,172) @expansion{} //   number of vars : 1
normal_lib.tex(,173) @expansion{} //        block   1 : ordering dp
normal_lib.tex(,174) @expansion{} //                  : names    T(1) 
normal_lib.tex(,175) @expansion{} //        block   2 : ordering C
normal_lib.tex(,176) endid;             // end/endid is isomorphic to End(r/id) as ring
normal_lib.tex(,177) @expansion{} endid[1]=0
normal_lib.tex(,178) map psi = r,endphi;// defines the canonical map r/id -> End(r/id)
normal_lib.tex(,179) psi;
normal_lib.tex(,180) @expansion{} psi[1]=T(1)^2
normal_lib.tex(,181) @expansion{} psi[2]=T(1)^3
normal_lib.tex(,182) @c end example HomJJ d2t_singular/normal_lib.doc:128
normal_lib.tex(,183) @end smallexample
normal_lib.tex(,184) @c ---end content HomJJ---
normal_lib.tex(,185) 
normal_lib.tex(,186) @c ------------------- genus -------------
normal_lib.tex(,187) @node genus, deltaLoc, HomJJ, normal_lib
normal_lib.tex(,188) @subsubsection genus
normal_lib.tex(,189) @cindex genus
normal_lib.tex(,190) @c ---content genus---
normal_lib.tex(,191) Procedure from library @code{normal.lib} (@pxref{normal_lib}).
normal_lib.tex(,192) 
normal_lib.tex(,193) @table @asis
normal_lib.tex(,194) @item @strong{Usage:}
normal_lib.tex(,195) genus(I) or genus(i,1); I a 1-dimensional ideal
normal_lib.tex(,196) 
normal_lib.tex(,197) @item @strong{Return:}
normal_lib.tex(,198) an integer, the geometric genus p_g = p_a - delta of the projective
normal_lib.tex(,199) curve defined by I, where p_a is the arithmetic genus.
normal_lib.tex(,200) 
normal_lib.tex(,201) @item @strong{Note:}
normal_lib.tex(,202) delta is the sum of all local delta-invariants of the singularities,
normal_lib.tex(,203) i.e. dim(R'/R), R' the normalization of the local ring R of the
normal_lib.tex(,204) singularity.
normal_lib.tex(,205) @*genus(i,1) uses the normalization to compute delta. Usually this
normal_lib.tex(,206) is slow but sometimes not.
normal_lib.tex(,207) 
normal_lib.tex(,208) @end table
normal_lib.tex(,209) @strong{Example:}
normal_lib.tex(,210) @smallexample
normal_lib.tex(,211) @c computed example genus d2t_singular/normal_lib.doc:171 
normal_lib.tex(,212) LIB "normal.lib";
normal_lib.tex(,213) ring r=0,(x,y),dp;
normal_lib.tex(,214) ideal i=y^9 - x^2*(x - 1)^9;
normal_lib.tex(,215) genus(i);
normal_lib.tex(,216) @expansion{} 0
normal_lib.tex(,217) @c end example genus d2t_singular/normal_lib.doc:171
normal_lib.tex(,218) @end smallexample
normal_lib.tex(,219) @c ---end content genus---
normal_lib.tex(,220) 
normal_lib.tex(,221) @c ------------------- deltaLoc -------------
normal_lib.tex(,222) @node deltaLoc,, genus, normal_lib
normal_lib.tex(,223) @subsubsection deltaLoc
normal_lib.tex(,224) @cindex deltaLoc
normal_lib.tex(,225) @c ---content deltaLoc---
normal_lib.tex(,226) Procedure from library @code{normal.lib} (@pxref{normal_lib}).
normal_lib.tex(,227) 
normal_lib.tex(,228) @table @asis
normal_lib.tex(,229) @item @strong{Usage:}
normal_lib.tex(,230) deltaLoc(f,J); f poly, J ideal
normal_lib.tex(,231) 
normal_lib.tex(,232) @item @strong{Assume:}
normal_lib.tex(,233) f is reduced bivariate polynomial; basering has exactly two variables;
normal_lib.tex(,234) J is irreducible prime component of the singular locus of f (e.g., one
normal_lib.tex(,235) entry of the output of @code{minAssGTZ(I);}, I = <f,jacob(f)>).
normal_lib.tex(,236) 
normal_lib.tex(,237) @item @strong{Return:}
normal_lib.tex(,238) list L:
normal_lib.tex(,239) 
normal_lib.tex(,240) @table @asis
normal_lib.tex(,241) @item @code{L[1]}; int:
normal_lib.tex(,242)          the sum of (local) delta invariants of f at the (conjugated) singular
normal_lib.tex(,243)          points given by J.
normal_lib.tex(,244) @item @code{L[2]}; int:
normal_lib.tex(,245)          the sum of (local) Tjurina numbers of f at the (conjugated) singular
normal_lib.tex(,246)          points given by J.
normal_lib.tex(,247) @item @code{L[3]}; int:
normal_lib.tex(,248)          the sum of (local) number of branches of f at the (conjugated) 
normal_lib.tex(,249)          singular points given by J.
normal_lib.tex(,250) @end table
normal_lib.tex(,251) 
normal_lib.tex(,252) @item @strong{Note:}
normal_lib.tex(,253) procedure makes use of @code{execute}; increasing printlevel displays
normal_lib.tex(,254) more comments (default: printlevel=0).
normal_lib.tex(,255) 
normal_lib.tex(,256) @cindex delta invariant
normal_lib.tex(,257) @cindex Tjurina number
normal_lib.tex(,258) @end table
normal_lib.tex(,259) @strong{Example:}
normal_lib.tex(,260) @smallexample
normal_lib.tex(,261) @c computed example deltaLoc d2t_singular/normal_lib.doc:220 
normal_lib.tex(,262) LIB "normal.lib";
normal_lib.tex(,263) ring r=0,(x,y),dp;
normal_lib.tex(,264) poly f=(x2+y^2-1)^3 +27x2y2;
normal_lib.tex(,265) ideal I=f,jacob(f);
normal_lib.tex(,266) I=std(I);
normal_lib.tex(,267) list qr=minAssGTZ(I);
normal_lib.tex(,268) size(qr);
normal_lib.tex(,269) @expansion{} 6
normal_lib.tex(,270) // each component of the singular locus either describes a cusp or a pair
normal_lib.tex(,271) // of conjugated nodes:
normal_lib.tex(,272) deltaLoc(f,qr[1]); 
normal_lib.tex(,273) @expansion{} [1]:
normal_lib.tex(,274) @expansion{}    1
normal_lib.tex(,275) @expansion{} [2]:
normal_lib.tex(,276) @expansion{}    2
normal_lib.tex(,277) @expansion{} [3]:
normal_lib.tex(,278) @expansion{}    1
normal_lib.tex(,279) deltaLoc(f,qr[2]); 
normal_lib.tex(,280) @expansion{} [1]:
normal_lib.tex(,281) @expansion{}    1
normal_lib.tex(,282) @expansion{} [2]:
normal_lib.tex(,283) @expansion{}    2
normal_lib.tex(,284) @expansion{} [3]:
normal_lib.tex(,285) @expansion{}    1
normal_lib.tex(,286) deltaLoc(f,qr[3]); 
normal_lib.tex(,287) @expansion{} [1]:
normal_lib.tex(,288) @expansion{}    1
normal_lib.tex(,289) @expansion{} [2]:
normal_lib.tex(,290) @expansion{}    2
normal_lib.tex(,291) @expansion{} [3]:
normal_lib.tex(,292) @expansion{}    1
normal_lib.tex(,293) deltaLoc(f,qr[4]); 
normal_lib.tex(,294) @expansion{} [1]:
normal_lib.tex(,295) @expansion{}    1
normal_lib.tex(,296) @expansion{} [2]:
normal_lib.tex(,297) @expansion{}    2
normal_lib.tex(,298) @expansion{} [3]:
normal_lib.tex(,299) @expansion{}    1
normal_lib.tex(,300) deltaLoc(f,qr[5]); 
normal_lib.tex(,301) @expansion{} [1]:
normal_lib.tex(,302) @expansion{}    2
normal_lib.tex(,303) @expansion{} [2]:
normal_lib.tex(,304) @expansion{}    2
normal_lib.tex(,305) @expansion{} [3]:
normal_lib.tex(,306) @expansion{}    4
normal_lib.tex(,307) deltaLoc(f,qr[6]);
normal_lib.tex(,308) @expansion{} [1]:
normal_lib.tex(,309) @expansion{}    2
normal_lib.tex(,310) @expansion{} [2]:
normal_lib.tex(,311) @expansion{}    2
normal_lib.tex(,312) @expansion{} [3]:
normal_lib.tex(,313) @expansion{}    4
normal_lib.tex(,314) @c end example deltaLoc d2t_singular/normal_lib.doc:220
normal_lib.tex(,315) @end smallexample
normal_lib.tex(,316) @c inserted refs from d2t_singular/normal_lib.doc:238
normal_lib.tex(,329) @c end inserted refs from d2t_singular/normal_lib.doc:238
normal_lib.tex(,330) 
normal_lib.tex(,331) @c ---end content deltaLoc---
singular.texi(,401) @c ----------------------------------------------------------
singular.texi(,402) @node primdec_lib, primitiv_lib, normal_lib, Commutative algebra
singular.texi(,403) @subsection primdec_lib
singular.texi(,404) @c include of docu for primdec.lib
primdec_lib.tex(,1) @c ---content LibInfo---
primdec_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/primdec_lib.doc
primdec_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/primdec_lib.doc INSTEAD
primdec_lib.tex(,4) @c library version: (1.98.2.16,2003/06/23)
primdec_lib.tex(,5) @c library file: ../Singular/LIB/primdec.lib
primdec_lib.tex(,6) @cindex primdec.lib
primdec_lib.tex(,7) @cindex primdec_lib
primdec_lib.tex(,8) @table @asis
primdec_lib.tex(,9) @item @strong{Library:}
primdec_lib.tex(,10) primdec.lib
primdec_lib.tex(,11) @item @strong{Purpose:}
primdec_lib.tex(,12)    Primary Decomposition and Radical of Ideals
primdec_lib.tex(,13) @item @strong{Authors:}
primdec_lib.tex(,14) Gerhard Pfister, pfister@@mathematik.uni-kl.de (GTZ)
primdec_lib.tex(,15) @* Wolfram Decker, decker@@math.uni-sb.de (SY)
primdec_lib.tex(,16) @* Hans Schoenemann, hannes@@mathematik.uni-kl.de (SY)
primdec_lib.tex(,17) 
primdec_lib.tex(,18) @item @strong{Overview:}
primdec_lib.tex(,19) Algorithms for primary decomposition based on the ideas of
primdec_lib.tex(,20) Gianni, Trager and Zacharias (implementation by Gerhard Pfister),
primdec_lib.tex(,21) respectively based on the ideas of Shimoyama and Yokoyama (implementation
primdec_lib.tex(,22) by Wolfram Decker and Hans Schoenemann).
primdec_lib.tex(,23) @* The procedures are implemented to be used in characteristic 0.
primdec_lib.tex(,24) @* They also work in positive characteristic >> 0.
primdec_lib.tex(,25) @* In small characteristic and for algebraic extensions, primdecGTZ
primdec_lib.tex(,26) may not terminate.
primdec_lib.tex(,27) @*Algorithms for the computation of the radical based on the ideas of
primdec_lib.tex(,28) Krick, Logar and Kemper (implementation by Gerhard Pfister).
primdec_lib.tex(,29) 
primdec_lib.tex(,30) @end table
primdec_lib.tex(,31) 
primdec_lib.tex(,32) @strong{Procedures:}
primdec_lib.tex(,33) @menu
primdec_lib.tex(,34) * Ann:: annihilator of R^n/M, R=basering, M in R^n
primdec_lib.tex(,35) * primdecGTZ:: complete primary decomposition via Gianni,Trager,Zacharias
primdec_lib.tex(,36) * primdecSY:: complete primary decomposition via Shimoyama-Yokoyama
primdec_lib.tex(,37) * minAssGTZ:: the minimal associated primes via Gianni,Trager,Zacharias
primdec_lib.tex(,38) * minAssChar:: the minimal associated primes using characteristic sets
primdec_lib.tex(,39) * testPrimary:: tests the result of the primary decomposition
primdec_lib.tex(,40) * radical:: computes the radical of I via Krick/Logar and Kemper
primdec_lib.tex(,41) * radicalEHV:: computes the radical of I via Eisenbud,Huneke,Vasconcelos
primdec_lib.tex(,42) * equiRadical:: the radical of the equidimensional part of the ideal I
primdec_lib.tex(,43) * prepareAss:: list of radicals of the equidimensional components of I
primdec_lib.tex(,44) * equidim:: weak equidimensional decomposition of I
primdec_lib.tex(,45) * equidimMax:: equidimensional locus of I
primdec_lib.tex(,46) * equidimMaxEHV:: equidimensional locus of I via Eisenbud,Huneke,Vasconcelos
primdec_lib.tex(,47) * zerodec:: zerodimensional decomposition via Monico
primdec_lib.tex(,48) @end menu
primdec_lib.tex(,49) @c ---end content LibInfo---
primdec_lib.tex(,50) 
primdec_lib.tex(,51) @c ------------------- Ann -------------
primdec_lib.tex(,52) @node Ann, primdecGTZ,, primdec_lib
primdec_lib.tex(,53) @subsubsection Ann
primdec_lib.tex(,54) @cindex Ann
primdec_lib.tex(,55) @c ---content Ann---
primdec_lib.tex(,56) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,57) 
primdec_lib.tex(,58) @table @asis
primdec_lib.tex(,59) @end table
primdec_lib.tex(,60) @c ---end content Ann---
primdec_lib.tex(,61) 
primdec_lib.tex(,62) @c ------------------- primdecGTZ -------------
primdec_lib.tex(,63) @node primdecGTZ, primdecSY, Ann, primdec_lib
primdec_lib.tex(,64) @subsubsection primdecGTZ
primdec_lib.tex(,65) @cindex primdecGTZ
primdec_lib.tex(,66) @c ---content primdecGTZ---
primdec_lib.tex(,67) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,68) 
primdec_lib.tex(,69) @table @asis
primdec_lib.tex(,70) @item @strong{Usage:}
primdec_lib.tex(,71) primdecGTZ(i); i ideal
primdec_lib.tex(,72) 
primdec_lib.tex(,73) @item @strong{Return:}
primdec_lib.tex(,74) a list pr of primary ideals and their associated primes:
primdec_lib.tex(,75) @format
primdec_lib.tex(,76)    pr[i][1]   the i-th primary component,
primdec_lib.tex(,77)    pr[i][2]   the i-th prime component.
primdec_lib.tex(,78) @end format
primdec_lib.tex(,79) 
primdec_lib.tex(,80) @item @strong{Note:}
primdec_lib.tex(,81) Algorithm of Gianni/Trager/Zacharias.
primdec_lib.tex(,82) @*Designed for characteristic 0, works also in char k > 0, if it
primdec_lib.tex(,83) terminates (may result in an infinite loop in small characteristic!)
primdec_lib.tex(,84) 
primdec_lib.tex(,85) @end table
primdec_lib.tex(,86) @strong{Example:}
primdec_lib.tex(,87) @smallexample
primdec_lib.tex(,88) @c reused example primdecGTZ d2t_singular/primdec_lib.doc:86 
primdec_lib.tex(,89) LIB "primdec.lib";
primdec_lib.tex(,90) ring  r = 0,(x,y,z),lp;
primdec_lib.tex(,91) poly  p = z2+1;
primdec_lib.tex(,92) poly  q = z3+2;
primdec_lib.tex(,93) ideal i = p*q^2,y-z2;
primdec_lib.tex(,94) list pr = primdecGTZ(i);
primdec_lib.tex(,95) pr;
primdec_lib.tex(,96) @expansion{} [1]:
primdec_lib.tex(,97) @expansion{}    [1]:
primdec_lib.tex(,98) @expansion{}       _[1]=z6+4z3+4
primdec_lib.tex(,99) @expansion{}       _[2]=y-z2
primdec_lib.tex(,100) @expansion{}    [2]:
primdec_lib.tex(,101) @expansion{}       _[1]=z3+2
primdec_lib.tex(,102) @expansion{}       _[2]=y-z2
primdec_lib.tex(,103) @expansion{} [2]:
primdec_lib.tex(,104) @expansion{}    [1]:
primdec_lib.tex(,105) @expansion{}       _[1]=z2+1
primdec_lib.tex(,106) @expansion{}       _[2]=y-z2
primdec_lib.tex(,107) @expansion{}    [2]:
primdec_lib.tex(,108) @expansion{}       _[1]=z2+1
primdec_lib.tex(,109) @expansion{}       _[2]=y-z2
primdec_lib.tex(,110) @c end example primdecGTZ d2t_singular/primdec_lib.doc:86
primdec_lib.tex(,111) @end smallexample
primdec_lib.tex(,112) @c ---end content primdecGTZ---
primdec_lib.tex(,113) 
primdec_lib.tex(,114) @c ------------------- primdecSY -------------
primdec_lib.tex(,115) @node primdecSY, minAssGTZ, primdecGTZ, primdec_lib
primdec_lib.tex(,116) @subsubsection primdecSY
primdec_lib.tex(,117) @cindex primdecSY
primdec_lib.tex(,118) @c ---content primdecSY---
primdec_lib.tex(,119) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,120) 
primdec_lib.tex(,121) @table @asis
primdec_lib.tex(,122) @item @strong{Usage:}
primdec_lib.tex(,123) primdecSY(i); i ideal, c int
primdec_lib.tex(,124) 
primdec_lib.tex(,125) @item @strong{Return:}
primdec_lib.tex(,126) a list pr of primary ideals and their associated primes:
primdec_lib.tex(,127) @format
primdec_lib.tex(,128)    pr[i][1]   the i-th primary component,
primdec_lib.tex(,129)    pr[i][2]   the i-th prime component.
primdec_lib.tex(,130) @end format
primdec_lib.tex(,131) 
primdec_lib.tex(,132) @item @strong{Note:}
primdec_lib.tex(,133) Algorithm of Shimoyama/Yokoyama.
primdec_lib.tex(,134) @format
primdec_lib.tex(,135)    if c=0,  the given ordering of the variables is used,
primdec_lib.tex(,136)    if c=1,  minAssChar tries to use an optimal ordering,
primdec_lib.tex(,137)    if c=2,  minAssGTZ is used,
primdec_lib.tex(,138)    if c=3,  minAssGTZ and facstd are used.
primdec_lib.tex(,139) @end format
primdec_lib.tex(,140) 
primdec_lib.tex(,141) @end table
primdec_lib.tex(,142) @strong{Example:}
primdec_lib.tex(,143) @smallexample
primdec_lib.tex(,144) @c reused example primdecSY d2t_singular/primdec_lib.doc:128 
primdec_lib.tex(,145) LIB "primdec.lib";
primdec_lib.tex(,146) ring  r = 0,(x,y,z),lp;
primdec_lib.tex(,147) poly  p = z2+1;
primdec_lib.tex(,148) poly  q = z3+2;
primdec_lib.tex(,149) ideal i = p*q^2,y-z2;
primdec_lib.tex(,150) list pr = primdecSY(i);
primdec_lib.tex(,151) pr;
primdec_lib.tex(,152) @expansion{} [1]:
primdec_lib.tex(,153) @expansion{}    [1]:
primdec_lib.tex(,154) @expansion{}       _[1]=z6+4z3+4
primdec_lib.tex(,155) @expansion{}       _[2]=y-z2
primdec_lib.tex(,156) @expansion{}    [2]:
primdec_lib.tex(,157) @expansion{}       _[1]=z3+2
primdec_lib.tex(,158) @expansion{}       _[2]=y-z2
primdec_lib.tex(,159) @expansion{} [2]:
primdec_lib.tex(,160) @expansion{}    [1]:
primdec_lib.tex(,161) @expansion{}       _[1]=z2+1
primdec_lib.tex(,162) @expansion{}       _[2]=y+1
primdec_lib.tex(,163) @expansion{}    [2]:
primdec_lib.tex(,164) @expansion{}       _[1]=z2+1
primdec_lib.tex(,165) @expansion{}       _[2]=y+1
primdec_lib.tex(,166) @c end example primdecSY d2t_singular/primdec_lib.doc:128
primdec_lib.tex(,167) @end smallexample
primdec_lib.tex(,168) @c ---end content primdecSY---
primdec_lib.tex(,169) 
primdec_lib.tex(,170) @c ------------------- minAssGTZ -------------
primdec_lib.tex(,171) @node minAssGTZ, minAssChar, primdecSY, primdec_lib
primdec_lib.tex(,172) @subsubsection minAssGTZ
primdec_lib.tex(,173) @cindex minAssGTZ
primdec_lib.tex(,174) @c ---content minAssGTZ---
primdec_lib.tex(,175) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,176) 
primdec_lib.tex(,177) @table @asis
primdec_lib.tex(,178) @item @strong{Usage:}
primdec_lib.tex(,179) minAssGTZ(i); i ideal
primdec_lib.tex(,180) @*minAssGTZ(i,1); i ideal does not use the factorizing Groebner
primdec_lib.tex(,181) 
primdec_lib.tex(,182) @item @strong{Return:}
primdec_lib.tex(,183) a list, the minimal associated prime ideals of i.
primdec_lib.tex(,184) 
primdec_lib.tex(,185) @item @strong{Note:}
primdec_lib.tex(,186) Designed for characteristic 0, works also in char k > 0 based
primdec_lib.tex(,187) on an algorithm of Yokoyama
primdec_lib.tex(,188) 
primdec_lib.tex(,189) @end table
primdec_lib.tex(,190) @strong{Example:}
primdec_lib.tex(,191) @smallexample
primdec_lib.tex(,192) @c reused example minAssGTZ d2t_singular/primdec_lib.doc:162 
primdec_lib.tex(,193) LIB "primdec.lib";
primdec_lib.tex(,194) ring  r = 0,(x,y,z),dp;
primdec_lib.tex(,195) poly  p = z2+1;
primdec_lib.tex(,196) poly  q = z3+2;
primdec_lib.tex(,197) ideal i = p*q^2,y-z2;
primdec_lib.tex(,198) list pr = minAssGTZ(i);
primdec_lib.tex(,199) pr;
primdec_lib.tex(,200) @expansion{} [1]:
primdec_lib.tex(,201) @expansion{}    _[1]=z2+1
primdec_lib.tex(,202) @expansion{}    _[2]=-z2+y
primdec_lib.tex(,203) @expansion{} [2]:
primdec_lib.tex(,204) @expansion{}    _[1]=z3+2
primdec_lib.tex(,205) @expansion{}    _[2]=-z2+y
primdec_lib.tex(,206) @c end example minAssGTZ d2t_singular/primdec_lib.doc:162
primdec_lib.tex(,207) @end smallexample
primdec_lib.tex(,208) @c ---end content minAssGTZ---
primdec_lib.tex(,209) 
primdec_lib.tex(,210) @c ------------------- minAssChar -------------
primdec_lib.tex(,211) @node minAssChar, testPrimary, minAssGTZ, primdec_lib
primdec_lib.tex(,212) @subsubsection minAssChar
primdec_lib.tex(,213) @cindex minAssChar
primdec_lib.tex(,214) @c ---content minAssChar---
primdec_lib.tex(,215) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,216) 
primdec_lib.tex(,217) @table @asis
primdec_lib.tex(,218) @item @strong{Usage:}
primdec_lib.tex(,219) minAssChar(i[,c]); i ideal, c int.
primdec_lib.tex(,220) 
primdec_lib.tex(,221) @item @strong{Return:}
primdec_lib.tex(,222) list, the minimal associated prime ideals of i.
primdec_lib.tex(,223) 
primdec_lib.tex(,224) @item @strong{Note:}
primdec_lib.tex(,225) If c=0, the given ordering of the variables is used. @*
primdec_lib.tex(,226) Otherwise, the system tries to find an optimal ordering,
primdec_lib.tex(,227) which in some cases may considerably speed up the algorithm. @*
primdec_lib.tex(,228) Due to a bug in the factorization, the result may be not completely
primdec_lib.tex(,229) decomposed in small characteristic.
primdec_lib.tex(,230) 
primdec_lib.tex(,231) @end table
primdec_lib.tex(,232) @strong{Example:}
primdec_lib.tex(,233) @smallexample
primdec_lib.tex(,234) @c reused example minAssChar d2t_singular/primdec_lib.doc:198 
primdec_lib.tex(,235) LIB "primdec.lib";
primdec_lib.tex(,236) ring  r = 0,(x,y,z),dp;
primdec_lib.tex(,237) poly  p = z2+1;
primdec_lib.tex(,238) poly  q = z3+2;
primdec_lib.tex(,239) ideal i = p*q^2,y-z2;
primdec_lib.tex(,240) list pr = minAssChar(i);
primdec_lib.tex(,241) pr;
primdec_lib.tex(,242) @expansion{} [1]:
primdec_lib.tex(,243) @expansion{}    _[1]=y+1
primdec_lib.tex(,244) @expansion{}    _[2]=z2+1
primdec_lib.tex(,245) @expansion{} [2]:
primdec_lib.tex(,246) @expansion{}    _[1]=z2-y
primdec_lib.tex(,247) @expansion{}    _[2]=yz+2
primdec_lib.tex(,248) @expansion{}    _[3]=y2+2z
primdec_lib.tex(,249) @c end example minAssChar d2t_singular/primdec_lib.doc:198
primdec_lib.tex(,250) @end smallexample
primdec_lib.tex(,251) @c ---end content minAssChar---
primdec_lib.tex(,252) 
primdec_lib.tex(,253) @c ------------------- testPrimary -------------
primdec_lib.tex(,254) @node testPrimary, radical, minAssChar, primdec_lib
primdec_lib.tex(,255) @subsubsection testPrimary
primdec_lib.tex(,256) @cindex testPrimary
primdec_lib.tex(,257) @c ---content testPrimary---
primdec_lib.tex(,258) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,259) 
primdec_lib.tex(,260) @table @asis
primdec_lib.tex(,261) @item @strong{Usage:}
primdec_lib.tex(,262) testPrimary(pr,k); pr a list, k an ideal.
primdec_lib.tex(,263) 
primdec_lib.tex(,264) @item @strong{Assume:}
primdec_lib.tex(,265) pr is the result of primdecGTZ(k) or primdecSY(k).
primdec_lib.tex(,266) 
primdec_lib.tex(,267) @item @strong{Return:}
primdec_lib.tex(,268) int, 1 if the intersection of the ideals in pr is k, 0 if not
primdec_lib.tex(,269) 
primdec_lib.tex(,270) @end table
primdec_lib.tex(,271) @strong{Example:}
primdec_lib.tex(,272) @smallexample
primdec_lib.tex(,273) @c reused example testPrimary d2t_singular/primdec_lib.doc:230 
primdec_lib.tex(,274) LIB "primdec.lib";
primdec_lib.tex(,275) ring  r = 32003,(x,y,z),dp;
primdec_lib.tex(,276) poly  p = z2+1;
primdec_lib.tex(,277) poly  q = z4+2;
primdec_lib.tex(,278) ideal i = p^2*q^3,(y-z3)^3,(x-yz+z4)^4;
primdec_lib.tex(,279) list pr = primdecGTZ(i);
primdec_lib.tex(,280) testPrimary(pr,i);
primdec_lib.tex(,281) @expansion{} 1
primdec_lib.tex(,282) @c end example testPrimary d2t_singular/primdec_lib.doc:230
primdec_lib.tex(,283) @end smallexample
primdec_lib.tex(,284) @c ---end content testPrimary---
primdec_lib.tex(,285) 
primdec_lib.tex(,286) @c ------------------- radical -------------
primdec_lib.tex(,287) @node radical, radicalEHV, testPrimary, primdec_lib
primdec_lib.tex(,288) @subsubsection radical
primdec_lib.tex(,289) @cindex radical
primdec_lib.tex(,290) @c ---content radical---
primdec_lib.tex(,291) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,292) 
primdec_lib.tex(,293) @table @asis
primdec_lib.tex(,294) @item @strong{Usage:}
primdec_lib.tex(,295) radical(i); i ideal.
primdec_lib.tex(,296) 
primdec_lib.tex(,297) @item @strong{Return:}
primdec_lib.tex(,298) ideal, the radical of i.
primdec_lib.tex(,299) 
primdec_lib.tex(,300) @item @strong{Note:}
primdec_lib.tex(,301) A combination of the algorithms of Krick/Logar and Kemper is used.
primdec_lib.tex(,302) Works also in positive characteristic (Kempers algorithm).
primdec_lib.tex(,303) 
primdec_lib.tex(,304) @end table
primdec_lib.tex(,305) @strong{Example:}
primdec_lib.tex(,306) @smallexample
primdec_lib.tex(,307) @c reused example radical d2t_singular/primdec_lib.doc:263 
primdec_lib.tex(,308) LIB "primdec.lib";
primdec_lib.tex(,309) ring  r = 0,(x,y,z),dp;
primdec_lib.tex(,310) poly  p = z2+1;
primdec_lib.tex(,311) poly  q = z3+2;
primdec_lib.tex(,312) ideal i = p*q^2,y-z2;
primdec_lib.tex(,313) ideal pr= radical(i);
primdec_lib.tex(,314) pr;
primdec_lib.tex(,315) @expansion{} pr[1]=z2-y
primdec_lib.tex(,316) @expansion{} pr[2]=y2z+yz+2y+2
primdec_lib.tex(,317) @c end example radical d2t_singular/primdec_lib.doc:263
primdec_lib.tex(,318) @end smallexample
primdec_lib.tex(,319) @c ---end content radical---
primdec_lib.tex(,320) 
primdec_lib.tex(,321) @c ------------------- radicalEHV -------------
primdec_lib.tex(,322) @node radicalEHV, equiRadical, radical, primdec_lib
primdec_lib.tex(,323) @subsubsection radicalEHV
primdec_lib.tex(,324) @cindex radicalEHV
primdec_lib.tex(,325) @c ---content radicalEHV---
primdec_lib.tex(,326) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,327) 
primdec_lib.tex(,328) @table @asis
primdec_lib.tex(,329) @item @strong{Usage:}
primdec_lib.tex(,330) radicalEHV(i); i ideal.
primdec_lib.tex(,331) 
primdec_lib.tex(,332) @item @strong{Return:}
primdec_lib.tex(,333) ideal, the radical of i.
primdec_lib.tex(,334) 
primdec_lib.tex(,335) @item @strong{Note:}
primdec_lib.tex(,336) Uses the algorithm of Eisenbud/Huneke/Vasconcelos, which
primdec_lib.tex(,337) reduces the computation to the complete intersection case,
primdec_lib.tex(,338) by taking, in the general case, a generic linear combination
primdec_lib.tex(,339) of the input.
primdec_lib.tex(,340) @*Works only in characteristic 0 or p large.
primdec_lib.tex(,341) 
primdec_lib.tex(,342) @end table
primdec_lib.tex(,343) @strong{Example:}
primdec_lib.tex(,344) @smallexample
primdec_lib.tex(,345) @c reused example radicalEHV d2t_singular/primdec_lib.doc:299 
primdec_lib.tex(,346) LIB "primdec.lib";
primdec_lib.tex(,347) ring  r = 0,(x,y,z),dp;
primdec_lib.tex(,348) poly  p = z2+1;
primdec_lib.tex(,349) poly  q = z3+2;
primdec_lib.tex(,350) ideal i = p*q^2,y-z2;
primdec_lib.tex(,351) ideal pr= radicalEHV(i);
primdec_lib.tex(,352) pr;
primdec_lib.tex(,353) @expansion{} pr[1]=z2-y
primdec_lib.tex(,354) @expansion{} pr[2]=y2z+yz+2y+2
primdec_lib.tex(,355) @expansion{} pr[3]=y3+y2+2yz+2z
primdec_lib.tex(,356) @c end example radicalEHV d2t_singular/primdec_lib.doc:299
primdec_lib.tex(,357) @end smallexample
primdec_lib.tex(,358) @c ---end content radicalEHV---
primdec_lib.tex(,359) 
primdec_lib.tex(,360) @c ------------------- equiRadical -------------
primdec_lib.tex(,361) @node equiRadical, prepareAss, radicalEHV, primdec_lib
primdec_lib.tex(,362) @subsubsection equiRadical
primdec_lib.tex(,363) @cindex equiRadical
primdec_lib.tex(,364) @c ---content equiRadical---
primdec_lib.tex(,365) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,366) 
primdec_lib.tex(,367) @table @asis
primdec_lib.tex(,368) @item @strong{Usage:}
primdec_lib.tex(,369) equiRadical(i); i ideal
primdec_lib.tex(,370) 
primdec_lib.tex(,371) @item @strong{Return:}
primdec_lib.tex(,372) ideal, intersection of associated primes of i of maximal dimension.
primdec_lib.tex(,373) 
primdec_lib.tex(,374) @item @strong{Note:}
primdec_lib.tex(,375) A combination of the algorithms of Krick/Logar and Kemper is used.
primdec_lib.tex(,376) Works also in positive characteristic (Kempers algorithm).
primdec_lib.tex(,377) 
primdec_lib.tex(,378) @end table
primdec_lib.tex(,379) @strong{Example:}
primdec_lib.tex(,380) @smallexample
primdec_lib.tex(,381) @c reused example equiRadical d2t_singular/primdec_lib.doc:332 
primdec_lib.tex(,382) LIB "primdec.lib";
primdec_lib.tex(,383) ring  r = 0,(x,y,z),dp;
primdec_lib.tex(,384) poly  p = z2+1;
primdec_lib.tex(,385) poly  q = z3+2;
primdec_lib.tex(,386) ideal i = p*q^2,y-z2;
primdec_lib.tex(,387) ideal pr= equiRadical(i);
primdec_lib.tex(,388) pr;
primdec_lib.tex(,389) @expansion{} pr[1]=z2-y
primdec_lib.tex(,390) @expansion{} pr[2]=y2z+yz+2y+2
primdec_lib.tex(,391) @c end example equiRadical d2t_singular/primdec_lib.doc:332
primdec_lib.tex(,392) @end smallexample
primdec_lib.tex(,393) @c ---end content equiRadical---
primdec_lib.tex(,394) 
primdec_lib.tex(,395) @c ------------------- prepareAss -------------
primdec_lib.tex(,396) @node prepareAss, equidim, equiRadical, primdec_lib
primdec_lib.tex(,397) @subsubsection prepareAss
primdec_lib.tex(,398) @cindex prepareAss
primdec_lib.tex(,399) @c ---content prepareAss---
primdec_lib.tex(,400) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,401) 
primdec_lib.tex(,402) @table @asis
primdec_lib.tex(,403) @item @strong{Usage:}
primdec_lib.tex(,404) prepareAss(i); i ideal
primdec_lib.tex(,405) 
primdec_lib.tex(,406) @item @strong{Return:}
primdec_lib.tex(,407) list, the radicals of the maximal dimensional components of i.
primdec_lib.tex(,408) 
primdec_lib.tex(,409) @item @strong{Note:}
primdec_lib.tex(,410) Uses algorithm of Eisenbud/Huneke/Vasconcelos.
primdec_lib.tex(,411) 
primdec_lib.tex(,412) @end table
primdec_lib.tex(,413) @strong{Example:}
primdec_lib.tex(,414) @smallexample
primdec_lib.tex(,415) @c reused example prepareAss d2t_singular/primdec_lib.doc:364 
primdec_lib.tex(,416) LIB "primdec.lib";
primdec_lib.tex(,417) ring  r = 0,(x,y,z),dp;
primdec_lib.tex(,418) poly  p = z2+1;
primdec_lib.tex(,419) poly  q = z3+2;
primdec_lib.tex(,420) ideal i = p*q^2,y-z2;
primdec_lib.tex(,421) list pr = prepareAss(i);
primdec_lib.tex(,422) pr;
primdec_lib.tex(,423) @expansion{} [1]:
primdec_lib.tex(,424) @expansion{}    _[1]=z2-y
primdec_lib.tex(,425) @expansion{}    _[2]=y2z+yz+2y+2
primdec_lib.tex(,426) @c end example prepareAss d2t_singular/primdec_lib.doc:364
primdec_lib.tex(,427) @end smallexample
primdec_lib.tex(,428) @c ---end content prepareAss---
primdec_lib.tex(,429) 
primdec_lib.tex(,430) @c ------------------- equidim -------------
primdec_lib.tex(,431) @node equidim, equidimMax, prepareAss, primdec_lib
primdec_lib.tex(,432) @subsubsection equidim
primdec_lib.tex(,433) @cindex equidim
primdec_lib.tex(,434) @c ---content equidim---
primdec_lib.tex(,435) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,436) 
primdec_lib.tex(,437) @table @asis
primdec_lib.tex(,438) @item @strong{Usage:}
primdec_lib.tex(,439) equidim(i) or equidim(i,1) ; i ideal
primdec_lib.tex(,440) 
primdec_lib.tex(,441) @item @strong{Return:}
primdec_lib.tex(,442) list of equidimensional ideals a[1],...,a[s] with:
primdec_lib.tex(,443) @*- a[s] the equidimensional locus of i, i.e. the intersection
primdec_lib.tex(,444) of the primary ideals of dimension of i
primdec_lib.tex(,445) @*- a[1],...,a[s-1] the lower dimensional equidimensional loci.
primdec_lib.tex(,446) 
primdec_lib.tex(,447) @item @strong{Note:}
primdec_lib.tex(,448) An embedded component q (primary ideal) of i can be replaced in the
primdec_lib.tex(,449) decomposition by a primary ideal q1 with the same radical as q. @*
primdec_lib.tex(,450) @code{equidim(i,1)} uses the algorithm of Eisenbud/Huneke/Vasconcelos.
primdec_lib.tex(,451) 
primdec_lib.tex(,452) @end table
primdec_lib.tex(,453) @strong{Example:}
primdec_lib.tex(,454) @smallexample
primdec_lib.tex(,455) @c reused example equidim d2t_singular/primdec_lib.doc:401 
primdec_lib.tex(,456) LIB "primdec.lib";
primdec_lib.tex(,457) ring  r = 32003,(x,y,z),dp;
primdec_lib.tex(,458) ideal i = intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
primdec_lib.tex(,459) equidim(i);
primdec_lib.tex(,460) @expansion{} [1]:
primdec_lib.tex(,461) @expansion{}    _[1]=z4
primdec_lib.tex(,462) @expansion{}    _[2]=y5
primdec_lib.tex(,463) @expansion{}    _[3]=x5
primdec_lib.tex(,464) @expansion{}    _[4]=x3z3
primdec_lib.tex(,465) @expansion{}    _[5]=x4y4
primdec_lib.tex(,466) @expansion{} [2]:
primdec_lib.tex(,467) @expansion{}    _[1]=yz
primdec_lib.tex(,468) @expansion{}    _[2]=xz
primdec_lib.tex(,469) @expansion{}    _[3]=x2
primdec_lib.tex(,470) @expansion{} [3]:
primdec_lib.tex(,471) @expansion{}    _[1]=z
primdec_lib.tex(,472) @c end example equidim d2t_singular/primdec_lib.doc:401
primdec_lib.tex(,473) @end smallexample
primdec_lib.tex(,474) @c ---end content equidim---
primdec_lib.tex(,475) 
primdec_lib.tex(,476) @c ------------------- equidimMax -------------
primdec_lib.tex(,477) @node equidimMax, equidimMaxEHV, equidim, primdec_lib
primdec_lib.tex(,478) @subsubsection equidimMax
primdec_lib.tex(,479) @cindex equidimMax
primdec_lib.tex(,480) @c ---content equidimMax---
primdec_lib.tex(,481) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,482) 
primdec_lib.tex(,483) @table @asis
primdec_lib.tex(,484) @item @strong{Usage:}
primdec_lib.tex(,485) equidimMax(i); i ideal
primdec_lib.tex(,486) 
primdec_lib.tex(,487) @item @strong{Return:}
primdec_lib.tex(,488) ideal of equidimensional locus (of maximal dimension) of i.
primdec_lib.tex(,489) 
primdec_lib.tex(,490) @end table
primdec_lib.tex(,491) @strong{Example:}
primdec_lib.tex(,492) @smallexample
primdec_lib.tex(,493) @c reused example equidimMax d2t_singular/primdec_lib.doc:427 
primdec_lib.tex(,494) LIB "primdec.lib";
primdec_lib.tex(,495) ring  r = 32003,(x,y,z),dp;
primdec_lib.tex(,496) ideal i = intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
primdec_lib.tex(,497) equidimMax(i);
primdec_lib.tex(,498) @expansion{} _[1]=z
primdec_lib.tex(,499) @c end example equidimMax d2t_singular/primdec_lib.doc:427
primdec_lib.tex(,500) @end smallexample
primdec_lib.tex(,501) @c ---end content equidimMax---
primdec_lib.tex(,502) 
primdec_lib.tex(,503) @c ------------------- equidimMaxEHV -------------
primdec_lib.tex(,504) @node equidimMaxEHV, zerodec, equidimMax, primdec_lib
primdec_lib.tex(,505) @subsubsection equidimMaxEHV
primdec_lib.tex(,506) @cindex equidimMaxEHV
primdec_lib.tex(,507) @c ---content equidimMaxEHV---
primdec_lib.tex(,508) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,509) 
primdec_lib.tex(,510) @table @asis
primdec_lib.tex(,511) @item @strong{Usage:}
primdec_lib.tex(,512) equidimMaxEHV(i); i ideal
primdec_lib.tex(,513) 
primdec_lib.tex(,514) @item @strong{Return:}
primdec_lib.tex(,515) ideal, the equidimensional component (of maximal dimension) of i.
primdec_lib.tex(,516) 
primdec_lib.tex(,517) @item @strong{Note:}
primdec_lib.tex(,518) Uses algorithm of Eisenbud, Huneke and Vasconcelos.
primdec_lib.tex(,519) 
primdec_lib.tex(,520) @end table
primdec_lib.tex(,521) @strong{Example:}
primdec_lib.tex(,522) @smallexample
primdec_lib.tex(,523) @c reused example equidimMaxEHV d2t_singular/primdec_lib.doc:456 
primdec_lib.tex(,524) LIB "primdec.lib";
primdec_lib.tex(,525) ring  r = 0,(x,y,z),dp;
primdec_lib.tex(,526) ideal i=intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
primdec_lib.tex(,527) equidimMaxEHV(i);
primdec_lib.tex(,528) @expansion{} _[1]=z
primdec_lib.tex(,529) @c end example equidimMaxEHV d2t_singular/primdec_lib.doc:456
primdec_lib.tex(,530) @end smallexample
primdec_lib.tex(,531) @c ---end content equidimMaxEHV---
primdec_lib.tex(,532) 
primdec_lib.tex(,533) @c ------------------- zerodec -------------
primdec_lib.tex(,534) @node zerodec,, equidimMaxEHV, primdec_lib
primdec_lib.tex(,535) @subsubsection zerodec
primdec_lib.tex(,536) @cindex zerodec
primdec_lib.tex(,537) @c ---content zerodec---
primdec_lib.tex(,538) Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).
primdec_lib.tex(,539) 
primdec_lib.tex(,540) @table @asis
primdec_lib.tex(,541) @item @strong{Usage:}
primdec_lib.tex(,542) zerodec(I); I ideal
primdec_lib.tex(,543) 
primdec_lib.tex(,544) @item @strong{Assume:}
primdec_lib.tex(,545) I is zero-dimensional, the characteristic of the ground field is 0
primdec_lib.tex(,546) 
primdec_lib.tex(,547) @item @strong{Return:}
primdec_lib.tex(,548) list of primary ideals, the zero-dimensional decomposition of I
primdec_lib.tex(,549) 
primdec_lib.tex(,550) @item @strong{Note:}
primdec_lib.tex(,551) The algorithm (of Monico), works well only for a small total number
primdec_lib.tex(,552) of solutions (@code{vdim(std(I))} should be < 100) and without
primdec_lib.tex(,553) parameters. In practice, it works also in large characteristic p>0
primdec_lib.tex(,554) but may fail for small p.
primdec_lib.tex(,555) @* If printlevel > 0 (default = 0) additional information is displayed.
primdec_lib.tex(,556) 
primdec_lib.tex(,557) @end table
primdec_lib.tex(,558) @strong{Example:}
primdec_lib.tex(,559) @smallexample
primdec_lib.tex(,560) @c reused example zerodec d2t_singular/primdec_lib.doc:492 
primdec_lib.tex(,561) LIB "primdec.lib";
primdec_lib.tex(,562) ring r  = 0,(x,y),dp;
primdec_lib.tex(,563) ideal i = x2-2,y2-2;
primdec_lib.tex(,564) list pr = zerodec(i);
primdec_lib.tex(,565) pr;
primdec_lib.tex(,566) @expansion{} [1]:
primdec_lib.tex(,567) @expansion{}    _[1]=y2-2
primdec_lib.tex(,568) @expansion{}    _[2]=xy-2
primdec_lib.tex(,569) @expansion{}    _[3]=x2-2
primdec_lib.tex(,570) @expansion{} [2]:
primdec_lib.tex(,571) @expansion{}    _[1]=y2-2
primdec_lib.tex(,572) @expansion{}    _[2]=xy+2
primdec_lib.tex(,573) @expansion{}    _[3]=x2-2
primdec_lib.tex(,574) @c end example zerodec d2t_singular/primdec_lib.doc:492
primdec_lib.tex(,575) @end smallexample
primdec_lib.tex(,576) @c ---end content zerodec---
singular.texi(,406) @c ---------------------------------------------------------
singular.texi(,407) @node primitiv_lib, reesclos_lib, primdec_lib, Commutative algebra
singular.texi(,408) @subsection primitiv_lib
singular.texi(,409) @c include of docu for primitiv.lib
primitiv_lib.tex(,1) @c ---content LibInfo---
primitiv_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/primitiv_lib.doc
primitiv_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/primitiv_lib.doc INSTEAD
primitiv_lib.tex(,4) @c library version: (1.15,2001/02/05)
primitiv_lib.tex(,5) @c library file: ../Singular/LIB/primitiv.lib
primitiv_lib.tex(,6) @cindex primitiv.lib
primitiv_lib.tex(,7) @cindex primitiv_lib
primitiv_lib.tex(,8) @table @asis
primitiv_lib.tex(,9) @item @strong{Library:}
primitiv_lib.tex(,10) primitiv.lib
primitiv_lib.tex(,11) @item @strong{Purpose:}
primitiv_lib.tex(,12)     Computing a Primitive Element
primitiv_lib.tex(,13) @item @strong{Author:}
primitiv_lib.tex(,14) Martin Lamm, email: lamm@@mathematik.uni-kl.de
primitiv_lib.tex(,15) 
primitiv_lib.tex(,16) @end table
primitiv_lib.tex(,17) 
primitiv_lib.tex(,18) @strong{Procedures:}
primitiv_lib.tex(,19) @menu
primitiv_lib.tex(,20) * primitive:: find minimal polynomial for a primitive element
primitiv_lib.tex(,21) * primitive_extra:: find primitive element for two generators
primitiv_lib.tex(,22) * splitring:: define ring extension with name R and switch to it
primitiv_lib.tex(,23) @end menu
primitiv_lib.tex(,24) @c ---end content LibInfo---
primitiv_lib.tex(,25) 
primitiv_lib.tex(,26) @c ------------------- primitive -------------
primitiv_lib.tex(,27) @node primitive, primitive_extra,, primitiv_lib
primitiv_lib.tex(,28) @subsubsection primitive
primitiv_lib.tex(,29) @cindex primitive
primitiv_lib.tex(,30) @c ---content primitive---
primitiv_lib.tex(,31) Procedure from library @code{primitiv.lib} (@pxref{primitiv_lib}).
primitiv_lib.tex(,32) 
primitiv_lib.tex(,33) @table @asis
primitiv_lib.tex(,34) @item @strong{Usage:}
primitiv_lib.tex(,35) primitive(i); i ideal
primitiv_lib.tex(,36) 
primitiv_lib.tex(,37) @item @strong{Assume:}
primitiv_lib.tex(,38) i is given by generators m[1],...,m[n] such that for j=1,...,n @*
primitiv_lib.tex(,39) - m[j] is a polynomial in k[x(1),...,x(j)] @*
primitiv_lib.tex(,40) - m[j](a[1],...,a[j-1],x(j)) is the minimal polynomial for a[j] over
primitiv_lib.tex(,41) k(a[1],...,a[j-1]) @*
primitiv_lib.tex(,42) (k the ground field of the current basering and x(1),...,x(n)
primitiv_lib.tex(,43) the ring variables).
primitiv_lib.tex(,44) 
primitiv_lib.tex(,45) @item @strong{Return:}
primitiv_lib.tex(,46) ideal j in k[x(n)] with
primitiv_lib.tex(,47) @*- j[1] a minimal polynomial for a primitive element b of 
primitiv_lib.tex(,48) k(a[1],...,a[n]) over k,
primitiv_lib.tex(,49) @*- j[2],...,j[n+1] polynomials in k[x(n)] such that j[i+1](b)=a[i]
primitiv_lib.tex(,50) for i=1,...,n.
primitiv_lib.tex(,51) 
primitiv_lib.tex(,52) @item @strong{Note:}
primitiv_lib.tex(,53) the number of variables in the basering has to be exactly n,
primitiv_lib.tex(,54) the number of given generators (i.e., minimal polynomials).@*
primitiv_lib.tex(,55) If the ground field k has only a few elements it may happen that no
primitiv_lib.tex(,56) linear combination of a[1],...,a[n] is a primitive element. In this
primitiv_lib.tex(,57) case @code{primitive(i)} returns the zero ideal, and one should use
primitiv_lib.tex(,58) @code{primitive_extra(i)} instead.
primitiv_lib.tex(,59) 
primitiv_lib.tex(,60) @cindex primitive element
primitiv_lib.tex(,61) @end table
primitiv_lib.tex(,62) @strong{Example:}
primitiv_lib.tex(,63) @smallexample
primitiv_lib.tex(,64) @c computed example primitive d2t_singular/primitiv_lib.doc:62 
primitiv_lib.tex(,65) LIB "primitiv.lib";
primitiv_lib.tex(,66) ring exring=0,(x,y),dp;
primitiv_lib.tex(,67) ideal i=x2+1,y2-x;                  // compute Q(i,i^(1/2))=:L
primitiv_lib.tex(,68) ideal j=primitive(i);
primitiv_lib.tex(,69) j[1];                               // L=Q(a) with a=(-1)^(1/4)
primitiv_lib.tex(,70) @expansion{} y4+1
primitiv_lib.tex(,71) j[2];                               // i=a^2
primitiv_lib.tex(,72) @expansion{} y2
primitiv_lib.tex(,73) j[3];                               // i^(1/2)=a
primitiv_lib.tex(,74) @expansion{} y
primitiv_lib.tex(,75) // the 2nd element was already primitive!
primitiv_lib.tex(,76) j=primitive(ideal(x2-2,y2-3));      // compute Q(sqrt(2),sqrt(3))
primitiv_lib.tex(,77) j[1];
primitiv_lib.tex(,78) @expansion{} y4-10y2+1
primitiv_lib.tex(,79) j[2];
primitiv_lib.tex(,80) @expansion{} 1/2y3-9/2y
primitiv_lib.tex(,81) j[3];
primitiv_lib.tex(,82) @expansion{} -1/2y3+11/2y
primitiv_lib.tex(,83) // no element was primitive -- the calculation of primitive elements 
primitiv_lib.tex(,84) // is based on a random choice.
primitiv_lib.tex(,85) @c end example primitive d2t_singular/primitiv_lib.doc:62
primitiv_lib.tex(,86) @end smallexample
primitiv_lib.tex(,87) @c inserted refs from d2t_singular/primitiv_lib.doc:79
primitiv_lib.tex(,98) @c end inserted refs from d2t_singular/primitiv_lib.doc:79
primitiv_lib.tex(,99) 
primitiv_lib.tex(,100) @c ---end content primitive---
primitiv_lib.tex(,101) 
primitiv_lib.tex(,102) @c ------------------- primitive_extra -------------
primitiv_lib.tex(,103) @node primitive_extra, splitring, primitive, primitiv_lib
primitiv_lib.tex(,104) @subsubsection primitive_extra
primitiv_lib.tex(,105) @cindex primitive_extra
primitiv_lib.tex(,106) @c ---content primitive_extra---
primitiv_lib.tex(,107) Procedure from library @code{primitiv.lib} (@pxref{primitiv_lib}).
primitiv_lib.tex(,108) 
primitiv_lib.tex(,109) @table @asis
primitiv_lib.tex(,110) @item @strong{Usage:}
primitiv_lib.tex(,111) primitive_extra(i); i ideal
primitiv_lib.tex(,112) 
primitiv_lib.tex(,113) @item @strong{Assume:}
primitiv_lib.tex(,114) The ground field of the basering is k=Q or k=Z/pZ and the ideal
primitiv_lib.tex(,115) i is given by 2 generators f,g with the following properties:
primitiv_lib.tex(,116) @format
primitiv_lib.tex(,117)    f is the minimal polynomial of a in k[x], 
primitiv_lib.tex(,118)    g is a polynomial in k[x,y] s.th. g(a,y) is the minpoly of b in k(a)[y].
primitiv_lib.tex(,119) @end format
primitiv_lib.tex(,120) Here, x is the name of the first ring variable, y the name of the
primitiv_lib.tex(,121) second.
primitiv_lib.tex(,122) 
primitiv_lib.tex(,123) @item @strong{Return:}
primitiv_lib.tex(,124) ideal j in k[y] such that
primitiv_lib.tex(,125) @format
primitiv_lib.tex(,126)    j[1] is the minimal polynomial for a primitive element c of k(a,b) over k,
primitiv_lib.tex(,127)    j[2] is a polynomial s.th. j[2](c)=a.
primitiv_lib.tex(,128) @end format
primitiv_lib.tex(,129) 
primitiv_lib.tex(,130) @item @strong{Note:}
primitiv_lib.tex(,131) While @code{primitive(i)} may fail for finite fields,
primitiv_lib.tex(,132) @code{primitive_extra(i)} tries all elements of k(a,b) and, hence,
primitiv_lib.tex(,133) always finds a primitive element. @*
primitiv_lib.tex(,134) In order to do this (try all elements), field extensions like Z/pZ(a)
primitiv_lib.tex(,135) are not allowed for the ground field k. @*
primitiv_lib.tex(,136) @code{primitive_extra(i)} assumes that the second generator, g, is
primitiv_lib.tex(,137) monic as polynomial in (k[x])[y].
primitiv_lib.tex(,138) 
primitiv_lib.tex(,139) @end table
primitiv_lib.tex(,140) @strong{Example:}
primitiv_lib.tex(,141) @smallexample
primitiv_lib.tex(,142) @c computed example primitive_extra d2t_singular/primitiv_lib.doc:125 
primitiv_lib.tex(,143) LIB "primitiv.lib";
primitiv_lib.tex(,144) ring exring=3,(x,y),dp;
primitiv_lib.tex(,145) ideal i=x2+1,y3+y2-1;
primitiv_lib.tex(,146) primitive_extra(i);
primitiv_lib.tex(,147) @expansion{} _[1]=y6-y5+y4-y3-y-1
primitiv_lib.tex(,148) @expansion{} _[2]=y5+y4+y2+y+1
primitiv_lib.tex(,149) ring extension=(3,y),x,dp;
primitiv_lib.tex(,150) minpoly=y6-y5+y4-y3-y-1;
primitiv_lib.tex(,151) number a=y5+y4+y2+y+1;
primitiv_lib.tex(,152) a^2;
primitiv_lib.tex(,153) @expansion{} -1
primitiv_lib.tex(,154) factorize(x2+1);
primitiv_lib.tex(,155) @expansion{} [1]:
primitiv_lib.tex(,156) @expansion{}    _[1]=1
primitiv_lib.tex(,157) @expansion{}    _[2]=x+(-y5-y4-y2-y-1)
primitiv_lib.tex(,158) @expansion{}    _[3]=x+(y5+y4+y2+y+1)
primitiv_lib.tex(,159) @expansion{} [2]:
primitiv_lib.tex(,160) @expansion{}    1,1,1
primitiv_lib.tex(,161) factorize(x3+x2-1);
primitiv_lib.tex(,162) @expansion{} [1]:
primitiv_lib.tex(,163) @expansion{}    _[1]=1
primitiv_lib.tex(,164) @expansion{}    _[2]=x+(-y5-y4-y3-y2-y-1)
primitiv_lib.tex(,165) @expansion{}    _[3]=x+(y5+y4+y2+1)
primitiv_lib.tex(,166) @expansion{}    _[4]=x+(y3+y+1)
primitiv_lib.tex(,167) @expansion{} [2]:
primitiv_lib.tex(,168) @expansion{}    1,1,1,1
primitiv_lib.tex(,169) @c end example primitive_extra d2t_singular/primitiv_lib.doc:125
primitiv_lib.tex(,170) @end smallexample
primitiv_lib.tex(,171) @c ---end content primitive_extra---
primitiv_lib.tex(,172) 
primitiv_lib.tex(,173) @c ------------------- splitring -------------
primitiv_lib.tex(,174) @node splitring,, primitive_extra, primitiv_lib
primitiv_lib.tex(,175) @subsubsection splitring
primitiv_lib.tex(,176) @cindex splitring
primitiv_lib.tex(,177) @c ---content splitring---
primitiv_lib.tex(,178) Procedure from library @code{primitiv.lib} (@pxref{primitiv_lib}).
primitiv_lib.tex(,179) 
primitiv_lib.tex(,180) @table @asis
primitiv_lib.tex(,181) @item @strong{Usage:}
primitiv_lib.tex(,182) splitring(f,R[,L]); f poly, R string, L list of polys and/or ideals
primitiv_lib.tex(,183) (optional)
primitiv_lib.tex(,184) 
primitiv_lib.tex(,185) @item @strong{Assume:}
primitiv_lib.tex(,186) f is univariate and irreducible over the active basering. @*
primitiv_lib.tex(,187) The active ring must allow an algebraic extension (e.g., it cannot
primitiv_lib.tex(,188) be a transcendent ring extension of Q or Z/p).
primitiv_lib.tex(,189) 
primitiv_lib.tex(,190) @item @strong{Create:}
primitiv_lib.tex(,191) a ring with name R, in which f is reducible, and CHANGE to it.
primitiv_lib.tex(,192) 
primitiv_lib.tex(,193) @item @strong{Return:}
primitiv_lib.tex(,194) list L mapped into the new ring R, if L is given; else nothing
primitiv_lib.tex(,195) 
primitiv_lib.tex(,196) @item @strong{Note:}
primitiv_lib.tex(,197) If the old ring has no parameter, the name @code{a} is chosen for the
primitiv_lib.tex(,198) parameter of R (if @code{a} is no ring variable; if it is, @code{b} is
primitiv_lib.tex(,199) chosen, etc.; if @code{a,b,c,o} are ring variables,
primitiv_lib.tex(,200) @code{splitring(f,R[,L])} produces an error message), otherwise the
primitiv_lib.tex(,201) name of the parameter is kept and only the minimal polynomial is
primitiv_lib.tex(,202) changed. @*
primitiv_lib.tex(,203) The names of the ring variables and the orderings are not affected. @*
primitiv_lib.tex(,204) It is also allowed to call @code{splitring} with R="".
primitiv_lib.tex(,205) Then the old basering will be REPLACED by the new ring (with the
primitiv_lib.tex(,206) same name as the old ring).
primitiv_lib.tex(,207) 
primitiv_lib.tex(,208) @cindex algebraic field extension
primitiv_lib.tex(,209) @cindex extension of rings
primitiv_lib.tex(,210) @end table
primitiv_lib.tex(,211) @strong{Example:}
primitiv_lib.tex(,212) @smallexample
primitiv_lib.tex(,213) @c computed example splitring d2t_singular/primitiv_lib.doc:180 
primitiv_lib.tex(,214) LIB "primitiv.lib";
primitiv_lib.tex(,215) ring r=0,(x,y),dp;
primitiv_lib.tex(,216) splitring(x2-2,"r1");   // change to Q(sqrt(2))
primitiv_lib.tex(,217) // change to Q(sqrt(2),sqrt(sqrt(2)))=Q(a) and return the transformed 
primitiv_lib.tex(,218) // old parameter:
primitiv_lib.tex(,219) splitring(x2-a,"r2",a); 
primitiv_lib.tex(,220) @expansion{} // new minimal polynomial: a4-2
primitiv_lib.tex(,221) @expansion{} [1]:
primitiv_lib.tex(,222) @expansion{}    (a2)
primitiv_lib.tex(,223) // the result is (a)^2 = (sqrt(sqrt(2)))^2
primitiv_lib.tex(,224) nameof(basering);
primitiv_lib.tex(,225) @expansion{} r2
primitiv_lib.tex(,226) r2;
primitiv_lib.tex(,227) @expansion{} //   characteristic : 0
primitiv_lib.tex(,228) @expansion{} //   1 parameter    : a 
primitiv_lib.tex(,229) @expansion{} //   minpoly        : (a4-2)
primitiv_lib.tex(,230) @expansion{} //   number of vars : 2
primitiv_lib.tex(,231) @expansion{} //        block   1 : ordering dp
primitiv_lib.tex(,232) @expansion{} //                  : names    x y 
primitiv_lib.tex(,233) @expansion{} //        block   2 : ordering C
primitiv_lib.tex(,234) kill r1; kill r2;
primitiv_lib.tex(,235) @c end example splitring d2t_singular/primitiv_lib.doc:180
primitiv_lib.tex(,236) @end smallexample
primitiv_lib.tex(,237) @c ---end content splitring---
singular.texi(,411) @c ---------------------------------------------------------
singular.texi(,412) @node reesclos_lib, intprog_lib, primitiv_lib, Commutative algebra
singular.texi(,413) @subsection reesclos_lib
singular.texi(,414) @c include of docu for reesclos.lib
reesclos_lib.tex(,1) @c ---content LibInfo---
reesclos_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/reesclos_lib.doc
reesclos_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/reesclos_lib.doc INSTEAD
reesclos_lib.tex(,4) @c library version: (1.50,2001/08/06)
reesclos_lib.tex(,5) @c library file: ../Singular/LIB/reesclos.lib
reesclos_lib.tex(,6) @cindex reesclos.lib
reesclos_lib.tex(,7) @cindex reesclos_lib
reesclos_lib.tex(,8) @table @asis
reesclos_lib.tex(,9) @item @strong{Library:}
reesclos_lib.tex(,10) reesclos.lib
reesclos_lib.tex(,11) @item @strong{Purpose:}
reesclos_lib.tex(,12)      procedures to compute the int. closure of an ideal
reesclos_lib.tex(,13) @item @strong{Author:}
reesclos_lib.tex(,14) Tobias Hirsch, email: hirsch@@math.tu-cottbus.de
reesclos_lib.tex(,15) 
reesclos_lib.tex(,16) @item @strong{Overview:}
reesclos_lib.tex(,17) A library to compute the integral closure of an ideal I in a polynomial ring
reesclos_lib.tex(,18) R=K[x(1),...,x(n)] using the Rees Algebra R[It] of I. It computes the integral
reesclos_lib.tex(,19) closure of R[It] (in the same manner as done in the library 'normal.lib'),
reesclos_lib.tex(,20) which is a graded subalgebra of R[t]. The degree-k-component is the integral
reesclos_lib.tex(,21) closure of the k-th power of I.
reesclos_lib.tex(,22) @*These procedures can also be used to compute the integral closure R^ of an
reesclos_lib.tex(,23) integral domain R=k[x(1),...,x(n)]/ker, ker a prime ideal, in its quotient
reesclos_lib.tex(,24) field K=Q(R), as an affine ring R^=k[T(1),...,T(s)]]/J and to get
reesclos_lib.tex(,25) representations of elements of R^ as fractions of elements of R.
reesclos_lib.tex(,26) 
reesclos_lib.tex(,27) @end table
reesclos_lib.tex(,28) 
reesclos_lib.tex(,29) @strong{Procedures:}
reesclos_lib.tex(,30) @menu
reesclos_lib.tex(,31) * ReesAlgebra:: computes the Rees Algebra of an ideal I
reesclos_lib.tex(,32) * normalI:: computes the integral closure of an ideal I using R[It]
reesclos_lib.tex(,33) * primeClosure:: computes the integral closure of the int. domain R
reesclos_lib.tex(,34) * closureRingtower:: defines the rings in the list L as global objects R(i)
reesclos_lib.tex(,35) * closureFrac:: computes fractions representing elements of R^=L[n]
reesclos_lib.tex(,36) @end menu
reesclos_lib.tex(,37) @c ---end content LibInfo---
reesclos_lib.tex(,38) 
reesclos_lib.tex(,39) @c ------------------- ReesAlgebra -------------
reesclos_lib.tex(,40) @node ReesAlgebra, normalI,, reesclos_lib
reesclos_lib.tex(,41) @subsubsection ReesAlgebra
reesclos_lib.tex(,42) @cindex ReesAlgebra
reesclos_lib.tex(,43) @c ---content ReesAlgebra---
reesclos_lib.tex(,44) Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).
reesclos_lib.tex(,45) 
reesclos_lib.tex(,46) @table @asis
reesclos_lib.tex(,47) @item @strong{Usage:}
reesclos_lib.tex(,48) ReesAlgebra (I); I = ideal
reesclos_lib.tex(,49) 
reesclos_lib.tex(,50) @item @strong{Return:}
reesclos_lib.tex(,51) The Rees algebra R[It] as an affine ring, where I is an ideal in R.
reesclos_lib.tex(,52) The procedure returns a list containing two rings:
reesclos_lib.tex(,53) @*[1]: a ring, say RR; in the ring an ideal ker such that R[It]=RR/ker
reesclos_lib.tex(,54) 
reesclos_lib.tex(,55) [2]: a ring, say Kxt; the basering with additional variable t
reesclos_lib.tex(,56) containing an ideal mapI that defines the map RR-->Kxt
reesclos_lib.tex(,57) 
reesclos_lib.tex(,58) @end table
reesclos_lib.tex(,59) @strong{Example:}
reesclos_lib.tex(,60) @smallexample
reesclos_lib.tex(,61) @c computed example ReesAlgebra d2t_singular/reesclos_lib.doc:59 
reesclos_lib.tex(,62) LIB "reesclos.lib";
reesclos_lib.tex(,63) ring R = 0,(x,y),dp;
reesclos_lib.tex(,64) ideal I = x2,xy4,y5;
reesclos_lib.tex(,65) list L = ReesAlgebra(I);
reesclos_lib.tex(,66) def Rees = L[1];       // defines the ring Rees, containing the ideal ker
reesclos_lib.tex(,67) setring Rees;          // passes to the ring Rees
reesclos_lib.tex(,68) Rees;
reesclos_lib.tex(,69) @expansion{} //   characteristic : 0
reesclos_lib.tex(,70) @expansion{} //   number of vars : 5
reesclos_lib.tex(,71) @expansion{} //        block   1 : ordering dp
reesclos_lib.tex(,72) @expansion{} //                  : names    x y U(1) U(2) U(3) 
reesclos_lib.tex(,73) @expansion{} //        block   2 : ordering C
reesclos_lib.tex(,74) ker;                   // R[It] is isomorphic to Rees/ker
reesclos_lib.tex(,75) @expansion{} ker[1]=y*U(2)-x*U(3)
reesclos_lib.tex(,76) @expansion{} ker[2]=y^3*U(1)*U(3)-U(2)^2
reesclos_lib.tex(,77) @expansion{} ker[3]=y^4*U(1)-x*U(2)
reesclos_lib.tex(,78) @expansion{} ker[4]=x*y^2*U(1)*U(3)^2-U(2)^3
reesclos_lib.tex(,79) @expansion{} ker[5]=x^2*y*U(1)*U(3)^3-U(2)^4
reesclos_lib.tex(,80) @expansion{} ker[6]=x^3*U(1)*U(3)^4-U(2)^5
reesclos_lib.tex(,81) @c end example ReesAlgebra d2t_singular/reesclos_lib.doc:59
reesclos_lib.tex(,82) @end smallexample
reesclos_lib.tex(,83) @c ---end content ReesAlgebra---
reesclos_lib.tex(,84) 
reesclos_lib.tex(,85) @c ------------------- normalI -------------
reesclos_lib.tex(,86) @node normalI, primeClosure, ReesAlgebra, reesclos_lib
reesclos_lib.tex(,87) @subsubsection normalI
reesclos_lib.tex(,88) @cindex normalI
reesclos_lib.tex(,89) @c ---content normalI---
reesclos_lib.tex(,90) Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).
reesclos_lib.tex(,91) 
reesclos_lib.tex(,92) @table @asis
reesclos_lib.tex(,93) @item @strong{Usage:}
reesclos_lib.tex(,94) normalI(I [,p[,c]]); I an ideal, p and c optional integers
reesclos_lib.tex(,95) 
reesclos_lib.tex(,96) @item @strong{Return:}
reesclos_lib.tex(,97) the integral closure of I,...,I^p. If p is not given, or p==0,
reesclos_lib.tex(,98) compute the closure of all powers up to the maximum degree in t
reesclos_lib.tex(,99) occurring in the generators of the closure of R[It] (so this is the
reesclos_lib.tex(,100) last one that is not just the sum/product of the above ones).
reesclos_lib.tex(,101) c is transferred to the procedure primeClosure and toggles its
reesclos_lib.tex(,102) behavior in computing the integral closure of R[It].
reesclos_lib.tex(,103) @*The result is a list containing the closure of the desired powers of
reesclos_lib.tex(,104) I as ideals of the basering.
reesclos_lib.tex(,105) 
reesclos_lib.tex(,106) @end table
reesclos_lib.tex(,107) @strong{Example:}
reesclos_lib.tex(,108) @smallexample
reesclos_lib.tex(,109) @c computed example normalI d2t_singular/reesclos_lib.doc:96 
reesclos_lib.tex(,110) LIB "reesclos.lib";
reesclos_lib.tex(,111) ring R=0,(x,y),dp;
reesclos_lib.tex(,112) ideal I = x2,xy4,y5;
reesclos_lib.tex(,113) list J = normalI(I);
reesclos_lib.tex(,114) I;
reesclos_lib.tex(,115) @expansion{} I[1]=x2
reesclos_lib.tex(,116) @expansion{} I[2]=xy4
reesclos_lib.tex(,117) @expansion{} I[3]=y5
reesclos_lib.tex(,118) J;                             // J[1] is the integral closure of I
reesclos_lib.tex(,119) @expansion{} [1]:
reesclos_lib.tex(,120) @expansion{}    _[1]=x2
reesclos_lib.tex(,121) @expansion{}    _[2]=y5
reesclos_lib.tex(,122) @expansion{}    _[3]=-xy3
reesclos_lib.tex(,123) @c end example normalI d2t_singular/reesclos_lib.doc:96
reesclos_lib.tex(,124) @end smallexample
reesclos_lib.tex(,125) @c ---end content normalI---
reesclos_lib.tex(,126) 
reesclos_lib.tex(,127) @c ------------------- primeClosure -------------
reesclos_lib.tex(,128) @node primeClosure, closureRingtower, normalI, reesclos_lib
reesclos_lib.tex(,129) @subsubsection primeClosure
reesclos_lib.tex(,130) @cindex primeClosure
reesclos_lib.tex(,131) @c ---content primeClosure---
reesclos_lib.tex(,132) Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).
reesclos_lib.tex(,133) 
reesclos_lib.tex(,134) @table @asis
reesclos_lib.tex(,135) @item @strong{Usage:}
reesclos_lib.tex(,136) primeClosure(L [,c]); L a list of a ring containing a prime ideal
reesclos_lib.tex(,137) ker, c an optional integer
reesclos_lib.tex(,138) 
reesclos_lib.tex(,139) @item @strong{Return:}
reesclos_lib.tex(,140) a list L consisting of rings L[1],...,L[n] such that
reesclos_lib.tex(,141) @*- L[1] is a copy of (not a reference to!) the input ring L[1]
reesclos_lib.tex(,142) - all rings L[i] contain ideals ker, L[2],...,L[n] contain ideals phi
reesclos_lib.tex(,143) such that
reesclos_lib.tex(,144) @*L[1]/ker --> ... --> L[n]/ker
reesclos_lib.tex(,145) @*are injections given by the corresponding ideals phi, and L[n]/ker
reesclos_lib.tex(,146) is the integral closure of L[1]/ker in its quotient field.
reesclos_lib.tex(,147) - all rings L[i] contain a polynomial nzd such that elements of
reesclos_lib.tex(,148) L[i]/ker are quotients of elements of L[i-1]/ker with denominator
reesclos_lib.tex(,149) nzd via the injection phi.
reesclos_lib.tex(,150) 
reesclos_lib.tex(,151) @item @strong{Note:}
reesclos_lib.tex(,152) - L is constructed by recursive calls of primeClosure itself.
reesclos_lib.tex(,153) - c determines the choice of nzd:
reesclos_lib.tex(,154) @*- c not given or equal to 0: first generator of the ideal SL,
reesclos_lib.tex(,155) the singular locus of Spec(L[i]/ker)
reesclos_lib.tex(,156) @*- c<>0: the generator of SL with least number of monomials.
reesclos_lib.tex(,157) 
reesclos_lib.tex(,158) @end table
reesclos_lib.tex(,159) @strong{Example:}
reesclos_lib.tex(,160) @smallexample
reesclos_lib.tex(,161) @c computed example primeClosure d2t_singular/reesclos_lib.doc:141 
reesclos_lib.tex(,162) LIB "reesclos.lib";
reesclos_lib.tex(,163) ring R=0,(x,y),dp;
reesclos_lib.tex(,164) ideal I=x4,y4;
reesclos_lib.tex(,165) def K=ReesAlgebra(I)[1];        // K contains ker such that K/ker=R[It]
reesclos_lib.tex(,166) list L=primeClosure(K);
reesclos_lib.tex(,167) def R(1)=L[1];                  // L[4] contains ker, L[4]/ker is the
reesclos_lib.tex(,168) def R(4)=L[4];                  // integral closure of L[1]/ker
reesclos_lib.tex(,169) setring R(1);
reesclos_lib.tex(,170) R(1);
reesclos_lib.tex(,171) @expansion{} //   characteristic : 0
reesclos_lib.tex(,172) @expansion{} //   number of vars : 4
reesclos_lib.tex(,173) @expansion{} //        block   1 : ordering dp
reesclos_lib.tex(,174) @expansion{} //                  : names    x y U(1) U(2) 
reesclos_lib.tex(,175) @expansion{} //        block   2 : ordering C
reesclos_lib.tex(,176) ker;
reesclos_lib.tex(,177) @expansion{} ker[1]=y^4*U(1)-x^4*U(2)
reesclos_lib.tex(,178) setring R(4);
reesclos_lib.tex(,179) R(4);
reesclos_lib.tex(,180) @expansion{} //   characteristic : 0
reesclos_lib.tex(,181) @expansion{} //   number of vars : 7
reesclos_lib.tex(,182) @expansion{} //        block   1 : ordering a
reesclos_lib.tex(,183) @expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
reesclos_lib.tex(,184) @expansion{} //                  : weights     1    1    1    1    1    1    1 
reesclos_lib.tex(,185) @expansion{} //        block   2 : ordering dp
reesclos_lib.tex(,186) @expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
reesclos_lib.tex(,187) @expansion{} //        block   3 : ordering C
reesclos_lib.tex(,188) ker;
reesclos_lib.tex(,189) @expansion{} ker[1]=T(2)*T(5)-T(1)*T(7)
reesclos_lib.tex(,190) @expansion{} ker[2]=T(1)*T(5)-T(2)*T(6)
reesclos_lib.tex(,191) @expansion{} ker[3]=T(5)*T(6)-T(3)*T(7)
reesclos_lib.tex(,192) @expansion{} ker[4]=T(4)*T(6)-T(5)*T(7)
reesclos_lib.tex(,193) @expansion{} ker[5]=T(5)^2-T(6)*T(7)
reesclos_lib.tex(,194) @expansion{} ker[6]=T(4)*T(5)-T(7)^2
reesclos_lib.tex(,195) @expansion{} ker[7]=T(3)*T(5)-T(6)^2
reesclos_lib.tex(,196) @expansion{} ker[8]=T(2)^2*T(6)-T(1)^2*T(7)
reesclos_lib.tex(,197) @expansion{} ker[9]=T(3)*T(4)-T(6)*T(7)
reesclos_lib.tex(,198) @expansion{} ker[10]=T(1)*T(4)-T(2)*T(7)
reesclos_lib.tex(,199) @expansion{} ker[11]=T(2)*T(3)-T(1)*T(6)
reesclos_lib.tex(,200) @expansion{} ker[12]=T(2)^2*T(6)^2-T(1)^2*T(6)*T(7)
reesclos_lib.tex(,201) @c end example primeClosure d2t_singular/reesclos_lib.doc:141
reesclos_lib.tex(,202) @end smallexample
reesclos_lib.tex(,203) @c ---end content primeClosure---
reesclos_lib.tex(,204) 
reesclos_lib.tex(,205) @c ------------------- closureRingtower -------------
reesclos_lib.tex(,206) @node closureRingtower, closureFrac, primeClosure, reesclos_lib
reesclos_lib.tex(,207) @subsubsection closureRingtower
reesclos_lib.tex(,208) @cindex closureRingtower
reesclos_lib.tex(,209) @c ---content closureRingtower---
reesclos_lib.tex(,210) Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).
reesclos_lib.tex(,211) 
reesclos_lib.tex(,212) @table @asis
reesclos_lib.tex(,213) @item @strong{Usage:}
reesclos_lib.tex(,214) closureRingtower(list L); L a list of rings
reesclos_lib.tex(,215) 
reesclos_lib.tex(,216) @item @strong{Create:}
reesclos_lib.tex(,217) rings R(1),...,R(n) such that R(i)=L[i] for all i
reesclos_lib.tex(,218) 
reesclos_lib.tex(,219) @end table
reesclos_lib.tex(,220) @strong{Example:}
reesclos_lib.tex(,221) @smallexample
reesclos_lib.tex(,222) @c computed example closureRingtower d2t_singular/reesclos_lib.doc:176 
reesclos_lib.tex(,223) LIB "reesclos.lib";
reesclos_lib.tex(,224) ring R=0,(x,y),dp;
reesclos_lib.tex(,225) ideal I=x4,y4;
reesclos_lib.tex(,226) list L=primeClosure(ReesAlgebra(I)[1]);
reesclos_lib.tex(,227) closureRingtower(L);
reesclos_lib.tex(,228) R(1);
reesclos_lib.tex(,229) @expansion{} //   characteristic : 0
reesclos_lib.tex(,230) @expansion{} //   number of vars : 4
reesclos_lib.tex(,231) @expansion{} //        block   1 : ordering dp
reesclos_lib.tex(,232) @expansion{} //                  : names    x y U(1) U(2) 
reesclos_lib.tex(,233) @expansion{} //        block   2 : ordering C
reesclos_lib.tex(,234) R(4);
reesclos_lib.tex(,235) @expansion{} //   characteristic : 0
reesclos_lib.tex(,236) @expansion{} //   number of vars : 7
reesclos_lib.tex(,237) @expansion{} //        block   1 : ordering a
reesclos_lib.tex(,238) @expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
reesclos_lib.tex(,239) @expansion{} //                  : weights     1    1    1    1    1    1    1 
reesclos_lib.tex(,240) @expansion{} //        block   2 : ordering dp
reesclos_lib.tex(,241) @expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
reesclos_lib.tex(,242) @expansion{} //        block   3 : ordering C
reesclos_lib.tex(,243) @c end example closureRingtower d2t_singular/reesclos_lib.doc:176
reesclos_lib.tex(,244) @end smallexample
reesclos_lib.tex(,245) @c ---end content closureRingtower---
reesclos_lib.tex(,246) 
reesclos_lib.tex(,247) @c ------------------- closureFrac -------------
reesclos_lib.tex(,248) @node closureFrac,, closureRingtower, reesclos_lib
reesclos_lib.tex(,249) @subsubsection closureFrac
reesclos_lib.tex(,250) @cindex closureFrac
reesclos_lib.tex(,251) @c ---content closureFrac---
reesclos_lib.tex(,252) Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).
reesclos_lib.tex(,253) 
reesclos_lib.tex(,254) @table @asis
reesclos_lib.tex(,255) @item @strong{Create:}
reesclos_lib.tex(,256) a list fraction of two elements of L[1], such that
reesclos_lib.tex(,257) @*f=fraction[1]/fraction[2] via the injections phi L[i]-->L[i+1].
reesclos_lib.tex(,258) 
reesclos_lib.tex(,259) @end table
reesclos_lib.tex(,260) @strong{Example:}
reesclos_lib.tex(,261) @smallexample
reesclos_lib.tex(,262) @c computed example closureFrac d2t_singular/reesclos_lib.doc:203 
reesclos_lib.tex(,263) LIB "reesclos.lib";
reesclos_lib.tex(,264) ring R=0,(x,y),dp;
reesclos_lib.tex(,265) ideal ker=x2+y2;
reesclos_lib.tex(,266) export R;
reesclos_lib.tex(,267) @expansion{} // ** `R` is already global
reesclos_lib.tex(,268) list L=primeClosure(R);          // We normalize R/ker
reesclos_lib.tex(,269) closureRingtower(L);             // Now R/ker=R(1) with normalization R(2)
reesclos_lib.tex(,270) setring R(2);
reesclos_lib.tex(,271) kill(R);
reesclos_lib.tex(,272) phi;                             // The map R(1)-->R(2)
reesclos_lib.tex(,273) @expansion{} phi[1]=T(1)*T(2)
reesclos_lib.tex(,274) @expansion{} phi[2]=T(1)
reesclos_lib.tex(,275) poly f=T(1)*T(2);                // We will get a representation of f
reesclos_lib.tex(,276) export R(2);
reesclos_lib.tex(,277) @expansion{} // ** `R(2)` is already global
reesclos_lib.tex(,278) closureFrac(L);
reesclos_lib.tex(,279) setring R(1);
reesclos_lib.tex(,280) kill (R(2));
reesclos_lib.tex(,281) fraction;                        // f=fraction[1]/fraction[2] via phi
reesclos_lib.tex(,282) @expansion{} [1]:
reesclos_lib.tex(,283) @expansion{}    xy
reesclos_lib.tex(,284) @expansion{} [2]:
reesclos_lib.tex(,285) @expansion{}    y
reesclos_lib.tex(,286) @c end example closureFrac d2t_singular/reesclos_lib.doc:203
reesclos_lib.tex(,287) @end smallexample
reesclos_lib.tex(,288) @c ---end content closureFrac---
singular.texi(,416) @c ---------------------------------------------------------
singular.texi(,417) @node intprog_lib, toric_lib, reesclos_lib, Commutative algebra
singular.texi(,418) @subsection intprog_lib
singular.texi(,419) @c include of docu for intprog.lib
intprog_lib.tex(,1) @c ---content LibInfo---
intprog_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/intprog_lib.doc
intprog_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/intprog_lib.doc INSTEAD
intprog_lib.tex(,4) @c library version: (1.5,2001/02/06)
intprog_lib.tex(,5) @c library file: ../Singular/LIB/intprog.lib
intprog_lib.tex(,6) @cindex intprog.lib
intprog_lib.tex(,7) @cindex intprog_lib
intprog_lib.tex(,8) @table @asis
intprog_lib.tex(,9) @item @strong{Library:}
intprog_lib.tex(,10) intprog.lib
intprog_lib.tex(,11) @item @strong{Purpose:}
intprog_lib.tex(,12)       Integer Programming with Groebner Basis Methods
intprog_lib.tex(,13) @item @strong{Author:}
intprog_lib.tex(,14) Christine Theis, email: ctheis@@math.uni-sb.de
intprog_lib.tex(,15) 
intprog_lib.tex(,16) @end table
intprog_lib.tex(,17) 
intprog_lib.tex(,18) @strong{Procedures:}
intprog_lib.tex(,19) @menu
intprog_lib.tex(,20) * solve_IP:: procedures for solving Integer Programming problems
intprog_lib.tex(,21) @end menu
intprog_lib.tex(,22) @c ---end content LibInfo---
intprog_lib.tex(,23) 
intprog_lib.tex(,24) @c ------------------- solve_IP -------------
intprog_lib.tex(,25) @node solve_IP,,, intprog_lib
intprog_lib.tex(,26) @subsubsection solve_IP
intprog_lib.tex(,27) @cindex solve_IP
intprog_lib.tex(,28) @c ---content solve_IP---
intprog_lib.tex(,29) Procedure from library @code{intprog.lib} (@pxref{intprog_lib}).
intprog_lib.tex(,30) 
intprog_lib.tex(,31) @table @asis
intprog_lib.tex(,32) @item @strong{Usage:}
intprog_lib.tex(,33) solve_IP(A,bx,c,alg); A intmat, bx intvec, c intvec, alg string.
intprog_lib.tex(,34) solve_IP(A,bx,c,alg); A intmat, bx list of intvec, c intvec,
intprog_lib.tex(,35) alg string.
intprog_lib.tex(,36) @*solve_IP(A,bx,c,alg,prsv); A intmat, bx intvec, c intvec,
intprog_lib.tex(,37) alg string, prsv intvec.
intprog_lib.tex(,38) @*solve_IP(A,bx,c,alg,prsv); A intmat, bx list of intvec, c intvec,
intprog_lib.tex(,39) alg string, prsv intvec.
intprog_lib.tex(,40) 
intprog_lib.tex(,41) @item @strong{Return:}
intprog_lib.tex(,42) same type as bx: solution of the associated integer programming
intprog_lib.tex(,43) problem(s) as explained in
intprog_lib.tex(,44) 
intprog_lib.tex(,45)    @ref{Toric ideals and integer programming}.
intprog_lib.tex(,46) 
intprog_lib.tex(,47) @item @strong{Note:}
intprog_lib.tex(,48) This procedure returns the solution(s) of the given IP-problem(s)
intprog_lib.tex(,49) or the message `not solvable'.
intprog_lib.tex(,50) @*One may call the procedure with several different algorithms:
intprog_lib.tex(,51) @*- the algorithm of Conti/Traverso (ct),
intprog_lib.tex(,52) @*- the positive variant of the algorithm of Conti/Traverso (pct),
intprog_lib.tex(,53) @*- the algorithm of Conti/Traverso using elimination (ect),
intprog_lib.tex(,54) @*- the algorithm of Pottier (pt),
intprog_lib.tex(,55) @*- an algorithm of Bigatti/La Scala/Robbiano (blr),
intprog_lib.tex(,56) @*- the algorithm of Hosten/Sturmfels (hs),
intprog_lib.tex(,57) @*- the algorithm of DiBiase/Urbanke (du).
intprog_lib.tex(,58) The argument `alg' should be the abbreviation for an algorithm as
intprog_lib.tex(,59) above: ct, pct, ect, pt, blr, hs or du.
intprog_lib.tex(,60) 
intprog_lib.tex(,61) `ct' allows computation of an optimal solution of the IP-problem
intprog_lib.tex(,62) directly from the right-hand vector b.
intprog_lib.tex(,63) @*The same is true for its `positive' variant `pct' which may only be
intprog_lib.tex(,64) applied if A and b have nonnegative entries.
intprog_lib.tex(,65) @*All other algorithms need initial solutions of the IP-problem.
intprog_lib.tex(,66) 
intprog_lib.tex(,67) If `alg' is chosen to be `ct' or `pct', bx is read as the right hand
intprog_lib.tex(,68) vector b of the system Ax=b. b should then be an intvec of size m
intprog_lib.tex(,69) where m is the number of rows of A.
intprog_lib.tex(,70) @*Furthermore, bx and A should be nonnegative if `pct' is used.
intprog_lib.tex(,71) If `alg' is chosen to be `ect',`pt',`blr',`hs' or `du',
intprog_lib.tex(,72) bx is read as an initial solution x of the system Ax=b.
intprog_lib.tex(,73) bx should then be a nonnegative intvec of size n where n is the
intprog_lib.tex(,74) number of columns of A.
intprog_lib.tex(,75) 
intprog_lib.tex(,76) If `alg' is chosen to be `blr' or `hs', the algorithm needs a vector
intprog_lib.tex(,77) with positive coefficients in the row space of A.
intprog_lib.tex(,78) @*If no row of A contains only positive entries, one has to use the
intprog_lib.tex(,79) versions of solve_IP which take such a vector prsv as an argument.
intprog_lib.tex(,80) 
intprog_lib.tex(,81) solve_IP may also be called with a list bx of intvecs instead of a
intprog_lib.tex(,82) single intvec.
intprog_lib.tex(,83) 
intprog_lib.tex(,84) @end table
intprog_lib.tex(,85) @strong{Example:}
intprog_lib.tex(,86) @smallexample
intprog_lib.tex(,87) @c computed example solve_IP d2t_singular/intprog_lib.doc:85 
intprog_lib.tex(,88) LIB "intprog.lib";
intprog_lib.tex(,89) // 1. call with single right-hand vector
intprog_lib.tex(,90) intmat A[2][3]=1,1,0,0,1,1;
intprog_lib.tex(,91) intvec b1=1,1;
intprog_lib.tex(,92) intvec c=2,2,1;
intprog_lib.tex(,93) intvec solution_vector=solve_IP(A,b1,c,"pct");
intprog_lib.tex(,94) solution_vector;"";
intprog_lib.tex(,95) @expansion{} 0,1,0
intprog_lib.tex(,96) @expansion{} 
intprog_lib.tex(,97) // 2. call with list of right-hand vectors
intprog_lib.tex(,98) intvec b2=-1,1;
intprog_lib.tex(,99) list l=b1,b2;
intprog_lib.tex(,100) l;
intprog_lib.tex(,101) @expansion{} [1]:
intprog_lib.tex(,102) @expansion{}    1,1
intprog_lib.tex(,103) @expansion{} [2]:
intprog_lib.tex(,104) @expansion{}    -1,1
intprog_lib.tex(,105) list solution_list=solve_IP(A,l,c,"ct");
intprog_lib.tex(,106) solution_list;"";
intprog_lib.tex(,107) @expansion{} [1]:
intprog_lib.tex(,108) @expansion{}    0,1,0
intprog_lib.tex(,109) @expansion{} [2]:
intprog_lib.tex(,110) @expansion{}    not solvable
intprog_lib.tex(,111) @expansion{} 
intprog_lib.tex(,112) // 3. call with single initial solution vector
intprog_lib.tex(,113) A=2,1,-1,-1,1,2;
intprog_lib.tex(,114) b1=3,4,5;
intprog_lib.tex(,115) solve_IP(A,b1,c,"du");"";
intprog_lib.tex(,116) @expansion{} 0,7,2
intprog_lib.tex(,117) @expansion{} 
intprog_lib.tex(,118) // 4. call with single initial solution vector
intprog_lib.tex(,119) //    and algorithm needing a positive row space vector
intprog_lib.tex(,120) solution_vector=solve_IP(A,b1,c,"hs");"";
intprog_lib.tex(,121) @expansion{} ERROR: The chosen algorithm needs a positive vector in the row space of t\
intprog_lib.tex(,122)    he matrix.
intprog_lib.tex(,123) @expansion{} 0
intprog_lib.tex(,124) @expansion{} 
intprog_lib.tex(,125) // 5. call with single initial solution vector
intprog_lib.tex(,126) //     and positive row space vector
intprog_lib.tex(,127) intvec prsv=1,2,1;
intprog_lib.tex(,128) solution_vector=solve_IP(A,b1,c,"hs",prsv);
intprog_lib.tex(,129) solution_vector;"";
intprog_lib.tex(,130) @expansion{} 0,7,2
intprog_lib.tex(,131) @expansion{} 
intprog_lib.tex(,132) // 6. call with list of initial solution vectors
intprog_lib.tex(,133) //    and positive row space vector
intprog_lib.tex(,134) b2=7,8,0;
intprog_lib.tex(,135) l=b1,b2;
intprog_lib.tex(,136) l;
intprog_lib.tex(,137) @expansion{} [1]:
intprog_lib.tex(,138) @expansion{}    3,4,5
intprog_lib.tex(,139) @expansion{} [2]:
intprog_lib.tex(,140) @expansion{}    7,8,0
intprog_lib.tex(,141) solution_list=solve_IP(A,l,c,"blr",prsv);
intprog_lib.tex(,142) solution_list;
intprog_lib.tex(,143) @expansion{} [1]:
intprog_lib.tex(,144) @expansion{}    0,7,2
intprog_lib.tex(,145) @expansion{} [2]:
intprog_lib.tex(,146) @expansion{}    7,8,0
intprog_lib.tex(,147) @c end example solve_IP d2t_singular/intprog_lib.doc:85
intprog_lib.tex(,148) @end smallexample
intprog_lib.tex(,149) @c inserted refs from d2t_singular/intprog_lib.doc:120
intprog_lib.tex(,164) @c end inserted refs from d2t_singular/intprog_lib.doc:120
intprog_lib.tex(,165) 
intprog_lib.tex(,166) @c ---end content solve_IP---
singular.texi(,421) @c ---------------------------------------------------------
singular.texi(,422) @node toric_lib, ,intprog_lib, Commutative algebra
singular.texi(,423) @subsection toric_lib
singular.texi(,424) @c include of docu for toric.lib
toric_lib.tex(,1) @c ---content LibInfo---
toric_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/toric_lib.doc
toric_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/toric_lib.doc INSTEAD
toric_lib.tex(,4) @c library version: (1.11,2001/02/06)
toric_lib.tex(,5) @c library file: ../Singular/LIB/toric.lib
toric_lib.tex(,6) @cindex toric.lib
toric_lib.tex(,7) @cindex toric_lib
toric_lib.tex(,8) @table @asis
toric_lib.tex(,9) @item @strong{Library:}
toric_lib.tex(,10) toric.lib
toric_lib.tex(,11) @item @strong{Purpose:}
toric_lib.tex(,12)    Standard Basis of Toric Ideals
toric_lib.tex(,13) @item @strong{Author:}
toric_lib.tex(,14) Christine Theis, email: ctheis@@math.uni-sb.de
toric_lib.tex(,15) 
toric_lib.tex(,16) @end table
toric_lib.tex(,17) 
toric_lib.tex(,18) @strong{Procedures:}
toric_lib.tex(,19) @menu
toric_lib.tex(,20) * toric_ideal:: computes the toric ideal of A
toric_lib.tex(,21) * toric_std:: standard basis of I by a specialized Buchberger algorithm
toric_lib.tex(,22) @end menu
toric_lib.tex(,23) @c ---end content LibInfo---
toric_lib.tex(,24) 
toric_lib.tex(,25) @c ------------------- toric_ideal -------------
toric_lib.tex(,26) @node toric_ideal, toric_std,, toric_lib
toric_lib.tex(,27) @subsubsection toric_ideal
toric_lib.tex(,28) @cindex toric_ideal
toric_lib.tex(,29) @c ---content toric_ideal---
toric_lib.tex(,30) Procedure from library @code{toric.lib} (@pxref{toric_lib}).
toric_lib.tex(,31) 
toric_lib.tex(,32) @table @asis
toric_lib.tex(,33) @item @strong{Usage:}
toric_lib.tex(,34) toric_ideal(A,alg); A intmat, alg string
toric_lib.tex(,35) @*toric_ideal(A,alg,prsv); A intmat, alg string, prsv intvec
toric_lib.tex(,36) 
toric_lib.tex(,37) @item @strong{Return:}
toric_lib.tex(,38) ideal: standard basis of the toric ideal of A
toric_lib.tex(,39) 
toric_lib.tex(,40) @item @strong{Note:}
toric_lib.tex(,41) These procedures return the standard basis of the toric ideal of A
toric_lib.tex(,42) with respect to the term ordering in the current basering. Not all
toric_lib.tex(,43) term orderings are supported: The usual global term orderings may be
toric_lib.tex(,44) used, but no block orderings combining them.
toric_lib.tex(,45) @*One may call the procedure with several different algorithms: @*
toric_lib.tex(,46) - the algorithm of Conti/Traverso using elimination (ect), @*
toric_lib.tex(,47) - the algorithm of Pottier (pt),
toric_lib.tex(,48) @*- an algorithm of Bigatti/La Scala/Robbiano (blr),
toric_lib.tex(,49) @*- the algorithm of Hosten/Sturmfels (hs),
toric_lib.tex(,50) @*- the algorithm of DiBiase/Urbanke (du).
toric_lib.tex(,51) @*The argument `alg' should be the abbreviation for an algorithm as
toric_lib.tex(,52) above: ect, pt, blr, hs or du.
toric_lib.tex(,53) 
toric_lib.tex(,54) If `alg' is chosen to be `blr' or `hs', the algorithm needs a vector
toric_lib.tex(,55) with positive coefficients in the row space of A.
toric_lib.tex(,56) @*If no row of A contains only positive entries, one has to use the
toric_lib.tex(,57) second version of toric_ideal which takes such a vector as its third
toric_lib.tex(,58) argument.
toric_lib.tex(,59) @*For the mathematical background, see
toric_lib.tex(,60) 
toric_lib.tex(,61)   @ref{Toric ideals and integer programming}.
toric_lib.tex(,62) 
toric_lib.tex(,63) @end table
toric_lib.tex(,64) @strong{Example:}
toric_lib.tex(,65) @smallexample
toric_lib.tex(,66) @c computed example toric_ideal d2t_singular/toric_lib.doc:64 
toric_lib.tex(,67) LIB "toric.lib";
toric_lib.tex(,68) ring r=0,(x,y,z),dp;
toric_lib.tex(,69) // call with two arguments
toric_lib.tex(,70) intmat A[2][3]=1,1,0,0,1,1;
toric_lib.tex(,71) A;
toric_lib.tex(,72) @expansion{} 1,1,0,
toric_lib.tex(,73) @expansion{} 0,1,1 
toric_lib.tex(,74) ideal I=toric_ideal(A,"du");
toric_lib.tex(,75) I;
toric_lib.tex(,76) @expansion{} I[1]=xz-y
toric_lib.tex(,77) I=toric_ideal(A,"blr");
toric_lib.tex(,78) @expansion{} ERROR: The chosen algorithm needs a positive vector in the row space of t\
toric_lib.tex(,79)    he matrix.
toric_lib.tex(,80) I;
toric_lib.tex(,81) @expansion{} I[1]=0
toric_lib.tex(,82) // call with three arguments
toric_lib.tex(,83) intvec prsv=1,2,1;
toric_lib.tex(,84) I=toric_ideal(A,"blr",prsv);
toric_lib.tex(,85) I;
toric_lib.tex(,86) @expansion{} I[1]=xz-y
toric_lib.tex(,87) @c end example toric_ideal d2t_singular/toric_lib.doc:64
toric_lib.tex(,88) @end smallexample
toric_lib.tex(,89) @c inserted refs from d2t_singular/toric_lib.doc:80
toric_lib.tex(,106) @c end inserted refs from d2t_singular/toric_lib.doc:80
toric_lib.tex(,107) 
toric_lib.tex(,108) @c ---end content toric_ideal---
toric_lib.tex(,109) 
toric_lib.tex(,110) @c ------------------- toric_std -------------
toric_lib.tex(,111) @node toric_std,, toric_ideal, toric_lib
toric_lib.tex(,112) @subsubsection toric_std
toric_lib.tex(,113) @cindex toric_std
toric_lib.tex(,114) @c ---content toric_std---
toric_lib.tex(,115) Procedure from library @code{toric.lib} (@pxref{toric_lib}).
toric_lib.tex(,116) 
toric_lib.tex(,117) @table @asis
toric_lib.tex(,118) @item @strong{Usage:}
toric_lib.tex(,119) toric_std(I); I ideal
toric_lib.tex(,120) 
toric_lib.tex(,121) @item @strong{Return:}
toric_lib.tex(,122) ideal: standard basis of I
toric_lib.tex(,123) 
toric_lib.tex(,124) @item @strong{Note:}
toric_lib.tex(,125) This procedure computes the standard basis of I using a specialized
toric_lib.tex(,126) Buchberger algorithm. The generating system by which I is given has
toric_lib.tex(,127) to consist of binomials of the form x^u-x^v. There is no real check
toric_lib.tex(,128) if I is toric. If I is generated by binomials of the above form,
toric_lib.tex(,129) but not toric, toric_std computes an ideal `between' I and its
toric_lib.tex(,130) saturation with respect to all variables.
toric_lib.tex(,131) @*For the mathematical background, see
toric_lib.tex(,132) 
toric_lib.tex(,133)    @ref{Toric ideals and integer programming}.
toric_lib.tex(,134) 
toric_lib.tex(,135) @end table
toric_lib.tex(,136) @strong{Example:}
toric_lib.tex(,137) @smallexample
toric_lib.tex(,138) @c computed example toric_std d2t_singular/toric_lib.doc:114 
toric_lib.tex(,139) LIB "toric.lib";
toric_lib.tex(,140) ring r=0,(x,y,z),wp(3,2,1);
toric_lib.tex(,141) // call with toric ideal (of the matrix A=(1,1,1))
toric_lib.tex(,142) ideal I=x-y,x-z;
toric_lib.tex(,143) ideal J=toric_std(I);
toric_lib.tex(,144) J;
toric_lib.tex(,145) @expansion{} J[1]=y-z
toric_lib.tex(,146) @expansion{} J[2]=x-z
toric_lib.tex(,147) // call with the same ideal, but badly chosen generators:
toric_lib.tex(,148) // 1) not only binomials
toric_lib.tex(,149) I=x-y,2x-y-z;
toric_lib.tex(,150) J=toric_std(I);
toric_lib.tex(,151) @expansion{} ERROR: Generator 2 of the input ideal is no difference of monomials.
toric_lib.tex(,152) // 2) binomials whose monomials are not relatively prime
toric_lib.tex(,153) I=x-y,xy-yz,y-z;
toric_lib.tex(,154) J=toric_std(I);
toric_lib.tex(,155) @expansion{} Warning: The monomials of generator 2 of the input ideal are not relative\
toric_lib.tex(,156)    ly prime.
toric_lib.tex(,157) J;
toric_lib.tex(,158) @expansion{} J[1]=y-z
toric_lib.tex(,159) @expansion{} J[2]=x-z
toric_lib.tex(,160) // call with a non-toric ideal that seems to be toric
toric_lib.tex(,161) I=x-yz,xy-z;
toric_lib.tex(,162) J=toric_std(I);
toric_lib.tex(,163) J;
toric_lib.tex(,164) @expansion{} J[1]=y2-1
toric_lib.tex(,165) @expansion{} J[2]=x-yz
toric_lib.tex(,166) // comparison with real standard basis and saturation
toric_lib.tex(,167) ideal H=std(I);
toric_lib.tex(,168) H;
toric_lib.tex(,169) @expansion{} H[1]=x-yz
toric_lib.tex(,170) @expansion{} H[2]=y2z-z
toric_lib.tex(,171) LIB "elim.lib";
toric_lib.tex(,172) sat(H,xyz);
toric_lib.tex(,173) @expansion{} [1]:
toric_lib.tex(,174) @expansion{}    _[1]=x-yz
toric_lib.tex(,175) @expansion{}    _[2]=y2-1
toric_lib.tex(,176) @expansion{} [2]:
toric_lib.tex(,177) @expansion{}    1
toric_lib.tex(,178) @c end example toric_std d2t_singular/toric_lib.doc:114
toric_lib.tex(,179) @end smallexample
toric_lib.tex(,180) @c inserted refs from d2t_singular/toric_lib.doc:140
toric_lib.tex(,197) @c end inserted refs from d2t_singular/toric_lib.doc:140
toric_lib.tex(,198) 
toric_lib.tex(,199) @c ---end content toric_std---
singular.texi(,426) @c ----------------------------------------------------------------------------
singular.texi(,427) @node Singularities, Invariant theory, Commutative algebra, SINGULAR libraries
singular.texi(,428) @section Singularities
singular.texi(,429) @cindex Singularities
singular.texi(,430) 
singular.texi(,431) @menu
singular.texi(,432) @c * alexpoly_lib:: Resolution Graph and Alexander Polynomial
singular.texi(,433) * classify_lib:: procedures for the Arnold-classifier of singularities
singular.texi(,434) * deform_lib:: procedures for computing miniversal deformation
singular.texi(,435) * equising_lib:: procedures for equisingularity strata
singular.texi(,436) * gaussman_lib:: procedures for gauss-manin connection of a singularity
singular.texi(,437) * hnoether_lib:: procedures for the Hamburger-Noether (Puiseux) development
singular.texi(,438) * mondromy_lib:: procedures to compute the monodromy of a singularity
singular.texi(,439) * qhmoduli_lib:: procedures for moduli spaces of sqh-singularities
singular.texi(,440) * sing_lib:: procedures for computing invariants of singularities
singular.texi(,441) * spcurve_lib:: procedures for cm codimension 2 singularities
singular.texi(,442) * spectrum_lib:: procedures for computing singularity spectra
singular.texi(,443) @end menu
singular.texi(,444) 
singular.texi(,445) @c ---------------------------------------------------------
singular.texi(,446) @c @node alexpoly_lib, classify_lib, Singularities, Singularities
singular.texi(,447) @c @subsection alexpoly_lib
singular.texi(,448) @c @c lib alexpoly.lib
singular.texi(,449) @c ---------------------------------------------------------
singular.texi(,450) @c @node classify_lib, deform_lib, alexpoly_lib, Singularities
singular.texi(,451) @node classify_lib, deform_lib, Singularities, Singularities
singular.texi(,452) @subsection classify_lib
singular.texi(,453) @c include of docu for classify.lib
classify_lib.tex(,1) @c ---content LibInfo---
classify_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/classify_lib.doc
classify_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/classify_lib.doc INSTEAD
classify_lib.tex(,4) @c library version: (1.48.2.4,2002/04/11)
classify_lib.tex(,5) @c library file: ../Singular/LIB/classify.lib
classify_lib.tex(,6) @cindex classify.lib
classify_lib.tex(,7) @cindex classify_lib
classify_lib.tex(,8) @table @asis
classify_lib.tex(,9) @item @strong{Library:}
classify_lib.tex(,10) classify.lib
classify_lib.tex(,11) @item @strong{Purpose:}
classify_lib.tex(,12)   Arnold Classifier of Singularities
classify_lib.tex(,13) @item @strong{Authors:}
classify_lib.tex(,14) Kai Krueger, krueger@@mathematik.uni-kl.de
classify_lib.tex(,15) @*Corina Baciu, baciu@@mathematik.uni-kl.de
classify_lib.tex(,16) 
classify_lib.tex(,17) @item @strong{Overview:}
classify_lib.tex(,18) A library for classifying isolated hypersurface singularities w.r.t. right
classify_lib.tex(,19) equivalence, based on the determinator of singularities by V.I. Arnold.
classify_lib.tex(,20) 
classify_lib.tex(,21) @end table
classify_lib.tex(,22) 
classify_lib.tex(,23) @strong{Procedures:}
classify_lib.tex(,24) @menu
classify_lib.tex(,25) * basicinvariants:: computes Milnor number, determinacy-bound and corank of
classify_lib.tex(,26) * classify:: normal form of poly f determined with Arnold's method
classify_lib.tex(,27) * corank:: computes the corank of f (i.e. of the Hessian of f)
classify_lib.tex(,28) * Hcode:: coding of intvec v according to the number repetitions
classify_lib.tex(,29) * init_debug:: print trace and debugging information depending on int n
classify_lib.tex(,30) * internalfunctions:: display names of internal procedures of this library
classify_lib.tex(,31) * milnorcode:: Hilbert poly of [e-th] Milnor algebra coded with Hcode
classify_lib.tex(,32) * morsesplit:: residual part of f after applying the splitting lemma
classify_lib.tex(,33) * quickclass:: normal form of f determined by invariants (milnorcode)
classify_lib.tex(,34) * singularity:: normal form of singularity given by its name s and index
classify_lib.tex(,35) * swap:: returns b,a
classify_lib.tex(,36) * A_L:: shortcut for quickclass(f) or normalform(s)
classify_lib.tex(,37) * normalform:: normal form of singularity given by its name s
classify_lib.tex(,38) * debug_log:: print trace and debugging information w.r.t level>@@DeBug
classify_lib.tex(,39) @end menu
classify_lib.tex(,40) @c ---end content LibInfo---
classify_lib.tex(,41) 
classify_lib.tex(,42) @c ------------------- basicinvariants -------------
classify_lib.tex(,43) @node basicinvariants, classify,, classify_lib
classify_lib.tex(,44) @subsubsection basicinvariants
classify_lib.tex(,45) @cindex basicinvariants
classify_lib.tex(,46) @c ---content basicinvariants---
classify_lib.tex(,47) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,48) 
classify_lib.tex(,49) @table @asis
classify_lib.tex(,50) @item @strong{Usage:}
classify_lib.tex(,51) basicinvariants(f); f = poly
classify_lib.tex(,52) 
classify_lib.tex(,53) @item @strong{Compute:}
classify_lib.tex(,54) Compute basic invariants of f: an upper bound d for the
classify_lib.tex(,55) determinacy, the milnor number mu and the corank c of f
classify_lib.tex(,56) 
classify_lib.tex(,57) @item @strong{Return:}
classify_lib.tex(,58) intvec: d, mu, c
classify_lib.tex(,59) 
classify_lib.tex(,60) @end table
classify_lib.tex(,61) @strong{Example:}
classify_lib.tex(,62) @smallexample
classify_lib.tex(,63) @c computed example basicinvariants d2t_singular/classify_lib.doc:61 
classify_lib.tex(,64) LIB "classify.lib";
classify_lib.tex(,65) ring r=0,(x,y,z),ds;
classify_lib.tex(,66) basicinvariants((x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3);
classify_lib.tex(,67) @expansion{} 5,4,2
classify_lib.tex(,68) @c end example basicinvariants d2t_singular/classify_lib.doc:61
classify_lib.tex(,69) @end smallexample
classify_lib.tex(,70) @c ---end content basicinvariants---
classify_lib.tex(,71) 
classify_lib.tex(,72) @c ------------------- classify -------------
classify_lib.tex(,73) @node classify, corank, basicinvariants, classify_lib
classify_lib.tex(,74) @subsubsection classify
classify_lib.tex(,75) @cindex classify
classify_lib.tex(,76) @c ---content classify---
classify_lib.tex(,77) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,78) 
classify_lib.tex(,79) @table @asis
classify_lib.tex(,80) @item @strong{Usage:}
classify_lib.tex(,81) classify(f); f=poly
classify_lib.tex(,82) 
classify_lib.tex(,83) @item @strong{Compute:}
classify_lib.tex(,84) normal form and singularity type of f with respect to right
classify_lib.tex(,85) equivalence, as given in the book "Singularities of differentiable
classify_lib.tex(,86) maps, Volume I" by V.I. Arnold, S.M. Gusein-Zade, A.N. Varchenko
classify_lib.tex(,87) 
classify_lib.tex(,88) @item @strong{Return:}
classify_lib.tex(,89) normal form of f, of type poly
classify_lib.tex(,90) 
classify_lib.tex(,91) @item @strong{Remark:}
classify_lib.tex(,92) This version of classify is only beta. Please send bugs and
classify_lib.tex(,93) comments to: "Kai Krueger" <krueger@@mathematik.uni-kl.de> @*
classify_lib.tex(,94) Be sure to have at least Singular version 1.0.1. Updates can be
classify_lib.tex(,95) found at: @*
classify_lib.tex(,96) URL=http://www.mathematik.uni-kl.de/~krueger/Singular/
classify_lib.tex(,97) 
classify_lib.tex(,98) @item @strong{Note:}
classify_lib.tex(,99) type init_debug(n); (0 <= n <= 10) in order to get intermediate
classify_lib.tex(,100) information, higher values of n give more information.
classify_lib.tex(,101) @*The proc creates several global objects with names all starting
classify_lib.tex(,102) with @@, hence there should be no name conflicts
classify_lib.tex(,103) 
classify_lib.tex(,104) @end table
classify_lib.tex(,105) @strong{Example:}
classify_lib.tex(,106) @smallexample
classify_lib.tex(,107) @c computed example classify d2t_singular/classify_lib.doc:104 
classify_lib.tex(,108) LIB "classify.lib";
classify_lib.tex(,109) ring r=0,(x,y,z),ds;
classify_lib.tex(,110) poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
classify_lib.tex(,111) classify(f);
classify_lib.tex(,112) @expansion{} About the singularity :
classify_lib.tex(,113) @expansion{}           Milnor number(f)   = 4
classify_lib.tex(,114) @expansion{}           Corank(f)          = 2
classify_lib.tex(,115) @expansion{}           Determinacy       <= 5
classify_lib.tex(,116) @expansion{} Guessing type via Milnorcode:   D[k]=D[4]
classify_lib.tex(,117) @expansion{} 
classify_lib.tex(,118) @expansion{} Computing normal form ...
classify_lib.tex(,119) @expansion{} I have to apply the splitting lemma. This will take some time....:-)
classify_lib.tex(,120) @expansion{}    Arnold step number 4
classify_lib.tex(,121) @expansion{} The singularity
classify_lib.tex(,122) @expansion{}    -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
classify_lib.tex(,123) @expansion{} is R-equivalent to D[4].
classify_lib.tex(,124) @expansion{}    Milnor number = 4
classify_lib.tex(,125) @expansion{}    modality      = 0
classify_lib.tex(,126) @expansion{} 2z2+x2y+y3
classify_lib.tex(,127) init_debug(3);
classify_lib.tex(,128) @expansion{} Debugging level change from  0  to  3
classify_lib.tex(,129) classify(f);
classify_lib.tex(,130) @expansion{} Computing Basicinvariants of f ...
classify_lib.tex(,131) @expansion{} About the singularity :
classify_lib.tex(,132) @expansion{}           Milnor number(f)   = 4
classify_lib.tex(,133) @expansion{}           Corank(f)          = 2
classify_lib.tex(,134) @expansion{}           Determinacy       <= 5
classify_lib.tex(,135) @expansion{} Hcode: 1,2,1,0,0
classify_lib.tex(,136) @expansion{} Milnor code :  1,1,1
classify_lib.tex(,137) @expansion{} Debug:(2):  entering HKclass3_teil_1 1,1,1
classify_lib.tex(,138) @expansion{} Debug:(2):  finishing HKclass3_teil_1
classify_lib.tex(,139) @expansion{} Guessing type via Milnorcode:   D[k]=D[4]
classify_lib.tex(,140) @expansion{} 
classify_lib.tex(,141) @expansion{} Computing normal form ...
classify_lib.tex(,142) @expansion{} I have to apply the splitting lemma. This will take some time....:-)
classify_lib.tex(,143) @expansion{} Debug:(3):  Split the polynomial below using determinacy:  5
classify_lib.tex(,144) @expansion{} Debug:(3):  9y2-12yz+4z2-x3+6x2y-4x2z+xyz+x4+3x2y3
classify_lib.tex(,145) @expansion{} Debug:(2):  Permutations: 3,2,1
classify_lib.tex(,146) @expansion{} Debug:(2):  Permutations: 3,2,1
classify_lib.tex(,147) @expansion{} Debug:(2):  rank determined with Morse rg= 1
classify_lib.tex(,148) @expansion{} Residual singularity f= -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
classify_lib.tex(,149) @expansion{} Step 3
classify_lib.tex(,150) @expansion{}    Arnold step number 4
classify_lib.tex(,151) @expansion{} The singularity
classify_lib.tex(,152) @expansion{}    -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
classify_lib.tex(,153) @expansion{} is R-equivalent to D[4].
classify_lib.tex(,154) @expansion{}    Milnor number = 4
classify_lib.tex(,155) @expansion{}    modality      = 0
classify_lib.tex(,156) @expansion{} Debug:(2):  Decode:
classify_lib.tex(,157) @expansion{} Debug:(2):  S_in= D[4]   s_in= D[4]                          
classify_lib.tex(,158) @expansion{} Debug:(2):  Looking for Normalform of  D[k] with (k,r,s) = ( 4 , 0 , 0 )
classify_lib.tex(,159) @expansion{} Debug:(2):  Opening Singalarity-database:  
classify_lib.tex(,160) @expansion{}  DBM: NFlist
classify_lib.tex(,161) @expansion{} Debug:(2):  DBMread( D[k] )= x2y+y^(k-1) .
classify_lib.tex(,162) @expansion{} Debug:(2):  S= f = x2y+y^(k-1);  Tp= x2y+y^(k-1) Key= I_D[k]
classify_lib.tex(,163) @expansion{} Polynom f= x2y+y3   crk= 2   Mu= 4  MlnCd= 1,1,1
classify_lib.tex(,164) @expansion{} Debug:(2):  Info= x2y+y3
classify_lib.tex(,165) @expansion{} Debug:(2):  Normal form NF(f)= 2*x(3)^2+x(1)^2*x(2)+x(2)^3
classify_lib.tex(,166) @expansion{} 2z2+x2y+y3
classify_lib.tex(,167) @c end example classify d2t_singular/classify_lib.doc:104
classify_lib.tex(,168) @end smallexample
classify_lib.tex(,169) @c ---end content classify---
classify_lib.tex(,170) 
classify_lib.tex(,171) @c ------------------- corank -------------
classify_lib.tex(,172) @node corank, Hcode, classify, classify_lib
classify_lib.tex(,173) @subsubsection corank
classify_lib.tex(,174) @cindex corank
classify_lib.tex(,175) @c ---content corank---
classify_lib.tex(,176) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,177) 
classify_lib.tex(,178) @table @asis
classify_lib.tex(,179) @item @strong{Usage:}
classify_lib.tex(,180) corank(f); f=poly
classify_lib.tex(,181) 
classify_lib.tex(,182) @item @strong{Return:}
classify_lib.tex(,183) the corank of the Hessian matrix of f, of type int
classify_lib.tex(,184) 
classify_lib.tex(,185) @item @strong{Remark:}
classify_lib.tex(,186) corank(f) is the number of variables occurring in the residual
classify_lib.tex(,187) singularity after applying 'morsesplit' to f
classify_lib.tex(,188) 
classify_lib.tex(,189) @end table
classify_lib.tex(,190) @strong{Example:}
classify_lib.tex(,191) @smallexample
classify_lib.tex(,192) @c computed example corank d2t_singular/classify_lib.doc:136 
classify_lib.tex(,193) LIB "classify.lib";
classify_lib.tex(,194) ring r=0,(x,y,z),ds;
classify_lib.tex(,195) poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
classify_lib.tex(,196) corank(f);
classify_lib.tex(,197) @expansion{} 2
classify_lib.tex(,198) @c end example corank d2t_singular/classify_lib.doc:136
classify_lib.tex(,199) @end smallexample
classify_lib.tex(,200) @c ---end content corank---
classify_lib.tex(,201) 
classify_lib.tex(,202) @c ------------------- Hcode -------------
classify_lib.tex(,203) @node Hcode, init_debug, corank, classify_lib
classify_lib.tex(,204) @subsubsection Hcode
classify_lib.tex(,205) @cindex Hcode
classify_lib.tex(,206) @c ---content Hcode---
classify_lib.tex(,207) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,208) 
classify_lib.tex(,209) @table @asis
classify_lib.tex(,210) @item @strong{Usage:}
classify_lib.tex(,211) Hcode(v); v=intvec
classify_lib.tex(,212) 
classify_lib.tex(,213) @item @strong{Return:}
classify_lib.tex(,214) intvec, coding v according to the number of successive
classify_lib.tex(,215) repetitions of an entry
classify_lib.tex(,216) 
classify_lib.tex(,217) @end table
classify_lib.tex(,218) @strong{Example:}
classify_lib.tex(,219) @smallexample
classify_lib.tex(,220) @c computed example Hcode d2t_singular/classify_lib.doc:163 
classify_lib.tex(,221) LIB "classify.lib";
classify_lib.tex(,222) intvec v1 = 1,3,5,5,2;
classify_lib.tex(,223) Hcode(v1);
classify_lib.tex(,224) @expansion{} 1,0,1,0,2,0,0,1,0
classify_lib.tex(,225) intvec v2 = 1,2,3,4,4,4,4,4,4,4,3,2,1;
classify_lib.tex(,226) Hcode(v2);
classify_lib.tex(,227) @expansion{} 1,1,1,7,1,1,1
classify_lib.tex(,228) @c end example Hcode d2t_singular/classify_lib.doc:163
classify_lib.tex(,229) @end smallexample
classify_lib.tex(,230) @c ---end content Hcode---
classify_lib.tex(,231) 
classify_lib.tex(,232) @c ------------------- init_debug -------------
classify_lib.tex(,233) @node init_debug, internalfunctions, Hcode, classify_lib
classify_lib.tex(,234) @subsubsection init_debug
classify_lib.tex(,235) @cindex init_debug
classify_lib.tex(,236) @c ---content init_debug---
classify_lib.tex(,237) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,238) 
classify_lib.tex(,239) @table @asis
classify_lib.tex(,240) @item @strong{Usage:}
classify_lib.tex(,241) init_debug([level]); level=int
classify_lib.tex(,242) 
classify_lib.tex(,243) @item @strong{Compute:}
classify_lib.tex(,244) Set the global variable @@DeBug to level. The variable @@DeBug is
classify_lib.tex(,245) used by the function debug_log(level, list of strings) to know
classify_lib.tex(,246) when to print the list of strings. init_debug() reports only
classify_lib.tex(,247) changes of @@DeBug.
classify_lib.tex(,248) 
classify_lib.tex(,249) @item @strong{Note:}
classify_lib.tex(,250) The procedure init_debug(n); is useful as trace-mode. n may
classify_lib.tex(,251) range from 0 to 10, higher values of n give more information.
classify_lib.tex(,252) 
classify_lib.tex(,253) @end table
classify_lib.tex(,254) @strong{Example:}
classify_lib.tex(,255) @smallexample
classify_lib.tex(,256) @c computed example init_debug d2t_singular/classify_lib.doc:197 
classify_lib.tex(,257) LIB "classify.lib";
classify_lib.tex(,258) init_debug();
classify_lib.tex(,259) debug_log(1,"no trace information printed");
classify_lib.tex(,260) init_debug(1);
classify_lib.tex(,261) @expansion{} Debugging level change from  0  to  1
classify_lib.tex(,262) debug_log(1,"some trace information");
classify_lib.tex(,263) @expansion{} some trace information
classify_lib.tex(,264) init_debug(2);
classify_lib.tex(,265) @expansion{} Debugging level change from  1  to  2
classify_lib.tex(,266) debug_log(2,"nice for debugging scripts");
classify_lib.tex(,267) @expansion{} Debug:(2):  nice for debugging scripts
classify_lib.tex(,268) init_debug(0);
classify_lib.tex(,269) @expansion{} Debugging switched off.
classify_lib.tex(,270) @c end example init_debug d2t_singular/classify_lib.doc:197
classify_lib.tex(,271) @end smallexample
classify_lib.tex(,272) @c ---end content init_debug---
classify_lib.tex(,273) 
classify_lib.tex(,274) @c ------------------- internalfunctions -------------
classify_lib.tex(,275) @node internalfunctions, milnorcode, init_debug, classify_lib
classify_lib.tex(,276) @subsubsection internalfunctions
classify_lib.tex(,277) @cindex internalfunctions
classify_lib.tex(,278) @c ---content internalfunctions---
classify_lib.tex(,279) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,280) 
classify_lib.tex(,281) @table @asis
classify_lib.tex(,282) @item @strong{Usage:}
classify_lib.tex(,283) internalfunctions();
classify_lib.tex(,284) 
classify_lib.tex(,285) @item @strong{Return:}
classify_lib.tex(,286) nothing, display names of internal procedures of classify.lib
classify_lib.tex(,287) 
classify_lib.tex(,288) @end table
classify_lib.tex(,289) @strong{Example:}
classify_lib.tex(,290) @smallexample
classify_lib.tex(,291) @c computed example internalfunctions d2t_singular/classify_lib.doc:227 
classify_lib.tex(,292) LIB "classify.lib";
classify_lib.tex(,293) internalfunctions();
classify_lib.tex(,294) @expansion{}    Internal functions for the classification using Arnold's method,
classify_lib.tex(,295) @expansion{}    the function numbers correspond to numbers in Arnold's classifier:
classify_lib.tex(,296) @expansion{} Klassifiziere(poly f);      //determine the type of the singularity f
classify_lib.tex(,297) @expansion{}   Funktion1bis (poly f, list cstn)
classify_lib.tex(,298) @expansion{}   Funktion3 (poly f, list cstn)
classify_lib.tex(,299) @expansion{}   Funktion6 (poly f, list cstn)
classify_lib.tex(,300) @expansion{}   Funktion13 (poly f, list cstn)
classify_lib.tex(,301) @expansion{}   Funktion17 (poly f, list cstn)
classify_lib.tex(,302) @expansion{}   Funktion25 (poly f, list cstn)
classify_lib.tex(,303) @expansion{}   Funktion40 (poly f, list cstn, int k)
classify_lib.tex(,304) @expansion{}   Funktion47 (poly f, list cstn)
classify_lib.tex(,305) @expansion{}   Funktion50 (poly f, list cstn)
classify_lib.tex(,306) @expansion{}   Funktion58 (poly fin, list cstn)
classify_lib.tex(,307) @expansion{}   Funktion59 (poly f, list cstn)
classify_lib.tex(,308) @expansion{}   Funktion66 (poly f, list cstn)
classify_lib.tex(,309) @expansion{}   Funktion82 (poly f, list cstn)
classify_lib.tex(,310) @expansion{}   Funktion83 (poly f, list cstn)
classify_lib.tex(,311) @expansion{}   Funktion91 (poly f, list cstn, int k)
classify_lib.tex(,312) @expansion{}   Funktion92 (poly f, list cstn, int k)
classify_lib.tex(,313) @expansion{}   Funktion93 (poly f, list cstn, int k)
classify_lib.tex(,314) @expansion{}   Funktion94 (poly f, list cstn, int k)
classify_lib.tex(,315) @expansion{}   Funktion95 (poly f, list cstn, int k)
classify_lib.tex(,316) @expansion{}   Funktion96 (poly f, list cstn, int k)
classify_lib.tex(,317) @expansion{}   Funktion97 (poly f, list cstn)
classify_lib.tex(,318) @expansion{}   Isomorphie_s82_x (poly f, poly fk, int k)
classify_lib.tex(,319) @expansion{}   Isomorphie_s82_z (poly f, poly fk, int k)
classify_lib.tex(,320) @expansion{}   Isomorphie_s17 (poly f, poly fk, int k, int ct)
classify_lib.tex(,321) @expansion{}   printresult (string f,string typ,int Mu,int m,int corank,int K)
classify_lib.tex(,322) @expansion{}   
classify_lib.tex(,323) @expansion{}    Internal functions for the classifcation by invariants:
classify_lib.tex(,324) @expansion{}   Cubic (poly f)
classify_lib.tex(,325) @expansion{}   parity (int e)             //return the parity of e
classify_lib.tex(,326) @expansion{}   HKclass (intvec i)
classify_lib.tex(,327) @expansion{}   HKclass3( intvec i, string SG_Typ, int cnt)
classify_lib.tex(,328) @expansion{}   HKclass3_teil_1 (intvec i, string SG_Typ, int cnt)
classify_lib.tex(,329) @expansion{}   HKclass5 (intvec i, string SG_Typ, int cnt)
classify_lib.tex(,330) @expansion{}   HKclass5_teil_1 (intvec i, string SG_Typ, int cnt)
classify_lib.tex(,331) @expansion{}   HKclass5_teil_2 (intvec i, string SG_Typ, int cnt)
classify_lib.tex(,332) @expansion{}   HKclass7 (intvec i, string SG_Typ, int cnt)
classify_lib.tex(,333) @expansion{}   HKclass7_teil_1 (intvec i, string SG_Typ, int cnt)
classify_lib.tex(,334) @expansion{}   
classify_lib.tex(,335) @expansion{}    Internal functions for the Morse-splitting lemma:
classify_lib.tex(,336) @expansion{}   Morse(poly fi, int K, int corank)  //splitting lemma itself
classify_lib.tex(,337) @expansion{}   Coeffs (list #)
classify_lib.tex(,338) @expansion{}   Coeff
classify_lib.tex(,339) @expansion{}   
classify_lib.tex(,340) @expansion{}    Internal functions providing tools:
classify_lib.tex(,341) @expansion{}   ReOrder(poly f)
classify_lib.tex(,342) @expansion{}   Singularitaet(string typ,int k,int r,int s,poly a,poly b,poly c,poly d)
classify_lib.tex(,343) @expansion{}   RandomPolyK
classify_lib.tex(,344) @expansion{}   Faktorisiere(poly f, poly g, int p, int k)   compute g = (ax+by^k)^p
classify_lib.tex(,345) @expansion{}   Teile(poly f, poly g);             //divides f by g
classify_lib.tex(,346) @expansion{}   GetRf(poly f, int n);
classify_lib.tex(,347) @expansion{}   Show(poly f);
classify_lib.tex(,348) @expansion{}   checkring();
classify_lib.tex(,349) @expansion{}   DecodeNormalFormString(string s);
classify_lib.tex(,350) @expansion{}   Setring(int n, string ringname);
classify_lib.tex(,351) @expansion{}   
classify_lib.tex(,352) @c end example internalfunctions d2t_singular/classify_lib.doc:227
classify_lib.tex(,353) @end smallexample
classify_lib.tex(,354) @c ---end content internalfunctions---
classify_lib.tex(,355) 
classify_lib.tex(,356) @c ------------------- milnorcode -------------
classify_lib.tex(,357) @node milnorcode, morsesplit, internalfunctions, classify_lib
classify_lib.tex(,358) @subsubsection milnorcode
classify_lib.tex(,359) @cindex milnorcode
classify_lib.tex(,360) @c ---content milnorcode---
classify_lib.tex(,361) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,362) 
classify_lib.tex(,363) @table @asis
classify_lib.tex(,364) @item @strong{Usage:}
classify_lib.tex(,365) milnorcode(f[,e]); f=poly, e=int
classify_lib.tex(,366) 
classify_lib.tex(,367) @item @strong{Return:}
classify_lib.tex(,368) intvec, coding the Hilbert function of the e-th Milnor algebra
classify_lib.tex(,369) of f, i.e. of basering/(jacob(f)^e) (default e=1), according
classify_lib.tex(,370) to proc Hcode
classify_lib.tex(,371) 
classify_lib.tex(,372) @end table
classify_lib.tex(,373) @strong{Example:}
classify_lib.tex(,374) @smallexample
classify_lib.tex(,375) @c computed example milnorcode d2t_singular/classify_lib.doc:253 
classify_lib.tex(,376) LIB "classify.lib";
classify_lib.tex(,377) ring r=0,(x,y,z),ds;
classify_lib.tex(,378) poly f=x2y+y3+z2;
classify_lib.tex(,379) milnorcode(f);
classify_lib.tex(,380) @expansion{} 1,1,1
classify_lib.tex(,381) milnorcode(f,2);  // a big second argument may result in memory overflow
classify_lib.tex(,382) @expansion{} 1,0,1,0,2,0,0,1,0
classify_lib.tex(,383) @c end example milnorcode d2t_singular/classify_lib.doc:253
classify_lib.tex(,384) @end smallexample
classify_lib.tex(,385) @c ---end content milnorcode---
classify_lib.tex(,386) 
classify_lib.tex(,387) @c ------------------- morsesplit -------------
classify_lib.tex(,388) @node morsesplit, quickclass, milnorcode, classify_lib
classify_lib.tex(,389) @subsubsection morsesplit
classify_lib.tex(,390) @cindex morsesplit
classify_lib.tex(,391) @c ---content morsesplit---
classify_lib.tex(,392) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,393) 
classify_lib.tex(,394) @table @asis
classify_lib.tex(,395) @item @strong{Usage:}
classify_lib.tex(,396) morsesplit(f); f=poly
classify_lib.tex(,397) 
classify_lib.tex(,398) @item @strong{Return:}
classify_lib.tex(,399) Normal form of f in M^3 after application of the splitting lemma
classify_lib.tex(,400) 
classify_lib.tex(,401) @item @strong{Compute:}
classify_lib.tex(,402) apply the splitting lemma (generalized Morse lemma) to f
classify_lib.tex(,403) 
classify_lib.tex(,404) @end table
classify_lib.tex(,405) @strong{Example:}
classify_lib.tex(,406) @smallexample
classify_lib.tex(,407) @c computed example morsesplit d2t_singular/classify_lib.doc:283 
classify_lib.tex(,408) LIB "classify.lib";
classify_lib.tex(,409) ring r=0,(x,y,z),ds;
classify_lib.tex(,410) export r;
classify_lib.tex(,411) @expansion{} // ** `r` is already global
classify_lib.tex(,412) init_debug(1);
classify_lib.tex(,413) @expansion{} Debugging level is set to  1
classify_lib.tex(,414) poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
classify_lib.tex(,415) poly g=morsesplit(f);
classify_lib.tex(,416) @expansion{} Residual singularity f= -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
classify_lib.tex(,417) g;
classify_lib.tex(,418) @expansion{} -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
classify_lib.tex(,419) @c end example morsesplit d2t_singular/classify_lib.doc:283
classify_lib.tex(,420) @end smallexample
classify_lib.tex(,421) @c ---end content morsesplit---
classify_lib.tex(,422) 
classify_lib.tex(,423) @c ------------------- quickclass -------------
classify_lib.tex(,424) @node quickclass, singularity, morsesplit, classify_lib
classify_lib.tex(,425) @subsubsection quickclass
classify_lib.tex(,426) @cindex quickclass
classify_lib.tex(,427) @c ---content quickclass---
classify_lib.tex(,428) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,429) 
classify_lib.tex(,430) @table @asis
classify_lib.tex(,431) @item @strong{Usage:}
classify_lib.tex(,432) quickclass(f); f=poly
classify_lib.tex(,433) 
classify_lib.tex(,434) @item @strong{Return:}
classify_lib.tex(,435) Normal form of f in Arnold's list
classify_lib.tex(,436) 
classify_lib.tex(,437) @item @strong{Remark:}
classify_lib.tex(,438) try to determine the normal form of f by invariants, mainly by
classify_lib.tex(,439) computing the Hilbert function of the Milnor algebra,
classify_lib.tex(,440) no coordinate change is needed (see also proc 'milnorcode').
classify_lib.tex(,441) 
classify_lib.tex(,442) @end table
classify_lib.tex(,443) @strong{Example:}
classify_lib.tex(,444) @smallexample
classify_lib.tex(,445) @c computed example quickclass d2t_singular/classify_lib.doc:317 
classify_lib.tex(,446) LIB "classify.lib";
classify_lib.tex(,447) ring r=0,(x,y,z),ds;
classify_lib.tex(,448) poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
classify_lib.tex(,449) quickclass(f);
classify_lib.tex(,450) @expansion{} Singularity R-equivalent to :  D[k]=D[4]
classify_lib.tex(,451) @expansion{} normal form : z2+x2y+y3
classify_lib.tex(,452) @expansion{} z2+x2y+y3
classify_lib.tex(,453) @c end example quickclass d2t_singular/classify_lib.doc:317
classify_lib.tex(,454) @end smallexample
classify_lib.tex(,455) @c ---end content quickclass---
classify_lib.tex(,456) 
classify_lib.tex(,457) @c ------------------- singularity -------------
classify_lib.tex(,458) @node singularity, swap, quickclass, classify_lib
classify_lib.tex(,459) @subsubsection singularity
classify_lib.tex(,460) @cindex singularity
classify_lib.tex(,461) @c ---content singularity---
classify_lib.tex(,462) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,463) 
classify_lib.tex(,464) @table @asis
classify_lib.tex(,465) @item @strong{Usage:}
classify_lib.tex(,466) singularity(t, l); t=string (name of singularity),
classify_lib.tex(,467) @*l=list of integers/polynomials (indices/parameters of singularity)
classify_lib.tex(,468) 
classify_lib.tex(,469) @item @strong{Compute:}
classify_lib.tex(,470) get the singularity named by type t from the database.
classify_lib.tex(,471) list l is as follows: @*
classify_lib.tex(,472) l= k [,r [,s [,a [,b [,c [,d]..]: k,r,s=int a,b,c,d=poly. @*
classify_lib.tex(,473) The name of the dbm-database file is: NFlist.[dir,pag].
classify_lib.tex(,474) The file is found in the current directory. If it does not
classify_lib.tex(,475) exist, please run the script MakeDBM first.
classify_lib.tex(,476) 
classify_lib.tex(,477) @item @strong{Return:}
classify_lib.tex(,478) Normal form and corank of the singularity named by type t and its
classify_lib.tex(,479) index (indices) l.
classify_lib.tex(,480) 
classify_lib.tex(,481) @end table
classify_lib.tex(,482) @strong{Example:}
classify_lib.tex(,483) @smallexample
classify_lib.tex(,484) @c computed example singularity d2t_singular/classify_lib.doc:353 
classify_lib.tex(,485) LIB "classify.lib";
classify_lib.tex(,486) ring r=0,(x,y,z),(c,ds);
classify_lib.tex(,487) init_debug(0);
classify_lib.tex(,488) singularity("E[6k]",6);
classify_lib.tex(,489) @expansion{} [1]:
classify_lib.tex(,490) @expansion{}    x3+xy13+y19
classify_lib.tex(,491) @expansion{} [2]:
classify_lib.tex(,492) @expansion{}    2
classify_lib.tex(,493) singularity("T[k,r,s]", 3, 7, 5);
classify_lib.tex(,494) @expansion{} [1]:
classify_lib.tex(,495) @expansion{}    x3+xyz+z5+y7
classify_lib.tex(,496) @expansion{} [2]:
classify_lib.tex(,497) @expansion{}    3
classify_lib.tex(,498) poly f=y;
classify_lib.tex(,499) singularity("J[k,r]", 4, 0, 0, f);
classify_lib.tex(,500) @expansion{} [1]:
classify_lib.tex(,501) @expansion{}    x3+x2y4+y13
classify_lib.tex(,502) @expansion{} [2]:
classify_lib.tex(,503) @expansion{}    2
classify_lib.tex(,504) @c end example singularity d2t_singular/classify_lib.doc:353
classify_lib.tex(,505) @end smallexample
classify_lib.tex(,506) @c ---end content singularity---
classify_lib.tex(,507) 
classify_lib.tex(,508) @c ------------------- swap -------------
classify_lib.tex(,509) @node swap, A_L, singularity, classify_lib
classify_lib.tex(,510) @subsubsection swap
classify_lib.tex(,511) @cindex swap
classify_lib.tex(,512) @c ---content swap---
classify_lib.tex(,513) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,514) 
classify_lib.tex(,515) @table @asis
classify_lib.tex(,516) @item @strong{Usage:}
classify_lib.tex(,517) swap(a,b);
classify_lib.tex(,518) 
classify_lib.tex(,519) @item @strong{Return:}
classify_lib.tex(,520) b,a if b,a is the input (any type)
classify_lib.tex(,521) 
classify_lib.tex(,522) @end table
classify_lib.tex(,523) @strong{Example:}
classify_lib.tex(,524) @smallexample
classify_lib.tex(,525) @c computed example swap d2t_singular/classify_lib.doc:382 
classify_lib.tex(,526) LIB "classify.lib";
classify_lib.tex(,527) swap("variable1","variable2");
classify_lib.tex(,528) @expansion{} variable2 variable1
classify_lib.tex(,529) @c end example swap d2t_singular/classify_lib.doc:382
classify_lib.tex(,530) @end smallexample
classify_lib.tex(,531) @c ---end content swap---
classify_lib.tex(,532) 
classify_lib.tex(,533) @c ------------------- A_L -------------
classify_lib.tex(,534) @node A_L, normalform, swap, classify_lib
classify_lib.tex(,535) @subsubsection A_L
classify_lib.tex(,536) @cindex A_L
classify_lib.tex(,537) @c ---content A_L---
classify_lib.tex(,538) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,539) 
classify_lib.tex(,540) @table @asis
classify_lib.tex(,541) @item @strong{Usage:}
classify_lib.tex(,542) A_L(f); f poly
classify_lib.tex(,543) @*A_L(s); s string, the name of the singularity
classify_lib.tex(,544) 
classify_lib.tex(,545) @item @strong{Compute:}
classify_lib.tex(,546) the normal form of f in Arnold's list of singularities in case 1,
classify_lib.tex(,547) in case 2 nothing has to be computed.
classify_lib.tex(,548) 
classify_lib.tex(,549) @item @strong{Return:}
classify_lib.tex(,550) A_L(f): compute via 'milnorcode' the class of f and return the normal
classify_lib.tex(,551) form of f found in the database.
classify_lib.tex(,552) @*A_L("name"): get the normal form from the database for the
classify_lib.tex(,553) singularity given by its name.
classify_lib.tex(,554) 
classify_lib.tex(,555) @end table
classify_lib.tex(,556) @strong{Example:}
classify_lib.tex(,557) @smallexample
classify_lib.tex(,558) @c computed example A_L d2t_singular/classify_lib.doc:414 
classify_lib.tex(,559) LIB "classify.lib";
classify_lib.tex(,560) ring r=0,(a,b,c),ds;
classify_lib.tex(,561) poly f=A_L("E[13]");
classify_lib.tex(,562) f;
classify_lib.tex(,563) @expansion{} c2+a3+ab5+b8
classify_lib.tex(,564) A_L(f);
classify_lib.tex(,565) @expansion{} Singularity R-equivalent to :  E[6k+1]=E[13]
classify_lib.tex(,566) @expansion{} normal form : c2+a3+ab5+b8
classify_lib.tex(,567) @expansion{} c2+a3+ab5+b8
classify_lib.tex(,568) @c end example A_L d2t_singular/classify_lib.doc:414
classify_lib.tex(,569) @end smallexample
classify_lib.tex(,570) @c ---end content A_L---
classify_lib.tex(,571) 
classify_lib.tex(,572) @c ------------------- normalform -------------
classify_lib.tex(,573) @node normalform, debug_log, A_L, classify_lib
classify_lib.tex(,574) @subsubsection normalform
classify_lib.tex(,575) @cindex normalform
classify_lib.tex(,576) @c ---content normalform---
classify_lib.tex(,577) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,578) 
classify_lib.tex(,579) @table @asis
classify_lib.tex(,580) @item @strong{Usage:}
classify_lib.tex(,581) normalform(s); s=string
classify_lib.tex(,582) 
classify_lib.tex(,583) @item @strong{Return:}
classify_lib.tex(,584) Arnold's normal form of singularity with name s
classify_lib.tex(,585) 
classify_lib.tex(,586) @end table
classify_lib.tex(,587) @strong{Example:}
classify_lib.tex(,588) @smallexample
classify_lib.tex(,589) @c computed example normalform d2t_singular/classify_lib.doc:441 
classify_lib.tex(,590) LIB "classify.lib";
classify_lib.tex(,591) ring r=0,(a,b,c),ds;
classify_lib.tex(,592) normalform("E[13]");
classify_lib.tex(,593) @expansion{} c2+a3+ab5+b8
classify_lib.tex(,594) @c end example normalform d2t_singular/classify_lib.doc:441
classify_lib.tex(,595) @end smallexample
classify_lib.tex(,596) @c ---end content normalform---
classify_lib.tex(,597) 
classify_lib.tex(,598) @c ------------------- debug_log -------------
classify_lib.tex(,599) @node debug_log,, normalform, classify_lib
classify_lib.tex(,600) @subsubsection debug_log
classify_lib.tex(,601) @cindex debug_log
classify_lib.tex(,602) @c ---content debug_log---
classify_lib.tex(,603) Procedure from library @code{classify.lib} (@pxref{classify_lib}).
classify_lib.tex(,604) 
classify_lib.tex(,605) @table @asis
classify_lib.tex(,606) @item @strong{Usage:}
classify_lib.tex(,607) debug_log(level,li); level=int, li=comma separated "message" list
classify_lib.tex(,608) 
classify_lib.tex(,609) @item @strong{Compute:}
classify_lib.tex(,610) print "messages" if level>=@@DeBug.
classify_lib.tex(,611) @*useful for user-defined trace messages.
classify_lib.tex(,612) 
classify_lib.tex(,613) @end table
classify_lib.tex(,614) @strong{Example:}
classify_lib.tex(,615) @smallexample
classify_lib.tex(,616) @c computed example debug_log d2t_singular/classify_lib.doc:467 
classify_lib.tex(,617) LIB "classify.lib";
classify_lib.tex(,618) example init_debug;
classify_lib.tex(,619) @expansion{} // proc init_debug from lib classify.lib
classify_lib.tex(,620) @expansion{} EXAMPLE:
classify_lib.tex(,621) @expansion{}   init_debug();
classify_lib.tex(,622) @expansion{}   debug_log(1,"no trace information printed");
classify_lib.tex(,623) @expansion{}   init_debug(1);
classify_lib.tex(,624) @expansion{} Debugging level change from  0  to  1
classify_lib.tex(,625) @expansion{}   debug_log(1,"some trace information");
classify_lib.tex(,626) @expansion{} some trace information
classify_lib.tex(,627) @expansion{}   init_debug(2);
classify_lib.tex(,628) @expansion{} Debugging level change from  1  to  2
classify_lib.tex(,629) @expansion{}   debug_log(2,"nice for debugging scripts");
classify_lib.tex(,630) @expansion{} Debug:(2):  nice for debugging scripts
classify_lib.tex(,631) @expansion{}   init_debug(0);
classify_lib.tex(,632) @expansion{} Debugging switched off.
classify_lib.tex(,633) @expansion{} 
classify_lib.tex(,634) @c end example debug_log d2t_singular/classify_lib.doc:467
classify_lib.tex(,635) @end smallexample
classify_lib.tex(,636) @c inserted refs from d2t_singular/classify_lib.doc:472
classify_lib.tex(,647) @c end inserted refs from d2t_singular/classify_lib.doc:472
classify_lib.tex(,648) 
classify_lib.tex(,649) @c ---end content debug_log---
singular.texi(,455) @c ----------------------------------------------------------
singular.texi(,456) @node deform_lib, equising_lib, classify_lib, Singularities
singular.texi(,457) @subsection deform_lib
singular.texi(,458) @c include of docu for deform.lib
deform_lib.tex(,1) @c ---content LibInfo---
deform_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/deform_lib.doc
deform_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/deform_lib.doc INSTEAD
deform_lib.tex(,4) @c library version: (1.25.2.2,2003/02/24)
deform_lib.tex(,5) @c library file: ../Singular/LIB/deform.lib
deform_lib.tex(,6) @cindex deform.lib
deform_lib.tex(,7) @cindex deform_lib
deform_lib.tex(,8) @table @asis
deform_lib.tex(,9) @item @strong{Library:}
deform_lib.tex(,10) deform.lib
deform_lib.tex(,11) @item @strong{Purpose:}
deform_lib.tex(,12)     Miniversal Deformation of Singularities and Modules
deform_lib.tex(,13) @item @strong{Author:}
deform_lib.tex(,14) Bernd Martin, email: martin@@math.tu-cottbus.de
deform_lib.tex(,15) 
deform_lib.tex(,16) @end table
deform_lib.tex(,17) 
deform_lib.tex(,18) @strong{Procedures:}
deform_lib.tex(,19) @menu
deform_lib.tex(,20) * versal:: miniversal deformation of isolated singularity Fo
deform_lib.tex(,21) * mod_versal:: miniversal deformation of module Mo modulo ideal I
deform_lib.tex(,22) * lift_kbase:: lifting N into standard kbase of M
deform_lib.tex(,23) * lift_rel_kb:: relative lifting N into a kbase of M
deform_lib.tex(,24) * kill_rings:: kills the exported rings from above
deform_lib.tex(,25) @end menu
deform_lib.tex(,26) @c ---end content LibInfo---
deform_lib.tex(,27) 
deform_lib.tex(,28) @c ------------------- versal -------------
deform_lib.tex(,29) @node versal, mod_versal,, deform_lib
deform_lib.tex(,30) @subsubsection versal
deform_lib.tex(,31) @cindex versal
deform_lib.tex(,32) @c ---content versal---
deform_lib.tex(,33) Procedure from library @code{deform.lib} (@pxref{deform_lib}).
deform_lib.tex(,34) 
deform_lib.tex(,35) @table @asis
deform_lib.tex(,36) @item @strong{Usage:}
deform_lib.tex(,37) versal(Fo[,d,any]); Fo=ideal, d=int, any=list
deform_lib.tex(,38) 
deform_lib.tex(,39) @item @strong{Compute:}
deform_lib.tex(,40) miniversal deformation of Fo up to degree d (default d=100),
deform_lib.tex(,41) 
deform_lib.tex(,42) @item @strong{Create:}
deform_lib.tex(,43) Rings (exported):
deform_lib.tex(,44) @*'my'Px = extending the basering Po by new variables given by
deform_lib.tex(,45) "A,B,.." (deformation parameters), returns as basering; the
deform_lib.tex(,46) new variables precede the old ones, the ordering is the
deform_lib.tex(,47) product between "ls" and "ord(Po)"
deform_lib.tex(,48) @*'my'Qx = Px/Fo extending Qo=Po/Fo,
deform_lib.tex(,49) @*'my'So = the embedding-ring of the versal base space,
deform_lib.tex(,50) @*'my'Ox = Px/Js extending So/Js. (default my="")
deform_lib.tex(,51) 
deform_lib.tex(,52) Matrices (in Px, exported):
deform_lib.tex(,53) @*Js = giving the versal base space (obstructions),
deform_lib.tex(,54) @*Fs = giving the versal family of Fo,
deform_lib.tex(,55) @*Rs = giving the lifting of Ro=syz(Fo).
deform_lib.tex(,56) 
deform_lib.tex(,57) If d is defined (!=0), it computes up to degree d.
deform_lib.tex(,58) @*If 'any' is defined and any[1] is no string, interactive version.
deform_lib.tex(,59) @*Otherwise 'any' gives predefined strings: "my","param","order","out"
deform_lib.tex(,60) ("my" prefix-string, "param" is a letter (e.g. "A") for the name of
deform_lib.tex(,61) first parameter or (e.g. "A(") for index parameter variables, "order"
deform_lib.tex(,62) ordering string for ring extension), "out" name of output-file).
deform_lib.tex(,63) 
deform_lib.tex(,64) @item @strong{Note:}
deform_lib.tex(,65) printlevel < 0 no output at all,
deform_lib.tex(,66) @*printlevel >=0,1,2,.. informs you, what is going on;
deform_lib.tex(,67) @*this proc uses 'execute'.
deform_lib.tex(,68) 
deform_lib.tex(,69) @end table
deform_lib.tex(,70) @strong{Example:}
deform_lib.tex(,71) @smallexample
deform_lib.tex(,72) @c computed example versal d2t_singular/deform_lib.doc:70 
deform_lib.tex(,73) LIB "deform.lib";
deform_lib.tex(,74) int p          = printlevel;
deform_lib.tex(,75) printlevel     = 0;
deform_lib.tex(,76) ring r1        = 0,(x,y,z,u,v),ds;
deform_lib.tex(,77) matrix m[2][4] = x,y,z,u,y,z,u,v;
deform_lib.tex(,78) ideal Fo       = minor(m,2);
deform_lib.tex(,79) // cone over rational normal curve of degree 4
deform_lib.tex(,80) versal(Fo);
deform_lib.tex(,81) @expansion{} // ready: T_1 and T_2
deform_lib.tex(,82) @expansion{} // start computation in degree 2.
deform_lib.tex(,83) @expansion{} 
deform_lib.tex(,84) @expansion{} // Result belongs to ring Px.
deform_lib.tex(,85) @expansion{} // Equations of total space of miniversal deformation are 
deform_lib.tex(,86) @expansion{} // given by Fs, equations of miniversal base space by Js.
deform_lib.tex(,87) @expansion{} // Make Px the basering and list objects defined in Px by typing:
deform_lib.tex(,88) @expansion{}    setring Px; show(Px);
deform_lib.tex(,89) @expansion{}    listvar(matrix);
deform_lib.tex(,90) @expansion{} // NOTE: rings Qx, Px, So are alive!
deform_lib.tex(,91) @expansion{} // (use 'kill_rings("");' to remove)
deform_lib.tex(,92) setring Px;
deform_lib.tex(,93) // ___ Equations of miniversal base space ___:
deform_lib.tex(,94) Js;"";
deform_lib.tex(,95) @expansion{} Js[1,1]=BD
deform_lib.tex(,96) @expansion{} Js[1,2]=-AD+D2
deform_lib.tex(,97) @expansion{} Js[1,3]=-CD
deform_lib.tex(,98) @expansion{} 
deform_lib.tex(,99) // ___ Equations of miniversal total space ___:
deform_lib.tex(,100) Fs;"";
deform_lib.tex(,101) @expansion{} Fs[1,1]=-u2+zv+Bu+Dv
deform_lib.tex(,102) @expansion{} Fs[1,2]=-zu+yv-Au+Du
deform_lib.tex(,103) @expansion{} Fs[1,3]=-yu+xv+Cu+Dz
deform_lib.tex(,104) @expansion{} Fs[1,4]=z2-yu+Az+By
deform_lib.tex(,105) @expansion{} Fs[1,5]=yz-xu+Bx-Cz
deform_lib.tex(,106) @expansion{} Fs[1,6]=-y2+xz+Ax+Cy
deform_lib.tex(,107) @expansion{} 
deform_lib.tex(,108) @c end example versal d2t_singular/deform_lib.doc:70
deform_lib.tex(,109) @end smallexample
deform_lib.tex(,110) @c ---end content versal---
deform_lib.tex(,111) 
deform_lib.tex(,112) @c ------------------- mod_versal -------------
deform_lib.tex(,113) @node mod_versal, lift_kbase, versal, deform_lib
deform_lib.tex(,114) @subsubsection mod_versal
deform_lib.tex(,115) @cindex mod_versal
deform_lib.tex(,116) @c ---content mod_versal---
deform_lib.tex(,117) Procedure from library @code{deform.lib} (@pxref{deform_lib}).
deform_lib.tex(,118) 
deform_lib.tex(,119) @table @asis
deform_lib.tex(,120) @item @strong{Usage:}
deform_lib.tex(,121) mod_versal(Mo,I[,d,any]); I=ideal, M=module, d=int, any =list
deform_lib.tex(,122) 
deform_lib.tex(,123) @item @strong{Compute:}
deform_lib.tex(,124) miniversal deformation of coker(Mo) over Qo=Po/Io, Po=basering;
deform_lib.tex(,125) 
deform_lib.tex(,126) @item @strong{Create:}
deform_lib.tex(,127) Ringsr (exported):
deform_lib.tex(,128) @*'my'Px = extending the basering by new variables (deformation
deform_lib.tex(,129) parameters), the new variables precede the old ones,
deform_lib.tex(,130) @*the ordering is the product between "my_ord"
deform_lib.tex(,131) @*and "ord(Po)"
deform_lib.tex(,132) @*'my'Qx = Px/Io extending Qo (returns as basering),
deform_lib.tex(,133) @*'my'Ox = Px/(Io+Js) ring of the versal deformation of coker(Ms),
deform_lib.tex(,134) @*'my'So = embedding-ring of the versal base space. (default 'my'="")
deform_lib.tex(,135) 
deform_lib.tex(,136) Matrices (in Qx, exported):
deform_lib.tex(,137) @*Js = giving the versal base space (obstructions),
deform_lib.tex(,138) @*Ms = giving the versal family of Mo,
deform_lib.tex(,139) @*Ls = giving the lifting of syzygies Lo=syz(Mo),
deform_lib.tex(,140) 
deform_lib.tex(,141) If d is defined (!=0), it computes up to degree d.
deform_lib.tex(,142) @*If 'any' is defined and any[1] is no string, interactive version.
deform_lib.tex(,143) @*Otherwise 'any' gives predefined strings:"my","param","order","out"
deform_lib.tex(,144) ("my" prefix-string, "param" is a letter (e.g. "A") for the name of
deform_lib.tex(,145) first parameter or (e.g. "A(") for index parameter variables, "ord"
deform_lib.tex(,146) ordering string for ring extension), "out" name of output-file).
deform_lib.tex(,147) 
deform_lib.tex(,148) @item @strong{Note:}
deform_lib.tex(,149) printlevel < 0 no output at all,
deform_lib.tex(,150) @*printlevel >=0,1,2,.. informs you, what is going on,
deform_lib.tex(,151) @*this proc uses 'execute'.
deform_lib.tex(,152) 
deform_lib.tex(,153) @end table
deform_lib.tex(,154) @strong{Example:}
deform_lib.tex(,155) @smallexample
deform_lib.tex(,156) @c computed example mod_versal d2t_singular/deform_lib.doc:132 
deform_lib.tex(,157) LIB "deform.lib";
deform_lib.tex(,158) int p = printlevel;
deform_lib.tex(,159) printlevel = 1;
deform_lib.tex(,160) ring  Ro = 0,(x,y),wp(3,4);
deform_lib.tex(,161) ideal Io = x4+y3;
deform_lib.tex(,162) matrix Mo[2][2] = x2,y,-y2,x2;
deform_lib.tex(,163) mod_versal(Mo,Io);
deform_lib.tex(,164) @expansion{} // vdim (Ext^2) = 4
deform_lib.tex(,165) @expansion{} // vdim (Ext^1) = 4
deform_lib.tex(,166) @expansion{} // ready: Ext1 and Ext2
deform_lib.tex(,167) @expansion{} // Ext1 is quasi-homogeneous represented: 3,6,1,4
deform_lib.tex(,168) @expansion{} // infinitesimal extension
deform_lib.tex(,169) @expansion{} x2-Ax-B,   y+Cx+D,
deform_lib.tex(,170) @expansion{} -y2+Cxy+Dy,x2+Ax+B
deform_lib.tex(,171) @expansion{} // start deg = 2
deform_lib.tex(,172) @expansion{} // start deg = 3
deform_lib.tex(,173) @expansion{} // start deg = 4
deform_lib.tex(,174) @expansion{} // start deg = 5
deform_lib.tex(,175) @expansion{} // finished in degree 
deform_lib.tex(,176) @expansion{} 5
deform_lib.tex(,177) @expansion{} // quasi-homogeneous weights of miniversal base
deform_lib.tex(,178) @expansion{} 3,6,1,4
deform_lib.tex(,179) @expansion{} // Result belongs to qring Qx
deform_lib.tex(,180) @expansion{} // Equations of total space of miniversal deformation are in Js
deform_lib.tex(,181) @expansion{} -2AB+A3+3CD2-BC3-3AC2D+A2C3,
deform_lib.tex(,182) @expansion{} -B2+A2B+D3-3BC2D+ABC3
deform_lib.tex(,183) @expansion{} // Matrix of the deformed module is Ms and lifted syzygies are Ls.
deform_lib.tex(,184) @expansion{} // Make Qx the basering and list objects defined in Qx by typing:
deform_lib.tex(,185) @expansion{}    listvar(ring);setring Qx; show(Qx);listvar(ideal);listvar(matrix);
deform_lib.tex(,186) @expansion{} // NOTE: rings Qx, Ox, So are still alive!
deform_lib.tex(,187) @expansion{} // (use: 'kill_rings();' to remove them)
deform_lib.tex(,188) printlevel = p;
deform_lib.tex(,189) if(system("with","Namespaces")) @{
deform_lib.tex(,190) if(nameof(Current) == "Ring" ) @{
deform_lib.tex(,191) kill Top::Px,Top::Qx,Top::So;
deform_lib.tex(,192) @} else @{
deform_lib.tex(,193) kill Ring::Px,Ring::So;
deform_lib.tex(,194) @}
deform_lib.tex(,195) @}
deform_lib.tex(,196) kill Px,Qx,So;
deform_lib.tex(,197) @c end example mod_versal d2t_singular/deform_lib.doc:132
deform_lib.tex(,198) @end smallexample
deform_lib.tex(,199) @c ---end content mod_versal---
deform_lib.tex(,200) 
deform_lib.tex(,201) @c ------------------- lift_kbase -------------
deform_lib.tex(,202) @node lift_kbase, lift_rel_kb, mod_versal, deform_lib
deform_lib.tex(,203) @subsubsection lift_kbase
deform_lib.tex(,204) @cindex lift_kbase
deform_lib.tex(,205) @c ---content lift_kbase---
deform_lib.tex(,206) Procedure from library @code{deform.lib} (@pxref{deform_lib}).
deform_lib.tex(,207) 
deform_lib.tex(,208) @table @asis
deform_lib.tex(,209) @item @strong{Usage:}
deform_lib.tex(,210) lift_kbase(N,M); N,M=poly/ideal/vector/module
deform_lib.tex(,211) 
deform_lib.tex(,212) @item @strong{Return:}
deform_lib.tex(,213) matrix A, coefficient matrix expressing N as linear combination of
deform_lib.tex(,214) k-basis of M. Let the k-basis have k elements and size(N)=c columns.
deform_lib.tex(,215) Then A satisfies:
deform_lib.tex(,216) @*matrix(reduce(N,std(M)),k,c) = matrix(kbase(std(M)))*A
deform_lib.tex(,217) 
deform_lib.tex(,218) @item @strong{Assume:}
deform_lib.tex(,219) dim(M)=0 and the monomial ordering is a well ordering or the last
deform_lib.tex(,220) block of the ordering is c or C
deform_lib.tex(,221) 
deform_lib.tex(,222) @end table
deform_lib.tex(,223) @strong{Example:}
deform_lib.tex(,224) @smallexample
deform_lib.tex(,225) @c computed example lift_kbase d2t_singular/deform_lib.doc:177 
deform_lib.tex(,226) LIB "deform.lib";
deform_lib.tex(,227) ring R=0,(x,y),ds;
deform_lib.tex(,228) module M=[x2,xy],[y2,xy],[0,xx],[0,yy];
deform_lib.tex(,229) module N=[x3+xy,x],[x,x+y2];
deform_lib.tex(,230) print(M);
deform_lib.tex(,231) @expansion{} x2,y2,0, 0,
deform_lib.tex(,232) @expansion{} xy,xy,x2,y2
deform_lib.tex(,233) module kb=kbase(std(M));
deform_lib.tex(,234) print(kb);
deform_lib.tex(,235) @expansion{} y2,xy,y,x,1,0,0,0,
deform_lib.tex(,236) @expansion{} 0, 0, 0,0,0,y,x,1 
deform_lib.tex(,237) print(N);
deform_lib.tex(,238) @expansion{} xy+x3,x,  
deform_lib.tex(,239) @expansion{} x,    x+y2
deform_lib.tex(,240) matrix A=lift_kbase(N,M);
deform_lib.tex(,241) print(A);
deform_lib.tex(,242) @expansion{} 0,0,
deform_lib.tex(,243) @expansion{} 1,0,
deform_lib.tex(,244) @expansion{} 0,0,
deform_lib.tex(,245) @expansion{} 0,1,
deform_lib.tex(,246) @expansion{} 0,0,
deform_lib.tex(,247) @expansion{} 0,0,
deform_lib.tex(,248) @expansion{} 1,1,
deform_lib.tex(,249) @expansion{} 0,0 
deform_lib.tex(,250) matrix(reduce(N,std(M)),nrows(kb),ncols(A)) - matrix(kbase(std(M)))*A;
deform_lib.tex(,251) @expansion{} _[1,1]=0
deform_lib.tex(,252) @expansion{} _[1,2]=0
deform_lib.tex(,253) @expansion{} _[2,1]=0
deform_lib.tex(,254) @expansion{} _[2,2]=0
deform_lib.tex(,255) @c end example lift_kbase d2t_singular/deform_lib.doc:177
deform_lib.tex(,256) @end smallexample
deform_lib.tex(,257) @c ---end content lift_kbase---
deform_lib.tex(,258) 
deform_lib.tex(,259) @c ------------------- lift_rel_kb -------------
deform_lib.tex(,260) @node lift_rel_kb, kill_rings, lift_kbase, deform_lib
deform_lib.tex(,261) @subsubsection lift_rel_kb
deform_lib.tex(,262) @cindex lift_rel_kb
deform_lib.tex(,263) @c ---content lift_rel_kb---
deform_lib.tex(,264) Procedure from library @code{deform.lib} (@pxref{deform_lib}).
deform_lib.tex(,265) 
deform_lib.tex(,266) @table @asis
deform_lib.tex(,267) @item @strong{Usage:}
deform_lib.tex(,268) lift_rel_kb(N,M[,kbaseM,p]);
deform_lib.tex(,269) 
deform_lib.tex(,270) @item @strong{Assume:}
deform_lib.tex(,271) [p a monomial ] or the product of all variables
deform_lib.tex(,272) @*N, M modules of same rank, M depending only on variables not in p
deform_lib.tex(,273) and vdim(M) is finite in this ring,
deform_lib.tex(,274) @*[ kbaseM the kbase of M in the subring given by variables not in p ] @*
deform_lib.tex(,275) warning: these assumptions are not checked by the procedure
deform_lib.tex(,276) 
deform_lib.tex(,277) @item @strong{Return:}
deform_lib.tex(,278) matrix A, whose j-th columns present the coeff's of N[j] in kbaseM,
deform_lib.tex(,279) i.e. kbaseM*A = reduce(N,std(M))
deform_lib.tex(,280) 
deform_lib.tex(,281) @end table
deform_lib.tex(,282) @strong{Example:}
deform_lib.tex(,283) @smallexample
deform_lib.tex(,284) @c computed example lift_rel_kb d2t_singular/deform_lib.doc:218 
deform_lib.tex(,285) LIB "deform.lib";
deform_lib.tex(,286) ring r=0,(A,B,x,y),dp;
deform_lib.tex(,287) module M      = [x2,xy],[xy,y3],[y2],[0,x];
deform_lib.tex(,288) module kbaseM = [1],[x],[xy],[y],[0,1],[0,y],[0,y2];
deform_lib.tex(,289) poly f=xy;
deform_lib.tex(,290) module N = [AB,BBy],[A3xy+x4,AB*(1+y2)];
deform_lib.tex(,291) matrix A = lift_rel_kb(N,M,kbaseM,f);
deform_lib.tex(,292) print(A);
deform_lib.tex(,293) @expansion{} AB,0, 
deform_lib.tex(,294) @expansion{} 0, 0, 
deform_lib.tex(,295) @expansion{} 0, A3,
deform_lib.tex(,296) @expansion{} 0, 0, 
deform_lib.tex(,297) @expansion{} 0, AB,
deform_lib.tex(,298) @expansion{} B2,0, 
deform_lib.tex(,299) @expansion{} 0, AB 
deform_lib.tex(,300) "TEST:";
deform_lib.tex(,301) @expansion{} TEST:
deform_lib.tex(,302) print(matrix(kbaseM)*A-matrix(reduce(N,std(M))));
deform_lib.tex(,303) @expansion{} 0,0,
deform_lib.tex(,304) @expansion{} 0,0 
deform_lib.tex(,305) @c end example lift_rel_kb d2t_singular/deform_lib.doc:218
deform_lib.tex(,306) @end smallexample
deform_lib.tex(,307) @c ---end content lift_rel_kb---
deform_lib.tex(,308) 
deform_lib.tex(,309) @c ------------------- kill_rings -------------
deform_lib.tex(,310) @node kill_rings,, lift_rel_kb, deform_lib
deform_lib.tex(,311) @subsubsection kill_rings
deform_lib.tex(,312) @cindex kill_rings
deform_lib.tex(,313) @c ---content kill_rings---
deform_lib.tex(,314) Procedure from library @code{deform.lib} (@pxref{deform_lib}).
deform_lib.tex(,315) 
deform_lib.tex(,316) @table @asis
deform_lib.tex(,317) @item @strong{Usage:}
deform_lib.tex(,318) kill_rings([string]);
deform_lib.tex(,319) 
deform_lib.tex(,320) @item @strong{Return:}
deform_lib.tex(,321) nothing, but kills exported rings generated by procedures
deform_lib.tex(,322) 'versal' and 'mod_versal' with optional prefix 'string'
deform_lib.tex(,323) 
deform_lib.tex(,324) @end table
deform_lib.tex(,325) @c ---end content kill_rings---
singular.texi(,460) @c ----------------------------------------------------------
singular.texi(,461) @node equising_lib, gaussman_lib, deform_lib, Singularities
singular.texi(,462) @subsection equising_lib
singular.texi(,463) @c include of docu for equising.lib
equising_lib.tex(,1) @c ---content LibInfo---
equising_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/equising_lib.doc
equising_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/equising_lib.doc INSTEAD
equising_lib.tex(,4) @c library version: (1.7.2.6,2003/05/23)
equising_lib.tex(,5) @c library file: ../Singular/LIB/equising.lib
equising_lib.tex(,6) @cindex equising.lib
equising_lib.tex(,7) @cindex equising_lib
equising_lib.tex(,8) @table @asis
equising_lib.tex(,9) @item @strong{Library:}
equising_lib.tex(,10) equising.lib
equising_lib.tex(,11) @item @strong{Purpose:}
equising_lib.tex(,12)   Equisingularity Stratum of a Family of Plane Curves
equising_lib.tex(,13) @item @strong{Author:}
equising_lib.tex(,14) Christoph Lossen, lossen@@mathematik.uni-kl.de
equising_lib.tex(,15) @*Andrea Mindnich, mindnich@@mathematik.uni-kl.de
equising_lib.tex(,16) 
equising_lib.tex(,17) @end table
equising_lib.tex(,18) 
equising_lib.tex(,19) @strong{Main procedures:}
equising_lib.tex(,20) @menu
equising_lib.tex(,21) * tau_es:: codim of mu-const stratum in semi-universal def. base
equising_lib.tex(,22) * esIdeal:: (Wahl's) equisingularity ideal of f
equising_lib.tex(,23) * esStratum:: equisingularity stratum of a family F
equising_lib.tex(,24) * isEquising:: tests if a given deformation is equisingular
equising_lib.tex(,25) @end menu
equising_lib.tex(,26) @strong{Auxiliary procedure:}
equising_lib.tex(,27) @menu
equising_lib.tex(,28) * control_Matrix:: computes list of blowing-up data
equising_lib.tex(,29) @end menu
equising_lib.tex(,30) @c ---end content LibInfo---
equising_lib.tex(,31) 
equising_lib.tex(,32) @c ------------------- tau_es -------------
equising_lib.tex(,33) @node tau_es, esIdeal,, equising_lib
equising_lib.tex(,34) @subsubsection tau_es
equising_lib.tex(,35) @cindex tau_es
equising_lib.tex(,36) @c ---content tau_es---
equising_lib.tex(,37) Procedure from library @code{equising.lib} (@pxref{equising_lib}).
equising_lib.tex(,38) 
equising_lib.tex(,39) @table @asis
equising_lib.tex(,40) @item @strong{Usage:}
equising_lib.tex(,41) tau_es(f); f poly
equising_lib.tex(,42) 
equising_lib.tex(,43) @item @strong{Assume:}
equising_lib.tex(,44) f is a reduced bivariate polynomial, the basering has precisely
equising_lib.tex(,45) two variables, is local and no qring.
equising_lib.tex(,46) 
equising_lib.tex(,47) @item @strong{Return:}
equising_lib.tex(,48) int, the codimension of the mu-const stratum in the semi-universal
equising_lib.tex(,49) deformation base.
equising_lib.tex(,50) 
equising_lib.tex(,51) @item @strong{Note:}
equising_lib.tex(,52) printlevel>=1 displays additional information.
equising_lib.tex(,53) @*When called with any additional parameter, the computation of the
equising_lib.tex(,54) Milnor number is avoided (no check for NND).
equising_lib.tex(,55) 
equising_lib.tex(,56) @end table
equising_lib.tex(,57) @strong{Example:}
equising_lib.tex(,58) @smallexample
equising_lib.tex(,59) @c reused example tau_es d2t_singular/equising_lib.doc:57 
equising_lib.tex(,60) LIB "equising.lib";
equising_lib.tex(,61) ring r=32003,(x,y),ds;
equising_lib.tex(,62) poly f=(x4-y4)^2-x10;
equising_lib.tex(,63) tau_es(f);
equising_lib.tex(,64) @expansion{} 42
equising_lib.tex(,65) @c end example tau_es d2t_singular/equising_lib.doc:57
equising_lib.tex(,66) @end smallexample
equising_lib.tex(,67) @c inserted refs from d2t_singular/equising_lib.doc:64
equising_lib.tex(,82) @c end inserted refs from d2t_singular/equising_lib.doc:64
equising_lib.tex(,83) 
equising_lib.tex(,84) @c ---end content tau_es---
equising_lib.tex(,85) 
equising_lib.tex(,86) @c ------------------- esIdeal -------------
equising_lib.tex(,87) @node esIdeal, esStratum, tau_es, equising_lib
equising_lib.tex(,88) @subsubsection esIdeal
equising_lib.tex(,89) @cindex esIdeal
equising_lib.tex(,90) @c ---content esIdeal---
equising_lib.tex(,91) Procedure from library @code{equising.lib} (@pxref{equising_lib}).
equising_lib.tex(,92) 
equising_lib.tex(,93) @table @asis
equising_lib.tex(,94) @item @strong{Usage:}
equising_lib.tex(,95) esIdeal(f); f poly
equising_lib.tex(,96) 
equising_lib.tex(,97) @item @strong{Assume:}
equising_lib.tex(,98) f is a reduced bivariate polynomial, the basering has precisely
equising_lib.tex(,99) two variables, is local and no qring, and the characteristic of
equising_lib.tex(,100) the ground field does not divide mult(f).
equising_lib.tex(,101) 
equising_lib.tex(,102) @item @strong{Return:}
equising_lib.tex(,103) list of two ideals:
equising_lib.tex(,104) @format
equising_lib.tex(,105)           _[1]:  equisingularity ideal of f (in sense of Wahl)
equising_lib.tex(,106)           _[2]:  equisingularity ideal of f with fixed section
equising_lib.tex(,107) @end format
equising_lib.tex(,108) 
equising_lib.tex(,109) @item @strong{Note:}
equising_lib.tex(,110) if some of the above condition is not satisfied then return
equising_lib.tex(,111) value is list(0,0).
equising_lib.tex(,112) 
equising_lib.tex(,113) @cindex equisingularity ideal
equising_lib.tex(,114) @end table
equising_lib.tex(,115) @strong{Example:}
equising_lib.tex(,116) @smallexample
equising_lib.tex(,117) @c computed example esIdeal d2t_singular/equising_lib.doc:101 
equising_lib.tex(,118) LIB "equising.lib";
equising_lib.tex(,119) ring r=0,(x,y),ds;
equising_lib.tex(,120) poly f=x7+y7+(x-y)^2*x2y2; 
equising_lib.tex(,121) list K=esIdeal(f);
equising_lib.tex(,122) @expansion{} polynomial is Newton degenerated !
equising_lib.tex(,123) @expansion{} 
equising_lib.tex(,124) @expansion{} // 
equising_lib.tex(,125) @expansion{} // versal deformation with triv. section
equising_lib.tex(,126) @expansion{} // =====================================
equising_lib.tex(,127) @expansion{} // 
equising_lib.tex(,128) @expansion{} // 
equising_lib.tex(,129) @expansion{} // Compute equisingular Stratum over Spec(C[t]/t^2)
equising_lib.tex(,130) @expansion{} // ================================================
equising_lib.tex(,131) @expansion{} // 
equising_lib.tex(,132) @expansion{} // finished
equising_lib.tex(,133) @expansion{} // 
equising_lib.tex(,134) option(redSB);
equising_lib.tex(,135) // Wahl's equisingularity ideal:
equising_lib.tex(,136) std(K[1]);
equising_lib.tex(,137) @expansion{} _[1]=4x4y-10x2y3+6xy4+21x6+14y6
equising_lib.tex(,138) @expansion{} _[2]=4x3y2-6x2y3+2xy4+7x6
equising_lib.tex(,139) @expansion{} _[3]=x2y4-xy5
equising_lib.tex(,140) @expansion{} _[4]=x7
equising_lib.tex(,141) @expansion{} _[5]=xy6
equising_lib.tex(,142) @expansion{} _[6]=y7
equising_lib.tex(,143) ring rr=0,(x,y),ds;
equising_lib.tex(,144) poly f=x4+4x3y+6x2y2+4xy3+y4+2x2y15+4xy16+2y17+xy23+y24+y30+y31;
equising_lib.tex(,145) list K=esIdeal(f);
equising_lib.tex(,146) @expansion{} polynomial is Newton degenerated !
equising_lib.tex(,147) @expansion{} 
equising_lib.tex(,148) @expansion{} // 
equising_lib.tex(,149) @expansion{} // versal deformation with triv. section
equising_lib.tex(,150) @expansion{} // =====================================
equising_lib.tex(,151) @expansion{} // 
equising_lib.tex(,152) @expansion{} // 
equising_lib.tex(,153) @expansion{} // Compute equisingular Stratum over Spec(C[t]/t^2)
equising_lib.tex(,154) @expansion{} // ================================================
equising_lib.tex(,155) @expansion{} // 
equising_lib.tex(,156) @expansion{} // finished
equising_lib.tex(,157) @expansion{} // 
equising_lib.tex(,158) vdim(std(K[1]));
equising_lib.tex(,159) @expansion{} 68
equising_lib.tex(,160) // the latter should be equal to: 
equising_lib.tex(,161) tau_es(f);
equising_lib.tex(,162) @expansion{} 68
equising_lib.tex(,163) @c end example esIdeal d2t_singular/equising_lib.doc:101
equising_lib.tex(,164) @end smallexample
equising_lib.tex(,165) @c inserted refs from d2t_singular/equising_lib.doc:117
equising_lib.tex(,178) @c end inserted refs from d2t_singular/equising_lib.doc:117
equising_lib.tex(,179) 
equising_lib.tex(,180) @c ---end content esIdeal---
equising_lib.tex(,181) 
equising_lib.tex(,182) @c ------------------- esStratum -------------
equising_lib.tex(,183) @node esStratum, isEquising, esIdeal, equising_lib
equising_lib.tex(,184) @subsubsection esStratum
equising_lib.tex(,185) @cindex esStratum
equising_lib.tex(,186) @c ---content esStratum---
equising_lib.tex(,187) Procedure from library @code{equising.lib} (@pxref{equising_lib}).
equising_lib.tex(,188) 
equising_lib.tex(,189) @table @asis
equising_lib.tex(,190) @item @strong{Usage:}
equising_lib.tex(,191) esStratum(F[,m,L]); F poly, m int, L list
equising_lib.tex(,192) 
equising_lib.tex(,193) @item @strong{Assume:}
equising_lib.tex(,194) F defines a deformation of a reduced bivariate polynomial f
equising_lib.tex(,195) and the characteristic of the basering does not divide mult(f). @*
equising_lib.tex(,196) If nv is the number of variables of the basering, then the first
equising_lib.tex(,197) nv-2 variables are the deformation parameters. @*
equising_lib.tex(,198) If the basering is a qring, ideal(basering) must only depend
equising_lib.tex(,199) on the deformation parameters.
equising_lib.tex(,200) 
equising_lib.tex(,201) @item @strong{Compute:}
equising_lib.tex(,202) equations for the stratum of equisingular deformations with 
equising_lib.tex(,203) fixed (trivial) section.
equising_lib.tex(,204) 
equising_lib.tex(,205) @item @strong{Return:}
equising_lib.tex(,206) list l: either consisting of an ideal and an integer, where
equising_lib.tex(,207) @format
equising_lib.tex(,208)   l[1]=ideal defining the equisingular stratum
equising_lib.tex(,209)   l[2]=1 if some error has occured,  l[2]=0 otherwise;
equising_lib.tex(,210) @end format
equising_lib.tex(,211) or consisting of a ring and an integer, where
equising_lib.tex(,212) @format
equising_lib.tex(,213)   l[1]=ESSring is a ring extension of basering containing the ideal ES 
equising_lib.tex(,214)         (describing the ES-stratum) and the poly p_F=F,
equising_lib.tex(,215)   l[2]=1 if some error has occured,  l[2]=0 otherwise.
equising_lib.tex(,216) @end format
equising_lib.tex(,217) 
equising_lib.tex(,218) @item @strong{Note:}
equising_lib.tex(,219) L is supposed to be the output of reddevelop (with the given ordering
equising_lib.tex(,220) of the variables appearing in f). @*
equising_lib.tex(,221) If m is given, the ES Stratum over A/maxideal(m) is computed. @*
equising_lib.tex(,222) This procedure uses @code{execute} or calls a procedure using
equising_lib.tex(,223) @code{execute}.
equising_lib.tex(,224) printlevel>=2 displays additional information.
equising_lib.tex(,225) 
equising_lib.tex(,226) @cindex equisingular stratum
equising_lib.tex(,227) @end table
equising_lib.tex(,228) @strong{Example:}
equising_lib.tex(,229) @smallexample
equising_lib.tex(,230) @c reused example esStratum d2t_singular/equising_lib.doc:171 
equising_lib.tex(,231) LIB "equising.lib";
equising_lib.tex(,232) int p=printlevel; 
equising_lib.tex(,233) printlevel=1;
equising_lib.tex(,234) ring r = 0,(a,b,c,d,e,f,g,x,y),ds;
equising_lib.tex(,235) poly F = (x2+2xy+y2+x5)+ax+by+cx2+dxy+ey2+fx3+gx4;
equising_lib.tex(,236) list M = esStratum(F);
equising_lib.tex(,237) M[1];
equising_lib.tex(,238) @expansion{} _[1]=g
equising_lib.tex(,239) @expansion{} _[2]=f
equising_lib.tex(,240) @expansion{} _[3]=b
equising_lib.tex(,241) @expansion{} _[4]=a
equising_lib.tex(,242) @expansion{} _[5]=-4c+4d-4e+d2-4ce
equising_lib.tex(,243) printlevel=3;    // displays additional information
equising_lib.tex(,244) esStratum(F,2);  // es stratum over Q[a,b,c,d,e,f,g] / <a,b,c,d,e,f,g>^2
equising_lib.tex(,245) @expansion{} // 
equising_lib.tex(,246) @expansion{} // Compute HN development
equising_lib.tex(,247) @expansion{} // ----------------------
equising_lib.tex(,248) @expansion{} // finished
equising_lib.tex(,249) @expansion{} // 
equising_lib.tex(,250) @expansion{} // Blowup Step 1 completed
equising_lib.tex(,251) @expansion{} // Blowup Step 2 completed
equising_lib.tex(,252) @expansion{} // Blowup Step 3 completed
equising_lib.tex(,253) @expansion{} // 1 branch finished
equising_lib.tex(,254) @expansion{} // 
equising_lib.tex(,255) @expansion{} // Elimination starts:
equising_lib.tex(,256) @expansion{} // -------------------
equising_lib.tex(,257) @expansion{} // finished
equising_lib.tex(,258) @expansion{} // 
equising_lib.tex(,259) @expansion{} // output of 'esStratum' is list consisting of:
equising_lib.tex(,260) @expansion{} //    _[1] = ideal defining equisingular stratum
equising_lib.tex(,261) @expansion{} //    _[2] = 0
equising_lib.tex(,262) @expansion{} [1]:
equising_lib.tex(,263) @expansion{}    _[1]=b
equising_lib.tex(,264) @expansion{}    _[2]=a
equising_lib.tex(,265) @expansion{}    _[3]=c-d+e
equising_lib.tex(,266) @expansion{}    _[4]=g
equising_lib.tex(,267) @expansion{}    _[5]=f
equising_lib.tex(,268) @expansion{} [2]:
equising_lib.tex(,269) @expansion{}    0
equising_lib.tex(,270) ideal I = f-fa,e+b;
equising_lib.tex(,271) qring q = std(I);
equising_lib.tex(,272) poly F = imap(r,F);
equising_lib.tex(,273) esStratum(F);
equising_lib.tex(,274) @expansion{} // 
equising_lib.tex(,275) @expansion{} // Compute HN development
equising_lib.tex(,276) @expansion{} // ----------------------
equising_lib.tex(,277) @expansion{} // finished
equising_lib.tex(,278) @expansion{} // 
equising_lib.tex(,279) @expansion{} // Blowup Step 1 completed
equising_lib.tex(,280) @expansion{} // Blowup Step 2 completed
equising_lib.tex(,281) @expansion{} // Blowup Step 3 completed
equising_lib.tex(,282) @expansion{} // 1 branch finished
equising_lib.tex(,283) @expansion{} // 
equising_lib.tex(,284) @expansion{} // Elimination starts:
equising_lib.tex(,285) @expansion{} // -------------------
equising_lib.tex(,286) @expansion{} // finished
equising_lib.tex(,287) @expansion{} // 
equising_lib.tex(,288) @expansion{} // output of 'esStratum' is list consisting of:
equising_lib.tex(,289) @expansion{} //    _[1] = ideal defining equisingular stratum
equising_lib.tex(,290) @expansion{} //    _[2] = 0
equising_lib.tex(,291) @expansion{} [1]:
equising_lib.tex(,292) @expansion{}    _[1]=e
equising_lib.tex(,293) @expansion{}    _[2]=a
equising_lib.tex(,294) @expansion{}    _[3]=-4c+4d+d2
equising_lib.tex(,295) @expansion{}    _[4]=g
equising_lib.tex(,296) @expansion{} [2]:
equising_lib.tex(,297) @expansion{}    0
equising_lib.tex(,298) printlevel=p;
equising_lib.tex(,299) @c end example esStratum d2t_singular/equising_lib.doc:171
equising_lib.tex(,300) @end smallexample
equising_lib.tex(,301) @c inserted refs from d2t_singular/equising_lib.doc:188
equising_lib.tex(,314) @c end inserted refs from d2t_singular/equising_lib.doc:188
equising_lib.tex(,315) 
equising_lib.tex(,316) @c ---end content esStratum---
equising_lib.tex(,317) 
equising_lib.tex(,318) @c ------------------- isEquising -------------
equising_lib.tex(,319) @node isEquising, control_Matrix, esStratum, equising_lib
equising_lib.tex(,320) @subsubsection isEquising
equising_lib.tex(,321) @cindex isEquising
equising_lib.tex(,322) @c ---content isEquising---
equising_lib.tex(,323) Procedure from library @code{equising.lib} (@pxref{equising_lib}).
equising_lib.tex(,324) 
equising_lib.tex(,325) @table @asis
equising_lib.tex(,326) @item @strong{Usage:}
equising_lib.tex(,327) isEquising(F[,m,L]); F poly, m int, L list
equising_lib.tex(,328) 
equising_lib.tex(,329) @item @strong{Assume:}
equising_lib.tex(,330) F defines a deformation of a reduced bivariate polynomial f
equising_lib.tex(,331) and the characteristic of the basering does not divide mult(f). @*
equising_lib.tex(,332) If nv is the number of variables of the basering, then the first
equising_lib.tex(,333) nv-2 variables are the deformation parameters. @*
equising_lib.tex(,334) If the basering is a qring, ideal(basering) must only depend
equising_lib.tex(,335) on the deformation parameters.
equising_lib.tex(,336) 
equising_lib.tex(,337) @item @strong{Compute:}
equising_lib.tex(,338) tests if the given family is equisingular along the trivial
equising_lib.tex(,339) section.
equising_lib.tex(,340) 
equising_lib.tex(,341) @item @strong{Return:}
equising_lib.tex(,342) int: 1 if the family is equisingular, 0 otherwise.
equising_lib.tex(,343) 
equising_lib.tex(,344) @item @strong{Note:}
equising_lib.tex(,345) L is supposed to be the output of reddevelop (with the given ordering
equising_lib.tex(,346) of the variables appearing in f). @*
equising_lib.tex(,347) If m is given, the family is considered over A/maxideal(m). @*
equising_lib.tex(,348) This procedure uses @code{execute} or calls a procedure using
equising_lib.tex(,349) @code{execute}.
equising_lib.tex(,350) printlevel>=2 displays additional information.
equising_lib.tex(,351) 
equising_lib.tex(,352) @end table
equising_lib.tex(,353) @strong{Example:}
equising_lib.tex(,354) @smallexample
equising_lib.tex(,355) @c reused example isEquising d2t_singular/equising_lib.doc:231 
equising_lib.tex(,356) LIB "equising.lib";
equising_lib.tex(,357) ring r = 0,(a,b,x,y),ds;
equising_lib.tex(,358) poly F = (x2+2xy+y2+x5)+ay3+bx5;
equising_lib.tex(,359) isEquising(F);
equising_lib.tex(,360) @expansion{} 0
equising_lib.tex(,361) ideal I = ideal(a);
equising_lib.tex(,362) qring q = std(I);
equising_lib.tex(,363) poly F = imap(r,F);
equising_lib.tex(,364) isEquising(F);
equising_lib.tex(,365) @expansion{} 1
equising_lib.tex(,366) ring rr=0,(A,B,C,x,y),ls;
equising_lib.tex(,367) poly f=x7+y7+(x-y)^2*x2y2;
equising_lib.tex(,368) poly F=f+A*y*diff(f,x)+B*x*diff(f,x);
equising_lib.tex(,369) isEquising(F);  
equising_lib.tex(,370) @expansion{} 0
equising_lib.tex(,371) isEquising(F,2);    // computation over  Q[a,b] / <a,b>^2
equising_lib.tex(,372) @expansion{} 1
equising_lib.tex(,373) @c end example isEquising d2t_singular/equising_lib.doc:231
equising_lib.tex(,374) @end smallexample
equising_lib.tex(,375) @c ---end content isEquising---
equising_lib.tex(,376) 
equising_lib.tex(,377) @c ------------------- control_Matrix -------------
equising_lib.tex(,378) @node control_Matrix,, isEquising, equising_lib
equising_lib.tex(,379) @subsubsection control_Matrix
equising_lib.tex(,380) @cindex control_Matrix
equising_lib.tex(,381) @c ---content control_Matrix---
equising_lib.tex(,382) Procedure from library @code{equising.lib} (@pxref{equising_lib}).
equising_lib.tex(,383) 
equising_lib.tex(,384) @table @asis
equising_lib.tex(,385) @item @strong{Assume:}
equising_lib.tex(,386) L is the output of multsequence(reddevelop(f)).
equising_lib.tex(,387) 
equising_lib.tex(,388) @item @strong{Return:}
equising_lib.tex(,389) list M of 4 intmat's:
equising_lib.tex(,390) @format
equising_lib.tex(,391)   M[1] contains the multiplicities at the respective infinitely near points 
equising_lib.tex(,392)        p[i,j] (i=step of blowup+1, j=branch) -- if branches j=k,...,k+m pass 
equising_lib.tex(,393)        through the same p[i,j] then the multiplicity is stored in M[1][k,j], 
equising_lib.tex(,394)        while M[1][k+1]=...=M[1][k+m]=0.   
equising_lib.tex(,395)   M[2] contains the number of branches meeting at p[i,j] (again, the information 
equising_lib.tex(,396)        is stored according to the above rule)   
equising_lib.tex(,397)   M[3] contains the information about the splitting of M[1][i,j] with respect to 
equising_lib.tex(,398)        different tangents of branches at p[i,j] (information is stored only for 
equising_lib.tex(,399)        minimal j>=k corresponding to a new tangent direction). 
equising_lib.tex(,400)        The entries are the sum of multiplicities of all branches with the 
equising_lib.tex(,401)        respective tangent.
equising_lib.tex(,402)   M[4] contains the maximal sum of higher multiplicities for a branch passing 
equising_lib.tex(,403)        through p[i,j] ( = degree Bound for blowing up)  
equising_lib.tex(,404) @end format
equising_lib.tex(,405) 
equising_lib.tex(,406) @item @strong{Note:}
equising_lib.tex(,407) the branches are ordered in such a way that only consecutive branches
equising_lib.tex(,408) can meet at an infinitely near point. @*
equising_lib.tex(,409) the final rows of the matrices M[1],...,M[3] is (1,1,1,...,1), and
equising_lib.tex(,410) correspond to infinitely near points such that the strict transforms
equising_lib.tex(,411) of the branches are smooth and intersect the exceptional divisor
equising_lib.tex(,412) transversally.
equising_lib.tex(,413) 
equising_lib.tex(,414) @end table
equising_lib.tex(,415) @c inserted refs from d2t_singular/equising_lib.doc:287
equising_lib.tex(,426) @c end inserted refs from d2t_singular/equising_lib.doc:287
equising_lib.tex(,427) 
equising_lib.tex(,428) @c ---end content control_Matrix---
singular.texi(,465) @c ----------------------------------------------------------
singular.texi(,466) @node gaussman_lib, hnoether_lib, equising_lib, Singularities
singular.texi(,467) @subsection gaussman_lib
singular.texi(,468) @c include of docu for gaussman.lib
gaussman_lib.tex(,1) @c ---content LibInfo---
gaussman_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/gaussman_lib.doc
gaussman_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/gaussman_lib.doc INSTEAD
gaussman_lib.tex(,4) @c library version: (1.33.2.26,2003/02/10)
gaussman_lib.tex(,5) @c library file: ../Singular/LIB/gaussman.lib
gaussman_lib.tex(,6) @cindex gaussman.lib
gaussman_lib.tex(,7) @cindex gaussman_lib
gaussman_lib.tex(,8) @table @asis
gaussman_lib.tex(,9) @item @strong{Library:}
gaussman_lib.tex(,10) gaussman.lib
gaussman_lib.tex(,11) @item @strong{Purpose:}
gaussman_lib.tex(,12)   Algorithmic Gauss-Manin Connection
gaussman_lib.tex(,13) 
gaussman_lib.tex(,14) @item @strong{Author:}
gaussman_lib.tex(,15) Mathias Schulze, email: mschulze@@mathematik.uni-kl.de
gaussman_lib.tex(,16) 
gaussman_lib.tex(,17) @item @strong{Overview:}
gaussman_lib.tex(,18) A library to compute Hodge-theoretic invariants
gaussman_lib.tex(,19) @*of isolated hypersurface singularities
gaussman_lib.tex(,20) 
gaussman_lib.tex(,21) @end table
gaussman_lib.tex(,22) 
gaussman_lib.tex(,23) @strong{Procedures:}
gaussman_lib.tex(,24) @menu
gaussman_lib.tex(,25) * gmsring:: Gauss-Manin system of t with variable s
gaussman_lib.tex(,26) * gmsnf:: Gauss-Manin normal form of p
gaussman_lib.tex(,27) * gmscoeffs:: Gauss-Manin basis representation of p
gaussman_lib.tex(,28) * bernstein:: roots of the Bernstein polynomial of t
gaussman_lib.tex(,29) * monodromy:: Jordan data of complex monodromy of t
gaussman_lib.tex(,30) * spectrum:: singularity spectrum of t
gaussman_lib.tex(,31) * sppairs:: spectral pairs of t
gaussman_lib.tex(,32) * spnf:: spectrum normal form of (a,m,V)
gaussman_lib.tex(,33) * sppnf:: spectral pairs normal form of (a,w,m,V)
gaussman_lib.tex(,34) * vfilt:: V-filtration of t on Brieskorn lattice
gaussman_lib.tex(,35) * vwfilt:: weighted V-filtration of t on Brieskorn lattice
gaussman_lib.tex(,36) * tmatrix:: C[[s]]-matrix of t on Brieskorn lattice
gaussman_lib.tex(,37) * endvfilt:: endomorphism V-filtration on Jacobian algebra
gaussman_lib.tex(,38) * spprint:: print spectrum sp
gaussman_lib.tex(,39) * sppprint:: print spectral pairs spp
gaussman_lib.tex(,40) * spadd:: sum of spectra sp1 and sp2
gaussman_lib.tex(,41) * spsub:: difference of spectra sp1 and sp2
gaussman_lib.tex(,42) * spmul:: linear combination of spectra sp
gaussman_lib.tex(,43) * spissemicont:: semicontinuity test of spectrum sp
gaussman_lib.tex(,44) * spsemicont:: semicontinuous combinations of spectra sp0 in sp
gaussman_lib.tex(,45) * spmilnor:: Milnor number of spectrum sp
gaussman_lib.tex(,46) * spgeomgenus:: geometrical genus of spectrum sp
gaussman_lib.tex(,47) * spgamma:: gamma invariant of spectrum sp
gaussman_lib.tex(,48) @end menu
gaussman_lib.tex(,49) @cindex singularities
gaussman_lib.tex(,50) @cindex Gauss-Manin connection
gaussman_lib.tex(,51) @cindex Brieskorn lattice
gaussman_lib.tex(,52) @cindex monodromy
gaussman_lib.tex(,53) @cindex spectrum
gaussman_lib.tex(,54) @cindex spectral pairs
gaussman_lib.tex(,55) @cindex mixed Hodge structure
gaussman_lib.tex(,56) @cindex V-filtration
gaussman_lib.tex(,57) @cindex weight filtration
gaussman_lib.tex(,58) @c inserted refs from d2t_singular/gaussman_lib.doc:56
gaussman_lib.tex(,71) @c end inserted refs from d2t_singular/gaussman_lib.doc:56
gaussman_lib.tex(,72) 
gaussman_lib.tex(,73) @c ---end content LibInfo---
gaussman_lib.tex(,74) 
gaussman_lib.tex(,75) @c ------------------- gmsring -------------
gaussman_lib.tex(,76) @node gmsring, gmsnf,, gaussman_lib
gaussman_lib.tex(,77) @subsubsection gmsring
gaussman_lib.tex(,78) @cindex gmsring
gaussman_lib.tex(,79) @c ---content gmsring---
gaussman_lib.tex(,80) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,81) 
gaussman_lib.tex(,82) @table @asis
gaussman_lib.tex(,83) @item @strong{Usage:}
gaussman_lib.tex(,84) gmsring(t,s); poly t, string s
gaussman_lib.tex(,85) 
gaussman_lib.tex(,86) @item @strong{Assume:}
gaussman_lib.tex(,87) characteristic 0; local degree ordering;
gaussman_lib.tex(,88) @*isolated critical point 0 of t
gaussman_lib.tex(,89) 
gaussman_lib.tex(,90) @item @strong{Return:}
gaussman_lib.tex(,91) @format
gaussman_lib.tex(,92) ring G;  Gauss-Manin system of t with variable s
gaussman_lib.tex(,93)   poly gmspoly=t;
gaussman_lib.tex(,94)   ideal gmsjacob;  Jacobian ideal of t
gaussman_lib.tex(,95)   ideal gmsstd;  standard basis of Jacobian ideal
gaussman_lib.tex(,96)   matrix gmsmatrix;  matrix(gmsjacob)*gmsmatrix==matrix(gmsstd)
gaussman_lib.tex(,97)   ideal gmsbasis;  monomial vector space basis of Jacobian algebra
gaussman_lib.tex(,98)   int gmsmaxdeg;  maximal weight of variables
gaussman_lib.tex(,99) @end format
gaussman_lib.tex(,100) 
gaussman_lib.tex(,101) @item @strong{Note:}
gaussman_lib.tex(,102) gmsbasis is a C[[s]]-basis of H'' and [t,s]=s^2
gaussman_lib.tex(,103) 
gaussman_lib.tex(,104) @cindex singularities
gaussman_lib.tex(,105) @cindex Gauss-Manin connection
gaussman_lib.tex(,106) @cindex Brieskorn lattice
gaussman_lib.tex(,107) @end table
gaussman_lib.tex(,108) @strong{Example:}
gaussman_lib.tex(,109) @smallexample
gaussman_lib.tex(,110) @c computed example gmsring d2t_singular/gaussman_lib.doc:97 
gaussman_lib.tex(,111) LIB "gaussman.lib";
gaussman_lib.tex(,112) ring R=0,(x,y),ds;
gaussman_lib.tex(,113) poly t=x5+x2y2+y5;
gaussman_lib.tex(,114) def G=gmsring(t,"s");
gaussman_lib.tex(,115) setring(G);
gaussman_lib.tex(,116) gmspoly;
gaussman_lib.tex(,117) @expansion{} x2y2+x5+y5
gaussman_lib.tex(,118) print(gmsjacob);
gaussman_lib.tex(,119) @expansion{} 2xy2+5x4,
gaussman_lib.tex(,120) @expansion{} 2x2y+5y4
gaussman_lib.tex(,121) print(gmsstd);
gaussman_lib.tex(,122) @expansion{} 2x2y+5y4,
gaussman_lib.tex(,123) @expansion{} 2xy2+5x4,
gaussman_lib.tex(,124) @expansion{} 5x5-5y5,
gaussman_lib.tex(,125) @expansion{} 10y6+25x3y4
gaussman_lib.tex(,126) print(gmsmatrix);
gaussman_lib.tex(,127) @expansion{} 0,1,x, -2xy,  
gaussman_lib.tex(,128) @expansion{} 1,0,-y,2y2+5x3
gaussman_lib.tex(,129) print(gmsbasis);
gaussman_lib.tex(,130) @expansion{} y5,
gaussman_lib.tex(,131) @expansion{} y4,
gaussman_lib.tex(,132) @expansion{} y3,
gaussman_lib.tex(,133) @expansion{} y2,
gaussman_lib.tex(,134) @expansion{} xy,
gaussman_lib.tex(,135) @expansion{} y,
gaussman_lib.tex(,136) @expansion{} x4,
gaussman_lib.tex(,137) @expansion{} x3,
gaussman_lib.tex(,138) @expansion{} x2,
gaussman_lib.tex(,139) @expansion{} x,
gaussman_lib.tex(,140) @expansion{} 1
gaussman_lib.tex(,141) gmsmaxdeg;
gaussman_lib.tex(,142) @expansion{} 1
gaussman_lib.tex(,143) @c end example gmsring d2t_singular/gaussman_lib.doc:97
gaussman_lib.tex(,144) @end smallexample
gaussman_lib.tex(,145) @c ---end content gmsring---
gaussman_lib.tex(,146) 
gaussman_lib.tex(,147) @c ------------------- gmsnf -------------
gaussman_lib.tex(,148) @node gmsnf, gmscoeffs, gmsring, gaussman_lib
gaussman_lib.tex(,149) @subsubsection gmsnf
gaussman_lib.tex(,150) @cindex gmsnf
gaussman_lib.tex(,151) @c ---content gmsnf---
gaussman_lib.tex(,152) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,153) 
gaussman_lib.tex(,154) @table @asis
gaussman_lib.tex(,155) @item @strong{Usage:}
gaussman_lib.tex(,156) gmsnf(p,K); poly p, int K
gaussman_lib.tex(,157) 
gaussman_lib.tex(,158) @item @strong{Assume:}
gaussman_lib.tex(,159) basering returned by gmsring
gaussman_lib.tex(,160) 
gaussman_lib.tex(,161) @item @strong{Return:}
gaussman_lib.tex(,162) @format
gaussman_lib.tex(,163) list nf;
gaussman_lib.tex(,164)   ideal nf[1];  projection of p to <gmsbasis>C[[s]] mod s^(K+1)
gaussman_lib.tex(,165)   ideal nf[2];  p==nf[1]+nf[2]
gaussman_lib.tex(,166) @end format
gaussman_lib.tex(,167) 
gaussman_lib.tex(,168) @item @strong{Note:}
gaussman_lib.tex(,169) computation can be continued by setting p=nf[2]
gaussman_lib.tex(,170) 
gaussman_lib.tex(,171) @cindex singularities
gaussman_lib.tex(,172) @cindex Gauss-Manin connection
gaussman_lib.tex(,173) @cindex Brieskorn lattice
gaussman_lib.tex(,174) @end table
gaussman_lib.tex(,175) @strong{Example:}
gaussman_lib.tex(,176) @smallexample
gaussman_lib.tex(,177) @c computed example gmsnf d2t_singular/gaussman_lib.doc:143 
gaussman_lib.tex(,178) LIB "gaussman.lib";
gaussman_lib.tex(,179) ring R=0,(x,y),ds;
gaussman_lib.tex(,180) poly t=x5+x2y2+y5;
gaussman_lib.tex(,181) def G=gmsring(t,"s");
gaussman_lib.tex(,182) setring(G);
gaussman_lib.tex(,183) list l0=gmsnf(gmspoly,0);
gaussman_lib.tex(,184) print(l0[1]);
gaussman_lib.tex(,185) @expansion{} -1/2y5
gaussman_lib.tex(,186) list l1=gmsnf(gmspoly,1);
gaussman_lib.tex(,187) print(l1[1]);
gaussman_lib.tex(,188) @expansion{} -1/2y5+1/2s
gaussman_lib.tex(,189) list l=gmsnf(l0[2],1);
gaussman_lib.tex(,190) print(l[1]);
gaussman_lib.tex(,191) @expansion{} 1/2s
gaussman_lib.tex(,192) @c end example gmsnf d2t_singular/gaussman_lib.doc:143
gaussman_lib.tex(,193) @end smallexample
gaussman_lib.tex(,194) @c ---end content gmsnf---
gaussman_lib.tex(,195) 
gaussman_lib.tex(,196) @c ------------------- gmscoeffs -------------
gaussman_lib.tex(,197) @node gmscoeffs, bernstein, gmsnf, gaussman_lib
gaussman_lib.tex(,198) @subsubsection gmscoeffs
gaussman_lib.tex(,199) @cindex gmscoeffs
gaussman_lib.tex(,200) @c ---content gmscoeffs---
gaussman_lib.tex(,201) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,202) 
gaussman_lib.tex(,203) @table @asis
gaussman_lib.tex(,204) @item @strong{Usage:}
gaussman_lib.tex(,205) gmscoeffs(p,K); poly p, int K
gaussman_lib.tex(,206) 
gaussman_lib.tex(,207) @item @strong{Assume:}
gaussman_lib.tex(,208) basering constructed by gmsring
gaussman_lib.tex(,209) 
gaussman_lib.tex(,210) @item @strong{Return:}
gaussman_lib.tex(,211) @format
gaussman_lib.tex(,212) list l;
gaussman_lib.tex(,213)   matrix l[1];  C[[s]]-basis representation of p mod s^(K+1)
gaussman_lib.tex(,214)   ideal l[2];  p==matrix(gmsbasis)*l[1]+l[2]
gaussman_lib.tex(,215) @end format
gaussman_lib.tex(,216) 
gaussman_lib.tex(,217) @item @strong{Note:}
gaussman_lib.tex(,218) computation can be continued by setting p=l[2]
gaussman_lib.tex(,219) 
gaussman_lib.tex(,220) @cindex singularities
gaussman_lib.tex(,221) @cindex Gauss-Manin connection
gaussman_lib.tex(,222) @cindex Brieskorn lattice
gaussman_lib.tex(,223) @end table
gaussman_lib.tex(,224) @strong{Example:}
gaussman_lib.tex(,225) @smallexample
gaussman_lib.tex(,226) @c computed example gmscoeffs d2t_singular/gaussman_lib.doc:189 
gaussman_lib.tex(,227) LIB "gaussman.lib";
gaussman_lib.tex(,228) ring R=0,(x,y),ds;
gaussman_lib.tex(,229) poly t=x5+x2y2+y5;
gaussman_lib.tex(,230) def G=gmsring(t,"s");
gaussman_lib.tex(,231) setring(G);
gaussman_lib.tex(,232) list l0=gmscoeffs(gmspoly,0);
gaussman_lib.tex(,233) print(l0[1]);
gaussman_lib.tex(,234) @expansion{} -1/2,
gaussman_lib.tex(,235) @expansion{} 0,   
gaussman_lib.tex(,236) @expansion{} 0,   
gaussman_lib.tex(,237) @expansion{} 0,   
gaussman_lib.tex(,238) @expansion{} 0,   
gaussman_lib.tex(,239) @expansion{} 0,   
gaussman_lib.tex(,240) @expansion{} 0,   
gaussman_lib.tex(,241) @expansion{} 0,   
gaussman_lib.tex(,242) @expansion{} 0,   
gaussman_lib.tex(,243) @expansion{} 0,   
gaussman_lib.tex(,244) @expansion{} 0    
gaussman_lib.tex(,245) list l1=gmscoeffs(gmspoly,1);
gaussman_lib.tex(,246) print(l1[1]);
gaussman_lib.tex(,247) @expansion{} -1/2,
gaussman_lib.tex(,248) @expansion{} 0,   
gaussman_lib.tex(,249) @expansion{} 0,   
gaussman_lib.tex(,250) @expansion{} 0,   
gaussman_lib.tex(,251) @expansion{} 0,   
gaussman_lib.tex(,252) @expansion{} 0,   
gaussman_lib.tex(,253) @expansion{} 0,   
gaussman_lib.tex(,254) @expansion{} 0,   
gaussman_lib.tex(,255) @expansion{} 0,   
gaussman_lib.tex(,256) @expansion{} 0,   
gaussman_lib.tex(,257) @expansion{} 1/2s 
gaussman_lib.tex(,258) list l=gmscoeffs(l0[2],1);
gaussman_lib.tex(,259) print(l[1]);
gaussman_lib.tex(,260) @expansion{} 0,  
gaussman_lib.tex(,261) @expansion{} 0,  
gaussman_lib.tex(,262) @expansion{} 0,  
gaussman_lib.tex(,263) @expansion{} 0,  
gaussman_lib.tex(,264) @expansion{} 0,  
gaussman_lib.tex(,265) @expansion{} 0,  
gaussman_lib.tex(,266) @expansion{} 0,  
gaussman_lib.tex(,267) @expansion{} 0,  
gaussman_lib.tex(,268) @expansion{} 0,  
gaussman_lib.tex(,269) @expansion{} 0,  
gaussman_lib.tex(,270) @expansion{} 1/2s
gaussman_lib.tex(,271) @c end example gmscoeffs d2t_singular/gaussman_lib.doc:189
gaussman_lib.tex(,272) @end smallexample
gaussman_lib.tex(,273) @c ---end content gmscoeffs---
gaussman_lib.tex(,274) 
gaussman_lib.tex(,275) @c ------------------- bernstein -------------
gaussman_lib.tex(,276) @node bernstein, monodromy, gmscoeffs, gaussman_lib
gaussman_lib.tex(,277) @subsubsection bernstein
gaussman_lib.tex(,278) @cindex bernstein
gaussman_lib.tex(,279) @c ---content bernstein---
gaussman_lib.tex(,280) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,281) 
gaussman_lib.tex(,282) @table @asis
gaussman_lib.tex(,283) @item @strong{Usage:}
gaussman_lib.tex(,284) bernstein(t); poly t
gaussman_lib.tex(,285) 
gaussman_lib.tex(,286) @item @strong{Assume:}
gaussman_lib.tex(,287) characteristic 0; local degree ordering;
gaussman_lib.tex(,288) @*isolated critical point 0 of t
gaussman_lib.tex(,289) 
gaussman_lib.tex(,290) @item @strong{Return:}
gaussman_lib.tex(,291) ideal r; roots of the Bernstein polynomial b excluding the root -1
gaussman_lib.tex(,292) 
gaussman_lib.tex(,293) @item @strong{Note:}
gaussman_lib.tex(,294) the roots of b are negative rational numbers and -1 is a root of b
gaussman_lib.tex(,295) 
gaussman_lib.tex(,296) @cindex singularities
gaussman_lib.tex(,297) @cindex Gauss-Manin connection
gaussman_lib.tex(,298) @cindex Brieskorn lattice
gaussman_lib.tex(,299) @cindex Bernstein polynomial
gaussman_lib.tex(,300) @end table
gaussman_lib.tex(,301) @strong{Example:}
gaussman_lib.tex(,302) @smallexample
gaussman_lib.tex(,303) @c computed example bernstein d2t_singular/gaussman_lib.doc:233 
gaussman_lib.tex(,304) LIB "gaussman.lib";
gaussman_lib.tex(,305) ring R=0,(x,y),ds;
gaussman_lib.tex(,306) poly t=x5+x2y2+y5;
gaussman_lib.tex(,307) bernstein(t);
gaussman_lib.tex(,308) @expansion{} [1]:
gaussman_lib.tex(,309) @expansion{}    _[1]=-1/2
gaussman_lib.tex(,310) @expansion{}    _[2]=-7/10
gaussman_lib.tex(,311) @expansion{}    _[3]=-9/10
gaussman_lib.tex(,312) @expansion{}    _[4]=-1
gaussman_lib.tex(,313) @expansion{}    _[5]=-11/10
gaussman_lib.tex(,314) @expansion{}    _[6]=-13/10
gaussman_lib.tex(,315) @expansion{} [2]:
gaussman_lib.tex(,316) @expansion{}    2,1,1,2,1,1
gaussman_lib.tex(,317) @c end example bernstein d2t_singular/gaussman_lib.doc:233
gaussman_lib.tex(,318) @end smallexample
gaussman_lib.tex(,319) @c ---end content bernstein---
gaussman_lib.tex(,320) 
gaussman_lib.tex(,321) @c ------------------- monodromy -------------
gaussman_lib.tex(,322) @node monodromy, spectrum, bernstein, gaussman_lib
gaussman_lib.tex(,323) @subsubsection monodromy
gaussman_lib.tex(,324) @cindex monodromy
gaussman_lib.tex(,325) @c ---content monodromy---
gaussman_lib.tex(,326) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,327) 
gaussman_lib.tex(,328) @table @asis
gaussman_lib.tex(,329) @item @strong{Usage:}
gaussman_lib.tex(,330) monodromy(t); poly t
gaussman_lib.tex(,331) 
gaussman_lib.tex(,332) @item @strong{Assume:}
gaussman_lib.tex(,333) characteristic 0; local degree ordering;
gaussman_lib.tex(,334) @*isolated critical point 0 of t
gaussman_lib.tex(,335) 
gaussman_lib.tex(,336) @item @strong{Return:}
gaussman_lib.tex(,337) @format
gaussman_lib.tex(,338) list l;  Jordan data jordan(M) of monodromy matrix exp(-2*pi*i*M)
gaussman_lib.tex(,339)   ideal l[1]; 
gaussman_lib.tex(,340)     number l[1][i];  eigenvalue of i-th Jordan block of M
gaussman_lib.tex(,341)   intvec l[2]; 
gaussman_lib.tex(,342)     int l[2][i];  size of i-th Jordan block of M
gaussman_lib.tex(,343)   intvec l[3]; 
gaussman_lib.tex(,344)     int l[3][i];  multiplicity of i-th Jordan block of M
gaussman_lib.tex(,345) @end format
gaussman_lib.tex(,346) 
gaussman_lib.tex(,347) @cindex singularities
gaussman_lib.tex(,348) @cindex Gauss-Manin connection
gaussman_lib.tex(,349) @cindex Brieskorn lattice
gaussman_lib.tex(,350) @cindex monodromy
gaussman_lib.tex(,351) @end table
gaussman_lib.tex(,352) @strong{Example:}
gaussman_lib.tex(,353) @smallexample
gaussman_lib.tex(,354) @c computed example monodromy d2t_singular/gaussman_lib.doc:275 
gaussman_lib.tex(,355) LIB "gaussman.lib";
gaussman_lib.tex(,356) ring R=0,(x,y),ds;
gaussman_lib.tex(,357) poly t=x5+x2y2+y5;
gaussman_lib.tex(,358) monodromy(t);
gaussman_lib.tex(,359) @expansion{} [1]:
gaussman_lib.tex(,360) @expansion{}    _[1]=1/2
gaussman_lib.tex(,361) @expansion{}    _[2]=7/10
gaussman_lib.tex(,362) @expansion{}    _[3]=9/10
gaussman_lib.tex(,363) @expansion{}    _[4]=1
gaussman_lib.tex(,364) @expansion{}    _[5]=11/10
gaussman_lib.tex(,365) @expansion{}    _[6]=13/10
gaussman_lib.tex(,366) @expansion{} [2]:
gaussman_lib.tex(,367) @expansion{}    2,1,1,1,1,1
gaussman_lib.tex(,368) @expansion{} [3]:
gaussman_lib.tex(,369) @expansion{}    1,2,2,1,2,2
gaussman_lib.tex(,370) @c end example monodromy d2t_singular/gaussman_lib.doc:275
gaussman_lib.tex(,371) @end smallexample
gaussman_lib.tex(,372) @c inserted refs from d2t_singular/gaussman_lib.doc:282
gaussman_lib.tex(,385) @c end inserted refs from d2t_singular/gaussman_lib.doc:282
gaussman_lib.tex(,386) 
gaussman_lib.tex(,387) @c ---end content monodromy---
gaussman_lib.tex(,388) 
gaussman_lib.tex(,389) @c ------------------- spectrum -------------
gaussman_lib.tex(,390) @node spectrum, sppairs, monodromy, gaussman_lib
gaussman_lib.tex(,391) @subsubsection spectrum
gaussman_lib.tex(,392) @cindex spectrum
gaussman_lib.tex(,393) @c ---content spectrum---
gaussman_lib.tex(,394) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,395) 
gaussman_lib.tex(,396) @table @asis
gaussman_lib.tex(,397) @item @strong{Usage:}
gaussman_lib.tex(,398) spectrum(t); poly t
gaussman_lib.tex(,399) 
gaussman_lib.tex(,400) @item @strong{Assume:}
gaussman_lib.tex(,401) characteristic 0; local degree ordering;
gaussman_lib.tex(,402) @*isolated critical point 0 of t
gaussman_lib.tex(,403) 
gaussman_lib.tex(,404) @item @strong{Return:}
gaussman_lib.tex(,405) @format
gaussman_lib.tex(,406) list sp;  singularity spectrum of t
gaussman_lib.tex(,407)   ideal sp[1];
gaussman_lib.tex(,408)     number sp[1][i];  i-th spectral number
gaussman_lib.tex(,409)   intvec sp[2];
gaussman_lib.tex(,410)     int sp[2][i];  multiplicity of i-th spectral number
gaussman_lib.tex(,411) @end format
gaussman_lib.tex(,412) 
gaussman_lib.tex(,413) @cindex singularities
gaussman_lib.tex(,414) @cindex Gauss-Manin connection
gaussman_lib.tex(,415) @cindex Brieskorn lattice
gaussman_lib.tex(,416) @cindex mixed Hodge structure
gaussman_lib.tex(,417) @cindex V-filtration
gaussman_lib.tex(,418) @cindex spectrum
gaussman_lib.tex(,419) @end table
gaussman_lib.tex(,420) @strong{Example:}
gaussman_lib.tex(,421) @smallexample
gaussman_lib.tex(,422) @c computed example spectrum d2t_singular/gaussman_lib.doc:321 
gaussman_lib.tex(,423) LIB "gaussman.lib";
gaussman_lib.tex(,424) ring R=0,(x,y),ds;
gaussman_lib.tex(,425) poly t=x5+x2y2+y5;
gaussman_lib.tex(,426) spprint(spectrum(t));
gaussman_lib.tex(,427) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,428) @c end example spectrum d2t_singular/gaussman_lib.doc:321
gaussman_lib.tex(,429) @end smallexample
gaussman_lib.tex(,430) @c inserted refs from d2t_singular/gaussman_lib.doc:328
gaussman_lib.tex(,441) @c end inserted refs from d2t_singular/gaussman_lib.doc:328
gaussman_lib.tex(,442) 
gaussman_lib.tex(,443) @c ---end content spectrum---
gaussman_lib.tex(,444) 
gaussman_lib.tex(,445) @c ------------------- sppairs -------------
gaussman_lib.tex(,446) @node sppairs, spnf, spectrum, gaussman_lib
gaussman_lib.tex(,447) @subsubsection sppairs
gaussman_lib.tex(,448) @cindex sppairs
gaussman_lib.tex(,449) @c ---content sppairs---
gaussman_lib.tex(,450) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,451) 
gaussman_lib.tex(,452) @table @asis
gaussman_lib.tex(,453) @item @strong{Usage:}
gaussman_lib.tex(,454) sppairs(t); poly t
gaussman_lib.tex(,455) 
gaussman_lib.tex(,456) @item @strong{Assume:}
gaussman_lib.tex(,457) characteristic 0; local degree ordering;
gaussman_lib.tex(,458) @*isolated critical point 0 of t
gaussman_lib.tex(,459) 
gaussman_lib.tex(,460) @item @strong{Return:}
gaussman_lib.tex(,461) @format
gaussman_lib.tex(,462) list spp;  spectral pairs of t
gaussman_lib.tex(,463)   ideal spp[1];
gaussman_lib.tex(,464)     number spp[1][i];  V-filtration index of i-th spectral pair
gaussman_lib.tex(,465)   intvec spp[2];
gaussman_lib.tex(,466)     int spp[2][i];  weight filtration index of i-th spectral pair
gaussman_lib.tex(,467)   intvec spp[3];
gaussman_lib.tex(,468)     int spp[3][i];  multiplicity of i-th spectral pair
gaussman_lib.tex(,469) @end format
gaussman_lib.tex(,470) 
gaussman_lib.tex(,471) @cindex singularities
gaussman_lib.tex(,472) @cindex Gauss-Manin connection
gaussman_lib.tex(,473) @cindex Brieskorn lattice
gaussman_lib.tex(,474) @cindex mixed Hodge structure
gaussman_lib.tex(,475) @cindex V-filtration
gaussman_lib.tex(,476) @cindex weight filtration
gaussman_lib.tex(,477) @cindex spectrum
gaussman_lib.tex(,478) @cindex spectral pairs
gaussman_lib.tex(,479) @end table
gaussman_lib.tex(,480) @strong{Example:}
gaussman_lib.tex(,481) @smallexample
gaussman_lib.tex(,482) @c computed example sppairs d2t_singular/gaussman_lib.doc:371 
gaussman_lib.tex(,483) LIB "gaussman.lib";
gaussman_lib.tex(,484) ring R=0,(x,y),ds;
gaussman_lib.tex(,485) poly t=x5+x2y2+y5;
gaussman_lib.tex(,486) sppprint(sppairs(t));
gaussman_lib.tex(,487) @expansion{} ((-1/2,2),1),((-3/10,1),2),((-1/10,1),2),((0,1),1),((1/10,1),2),((3/10,1)\
gaussman_lib.tex(,488)    ,2),((1/2,0),1)
gaussman_lib.tex(,489) @c end example sppairs d2t_singular/gaussman_lib.doc:371
gaussman_lib.tex(,490) @end smallexample
gaussman_lib.tex(,491) @c inserted refs from d2t_singular/gaussman_lib.doc:378
gaussman_lib.tex(,502) @c end inserted refs from d2t_singular/gaussman_lib.doc:378
gaussman_lib.tex(,503) 
gaussman_lib.tex(,504) @c ---end content sppairs---
gaussman_lib.tex(,505) 
gaussman_lib.tex(,506) @c ------------------- spnf -------------
gaussman_lib.tex(,507) @node spnf, sppnf, sppairs, gaussman_lib
gaussman_lib.tex(,508) @subsubsection spnf
gaussman_lib.tex(,509) @cindex spnf
gaussman_lib.tex(,510) @c ---content spnf---
gaussman_lib.tex(,511) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,512) 
gaussman_lib.tex(,513) @table @asis
gaussman_lib.tex(,514) @item @strong{Assume:}
gaussman_lib.tex(,515) ncols(a)==size(m)==size(V); typeof(V[i])=="int"
gaussman_lib.tex(,516) 
gaussman_lib.tex(,517) @item @strong{Return:}
gaussman_lib.tex(,518) order (a[i][,V[i]]) with multiplicity m[i] lexicographically
gaussman_lib.tex(,519) 
gaussman_lib.tex(,520) @end table
gaussman_lib.tex(,521) @c ---end content spnf---
gaussman_lib.tex(,522) 
gaussman_lib.tex(,523) @c ------------------- sppnf -------------
gaussman_lib.tex(,524) @node sppnf, vfilt, spnf, gaussman_lib
gaussman_lib.tex(,525) @subsubsection sppnf
gaussman_lib.tex(,526) @cindex sppnf
gaussman_lib.tex(,527) @c ---content sppnf---
gaussman_lib.tex(,528) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,529) 
gaussman_lib.tex(,530) @table @asis
gaussman_lib.tex(,531) @item @strong{Assume:}
gaussman_lib.tex(,532) ncols(e)=size(w)=size(m)=size(V); typeof(V[i])=="module"
gaussman_lib.tex(,533) 
gaussman_lib.tex(,534) @item @strong{Return:}
gaussman_lib.tex(,535) order (a[i][,w[i]][,V[i]]) with multiplicity m[i] lexicographically
gaussman_lib.tex(,536) 
gaussman_lib.tex(,537) @end table
gaussman_lib.tex(,538) @c ---end content sppnf---
gaussman_lib.tex(,539) 
gaussman_lib.tex(,540) @c ------------------- vfilt -------------
gaussman_lib.tex(,541) @node vfilt, vwfilt, sppnf, gaussman_lib
gaussman_lib.tex(,542) @subsubsection vfilt
gaussman_lib.tex(,543) @cindex vfilt
gaussman_lib.tex(,544) @c ---content vfilt---
gaussman_lib.tex(,545) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,546) 
gaussman_lib.tex(,547) @table @asis
gaussman_lib.tex(,548) @item @strong{Usage:}
gaussman_lib.tex(,549) vfilt(t); poly t
gaussman_lib.tex(,550) 
gaussman_lib.tex(,551) @item @strong{Assume:}
gaussman_lib.tex(,552) characteristic 0; local degree ordering;
gaussman_lib.tex(,553) @*isolated critical point 0 of t
gaussman_lib.tex(,554) 
gaussman_lib.tex(,555) @item @strong{Return:}
gaussman_lib.tex(,556) @format
gaussman_lib.tex(,557) list v;  V-filtration on H''/s*H''
gaussman_lib.tex(,558)   ideal v[1];
gaussman_lib.tex(,559)     number v[1][i];  V-filtration index of i-th spectral number
gaussman_lib.tex(,560)   intvec v[2];
gaussman_lib.tex(,561)     int v[2][i];  multiplicity of i-th spectral number
gaussman_lib.tex(,562)   list v[3];
gaussman_lib.tex(,563)     module v[3][i];  vector space of i-th graded part in terms of v[4]
gaussman_lib.tex(,564)   ideal v[4];  monomial vector space basis of H''/s*H''
gaussman_lib.tex(,565)   ideal v[5];  standard basis of Jacobian ideal
gaussman_lib.tex(,566) @end format
gaussman_lib.tex(,567) 
gaussman_lib.tex(,568) @cindex singularities
gaussman_lib.tex(,569) @cindex Gauss-Manin connection
gaussman_lib.tex(,570) @cindex Brieskorn lattice
gaussman_lib.tex(,571) @cindex mixed Hodge structure
gaussman_lib.tex(,572) @cindex V-filtration
gaussman_lib.tex(,573) @cindex spectrum
gaussman_lib.tex(,574) @end table
gaussman_lib.tex(,575) @strong{Example:}
gaussman_lib.tex(,576) @smallexample
gaussman_lib.tex(,577) @c computed example vfilt d2t_singular/gaussman_lib.doc:455 
gaussman_lib.tex(,578) LIB "gaussman.lib";
gaussman_lib.tex(,579) ring R=0,(x,y),ds;
gaussman_lib.tex(,580) poly t=x5+x2y2+y5;
gaussman_lib.tex(,581) vfilt(t);
gaussman_lib.tex(,582) @expansion{} [1]:
gaussman_lib.tex(,583) @expansion{}    _[1]=-1/2
gaussman_lib.tex(,584) @expansion{}    _[2]=-3/10
gaussman_lib.tex(,585) @expansion{}    _[3]=-1/10
gaussman_lib.tex(,586) @expansion{}    _[4]=0
gaussman_lib.tex(,587) @expansion{}    _[5]=1/10
gaussman_lib.tex(,588) @expansion{}    _[6]=3/10
gaussman_lib.tex(,589) @expansion{}    _[7]=1/2
gaussman_lib.tex(,590) @expansion{} [2]:
gaussman_lib.tex(,591) @expansion{}    1,2,2,1,2,2,1
gaussman_lib.tex(,592) @expansion{} [3]:
gaussman_lib.tex(,593) @expansion{}    [1]:
gaussman_lib.tex(,594) @expansion{}       _[1]=gen(11)
gaussman_lib.tex(,595) @expansion{}    [2]:
gaussman_lib.tex(,596) @expansion{}       _[1]=gen(10)
gaussman_lib.tex(,597) @expansion{}       _[2]=gen(6)
gaussman_lib.tex(,598) @expansion{}    [3]:
gaussman_lib.tex(,599) @expansion{}       _[1]=gen(9)
gaussman_lib.tex(,600) @expansion{}       _[2]=gen(4)
gaussman_lib.tex(,601) @expansion{}    [4]:
gaussman_lib.tex(,602) @expansion{}       _[1]=gen(5)
gaussman_lib.tex(,603) @expansion{}    [5]:
gaussman_lib.tex(,604) @expansion{}       _[1]=gen(3)
gaussman_lib.tex(,605) @expansion{}       _[2]=gen(8)
gaussman_lib.tex(,606) @expansion{}    [6]:
gaussman_lib.tex(,607) @expansion{}       _[1]=gen(2)
gaussman_lib.tex(,608) @expansion{}       _[2]=gen(7)
gaussman_lib.tex(,609) @expansion{}    [7]:
gaussman_lib.tex(,610) @expansion{}       _[1]=gen(1)
gaussman_lib.tex(,611) @expansion{} [4]:
gaussman_lib.tex(,612) @expansion{}    _[1]=y5
gaussman_lib.tex(,613) @expansion{}    _[2]=y4
gaussman_lib.tex(,614) @expansion{}    _[3]=y3
gaussman_lib.tex(,615) @expansion{}    _[4]=y2
gaussman_lib.tex(,616) @expansion{}    _[5]=xy
gaussman_lib.tex(,617) @expansion{}    _[6]=y
gaussman_lib.tex(,618) @expansion{}    _[7]=x4
gaussman_lib.tex(,619) @expansion{}    _[8]=x3
gaussman_lib.tex(,620) @expansion{}    _[9]=x2
gaussman_lib.tex(,621) @expansion{}    _[10]=x
gaussman_lib.tex(,622) @expansion{}    _[11]=1
gaussman_lib.tex(,623) @expansion{} [5]:
gaussman_lib.tex(,624) @expansion{}    _[1]=2x2y+5y4
gaussman_lib.tex(,625) @expansion{}    _[2]=2xy2+5x4
gaussman_lib.tex(,626) @expansion{}    _[3]=5x5-5y5
gaussman_lib.tex(,627) @expansion{}    _[4]=10y6+25x3y4
gaussman_lib.tex(,628) @c end example vfilt d2t_singular/gaussman_lib.doc:455
gaussman_lib.tex(,629) @end smallexample
gaussman_lib.tex(,630) @c inserted refs from d2t_singular/gaussman_lib.doc:462
gaussman_lib.tex(,641) @c end inserted refs from d2t_singular/gaussman_lib.doc:462
gaussman_lib.tex(,642) 
gaussman_lib.tex(,643) @c ---end content vfilt---
gaussman_lib.tex(,644) 
gaussman_lib.tex(,645) @c ------------------- vwfilt -------------
gaussman_lib.tex(,646) @node vwfilt, tmatrix, vfilt, gaussman_lib
gaussman_lib.tex(,647) @subsubsection vwfilt
gaussman_lib.tex(,648) @cindex vwfilt
gaussman_lib.tex(,649) @c ---content vwfilt---
gaussman_lib.tex(,650) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,651) 
gaussman_lib.tex(,652) @table @asis
gaussman_lib.tex(,653) @item @strong{Usage:}
gaussman_lib.tex(,654) vwfilt(t); poly t
gaussman_lib.tex(,655) 
gaussman_lib.tex(,656) @item @strong{Assume:}
gaussman_lib.tex(,657) characteristic 0; local degree ordering;
gaussman_lib.tex(,658) @*isolated critical point 0 of t
gaussman_lib.tex(,659) 
gaussman_lib.tex(,660) @item @strong{Return:}
gaussman_lib.tex(,661) @format
gaussman_lib.tex(,662) list vw;  weighted V-filtration on H''/s*H''
gaussman_lib.tex(,663)   ideal vw[1];
gaussman_lib.tex(,664)     number vw[1][i];  V-filtration index of i-th spectral pair
gaussman_lib.tex(,665)   intvec vw[2];
gaussman_lib.tex(,666)     int vw[2][i];  weight filtration index of i-th spectral pair
gaussman_lib.tex(,667)   intvec vw[3];
gaussman_lib.tex(,668)     int vw[3][i];  multiplicity of i-th spectral pair
gaussman_lib.tex(,669)   list vw[4];
gaussman_lib.tex(,670)     module vw[4][i];  vector space of i-th graded part in terms of vw[5]
gaussman_lib.tex(,671)   ideal vw[5];  monomial vector space basis of H''/s*H''
gaussman_lib.tex(,672)   ideal vw[6];  standard basis of Jacobian ideal
gaussman_lib.tex(,673) @end format
gaussman_lib.tex(,674) 
gaussman_lib.tex(,675) @cindex singularities
gaussman_lib.tex(,676) @cindex Gauss-Manin connection
gaussman_lib.tex(,677) @cindex Brieskorn lattice
gaussman_lib.tex(,678) @cindex mixed Hodge structure
gaussman_lib.tex(,679) @cindex V-filtration
gaussman_lib.tex(,680) @cindex weight filtration
gaussman_lib.tex(,681) @cindex spectrum
gaussman_lib.tex(,682) @cindex spectral pairs
gaussman_lib.tex(,683) @end table
gaussman_lib.tex(,684) @strong{Example:}
gaussman_lib.tex(,685) @smallexample
gaussman_lib.tex(,686) @c computed example vwfilt d2t_singular/gaussman_lib.doc:509 
gaussman_lib.tex(,687) LIB "gaussman.lib";
gaussman_lib.tex(,688) ring R=0,(x,y),ds;
gaussman_lib.tex(,689) poly t=x5+x2y2+y5;
gaussman_lib.tex(,690) vwfilt(t);
gaussman_lib.tex(,691) @expansion{} [1]:
gaussman_lib.tex(,692) @expansion{}    _[1]=-1/2
gaussman_lib.tex(,693) @expansion{}    _[2]=-3/10
gaussman_lib.tex(,694) @expansion{}    _[3]=-1/10
gaussman_lib.tex(,695) @expansion{}    _[4]=0
gaussman_lib.tex(,696) @expansion{}    _[5]=1/10
gaussman_lib.tex(,697) @expansion{}    _[6]=3/10
gaussman_lib.tex(,698) @expansion{}    _[7]=1/2
gaussman_lib.tex(,699) @expansion{} [2]:
gaussman_lib.tex(,700) @expansion{}    2,1,1,1,1,1,0
gaussman_lib.tex(,701) @expansion{} [3]:
gaussman_lib.tex(,702) @expansion{}    1,2,2,1,2,2,1
gaussman_lib.tex(,703) @expansion{} [4]:
gaussman_lib.tex(,704) @expansion{}    [1]:
gaussman_lib.tex(,705) @expansion{}       _[1]=gen(11)
gaussman_lib.tex(,706) @expansion{}    [2]:
gaussman_lib.tex(,707) @expansion{}       _[1]=gen(10)
gaussman_lib.tex(,708) @expansion{}       _[2]=gen(6)
gaussman_lib.tex(,709) @expansion{}    [3]:
gaussman_lib.tex(,710) @expansion{}       _[1]=gen(9)
gaussman_lib.tex(,711) @expansion{}       _[2]=gen(4)
gaussman_lib.tex(,712) @expansion{}    [4]:
gaussman_lib.tex(,713) @expansion{}       _[1]=gen(5)
gaussman_lib.tex(,714) @expansion{}    [5]:
gaussman_lib.tex(,715) @expansion{}       _[1]=gen(3)
gaussman_lib.tex(,716) @expansion{}       _[2]=gen(8)
gaussman_lib.tex(,717) @expansion{}    [6]:
gaussman_lib.tex(,718) @expansion{}       _[1]=gen(2)
gaussman_lib.tex(,719) @expansion{}       _[2]=gen(7)
gaussman_lib.tex(,720) @expansion{}    [7]:
gaussman_lib.tex(,721) @expansion{}       _[1]=gen(1)
gaussman_lib.tex(,722) @expansion{} [5]:
gaussman_lib.tex(,723) @expansion{}    _[1]=y5
gaussman_lib.tex(,724) @expansion{}    _[2]=y4
gaussman_lib.tex(,725) @expansion{}    _[3]=y3
gaussman_lib.tex(,726) @expansion{}    _[4]=y2
gaussman_lib.tex(,727) @expansion{}    _[5]=xy
gaussman_lib.tex(,728) @expansion{}    _[6]=y
gaussman_lib.tex(,729) @expansion{}    _[7]=x4
gaussman_lib.tex(,730) @expansion{}    _[8]=x3
gaussman_lib.tex(,731) @expansion{}    _[9]=x2
gaussman_lib.tex(,732) @expansion{}    _[10]=x
gaussman_lib.tex(,733) @expansion{}    _[11]=1
gaussman_lib.tex(,734) @expansion{} [6]:
gaussman_lib.tex(,735) @expansion{}    _[1]=2x2y+5y4
gaussman_lib.tex(,736) @expansion{}    _[2]=2xy2+5x4
gaussman_lib.tex(,737) @expansion{}    _[3]=5x5-5y5
gaussman_lib.tex(,738) @expansion{}    _[4]=10y6+25x3y4
gaussman_lib.tex(,739) @c end example vwfilt d2t_singular/gaussman_lib.doc:509
gaussman_lib.tex(,740) @end smallexample
gaussman_lib.tex(,741) @c inserted refs from d2t_singular/gaussman_lib.doc:516
gaussman_lib.tex(,752) @c end inserted refs from d2t_singular/gaussman_lib.doc:516
gaussman_lib.tex(,753) 
gaussman_lib.tex(,754) @c ---end content vwfilt---
gaussman_lib.tex(,755) 
gaussman_lib.tex(,756) @c ------------------- tmatrix -------------
gaussman_lib.tex(,757) @node tmatrix, endvfilt, vwfilt, gaussman_lib
gaussman_lib.tex(,758) @subsubsection tmatrix
gaussman_lib.tex(,759) @cindex tmatrix
gaussman_lib.tex(,760) @c ---content tmatrix---
gaussman_lib.tex(,761) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,762) 
gaussman_lib.tex(,763) @table @asis
gaussman_lib.tex(,764) @item @strong{Usage:}
gaussman_lib.tex(,765) tmatrix(t); poly t
gaussman_lib.tex(,766) 
gaussman_lib.tex(,767) @item @strong{Assume:}
gaussman_lib.tex(,768) characteristic 0; local degree ordering;
gaussman_lib.tex(,769) @*isolated critical point 0 of t
gaussman_lib.tex(,770) 
gaussman_lib.tex(,771) @item @strong{Return:}
gaussman_lib.tex(,772) @format
gaussman_lib.tex(,773) list l=A0,A1,T,M;
gaussman_lib.tex(,774)   matrix A0,A1;  t=A0+s*A1+s^2*(d/ds) on H'' w.r.t. C[[s]]-basis M*T
gaussman_lib.tex(,775)   module T;  C-basis of C^mu
gaussman_lib.tex(,776)   ideal M;  monomial C-basis of H''/sH''
gaussman_lib.tex(,777) @end format
gaussman_lib.tex(,778) 
gaussman_lib.tex(,779) @cindex singularities
gaussman_lib.tex(,780) @cindex Gauss-Manin connection
gaussman_lib.tex(,781) @cindex Brieskorn lattice
gaussman_lib.tex(,782) @cindex mixed Hodge structure
gaussman_lib.tex(,783) @cindex opposite Hodge filtration
gaussman_lib.tex(,784) @cindex V-filtration
gaussman_lib.tex(,785) @end table
gaussman_lib.tex(,786) @strong{Example:}
gaussman_lib.tex(,787) @smallexample
gaussman_lib.tex(,788) @c computed example tmatrix d2t_singular/gaussman_lib.doc:554 
gaussman_lib.tex(,789) LIB "gaussman.lib";
gaussman_lib.tex(,790) ring R=0,(x,y),ds;
gaussman_lib.tex(,791) poly t=x5+x2y2+y5;
gaussman_lib.tex(,792) list A=tmatrix(t);
gaussman_lib.tex(,793) print(A[1]);
gaussman_lib.tex(,794) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,795) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,796) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,797) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,798) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,799) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,800) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,801) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,802) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,803) @expansion{} 0,0,0,0,0,0,0,0,0,0,0,
gaussman_lib.tex(,804) @expansion{} 1,0,0,0,0,0,0,0,0,0,0 
gaussman_lib.tex(,805) print(A[2]);
gaussman_lib.tex(,806) @expansion{} 1/2,0,   0,   0,   0,   0,0,    0,    0,    0,    0, 
gaussman_lib.tex(,807) @expansion{} 0,  7/10,0,   0,   0,   0,0,    0,    0,    0,    0, 
gaussman_lib.tex(,808) @expansion{} 0,  0,   7/10,0,   0,   0,0,    0,    0,    0,    0, 
gaussman_lib.tex(,809) @expansion{} 0,  0,   0,   9/10,0,   0,0,    0,    0,    0,    0, 
gaussman_lib.tex(,810) @expansion{} 0,  0,   0,   0,   9/10,0,0,    0,    0,    0,    0, 
gaussman_lib.tex(,811) @expansion{} 0,  0,   0,   0,   0,   1,0,    0,    0,    0,    0, 
gaussman_lib.tex(,812) @expansion{} 0,  0,   0,   0,   0,   0,11/10,0,    0,    0,    0, 
gaussman_lib.tex(,813) @expansion{} 0,  0,   0,   0,   0,   0,0,    11/10,0,    0,    0, 
gaussman_lib.tex(,814) @expansion{} 0,  0,   0,   0,   0,   0,0,    0,    13/10,0,    0, 
gaussman_lib.tex(,815) @expansion{} 0,  0,   0,   0,   0,   0,0,    0,    0,    13/10,0, 
gaussman_lib.tex(,816) @expansion{} 0,  0,   0,   0,   0,   0,0,    0,    0,    0,    3/2
gaussman_lib.tex(,817) print(A[3]);
gaussman_lib.tex(,818) @expansion{} -1445/64,0,  0,  0,0,85/8,0,0,0,0,1/2,
gaussman_lib.tex(,819) @expansion{} 0,       125,0,  0,0,0,   0,0,1,0,0,  
gaussman_lib.tex(,820) @expansion{} 0,       0,  0,  5,0,0,   1,0,0,0,0,  
gaussman_lib.tex(,821) @expansion{} 0,       0,  0,  0,4,0,   0,0,0,0,0,  
gaussman_lib.tex(,822) @expansion{} 2,       0,  0,  0,0,1,   0,0,0,0,0,  
gaussman_lib.tex(,823) @expansion{} 0,       0,  16, 0,0,0,   0,0,0,0,0,  
gaussman_lib.tex(,824) @expansion{} 0,       0,  125,0,0,0,   0,0,0,1,0,  
gaussman_lib.tex(,825) @expansion{} 0,       0,  0,  0,5,0,   0,1,0,0,0,  
gaussman_lib.tex(,826) @expansion{} 0,       0,  0,  4,0,0,   0,0,0,0,0,  
gaussman_lib.tex(,827) @expansion{} 0,       16, 0,  0,0,0,   0,0,0,0,0,  
gaussman_lib.tex(,828) @expansion{} -1,      0,  0,  0,0,0,   0,0,0,0,0   
gaussman_lib.tex(,829) print(A[4]);
gaussman_lib.tex(,830) @expansion{} y5,
gaussman_lib.tex(,831) @expansion{} y4,
gaussman_lib.tex(,832) @expansion{} y3,
gaussman_lib.tex(,833) @expansion{} y2,
gaussman_lib.tex(,834) @expansion{} xy,
gaussman_lib.tex(,835) @expansion{} y,
gaussman_lib.tex(,836) @expansion{} x4,
gaussman_lib.tex(,837) @expansion{} x3,
gaussman_lib.tex(,838) @expansion{} x2,
gaussman_lib.tex(,839) @expansion{} x,
gaussman_lib.tex(,840) @expansion{} 1
gaussman_lib.tex(,841) @c end example tmatrix d2t_singular/gaussman_lib.doc:554
gaussman_lib.tex(,842) @end smallexample
gaussman_lib.tex(,843) @c ---end content tmatrix---
gaussman_lib.tex(,844) 
gaussman_lib.tex(,845) @c ------------------- endvfilt -------------
gaussman_lib.tex(,846) @node endvfilt, spprint, tmatrix, gaussman_lib
gaussman_lib.tex(,847) @subsubsection endvfilt
gaussman_lib.tex(,848) @cindex endvfilt
gaussman_lib.tex(,849) @c ---content endvfilt---
gaussman_lib.tex(,850) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,851) 
gaussman_lib.tex(,852) @table @asis
gaussman_lib.tex(,853) @item @strong{Usage:}
gaussman_lib.tex(,854) endvfilt(v); list v
gaussman_lib.tex(,855) 
gaussman_lib.tex(,856) @item @strong{Assume:}
gaussman_lib.tex(,857) v returned by vfilt
gaussman_lib.tex(,858) 
gaussman_lib.tex(,859) @item @strong{Return:}
gaussman_lib.tex(,860) @format
gaussman_lib.tex(,861) list ev;  V-filtration on Jacobian algebra
gaussman_lib.tex(,862)   ideal ev[1];
gaussman_lib.tex(,863)     number ev[1][i];  i-th V-filtration index
gaussman_lib.tex(,864)   intvec ev[2];
gaussman_lib.tex(,865)     int ev[2][i];  i-th multiplicity
gaussman_lib.tex(,866)   list ev[3];
gaussman_lib.tex(,867)     module ev[3][i];  vector space of i-th graded part in terms of ev[4]
gaussman_lib.tex(,868)   ideal ev[4];  monomial vector space basis of Jacobian algebra
gaussman_lib.tex(,869)   ideal ev[5];  standard basis of Jacobian ideal
gaussman_lib.tex(,870) @end format
gaussman_lib.tex(,871) 
gaussman_lib.tex(,872) @cindex singularities
gaussman_lib.tex(,873) @cindex Gauss-Manin connection
gaussman_lib.tex(,874) @cindex Brieskorn lattice
gaussman_lib.tex(,875) @cindex mixed Hodge structure
gaussman_lib.tex(,876) @cindex V-filtration
gaussman_lib.tex(,877) @cindex endomorphism filtration
gaussman_lib.tex(,878) @end table
gaussman_lib.tex(,879) @strong{Example:}
gaussman_lib.tex(,880) @smallexample
gaussman_lib.tex(,881) @c computed example endvfilt d2t_singular/gaussman_lib.doc:603 
gaussman_lib.tex(,882) LIB "gaussman.lib";
gaussman_lib.tex(,883) ring R=0,(x,y),ds;
gaussman_lib.tex(,884) poly t=x5+x2y2+y5;
gaussman_lib.tex(,885) endvfilt(vfilt(t));
gaussman_lib.tex(,886) @expansion{} [1]:
gaussman_lib.tex(,887) @expansion{}    _[1]=0
gaussman_lib.tex(,888) @expansion{}    _[2]=1/5
gaussman_lib.tex(,889) @expansion{}    _[3]=2/5
gaussman_lib.tex(,890) @expansion{}    _[4]=1/2
gaussman_lib.tex(,891) @expansion{}    _[5]=3/5
gaussman_lib.tex(,892) @expansion{}    _[6]=4/5
gaussman_lib.tex(,893) @expansion{}    _[7]=1
gaussman_lib.tex(,894) @expansion{} [2]:
gaussman_lib.tex(,895) @expansion{}    1,2,2,1,2,2,1
gaussman_lib.tex(,896) @expansion{} [3]:
gaussman_lib.tex(,897) @expansion{}    [1]:
gaussman_lib.tex(,898) @expansion{}       _[1]=gen(11)
gaussman_lib.tex(,899) @expansion{}    [2]:
gaussman_lib.tex(,900) @expansion{}       _[1]=gen(10)
gaussman_lib.tex(,901) @expansion{}       _[2]=gen(6)
gaussman_lib.tex(,902) @expansion{}    [3]:
gaussman_lib.tex(,903) @expansion{}       _[1]=gen(9)
gaussman_lib.tex(,904) @expansion{}       _[2]=gen(4)
gaussman_lib.tex(,905) @expansion{}    [4]:
gaussman_lib.tex(,906) @expansion{}       _[1]=gen(5)
gaussman_lib.tex(,907) @expansion{}    [5]:
gaussman_lib.tex(,908) @expansion{}       _[1]=gen(8)
gaussman_lib.tex(,909) @expansion{}       _[2]=gen(3)
gaussman_lib.tex(,910) @expansion{}    [6]:
gaussman_lib.tex(,911) @expansion{}       _[1]=gen(7)
gaussman_lib.tex(,912) @expansion{}       _[2]=gen(2)
gaussman_lib.tex(,913) @expansion{}    [7]:
gaussman_lib.tex(,914) @expansion{}       _[1]=gen(1)
gaussman_lib.tex(,915) @expansion{} [4]:
gaussman_lib.tex(,916) @expansion{}    _[1]=y5
gaussman_lib.tex(,917) @expansion{}    _[2]=y4
gaussman_lib.tex(,918) @expansion{}    _[3]=y3
gaussman_lib.tex(,919) @expansion{}    _[4]=y2
gaussman_lib.tex(,920) @expansion{}    _[5]=xy
gaussman_lib.tex(,921) @expansion{}    _[6]=y
gaussman_lib.tex(,922) @expansion{}    _[7]=x4
gaussman_lib.tex(,923) @expansion{}    _[8]=x3
gaussman_lib.tex(,924) @expansion{}    _[9]=x2
gaussman_lib.tex(,925) @expansion{}    _[10]=x
gaussman_lib.tex(,926) @expansion{}    _[11]=1
gaussman_lib.tex(,927) @expansion{} [5]:
gaussman_lib.tex(,928) @expansion{}    _[1]=2x2y+5y4
gaussman_lib.tex(,929) @expansion{}    _[2]=2xy2+5x4
gaussman_lib.tex(,930) @expansion{}    _[3]=5x5-5y5
gaussman_lib.tex(,931) @expansion{}    _[4]=10y6+25x3y4
gaussman_lib.tex(,932) @c end example endvfilt d2t_singular/gaussman_lib.doc:603
gaussman_lib.tex(,933) @end smallexample
gaussman_lib.tex(,934) @c ---end content endvfilt---
gaussman_lib.tex(,935) 
gaussman_lib.tex(,936) @c ------------------- spprint -------------
gaussman_lib.tex(,937) @node spprint, sppprint, endvfilt, gaussman_lib
gaussman_lib.tex(,938) @subsubsection spprint
gaussman_lib.tex(,939) @cindex spprint
gaussman_lib.tex(,940) @c ---content spprint---
gaussman_lib.tex(,941) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,942) 
gaussman_lib.tex(,943) @table @asis
gaussman_lib.tex(,944) @item @strong{Usage:}
gaussman_lib.tex(,945) spprint(sp); list sp
gaussman_lib.tex(,946) 
gaussman_lib.tex(,947) @item @strong{Return:}
gaussman_lib.tex(,948) string s; spectrum sp
gaussman_lib.tex(,949) 
gaussman_lib.tex(,950) @end table
gaussman_lib.tex(,951) @strong{Example:}
gaussman_lib.tex(,952) @smallexample
gaussman_lib.tex(,953) @c computed example spprint d2t_singular/gaussman_lib.doc:629 
gaussman_lib.tex(,954) LIB "gaussman.lib";
gaussman_lib.tex(,955) ring R=0,(x,y),ds;
gaussman_lib.tex(,956) list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,957) spprint(sp);
gaussman_lib.tex(,958) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,959) @c end example spprint d2t_singular/gaussman_lib.doc:629
gaussman_lib.tex(,960) @end smallexample
gaussman_lib.tex(,961) @c ---end content spprint---
gaussman_lib.tex(,962) 
gaussman_lib.tex(,963) @c ------------------- sppprint -------------
gaussman_lib.tex(,964) @node sppprint, spadd, spprint, gaussman_lib
gaussman_lib.tex(,965) @subsubsection sppprint
gaussman_lib.tex(,966) @cindex sppprint
gaussman_lib.tex(,967) @c ---content sppprint---
gaussman_lib.tex(,968) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,969) 
gaussman_lib.tex(,970) @table @asis
gaussman_lib.tex(,971) @item @strong{Usage:}
gaussman_lib.tex(,972) sppprint(spp); list spp
gaussman_lib.tex(,973) 
gaussman_lib.tex(,974) @item @strong{Return:}
gaussman_lib.tex(,975) string s; spectral pairs spp
gaussman_lib.tex(,976) 
gaussman_lib.tex(,977) @end table
gaussman_lib.tex(,978) @strong{Example:}
gaussman_lib.tex(,979) @smallexample
gaussman_lib.tex(,980) @c computed example sppprint d2t_singular/gaussman_lib.doc:655 
gaussman_lib.tex(,981) LIB "gaussman.lib";
gaussman_lib.tex(,982) ring R=0,(x,y),ds;
gaussman_lib.tex(,983) list spp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(2,1,1,1,1,1,0),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,984) sppprint(spp);
gaussman_lib.tex(,985) @expansion{} ((-1/2,2),1),((-3/10,1),2),((-1/10,1),2),((0,1),1),((1/10,1),2),((3/10,1)\
gaussman_lib.tex(,986)    ,2),((1/2,0),1)
gaussman_lib.tex(,987) @c end example sppprint d2t_singular/gaussman_lib.doc:655
gaussman_lib.tex(,988) @end smallexample
gaussman_lib.tex(,989) @c ---end content sppprint---
gaussman_lib.tex(,990) 
gaussman_lib.tex(,991) @c ------------------- spadd -------------
gaussman_lib.tex(,992) @node spadd, spsub, sppprint, gaussman_lib
gaussman_lib.tex(,993) @subsubsection spadd
gaussman_lib.tex(,994) @cindex spadd
gaussman_lib.tex(,995) @c ---content spadd---
gaussman_lib.tex(,996) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,997) 
gaussman_lib.tex(,998) @table @asis
gaussman_lib.tex(,999) @item @strong{Usage:}
gaussman_lib.tex(,1000) spadd(sp1,sp2); list sp1, list sp2
gaussman_lib.tex(,1001) 
gaussman_lib.tex(,1002) @item @strong{Return:}
gaussman_lib.tex(,1003) list sp; sum of spectra sp1 and sp2
gaussman_lib.tex(,1004) 
gaussman_lib.tex(,1005) @end table
gaussman_lib.tex(,1006) @strong{Example:}
gaussman_lib.tex(,1007) @smallexample
gaussman_lib.tex(,1008) @c computed example spadd d2t_singular/gaussman_lib.doc:681 
gaussman_lib.tex(,1009) LIB "gaussman.lib";
gaussman_lib.tex(,1010) ring R=0,(x,y),ds;
gaussman_lib.tex(,1011) list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,1012) spprint(sp1);
gaussman_lib.tex(,1013) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,1014) list sp2=list(ideal(-1/6,1/6),intvec(1,1));
gaussman_lib.tex(,1015) spprint(sp2);
gaussman_lib.tex(,1016) @expansion{} (-1/6,1),(1/6,1)
gaussman_lib.tex(,1017) spprint(spadd(sp1,sp2));
gaussman_lib.tex(,1018) @expansion{} (-1/2,1),(-3/10,2),(-1/6,1),(-1/10,2),(0,1),(1/10,2),(1/6,1),(3/10,2),(1/\
gaussman_lib.tex(,1019)    2,1)
gaussman_lib.tex(,1020) @c end example spadd d2t_singular/gaussman_lib.doc:681
gaussman_lib.tex(,1021) @end smallexample
gaussman_lib.tex(,1022) @c ---end content spadd---
gaussman_lib.tex(,1023) 
gaussman_lib.tex(,1024) @c ------------------- spsub -------------
gaussman_lib.tex(,1025) @node spsub, spmul, spadd, gaussman_lib
gaussman_lib.tex(,1026) @subsubsection spsub
gaussman_lib.tex(,1027) @cindex spsub
gaussman_lib.tex(,1028) @c ---content spsub---
gaussman_lib.tex(,1029) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,1030) 
gaussman_lib.tex(,1031) @table @asis
gaussman_lib.tex(,1032) @item @strong{Usage:}
gaussman_lib.tex(,1033) spsub(sp1,sp2); list sp1, list sp2
gaussman_lib.tex(,1034) 
gaussman_lib.tex(,1035) @item @strong{Return:}
gaussman_lib.tex(,1036) list sp; difference of spectra sp1 and sp2
gaussman_lib.tex(,1037) 
gaussman_lib.tex(,1038) @end table
gaussman_lib.tex(,1039) @strong{Example:}
gaussman_lib.tex(,1040) @smallexample
gaussman_lib.tex(,1041) @c computed example spsub d2t_singular/gaussman_lib.doc:710 
gaussman_lib.tex(,1042) LIB "gaussman.lib";
gaussman_lib.tex(,1043) ring R=0,(x,y),ds;
gaussman_lib.tex(,1044) list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,1045) spprint(sp1);
gaussman_lib.tex(,1046) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,1047) list sp2=list(ideal(-1/6,1/6),intvec(1,1));
gaussman_lib.tex(,1048) spprint(sp2);
gaussman_lib.tex(,1049) @expansion{} (-1/6,1),(1/6,1)
gaussman_lib.tex(,1050) spprint(spsub(sp1,sp2));
gaussman_lib.tex(,1051) @expansion{} (-1/2,1),(-3/10,2),(-1/6,-1),(-1/10,2),(0,1),(1/10,2),(1/6,-1),(3/10,2),(\
gaussman_lib.tex(,1052)    1/2,1)
gaussman_lib.tex(,1053) @c end example spsub d2t_singular/gaussman_lib.doc:710
gaussman_lib.tex(,1054) @end smallexample
gaussman_lib.tex(,1055) @c ---end content spsub---
gaussman_lib.tex(,1056) 
gaussman_lib.tex(,1057) @c ------------------- spmul -------------
gaussman_lib.tex(,1058) @node spmul, spissemicont, spsub, gaussman_lib
gaussman_lib.tex(,1059) @subsubsection spmul
gaussman_lib.tex(,1060) @cindex spmul
gaussman_lib.tex(,1061) @c ---content spmul---
gaussman_lib.tex(,1062) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,1063) 
gaussman_lib.tex(,1064) @table @asis
gaussman_lib.tex(,1065) @item @strong{Usage:}
gaussman_lib.tex(,1066) spmul(sp0,k); list sp0, int[vec] k
gaussman_lib.tex(,1067) 
gaussman_lib.tex(,1068) @item @strong{Return:}
gaussman_lib.tex(,1069) list sp; linear combination of spectra sp0 with coefficients k
gaussman_lib.tex(,1070) 
gaussman_lib.tex(,1071) @end table
gaussman_lib.tex(,1072) @strong{Example:}
gaussman_lib.tex(,1073) @smallexample
gaussman_lib.tex(,1074) @c computed example spmul d2t_singular/gaussman_lib.doc:739 
gaussman_lib.tex(,1075) LIB "gaussman.lib";
gaussman_lib.tex(,1076) ring R=0,(x,y),ds;
gaussman_lib.tex(,1077) list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,1078) spprint(sp);
gaussman_lib.tex(,1079) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,1080) spprint(spmul(sp,2));
gaussman_lib.tex(,1081) @expansion{} (-1/2,2),(-3/10,4),(-1/10,4),(0,2),(1/10,4),(3/10,4),(1/2,2)
gaussman_lib.tex(,1082) list sp1=list(ideal(-1/6,1/6),intvec(1,1));
gaussman_lib.tex(,1083) spprint(sp1);
gaussman_lib.tex(,1084) @expansion{} (-1/6,1),(1/6,1)
gaussman_lib.tex(,1085) list sp2=list(ideal(-1/3,0,1/3),intvec(1,2,1));
gaussman_lib.tex(,1086) spprint(sp2);
gaussman_lib.tex(,1087) @expansion{} (-1/3,1),(0,2),(1/3,1)
gaussman_lib.tex(,1088) spprint(spmul(list(sp1,sp2),intvec(1,2)));
gaussman_lib.tex(,1089) @expansion{} (-1/3,2),(-1/6,1),(0,4),(1/6,1),(1/3,2)
gaussman_lib.tex(,1090) @c end example spmul d2t_singular/gaussman_lib.doc:739
gaussman_lib.tex(,1091) @end smallexample
gaussman_lib.tex(,1092) @c ---end content spmul---
gaussman_lib.tex(,1093) 
gaussman_lib.tex(,1094) @c ------------------- spissemicont -------------
gaussman_lib.tex(,1095) @node spissemicont, spsemicont, spmul, gaussman_lib
gaussman_lib.tex(,1096) @subsubsection spissemicont
gaussman_lib.tex(,1097) @cindex spissemicont
gaussman_lib.tex(,1098) @c ---content spissemicont---
gaussman_lib.tex(,1099) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,1100) 
gaussman_lib.tex(,1101) @table @asis
gaussman_lib.tex(,1102) @item @strong{Usage:}
gaussman_lib.tex(,1103) spissemicont(sp[,1]); list sp, int opt
gaussman_lib.tex(,1104) 
gaussman_lib.tex(,1105) @item @strong{Return:}
gaussman_lib.tex(,1106) @format
gaussman_lib.tex(,1107) int k=
gaussman_lib.tex(,1108)   1;  if sum of sp is positive on all intervals [a,a+1) [and (a,a+1)]
gaussman_lib.tex(,1109)   0;  if sum of sp is negative on some interval [a,a+1) [or (a,a+1)]
gaussman_lib.tex(,1110) @end format
gaussman_lib.tex(,1111) 
gaussman_lib.tex(,1112) @end table
gaussman_lib.tex(,1113) @strong{Example:}
gaussman_lib.tex(,1114) @smallexample
gaussman_lib.tex(,1115) @c computed example spissemicont d2t_singular/gaussman_lib.doc:775 
gaussman_lib.tex(,1116) LIB "gaussman.lib";
gaussman_lib.tex(,1117) ring R=0,(x,y),ds;
gaussman_lib.tex(,1118) list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,1119) spprint(sp1);
gaussman_lib.tex(,1120) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,1121) list sp2=list(ideal(-1/6,1/6),intvec(1,1));
gaussman_lib.tex(,1122) spprint(sp2);
gaussman_lib.tex(,1123) @expansion{} (-1/6,1),(1/6,1)
gaussman_lib.tex(,1124) spissemicont(spsub(sp1,spmul(sp2,3)));
gaussman_lib.tex(,1125) @expansion{} 1
gaussman_lib.tex(,1126) spissemicont(spsub(sp1,spmul(sp2,4)));
gaussman_lib.tex(,1127) @expansion{} 0
gaussman_lib.tex(,1128) @c end example spissemicont d2t_singular/gaussman_lib.doc:775
gaussman_lib.tex(,1129) @end smallexample
gaussman_lib.tex(,1130) @c ---end content spissemicont---
gaussman_lib.tex(,1131) 
gaussman_lib.tex(,1132) @c ------------------- spsemicont -------------
gaussman_lib.tex(,1133) @node spsemicont, spmilnor, spissemicont, gaussman_lib
gaussman_lib.tex(,1134) @subsubsection spsemicont
gaussman_lib.tex(,1135) @cindex spsemicont
gaussman_lib.tex(,1136) @c ---content spsemicont---
gaussman_lib.tex(,1137) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,1138) 
gaussman_lib.tex(,1139) @table @asis
gaussman_lib.tex(,1140) @item @strong{Usage:}
gaussman_lib.tex(,1141) spsemicont(sp0,sp,k[,1]); list sp0, list sp
gaussman_lib.tex(,1142) 
gaussman_lib.tex(,1143) @item @strong{Return:}
gaussman_lib.tex(,1144) @format
gaussman_lib.tex(,1145) list l;
gaussman_lib.tex(,1146)   intvec l[i];  if the spectra sp0 occur with multiplicities k
gaussman_lib.tex(,1147)                 in a deformation of a [quasihomogeneous] singularity
gaussman_lib.tex(,1148)                 with spectrum sp then k<=l[i]
gaussman_lib.tex(,1149) @end format
gaussman_lib.tex(,1150) 
gaussman_lib.tex(,1151) @end table
gaussman_lib.tex(,1152) @strong{Example:}
gaussman_lib.tex(,1153) @smallexample
gaussman_lib.tex(,1154) @c computed example spsemicont d2t_singular/gaussman_lib.doc:810 
gaussman_lib.tex(,1155) LIB "gaussman.lib";
gaussman_lib.tex(,1156) ring R=0,(x,y),ds;
gaussman_lib.tex(,1157) list sp0=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,1158) spprint(sp0);
gaussman_lib.tex(,1159) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,1160) list sp1=list(ideal(-1/6,1/6),intvec(1,1));
gaussman_lib.tex(,1161) spprint(sp1);
gaussman_lib.tex(,1162) @expansion{} (-1/6,1),(1/6,1)
gaussman_lib.tex(,1163) list sp2=list(ideal(-1/3,0,1/3),intvec(1,2,1));
gaussman_lib.tex(,1164) spprint(sp2);
gaussman_lib.tex(,1165) @expansion{} (-1/3,1),(0,2),(1/3,1)
gaussman_lib.tex(,1166) list sp=sp1,sp2;
gaussman_lib.tex(,1167) list l=spsemicont(sp0,sp);
gaussman_lib.tex(,1168) l;
gaussman_lib.tex(,1169) @expansion{} [1]:
gaussman_lib.tex(,1170) @expansion{}    3
gaussman_lib.tex(,1171) @expansion{} [2]:
gaussman_lib.tex(,1172) @expansion{}    2,1
gaussman_lib.tex(,1173) spissemicont(spsub(sp0,spmul(sp,l[1])));
gaussman_lib.tex(,1174) @expansion{} 1
gaussman_lib.tex(,1175) spissemicont(spsub(sp0,spmul(sp,l[1]-1)));
gaussman_lib.tex(,1176) @expansion{} 1
gaussman_lib.tex(,1177) spissemicont(spsub(sp0,spmul(sp,l[1]+1)));
gaussman_lib.tex(,1178) @expansion{} 0
gaussman_lib.tex(,1179) @c end example spsemicont d2t_singular/gaussman_lib.doc:810
gaussman_lib.tex(,1180) @end smallexample
gaussman_lib.tex(,1181) @c ---end content spsemicont---
gaussman_lib.tex(,1182) 
gaussman_lib.tex(,1183) @c ------------------- spmilnor -------------
gaussman_lib.tex(,1184) @node spmilnor, spgeomgenus, spsemicont, gaussman_lib
gaussman_lib.tex(,1185) @subsubsection spmilnor
gaussman_lib.tex(,1186) @cindex spmilnor
gaussman_lib.tex(,1187) @c ---content spmilnor---
gaussman_lib.tex(,1188) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,1189) 
gaussman_lib.tex(,1190) @table @asis
gaussman_lib.tex(,1191) @item @strong{Usage:}
gaussman_lib.tex(,1192) spmilnor(sp); list sp
gaussman_lib.tex(,1193) 
gaussman_lib.tex(,1194) @item @strong{Return:}
gaussman_lib.tex(,1195) int mu; Milnor number of spectrum sp
gaussman_lib.tex(,1196) 
gaussman_lib.tex(,1197) @end table
gaussman_lib.tex(,1198) @strong{Example:}
gaussman_lib.tex(,1199) @smallexample
gaussman_lib.tex(,1200) @c computed example spmilnor d2t_singular/gaussman_lib.doc:846 
gaussman_lib.tex(,1201) LIB "gaussman.lib";
gaussman_lib.tex(,1202) ring R=0,(x,y),ds;
gaussman_lib.tex(,1203) list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,1204) spprint(sp);
gaussman_lib.tex(,1205) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,1206) spmilnor(sp);
gaussman_lib.tex(,1207) @expansion{} 11
gaussman_lib.tex(,1208) @c end example spmilnor d2t_singular/gaussman_lib.doc:846
gaussman_lib.tex(,1209) @end smallexample
gaussman_lib.tex(,1210) @c ---end content spmilnor---
gaussman_lib.tex(,1211) 
gaussman_lib.tex(,1212) @c ------------------- spgeomgenus -------------
gaussman_lib.tex(,1213) @node spgeomgenus, spgamma, spmilnor, gaussman_lib
gaussman_lib.tex(,1214) @subsubsection spgeomgenus
gaussman_lib.tex(,1215) @cindex spgeomgenus
gaussman_lib.tex(,1216) @c ---content spgeomgenus---
gaussman_lib.tex(,1217) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,1218) 
gaussman_lib.tex(,1219) @table @asis
gaussman_lib.tex(,1220) @item @strong{Usage:}
gaussman_lib.tex(,1221) spgeomgenus(sp); list sp
gaussman_lib.tex(,1222) 
gaussman_lib.tex(,1223) @item @strong{Return:}
gaussman_lib.tex(,1224) int g; geometrical genus of spectrum sp
gaussman_lib.tex(,1225) 
gaussman_lib.tex(,1226) @end table
gaussman_lib.tex(,1227) @strong{Example:}
gaussman_lib.tex(,1228) @smallexample
gaussman_lib.tex(,1229) @c computed example spgeomgenus d2t_singular/gaussman_lib.doc:873 
gaussman_lib.tex(,1230) LIB "gaussman.lib";
gaussman_lib.tex(,1231) ring R=0,(x,y),ds;
gaussman_lib.tex(,1232) list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,1233) spprint(sp);
gaussman_lib.tex(,1234) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,1235) spgeomgenus(sp);
gaussman_lib.tex(,1236) @expansion{} 6
gaussman_lib.tex(,1237) @c end example spgeomgenus d2t_singular/gaussman_lib.doc:873
gaussman_lib.tex(,1238) @end smallexample
gaussman_lib.tex(,1239) @c ---end content spgeomgenus---
gaussman_lib.tex(,1240) 
gaussman_lib.tex(,1241) @c ------------------- spgamma -------------
gaussman_lib.tex(,1242) @node spgamma,, spgeomgenus, gaussman_lib
gaussman_lib.tex(,1243) @subsubsection spgamma
gaussman_lib.tex(,1244) @cindex spgamma
gaussman_lib.tex(,1245) @c ---content spgamma---
gaussman_lib.tex(,1246) Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).
gaussman_lib.tex(,1247) 
gaussman_lib.tex(,1248) @table @asis
gaussman_lib.tex(,1249) @item @strong{Usage:}
gaussman_lib.tex(,1250) spgamma(sp); list sp
gaussman_lib.tex(,1251) 
gaussman_lib.tex(,1252) @item @strong{Return:}
gaussman_lib.tex(,1253) number gamma; gamma invariant of spectrum sp
gaussman_lib.tex(,1254) 
gaussman_lib.tex(,1255) @end table
gaussman_lib.tex(,1256) @strong{Example:}
gaussman_lib.tex(,1257) @smallexample
gaussman_lib.tex(,1258) @c computed example spgamma d2t_singular/gaussman_lib.doc:900 
gaussman_lib.tex(,1259) LIB "gaussman.lib";
gaussman_lib.tex(,1260) ring R=0,(x,y),ds;
gaussman_lib.tex(,1261) list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
gaussman_lib.tex(,1262) spprint(sp);
gaussman_lib.tex(,1263) @expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
gaussman_lib.tex(,1264) spgamma(sp);
gaussman_lib.tex(,1265) @expansion{} 1/240
gaussman_lib.tex(,1266) @c end example spgamma d2t_singular/gaussman_lib.doc:900
gaussman_lib.tex(,1267) @end smallexample
gaussman_lib.tex(,1268) @c ---end content spgamma---
singular.texi(,470) @c ---------------------------------------------------------
singular.texi(,471) @node hnoether_lib, mondromy_lib, gaussman_lib, Singularities
singular.texi(,472) @subsection hnoether_lib
singular.texi(,473) @c include of docu for hnoether.lib
hnoether_lib.tex(,1) @c ---content LibInfo---
hnoether_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/hnoether_lib.doc
hnoether_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/hnoether_lib.doc INSTEAD
hnoether_lib.tex(,4) @c library version: (1.29.2.14,2002/10/21)
hnoether_lib.tex(,5) @c library file: ../Singular/LIB/hnoether.lib
hnoether_lib.tex(,6) @cindex hnoether.lib
hnoether_lib.tex(,7) @cindex hnoether_lib
hnoether_lib.tex(,8) @table @asis
hnoether_lib.tex(,9) @item @strong{Library:}
hnoether_lib.tex(,10) hnoether.lib
hnoether_lib.tex(,11) @item @strong{Purpose:}
hnoether_lib.tex(,12)    Hamburger-Noether (Puiseux) Development
hnoether_lib.tex(,13) @item @strong{Author:}
hnoether_lib.tex(,14) Martin Lamm, lamm@@mathematik.uni-kl.de
hnoether_lib.tex(,15) 
hnoether_lib.tex(,16) @item @strong{Overview:}
hnoether_lib.tex(,17) A library for computing the Hamburger-Noether, resp. Puiseux, development
hnoether_lib.tex(,18) of a plane curve singularity following [Campillo, A.: Algebroid curves
hnoether_lib.tex(,19) in positive characteristic, Springer LNM 813 (1980)]. @*
hnoether_lib.tex(,20) The library contains also procedures for computing the (topological)
hnoether_lib.tex(,21) numerical invariants of plane curve singularities.
hnoether_lib.tex(,22) 
hnoether_lib.tex(,23) @end table
hnoether_lib.tex(,24) 
hnoether_lib.tex(,25) @strong{Main procedures:}
hnoether_lib.tex(,26) @menu
hnoether_lib.tex(,27) * hnexpansion:: Hamburger-Noether (H-N) development of f
hnoether_lib.tex(,28) * sethnering:: changes to the hnering created by hnexpansion
hnoether_lib.tex(,29) * develop:: H-N development of irreducible curves
hnoether_lib.tex(,30) * extdevelop:: extension of the H-N development hne of f
hnoether_lib.tex(,31) * parametrisation:: a parametrization of f
hnoether_lib.tex(,32) * displayHNE:: display H-N development as an ideal
hnoether_lib.tex(,33) * invariants:: invariants of f, e.g. the characteristic exponents
hnoether_lib.tex(,34) * displayInvariants:: display invariants of f
hnoether_lib.tex(,35) * multsequence:: sequence of multiplicities
hnoether_lib.tex(,36) * displayMultsequence:: display sequence of multiplicities
hnoether_lib.tex(,37) * intersection:: intersection multiplicity of two curves
hnoether_lib.tex(,38) * stripHNE:: reduce amount of memory consumed by hne
hnoether_lib.tex(,39) * is_irred:: test if f is irreducible
hnoether_lib.tex(,40) * delta:: delta invariant of f
hnoether_lib.tex(,41) * newtonpoly:: (local) Newton polygon of f
hnoether_lib.tex(,42) * is_NND:: test if f is Newton non-degenerate
hnoether_lib.tex(,43) @end menu
hnoether_lib.tex(,44) @strong{Auxiliary procedures:}
hnoether_lib.tex(,45) @menu
hnoether_lib.tex(,46) * puiseux2generators:: convert Puiseux pairs to generators of semigroup
hnoether_lib.tex(,47) * separateHNE:: number of quadratic transf. needed for separation
hnoether_lib.tex(,48) * squarefree:: a squarefree divisor of the poly f
hnoether_lib.tex(,49) * allsquarefree:: the maximal squarefree divisor of the poly f
hnoether_lib.tex(,50) * further_hn_proc:: show further procedures useful for interactive use
hnoether_lib.tex(,51) @end menu
hnoether_lib.tex(,52) @cindex Hamburger-Noether expansion
hnoether_lib.tex(,53) @cindex Puiseux expansion
hnoether_lib.tex(,54) @cindex curve singularities
hnoether_lib.tex(,55) @c ---end content LibInfo---
hnoether_lib.tex(,56) 
hnoether_lib.tex(,57) @c ------------------- hnexpansion -------------
hnoether_lib.tex(,58) @node hnexpansion, sethnering,, hnoether_lib
hnoether_lib.tex(,59) @subsubsection hnexpansion
hnoether_lib.tex(,60) @cindex hnexpansion
hnoether_lib.tex(,61) @c ---content hnexpansion---
hnoether_lib.tex(,62) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,63) 
hnoether_lib.tex(,64) @table @asis
hnoether_lib.tex(,65) @item @strong{Usage:}
hnoether_lib.tex(,66) hnexpansion(f); or hnexpansion(f,"ess"); f poly
hnoether_lib.tex(,67) 
hnoether_lib.tex(,68) @item @strong{Usage:}
hnoether_lib.tex(,69) hnexpansion(f); f poly
hnoether_lib.tex(,70) 
hnoether_lib.tex(,71) @item @strong{Assume:}
hnoether_lib.tex(,72) f is a bivariate polynomial (in the first 2 ring variables)
hnoether_lib.tex(,73) 
hnoether_lib.tex(,74) @item @strong{Create:}
hnoether_lib.tex(,75) ring with variables @code{x,y} and ordering @code{ls} over a
hnoether_lib.tex(,76) field extension of the current basering's ground field, 
hnoether_lib.tex(,77) since the Hamburger-Noether development usually does not exist
hnoether_lib.tex(,78) in the originally given basering. The field extension is chosen
hnoether_lib.tex(,79) minimally.@*
hnoether_lib.tex(,80) Moreover, in the ring a list @code{hne} of lists @code{hne[i]} is
hnoether_lib.tex(,81) created (corresponding to the output of @code{develop(f[i])},
hnoether_lib.tex(,82) f[i] a branch of f, but the last entry being omitted).
hnoether_lib.tex(,83) 
hnoether_lib.tex(,84) @table @asis
hnoether_lib.tex(,85) @item @code{hne[i][1]}; matrix:
hnoether_lib.tex(,86)          Each row contains the coefficients of the corresponding line of the
hnoether_lib.tex(,87)          Hamburger-Noether expansion (HNE) for f[i]. The end of the line is
hnoether_lib.tex(,88)          marked in the matrix by the first ring variable (usually x).
hnoether_lib.tex(,89) @item @code{hne[i][2]}; intvec:
hnoether_lib.tex(,90)          indicating the length of lines of the HNE
hnoether_lib.tex(,91) @item @code{hne[i][3]}; int:
hnoether_lib.tex(,92)          0  if the 1st ring variable was transversal (with respect to f[i]), @*
hnoether_lib.tex(,93)          1  if the variables were changed at the beginning of the
hnoether_lib.tex(,94)             computation, @*
hnoether_lib.tex(,95)         -1  if an error has occurred.
hnoether_lib.tex(,96) @item @code{hne[i][4]}; poly:
hnoether_lib.tex(,97)          the transformed polynomial of f[i] to make it possible to extend the
hnoether_lib.tex(,98)          Hamburger-Noether development a posteriori without having to do
hnoether_lib.tex(,99)          all the previous calculation once again (0 if not needed)
hnoether_lib.tex(,100) @end table
hnoether_lib.tex(,101) 
hnoether_lib.tex(,102) @item @strong{Return:}
hnoether_lib.tex(,103) a list, say @code{hn}, containing the created ring
hnoether_lib.tex(,104) 
hnoether_lib.tex(,105) @item @strong{Note:}
hnoether_lib.tex(,106) to use the ring type: @code{def HNEring=hn[i]; setring HNEring;}.
hnoether_lib.tex(,107) @*
hnoether_lib.tex(,108) If f is known to be irreducible as a power series, @code{develop(f)}
hnoether_lib.tex(,109) could be chosen instead to avoid the change of basering. @*
hnoether_lib.tex(,110) Increasing @code{printlevel} leads to more and more comments.
hnoether_lib.tex(,111) 
hnoether_lib.tex(,112) @item @strong{Usage:}
hnoether_lib.tex(,113) hnexpansion(f,"ess"); f poly
hnoether_lib.tex(,114) 
hnoether_lib.tex(,115) @item @strong{Assume:}
hnoether_lib.tex(,116) f is a bivariate polynomial (in the first 2 ring variables)
hnoether_lib.tex(,117) 
hnoether_lib.tex(,118) @item @strong{Create:}
hnoether_lib.tex(,119) ring with variables @code{x,y} and ordering @code{ls} over a
hnoether_lib.tex(,120) field extension of the current basering's ground field, 
hnoether_lib.tex(,121) since the Hamburger-Noether development usually does not exist
hnoether_lib.tex(,122) in the originally given basering. The field extension is chosen
hnoether_lib.tex(,123) minimally.
hnoether_lib.tex(,124) @*
hnoether_lib.tex(,125) Moreover, in the ring a list @code{hne} of lists @code{hne[i]} is
hnoether_lib.tex(,126) created (corresponding to the output of @code{develop(f[i])}, f[i] an
hnoether_lib.tex(,127) "essential" branch of f, but the last entry being omitted). See
hnoether_lib.tex(,128) @code{hnexpansion} above for more details.
hnoether_lib.tex(,129) 
hnoether_lib.tex(,130) @item @strong{Return:}
hnoether_lib.tex(,131) a list, say @code{hn}, containing the created ring
hnoether_lib.tex(,132) 
hnoether_lib.tex(,133) @item @strong{Note:}
hnoether_lib.tex(,134) to use the ring type: @code{def hnering=hn[i]; setring hnering;}.
hnoether_lib.tex(,135) @*
hnoether_lib.tex(,136) Alternatively you may use the procedure sethnering and type:
hnoether_lib.tex(,137) @code{sethnering(hn);}
hnoether_lib.tex(,138) @*
hnoether_lib.tex(,139) If the HNE needs a field extension, some of the branches will be
hnoether_lib.tex(,140) conjugate. In this case @code{hnexpansion(f,"ess")} reduces the
hnoether_lib.tex(,141) computation to one representative for each group of conjugate
hnoether_lib.tex(,142) branches.@*
hnoether_lib.tex(,143) Note that the degree of each branch is in general less than the degree
hnoether_lib.tex(,144) of the field extension in which all HNEs can be put.@*
hnoether_lib.tex(,145) Use @code{hnexpansion(f)} to compute a complete HNE, i.e., a HNE for
hnoether_lib.tex(,146) all branches.@*
hnoether_lib.tex(,147) Increasing @code{printlevel} leads to more and more comments.
hnoether_lib.tex(,148) 
hnoether_lib.tex(,149) @end table
hnoether_lib.tex(,150) @strong{Example:}
hnoether_lib.tex(,151) @smallexample
hnoether_lib.tex(,152) @c computed example hnexpansion d2t_singular/hnoether_lib.doc:150 
hnoether_lib.tex(,153) LIB "hnoether.lib";
hnoether_lib.tex(,154) ring r=0,(x,y),ls;
hnoether_lib.tex(,155) list hn=hnexpansion(x4-y6);
hnoether_lib.tex(,156) show(hn);
hnoether_lib.tex(,157) @expansion{} // list, 1 element(s):
hnoether_lib.tex(,158) @expansion{} [1]:
hnoether_lib.tex(,159) @expansion{}    // ring: (0),(x,y),(ls(2),C);
hnoether_lib.tex(,160) @expansion{}    // minpoly = 0
hnoether_lib.tex(,161) @expansion{} // objects belonging to this ring:
hnoether_lib.tex(,162) @expansion{} // hne                  [0]  list, size: 2
hnoether_lib.tex(,163) def hnering=hn[1];
hnoether_lib.tex(,164) setring hnering;
hnoether_lib.tex(,165) size(hne);           // number of branches
hnoether_lib.tex(,166) @expansion{} 2
hnoether_lib.tex(,167) print(hne[1][1]);    // HN-matrix of 1st branch
hnoether_lib.tex(,168) @expansion{} 0,x,0,
hnoether_lib.tex(,169) @expansion{} 0,1,x 
hnoether_lib.tex(,170) parametrisation(hne);    // parametrization of the two branches
hnoether_lib.tex(,171) @expansion{} [1]:
hnoether_lib.tex(,172) @expansion{}    _[1]=x3
hnoether_lib.tex(,173) @expansion{}    _[2]=x2
hnoether_lib.tex(,174) @expansion{} [2]:
hnoether_lib.tex(,175) @expansion{}    _[1]=-x3
hnoether_lib.tex(,176) @expansion{}    _[2]=-x2
hnoether_lib.tex(,177) /////////////////////////////////////////////////////////
hnoether_lib.tex(,178) ring s=2,(x,y),ls;
hnoether_lib.tex(,179) poly f=(x4+x2y+y2)*(x3+xy2+y3);
hnoether_lib.tex(,180) // --------- compute all branches: ---------
hnoether_lib.tex(,181) hn=hnexpansion(f);
hnoether_lib.tex(,182) @expansion{} // new minimal polynomial: a6+a5+a3+a2+1
hnoether_lib.tex(,183) hnering=hn[1];
hnoether_lib.tex(,184) setring hnering;
hnoether_lib.tex(,185) displayHNE(hne[1]);   // HN-matrix of 1st branch
hnoether_lib.tex(,186) @expansion{} HNE[1]=y+(a^4+a+1)*z(0)
hnoether_lib.tex(,187) @expansion{} HNE[2]=x+z(0)
hnoether_lib.tex(,188) displayHNE(hne[4]);   // HN-matrix of 4th branch
hnoether_lib.tex(,189) @expansion{} HNE[1]=y+(a^4+a^2+a+1)*z(0)^2
hnoether_lib.tex(,190) @expansion{} HNE[2]=x+z(0)
hnoether_lib.tex(,191) setring s;
hnoether_lib.tex(,192) // --- compute only one of conjugate branches: ---
hnoether_lib.tex(,193) hn=hnexpansion(f,"ess");
hnoether_lib.tex(,194) @expansion{} // new minimal polynomial: a6+a5+a3+a2+1
hnoether_lib.tex(,195) hnering=hn[1];
hnoether_lib.tex(,196) setring hnering;
hnoether_lib.tex(,197) displayHNE(hne);
hnoether_lib.tex(,198) @expansion{} // Hamburger-Noether development of branch nr.1:
hnoether_lib.tex(,199) @expansion{} HNE[1]=y+(a^4+a^2)*z(0)
hnoether_lib.tex(,200) @expansion{} HNE[2]=x+z(0)
hnoether_lib.tex(,201) @expansion{} 
hnoether_lib.tex(,202) @expansion{} // Hamburger-Noether development of branch nr.2:
hnoether_lib.tex(,203) @expansion{} HNE[1]=y+(a^4+a^2+a)*z(0)^2
hnoether_lib.tex(,204) @expansion{} HNE[2]=x+z(0)
hnoether_lib.tex(,205) @expansion{} 
hnoether_lib.tex(,206) // no. 1 of hnexpansion(f,"ess") represents no. 1 - 3 of hnexpansion(f) and
hnoether_lib.tex(,207) // no. 2 of hnexpansion(f,"ess") represents no. 4 + 5 of hnexpansion(f)
hnoether_lib.tex(,208) @c end example hnexpansion d2t_singular/hnoether_lib.doc:150
hnoether_lib.tex(,209) @end smallexample
hnoether_lib.tex(,210) @c inserted refs from d2t_singular/hnoether_lib.doc:179
hnoether_lib.tex(,227) @c end inserted refs from d2t_singular/hnoether_lib.doc:179
hnoether_lib.tex(,228) 
hnoether_lib.tex(,229) @c ---end content hnexpansion---
hnoether_lib.tex(,230) 
hnoether_lib.tex(,231) @c ------------------- sethnering -------------
hnoether_lib.tex(,232) @node sethnering, develop, hnexpansion, hnoether_lib
hnoether_lib.tex(,233) @subsubsection sethnering
hnoether_lib.tex(,234) @cindex sethnering
hnoether_lib.tex(,235) @c ---content sethnering---
hnoether_lib.tex(,236) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,237) 
hnoether_lib.tex(,238) @table @asis
hnoether_lib.tex(,239) @item @strong{Usage:}
hnoether_lib.tex(,240) sethnering(L[,s]); L list, s string (optional)
hnoether_lib.tex(,241) 
hnoether_lib.tex(,242) @item @strong{Assume:}
hnoether_lib.tex(,243) L is a list containing a ring (e.g. the output of @code{hnexpansion}).
hnoether_lib.tex(,244) 
hnoether_lib.tex(,245) @item @strong{Create:}
hnoether_lib.tex(,246) The procedure creates a ring with name given by the optional parameter
hnoether_lib.tex(,247) s resp. with name hnering, if no optional parameter is given, and
hnoether_lib.tex(,248) changes your ring to this ring. The new ring will be the ring given
hnoether_lib.tex(,249) as the first entry in the list L.
hnoether_lib.tex(,250) 
hnoether_lib.tex(,251) @item @strong{Return:}
hnoether_lib.tex(,252) nothing.
hnoether_lib.tex(,253) 
hnoether_lib.tex(,254) @end table
hnoether_lib.tex(,255) @strong{Example:}
hnoether_lib.tex(,256) @smallexample
hnoether_lib.tex(,257) @c computed example sethnering d2t_singular/hnoether_lib.doc:211 
hnoether_lib.tex(,258) LIB "hnoether.lib";
hnoether_lib.tex(,259) // -------- prepare for example ---------
hnoether_lib.tex(,260) if (defined(hnering))
hnoether_lib.tex(,261) @{
hnoether_lib.tex(,262) def rette@@ring=hnering;
hnoether_lib.tex(,263) if (nameof(basering)=="hnering")
hnoether_lib.tex(,264) @{
hnoether_lib.tex(,265) int wechsel=1;
hnoether_lib.tex(,266) @}
hnoether_lib.tex(,267) else
hnoether_lib.tex(,268) @{
hnoether_lib.tex(,269) int wechsel;
hnoether_lib.tex(,270) @}
hnoether_lib.tex(,271) kill hnering;
hnoether_lib.tex(,272) @}
hnoether_lib.tex(,273) // ------ the example starts here -------
hnoether_lib.tex(,274) ring r=0,(x,y),ls;
hnoether_lib.tex(,275) nameof(basering);
hnoether_lib.tex(,276) @expansion{} r
hnoether_lib.tex(,277) sethnering(hnexpansion(x4-y6)); // Creates hnering and changes to it!
hnoether_lib.tex(,278) nameof(basering);
hnoether_lib.tex(,279) @expansion{} hnering
hnoether_lib.tex(,280) // --- restore HNEring if previously defined ---
hnoether_lib.tex(,281) kill hnering;
hnoether_lib.tex(,282) if (defined(rette@@ring)) @{
hnoether_lib.tex(,283) def hnering=rette@@ring;
hnoether_lib.tex(,284) export hnering;
hnoether_lib.tex(,285) if (wechsel==1)
hnoether_lib.tex(,286) @{
hnoether_lib.tex(,287) setring hnering;
hnoether_lib.tex(,288) @}
hnoether_lib.tex(,289) @}
hnoether_lib.tex(,290) @c end example sethnering d2t_singular/hnoether_lib.doc:211
hnoether_lib.tex(,291) @end smallexample
hnoether_lib.tex(,292) @c inserted refs from d2t_singular/hnoether_lib.doc:244
hnoether_lib.tex(,303) @c end inserted refs from d2t_singular/hnoether_lib.doc:244
hnoether_lib.tex(,304) 
hnoether_lib.tex(,305) @c ---end content sethnering---
hnoether_lib.tex(,306) 
hnoether_lib.tex(,307) @c ------------------- develop -------------
hnoether_lib.tex(,308) @node develop, extdevelop, sethnering, hnoether_lib
hnoether_lib.tex(,309) @subsubsection develop
hnoether_lib.tex(,310) @cindex develop
hnoether_lib.tex(,311) @c ---content develop---
hnoether_lib.tex(,312) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,313) 
hnoether_lib.tex(,314) @table @asis
hnoether_lib.tex(,315) @item @strong{Usage:}
hnoether_lib.tex(,316) develop(f [,n]); f poly, n int
hnoether_lib.tex(,317) 
hnoether_lib.tex(,318) @item @strong{Assume:}
hnoether_lib.tex(,319) f is a bivariate polynomial (in the first 2 ring variables) and
hnoether_lib.tex(,320) irreducible as power series (for reducible f use @code{hnexpansion}).
hnoether_lib.tex(,321) 
hnoether_lib.tex(,322) @item @strong{Return:}
hnoether_lib.tex(,323) list @code{L} with:
hnoether_lib.tex(,324) 
hnoether_lib.tex(,325) @table @asis
hnoether_lib.tex(,326) @item @code{L[1]}; matrix:
hnoether_lib.tex(,327)          Each row contains the coefficients of the corresponding line of the
hnoether_lib.tex(,328)          Hamburger-Noether expansion (HNE). The end of the line is marked in
hnoether_lib.tex(,329)          the matrix by the first ring variable (usually x).
hnoether_lib.tex(,330) @item @code{L[2]}; intvec:
hnoether_lib.tex(,331)          indicating the length of lines of the HNE
hnoether_lib.tex(,332) @item @code{L[3]}; int:
hnoether_lib.tex(,333)          0  if the 1st ring variable was transversal (with respect to f), @*
hnoether_lib.tex(,334)          1  if the variables were changed at the beginning of the
hnoether_lib.tex(,335)             computation, @*
hnoether_lib.tex(,336)         -1  if an error has occurred.
hnoether_lib.tex(,337) @item @code{L[4]}; poly:
hnoether_lib.tex(,338)          the transformed polynomial of f to make it possible to extend the
hnoether_lib.tex(,339)          Hamburger-Noether development a posteriori without having to do
hnoether_lib.tex(,340)          all the previous calculation once again (0 if not needed)
hnoether_lib.tex(,341) @item @code{L[5]}; int:
hnoether_lib.tex(,342)          1  if the curve has exactly one branch (i.e., is irreducible), @*
hnoether_lib.tex(,343)          0  else (i.e., the curve has more than one HNE, or f is not valid).
hnoether_lib.tex(,344) @end table
hnoether_lib.tex(,345) 
hnoether_lib.tex(,346) @item @strong{Display:}
hnoether_lib.tex(,347) The (non zero) elements of the HNE (if not called by another proc).
hnoether_lib.tex(,348) 
hnoether_lib.tex(,349) @item @strong{Note:}
hnoether_lib.tex(,350) The optional parameter @code{n} affects only the computation of
hnoether_lib.tex(,351) the LAST line of the HNE. If it is given, the HN-matrix @code{L[1]}
hnoether_lib.tex(,352) will have at least @code{n} columns. @*
hnoether_lib.tex(,353) Otherwise, the number of columns will be chosen minimal such that the
hnoether_lib.tex(,354) matrix contains all necessary information (i.e., all lines of the HNE
hnoether_lib.tex(,355) but the last (which is in general infinite) have place). @*
hnoether_lib.tex(,356) If @code{n} is negative, the algorithm is stopped as soon as the
hnoether_lib.tex(,357) computed information is sufficient for @code{invariants(L)}, but the
hnoether_lib.tex(,358) HN-matrix @code{L[1]} may still contain undetermined elements, which
hnoether_lib.tex(,359) are marked with the 2nd variable (of the basering). @*
hnoether_lib.tex(,360) For time critical computations it is recommended to use
hnoether_lib.tex(,361) @code{ring ...,(x,y),ls} as basering - it increases the algorithm's
hnoether_lib.tex(,362) speed. @*
hnoether_lib.tex(,363) If @code{printlevel>=0} comments are displayed (default is
hnoether_lib.tex(,364) @code{printlevel=0}).
hnoether_lib.tex(,365) 
hnoether_lib.tex(,366) @end table
hnoether_lib.tex(,367) @strong{Example:}
hnoether_lib.tex(,368) @smallexample
hnoether_lib.tex(,369) @c computed example develop d2t_singular/hnoether_lib.doc:312 
hnoether_lib.tex(,370) LIB "hnoether.lib";
hnoether_lib.tex(,371) ring exring = 7,(x,y),ds;
hnoether_lib.tex(,372) list hne=develop(4x98+2x49y7+x11y14+2y14);
hnoether_lib.tex(,373) print(hne[1]);
hnoether_lib.tex(,374) @expansion{} 0,0, 0,0,0,0,3,x,
hnoether_lib.tex(,375) @expansion{} 0,x, 0,0,0,0,0,0,
hnoether_lib.tex(,376) @expansion{} 0,0, 0,x,0,0,0,0,
hnoether_lib.tex(,377) @expansion{} 0,x, 0,0,0,0,0,0,
hnoether_lib.tex(,378) @expansion{} 0,-1,0,0,0,0,0,0 
hnoether_lib.tex(,379) // therefore the HNE is:
hnoether_lib.tex(,380) // z(-1)= 3*z(0)^7 + z(0)^7*z(1),
hnoether_lib.tex(,381) // z(0) = z(1)*z(2),       (there is 1 zero in the 2nd row before x)
hnoether_lib.tex(,382) // z(1) = z(2)^3*z(3),     (there are 3 zeroes in the 3rd row)
hnoether_lib.tex(,383) // z(2) = z(3)*z(4),
hnoether_lib.tex(,384) // z(3) = -z(4)^2 + 0*z(4)^3 +...+ 0*z(4)^8 + ?*z(4)^9 + ...
hnoether_lib.tex(,385) // (the missing x in the last line indicates that it is not complete.)
hnoether_lib.tex(,386) hne[2];
hnoether_lib.tex(,387) @expansion{} 7,1,3,1,-1
hnoether_lib.tex(,388) parametrisation(hne);
hnoether_lib.tex(,389) @expansion{} [1]:
hnoether_lib.tex(,390) @expansion{}    _[1]=-x14
hnoether_lib.tex(,391) @expansion{}    _[2]=-3x98-x109
hnoether_lib.tex(,392) // parametrization:   x(t)= -t^14+O(t^21),  y(t)= -3t^98+O(t^105)
hnoether_lib.tex(,393) // (the term -t^109 in y may have a wrong coefficient)
hnoether_lib.tex(,394) displayHNE(hne);
hnoether_lib.tex(,395) @expansion{} HNE[1]=-y+3*z(0)^7+z(0)^7*z(1)
hnoether_lib.tex(,396) @expansion{} HNE[2]=-x+z(1)*z(2)
hnoether_lib.tex(,397) @expansion{} HNE[3]=z(2)^3*z(3)
hnoether_lib.tex(,398) @expansion{} HNE[4]=z(3)*z(4)
hnoether_lib.tex(,399) @expansion{} HNE[5]=-z(4)^2
hnoether_lib.tex(,400) @c end example develop d2t_singular/hnoether_lib.doc:312
hnoether_lib.tex(,401) @end smallexample
hnoether_lib.tex(,402) @c inserted refs from d2t_singular/hnoether_lib.doc:331
hnoether_lib.tex(,417) @c end inserted refs from d2t_singular/hnoether_lib.doc:331
hnoether_lib.tex(,418) 
hnoether_lib.tex(,419) @c ---end content develop---
hnoether_lib.tex(,420) 
hnoether_lib.tex(,421) @c ------------------- extdevelop -------------
hnoether_lib.tex(,422) @node extdevelop, parametrisation, develop, hnoether_lib
hnoether_lib.tex(,423) @subsubsection extdevelop
hnoether_lib.tex(,424) @cindex extdevelop
hnoether_lib.tex(,425) @c ---content extdevelop---
hnoether_lib.tex(,426) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,427) 
hnoether_lib.tex(,428) @table @asis
hnoether_lib.tex(,429) @item @strong{Usage:}
hnoether_lib.tex(,430) extdevelop(L,N); list L, int N
hnoether_lib.tex(,431) 
hnoether_lib.tex(,432) @item @strong{Assume:}
hnoether_lib.tex(,433) L is the output of @code{develop(f)}, or of @code{extdevelop(l,n)},
hnoether_lib.tex(,434) or one entry in the list @code{hne} in the ring created by
hnoether_lib.tex(,435) @code{hnexpansion(f[,"ess"])}.
hnoether_lib.tex(,436) 
hnoether_lib.tex(,437) @item @strong{Return:}
hnoether_lib.tex(,438) an extension of the Hamburger-Noether development of f as a list
hnoether_lib.tex(,439) in the same format as L has (up to the last entry in the output
hnoether_lib.tex(,440) of @code{develop(f)}).@*
hnoether_lib.tex(,441) Type @code{help develop;}, resp. @code{help hnexpansion;} for more
hnoether_lib.tex(,442) details.
hnoether_lib.tex(,443) 
hnoether_lib.tex(,444) @item @strong{Note:}
hnoether_lib.tex(,445) The new HN-matrix will have at least N columns (if the HNE is not
hnoether_lib.tex(,446) finite). In particular, if f is irreducible then (in most cases)
hnoether_lib.tex(,447) @code{extdevelop(develop(f),N)} will produce the same result as
hnoether_lib.tex(,448) @code{develop(f,N)}.@*
hnoether_lib.tex(,449) If the matrix M of L has n columns then, compared with
hnoether_lib.tex(,450) @code{parametrisation(L)}, @code{paramametrize(extdevelop(L,N))} will increase the
hnoether_lib.tex(,451) exactness by at least (N-n) more significant monomials.
hnoether_lib.tex(,452) 
hnoether_lib.tex(,453) @end table
hnoether_lib.tex(,454) @strong{Example:}
hnoether_lib.tex(,455) @smallexample
hnoether_lib.tex(,456) @c computed example extdevelop d2t_singular/hnoether_lib.doc:372 
hnoether_lib.tex(,457) LIB "hnoether.lib";
hnoether_lib.tex(,458) if (defined(HNEring))
hnoether_lib.tex(,459) @{
hnoether_lib.tex(,460) def save_r_i_n_g=HNEring;
hnoether_lib.tex(,461) kill HNEring;
hnoether_lib.tex(,462) @}
hnoether_lib.tex(,463) // ------ the example starts here -------
hnoether_lib.tex(,464) ring exring=0,(x,y),dp;
hnoether_lib.tex(,465) list hn=hnexpansion(x14-3y2x11-y3x10-y2x9+3y4x8+y5x7+3y4x6+x5*(-y6+y5)
hnoether_lib.tex(,466) -3y6x3-y7x2+y8);
hnoether_lib.tex(,467) def HNEring=hn[1];
hnoether_lib.tex(,468) setring HNEring;  
hnoether_lib.tex(,469) export(HNEring);  
hnoether_lib.tex(,470) @expansion{} // ** `HNEring` is already global
hnoether_lib.tex(,471) print(hne[1][1]);    // HNE of 1st branch is finite
hnoether_lib.tex(,472) @expansion{} 0,x,0,
hnoether_lib.tex(,473) @expansion{} 0,1,x 
hnoether_lib.tex(,474) print(extdevelop(hne[1],5)[1]);
hnoether_lib.tex(,475) @expansion{}  No extension is possible
hnoether_lib.tex(,476) @expansion{} 0,x,0,
hnoether_lib.tex(,477) @expansion{} 0,1,x 
hnoether_lib.tex(,478) print(hne[2][1]);    // HNE of 2nd branch can be extended
hnoether_lib.tex(,479) @expansion{} 0,x,0,
hnoether_lib.tex(,480) @expansion{} 0,1,x,
hnoether_lib.tex(,481) @expansion{} 0,1,-1
hnoether_lib.tex(,482) list ehne=extdevelop(hne[2],5);
hnoether_lib.tex(,483) print(ehne[1]);      // new HN-matrix has 5 columns
hnoether_lib.tex(,484) @expansion{} 0,x,0, 0,0,
hnoether_lib.tex(,485) @expansion{} 0,1,x, 0,0,
hnoether_lib.tex(,486) @expansion{} 0,1,-1,1,-1
hnoether_lib.tex(,487) parametrisation(hne[2]);
hnoether_lib.tex(,488) @expansion{} [1]:
hnoether_lib.tex(,489) @expansion{}    _[1]=x4-x5-x6+x7
hnoether_lib.tex(,490) @expansion{}    _[2]=x6-2x7+2x9-x10
hnoether_lib.tex(,491) parametrisation(ehne);
hnoether_lib.tex(,492) @expansion{} [1]:
hnoether_lib.tex(,493) @expansion{}    _[1]=x4-x5+x6-x7-x8+x9-x10+x11
hnoether_lib.tex(,494) @expansion{}    _[2]=x6-2x7+3x8-4x9+2x10-2x12+4x13-3x14+2x15-x16
hnoether_lib.tex(,495) if (defined(save_r_i_n_g))
hnoether_lib.tex(,496) @{
hnoether_lib.tex(,497) kill HNEring;
hnoether_lib.tex(,498) def HNEring=save_r_i_n_g;
hnoether_lib.tex(,499) @}
hnoether_lib.tex(,500) @c end example extdevelop d2t_singular/hnoether_lib.doc:372
hnoether_lib.tex(,501) @end smallexample
hnoether_lib.tex(,502) @c inserted refs from d2t_singular/hnoether_lib.doc:400
hnoether_lib.tex(,517) @c end inserted refs from d2t_singular/hnoether_lib.doc:400
hnoether_lib.tex(,518) 
hnoether_lib.tex(,519) @c ---end content extdevelop---
hnoether_lib.tex(,520) 
hnoether_lib.tex(,521) @c ------------------- parametrisation -------------
hnoether_lib.tex(,522) @node parametrisation, displayHNE, extdevelop, hnoether_lib
hnoether_lib.tex(,523) @subsubsection parametrisation
hnoether_lib.tex(,524) @cindex parametrisation
hnoether_lib.tex(,525) @c ---content parametrisation---
hnoether_lib.tex(,526) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,527) 
hnoether_lib.tex(,528) @table @asis
hnoether_lib.tex(,529) @item @strong{Usage:}
hnoether_lib.tex(,530) parametrisation(INPUT [,x]); INPUT list or poly, x int (optional)
hnoether_lib.tex(,531) 
hnoether_lib.tex(,532) @item @strong{Assume:}
hnoether_lib.tex(,533) INPUT is either a bivariate polynomial f defining a plane curve
hnoether_lib.tex(,534) singularity, or it is the output of @code{hnexpansion(f[,"ess"])},
hnoether_lib.tex(,535) or of @code{develop(f)}, or of @code{extdevelop(develop(f),n)},
hnoether_lib.tex(,536) or the list @@@{hne@} in the ring created by @code{hnexpansion(f)}
hnoether_lib.tex(,537) respectively one entry thereof.
hnoether_lib.tex(,538) 
hnoether_lib.tex(,539) @item @strong{Return:}
hnoether_lib.tex(,540) a list L containing a parametrization L[i] for each branch f[i] of f
hnoether_lib.tex(,541) in the following format: @*
hnoether_lib.tex(,542) - if only the list INPUT is given, L[i] is an ideal of two polynomials
hnoether_lib.tex(,543) p[1],p[2]: if the HNE of was finite then f[i](p[1],p[2])=0; if not,
hnoether_lib.tex(,544) the "real" parametrization will be two power series and p[1],p[2] are
hnoether_lib.tex(,545) truncations of these series.@*
hnoether_lib.tex(,546) - if the optional parameter x is given, L[i] is itself a list:
hnoether_lib.tex(,547) L[i][1] is the parametrization ideal as above and L[i][2] is an intvec
hnoether_lib.tex(,548) with two entries indicating the highest degree up to which the
hnoether_lib.tex(,549) coefficients of the monomials in L[i][1] are exact (entry -1 means that
hnoether_lib.tex(,550) the corresponding parametrization is exact).
hnoether_lib.tex(,551) 
hnoether_lib.tex(,552) @item @strong{Note:}
hnoether_lib.tex(,553) If the basering has only 2 variables, the first variable is chosen
hnoether_lib.tex(,554) as indefinite. Otherwise, the 3rd variable is chosen. @*
hnoether_lib.tex(,555) In case the Hamburger-Noether expansion of the curve f is needed
hnoether_lib.tex(,556) for other purposes as well it is better to calculate this first
hnoether_lib.tex(,557) with the aid of @code{hnexpansion} and use it as input instead of
hnoether_lib.tex(,558) the polynomial itself.
hnoether_lib.tex(,559) 
hnoether_lib.tex(,560) @cindex parametrization
hnoether_lib.tex(,561) @end table
hnoether_lib.tex(,562) @strong{Example:}
hnoether_lib.tex(,563) @smallexample
hnoether_lib.tex(,564) @c computed example parametrisation d2t_singular/hnoether_lib.doc:449 
hnoether_lib.tex(,565) LIB "hnoether.lib";
hnoether_lib.tex(,566) ring exring=0,(x,y,t),ds;
hnoether_lib.tex(,567) // 1st Example: input is a polynomial
hnoether_lib.tex(,568) poly g=(x2-y3)*(x3-y5);
hnoether_lib.tex(,569) parametrisation(g);
hnoether_lib.tex(,570) @expansion{} [1]:
hnoether_lib.tex(,571) @expansion{}    _[1]=t3
hnoether_lib.tex(,572) @expansion{}    _[2]=t2
hnoether_lib.tex(,573) @expansion{} [2]:
hnoether_lib.tex(,574) @expansion{}    _[1]=t5
hnoether_lib.tex(,575) @expansion{}    _[2]=t3
hnoether_lib.tex(,576) // 2nd Example: input is the ring of a Hamburger-Noether expansion
hnoether_lib.tex(,577) poly h=x2-y2-y3;
hnoether_lib.tex(,578) list hn=hnexpansion(h);
hnoether_lib.tex(,579) parametrisation(h,1);
hnoether_lib.tex(,580) @expansion{} [1]:
hnoether_lib.tex(,581) @expansion{}    [1]:
hnoether_lib.tex(,582) @expansion{}       _[1]=t
hnoether_lib.tex(,583) @expansion{}       _[2]=t-1/2t2
hnoether_lib.tex(,584) @expansion{}    [2]:
hnoether_lib.tex(,585) @expansion{}       -1,2
hnoether_lib.tex(,586) @expansion{} [2]:
hnoether_lib.tex(,587) @expansion{}    [1]:
hnoether_lib.tex(,588) @expansion{}       _[1]=t
hnoether_lib.tex(,589) @expansion{}       _[2]=-t-1/2t2
hnoether_lib.tex(,590) @expansion{}    [2]:
hnoether_lib.tex(,591) @expansion{}       -1,2
hnoether_lib.tex(,592) // 3rd Example: input is a Hamburger-Noether expansion
hnoether_lib.tex(,593) poly f=x3+2xy2+y2;
hnoether_lib.tex(,594) list hne=develop(f);
hnoether_lib.tex(,595) list hne_extended=extdevelop(hne,10);
hnoether_lib.tex(,596) //   compare the matrices ...
hnoether_lib.tex(,597) print(hne[1]);
hnoether_lib.tex(,598) @expansion{} 0,x,
hnoether_lib.tex(,599) @expansion{} 0,-1
hnoether_lib.tex(,600) print(hne_extended[1]);
hnoether_lib.tex(,601) @expansion{} 0,x, 0,0,0,0, 0,0,0,0, 
hnoether_lib.tex(,602) @expansion{} 0,-1,0,2,0,-4,0,8,0,-16
hnoether_lib.tex(,603) // ... and the resulting parametrizations:
hnoether_lib.tex(,604) parametrisation(hne);
hnoether_lib.tex(,605) @expansion{} [1]:
hnoether_lib.tex(,606) @expansion{}    _[1]=-t2
hnoether_lib.tex(,607) @expansion{}    _[2]=-t3
hnoether_lib.tex(,608) parametrisation(hne_extended);
hnoether_lib.tex(,609) @expansion{} [1]:
hnoether_lib.tex(,610) @expansion{}    _[1]=-t2+2t4-4t6+8t8-16t10
hnoether_lib.tex(,611) @expansion{}    _[2]=-t3+2t5-4t7+8t9-16t11
hnoether_lib.tex(,612) parametrisation(hne_extended,0);
hnoether_lib.tex(,613) @expansion{} [1]:
hnoether_lib.tex(,614) @expansion{}    [1]:
hnoether_lib.tex(,615) @expansion{}       _[1]=-t2+2t4-4t6+8t8-16t10
hnoether_lib.tex(,616) @expansion{}       _[2]=-t3+2t5-4t7+8t9-16t11
hnoether_lib.tex(,617) @expansion{}    [2]:
hnoether_lib.tex(,618) @expansion{}       10,11
hnoether_lib.tex(,619) @c end example parametrisation d2t_singular/hnoether_lib.doc:449
hnoether_lib.tex(,620) @end smallexample
hnoether_lib.tex(,621) @c inserted refs from d2t_singular/hnoether_lib.doc:472
hnoether_lib.tex(,634) @c end inserted refs from d2t_singular/hnoether_lib.doc:472
hnoether_lib.tex(,635) 
hnoether_lib.tex(,636) @c ---end content parametrisation---
hnoether_lib.tex(,637) 
hnoether_lib.tex(,638) @c ------------------- displayHNE -------------
hnoether_lib.tex(,639) @node displayHNE, invariants, parametrisation, hnoether_lib
hnoether_lib.tex(,640) @subsubsection displayHNE
hnoether_lib.tex(,641) @cindex displayHNE
hnoether_lib.tex(,642) @c ---content displayHNE---
hnoether_lib.tex(,643) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,644) 
hnoether_lib.tex(,645) @table @asis
hnoether_lib.tex(,646) @item @strong{Usage:}
hnoether_lib.tex(,647) displayHNE(L[,n]); L list, n int
hnoether_lib.tex(,648) 
hnoether_lib.tex(,649) @item @strong{Assume:}
hnoether_lib.tex(,650) L is the output of @code{develop(f)}, or of @code{exdevelop(f,n)},
hnoether_lib.tex(,651) or of @code{hnexpansion(f[,"ess"])}, or (one entry in) the list
hnoether_lib.tex(,652) @code{hne} in the ring created by @code{hnexpansion(f[,"ess"])}.
hnoether_lib.tex(,653) 
hnoether_lib.tex(,654) @item @strong{Return:}
hnoether_lib.tex(,655) - if only one argument is given, no return value, but
hnoether_lib.tex(,656) display an ideal HNE of the following form:
hnoether_lib.tex(,657) @smallexample
hnoether_lib.tex(,658)      HNE[1]=-y+[]*z(0)^1+[]*z(0)^2+...+z(0)^<>*z(1)
hnoether_lib.tex(,659)      HNE[2]=-x+          []*z(1)^2+...+z(1)^<>*z(2)
hnoether_lib.tex(,660)      HNE[3]=             []*z(2)^2+...+z(2)^<>*z(3)
hnoether_lib.tex(,661)      .......             ..........................
hnoether_lib.tex(,662)      HNE[r+1]=           []*z(r)^2+[]*z(r)^3+......
hnoether_lib.tex(,663) @end smallexample
hnoether_lib.tex(,664) where @code{x},@code{y} are the first 2 variables of the basering.
hnoether_lib.tex(,665) The values of @code{[]} are the coefficients of the Hamburger-Noether
hnoether_lib.tex(,666) matrix, the values of @code{<>} are represented by @code{x} in the
hnoether_lib.tex(,667) HN-matrix.@*
hnoether_lib.tex(,668) - if a second argument is given, create and export a new ring with
hnoether_lib.tex(,669) name @code{displayring} containing an ideal @code{HNE} as described
hnoether_lib.tex(,670) above.@*
hnoether_lib.tex(,671) - if L corresponds to the output of @code{hnexpansion(f[,"ess"])}
hnoether_lib.tex(,672) or to the list @code{hne} in the ring created by @code{hnexpansion(f[,"ess"])},
hnoether_lib.tex(,673) @code{displayHNE(L[,n])} shows the HNE's of all branches of f in the form
hnoether_lib.tex(,674) described above. The optional parameter is then ignored.
hnoether_lib.tex(,675) 
hnoether_lib.tex(,676) @item @strong{Note:}
hnoether_lib.tex(,677) The 1st line of the above ideal (i.e., @code{HNE[1]}) means that
hnoether_lib.tex(,678) @code{y=[]*z(0)^1+...}, the 2nd line (@code{HNE[2]}) means that
hnoether_lib.tex(,679) @code{x=[]*z(1)^2+...}, so you can see which indeterminate
hnoether_lib.tex(,680) corresponds to which line (it's also possible that @code{x} corresponds
hnoether_lib.tex(,681) to the 1st line and @code{y} to the 2nd).
hnoether_lib.tex(,682) 
hnoether_lib.tex(,683) @end table
hnoether_lib.tex(,684) @strong{Example:}
hnoether_lib.tex(,685) @smallexample
hnoether_lib.tex(,686) @c computed example displayHNE d2t_singular/hnoether_lib.doc:526 
hnoether_lib.tex(,687) LIB "hnoether.lib";
hnoether_lib.tex(,688) ring r=0,(x,y),dp;
hnoether_lib.tex(,689) poly f=x3+2xy2+y2;
hnoether_lib.tex(,690) list hn=develop(f);
hnoether_lib.tex(,691) displayHNE(hn);
hnoether_lib.tex(,692) @expansion{} HNE[1]=-y+z(0)*z(1)
hnoether_lib.tex(,693) @expansion{} HNE[2]=-x-z(1)^2
hnoether_lib.tex(,694) @c end example displayHNE d2t_singular/hnoether_lib.doc:526
hnoether_lib.tex(,695) @end smallexample
hnoether_lib.tex(,696) @c inserted refs from d2t_singular/hnoether_lib.doc:534
hnoether_lib.tex(,709) @c end inserted refs from d2t_singular/hnoether_lib.doc:534
hnoether_lib.tex(,710) 
hnoether_lib.tex(,711) @c ---end content displayHNE---
hnoether_lib.tex(,712) 
hnoether_lib.tex(,713) @c ------------------- invariants -------------
hnoether_lib.tex(,714) @node invariants, displayInvariants, displayHNE, hnoether_lib
hnoether_lib.tex(,715) @subsubsection invariants
hnoether_lib.tex(,716) @cindex invariants
hnoether_lib.tex(,717) @c ---content invariants---
hnoether_lib.tex(,718) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,719) 
hnoether_lib.tex(,720) @table @asis
hnoether_lib.tex(,721) @item @strong{Usage:}
hnoether_lib.tex(,722) invariants(INPUT); INPUT list or poly
hnoether_lib.tex(,723) 
hnoether_lib.tex(,724) @item @strong{Assume:}
hnoether_lib.tex(,725) INPUT is the output of @code{develop(f)}, or of
hnoether_lib.tex(,726) @code{extdevelop(develop(f),n)}, or one entry in the list @code{hne}
hnoether_lib.tex(,727) of the HNEring created by @code{hnexpansion}.
hnoether_lib.tex(,728) 
hnoether_lib.tex(,729) @item @strong{Return:}
hnoether_lib.tex(,730) list, if INPUT contains a valid HNE:
hnoether_lib.tex(,731) @format
hnoether_lib.tex(,732)     invariants(INPUT)[1]:  intvec    (characteristic exponents)
hnoether_lib.tex(,733)     invariants(INPUT)[2]:  intvec    (generators of the semigroup)
hnoether_lib.tex(,734)     invariants(INPUT)[3]:  intvec    (Puiseux pairs, 1st components)
hnoether_lib.tex(,735)     invariants(INPUT)[4]:  intvec    (Puiseux pairs, 2nd components)
hnoether_lib.tex(,736)     invariants(INPUT)[5]:  int       (degree of the conductor)
hnoether_lib.tex(,737)     invariants(INPUT)[6]:  intvec    (sequence of multiplicities)
hnoether_lib.tex(,738) @end format
hnoether_lib.tex(,739) an empty list, if INPUT contains no valid HNE.
hnoether_lib.tex(,740) 
hnoether_lib.tex(,741) @item @strong{Assume:}
hnoether_lib.tex(,742) INPUT is bivariate polynomial f or the output of @code{hnexpansion(f[,"ess"])},
hnoether_lib.tex(,743) or the list @code{hne} in the HNEring created by @code{hnexpansion}.
hnoether_lib.tex(,744) 
hnoether_lib.tex(,745) @item @strong{Return:}
hnoether_lib.tex(,746) list INV, such that INV[i] is the output of @code{invariants(develop(f[i]))}
hnoether_lib.tex(,747) as above, where f[i] is the ith branch of the curve f, and the last
hnoether_lib.tex(,748) entry contains further invariants of f in the format:
hnoether_lib.tex(,749) @format
hnoether_lib.tex(,750)     INV[i][1]    : intvec    (characteristic exponents)
hnoether_lib.tex(,751)     INV[i][2]    : intvec    (generators of the semigroup)
hnoether_lib.tex(,752)     INV[i][3]    : intvec    (Puiseux pairs, 1st components)
hnoether_lib.tex(,753)     INV[i][4]    : intvec    (Puiseux pairs, 2nd components)
hnoether_lib.tex(,754)     INV[i][5]    : int       (degree of the conductor)
hnoether_lib.tex(,755)     INV[i][6]    : intvec    (sequence of multiplicities)
hnoether_lib.tex(,756)     INV[last][1] : intmat    (contact matrix of the branches)
hnoether_lib.tex(,757)     INV[last][2] : intmat    (intersection multiplicities of the branches)
hnoether_lib.tex(,758)     INV[last][3] : int       (delta invariant of f)
hnoether_lib.tex(,759) @end format
hnoether_lib.tex(,760) 
hnoether_lib.tex(,761) @item @strong{Note:}
hnoether_lib.tex(,762) In case the Hamburger-Noether expansion of the curve f is needed
hnoether_lib.tex(,763) for other purposes as well it is better to calculate this first
hnoether_lib.tex(,764) with the aid of @code{hnexpansion} and use it as input instead of
hnoether_lib.tex(,765) the polynomial itself.
hnoether_lib.tex(,766) 
hnoether_lib.tex(,767) @cindex characteristic exponents
hnoether_lib.tex(,768) @cindex semigroup of values
hnoether_lib.tex(,769) @cindex Puiseux pairs
hnoether_lib.tex(,770) @cindex conductor, degree
hnoether_lib.tex(,771) @cindex multiplicities, sequence of
hnoether_lib.tex(,772) @end table
hnoether_lib.tex(,773) @strong{Example:}
hnoether_lib.tex(,774) @smallexample
hnoether_lib.tex(,775) @c computed example invariants d2t_singular/hnoether_lib.doc:602 
hnoether_lib.tex(,776) LIB "hnoether.lib";
hnoether_lib.tex(,777) ring exring=0,(x,y),dp;
hnoether_lib.tex(,778) list hne=develop(y4+2x3y2+x6+x5y);
hnoether_lib.tex(,779) list INV=invariants(hne);
hnoether_lib.tex(,780) INV[1];                   // the characteristic exponents
hnoether_lib.tex(,781) @expansion{} 4,6,7
hnoether_lib.tex(,782) INV[2];                   // the generators of the semigroup of values
hnoether_lib.tex(,783) @expansion{} 4,6,13
hnoether_lib.tex(,784) INV[3],INV[4];            // the Puiseux pairs in packed form
hnoether_lib.tex(,785) @expansion{} 3,7 2,2
hnoether_lib.tex(,786) INV[5] / 2;               // the delta-invariant
hnoether_lib.tex(,787) @expansion{} 8
hnoether_lib.tex(,788) INV[6];                   // the sequence of multiplicities
hnoether_lib.tex(,789) @expansion{} 4,2,2,1,1
hnoether_lib.tex(,790) // To display the invariants more 'nicely':
hnoether_lib.tex(,791) displayInvariants(hne);
hnoether_lib.tex(,792) @expansion{}  characteristic exponents  : 4,6,7
hnoether_lib.tex(,793) @expansion{}  generators of semigroup   : 4,6,13
hnoether_lib.tex(,794) @expansion{}  Puiseux pairs             : (3,2)(7,2)
hnoether_lib.tex(,795) @expansion{}  degree of the conductor   : 16
hnoether_lib.tex(,796) @expansion{}  delta invariant           : 8
hnoether_lib.tex(,797) @expansion{}  sequence of multiplicities: 4,2,2,1,1
hnoether_lib.tex(,798) /////////////////////////////
hnoether_lib.tex(,799) INV=invariants((x2-y3)*(x3-y5));
hnoether_lib.tex(,800) INV[1][1];                // the characteristic exponents of the first branch
hnoether_lib.tex(,801) @expansion{} 2,3
hnoether_lib.tex(,802) INV[2][6];                // the sequence of multiplicities of the second branch
hnoether_lib.tex(,803) @expansion{} 3,2,1,1
hnoether_lib.tex(,804) print(INV[size(INV)][1]);         // the contact matrix of the branches
hnoether_lib.tex(,805) @expansion{}      0     3
hnoether_lib.tex(,806) @expansion{}      3     0
hnoether_lib.tex(,807) print(INV[size(INV)][2]);         // the intersection numbers of the branches
hnoether_lib.tex(,808) @expansion{}      0     9
hnoether_lib.tex(,809) @expansion{}      9     0
hnoether_lib.tex(,810) INV[size(INV)][3];                // the delta invariant of the curve
hnoether_lib.tex(,811) @expansion{} 14
hnoether_lib.tex(,812) @c end example invariants d2t_singular/hnoether_lib.doc:602
hnoether_lib.tex(,813) @end smallexample
hnoether_lib.tex(,814) @c inserted refs from d2t_singular/hnoether_lib.doc:623
hnoether_lib.tex(,831) @c end inserted refs from d2t_singular/hnoether_lib.doc:623
hnoether_lib.tex(,832) 
hnoether_lib.tex(,833) @c ---end content invariants---
hnoether_lib.tex(,834) 
hnoether_lib.tex(,835) @c ------------------- displayInvariants -------------
hnoether_lib.tex(,836) @node displayInvariants, multsequence, invariants, hnoether_lib
hnoether_lib.tex(,837) @subsubsection displayInvariants
hnoether_lib.tex(,838) @cindex displayInvariants
hnoether_lib.tex(,839) @c ---content displayInvariants---
hnoether_lib.tex(,840) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,841) 
hnoether_lib.tex(,842) @table @asis
hnoether_lib.tex(,843) @item @strong{Usage:}
hnoether_lib.tex(,844) displayInvariants(INPUT); INPUT list or poly
hnoether_lib.tex(,845) 
hnoether_lib.tex(,846) @item @strong{Assume:}
hnoether_lib.tex(,847) INPUT is a bivariate polynomial, or the output of @code{develop(f)}, or of
hnoether_lib.tex(,848) @code{extdevelop(develop(f),n)}, or (one entry of) the list @code{hne}
hnoether_lib.tex(,849) in the ring created by @code{hnexpansion(f[,"ess"])}.
hnoether_lib.tex(,850) 
hnoether_lib.tex(,851) @item @strong{Return:}
hnoether_lib.tex(,852) none
hnoether_lib.tex(,853) 
hnoether_lib.tex(,854) @item @strong{Display:}
hnoether_lib.tex(,855) invariants of the corresponding branch, resp. of all branches,
hnoether_lib.tex(,856) in a better readable form.
hnoether_lib.tex(,857) 
hnoether_lib.tex(,858) @item @strong{Note:}
hnoether_lib.tex(,859) In case the Hamburger-Noether expansion of the curve f is needed
hnoether_lib.tex(,860) for other purposes as well it is better to calculate this first
hnoether_lib.tex(,861) with the aid of @code{hnexpansion} and use it as input instead of
hnoether_lib.tex(,862) the polynomial itself.
hnoether_lib.tex(,863) 
hnoether_lib.tex(,864) @end table
hnoether_lib.tex(,865) @strong{Example:}
hnoether_lib.tex(,866) @smallexample
hnoether_lib.tex(,867) @c computed example displayInvariants d2t_singular/hnoether_lib.doc:661 
hnoether_lib.tex(,868) LIB "hnoether.lib";
hnoether_lib.tex(,869) ring exring=0,(x,y),dp;
hnoether_lib.tex(,870) list hne=develop(y4+2x3y2+x6+x5y);
hnoether_lib.tex(,871) displayInvariants(hne);
hnoether_lib.tex(,872) @expansion{}  characteristic exponents  : 4,6,7
hnoether_lib.tex(,873) @expansion{}  generators of semigroup   : 4,6,13
hnoether_lib.tex(,874) @expansion{}  Puiseux pairs             : (3,2)(7,2)
hnoether_lib.tex(,875) @expansion{}  degree of the conductor   : 16
hnoether_lib.tex(,876) @expansion{}  delta invariant           : 8
hnoether_lib.tex(,877) @expansion{}  sequence of multiplicities: 4,2,2,1,1
hnoether_lib.tex(,878) @c end example displayInvariants d2t_singular/hnoether_lib.doc:661
hnoether_lib.tex(,879) @end smallexample
hnoether_lib.tex(,880) @c inserted refs from d2t_singular/hnoether_lib.doc:668
hnoether_lib.tex(,897) @c end inserted refs from d2t_singular/hnoether_lib.doc:668
hnoether_lib.tex(,898) 
hnoether_lib.tex(,899) @c ---end content displayInvariants---
hnoether_lib.tex(,900) 
hnoether_lib.tex(,901) @c ------------------- multsequence -------------
hnoether_lib.tex(,902) @node multsequence, displayMultsequence, displayInvariants, hnoether_lib
hnoether_lib.tex(,903) @subsubsection multsequence
hnoether_lib.tex(,904) @cindex multsequence
hnoether_lib.tex(,905) @c ---content multsequence---
hnoether_lib.tex(,906) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,907) 
hnoether_lib.tex(,908) @table @asis
hnoether_lib.tex(,909) @item @strong{Usage:}
hnoether_lib.tex(,910) multsequence(INPUT); INPUT list or poly
hnoether_lib.tex(,911) 
hnoether_lib.tex(,912) @item @strong{Assume:}
hnoether_lib.tex(,913) INPUT is the output of @code{develop(f)}, or of @code{extdevelop(develop(f),n)},
hnoether_lib.tex(,914) or one entry in the list @code{hne} of the ring created by @code{hnexpansion(f)}.
hnoether_lib.tex(,915) 
hnoether_lib.tex(,916) @item @strong{Return:}
hnoether_lib.tex(,917) intvec corresponding to the multiplicity sequence of (a branch)
hnoether_lib.tex(,918) of the curve (the same as @code{invariants(INPUT)[6]}).
hnoether_lib.tex(,919) 
hnoether_lib.tex(,920) @item @strong{Assume:}
hnoether_lib.tex(,921) INPUT is a bivariate polynomial, or the output of @code{hnexpansion(f)},
hnoether_lib.tex(,922) or the list @code{hne} in the ring created by @code{hnexpansion(f)}.
hnoether_lib.tex(,923) 
hnoether_lib.tex(,924) @item @strong{Return:}
hnoether_lib.tex(,925) list of two integer matrices:
hnoether_lib.tex(,926) 
hnoether_lib.tex(,927) @table @asis
hnoether_lib.tex(,928) @item  @code{multsequence(INPUT)[1][i,*]}
hnoether_lib.tex(,929)    contains the multiplicities of the branches at their infinitely near point
hnoether_lib.tex(,930)    of 0 in its (i-1) order neighbourhood (i.e., i=1: multiplicity of the
hnoether_lib.tex(,931)    branches themselves, i=2: multiplicity of their 1st quadratic transformed,
hnoether_lib.tex(,932)    etc., @*
hnoether_lib.tex(,933)    Hence, @code{multsequence(INPUT)[1][*,j]} is the multiplicity sequence
hnoether_lib.tex(,934)    of branch j.
hnoether_lib.tex(,935) @item  @code{multsequence(INPUT)[2][i,*]}:
hnoether_lib.tex(,936)    contains the information which of these infinitely near points coincide.
hnoether_lib.tex(,937) @end table
hnoether_lib.tex(,938) 
hnoether_lib.tex(,939) @item @strong{Note:}
hnoether_lib.tex(,940) The order of elements of the list @code{hne} obtained from @code{hnexpansion(f[,"ess")}
hnoether_lib.tex(,941) must not be changed (because then the coincident infinitely near points
hnoether_lib.tex(,942) couldn't be grouped together, cf. meaning of 2nd intmat in example).
hnoether_lib.tex(,943) Hence, it is not wise to compute the HNE of several polynomials
hnoether_lib.tex(,944) separately, put them into a list INPUT and call @code{multsequence(INPUT)}. @*
hnoether_lib.tex(,945) Use @code{displayMultsequence} to produce a better readable output for
hnoether_lib.tex(,946) reducible curves on the screen. @*
hnoether_lib.tex(,947) In case the Hamburger-Noether expansion of the curve f is needed
hnoether_lib.tex(,948) for other purposes as well it is better to calculate this first
hnoether_lib.tex(,949) with the aid of @code{hnexpansion} and use it as input instead of
hnoether_lib.tex(,950) the polynomial itself.
hnoether_lib.tex(,951) 
hnoether_lib.tex(,952) @cindex multiplicity sequence
hnoether_lib.tex(,953) @end table
hnoether_lib.tex(,954) @strong{Example:}
hnoether_lib.tex(,955) @smallexample
hnoether_lib.tex(,956) @c computed example multsequence d2t_singular/hnoether_lib.doc:729 
hnoether_lib.tex(,957) LIB "hnoether.lib";
hnoether_lib.tex(,958) // -------- prepare for example ---------
hnoether_lib.tex(,959) if (nameof(basering)=="HNEring") @{
hnoether_lib.tex(,960) def rettering=HNEring;
hnoether_lib.tex(,961) kill HNEring;
hnoether_lib.tex(,962) @}
hnoether_lib.tex(,963) // ------ the example starts here -------
hnoether_lib.tex(,964) ring r=0,(x,y),dp;
hnoether_lib.tex(,965) list hn=hnexpansion((x6-y10)*(x+y2-y3)*(x+y2+y3));   // 4 branches
hnoether_lib.tex(,966) def HNEring=hn[1];
hnoether_lib.tex(,967) setring HNEring;
hnoether_lib.tex(,968) multsequence(hne[1]),"  |  ",multsequence(hne[2]),"  |  ",
hnoether_lib.tex(,969) multsequence(hne[3]),"  |  ",multsequence(hne[4]);
hnoether_lib.tex(,970) @expansion{} 3,2,1,1   |   3,2,1,1   |   1   |   1
hnoether_lib.tex(,971) multsequence(hne);
hnoether_lib.tex(,972) @expansion{} [1]:
hnoether_lib.tex(,973) @expansion{}    3,3,1,1,
hnoether_lib.tex(,974) @expansion{}    2,2,1,1,
hnoether_lib.tex(,975) @expansion{}    1,1,1,1,
hnoether_lib.tex(,976) @expansion{}    1,1,1,1,
hnoether_lib.tex(,977) @expansion{}    1,1,1,1 
hnoether_lib.tex(,978) @expansion{} [2]:
hnoether_lib.tex(,979) @expansion{}    4,0,0,0,
hnoether_lib.tex(,980) @expansion{}    4,0,0,0,
hnoether_lib.tex(,981) @expansion{}    2,2,0,0,
hnoether_lib.tex(,982) @expansion{}    2,1,1,0,
hnoether_lib.tex(,983) @expansion{}    1,1,1,1 
hnoether_lib.tex(,984) // The meaning of the entries of the 2nd matrix is as follows:
hnoether_lib.tex(,985) displayMultsequence(hne);
hnoether_lib.tex(,986) @expansion{} [(3,3,1,1)],
hnoether_lib.tex(,987) @expansion{} [(2,2,1,1)],
hnoether_lib.tex(,988) @expansion{} [(1,1),(1,1)],
hnoether_lib.tex(,989) @expansion{} [(1,1),(1),(1)],
hnoether_lib.tex(,990) @expansion{} [(1),(1),(1),(1)]
hnoether_lib.tex(,991) // --- restore HNEring if previously defined ---
hnoether_lib.tex(,992) kill HNEring,r;
hnoether_lib.tex(,993) if (defined(rettering)) @{
hnoether_lib.tex(,994) setring rettering;
hnoether_lib.tex(,995) def HNEring=rettering;
hnoether_lib.tex(,996) export HNEring;
hnoether_lib.tex(,997) @}
hnoether_lib.tex(,998) @c end example multsequence d2t_singular/hnoether_lib.doc:729
hnoether_lib.tex(,999) @end smallexample
hnoether_lib.tex(,1000) @c inserted refs from d2t_singular/hnoether_lib.doc:755
hnoether_lib.tex(,1017) @c end inserted refs from d2t_singular/hnoether_lib.doc:755
hnoether_lib.tex(,1018) 
hnoether_lib.tex(,1019) @c ---end content multsequence---
hnoether_lib.tex(,1020) 
hnoether_lib.tex(,1021) @c ------------------- displayMultsequence -------------
hnoether_lib.tex(,1022) @node displayMultsequence, intersection, multsequence, hnoether_lib
hnoether_lib.tex(,1023) @subsubsection displayMultsequence
hnoether_lib.tex(,1024) @cindex displayMultsequence
hnoether_lib.tex(,1025) @c ---content displayMultsequence---
hnoether_lib.tex(,1026) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1027) 
hnoether_lib.tex(,1028) @table @asis
hnoether_lib.tex(,1029) @item @strong{Usage:}
hnoether_lib.tex(,1030) displayMultsequence(INPUT); INPUT list or poly
hnoether_lib.tex(,1031) 
hnoether_lib.tex(,1032) @item @strong{Assume:}
hnoether_lib.tex(,1033) INPUT is a bivariate polynomial, or the output of @code{develop(f)},
hnoether_lib.tex(,1034) or of @code{extdevelop(develop(f),n)}, or of of @code{hnexpansion(f[,"ess"])},
hnoether_lib.tex(,1035) or (one entry in) the list @code{hne} of the ring created by @code{hnexpansion(f[,"ess "])}.
hnoether_lib.tex(,1036) 
hnoether_lib.tex(,1037) @item @strong{Return:}
hnoether_lib.tex(,1038) nothing
hnoether_lib.tex(,1039) 
hnoether_lib.tex(,1040) @item @strong{Display:}
hnoether_lib.tex(,1041) the sequence of multiplicities:
hnoether_lib.tex(,1042) @format
hnoether_lib.tex(,1043)  - if @code{INPUT=develop(f)} or @code{INPUT=extdevelop(develop(f),n)} or @code{INPUT=hne[i]}:
hnoether_lib.tex(,1044)                       @code{a , b , c , ....... , 1}
hnoether_lib.tex(,1045)  - if @code{INPUT=f} or @code{INPUT=hnexpansion(f[,"ess"])} or @code{INPUT=hne}:
hnoether_lib.tex(,1046)                       @code{[(a_1, .... , b_1 , .... , c_1)],}
hnoether_lib.tex(,1047)                       @code{[(a_2, ... ), ... , (... , c_2)],}
hnoether_lib.tex(,1048)                       @code{ ........................................ ,}
hnoether_lib.tex(,1049)                       @code{[(a_n),(b_n), ....., (c_n)]}
hnoether_lib.tex(,1050)      with:
hnoether_lib.tex(,1051)        @code{a_1 , ... , a_n} the sequence of multiplicities of the 1st branch,
hnoether_lib.tex(,1052)        @code{[...]} the multiplicities of the j-th transformed of all branches,
hnoether_lib.tex(,1053)        @code{(...)} indicating branches meeting in an infinitely near point.
hnoether_lib.tex(,1054) @end format
hnoether_lib.tex(,1055) 
hnoether_lib.tex(,1056) @item @strong{Note:}
hnoether_lib.tex(,1057) The same restrictions for INPUT as in @code{multsequence} apply.@*
hnoether_lib.tex(,1058) In case the Hamburger-Noether expansion of the curve f is needed
hnoether_lib.tex(,1059) for other purposes as well it is better to calculate this first
hnoether_lib.tex(,1060) with the aid of @code{hnexpansion} and use it as input instead of
hnoether_lib.tex(,1061) the polynomial itself.
hnoether_lib.tex(,1062) 
hnoether_lib.tex(,1063) @end table
hnoether_lib.tex(,1064) @strong{Example:}
hnoether_lib.tex(,1065) @smallexample
hnoether_lib.tex(,1066) @c computed example displayMultsequence d2t_singular/hnoether_lib.doc:806 
hnoether_lib.tex(,1067) LIB "hnoether.lib";
hnoether_lib.tex(,1068) // ------ the example starts here -------
hnoether_lib.tex(,1069) ring r=0,(x,y),dp;
hnoether_lib.tex(,1070) //// Example 1: Input = output of develop
hnoether_lib.tex(,1071) displayMultsequence(develop(x3-y5));
hnoether_lib.tex(,1072) @expansion{} The sequence of multiplicities is   3,2,1,1
hnoether_lib.tex(,1073) //// Example 2: Input = bivariate polynomial
hnoether_lib.tex(,1074) displayMultsequence((x6-y10)*(x+y2-y3)*(x+y2+y3));
hnoether_lib.tex(,1075) @expansion{} [(3,3,1,1)],
hnoether_lib.tex(,1076) @expansion{} [(2,2,1,1)],
hnoether_lib.tex(,1077) @expansion{} [(1,1),(1,1)],
hnoether_lib.tex(,1078) @expansion{} [(1,1),(1),(1)],
hnoether_lib.tex(,1079) @expansion{} [(1),(1),(1),(1)]
hnoether_lib.tex(,1080) @c end example displayMultsequence d2t_singular/hnoether_lib.doc:806
hnoether_lib.tex(,1081) @end smallexample
hnoether_lib.tex(,1082) @c inserted refs from d2t_singular/hnoether_lib.doc:816
hnoether_lib.tex(,1099) @c end inserted refs from d2t_singular/hnoether_lib.doc:816
hnoether_lib.tex(,1100) 
hnoether_lib.tex(,1101) @c ---end content displayMultsequence---
hnoether_lib.tex(,1102) 
hnoether_lib.tex(,1103) @c ------------------- intersection -------------
hnoether_lib.tex(,1104) @node intersection, stripHNE, displayMultsequence, hnoether_lib
hnoether_lib.tex(,1105) @subsubsection intersection
hnoether_lib.tex(,1106) @cindex intersection
hnoether_lib.tex(,1107) @c ---content intersection---
hnoether_lib.tex(,1108) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1109) 
hnoether_lib.tex(,1110) @table @asis
hnoether_lib.tex(,1111) @item @strong{Usage:}
hnoether_lib.tex(,1112) intersection(hne1,hne2); hne1, hne2 lists
hnoether_lib.tex(,1113) 
hnoether_lib.tex(,1114) @item @strong{Assume:}
hnoether_lib.tex(,1115) hne1, hne2 represent a HNE (i.e., are the output of
hnoether_lib.tex(,1116) @code{develop(f)}, or of @code{extdevelop(develop(f),n)}, or
hnoether_lib.tex(,1117) one entry of the list @code{hne} in the ring created by
hnoether_lib.tex(,1118) @code{hnexpansion(f[,"ess"])}).
hnoether_lib.tex(,1119) 
hnoether_lib.tex(,1120) @item @strong{Return:}
hnoether_lib.tex(,1121) int, the intersection multiplicity of the branches corresponding to
hnoether_lib.tex(,1122) hne1 and hne2.
hnoether_lib.tex(,1123) 
hnoether_lib.tex(,1124) @cindex intersection multiplicity
hnoether_lib.tex(,1125) @end table
hnoether_lib.tex(,1126) @strong{Example:}
hnoether_lib.tex(,1127) @smallexample
hnoether_lib.tex(,1128) @c computed example intersection d2t_singular/hnoether_lib.doc:847 
hnoether_lib.tex(,1129) LIB "hnoether.lib";
hnoether_lib.tex(,1130) // ------ the example starts here -------
hnoether_lib.tex(,1131) ring r=0,(x,y),dp;
hnoether_lib.tex(,1132) list hn=hnexpansion((x2-y3)*(x2+y3));
hnoether_lib.tex(,1133) def HNEring=hn[1];
hnoether_lib.tex(,1134) setring HNEring;
hnoether_lib.tex(,1135) intersection(hne[1],hne[2]);
hnoether_lib.tex(,1136) @expansion{} 6
hnoether_lib.tex(,1137) @c end example intersection d2t_singular/hnoether_lib.doc:847
hnoether_lib.tex(,1138) @end smallexample
hnoether_lib.tex(,1139) @c inserted refs from d2t_singular/hnoether_lib.doc:857
hnoether_lib.tex(,1152) @c end inserted refs from d2t_singular/hnoether_lib.doc:857
hnoether_lib.tex(,1153) 
hnoether_lib.tex(,1154) @c ---end content intersection---
hnoether_lib.tex(,1155) 
hnoether_lib.tex(,1156) @c ------------------- stripHNE -------------
hnoether_lib.tex(,1157) @node stripHNE, is_irred, intersection, hnoether_lib
hnoether_lib.tex(,1158) @subsubsection stripHNE
hnoether_lib.tex(,1159) @cindex stripHNE
hnoether_lib.tex(,1160) @c ---content stripHNE---
hnoether_lib.tex(,1161) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1162) 
hnoether_lib.tex(,1163) @table @asis
hnoether_lib.tex(,1164) @item @strong{Usage:}
hnoether_lib.tex(,1165) stripHNE(L); L list
hnoether_lib.tex(,1166) 
hnoether_lib.tex(,1167) @item @strong{Assume:}
hnoether_lib.tex(,1168) L is the output of @code{develop(f)}, or of
hnoether_lib.tex(,1169) @code{extdevelop(develop(f),n)}, or (one entry of) the list
hnoether_lib.tex(,1170) @code{hne} in the ring created by @code{hnexpansion(f[,"ess"])}.
hnoether_lib.tex(,1171) 
hnoether_lib.tex(,1172) @item @strong{Return:}
hnoether_lib.tex(,1173) list in the same format as L, but all polynomials L[4], resp.
hnoether_lib.tex(,1174) L[i][4], are set to zero.
hnoether_lib.tex(,1175) 
hnoether_lib.tex(,1176) @item @strong{Note:}
hnoether_lib.tex(,1177) The purpose of this procedure is to remove huge amounts of data
hnoether_lib.tex(,1178) no longer needed. It is useful, if one or more of the polynomials
hnoether_lib.tex(,1179) in L consume much memory. It is still possible to compute invariants,
hnoether_lib.tex(,1180) parametrizations etc. with the stripped HNE(s), but it is not possible
hnoether_lib.tex(,1181) to use @code{extdevelop} with them.
hnoether_lib.tex(,1182) 
hnoether_lib.tex(,1183) @end table
hnoether_lib.tex(,1184) @strong{Example:}
hnoether_lib.tex(,1185) @smallexample
hnoether_lib.tex(,1186) @c computed example stripHNE d2t_singular/hnoether_lib.doc:893 
hnoether_lib.tex(,1187) LIB "hnoether.lib";
hnoether_lib.tex(,1188) ring r=0,(x,y),dp;
hnoether_lib.tex(,1189) list hne=develop(x2+y3+y4);
hnoether_lib.tex(,1190) hne;
hnoether_lib.tex(,1191) @expansion{} [1]:
hnoether_lib.tex(,1192) @expansion{}    _[1,1]=0
hnoether_lib.tex(,1193) @expansion{}    _[1,2]=x
hnoether_lib.tex(,1194) @expansion{}    _[2,1]=0
hnoether_lib.tex(,1195) @expansion{}    _[2,2]=-1
hnoether_lib.tex(,1196) @expansion{} [2]:
hnoether_lib.tex(,1197) @expansion{}    1,-1
hnoether_lib.tex(,1198) @expansion{} [3]:
hnoether_lib.tex(,1199) @expansion{}    1
hnoether_lib.tex(,1200) @expansion{} [4]:
hnoether_lib.tex(,1201) @expansion{}    x4-2x2y+y2+y
hnoether_lib.tex(,1202) @expansion{} [5]:
hnoether_lib.tex(,1203) @expansion{}    1
hnoether_lib.tex(,1204) stripHNE(hne);
hnoether_lib.tex(,1205) @expansion{} [1]:
hnoether_lib.tex(,1206) @expansion{}    _[1,1]=0
hnoether_lib.tex(,1207) @expansion{}    _[1,2]=x
hnoether_lib.tex(,1208) @expansion{}    _[2,1]=0
hnoether_lib.tex(,1209) @expansion{}    _[2,2]=-1
hnoether_lib.tex(,1210) @expansion{} [2]:
hnoether_lib.tex(,1211) @expansion{}    1,-1
hnoether_lib.tex(,1212) @expansion{} [3]:
hnoether_lib.tex(,1213) @expansion{}    1
hnoether_lib.tex(,1214) @expansion{} [4]:
hnoether_lib.tex(,1215) @expansion{}    0
hnoether_lib.tex(,1216) @expansion{} [5]:
hnoether_lib.tex(,1217) @expansion{}    1
hnoether_lib.tex(,1218) @c end example stripHNE d2t_singular/hnoether_lib.doc:893
hnoether_lib.tex(,1219) @end smallexample
hnoether_lib.tex(,1220) @c inserted refs from d2t_singular/hnoether_lib.doc:901
hnoether_lib.tex(,1235) @c end inserted refs from d2t_singular/hnoether_lib.doc:901
hnoether_lib.tex(,1236) 
hnoether_lib.tex(,1237) @c ---end content stripHNE---
hnoether_lib.tex(,1238) 
hnoether_lib.tex(,1239) @c ------------------- is_irred -------------
hnoether_lib.tex(,1240) @node is_irred, delta, stripHNE, hnoether_lib
hnoether_lib.tex(,1241) @subsubsection is_irred
hnoether_lib.tex(,1242) @cindex is_irred
hnoether_lib.tex(,1243) @c ---content is_irred---
hnoether_lib.tex(,1244) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1245) 
hnoether_lib.tex(,1246) @table @asis
hnoether_lib.tex(,1247) @item @strong{Usage:}
hnoether_lib.tex(,1248) is_irred(f); f poly
hnoether_lib.tex(,1249) 
hnoether_lib.tex(,1250) @item @strong{Assume:}
hnoether_lib.tex(,1251) f is a squarefree bivariate polynomial (in the first 2 ring
hnoether_lib.tex(,1252) variables).
hnoether_lib.tex(,1253) 
hnoether_lib.tex(,1254) @item @strong{Return:}
hnoether_lib.tex(,1255) int (0 or 1): @*
hnoether_lib.tex(,1256) - @code{is_irred(f)=1} if f is irreducible as a formal power
hnoether_lib.tex(,1257) series over the algebraic closure of its coefficient field (f
hnoether_lib.tex(,1258) defines an analytically irreducible curve at zero), @*
hnoether_lib.tex(,1259) - @code{is_irred(f)=0} otherwise.
hnoether_lib.tex(,1260) 
hnoether_lib.tex(,1261) @item @strong{Note:}
hnoether_lib.tex(,1262) 0 and units in the ring of formal power series are considered to be
hnoether_lib.tex(,1263) not irreducible.
hnoether_lib.tex(,1264) 
hnoether_lib.tex(,1265) @cindex irreducible power series
hnoether_lib.tex(,1266) @end table
hnoether_lib.tex(,1267) @strong{Example:}
hnoether_lib.tex(,1268) @smallexample
hnoether_lib.tex(,1269) @c computed example is_irred d2t_singular/hnoether_lib.doc:937 
hnoether_lib.tex(,1270) LIB "hnoether.lib";
hnoether_lib.tex(,1271) ring exring=0,(x,y),ls;
hnoether_lib.tex(,1272) is_irred(x2+y3);
hnoether_lib.tex(,1273) @expansion{} 1
hnoether_lib.tex(,1274) is_irred(x2+y2);
hnoether_lib.tex(,1275) @expansion{} 0
hnoether_lib.tex(,1276) is_irred(x2+y3+1);
hnoether_lib.tex(,1277) @expansion{} 0
hnoether_lib.tex(,1278) @c end example is_irred d2t_singular/hnoether_lib.doc:937
hnoether_lib.tex(,1279) @end smallexample
hnoether_lib.tex(,1280) @c ---end content is_irred---
hnoether_lib.tex(,1281) 
hnoether_lib.tex(,1282) @c ------------------- delta -------------
hnoether_lib.tex(,1283) @node delta, newtonpoly, is_irred, hnoether_lib
hnoether_lib.tex(,1284) @subsubsection delta
hnoether_lib.tex(,1285) @cindex delta
hnoether_lib.tex(,1286) @c ---content delta---
hnoether_lib.tex(,1287) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1288) 
hnoether_lib.tex(,1289) @table @asis
hnoether_lib.tex(,1290) @item @strong{Usage:}
hnoether_lib.tex(,1291) delta(INPUT); INPUT a polynomial defining an isolated plane curve
hnoether_lib.tex(,1292) singularity at 0, or the Hamburger-Noether expansion thereof, i.e.
hnoether_lib.tex(,1293) the output of @code{develop(f)}, or the output of @code{hnexpansion(f[,"ess"])},
hnoether_lib.tex(,1294) or (one of the entries of) the list @code{hne} in the ring created
hnoether_lib.tex(,1295) by @code{hnexpansion(f[,"ess"])}.
hnoether_lib.tex(,1296) 
hnoether_lib.tex(,1297) @item @strong{Return:}
hnoether_lib.tex(,1298) the delta invariant of the singularity at 0, the vector space
hnoether_lib.tex(,1299) dimension of R~/R, where R~ is the normalization of the
hnoether_lib.tex(,1300) singularity R=basering/f
hnoether_lib.tex(,1301) 
hnoether_lib.tex(,1302) @item @strong{Note:}
hnoether_lib.tex(,1303) In case the Hamburger-Noether expansion of the curve f is needed
hnoether_lib.tex(,1304) for other purposes as well it is better to calculate this first
hnoether_lib.tex(,1305) with the aid of @code{hnexpansion} and use it as input instead of
hnoether_lib.tex(,1306) the polynomial itself.
hnoether_lib.tex(,1307) 
hnoether_lib.tex(,1308) @cindex delta invariant
hnoether_lib.tex(,1309) @end table
hnoether_lib.tex(,1310) @strong{Example:}
hnoether_lib.tex(,1311) @smallexample
hnoether_lib.tex(,1312) @c computed example delta d2t_singular/hnoether_lib.doc:977 
hnoether_lib.tex(,1313) LIB "hnoether.lib";
hnoether_lib.tex(,1314) ring r = 32003,(x,y),ds;
hnoether_lib.tex(,1315) poly f = x25+x24-4x23-1x22y+4x22+8x21y-2x21-12x20y-4x19y2+4x20+10x19y
hnoether_lib.tex(,1316) +12x18y2-24x18y-20x17y2-4x16y3+x18+60x16y2+20x15y3-9x16y
hnoether_lib.tex(,1317) -80x14y3-10x13y4+36x14y2+60x12y4+2x11y5-84x12y3-24x10y5
hnoether_lib.tex(,1318) +126x10y4+4x8y6-126x8y5+84x6y6-36x4y7+9x2y8-1y9;
hnoether_lib.tex(,1319) delta(f);
hnoether_lib.tex(,1320) @expansion{} 96
hnoether_lib.tex(,1321) @c end example delta d2t_singular/hnoether_lib.doc:977
hnoether_lib.tex(,1322) @end smallexample
hnoether_lib.tex(,1323) @c inserted refs from d2t_singular/hnoether_lib.doc:987
hnoether_lib.tex(,1336) @c end inserted refs from d2t_singular/hnoether_lib.doc:987
hnoether_lib.tex(,1337) 
hnoether_lib.tex(,1338) @c ---end content delta---
hnoether_lib.tex(,1339) 
hnoether_lib.tex(,1340) @c ------------------- newtonpoly -------------
hnoether_lib.tex(,1341) @node newtonpoly, is_NND, delta, hnoether_lib
hnoether_lib.tex(,1342) @subsubsection newtonpoly
hnoether_lib.tex(,1343) @cindex newtonpoly
hnoether_lib.tex(,1344) @c ---content newtonpoly---
hnoether_lib.tex(,1345) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1346) 
hnoether_lib.tex(,1347) @table @asis
hnoether_lib.tex(,1348) @item @strong{Usage:}
hnoether_lib.tex(,1349) newtonpoly(f); f poly
hnoether_lib.tex(,1350) 
hnoether_lib.tex(,1351) @item @strong{Assume:}
hnoether_lib.tex(,1352) basering has exactly two variables; @*
hnoether_lib.tex(,1353) f is convenient, that is, f(x,0) != 0 != f(0,y).
hnoether_lib.tex(,1354) 
hnoether_lib.tex(,1355) @item @strong{Return:}
hnoether_lib.tex(,1356) list of intvecs (= coordinates x,y of the Newton polygon of f).
hnoether_lib.tex(,1357) 
hnoether_lib.tex(,1358) @item @strong{Note:}
hnoether_lib.tex(,1359) Procedure uses @code{execute}; this can be avoided by calling
hnoether_lib.tex(,1360) @code{newtonpoly(f,1)} if the ordering of the basering is @code{ls}.
hnoether_lib.tex(,1361) 
hnoether_lib.tex(,1362) @cindex Newton polygon
hnoether_lib.tex(,1363) @end table
hnoether_lib.tex(,1364) @strong{Example:}
hnoether_lib.tex(,1365) @smallexample
hnoether_lib.tex(,1366) @c computed example newtonpoly d2t_singular/hnoether_lib.doc:1019 
hnoether_lib.tex(,1367) LIB "hnoether.lib";
hnoether_lib.tex(,1368) ring r=0,(x,y),ls;
hnoether_lib.tex(,1369) poly f=x5+2x3y-x2y2+3xy5+y6-y7;
hnoether_lib.tex(,1370) newtonpoly(f);
hnoether_lib.tex(,1371) @expansion{} [1]:
hnoether_lib.tex(,1372) @expansion{}    0,6
hnoether_lib.tex(,1373) @expansion{} [2]:
hnoether_lib.tex(,1374) @expansion{}    2,2
hnoether_lib.tex(,1375) @expansion{} [3]:
hnoether_lib.tex(,1376) @expansion{}    3,1
hnoether_lib.tex(,1377) @expansion{} [4]:
hnoether_lib.tex(,1378) @expansion{}    5,0
hnoether_lib.tex(,1379) @c end example newtonpoly d2t_singular/hnoether_lib.doc:1019
hnoether_lib.tex(,1380) @end smallexample
hnoether_lib.tex(,1381) @c ---end content newtonpoly---
hnoether_lib.tex(,1382) 
hnoether_lib.tex(,1383) @c ------------------- is_NND -------------
hnoether_lib.tex(,1384) @node is_NND, puiseux2generators, newtonpoly, hnoether_lib
hnoether_lib.tex(,1385) @subsubsection is_NND
hnoether_lib.tex(,1386) @cindex is_NND
hnoether_lib.tex(,1387) @c ---content is_NND---
hnoether_lib.tex(,1388) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1389) 
hnoether_lib.tex(,1390) @table @asis
hnoether_lib.tex(,1391) @item @strong{Usage:}
hnoether_lib.tex(,1392) is_NND(f[,mu,NP]); f poly, mu int, NP list of intvecs
hnoether_lib.tex(,1393) 
hnoether_lib.tex(,1394) @item @strong{Assume:}
hnoether_lib.tex(,1395) f is convenient, that is, f(x,0) != 0 != f(0,y);@*
hnoether_lib.tex(,1396) mu (optional) is Milnor number of f.@*
hnoether_lib.tex(,1397) NP (optional) is output of @code{newtonpoly(f)}.
hnoether_lib.tex(,1398) 
hnoether_lib.tex(,1399) @item @strong{Return:}
hnoether_lib.tex(,1400) int: 1 if f in Newton non-degenerate, 0 otherwise.
hnoether_lib.tex(,1401) 
hnoether_lib.tex(,1402) @cindex Newton non-degenerate
hnoether_lib.tex(,1403) @cindex Newton polygon
hnoether_lib.tex(,1404) @end table
hnoether_lib.tex(,1405) @strong{Example:}
hnoether_lib.tex(,1406) @smallexample
hnoether_lib.tex(,1407) @c computed example is_NND d2t_singular/hnoether_lib.doc:1052 
hnoether_lib.tex(,1408) LIB "hnoether.lib";
hnoether_lib.tex(,1409) ring r=0,(x,y),ls;
hnoether_lib.tex(,1410) poly f=x5+y3;
hnoether_lib.tex(,1411) is_NND(f);
hnoether_lib.tex(,1412) @expansion{} 1
hnoether_lib.tex(,1413) poly g=(x-y)^5+3xy5+y6-y7;
hnoether_lib.tex(,1414) is_NND(g);
hnoether_lib.tex(,1415) @expansion{} 0
hnoether_lib.tex(,1416) // if already computed, one should give the Minor number and Newton polygon
hnoether_lib.tex(,1417) // as second and third input: 
hnoether_lib.tex(,1418) int mu=milnor(g);
hnoether_lib.tex(,1419) list NP=newtonpoly(g);
hnoether_lib.tex(,1420) is_NND(g,mu,NP);
hnoether_lib.tex(,1421) @expansion{} 0
hnoether_lib.tex(,1422) @c end example is_NND d2t_singular/hnoether_lib.doc:1052
hnoether_lib.tex(,1423) @end smallexample
hnoether_lib.tex(,1424) @c inserted refs from d2t_singular/hnoether_lib.doc:1066
hnoether_lib.tex(,1435) @c end inserted refs from d2t_singular/hnoether_lib.doc:1066
hnoether_lib.tex(,1436) 
hnoether_lib.tex(,1437) @c ---end content is_NND---
hnoether_lib.tex(,1438) 
hnoether_lib.tex(,1439) @c ------------------- puiseux2generators -------------
hnoether_lib.tex(,1440) @node puiseux2generators, separateHNE, is_NND, hnoether_lib
hnoether_lib.tex(,1441) @subsubsection puiseux2generators
hnoether_lib.tex(,1442) @cindex puiseux2generators
hnoether_lib.tex(,1443) @c ---content puiseux2generators---
hnoether_lib.tex(,1444) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1445) 
hnoether_lib.tex(,1446) @table @asis
hnoether_lib.tex(,1447) @item @strong{Usage:}
hnoether_lib.tex(,1448) puiseux2generators(m,n); m,n intvec
hnoether_lib.tex(,1449) 
hnoether_lib.tex(,1450) @item @strong{Assume:}
hnoether_lib.tex(,1451) m, resp. n, represent the 1st, resp. 2nd, components of Puiseux pairs
hnoether_lib.tex(,1452) (e.g., @code{m=invariants(L)[3]}, @code{n=invariants(L)[4]}).
hnoether_lib.tex(,1453) 
hnoether_lib.tex(,1454) @item @strong{Return:}
hnoether_lib.tex(,1455) intvec of the generators of the semigroup of values.
hnoether_lib.tex(,1456) 
hnoether_lib.tex(,1457) @end table
hnoether_lib.tex(,1458) @strong{Example:}
hnoether_lib.tex(,1459) @smallexample
hnoether_lib.tex(,1460) @c computed example puiseux2generators d2t_singular/hnoether_lib.doc:1093 
hnoether_lib.tex(,1461) LIB "hnoether.lib";
hnoether_lib.tex(,1462) // take (3,2),(7,2),(15,2),(31,2),(63,2),(127,2) as Puiseux pairs:
hnoether_lib.tex(,1463) puiseux2generators(intvec(3,7,15,31,63,127),intvec(2,2,2,2,2,2));
hnoether_lib.tex(,1464) @expansion{} 64,96,208,424,852,1706,3413
hnoether_lib.tex(,1465) @c end example puiseux2generators d2t_singular/hnoether_lib.doc:1093
hnoether_lib.tex(,1466) @end smallexample
hnoether_lib.tex(,1467) @c inserted refs from d2t_singular/hnoether_lib.doc:1099
hnoether_lib.tex(,1478) @c end inserted refs from d2t_singular/hnoether_lib.doc:1099
hnoether_lib.tex(,1479) 
hnoether_lib.tex(,1480) @c ---end content puiseux2generators---
hnoether_lib.tex(,1481) 
hnoether_lib.tex(,1482) @c ------------------- separateHNE -------------
hnoether_lib.tex(,1483) @node separateHNE, squarefree, puiseux2generators, hnoether_lib
hnoether_lib.tex(,1484) @subsubsection separateHNE
hnoether_lib.tex(,1485) @cindex separateHNE
hnoether_lib.tex(,1486) @c ---content separateHNE---
hnoether_lib.tex(,1487) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1488) 
hnoether_lib.tex(,1489) @table @asis
hnoether_lib.tex(,1490) @item @strong{Usage:}
hnoether_lib.tex(,1491) separateHNE(hne1,hne2); hne1, hne2 lists
hnoether_lib.tex(,1492) 
hnoether_lib.tex(,1493) @item @strong{Assume:}
hnoether_lib.tex(,1494) hne1, hne2 are HNEs (=output of
hnoether_lib.tex(,1495) @code{develop(f)}, @code{extdevelop(develop(f),n)}, or
hnoether_lib.tex(,1496) one entry in the list @code{hne} in the ring created by
hnoether_lib.tex(,1497) @code{hnexpansion(f[,"ess"])}.
hnoether_lib.tex(,1498) 
hnoether_lib.tex(,1499) @item @strong{Return:}
hnoether_lib.tex(,1500) number of quadratic transformations needed to separate both curves
hnoether_lib.tex(,1501) (branches).
hnoether_lib.tex(,1502) 
hnoether_lib.tex(,1503) @end table
hnoether_lib.tex(,1504) @strong{Example:}
hnoether_lib.tex(,1505) @smallexample
hnoether_lib.tex(,1506) @c computed example separateHNE d2t_singular/hnoether_lib.doc:1129 
hnoether_lib.tex(,1507) LIB "hnoether.lib";
hnoether_lib.tex(,1508) int p=printlevel; printlevel=-1;
hnoether_lib.tex(,1509) ring r=0,(x,y),dp;
hnoether_lib.tex(,1510) list hne1=develop(x);
hnoether_lib.tex(,1511) list hne2=develop(x+y);
hnoether_lib.tex(,1512) list hne3=develop(x+y2);
hnoether_lib.tex(,1513) separateHNE(hne1,hne2);  // two transversal lines
hnoether_lib.tex(,1514) @expansion{} 1
hnoether_lib.tex(,1515) separateHNE(hne1,hne3);  // one quadratic transform. gives 1st example
hnoether_lib.tex(,1516) @expansion{} 2
hnoether_lib.tex(,1517) printlevel=p;
hnoether_lib.tex(,1518) @c end example separateHNE d2t_singular/hnoether_lib.doc:1129
hnoether_lib.tex(,1519) @end smallexample
hnoether_lib.tex(,1520) @c inserted refs from d2t_singular/hnoether_lib.doc:1141
hnoether_lib.tex(,1537) @c end inserted refs from d2t_singular/hnoether_lib.doc:1141
hnoether_lib.tex(,1538) 
hnoether_lib.tex(,1539) @c ---end content separateHNE---
hnoether_lib.tex(,1540) 
hnoether_lib.tex(,1541) @c ------------------- squarefree -------------
hnoether_lib.tex(,1542) @node squarefree, allsquarefree, separateHNE, hnoether_lib
hnoether_lib.tex(,1543) @subsubsection squarefree
hnoether_lib.tex(,1544) @cindex squarefree
hnoether_lib.tex(,1545) @c ---content squarefree---
hnoether_lib.tex(,1546) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1547) 
hnoether_lib.tex(,1548) @table @asis
hnoether_lib.tex(,1549) @item @strong{Usage:}
hnoether_lib.tex(,1550) squarefree(f); f poly
hnoether_lib.tex(,1551) 
hnoether_lib.tex(,1552) @item @strong{Assume:}
hnoether_lib.tex(,1553) f is a bivariate polynomial (in the first 2 ring variables).
hnoether_lib.tex(,1554) 
hnoether_lib.tex(,1555) @item @strong{Return:}
hnoether_lib.tex(,1556) poly, a squarefree divisor of f.
hnoether_lib.tex(,1557) 
hnoether_lib.tex(,1558) @item @strong{Note:}
hnoether_lib.tex(,1559) Usually, the return value is the greatest squarefree divisor, but
hnoether_lib.tex(,1560) there is one exception: factors with a p-th root, p the
hnoether_lib.tex(,1561) characteristic of the basering, are lost.
hnoether_lib.tex(,1562) 
hnoether_lib.tex(,1563) @end table
hnoether_lib.tex(,1564) @strong{Example:}
hnoether_lib.tex(,1565) @smallexample
hnoether_lib.tex(,1566) @c computed example squarefree d2t_singular/hnoether_lib.doc:1172 
hnoether_lib.tex(,1567) LIB "hnoether.lib";
hnoether_lib.tex(,1568) ring exring=3,(x,y),dp;
hnoether_lib.tex(,1569) squarefree((x3+y)^2);
hnoether_lib.tex(,1570) @expansion{} x3+y
hnoether_lib.tex(,1571) squarefree((x+y)^3*(x-y)^2); // Warning: (x+y)^3 is lost
hnoether_lib.tex(,1572) @expansion{} x-y
hnoether_lib.tex(,1573) squarefree((x+y)^4*(x-y)^2); // result is (x+y)*(x-y)
hnoether_lib.tex(,1574) @expansion{} x2-y2
hnoether_lib.tex(,1575) @c end example squarefree d2t_singular/hnoether_lib.doc:1172
hnoether_lib.tex(,1576) @end smallexample
hnoether_lib.tex(,1577) @c inserted refs from d2t_singular/hnoether_lib.doc:1180
hnoether_lib.tex(,1588) @c end inserted refs from d2t_singular/hnoether_lib.doc:1180
hnoether_lib.tex(,1589) 
hnoether_lib.tex(,1590) @c ---end content squarefree---
hnoether_lib.tex(,1591) 
hnoether_lib.tex(,1592) @c ------------------- allsquarefree -------------
hnoether_lib.tex(,1593) @node allsquarefree, further_hn_proc, squarefree, hnoether_lib
hnoether_lib.tex(,1594) @subsubsection allsquarefree
hnoether_lib.tex(,1595) @cindex allsquarefree
hnoether_lib.tex(,1596) @c ---content allsquarefree---
hnoether_lib.tex(,1597) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1598) 
hnoether_lib.tex(,1599) @table @asis
hnoether_lib.tex(,1600) @item @strong{Usage :}
hnoether_lib.tex(,1601) allsquarefree(f,g); f,g poly
hnoether_lib.tex(,1602) 
hnoether_lib.tex(,1603) @item @strong{Assume:}
hnoether_lib.tex(,1604) g is the output of @code{squarefree(f)}.
hnoether_lib.tex(,1605) 
hnoether_lib.tex(,1606) @item @strong{Return:}
hnoether_lib.tex(,1607) the greatest squarefree divisor of f.
hnoether_lib.tex(,1608) 
hnoether_lib.tex(,1609) @item @strong{Note  :}
hnoether_lib.tex(,1610) This proc uses factorize to get the missing factors of f not in g and,
hnoether_lib.tex(,1611) therefore, may be slow.
hnoether_lib.tex(,1612) 
hnoether_lib.tex(,1613) @end table
hnoether_lib.tex(,1614) @strong{Example:}
hnoether_lib.tex(,1615) @smallexample
hnoether_lib.tex(,1616) @c computed example allsquarefree d2t_singular/hnoether_lib.doc:1210 
hnoether_lib.tex(,1617) LIB "hnoether.lib";
hnoether_lib.tex(,1618) ring exring=7,(x,y),dp;
hnoether_lib.tex(,1619) poly f=(x+y)^7*(x-y)^8;
hnoether_lib.tex(,1620) poly g=squarefree(f);
hnoether_lib.tex(,1621) g;                      // factor x+y lost, since characteristic=7
hnoether_lib.tex(,1622) @expansion{} x-y
hnoether_lib.tex(,1623) allsquarefree(f,g);     // all factors (x+y)*(x-y) found
hnoether_lib.tex(,1624) @expansion{} x2-y2
hnoether_lib.tex(,1625) @c end example allsquarefree d2t_singular/hnoether_lib.doc:1210
hnoether_lib.tex(,1626) @end smallexample
hnoether_lib.tex(,1627) @c inserted refs from d2t_singular/hnoether_lib.doc:1219
hnoether_lib.tex(,1638) @c end inserted refs from d2t_singular/hnoether_lib.doc:1219
hnoether_lib.tex(,1639) 
hnoether_lib.tex(,1640) @c ---end content allsquarefree---
hnoether_lib.tex(,1641) 
hnoether_lib.tex(,1642) @c ------------------- further_hn_proc -------------
hnoether_lib.tex(,1643) @node further_hn_proc,, allsquarefree, hnoether_lib
hnoether_lib.tex(,1644) @subsubsection further_hn_proc
hnoether_lib.tex(,1645) @cindex further_hn_proc
hnoether_lib.tex(,1646) @c ---content further_hn_proc---
hnoether_lib.tex(,1647) Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).
hnoether_lib.tex(,1648) 
hnoether_lib.tex(,1649) @table @asis
hnoether_lib.tex(,1650) @item @strong{Usage:}
hnoether_lib.tex(,1651) further_hn_proc();
hnoether_lib.tex(,1652) 
hnoether_lib.tex(,1653) @item @strong{Note:}
hnoether_lib.tex(,1654) The library @code{hnoether.lib} contains some more procedures which
hnoether_lib.tex(,1655) are not shown when typing @code{help hnoether.lib;}. They may be useful
hnoether_lib.tex(,1656) for interactive use (e.g. if you want to do the calculation of an HN
hnoether_lib.tex(,1657) development "by hand" to see the intermediate results), and they
hnoether_lib.tex(,1658) can be enumerated by calling @code{further_hn_proc()}. @*
hnoether_lib.tex(,1659) Use @code{help <procedure>;} for detailed information about each of
hnoether_lib.tex(,1660) them.
hnoether_lib.tex(,1661) 
hnoether_lib.tex(,1662) @end table
hnoether_lib.tex(,1663) @strong{Example:}
hnoether_lib.tex(,1664) @smallexample
hnoether_lib.tex(,1665) @c computed example further_hn_proc d2t_singular/hnoether_lib.doc:1248 
hnoether_lib.tex(,1666) LIB "hnoether.lib";
hnoether_lib.tex(,1667) further_hn_proc();
hnoether_lib.tex(,1668) @expansion{} 
hnoether_lib.tex(,1669) @expansion{}  The following procedures are also part of `hnoether.lib':
hnoether_lib.tex(,1670) @expansion{} 
hnoether_lib.tex(,1671) @expansion{}  getnm(f);           intersection pts. of Newton polygon with axes
hnoether_lib.tex(,1672) @expansion{}  T_Transform(f,Q,N); returns f(y,xy^Q)/y^NQ (f: poly, Q,N: int)
hnoether_lib.tex(,1673) @expansion{}  T1_Transform(f,d,M); returns f(x,y+d*x^M)  (f: poly,d:number,M:int)
hnoether_lib.tex(,1674) @expansion{}  T2_Transform(f,d,M,N,ref);   a composition of T1 & T
hnoether_lib.tex(,1675) @expansion{}  koeff(f,I,J);       gets coefficient of indicated monomial of poly f
hnoether_lib.tex(,1676) @expansion{}  redleit(f,S,E);     restriction of monomials of f to line (S-E)
hnoether_lib.tex(,1677) @expansion{}  leit(f,n,m);        special case of redleit (for irred. polynomials)
hnoether_lib.tex(,1678) @expansion{}  testreducible(f,n,m); tests whether f is reducible
hnoether_lib.tex(,1679) @expansion{}  charPoly(f,M,N);    characteristic polynomial of f
hnoether_lib.tex(,1680) @expansion{}  find_in_list(L,p);  find int p in list L
hnoether_lib.tex(,1681) @expansion{}  get_last_divisor(M,N); last divisor in Euclid's algorithm
hnoether_lib.tex(,1682) @expansion{}  factorfirst(f,M,N); try to factor f without `factorize'
hnoether_lib.tex(,1683) @expansion{}  factorlist(L);      factorize a list L of polynomials
hnoether_lib.tex(,1684) @expansion{}  referencepoly(D);   a polynomial f s.t. D is the Newton diagram of f
hnoether_lib.tex(,1685) @c end example further_hn_proc d2t_singular/hnoether_lib.doc:1248
hnoether_lib.tex(,1686) @end smallexample
hnoether_lib.tex(,1687) @c ---end content further_hn_proc---
singular.texi(,475) @c ---------------------------------------------------------
singular.texi(,476) @node mondromy_lib, qhmoduli_lib, hnoether_lib, Singularities
singular.texi(,477) @subsection mondromy_lib
singular.texi(,478) @c include of docu for mondromy.lib
mondromy_lib.tex(,1) @c ---content LibInfo---
mondromy_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/mondromy_lib.doc
mondromy_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/mondromy_lib.doc INSTEAD
mondromy_lib.tex(,4) @c library version: (1.22.2.2,2002/02/20)
mondromy_lib.tex(,5) @c library file: ../Singular/LIB/mondromy.lib
mondromy_lib.tex(,6) @cindex mondromy.lib
mondromy_lib.tex(,7) @cindex mondromy_lib
mondromy_lib.tex(,8) @table @asis
mondromy_lib.tex(,9) @item @strong{Library:}
mondromy_lib.tex(,10) mondromy.lib
mondromy_lib.tex(,11) @item @strong{Purpose:}
mondromy_lib.tex(,12)   Monodromy of an Isolated Hypersurface Singularity
mondromy_lib.tex(,13) @item @strong{Author:}
mondromy_lib.tex(,14) Mathias Schulze, email: mschulze@@mathematik.uni-kl.de
mondromy_lib.tex(,15) 
mondromy_lib.tex(,16) @item @strong{Overview:}
mondromy_lib.tex(,17) A library to compute the monodromy of an isolated hypersurface singularity.
mondromy_lib.tex(,18) It uses an algorithm by Brieskorn (manuscripta math. 2 (1970), 103-161) to
mondromy_lib.tex(,19) compute a connection matrix of the meromorphic Gauss-Manin connection up to
mondromy_lib.tex(,20) arbitrarily high order, and an algorithm of Gerard and Levelt (Ann. Inst.
mondromy_lib.tex(,21) Fourier, Grenoble 23,1 (1973), pp. 157-195) to transform it to a simple pole.
mondromy_lib.tex(,22) 
mondromy_lib.tex(,23) @end table
mondromy_lib.tex(,24) 
mondromy_lib.tex(,25) @strong{Procedures:}
mondromy_lib.tex(,26) @menu
mondromy_lib.tex(,27) * detadj:: determinant and adjoint matrix of square matrix U
mondromy_lib.tex(,28) * invunit:: series inverse of polynomial u up to order n
mondromy_lib.tex(,29) * jacoblift:: lifts f^kappa in jacob(f) with minimal kappa
mondromy_lib.tex(,30) * monodromyB:: monodromy of isolated hypersurface singularity f
mondromy_lib.tex(,31) * H2basis:: basis of Brieskorn lattice H''
mondromy_lib.tex(,32) @end menu
mondromy_lib.tex(,33) @cindex Monodromy
mondromy_lib.tex(,34) @cindex hypersurface singularity
mondromy_lib.tex(,35) @cindex Gauss-Manin connection
mondromy_lib.tex(,36) @cindex Brieskorn lattice
mondromy_lib.tex(,37) @c inserted refs from d2t_singular/mondromy_lib.doc:35
mondromy_lib.tex(,48) @c end inserted refs from d2t_singular/mondromy_lib.doc:35
mondromy_lib.tex(,49) 
mondromy_lib.tex(,50) @c ---end content LibInfo---
mondromy_lib.tex(,51) 
mondromy_lib.tex(,52) @c ------------------- detadj -------------
mondromy_lib.tex(,53) @node detadj, invunit,, mondromy_lib
mondromy_lib.tex(,54) @subsubsection detadj
mondromy_lib.tex(,55) @cindex detadj
mondromy_lib.tex(,56) @c ---content detadj---
mondromy_lib.tex(,57) Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).
mondromy_lib.tex(,58) 
mondromy_lib.tex(,59) @table @asis
mondromy_lib.tex(,60) @item @strong{Usage:}
mondromy_lib.tex(,61) detadj(U); U matrix
mondromy_lib.tex(,62) 
mondromy_lib.tex(,63) @item @strong{Assume:}
mondromy_lib.tex(,64) U is a square matrix with non zero determinant.
mondromy_lib.tex(,65) 
mondromy_lib.tex(,66) @item @strong{Return:}
mondromy_lib.tex(,67) The procedure returns a list with at most 2 entries.
mondromy_lib.tex(,68) @*If U is not a square matrix, the list is empty.
mondromy_lib.tex(,69) @*If U is a square matrix, then the first entry is the determinant of U.
mondromy_lib.tex(,70) If U is a square matrix and the determinant of U not zero,
mondromy_lib.tex(,71) then the second entry is the adjoint matrix of U.
mondromy_lib.tex(,72) 
mondromy_lib.tex(,73) @item @strong{Display:}
mondromy_lib.tex(,74) The procedure displays comments if printlevel>=1.
mondromy_lib.tex(,75) 
mondromy_lib.tex(,76) @end table
mondromy_lib.tex(,77) @strong{Example:}
mondromy_lib.tex(,78) @smallexample
mondromy_lib.tex(,79) @c computed example detadj d2t_singular/mondromy_lib.doc:68 
mondromy_lib.tex(,80) LIB "mondromy.lib";
mondromy_lib.tex(,81) ring R=0,x,dp;
mondromy_lib.tex(,82) matrix U[2][2]=1,1+x,1+x2,1+x3;
mondromy_lib.tex(,83) list daU=detadj(U);
mondromy_lib.tex(,84) daU[1];
mondromy_lib.tex(,85) @expansion{} -x2-x
mondromy_lib.tex(,86) print(daU[2]);
mondromy_lib.tex(,87) @expansion{} x3+1, -x-1,
mondromy_lib.tex(,88) @expansion{} -x2-1,1    
mondromy_lib.tex(,89) @c end example detadj d2t_singular/mondromy_lib.doc:68
mondromy_lib.tex(,90) @end smallexample
mondromy_lib.tex(,91) @c ---end content detadj---
mondromy_lib.tex(,92) 
mondromy_lib.tex(,93) @c ------------------- invunit -------------
mondromy_lib.tex(,94) @node invunit, jacoblift, detadj, mondromy_lib
mondromy_lib.tex(,95) @subsubsection invunit
mondromy_lib.tex(,96) @cindex invunit
mondromy_lib.tex(,97) @c ---content invunit---
mondromy_lib.tex(,98) Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).
mondromy_lib.tex(,99) 
mondromy_lib.tex(,100) @table @asis
mondromy_lib.tex(,101) @item @strong{Usage:}
mondromy_lib.tex(,102) invunit(u,n); u poly, n int
mondromy_lib.tex(,103) 
mondromy_lib.tex(,104) @item @strong{Assume:}
mondromy_lib.tex(,105) The polynomial u is a series unit.
mondromy_lib.tex(,106) 
mondromy_lib.tex(,107) @item @strong{Return:}
mondromy_lib.tex(,108) The procedure returns the series inverse of u up to order n
mondromy_lib.tex(,109) or a zero polynomial if u is no series unit.
mondromy_lib.tex(,110) 
mondromy_lib.tex(,111) @item @strong{Display:}
mondromy_lib.tex(,112) The procedure displays comments if printlevel>=1.
mondromy_lib.tex(,113) 
mondromy_lib.tex(,114) @end table
mondromy_lib.tex(,115) @strong{Example:}
mondromy_lib.tex(,116) @smallexample
mondromy_lib.tex(,117) @c computed example invunit d2t_singular/mondromy_lib.doc:103 
mondromy_lib.tex(,118) LIB "mondromy.lib";
mondromy_lib.tex(,119) ring R=0,(x,y),dp;
mondromy_lib.tex(,120) invunit(2+x3+xy4,10);
mondromy_lib.tex(,121) @expansion{} 1/8x2y8-1/16x9+1/4x4y4+1/8x6-1/4xy4-1/4x3+1/2
mondromy_lib.tex(,122) @c end example invunit d2t_singular/mondromy_lib.doc:103
mondromy_lib.tex(,123) @end smallexample
mondromy_lib.tex(,124) @c ---end content invunit---
mondromy_lib.tex(,125) 
mondromy_lib.tex(,126) @c ------------------- jacoblift -------------
mondromy_lib.tex(,127) @node jacoblift, monodromyB, invunit, mondromy_lib
mondromy_lib.tex(,128) @subsubsection jacoblift
mondromy_lib.tex(,129) @cindex jacoblift
mondromy_lib.tex(,130) @c ---content jacoblift---
mondromy_lib.tex(,131) Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).
mondromy_lib.tex(,132) 
mondromy_lib.tex(,133) @table @asis
mondromy_lib.tex(,134) @item @strong{Usage:}
mondromy_lib.tex(,135) jacoblift(f); f poly
mondromy_lib.tex(,136) 
mondromy_lib.tex(,137) @item @strong{Assume:}
mondromy_lib.tex(,138) The polynomial f in a series ring (local ordering) defines
mondromy_lib.tex(,139) an isolated hypersurface singularity.
mondromy_lib.tex(,140) 
mondromy_lib.tex(,141) @item @strong{Return:}
mondromy_lib.tex(,142) The procedure returns a list with entries kappa, xi, u of type
mondromy_lib.tex(,143) int, vector, poly such that kappa is minimal with f^kappa in jacob(f),
mondromy_lib.tex(,144) u is a unit, and u*f^kappa=(matrix(jacob(f))*xi)[1,1].
mondromy_lib.tex(,145) 
mondromy_lib.tex(,146) @item @strong{Display:}
mondromy_lib.tex(,147) The procedure displays comments if printlevel>=1.
mondromy_lib.tex(,148) 
mondromy_lib.tex(,149) @end table
mondromy_lib.tex(,150) @strong{Example:}
mondromy_lib.tex(,151) @smallexample
mondromy_lib.tex(,152) @c computed example jacoblift d2t_singular/mondromy_lib.doc:137 
mondromy_lib.tex(,153) LIB "mondromy.lib";
mondromy_lib.tex(,154) ring R=0,(x,y),ds;
mondromy_lib.tex(,155) poly f=x2y2+x6+y6;
mondromy_lib.tex(,156) jacoblift(f);
mondromy_lib.tex(,157) @expansion{} [1]:
mondromy_lib.tex(,158) @expansion{}    2
mondromy_lib.tex(,159) @expansion{} [2]:
mondromy_lib.tex(,160) @expansion{}    1/2x2y3*gen(2)+1/6x7*gen(1)+5/6x6y*gen(2)-2/3xy6*gen(1)+1/6y7*gen(2)-4\
mondromy_lib.tex(,161)    x4y5*gen(2)-3/2x9y2*gen(1)-15/2x8y3*gen(2)+9/2x3y8*gen(1)-3/2x2y9*gen(2)
mondromy_lib.tex(,162) @expansion{} [3]:
mondromy_lib.tex(,163) @expansion{}    1-9x2y2
mondromy_lib.tex(,164) @c end example jacoblift d2t_singular/mondromy_lib.doc:137
mondromy_lib.tex(,165) @end smallexample
mondromy_lib.tex(,166) @c ---end content jacoblift---
mondromy_lib.tex(,167) 
mondromy_lib.tex(,168) @c ------------------- monodromyB -------------
mondromy_lib.tex(,169) @node monodromyB, H2basis, jacoblift, mondromy_lib
mondromy_lib.tex(,170) @subsubsection monodromyB
mondromy_lib.tex(,171) @cindex monodromyB
mondromy_lib.tex(,172) @c ---content monodromyB---
mondromy_lib.tex(,173) Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).
mondromy_lib.tex(,174) 
mondromy_lib.tex(,175) @table @asis
mondromy_lib.tex(,176) @item @strong{Usage:}
mondromy_lib.tex(,177) monodromyB(f[,opt]); f poly, opt int
mondromy_lib.tex(,178) 
mondromy_lib.tex(,179) @item @strong{Assume:}
mondromy_lib.tex(,180) The polynomial f in a series ring (local ordering) defines
mondromy_lib.tex(,181) an isolated hypersurface singularity.
mondromy_lib.tex(,182) 
mondromy_lib.tex(,183) @item @strong{Return:}
mondromy_lib.tex(,184) The procedure returns a residue matrix M of the meromorphic
mondromy_lib.tex(,185) Gauss-Manin connection of the singularity defined by f
mondromy_lib.tex(,186) or an empty matrix if the assumptions are not fulfilled.
mondromy_lib.tex(,187) If opt=0 (default), exp(-2*pi*i*M) is a monodromy matrix of f,
mondromy_lib.tex(,188) else, only the characteristic polynomial of exp(-2*pi*i*M) coincides
mondromy_lib.tex(,189) with the characteristic polynomial of the monodromy of f.
mondromy_lib.tex(,190) 
mondromy_lib.tex(,191) @item @strong{Display:}
mondromy_lib.tex(,192) The procedure displays more comments for higher printlevel.
mondromy_lib.tex(,193) 
mondromy_lib.tex(,194) @end table
mondromy_lib.tex(,195) @strong{Example:}
mondromy_lib.tex(,196) @smallexample
mondromy_lib.tex(,197) @c computed example monodromyB d2t_singular/mondromy_lib.doc:175 
mondromy_lib.tex(,198) LIB "mondromy.lib";
mondromy_lib.tex(,199) ring R=0,(x,y),ds;
mondromy_lib.tex(,200) poly f=x2y2+x6+y6;
mondromy_lib.tex(,201) matrix M=monodromyB(f);
mondromy_lib.tex(,202) print(M);
mondromy_lib.tex(,203) @expansion{} 7/6,0,  0,0,  0,  0,0,   0,-1/2,0,  0,  0,    0,       
mondromy_lib.tex(,204) @expansion{} 0,  7/6,0,0,  0,  0,-1/2,0,0,   0,  0,  0,    0,       
mondromy_lib.tex(,205) @expansion{} 0,  0,  1,0,  0,  0,0,   0,0,   0,  0,  0,    0,       
mondromy_lib.tex(,206) @expansion{} 0,  0,  0,4/3,0,  0,0,   0,0,   0,  0,  0,    0,       
mondromy_lib.tex(,207) @expansion{} 0,  0,  0,0,  4/3,0,0,   0,0,   0,  0,  0,    0,       
mondromy_lib.tex(,208) @expansion{} 0,  0,  0,0,  0,  1,0,   0,0,   0,  0,  0,    0,       
mondromy_lib.tex(,209) @expansion{} 0,  0,  0,0,  0,  0,5/6, 0,0,   0,  0,  0,    0,       
mondromy_lib.tex(,210) @expansion{} 0,  0,  0,0,  0,  0,0,   1,0,   0,  0,  0,    0,       
mondromy_lib.tex(,211) @expansion{} 0,  0,  0,0,  0,  0,0,   0,5/6, 0,  0,  0,    0,       
mondromy_lib.tex(,212) @expansion{} 0,  0,  0,0,  0,  0,0,   0,0,   2/3,0,  0,    0,       
mondromy_lib.tex(,213) @expansion{} 0,  0,  0,0,  0,  0,0,   0,0,   0,  2/3,0,    0,       
mondromy_lib.tex(,214) @expansion{} 0,  0,  0,0,  0,  0,0,   0,0,   0,  0,  47/44,-625/396,
mondromy_lib.tex(,215) @expansion{} 0,  0,  0,0,  0,  0,0,   0,0,   0,  0,  9/44, -3/44    
mondromy_lib.tex(,216) @c end example monodromyB d2t_singular/mondromy_lib.doc:175
mondromy_lib.tex(,217) @end smallexample
mondromy_lib.tex(,218) @c ---end content monodromyB---
mondromy_lib.tex(,219) 
mondromy_lib.tex(,220) @c ------------------- H2basis -------------
mondromy_lib.tex(,221) @node H2basis,, monodromyB, mondromy_lib
mondromy_lib.tex(,222) @subsubsection H2basis
mondromy_lib.tex(,223) @cindex H2basis
mondromy_lib.tex(,224) @c ---content H2basis---
mondromy_lib.tex(,225) Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).
mondromy_lib.tex(,226) 
mondromy_lib.tex(,227) @table @asis
mondromy_lib.tex(,228) @item @strong{Usage:}
mondromy_lib.tex(,229) H2basis(f); f poly
mondromy_lib.tex(,230) 
mondromy_lib.tex(,231) @item @strong{Assume:}
mondromy_lib.tex(,232) The polynomial f in a series ring (local ordering) defines
mondromy_lib.tex(,233) an isolated hypersurface singularity.
mondromy_lib.tex(,234) 
mondromy_lib.tex(,235) @item @strong{Return:}
mondromy_lib.tex(,236) The procedure returns a list of representatives of a C@{f@}-basis of the
mondromy_lib.tex(,237) Brieskorn lattice H''=Omega^(n+1)/df^dOmega^(n-1).
mondromy_lib.tex(,238) 
mondromy_lib.tex(,239) @item @strong{Theory:}
mondromy_lib.tex(,240) H'' is a free C@{f@}-module of rank milnor(f).
mondromy_lib.tex(,241) 
mondromy_lib.tex(,242) @item @strong{Display:}
mondromy_lib.tex(,243) The procedure displays more comments for higher printlevel.
mondromy_lib.tex(,244) 
mondromy_lib.tex(,245) @end table
mondromy_lib.tex(,246) @strong{Example:}
mondromy_lib.tex(,247) @smallexample
mondromy_lib.tex(,248) @c computed example H2basis d2t_singular/mondromy_lib.doc:213 
mondromy_lib.tex(,249) LIB "mondromy.lib";
mondromy_lib.tex(,250) ring R=0,(x,y),ds;
mondromy_lib.tex(,251) poly f=x2y2+x6+y6;
mondromy_lib.tex(,252) H2basis(f);
mondromy_lib.tex(,253) @expansion{} [1]:
mondromy_lib.tex(,254) @expansion{}    x4
mondromy_lib.tex(,255) @expansion{} [2]:
mondromy_lib.tex(,256) @expansion{}    x2y2
mondromy_lib.tex(,257) @expansion{} [3]:
mondromy_lib.tex(,258) @expansion{}    y4
mondromy_lib.tex(,259) @expansion{} [4]:
mondromy_lib.tex(,260) @expansion{}    x3
mondromy_lib.tex(,261) @expansion{} [5]:
mondromy_lib.tex(,262) @expansion{}    x2y
mondromy_lib.tex(,263) @expansion{} [6]:
mondromy_lib.tex(,264) @expansion{}    xy2
mondromy_lib.tex(,265) @expansion{} [7]:
mondromy_lib.tex(,266) @expansion{}    y3
mondromy_lib.tex(,267) @expansion{} [8]:
mondromy_lib.tex(,268) @expansion{}    x2
mondromy_lib.tex(,269) @expansion{} [9]:
mondromy_lib.tex(,270) @expansion{}    xy
mondromy_lib.tex(,271) @expansion{} [10]:
mondromy_lib.tex(,272) @expansion{}    y2
mondromy_lib.tex(,273) @expansion{} [11]:
mondromy_lib.tex(,274) @expansion{}    x
mondromy_lib.tex(,275) @expansion{} [12]:
mondromy_lib.tex(,276) @expansion{}    y
mondromy_lib.tex(,277) @expansion{} [13]:
mondromy_lib.tex(,278) @expansion{}    1
mondromy_lib.tex(,279) @c end example H2basis d2t_singular/mondromy_lib.doc:213
mondromy_lib.tex(,280) @end smallexample
mondromy_lib.tex(,281) @c ---end content H2basis---
singular.texi(,480) @c ---------------------------------------------------------
singular.texi(,481) @node qhmoduli_lib, sing_lib, mondromy_lib, Singularities
singular.texi(,482) @subsection qhmoduli_lib
singular.texi(,483) @c include of docu for qhmoduli.lib
qhmoduli_lib.tex(,1) @c ---content LibInfo---
qhmoduli_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/qhmoduli_lib.doc
qhmoduli_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/qhmoduli_lib.doc INSTEAD
qhmoduli_lib.tex(,4) @c library version: (1.0,2000/12/12)
qhmoduli_lib.tex(,5) @c library file: ../Singular/LIB/qhmoduli.lib
qhmoduli_lib.tex(,6) @cindex qhmoduli.lib
qhmoduli_lib.tex(,7) @cindex qhmoduli_lib
qhmoduli_lib.tex(,8) @table @asis
qhmoduli_lib.tex(,9) @item @strong{Library:}
qhmoduli_lib.tex(,10) qhmoduli.lib
qhmoduli_lib.tex(,11) @item @strong{Purpose:}
qhmoduli_lib.tex(,12)     Moduli Spaces of Semi-Quasihomogeneous Singularities
qhmoduli_lib.tex(,13) @item @strong{Author:}
qhmoduli_lib.tex(,14) Thomas Bayer, email: bayert@@in.tum.de
qhmoduli_lib.tex(,15) 
qhmoduli_lib.tex(,16) @end table
qhmoduli_lib.tex(,17) 
qhmoduli_lib.tex(,18) @strong{Procedures:}
qhmoduli_lib.tex(,19) @menu
qhmoduli_lib.tex(,20) * ArnoldAction:: Induced action of G_f on T_.
qhmoduli_lib.tex(,21) * ModEqn:: Equations of the moduli space for principal part f
qhmoduli_lib.tex(,22) * QuotientEquations:: Equations of Variety(I)/G w.r.t. action 'A'
qhmoduli_lib.tex(,23) * StabEqn:: Equations of the stabilizer of f.
qhmoduli_lib.tex(,24) * StabEqnId:: Equations of the stabilizer of the qhom. ideal I.
qhmoduli_lib.tex(,25) * StabOrder:: Order of the stabilizer of f.
qhmoduli_lib.tex(,26) * UpperMonomials:: Upper basis of the Milnor algebra of f.
qhmoduli_lib.tex(,27) * Max:: maximal integer contained in 'data'
qhmoduli_lib.tex(,28) * Min:: minimal integer contained in 'data'
qhmoduli_lib.tex(,29) * Table:: list, i-th entry is cmd(i), lb <= i <= ub
qhmoduli_lib.tex(,30) @end menu
qhmoduli_lib.tex(,31) @c ---end content LibInfo---
qhmoduli_lib.tex(,32) 
qhmoduli_lib.tex(,33) @c ------------------- ArnoldAction -------------
qhmoduli_lib.tex(,34) @node ArnoldAction, ModEqn,, qhmoduli_lib
qhmoduli_lib.tex(,35) @subsubsection ArnoldAction
qhmoduli_lib.tex(,36) @cindex ArnoldAction
qhmoduli_lib.tex(,37) @c ---content ArnoldAction---
qhmoduli_lib.tex(,38) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,39) 
qhmoduli_lib.tex(,40) @table @asis
qhmoduli_lib.tex(,41) @item @strong{Usage:}
qhmoduli_lib.tex(,42) ArnoldAction(f, [Gf, B]); poly f; list Gf, B;
qhmoduli_lib.tex(,43) @*'Gf' is a list of two rings (coming from 'StabEqn')
qhmoduli_lib.tex(,44) 
qhmoduli_lib.tex(,45) @item @strong{Purpose:}
qhmoduli_lib.tex(,46) compute the induced action of the stabilizer G of f on T_, where
qhmoduli_lib.tex(,47) T_ is given by the upper monomials B of the Milnor algebra of f.
qhmoduli_lib.tex(,48) 
qhmoduli_lib.tex(,49) @item @strong{Assume:}
qhmoduli_lib.tex(,50) f is quasihomogeneous
qhmoduli_lib.tex(,51) 
qhmoduli_lib.tex(,52) @item @strong{Return:}
qhmoduli_lib.tex(,53) polynomial ring over the same ground field, containing the ideals
qhmoduli_lib.tex(,54) 'actionid' and 'stabid'.
qhmoduli_lib.tex(,55) @*- 'actionid' is the ideal defining the induced action of Gf on T_ @*
qhmoduli_lib.tex(,56) - 'stabid' is the ideal of the stabilizer Gf in the new ring
qhmoduli_lib.tex(,57) 
qhmoduli_lib.tex(,58) @end table
qhmoduli_lib.tex(,59) @strong{Example:}
qhmoduli_lib.tex(,60) @smallexample
qhmoduli_lib.tex(,61) @c computed example ArnoldAction d2t_singular/qhmoduli_lib.doc:59 
qhmoduli_lib.tex(,62) LIB "qhmoduli.lib";
qhmoduli_lib.tex(,63) ring B   = 0,(x,y,z), ls;
qhmoduli_lib.tex(,64) poly f = -z5+y5+x2z+x2y;
qhmoduli_lib.tex(,65) def R = ArnoldAction(f);
qhmoduli_lib.tex(,66) setring R;
qhmoduli_lib.tex(,67) actionid;
qhmoduli_lib.tex(,68) @expansion{} actionid[1]=-s(2)*t(1)+s(3)*t(1)
qhmoduli_lib.tex(,69) @expansion{} actionid[2]=-s(2)^2*t(2)+2*s(2)^2*t(3)^2+s(3)^2*t(2)
qhmoduli_lib.tex(,70) @expansion{} actionid[3]=s(2)*t(3)+s(3)*t(3)
qhmoduli_lib.tex(,71) stabid;
qhmoduli_lib.tex(,72) @expansion{} stabid[1]=s(2)*s(3)
qhmoduli_lib.tex(,73) @expansion{} stabid[2]=s(1)^2*s(2)+s(1)^2*s(3)-1
qhmoduli_lib.tex(,74) @expansion{} stabid[3]=s(1)^2*s(3)^2-s(3)
qhmoduli_lib.tex(,75) @expansion{} stabid[4]=s(1)^2+s(2)^4-s(3)^4
qhmoduli_lib.tex(,76) @expansion{} stabid[5]=s(1)^4+s(2)^3-s(3)^3
qhmoduli_lib.tex(,77) @expansion{} stabid[6]=-s(1)^2*s(3)+s(3)^5
qhmoduli_lib.tex(,78) @c end example ArnoldAction d2t_singular/qhmoduli_lib.doc:59
qhmoduli_lib.tex(,79) @end smallexample
qhmoduli_lib.tex(,80) @c ---end content ArnoldAction---
qhmoduli_lib.tex(,81) 
qhmoduli_lib.tex(,82) @c ------------------- ModEqn -------------
qhmoduli_lib.tex(,83) @node ModEqn, QuotientEquations, ArnoldAction, qhmoduli_lib
qhmoduli_lib.tex(,84) @subsubsection ModEqn
qhmoduli_lib.tex(,85) @cindex ModEqn
qhmoduli_lib.tex(,86) @c ---content ModEqn---
qhmoduli_lib.tex(,87) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,88) 
qhmoduli_lib.tex(,89) @table @asis
qhmoduli_lib.tex(,90) @item @strong{Usage:}
qhmoduli_lib.tex(,91) ModEqn(f [, opt]); poly f; int opt;
qhmoduli_lib.tex(,92) 
qhmoduli_lib.tex(,93) @item @strong{Purpose:}
qhmoduli_lib.tex(,94) compute equations of the moduli space of semiquasihomogeneous hypersurface singularity with principal part f w.r.t. right equivalence
qhmoduli_lib.tex(,95) 
qhmoduli_lib.tex(,96) @item @strong{Assume:}
qhmoduli_lib.tex(,97) f quasihomogeneous polynomial with an isolated singularity at 0
qhmoduli_lib.tex(,98) 
qhmoduli_lib.tex(,99) @item @strong{Return:}
qhmoduli_lib.tex(,100) polynomial ring, possibly a simple extension of the ground field of
qhmoduli_lib.tex(,101) the basering, containing the ideal 'modid'
qhmoduli_lib.tex(,102) @*- 'modid' is the ideal of the moduli space if opt is even (> 0).
qhmoduli_lib.tex(,103) otherwise it contains generators of the coordinate ring R of the
qhmoduli_lib.tex(,104) moduli space (note : Spec(R) is the moduli space)
qhmoduli_lib.tex(,105) 
qhmoduli_lib.tex(,106) @item @strong{Options:}
qhmoduli_lib.tex(,107) 1 compute equations of the mod. space,
qhmoduli_lib.tex(,108) @*2 use a primary decomposition
qhmoduli_lib.tex(,109) @*4 compute E_f0, i.e., the image of G_f0
qhmoduli_lib.tex(,110) @*To combine options, add their value, default: opt =7
qhmoduli_lib.tex(,111) 
qhmoduli_lib.tex(,112) @end table
qhmoduli_lib.tex(,113) @strong{Example:}
qhmoduli_lib.tex(,114) @smallexample
qhmoduli_lib.tex(,115) @c computed example ModEqn d2t_singular/qhmoduli_lib.doc:104 
qhmoduli_lib.tex(,116) LIB "qhmoduli.lib";
qhmoduli_lib.tex(,117) ring B   = 0,(x,y), ls;
qhmoduli_lib.tex(,118) poly f = -x4 + xy5;
qhmoduli_lib.tex(,119) def R = ModEqn(f);
qhmoduli_lib.tex(,120) setring R;
qhmoduli_lib.tex(,121) modid;
qhmoduli_lib.tex(,122) @expansion{} modid[1]=Y(5)^2-Y(4)*Y(6)
qhmoduli_lib.tex(,123) @expansion{} modid[2]=Y(4)*Y(5)-Y(3)*Y(6)
qhmoduli_lib.tex(,124) @expansion{} modid[3]=Y(3)*Y(5)-Y(2)*Y(6)
qhmoduli_lib.tex(,125) @expansion{} modid[4]=Y(2)*Y(5)-Y(1)*Y(6)
qhmoduli_lib.tex(,126) @expansion{} modid[5]=Y(4)^2-Y(2)*Y(6)
qhmoduli_lib.tex(,127) @expansion{} modid[6]=Y(3)*Y(4)-Y(1)*Y(6)
qhmoduli_lib.tex(,128) @expansion{} modid[7]=Y(2)*Y(4)-Y(1)*Y(5)
qhmoduli_lib.tex(,129) @expansion{} modid[8]=Y(3)^2-Y(1)*Y(5)
qhmoduli_lib.tex(,130) @expansion{} modid[9]=Y(2)*Y(3)-Y(1)*Y(4)
qhmoduli_lib.tex(,131) @expansion{} modid[10]=Y(2)^2-Y(1)*Y(3)
qhmoduli_lib.tex(,132) @c end example ModEqn d2t_singular/qhmoduli_lib.doc:104
qhmoduli_lib.tex(,133) @end smallexample
qhmoduli_lib.tex(,134) @c ---end content ModEqn---
qhmoduli_lib.tex(,135) 
qhmoduli_lib.tex(,136) @c ------------------- QuotientEquations -------------
qhmoduli_lib.tex(,137) @node QuotientEquations, StabEqn, ModEqn, qhmoduli_lib
qhmoduli_lib.tex(,138) @subsubsection QuotientEquations
qhmoduli_lib.tex(,139) @cindex QuotientEquations
qhmoduli_lib.tex(,140) @c ---content QuotientEquations---
qhmoduli_lib.tex(,141) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,142) 
qhmoduli_lib.tex(,143) @table @asis
qhmoduli_lib.tex(,144) @item @strong{Usage:}
qhmoduli_lib.tex(,145) QuotientEquations(G,action,emb [, opt]); ideal G,action,emb;int opt
qhmoduli_lib.tex(,146) 
qhmoduli_lib.tex(,147) @item @strong{Purpose:}
qhmoduli_lib.tex(,148) compute the quotient of the variety given by the parameterization
qhmoduli_lib.tex(,149) 'emb' by the linear action 'action' of the algebraic group G.
qhmoduli_lib.tex(,150) 
qhmoduli_lib.tex(,151) @item @strong{Assume:}
qhmoduli_lib.tex(,152) 'action' is linear, G must be finite if the Reynolds operator is
qhmoduli_lib.tex(,153) needed (i.e., NullCone(G,action) returns some non-invariant polys)
qhmoduli_lib.tex(,154) 
qhmoduli_lib.tex(,155) @item @strong{Return:}
qhmoduli_lib.tex(,156) polynomial ring over a simple extension of the ground field of the
qhmoduli_lib.tex(,157) basering, containing the ideals 'id' and 'embedid'.
qhmoduli_lib.tex(,158) @*- 'id' contains the equations of the quotient, if opt = 1;
qhmoduli_lib.tex(,159) if opt = 0, 2, 'id' contains generators of the coordinate ring R
qhmoduli_lib.tex(,160) of the quotient (Spec(R) is the quotient)
qhmoduli_lib.tex(,161) @*- 'embedid' = 0, if opt = 1;
qhmoduli_lib.tex(,162) @*if opt = 0, 2, it is the ideal defining the equivariant embedding
qhmoduli_lib.tex(,163) 
qhmoduli_lib.tex(,164) @item @strong{Options:}
qhmoduli_lib.tex(,165) 1 compute equations of the quotient,
qhmoduli_lib.tex(,166) @*2 use a primary decomposition when computing the Reynolds operator @*
qhmoduli_lib.tex(,167) To combine options, add their value, default: opt =3.
qhmoduli_lib.tex(,168) 
qhmoduli_lib.tex(,169) @end table
qhmoduli_lib.tex(,170) @c ---end content QuotientEquations---
qhmoduli_lib.tex(,171) 
qhmoduli_lib.tex(,172) @c ------------------- StabEqn -------------
qhmoduli_lib.tex(,173) @node StabEqn, StabEqnId, QuotientEquations, qhmoduli_lib
qhmoduli_lib.tex(,174) @subsubsection StabEqn
qhmoduli_lib.tex(,175) @cindex StabEqn
qhmoduli_lib.tex(,176) @c ---content StabEqn---
qhmoduli_lib.tex(,177) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,178) 
qhmoduli_lib.tex(,179) @table @asis
qhmoduli_lib.tex(,180) @item @strong{Usage:}
qhmoduli_lib.tex(,181) StabEqn(f); f polynomial
qhmoduli_lib.tex(,182) 
qhmoduli_lib.tex(,183) @item @strong{Purpose:}
qhmoduli_lib.tex(,184) compute the equations of the isometry group of f.
qhmoduli_lib.tex(,185) 
qhmoduli_lib.tex(,186) @item @strong{Assume:}
qhmoduli_lib.tex(,187) f semiquasihomogeneous polynomial with an isolated singularity at 0
qhmoduli_lib.tex(,188) 
qhmoduli_lib.tex(,189) @item @strong{Return:}
qhmoduli_lib.tex(,190) list of two ring 'S1', 'S2'
qhmoduli_lib.tex(,191) @*- 'S1' contains the equations of the stabilizer (ideal 'stabid') @*
qhmoduli_lib.tex(,192) - 'S2' contains the action of the stabilizer (ideal 'actionid')
qhmoduli_lib.tex(,193) 
qhmoduli_lib.tex(,194) @item @strong{Global:}
qhmoduli_lib.tex(,195) varSubsList, contains the index j s.t. x(i) -> x(i)t(j) ...
qhmoduli_lib.tex(,196) 
qhmoduli_lib.tex(,197) @end table
qhmoduli_lib.tex(,198) @strong{Example:}
qhmoduli_lib.tex(,199) @smallexample
qhmoduli_lib.tex(,200) @c computed example StabEqn d2t_singular/qhmoduli_lib.doc:179 
qhmoduli_lib.tex(,201) LIB "qhmoduli.lib";
qhmoduli_lib.tex(,202) ring B = 0,(x,y,z), ls;
qhmoduli_lib.tex(,203) poly f = -z5+y5+x2z+x2y;
qhmoduli_lib.tex(,204) list stab = StabEqn(f);
qhmoduli_lib.tex(,205) def S1 = stab[1]; setring S1;  stabid;
qhmoduli_lib.tex(,206) @expansion{} stabid[1]=s(2)*s(3)
qhmoduli_lib.tex(,207) @expansion{} stabid[2]=s(1)^2*s(2)+s(1)^2*s(3)-1
qhmoduli_lib.tex(,208) @expansion{} stabid[3]=s(1)^2*s(3)^2-s(3)
qhmoduli_lib.tex(,209) @expansion{} stabid[4]=s(2)^4-s(3)^4+s(1)^2
qhmoduli_lib.tex(,210) @expansion{} stabid[5]=s(1)^4+s(2)^3-s(3)^3
qhmoduli_lib.tex(,211) @expansion{} stabid[6]=s(3)^5-s(1)^2*s(3)
qhmoduli_lib.tex(,212) def S2 = stab[2]; setring S2;  actionid;
qhmoduli_lib.tex(,213) @expansion{} actionid[1]=s(1)*x
qhmoduli_lib.tex(,214) @expansion{} actionid[2]=s(3)*y+s(2)*z
qhmoduli_lib.tex(,215) @expansion{} actionid[3]=s(2)*y+s(3)*z
qhmoduli_lib.tex(,216) @c end example StabEqn d2t_singular/qhmoduli_lib.doc:179
qhmoduli_lib.tex(,217) @end smallexample
qhmoduli_lib.tex(,218) @c ---end content StabEqn---
qhmoduli_lib.tex(,219) 
qhmoduli_lib.tex(,220) @c ------------------- StabEqnId -------------
qhmoduli_lib.tex(,221) @node StabEqnId, StabOrder, StabEqn, qhmoduli_lib
qhmoduli_lib.tex(,222) @subsubsection StabEqnId
qhmoduli_lib.tex(,223) @cindex StabEqnId
qhmoduli_lib.tex(,224) @c ---content StabEqnId---
qhmoduli_lib.tex(,225) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,226) 
qhmoduli_lib.tex(,227) @table @asis
qhmoduli_lib.tex(,228) @item @strong{Usage:}
qhmoduli_lib.tex(,229) StabEqn(I, w); I ideal, w intvec
qhmoduli_lib.tex(,230) 
qhmoduli_lib.tex(,231) @item @strong{Purpose:}
qhmoduli_lib.tex(,232) compute the equations of the isometry group of the ideal I
qhmoduli_lib.tex(,233) each generator of I is fixed by the stabilizer.
qhmoduli_lib.tex(,234) 
qhmoduli_lib.tex(,235) @item @strong{Assume:}
qhmoduli_lib.tex(,236) I semiquasihomogeneous ideal wrt 'w' with an isolated singularity at 0
qhmoduli_lib.tex(,237) 
qhmoduli_lib.tex(,238) @item @strong{Return:}
qhmoduli_lib.tex(,239) list of two ring 'S1', 'S2'
qhmoduli_lib.tex(,240) @*- 'S1' contains the equations of the stabilizer (ideal 'stabid') @*
qhmoduli_lib.tex(,241) - 'S2' contains the action of the stabilizer (ideal 'actionid')
qhmoduli_lib.tex(,242) 
qhmoduli_lib.tex(,243) @item @strong{Global:}
qhmoduli_lib.tex(,244) varSubsList, contains the index j s.t. t(i) -> t(i)t(j) ...
qhmoduli_lib.tex(,245) 
qhmoduli_lib.tex(,246) @end table
qhmoduli_lib.tex(,247) @strong{Example:}
qhmoduli_lib.tex(,248) @smallexample
qhmoduli_lib.tex(,249) @c computed example StabEqnId d2t_singular/qhmoduli_lib.doc:219 
qhmoduli_lib.tex(,250) LIB "qhmoduli.lib";
qhmoduli_lib.tex(,251) ring B   = 0,(x,y,z), ls;
qhmoduli_lib.tex(,252) ideal I = x2,y3,z6;
qhmoduli_lib.tex(,253) intvec w = 3,2,1;
qhmoduli_lib.tex(,254) list stab = StabEqnId(I, w);
qhmoduli_lib.tex(,255) @expansion{} // ** redefining d **
qhmoduli_lib.tex(,256) @expansion{} // ** redefining newcoMx **
qhmoduli_lib.tex(,257) @expansion{} // ** redefining coMx **
qhmoduli_lib.tex(,258) @expansion{} // ** redefining d **
qhmoduli_lib.tex(,259) @expansion{} // ** redefining newcoMx **
qhmoduli_lib.tex(,260) @expansion{} // ** redefining coMx **
qhmoduli_lib.tex(,261) def S1 = stab[1]; setring S1;  stabid;
qhmoduli_lib.tex(,262) @expansion{} stabid[1]=s(1)^2-1
qhmoduli_lib.tex(,263) @expansion{} stabid[2]=s(2)^3-1
qhmoduli_lib.tex(,264) @expansion{} stabid[3]=s(3)^6-1
qhmoduli_lib.tex(,265) def S2 = stab[2]; setring S2;  actionid;
qhmoduli_lib.tex(,266) @expansion{} actionid[1]=s(1)*x
qhmoduli_lib.tex(,267) @expansion{} actionid[2]=s(2)*y
qhmoduli_lib.tex(,268) @expansion{} actionid[3]=s(3)*z
qhmoduli_lib.tex(,269) @c end example StabEqnId d2t_singular/qhmoduli_lib.doc:219
qhmoduli_lib.tex(,270) @end smallexample
qhmoduli_lib.tex(,271) @c ---end content StabEqnId---
qhmoduli_lib.tex(,272) 
qhmoduli_lib.tex(,273) @c ------------------- StabOrder -------------
qhmoduli_lib.tex(,274) @node StabOrder, UpperMonomials, StabEqnId, qhmoduli_lib
qhmoduli_lib.tex(,275) @subsubsection StabOrder
qhmoduli_lib.tex(,276) @cindex StabOrder
qhmoduli_lib.tex(,277) @c ---content StabOrder---
qhmoduli_lib.tex(,278) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,279) 
qhmoduli_lib.tex(,280) @table @asis
qhmoduli_lib.tex(,281) @item @strong{Usage:}
qhmoduli_lib.tex(,282) StabOrder(f); poly f;
qhmoduli_lib.tex(,283) 
qhmoduli_lib.tex(,284) @item @strong{Purpose:}
qhmoduli_lib.tex(,285) compute the order of the stabilizer group of f.
qhmoduli_lib.tex(,286) 
qhmoduli_lib.tex(,287) @item @strong{Assume:}
qhmoduli_lib.tex(,288) f quasihomogeneous polynomial with an isolated singularity at 0
qhmoduli_lib.tex(,289) 
qhmoduli_lib.tex(,290) @item @strong{Return:}
qhmoduli_lib.tex(,291) int
qhmoduli_lib.tex(,292) 
qhmoduli_lib.tex(,293) @item @strong{Global:}
qhmoduli_lib.tex(,294) varSubsList
qhmoduli_lib.tex(,295) 
qhmoduli_lib.tex(,296) @end table
qhmoduli_lib.tex(,297) @c ---end content StabOrder---
qhmoduli_lib.tex(,298) 
qhmoduli_lib.tex(,299) @c ------------------- UpperMonomials -------------
qhmoduli_lib.tex(,300) @node UpperMonomials, Max, StabOrder, qhmoduli_lib
qhmoduli_lib.tex(,301) @subsubsection UpperMonomials
qhmoduli_lib.tex(,302) @cindex UpperMonomials
qhmoduli_lib.tex(,303) @c ---content UpperMonomials---
qhmoduli_lib.tex(,304) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,305) 
qhmoduli_lib.tex(,306) @table @asis
qhmoduli_lib.tex(,307) @item @strong{Usage:}
qhmoduli_lib.tex(,308) UpperMonomials(poly f, [intvec w])
qhmoduli_lib.tex(,309) 
qhmoduli_lib.tex(,310) @item @strong{Purpose:}
qhmoduli_lib.tex(,311) compute the upper monomials of the milnor algebra of f.
qhmoduli_lib.tex(,312) 
qhmoduli_lib.tex(,313) @item @strong{Assume:}
qhmoduli_lib.tex(,314) f is quasihomogeneous (w.r.t. w)
qhmoduli_lib.tex(,315) 
qhmoduli_lib.tex(,316) @item @strong{Return:}
qhmoduli_lib.tex(,317) ideal
qhmoduli_lib.tex(,318) 
qhmoduli_lib.tex(,319) @end table
qhmoduli_lib.tex(,320) @strong{Example:}
qhmoduli_lib.tex(,321) @smallexample
qhmoduli_lib.tex(,322) @c computed example UpperMonomials d2t_singular/qhmoduli_lib.doc:280 
qhmoduli_lib.tex(,323) LIB "qhmoduli.lib";
qhmoduli_lib.tex(,324) ring B   = 0,(x,y,z), ls;
qhmoduli_lib.tex(,325) poly f = -z5+y5+x2z+x2y;
qhmoduli_lib.tex(,326) UpperMonomials(f);
qhmoduli_lib.tex(,327) @expansion{} _[1]=y3z3
qhmoduli_lib.tex(,328) @expansion{} _[2]=x2y3
qhmoduli_lib.tex(,329) @expansion{} _[3]=x2y2
qhmoduli_lib.tex(,330) @c end example UpperMonomials d2t_singular/qhmoduli_lib.doc:280
qhmoduli_lib.tex(,331) @end smallexample
qhmoduli_lib.tex(,332) @c ---end content UpperMonomials---
qhmoduli_lib.tex(,333) 
qhmoduli_lib.tex(,334) @c ------------------- Max -------------
qhmoduli_lib.tex(,335) @node Max, Min, UpperMonomials, qhmoduli_lib
qhmoduli_lib.tex(,336) @subsubsection Max
qhmoduli_lib.tex(,337) @cindex Max
qhmoduli_lib.tex(,338) @c ---content Max---
qhmoduli_lib.tex(,339) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,340) 
qhmoduli_lib.tex(,341) @table @asis
qhmoduli_lib.tex(,342) @item @strong{Usage:}
qhmoduli_lib.tex(,343) Max(data); intvec/list of integers data
qhmoduli_lib.tex(,344) 
qhmoduli_lib.tex(,345) @item @strong{Purpose:}
qhmoduli_lib.tex(,346) find the maximal integer contained in 'data'
qhmoduli_lib.tex(,347) 
qhmoduli_lib.tex(,348) @item @strong{Return:}
qhmoduli_lib.tex(,349) list
qhmoduli_lib.tex(,350) 
qhmoduli_lib.tex(,351) @item @strong{Assume:}
qhmoduli_lib.tex(,352) 'data' contains only integers and is not empty
qhmoduli_lib.tex(,353) 
qhmoduli_lib.tex(,354) @end table
qhmoduli_lib.tex(,355) @c ---end content Max---
qhmoduli_lib.tex(,356) 
qhmoduli_lib.tex(,357) @c ------------------- Min -------------
qhmoduli_lib.tex(,358) @node Min, Table, Max, qhmoduli_lib
qhmoduli_lib.tex(,359) @subsubsection Min
qhmoduli_lib.tex(,360) @cindex Min
qhmoduli_lib.tex(,361) @c ---content Min---
qhmoduli_lib.tex(,362) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,363) 
qhmoduli_lib.tex(,364) @table @asis
qhmoduli_lib.tex(,365) @item @strong{Usage:}
qhmoduli_lib.tex(,366) Min(data); intvec/list of integers data
qhmoduli_lib.tex(,367) 
qhmoduli_lib.tex(,368) @item @strong{Purpose:}
qhmoduli_lib.tex(,369) find the minimal integer contained in 'data'
qhmoduli_lib.tex(,370) 
qhmoduli_lib.tex(,371) @item @strong{Return:}
qhmoduli_lib.tex(,372) list
qhmoduli_lib.tex(,373) 
qhmoduli_lib.tex(,374) @item @strong{Assume:}
qhmoduli_lib.tex(,375) 'data' contains only integers and is not empty
qhmoduli_lib.tex(,376) 
qhmoduli_lib.tex(,377) @end table
qhmoduli_lib.tex(,378) @c ---end content Min---
qhmoduli_lib.tex(,379) 
qhmoduli_lib.tex(,380) @c ------------------- Table -------------
qhmoduli_lib.tex(,381) @node Table,, Min, qhmoduli_lib
qhmoduli_lib.tex(,382) @subsubsection Table
qhmoduli_lib.tex(,383) @cindex Table
qhmoduli_lib.tex(,384) @c ---content Table---
qhmoduli_lib.tex(,385) Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).
qhmoduli_lib.tex(,386) 
qhmoduli_lib.tex(,387) @table @asis
qhmoduli_lib.tex(,388) @item @strong{Usage:}
qhmoduli_lib.tex(,389) Table(cmd,i, lb, ub); string cmd, i; int lb, ub
qhmoduli_lib.tex(,390) 
qhmoduli_lib.tex(,391) @item @strong{Purpose:}
qhmoduli_lib.tex(,392) generate a list of size ub - lb + 1 s.t. _[i] = cmd(i)
qhmoduli_lib.tex(,393) 
qhmoduli_lib.tex(,394) @item @strong{Return:}
qhmoduli_lib.tex(,395) list
qhmoduli_lib.tex(,396) 
qhmoduli_lib.tex(,397) @end table
qhmoduli_lib.tex(,398) @c ---end content Table---
singular.texi(,485) @c ----------------------------------------------------------
singular.texi(,486) @node sing_lib, spcurve_lib, qhmoduli_lib, Singularities
singular.texi(,487) @subsection sing_lib
singular.texi(,488) @c include of docu for sing.lib
sing_lib.tex(,1) @c ---content LibInfo---
sing_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/sing_lib.doc
sing_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/sing_lib.doc INSTEAD
sing_lib.tex(,4) @c library version: (1.24.2.5,2003/04/15)
sing_lib.tex(,5) @c library file: ../Singular/LIB/sing.lib
sing_lib.tex(,6) @cindex sing.lib
sing_lib.tex(,7) @cindex sing_lib
sing_lib.tex(,8) @table @asis
sing_lib.tex(,9) @item @strong{Library:}
sing_lib.tex(,10) sing.lib
sing_lib.tex(,11) @item @strong{Purpose:}
sing_lib.tex(,12)       Invariants of Singularities
sing_lib.tex(,13) @item @strong{Authors:}
sing_lib.tex(,14) Gert-Martin Greuel, email: greuel@@mathematik.uni-kl.de @*
sing_lib.tex(,15) Bernd Martin, email: martin@@math.tu-cottbus.de
sing_lib.tex(,16) 
sing_lib.tex(,17) @end table
sing_lib.tex(,18) 
sing_lib.tex(,19) @strong{Procedures:}
sing_lib.tex(,20) @menu
sing_lib.tex(,21) * deform:: infinitesimal deformations of ideal i
sing_lib.tex(,22) * dim_slocus:: dimension of singular locus of ideal i
sing_lib.tex(,23) * is_active:: is poly f an active element mod id? (id ideal/module)
sing_lib.tex(,24) * is_ci:: is ideal i a complete intersection?
sing_lib.tex(,25) * is_is:: is ideal i an isolated singularity?
sing_lib.tex(,26) * is_reg:: is poly f a regular element mod id? (id ideal/module)
sing_lib.tex(,27) * is_regs:: are gen's of ideal i regular sequence modulo id?
sing_lib.tex(,28) * locstd:: SB for local degree ordering without cancelling units
sing_lib.tex(,29) * milnor:: milnor number of ideal i; (assume i is ICIS in nf)
sing_lib.tex(,30) * nf_icis:: generic combinations of generators; get ICIS in nf
sing_lib.tex(,31) * slocus:: ideal of singular locus of ideal i
sing_lib.tex(,32) * qhspectrum:: spectrum numbers of w-homogeneous polynomial f
sing_lib.tex(,33) * Tjurina:: SB of Tjurina module of ideal i (assume i is ICIS)
sing_lib.tex(,34) * tjurina:: Tjurina number of ideal i (assume i is ICIS)
sing_lib.tex(,35) * T_1:: T^1-module of ideal i
sing_lib.tex(,36) * T_2:: T^2-module of ideal i
sing_lib.tex(,37) * T_12:: T^1- and T^2-module of ideal i
sing_lib.tex(,38) * tangentcone:: compute tangent cone of id
sing_lib.tex(,39) @end menu
sing_lib.tex(,40) @c ---end content LibInfo---
sing_lib.tex(,41) 
sing_lib.tex(,42) @c ------------------- deform -------------
sing_lib.tex(,43) @node deform, dim_slocus,, sing_lib
sing_lib.tex(,44) @subsubsection deform
sing_lib.tex(,45) @cindex deform
sing_lib.tex(,46) @c ---content deform---
sing_lib.tex(,47) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,48) 
sing_lib.tex(,49) @table @asis
sing_lib.tex(,50) @item @strong{Usage:}
sing_lib.tex(,51) deform(id); id=ideal or poly
sing_lib.tex(,52) 
sing_lib.tex(,53) @item @strong{Return:}
sing_lib.tex(,54) matrix, columns are kbase of infinitesimal deformations
sing_lib.tex(,55) 
sing_lib.tex(,56) @end table
sing_lib.tex(,57) @strong{Example:}
sing_lib.tex(,58) @smallexample
sing_lib.tex(,59) @c computed example deform d2t_singular/sing_lib.doc:57 
sing_lib.tex(,60) LIB "sing.lib";
sing_lib.tex(,61) ring r   = 32003,(x,y,z),ds;
sing_lib.tex(,62) ideal i  = xy,xz,yz;
sing_lib.tex(,63) matrix T = deform(i);
sing_lib.tex(,64) print(T);
sing_lib.tex(,65) @expansion{} x,0,0,
sing_lib.tex(,66) @expansion{} 0,0,z,
sing_lib.tex(,67) @expansion{} 0,y,0 
sing_lib.tex(,68) print(deform(x3+y5+z2));
sing_lib.tex(,69) @expansion{} xy3,y3,xy2,y2,xy,y,x,1
sing_lib.tex(,70) @c end example deform d2t_singular/sing_lib.doc:57
sing_lib.tex(,71) @end smallexample
sing_lib.tex(,72) @c ---end content deform---
sing_lib.tex(,73) 
sing_lib.tex(,74) @c ------------------- dim_slocus -------------
sing_lib.tex(,75) @node dim_slocus, is_active, deform, sing_lib
sing_lib.tex(,76) @subsubsection dim_slocus
sing_lib.tex(,77) @cindex dim_slocus
sing_lib.tex(,78) @c ---content dim_slocus---
sing_lib.tex(,79) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,80) 
sing_lib.tex(,81) @table @asis
sing_lib.tex(,82) @item @strong{Usage:}
sing_lib.tex(,83) dim_slocus(i); i ideal or poly
sing_lib.tex(,84) 
sing_lib.tex(,85) @item @strong{Return:}
sing_lib.tex(,86) dimension of singular locus of i
sing_lib.tex(,87) 
sing_lib.tex(,88) @end table
sing_lib.tex(,89) @strong{Example:}
sing_lib.tex(,90) @smallexample
sing_lib.tex(,91) @c computed example dim_slocus d2t_singular/sing_lib.doc:85 
sing_lib.tex(,92) LIB "sing.lib";
sing_lib.tex(,93) ring r  = 32003,(x,y,z),ds;
sing_lib.tex(,94) ideal i = x5+y6+z6,x2+2y2+3z2;
sing_lib.tex(,95) dim_slocus(i);
sing_lib.tex(,96) @expansion{} 0
sing_lib.tex(,97) @c end example dim_slocus d2t_singular/sing_lib.doc:85
sing_lib.tex(,98) @end smallexample
sing_lib.tex(,99) @c ---end content dim_slocus---
sing_lib.tex(,100) 
sing_lib.tex(,101) @c ------------------- is_active -------------
sing_lib.tex(,102) @node is_active, is_ci, dim_slocus, sing_lib
sing_lib.tex(,103) @subsubsection is_active
sing_lib.tex(,104) @cindex is_active
sing_lib.tex(,105) @c ---content is_active---
sing_lib.tex(,106) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,107) 
sing_lib.tex(,108) @table @asis
sing_lib.tex(,109) @item @strong{Usage:}
sing_lib.tex(,110) is_active(f,id); f poly, id ideal or module
sing_lib.tex(,111) 
sing_lib.tex(,112) @item @strong{Return:}
sing_lib.tex(,113) 1 if f is an active element modulo id (i.e. dim(id)=dim(id+f*R^n)+1,
sing_lib.tex(,114) if id is a submodule of R^n) resp. 0 if f is not active.
sing_lib.tex(,115) The basering may be a quotient ring
sing_lib.tex(,116) 
sing_lib.tex(,117) @item @strong{Note:}
sing_lib.tex(,118) regular parameters are active but not vice versa (id may have embedded
sing_lib.tex(,119) components). proc is_reg tests whether f is a regular parameter
sing_lib.tex(,120) 
sing_lib.tex(,121) @end table
sing_lib.tex(,122) @strong{Example:}
sing_lib.tex(,123) @smallexample
sing_lib.tex(,124) @c computed example is_active d2t_singular/sing_lib.doc:117 
sing_lib.tex(,125) LIB "sing.lib";
sing_lib.tex(,126) ring r   =32003,(x,y,z),ds;
sing_lib.tex(,127) ideal i  = yx3+y,yz3+y3z;
sing_lib.tex(,128) poly f   = x;
sing_lib.tex(,129) is_active(f,i);
sing_lib.tex(,130) @expansion{} 1
sing_lib.tex(,131) qring q  = std(x4y5);
sing_lib.tex(,132) poly f   = x;
sing_lib.tex(,133) module m = [yx3+x,yx3+y3x];
sing_lib.tex(,134) is_active(f,m);
sing_lib.tex(,135) @expansion{} 0
sing_lib.tex(,136) @c end example is_active d2t_singular/sing_lib.doc:117
sing_lib.tex(,137) @end smallexample
sing_lib.tex(,138) @c ---end content is_active---
sing_lib.tex(,139) 
sing_lib.tex(,140) @c ------------------- is_ci -------------
sing_lib.tex(,141) @node is_ci, is_is, is_active, sing_lib
sing_lib.tex(,142) @subsubsection is_ci
sing_lib.tex(,143) @cindex is_ci
sing_lib.tex(,144) @c ---content is_ci---
sing_lib.tex(,145) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,146) 
sing_lib.tex(,147) @table @asis
sing_lib.tex(,148) @item @strong{Usage:}
sing_lib.tex(,149) is_ci(i); i ideal
sing_lib.tex(,150) 
sing_lib.tex(,151) @item @strong{Return:}
sing_lib.tex(,152) intvec = sequence of dimensions of ideals (j[1],...,j[k]), for
sing_lib.tex(,153) k=1,...,size(j), where j is minimal base of i. i is a complete
sing_lib.tex(,154) intersection if last number equals nvars-size(i)
sing_lib.tex(,155) 
sing_lib.tex(,156) @item @strong{Note:}
sing_lib.tex(,157) dim(0-ideal) = -1. You may first apply simplify(i,10); in order to
sing_lib.tex(,158) delete zeroes and multiples from set of generators
sing_lib.tex(,159) @*printlevel >=0: display comments (default)
sing_lib.tex(,160) 
sing_lib.tex(,161) @end table
sing_lib.tex(,162) @strong{Example:}
sing_lib.tex(,163) @smallexample
sing_lib.tex(,164) @c computed example is_ci d2t_singular/sing_lib.doc:155 
sing_lib.tex(,165) LIB "sing.lib";
sing_lib.tex(,166) int p      = printlevel;
sing_lib.tex(,167) printlevel = 1;                // display comments
sing_lib.tex(,168) ring r     = 32003,(x,y,z),ds;
sing_lib.tex(,169) ideal i    = x4+y5+z6,xyz,yx2+xz2+zy7;
sing_lib.tex(,170) is_ci(i);
sing_lib.tex(,171) @expansion{} // complete intersection of dim 0
sing_lib.tex(,172) @expansion{} // dim-sequence:
sing_lib.tex(,173) @expansion{} 2,1,0
sing_lib.tex(,174) i          = xy,yz;
sing_lib.tex(,175) is_ci(i);
sing_lib.tex(,176) @expansion{} // no complete intersection
sing_lib.tex(,177) @expansion{} // dim-sequence:
sing_lib.tex(,178) @expansion{} 2,2
sing_lib.tex(,179) printlevel = p;
sing_lib.tex(,180) @c end example is_ci d2t_singular/sing_lib.doc:155
sing_lib.tex(,181) @end smallexample
sing_lib.tex(,182) @c ---end content is_ci---
sing_lib.tex(,183) 
sing_lib.tex(,184) @c ------------------- is_is -------------
sing_lib.tex(,185) @node is_is, is_reg, is_ci, sing_lib
sing_lib.tex(,186) @subsubsection is_is
sing_lib.tex(,187) @cindex is_is
sing_lib.tex(,188) @c ---content is_is---
sing_lib.tex(,189) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,190) 
sing_lib.tex(,191) @table @asis
sing_lib.tex(,192) @item @strong{Usage:}
sing_lib.tex(,193) is_is(id); id ideal or poly
sing_lib.tex(,194) 
sing_lib.tex(,195) @item @strong{Return:}
sing_lib.tex(,196) intvec = sequence of dimensions of singular loci of ideals
sing_lib.tex(,197) generated by id[1]..id[i], k = 1..size(id); @*
sing_lib.tex(,198) dim(0-ideal) = -1;
sing_lib.tex(,199) @*id defines an isolated singularity if last number is 0
sing_lib.tex(,200) 
sing_lib.tex(,201) @item @strong{Note:}
sing_lib.tex(,202) printlevel >=0: display comments (default)
sing_lib.tex(,203) 
sing_lib.tex(,204) @end table
sing_lib.tex(,205) @strong{Example:}
sing_lib.tex(,206) @smallexample
sing_lib.tex(,207) @c computed example is_is d2t_singular/sing_lib.doc:192 
sing_lib.tex(,208) LIB "sing.lib";
sing_lib.tex(,209) int p      = printlevel;
sing_lib.tex(,210) printlevel = 1;
sing_lib.tex(,211) ring r     = 32003,(x,y,z),ds;
sing_lib.tex(,212) ideal i    = x2y,x4+y5+z6,yx2+xz2+zy7;
sing_lib.tex(,213) is_is(i);
sing_lib.tex(,214) @expansion{} // dim of singular locus = 0
sing_lib.tex(,215) @expansion{} // isolated singularity if last number is 0 in dim-sequence:
sing_lib.tex(,216) @expansion{} 2,1,0
sing_lib.tex(,217) poly f     = xy+yz;
sing_lib.tex(,218) is_is(f);
sing_lib.tex(,219) @expansion{} // dim of singular locus = 1
sing_lib.tex(,220) @expansion{} // isolated singularity if last number is 0 in dim-sequence:
sing_lib.tex(,221) @expansion{} 1
sing_lib.tex(,222) printlevel = p;
sing_lib.tex(,223) @c end example is_is d2t_singular/sing_lib.doc:192
sing_lib.tex(,224) @end smallexample
sing_lib.tex(,225) @c ---end content is_is---
sing_lib.tex(,226) 
sing_lib.tex(,227) @c ------------------- is_reg -------------
sing_lib.tex(,228) @node is_reg, is_regs, is_is, sing_lib
sing_lib.tex(,229) @subsubsection is_reg
sing_lib.tex(,230) @cindex is_reg
sing_lib.tex(,231) @c ---content is_reg---
sing_lib.tex(,232) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,233) 
sing_lib.tex(,234) @table @asis
sing_lib.tex(,235) @item @strong{Usage:}
sing_lib.tex(,236) is_reg(f,id); f poly, id ideal or module
sing_lib.tex(,237) 
sing_lib.tex(,238) @item @strong{Return:}
sing_lib.tex(,239) 1 if multiplication with f is injective modulo id, 0 otherwise
sing_lib.tex(,240) 
sing_lib.tex(,241) @item @strong{Note:}
sing_lib.tex(,242) let R be the basering and id a submodule of R^n. The procedure checks
sing_lib.tex(,243) injectivity of multiplication with f on R^n/id. The basering may be a
sing_lib.tex(,244) quotient ring
sing_lib.tex(,245) 
sing_lib.tex(,246) @end table
sing_lib.tex(,247) @strong{Example:}
sing_lib.tex(,248) @smallexample
sing_lib.tex(,249) @c computed example is_reg d2t_singular/sing_lib.doc:228 
sing_lib.tex(,250) LIB "sing.lib";
sing_lib.tex(,251) ring r  = 32003,(x,y),ds;
sing_lib.tex(,252) ideal i = x8,y8;
sing_lib.tex(,253) ideal j = (x+y)^4;
sing_lib.tex(,254) i       = intersect(i,j);
sing_lib.tex(,255) poly f  = xy;
sing_lib.tex(,256) is_reg(f,i);
sing_lib.tex(,257) @expansion{} 0
sing_lib.tex(,258) @c end example is_reg d2t_singular/sing_lib.doc:228
sing_lib.tex(,259) @end smallexample
sing_lib.tex(,260) @c ---end content is_reg---
sing_lib.tex(,261) 
sing_lib.tex(,262) @c ------------------- is_regs -------------
sing_lib.tex(,263) @node is_regs, locstd, is_reg, sing_lib
sing_lib.tex(,264) @subsubsection is_regs
sing_lib.tex(,265) @cindex is_regs
sing_lib.tex(,266) @c ---content is_regs---
sing_lib.tex(,267) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,268) 
sing_lib.tex(,269) @table @asis
sing_lib.tex(,270) @item @strong{Usage:}
sing_lib.tex(,271) is_regs(i[,id]); i poly, id ideal or module (default: id=0)
sing_lib.tex(,272) 
sing_lib.tex(,273) @item @strong{Return:}
sing_lib.tex(,274) 1 if generators of i are a regular sequence modulo id, 0 otherwise
sing_lib.tex(,275) 
sing_lib.tex(,276) @item @strong{Note:}
sing_lib.tex(,277) let R be the basering and id a submodule of R^n. The procedure checks
sing_lib.tex(,278) injectivity of multiplication with i[k] on R^n/id+i[1..k-1].
sing_lib.tex(,279) The basering may be a quotient ring
sing_lib.tex(,280) @*printlevel >=0: display comments (default)
sing_lib.tex(,281) @*printlevel >=1: display comments during computation
sing_lib.tex(,282) 
sing_lib.tex(,283) @end table
sing_lib.tex(,284) @strong{Example:}
sing_lib.tex(,285) @smallexample
sing_lib.tex(,286) @c computed example is_regs d2t_singular/sing_lib.doc:264 
sing_lib.tex(,287) LIB "sing.lib";
sing_lib.tex(,288) int p      = printlevel;
sing_lib.tex(,289) printlevel = 1;
sing_lib.tex(,290) ring r1    = 32003,(x,y,z),ds;
sing_lib.tex(,291) ideal i    = x8,y8,(x+y)^4;
sing_lib.tex(,292) is_regs(i);
sing_lib.tex(,293) @expansion{} // checking whether element 1 is regular mod 1 .. 0
sing_lib.tex(,294) @expansion{} // checking whether element 2 is regular mod 1 .. 1
sing_lib.tex(,295) @expansion{} // checking whether element 3 is regular mod 1 .. 2
sing_lib.tex(,296) @expansion{} // elements 1..2 are regular, 3 is not regular mod 1..2
sing_lib.tex(,297) @expansion{} 0
sing_lib.tex(,298) module m   = [x,0,y];
sing_lib.tex(,299) i          = x8,(x+z)^4;;
sing_lib.tex(,300) is_regs(i,m);
sing_lib.tex(,301) @expansion{} // checking whether element 1 is regular mod 1 .. 0
sing_lib.tex(,302) @expansion{} // checking whether element 2 is regular mod 1 .. 1
sing_lib.tex(,303) @expansion{} // elements are a regular sequence of length 2
sing_lib.tex(,304) @expansion{} 1
sing_lib.tex(,305) printlevel = p;
sing_lib.tex(,306) @c end example is_regs d2t_singular/sing_lib.doc:264
sing_lib.tex(,307) @end smallexample
sing_lib.tex(,308) @c ---end content is_regs---
sing_lib.tex(,309) 
sing_lib.tex(,310) @c ------------------- locstd -------------
sing_lib.tex(,311) @node locstd, milnor, is_regs, sing_lib
sing_lib.tex(,312) @subsubsection locstd
sing_lib.tex(,313) @cindex locstd
sing_lib.tex(,314) @c ---content locstd---
sing_lib.tex(,315) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,316) 
sing_lib.tex(,317) @table @asis
sing_lib.tex(,318) @item @strong{Usage:}
sing_lib.tex(,319) locstd (id); id = ideal
sing_lib.tex(,320) 
sing_lib.tex(,321) @item @strong{Return:}
sing_lib.tex(,322) a standard basis for a local degree ordering
sing_lib.tex(,323) 
sing_lib.tex(,324) @item @strong{Note:}
sing_lib.tex(,325) the procedure homogenizes id w.r.t. a new 1st variable @@t@@, computes
sing_lib.tex(,326) a SB wrt (dp(1),dp) and substitutes @@t@@ by 1.
sing_lib.tex(,327) @*Hence the result is a SB with respect to an ordering which sorts
sing_lib.tex(,328) first w.r.t. the order and then refines it with dp. This is a
sing_lib.tex(,329) local degree ordering.
sing_lib.tex(,330) @*This is done in order to avoid cancellation of units and thus
sing_lib.tex(,331) be able to use option(contentSB);
sing_lib.tex(,332) 
sing_lib.tex(,333) @end table
sing_lib.tex(,334) @strong{Example:}
sing_lib.tex(,335) @smallexample
sing_lib.tex(,336) @c computed example locstd d2t_singular/sing_lib.doc:305 
sing_lib.tex(,337) LIB "sing.lib";
sing_lib.tex(,338) ring R = 0,(x,y,z),ds;
sing_lib.tex(,339) ideal i  = xyz+z5,2x2+y3+z7,3z5+y5;
sing_lib.tex(,340) locstd(i);
sing_lib.tex(,341) @expansion{} _[1]=y5+3z5
sing_lib.tex(,342) @expansion{} _[2]=3x4y3z8-4x3y3z9+6x2y4z9+3y5z10
sing_lib.tex(,343) @expansion{} _[3]=3x4z13-4x3z14+6x2yz14+3y2z15
sing_lib.tex(,344) @expansion{} _[4]=3x4yz12-4x3yz13+6x2y2z13+3y3z14
sing_lib.tex(,345) @expansion{} _[5]=2x2z9+x2y2z8+y3z9
sing_lib.tex(,346) @expansion{} _[6]=2x2y4z5+y7z5-3x2yz9
sing_lib.tex(,347) @expansion{} _[7]=6y2z10-3x2y3z8+4xy3z9-3y4z9
sing_lib.tex(,348) @expansion{} _[8]=3x2y2z8+3y3z9+2xy4z8
sing_lib.tex(,349) @expansion{} _[9]=18z14-4xy6z8+3y7z8-9x2yz12
sing_lib.tex(,350) @expansion{} _[10]=xyz+z5
sing_lib.tex(,351) @expansion{} _[11]=3xz6-y4z5
sing_lib.tex(,352) @expansion{} _[12]=3y3z6+2xy4z5-3xyz9
sing_lib.tex(,353) @expansion{} _[13]=y4z5-2xz9-xy2z8
sing_lib.tex(,354) @expansion{} _[14]=3z10+2xyz9+xy3z8
sing_lib.tex(,355) @expansion{} _[15]=2x2z5+y3z5-xyz8
sing_lib.tex(,356) @expansion{} _[16]=y4z-2xz5+yz8
sing_lib.tex(,357) @expansion{} _[17]=3z6+2xyz5-y2z8
sing_lib.tex(,358) @expansion{} _[18]=2x2+y3+z7
sing_lib.tex(,359) @c end example locstd d2t_singular/sing_lib.doc:305
sing_lib.tex(,360) @end smallexample
sing_lib.tex(,361) @c ---end content locstd---
sing_lib.tex(,362) 
sing_lib.tex(,363) @c ------------------- milnor -------------
sing_lib.tex(,364) @node milnor, nf_icis, locstd, sing_lib
sing_lib.tex(,365) @subsubsection milnor
sing_lib.tex(,366) @cindex milnor
sing_lib.tex(,367) @c ---content milnor---
sing_lib.tex(,368) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,369) 
sing_lib.tex(,370) @table @asis
sing_lib.tex(,371) @item @strong{Usage:}
sing_lib.tex(,372) milnor(i); i ideal or poly
sing_lib.tex(,373) 
sing_lib.tex(,374) @item @strong{Return:}
sing_lib.tex(,375) Milnor number of i, if i is ICIS (isolated complete intersection
sing_lib.tex(,376) singularity) in generic form, resp. -1 if not
sing_lib.tex(,377) 
sing_lib.tex(,378) @item @strong{Note:}
sing_lib.tex(,379) use proc nf_icis to put generators in generic form
sing_lib.tex(,380) @*printlevel >=0: display comments (default)
sing_lib.tex(,381) 
sing_lib.tex(,382) @end table
sing_lib.tex(,383) @strong{Example:}
sing_lib.tex(,384) @smallexample
sing_lib.tex(,385) @c computed example milnor d2t_singular/sing_lib.doc:336 
sing_lib.tex(,386) LIB "sing.lib";
sing_lib.tex(,387) int p      = printlevel;
sing_lib.tex(,388) printlevel = 1;
sing_lib.tex(,389) ring r     = 32003,(x,y,z),ds;
sing_lib.tex(,390) ideal j    = x5+y6+z6,x2+2y2+3z2,xyz+yx;
sing_lib.tex(,391) milnor(j);
sing_lib.tex(,392) @expansion{} //sequence of discriminant numbers: 100,149,70
sing_lib.tex(,393) @expansion{} 21
sing_lib.tex(,394) poly f     = x7+y7+(x-y)^2*x2y2+z2;
sing_lib.tex(,395) milnor(f);
sing_lib.tex(,396) @expansion{} 28
sing_lib.tex(,397) printlevel = p;
sing_lib.tex(,398) @c end example milnor d2t_singular/sing_lib.doc:336
sing_lib.tex(,399) @end smallexample
sing_lib.tex(,400) @c ---end content milnor---
sing_lib.tex(,401) 
sing_lib.tex(,402) @c ------------------- nf_icis -------------
sing_lib.tex(,403) @node nf_icis, slocus, milnor, sing_lib
sing_lib.tex(,404) @subsubsection nf_icis
sing_lib.tex(,405) @cindex nf_icis
sing_lib.tex(,406) @c ---content nf_icis---
sing_lib.tex(,407) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,408) 
sing_lib.tex(,409) @table @asis
sing_lib.tex(,410) @item @strong{Usage:}
sing_lib.tex(,411) nf_icis(i); i ideal
sing_lib.tex(,412) 
sing_lib.tex(,413) @item @strong{Return:}
sing_lib.tex(,414) ideal = generic linear combination of generators of i if i is an ICIS
sing_lib.tex(,415) (isolated complete intersection singularity), return i if not
sing_lib.tex(,416) 
sing_lib.tex(,417) @item @strong{Note:}
sing_lib.tex(,418) this proc is useful in connection with proc milnor
sing_lib.tex(,419) @*printlevel >=0: display comments (default)
sing_lib.tex(,420) 
sing_lib.tex(,421) @end table
sing_lib.tex(,422) @strong{Example:}
sing_lib.tex(,423) @smallexample
sing_lib.tex(,424) @c computed example nf_icis d2t_singular/sing_lib.doc:372 
sing_lib.tex(,425) LIB "sing.lib";
sing_lib.tex(,426) int p      = printlevel;
sing_lib.tex(,427) printlevel = 1;
sing_lib.tex(,428) ring r     = 32003,(x,y,z),ds;
sing_lib.tex(,429) ideal i    = x3+y4,z4+yx;
sing_lib.tex(,430) nf_icis(i);
sing_lib.tex(,431) @expansion{} // complete intersection of dim 1
sing_lib.tex(,432) @expansion{} // dim-sequence:
sing_lib.tex(,433) @expansion{} // dim of singular locus = 0
sing_lib.tex(,434) @expansion{} // isolated singularity if last number is 0 in dim-sequence:
sing_lib.tex(,435) @expansion{} // dim of singular locus = 0
sing_lib.tex(,436) @expansion{} // isolated singularity if last number is 0 in dim-sequence:
sing_lib.tex(,437) @expansion{} // ICIS in generic form after 1 genericity loop(s)
sing_lib.tex(,438) @expansion{} _[1]=2xy+x3+y4+2z4
sing_lib.tex(,439) @expansion{} _[2]=xy+z4
sing_lib.tex(,440) ideal j    = x3+y4,xy,yz;
sing_lib.tex(,441) nf_icis(j);
sing_lib.tex(,442) @expansion{} // no complete intersection
sing_lib.tex(,443) @expansion{} // dim-sequence:
sing_lib.tex(,444) @expansion{} // no complete intersection
sing_lib.tex(,445) @expansion{} _[1]=x3+y4
sing_lib.tex(,446) @expansion{} _[2]=xy
sing_lib.tex(,447) @expansion{} _[3]=yz
sing_lib.tex(,448) printlevel = p;
sing_lib.tex(,449) @c end example nf_icis d2t_singular/sing_lib.doc:372
sing_lib.tex(,450) @end smallexample
sing_lib.tex(,451) @c ---end content nf_icis---
sing_lib.tex(,452) 
sing_lib.tex(,453) @c ------------------- slocus -------------
sing_lib.tex(,454) @node slocus, qhspectrum, nf_icis, sing_lib
sing_lib.tex(,455) @subsubsection slocus
sing_lib.tex(,456) @cindex slocus
sing_lib.tex(,457) @c ---content slocus---
sing_lib.tex(,458) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,459) 
sing_lib.tex(,460) @table @asis
sing_lib.tex(,461) @item @strong{Usage:}
sing_lib.tex(,462) slocus(i); i ideal
sing_lib.tex(,463) 
sing_lib.tex(,464) @item @strong{Return:}
sing_lib.tex(,465) ideal of singular locus of i
sing_lib.tex(,466) 
sing_lib.tex(,467) @end table
sing_lib.tex(,468) @strong{Example:}
sing_lib.tex(,469) @smallexample
sing_lib.tex(,470) @c computed example slocus d2t_singular/sing_lib.doc:403 
sing_lib.tex(,471) LIB "sing.lib";
sing_lib.tex(,472) ring r  = 0,(u,v,w,x,y,z),dp;
sing_lib.tex(,473) ideal i = wx,wy,wz,vx,vy,vz,ux,uy,uz,y3-x2;;
sing_lib.tex(,474) slocus(i);
sing_lib.tex(,475) @expansion{} _[1]=x
sing_lib.tex(,476) @expansion{} _[2]=w
sing_lib.tex(,477) @expansion{} _[3]=v
sing_lib.tex(,478) @expansion{} _[4]=u
sing_lib.tex(,479) @expansion{} _[5]=y2
sing_lib.tex(,480) @c end example slocus d2t_singular/sing_lib.doc:403
sing_lib.tex(,481) @end smallexample
sing_lib.tex(,482) @c ---end content slocus---
sing_lib.tex(,483) 
sing_lib.tex(,484) @c ------------------- qhspectrum -------------
sing_lib.tex(,485) @node qhspectrum, Tjurina, slocus, sing_lib
sing_lib.tex(,486) @subsubsection qhspectrum
sing_lib.tex(,487) @cindex qhspectrum
sing_lib.tex(,488) @c ---content qhspectrum---
sing_lib.tex(,489) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,490) 
sing_lib.tex(,491) @table @asis
sing_lib.tex(,492) @item @strong{Usage:}
sing_lib.tex(,493) qhspectrum(f,w); f=poly, w=intvec;
sing_lib.tex(,494) 
sing_lib.tex(,495) @item @strong{Assume:}
sing_lib.tex(,496) f is a weighted homogeneous isolated singularity w.r.t. the weights
sing_lib.tex(,497) given by w; w must consist of as many positive integers as there
sing_lib.tex(,498) are variables of the basering
sing_lib.tex(,499) 
sing_lib.tex(,500) @item @strong{Compute:}
sing_lib.tex(,501) the spectral numbers of the w-homogeneous polynomial f, computed in a
sing_lib.tex(,502) ring of characteristic 0
sing_lib.tex(,503) 
sing_lib.tex(,504) @item @strong{Return:}
sing_lib.tex(,505) intvec d,s1,...,su where:
sing_lib.tex(,506) @*d = w-degree(f) and si/d = i-th spectral-number(f)
sing_lib.tex(,507) @*No return value if basering has parameters or if f is no isolated
sing_lib.tex(,508) singularity, displays a warning in this case
sing_lib.tex(,509) 
sing_lib.tex(,510) @end table
sing_lib.tex(,511) @strong{Example:}
sing_lib.tex(,512) @smallexample
sing_lib.tex(,513) @c computed example qhspectrum d2t_singular/sing_lib.doc:441 
sing_lib.tex(,514) LIB "sing.lib";
sing_lib.tex(,515) ring r;
sing_lib.tex(,516) poly f=x3+y5+z2;
sing_lib.tex(,517) intvec w=10,6,15;
sing_lib.tex(,518) qhspectrum(f,w);
sing_lib.tex(,519) @expansion{} 30,1,7,11,13,17,19,23,29
sing_lib.tex(,520) // the spectrum numbers are:
sing_lib.tex(,521) // 1/30,7/30,11/30,13/30,17/30,19/30,23/30,29/30
sing_lib.tex(,522) @c end example qhspectrum d2t_singular/sing_lib.doc:441
sing_lib.tex(,523) @end smallexample
sing_lib.tex(,524) @c ---end content qhspectrum---
sing_lib.tex(,525) 
sing_lib.tex(,526) @c ------------------- Tjurina -------------
sing_lib.tex(,527) @node Tjurina, tjurina, qhspectrum, sing_lib
sing_lib.tex(,528) @subsubsection Tjurina
sing_lib.tex(,529) @cindex Tjurina
sing_lib.tex(,530) @c ---content Tjurina---
sing_lib.tex(,531) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,532) 
sing_lib.tex(,533) @table @asis
sing_lib.tex(,534) @item @strong{Usage:}
sing_lib.tex(,535) Tjurina(id[,<any>]); id=ideal or poly
sing_lib.tex(,536) 
sing_lib.tex(,537) @item @strong{Assume:}
sing_lib.tex(,538) id=ICIS (isolated complete intersection singularity)
sing_lib.tex(,539) 
sing_lib.tex(,540) @item @strong{Return:}
sing_lib.tex(,541) standard basis of Tjurina-module of id,
sing_lib.tex(,542) @*of type module if id=ideal, resp. of type ideal if id=poly.
sing_lib.tex(,543) If a second argument is present (of any type) return a list: @*
sing_lib.tex(,544) [1] = Tjurina number,
sing_lib.tex(,545) @*[2] = k-basis of miniversal deformation,
sing_lib.tex(,546) @*[3] = SB of Tjurina module,
sing_lib.tex(,547) @*[4] = Tjurina module
sing_lib.tex(,548) 
sing_lib.tex(,549) @item @strong{Display:}
sing_lib.tex(,550) Tjurina number if printlevel >= 0 (default)
sing_lib.tex(,551) 
sing_lib.tex(,552) @item @strong{Note:}
sing_lib.tex(,553) Tjurina number = -1 implies that id is not an ICIS
sing_lib.tex(,554) 
sing_lib.tex(,555) @end table
sing_lib.tex(,556) @strong{Example:}
sing_lib.tex(,557) @smallexample
sing_lib.tex(,558) @c computed example Tjurina d2t_singular/sing_lib.doc:485 
sing_lib.tex(,559) LIB "sing.lib";
sing_lib.tex(,560) int p      = printlevel;
sing_lib.tex(,561) printlevel = 1;
sing_lib.tex(,562) ring r     = 0,(x,y,z),ds;
sing_lib.tex(,563) poly f     = x5+y6+z7+xyz;        // singularity T[5,6,7]
sing_lib.tex(,564) list T     = Tjurina(f,"");
sing_lib.tex(,565) @expansion{} // Tjurina number = 16
sing_lib.tex(,566) show(T[1]);                       // Tjurina number, should be 16
sing_lib.tex(,567) @expansion{} // int, size 1
sing_lib.tex(,568) @expansion{} 16
sing_lib.tex(,569) show(T[2]);                       // basis of miniversal deformation
sing_lib.tex(,570) @expansion{} // ideal, 16 generator(s)
sing_lib.tex(,571) @expansion{} z6,
sing_lib.tex(,572) @expansion{} z5,
sing_lib.tex(,573) @expansion{} z4,
sing_lib.tex(,574) @expansion{} z3,
sing_lib.tex(,575) @expansion{} z2,
sing_lib.tex(,576) @expansion{} z,
sing_lib.tex(,577) @expansion{} y5,
sing_lib.tex(,578) @expansion{} y4,
sing_lib.tex(,579) @expansion{} y3,
sing_lib.tex(,580) @expansion{} y2,
sing_lib.tex(,581) @expansion{} y,
sing_lib.tex(,582) @expansion{} x4,
sing_lib.tex(,583) @expansion{} x3,
sing_lib.tex(,584) @expansion{} x2,
sing_lib.tex(,585) @expansion{} x,
sing_lib.tex(,586) @expansion{} 1
sing_lib.tex(,587) show(T[3]);                       // SB of Tjurina ideal
sing_lib.tex(,588) @expansion{} // ideal, 6 generator(s)
sing_lib.tex(,589) @expansion{} xy+7z6,
sing_lib.tex(,590) @expansion{} xz+6y5,
sing_lib.tex(,591) @expansion{} yz+5x4,
sing_lib.tex(,592) @expansion{} 5x5-6y6,
sing_lib.tex(,593) @expansion{} 6y6,
sing_lib.tex(,594) @expansion{} z7
sing_lib.tex(,595) show(T[4]); "";                   // Tjurina ideal
sing_lib.tex(,596) @expansion{} // ideal, 4 generator(s)
sing_lib.tex(,597) @expansion{} yz+5x4,
sing_lib.tex(,598) @expansion{} xz+6y5,
sing_lib.tex(,599) @expansion{} xy+7z6,
sing_lib.tex(,600) @expansion{} xyz+x5+y6+z7
sing_lib.tex(,601) @expansion{} 
sing_lib.tex(,602) ideal j    = x2+y2+z2,x2+2y2+3z2;
sing_lib.tex(,603) show(kbase(Tjurina(j)));          // basis of miniversal deformation
sing_lib.tex(,604) @expansion{} // Tjurina number = 5
sing_lib.tex(,605) @expansion{} // module, 5 generator(s)
sing_lib.tex(,606) @expansion{} [z]
sing_lib.tex(,607) @expansion{} [y]
sing_lib.tex(,608) @expansion{} [x]
sing_lib.tex(,609) @expansion{} [1]
sing_lib.tex(,610) @expansion{} [0,1]
sing_lib.tex(,611) hilb(Tjurina(j));                 // Hilbert series of Tjurina module
sing_lib.tex(,612) @expansion{} // Tjurina number = 5
sing_lib.tex(,613) @expansion{} //         2 t^0
sing_lib.tex(,614) @expansion{} //        -3 t^1
sing_lib.tex(,615) @expansion{} //        -3 t^2
sing_lib.tex(,616) @expansion{} //         7 t^3
sing_lib.tex(,617) @expansion{} //        -3 t^4
sing_lib.tex(,618) @expansion{} 
sing_lib.tex(,619) @expansion{} //         2 t^0
sing_lib.tex(,620) @expansion{} //         3 t^1
sing_lib.tex(,621) @expansion{} // dimension (local)   = 0
sing_lib.tex(,622) @expansion{} // multiplicity = 5
sing_lib.tex(,623) printlevel = p;
sing_lib.tex(,624) @c end example Tjurina d2t_singular/sing_lib.doc:485
sing_lib.tex(,625) @end smallexample
sing_lib.tex(,626) @c ---end content Tjurina---
sing_lib.tex(,627) 
sing_lib.tex(,628) @c ------------------- tjurina -------------
sing_lib.tex(,629) @node tjurina, T_1, Tjurina, sing_lib
sing_lib.tex(,630) @subsubsection tjurina
sing_lib.tex(,631) @cindex tjurina
sing_lib.tex(,632) @c ---content tjurina---
sing_lib.tex(,633) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,634) 
sing_lib.tex(,635) @table @asis
sing_lib.tex(,636) @item @strong{Usage:}
sing_lib.tex(,637) tjurina(id); id=ideal or poly
sing_lib.tex(,638) 
sing_lib.tex(,639) @item @strong{Assume:}
sing_lib.tex(,640) id=ICIS (isolated complete intersection singularity)
sing_lib.tex(,641) 
sing_lib.tex(,642) @item @strong{Return:}
sing_lib.tex(,643) int = Tjurina number of id
sing_lib.tex(,644) 
sing_lib.tex(,645) @item @strong{Note:}
sing_lib.tex(,646) Tjurina number = -1 implies that id is not an ICIS
sing_lib.tex(,647) 
sing_lib.tex(,648) @end table
sing_lib.tex(,649) @strong{Example:}
sing_lib.tex(,650) @smallexample
sing_lib.tex(,651) @c computed example tjurina d2t_singular/sing_lib.doc:527 
sing_lib.tex(,652) LIB "sing.lib";
sing_lib.tex(,653) ring r=32003,(x,y,z),(c,ds);
sing_lib.tex(,654) ideal j=x2+y2+z2,x2+2y2+3z2;
sing_lib.tex(,655) tjurina(j);
sing_lib.tex(,656) @expansion{} 5
sing_lib.tex(,657) @c end example tjurina d2t_singular/sing_lib.doc:527
sing_lib.tex(,658) @end smallexample
sing_lib.tex(,659) @c ---end content tjurina---
sing_lib.tex(,660) 
sing_lib.tex(,661) @c ------------------- T_1 -------------
sing_lib.tex(,662) @node T_1, T_2, tjurina, sing_lib
sing_lib.tex(,663) @subsubsection T_1
sing_lib.tex(,664) @cindex T_1
sing_lib.tex(,665) @c ---content T_1---
sing_lib.tex(,666) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,667) 
sing_lib.tex(,668) @table @asis
sing_lib.tex(,669) @item @strong{Usage:}
sing_lib.tex(,670) T_1(id[,<any>]); id = ideal or poly
sing_lib.tex(,671) 
sing_lib.tex(,672) @item @strong{Return:}
sing_lib.tex(,673) T_1(id): of type module/ideal if id is of type ideal/poly.
sing_lib.tex(,674) We call T_1(id) the T_1-module of id. It is a std basis of the
sing_lib.tex(,675) presentation of 1st order deformations of P/id, if P is the basering.
sing_lib.tex(,676) If a second argument is present (of any type) return a list of
sing_lib.tex(,677) 3 modules:
sing_lib.tex(,678) @*[1]= T_1(id)
sing_lib.tex(,679) @*[2]= generators of normal bundle of id, lifted to P
sing_lib.tex(,680) @*[3]= module of relations of [2], lifted to P
sing_lib.tex(,681) @*(note: transpose[3]*[2]=0 mod id)
sing_lib.tex(,682) @*The list contains all non-easy objects which must be computed
sing_lib.tex(,683) to get T_1(id).
sing_lib.tex(,684) 
sing_lib.tex(,685) @item @strong{Display:}
sing_lib.tex(,686) k-dimension of T_1(id) if printlevel >= 0 (default)
sing_lib.tex(,687) 
sing_lib.tex(,688) @item @strong{Note:}
sing_lib.tex(,689) T_1(id) itself is usually of minor importance. Nevertheless, from it
sing_lib.tex(,690) all relevant information can be obtained. The most important are
sing_lib.tex(,691) probably vdim(T_1(id)); (which computes the Tjurina number),
sing_lib.tex(,692) hilb(T_1(id)); and kbase(T_1(id));
sing_lib.tex(,693) @*If T_1 is called with two argument, then matrix([2])*(kbase([1]))
sing_lib.tex(,694) represents a basis of 1st order semiuniversal deformation of id
sing_lib.tex(,695) (use proc 'deform', to get this in a direct way).
sing_lib.tex(,696) @*For a complete intersection the proc Tjurina is faster
sing_lib.tex(,697) 
sing_lib.tex(,698) @end table
sing_lib.tex(,699) @strong{Example:}
sing_lib.tex(,700) @smallexample
sing_lib.tex(,701) @c computed example T_1 d2t_singular/sing_lib.doc:576 
sing_lib.tex(,702) LIB "sing.lib";
sing_lib.tex(,703) int p      = printlevel;
sing_lib.tex(,704) printlevel = 1;
sing_lib.tex(,705) ring r     = 32003,(x,y,z),(c,ds);
sing_lib.tex(,706) ideal i    = xy,xz,yz;
sing_lib.tex(,707) module T   = T_1(i);
sing_lib.tex(,708) @expansion{} // dim T_1 = 3
sing_lib.tex(,709) vdim(T);                      // Tjurina number = dim_K(T_1), should be 3
sing_lib.tex(,710) @expansion{} 3
sing_lib.tex(,711) list L=T_1(i,"");
sing_lib.tex(,712) @expansion{} // dim T_1 = 3
sing_lib.tex(,713) module kB  = kbase(L[1]);
sing_lib.tex(,714) print(L[2]*kB);               // basis of 1st order miniversal deformation
sing_lib.tex(,715) @expansion{} 0,0,0,
sing_lib.tex(,716) @expansion{} z,0,0,
sing_lib.tex(,717) @expansion{} 0,y,z 
sing_lib.tex(,718) show(L[2]);                   // presentation of normal bundle
sing_lib.tex(,719) @expansion{} // module, 6 generator(s)
sing_lib.tex(,720) @expansion{} [x]
sing_lib.tex(,721) @expansion{} [y,z]
sing_lib.tex(,722) @expansion{} [0,x,y]
sing_lib.tex(,723) @expansion{} [0,z]
sing_lib.tex(,724) @expansion{} [0,0,y]
sing_lib.tex(,725) @expansion{} [0,0,z]
sing_lib.tex(,726) print(L[3]);                  // relations of i
sing_lib.tex(,727) @expansion{} z, 0,
sing_lib.tex(,728) @expansion{} -y,y,
sing_lib.tex(,729) @expansion{} 0, -x
sing_lib.tex(,730) print(transpose(L[3])*L[2]);  // should be 0 (mod i)
sing_lib.tex(,731) @expansion{} xz,0, -xy,-yz,0,  0, 
sing_lib.tex(,732) @expansion{} 0, yz,0,  yz, -xy,-xz
sing_lib.tex(,733) printlevel = p;
sing_lib.tex(,734) @c end example T_1 d2t_singular/sing_lib.doc:576
sing_lib.tex(,735) @end smallexample
sing_lib.tex(,736) @c ---end content T_1---
sing_lib.tex(,737) 
sing_lib.tex(,738) @c ------------------- T_2 -------------
sing_lib.tex(,739) @node T_2, T_12, T_1, sing_lib
sing_lib.tex(,740) @subsubsection T_2
sing_lib.tex(,741) @cindex T_2
sing_lib.tex(,742) @c ---content T_2---
sing_lib.tex(,743) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,744) 
sing_lib.tex(,745) @table @asis
sing_lib.tex(,746) @item @strong{Usage:}
sing_lib.tex(,747) T_2(id[,<any>]); id = ideal
sing_lib.tex(,748) 
sing_lib.tex(,749) @item @strong{Return:}
sing_lib.tex(,750) T_2(id): T_2-module of id . This is a std basis of a presentation of
sing_lib.tex(,751) the module of obstructions of R=P/id, if P is the basering.
sing_lib.tex(,752) If a second argument is present (of any type) return a list of
sing_lib.tex(,753) 4 modules and 1 ideal:
sing_lib.tex(,754) @*[1]= T_2(id)
sing_lib.tex(,755) @*[2]= standard basis of id (ideal)
sing_lib.tex(,756) @*[3]= module of relations of id (=1st syzygy module of id) @*
sing_lib.tex(,757) [4]= presentation of syz/kos
sing_lib.tex(,758) @*[5]= relations of Hom_P([3]/kos,R), lifted to P
sing_lib.tex(,759) @*The list contains all non-easy objects which must be computed
sing_lib.tex(,760) to get T_2(id).
sing_lib.tex(,761) 
sing_lib.tex(,762) @item @strong{Display:}
sing_lib.tex(,763) k-dimension of T_2(id) if printlevel >= 0 (default)
sing_lib.tex(,764) 
sing_lib.tex(,765) @item @strong{Note:}
sing_lib.tex(,766) The most important information is probably vdim(T_2(id)).
sing_lib.tex(,767) Use proc miniversal to get equations of miniversal deformation.
sing_lib.tex(,768) 
sing_lib.tex(,769) @end table
sing_lib.tex(,770) @strong{Example:}
sing_lib.tex(,771) @smallexample
sing_lib.tex(,772) @c computed example T_2 d2t_singular/sing_lib.doc:629 
sing_lib.tex(,773) LIB "sing.lib";
sing_lib.tex(,774) int p      = printlevel;
sing_lib.tex(,775) printlevel = 1;
sing_lib.tex(,776) ring  r    = 32003,(x,y),(c,dp);
sing_lib.tex(,777) ideal j    = x6-y4,x6y6,x2y4-x5y2;
sing_lib.tex(,778) module T   = T_2(j);
sing_lib.tex(,779) @expansion{} // dim T_2 = 6
sing_lib.tex(,780) vdim(T);
sing_lib.tex(,781) @expansion{} 6
sing_lib.tex(,782) hilb(T);"";
sing_lib.tex(,783) @expansion{} //         1 t^0
sing_lib.tex(,784) @expansion{} //        -1 t^2
sing_lib.tex(,785) @expansion{} //        -1 t^3
sing_lib.tex(,786) @expansion{} //         1 t^5
sing_lib.tex(,787) @expansion{} 
sing_lib.tex(,788) @expansion{} //         1 t^0
sing_lib.tex(,789) @expansion{} //         2 t^1
sing_lib.tex(,790) @expansion{} //         2 t^2
sing_lib.tex(,791) @expansion{} //         1 t^3
sing_lib.tex(,792) @expansion{} // dimension (affine)  = 0
sing_lib.tex(,793) @expansion{} // degree      = 6
sing_lib.tex(,794) @expansion{} 
sing_lib.tex(,795) ring r1    = 0,(x,y,z),dp;
sing_lib.tex(,796) ideal id   = xy,xz,yz;
sing_lib.tex(,797) list L     = T_2(id,"");
sing_lib.tex(,798) @expansion{} // dim T_2 = 0
sing_lib.tex(,799) vdim(L[1]);                           // vdim of T_2
sing_lib.tex(,800) @expansion{} 0
sing_lib.tex(,801) print(L[3]);                          // syzygy module of id
sing_lib.tex(,802) @expansion{} -z,-z,
sing_lib.tex(,803) @expansion{} y, 0, 
sing_lib.tex(,804) @expansion{} 0, x  
sing_lib.tex(,805) printlevel = p;
sing_lib.tex(,806) @c end example T_2 d2t_singular/sing_lib.doc:629
sing_lib.tex(,807) @end smallexample
sing_lib.tex(,808) @c ---end content T_2---
sing_lib.tex(,809) 
sing_lib.tex(,810) @c ------------------- T_12 -------------
sing_lib.tex(,811) @node T_12, tangentcone, T_2, sing_lib
sing_lib.tex(,812) @subsubsection T_12
sing_lib.tex(,813) @cindex T_12
sing_lib.tex(,814) @c ---content T_12---
sing_lib.tex(,815) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,816) 
sing_lib.tex(,817) @table @asis
sing_lib.tex(,818) @item @strong{Usage:}
sing_lib.tex(,819) T_12(i[,any]); i = ideal
sing_lib.tex(,820) 
sing_lib.tex(,821) @item @strong{Return:}
sing_lib.tex(,822) T_12(i): list of 2 modules: @*
sing_lib.tex(,823) * standard basis of T_1-module =T_1(i), 1st order deformations @*
sing_lib.tex(,824) * standard basis of T_2-module =T_2(i), obstructions of R=P/i @*
sing_lib.tex(,825) If a second argument is present (of any type) return a list of
sing_lib.tex(,826) 9 modules, matrices, integers: @*
sing_lib.tex(,827) [1]= standard basis of T_1-module
sing_lib.tex(,828) @*[2]= standard basis of T_2-module
sing_lib.tex(,829) @*[3]= vdim of T_1
sing_lib.tex(,830) @*[4]= vdim of T_2
sing_lib.tex(,831) @*[5]= matrix, whose cols present infinitesimal deformations @*
sing_lib.tex(,832) [6]= matrix, whose cols are generators of relations of i(=syz(i)) @*
sing_lib.tex(,833) [7]= matrix, presenting Hom_P(syz/kos,R), lifted to P @*
sing_lib.tex(,834) [8]= presentation of T_1-module, no std basis
sing_lib.tex(,835) @*[9]= presentation of T_2-module, no std basis
sing_lib.tex(,836) 
sing_lib.tex(,837) @item @strong{Display:}
sing_lib.tex(,838) k-dimension of T_1 and T_2 if printlevel >= 0 (default)
sing_lib.tex(,839) 
sing_lib.tex(,840) @item @strong{Note:}
sing_lib.tex(,841) Use proc miniversal from deform.lib to get miniversal deformation of i,
sing_lib.tex(,842) the list contains all objects used by proc miniversal
sing_lib.tex(,843) 
sing_lib.tex(,844) @end table
sing_lib.tex(,845) @strong{Example:}
sing_lib.tex(,846) @smallexample
sing_lib.tex(,847) @c computed example T_12 d2t_singular/sing_lib.doc:685 
sing_lib.tex(,848) LIB "sing.lib";
sing_lib.tex(,849) int p      = printlevel;
sing_lib.tex(,850) printlevel = 1;
sing_lib.tex(,851) ring r     = 200,(x,y,z,u,v),(c,ws(4,3,2,3,4));
sing_lib.tex(,852) ideal i    = xz-y2,yz2-xu,xv-yzu,yu-z3,z2u-yv,zv-u2;
sing_lib.tex(,853) //a cyclic quotient singularity
sing_lib.tex(,854) list L     = T_12(i,1);
sing_lib.tex(,855) @expansion{} // dim T_1 = 5
sing_lib.tex(,856) @expansion{} // dim T_2 = 3
sing_lib.tex(,857) print(L[5]);             //matrix of infin. deformations
sing_lib.tex(,858) @expansion{} 0,  0,  0,  0,  0,  
sing_lib.tex(,859) @expansion{} yz, y,  z2, 0,  0,  
sing_lib.tex(,860) @expansion{} -z3,-z2,-zu,yz, yu, 
sing_lib.tex(,861) @expansion{} -z2,-z, -u, 0,  0,  
sing_lib.tex(,862) @expansion{} zu, u,  v,  -z2,-zu,
sing_lib.tex(,863) @expansion{} 0,  0,  0,  u,  v   
sing_lib.tex(,864) printlevel = p;
sing_lib.tex(,865) @c end example T_12 d2t_singular/sing_lib.doc:685
sing_lib.tex(,866) @end smallexample
sing_lib.tex(,867) @c ---end content T_12---
sing_lib.tex(,868) 
sing_lib.tex(,869) @c ------------------- tangentcone -------------
sing_lib.tex(,870) @node tangentcone,, T_12, sing_lib
sing_lib.tex(,871) @subsubsection tangentcone
sing_lib.tex(,872) @cindex tangentcone
sing_lib.tex(,873) @c ---content tangentcone---
sing_lib.tex(,874) Procedure from library @code{sing.lib} (@pxref{sing_lib}).
sing_lib.tex(,875) 
sing_lib.tex(,876) @table @asis
sing_lib.tex(,877) @item @strong{Usage:}
sing_lib.tex(,878) tangentcone(id [,n]); id = ideal, n = int
sing_lib.tex(,879) 
sing_lib.tex(,880) @item @strong{Return:}
sing_lib.tex(,881) the tangent cone of id
sing_lib.tex(,882) 
sing_lib.tex(,883) @item @strong{Note:}
sing_lib.tex(,884) the procedure works for any monomial ordering.
sing_lib.tex(,885) @*If n=0 use std w.r.t. local ordering ds, if n=1 use locstd
sing_lib.tex(,886) 
sing_lib.tex(,887) @end table
sing_lib.tex(,888) @strong{Example:}
sing_lib.tex(,889) @smallexample
sing_lib.tex(,890) @c computed example tangentcone d2t_singular/sing_lib.doc:720 
sing_lib.tex(,891) LIB "sing.lib";
sing_lib.tex(,892) ring R = 0,(x,y,z),ds;
sing_lib.tex(,893) ideal i  = 7xyz+z5,x2+y3+z7,5z5+y5;
sing_lib.tex(,894) tangentcone(i);
sing_lib.tex(,895) @expansion{} _[1]=x2
sing_lib.tex(,896) @expansion{} _[2]=7xyz
sing_lib.tex(,897) @expansion{} _[3]=y5+5z5
sing_lib.tex(,898) @expansion{} _[4]=7y4z
sing_lib.tex(,899) @expansion{} _[5]=35z6
sing_lib.tex(,900) @c end example tangentcone d2t_singular/sing_lib.doc:720
sing_lib.tex(,901) @end smallexample
sing_lib.tex(,902) @c ---end content tangentcone---
singular.texi(,490) @c ---------------------------------------------------------
singular.texi(,491) @node spcurve_lib, spectrum_lib, sing_lib, Singularities
singular.texi(,492) @subsection spcurve_lib
singular.texi(,493) @c include of docu for spcurve.lib
spcurve_lib.tex(,1) @c ---content LibInfo---
spcurve_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/spcurve_lib.doc
spcurve_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/spcurve_lib.doc INSTEAD
spcurve_lib.tex(,4) @c library version: (1.15.2.1,2002/02/20)
spcurve_lib.tex(,5) @c library file: ../Singular/LIB/spcurve.lib
spcurve_lib.tex(,6) @cindex spcurve.lib
spcurve_lib.tex(,7) @cindex spcurve_lib
spcurve_lib.tex(,8) @table @asis
spcurve_lib.tex(,9) @item @strong{Library:}
spcurve_lib.tex(,10) spcurve.lib
spcurve_lib.tex(,11) @item @strong{Purpose:}
spcurve_lib.tex(,12)     Deformations and Invariants of CM-codim 2 Singularities
spcurve_lib.tex(,13) @item @strong{Author:}
spcurve_lib.tex(,14) Anne Fruehbis-Krueger, anne@@mathematik.uni-kl.de
spcurve_lib.tex(,15) 
spcurve_lib.tex(,16) @end table
spcurve_lib.tex(,17) 
spcurve_lib.tex(,18) @strong{Procedures:}
spcurve_lib.tex(,19) @menu
spcurve_lib.tex(,20) * isCMcod2:: presentation matrix of the ideal i, if i is CM
spcurve_lib.tex(,21) * CMtype:: Cohen-Macaulay type of the ideal i
spcurve_lib.tex(,22) * matrixT1:: 1st order deformation T1 in matrix description
spcurve_lib.tex(,23) * semiCMcod2:: semiuniversal deformation of maximal minors of M
spcurve_lib.tex(,24) * discr:: discriminant of semiuniversal deformation
spcurve_lib.tex(,25) * qhmatrix:: weights if M is quasihomogeneous
spcurve_lib.tex(,26) * relweight:: relative matrix weight of N w.r.t. weights (W,a)
spcurve_lib.tex(,27) * posweight:: deformation of coker(M) of non-negative weight
spcurve_lib.tex(,28) * KSpencerKernel:: kernel of the Kodaira-Spencer map
spcurve_lib.tex(,29) @end menu
spcurve_lib.tex(,30) @c ---end content LibInfo---
spcurve_lib.tex(,31) 
spcurve_lib.tex(,32) @c ------------------- isCMcod2 -------------
spcurve_lib.tex(,33) @node isCMcod2, CMtype,, spcurve_lib
spcurve_lib.tex(,34) @subsubsection isCMcod2
spcurve_lib.tex(,35) @cindex isCMcod2
spcurve_lib.tex(,36) @c ---content isCMcod2---
spcurve_lib.tex(,37) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,38) 
spcurve_lib.tex(,39) @table @asis
spcurve_lib.tex(,40) @item @strong{Usage:}
spcurve_lib.tex(,41) isCMcod2(i); i an ideal
spcurve_lib.tex(,42) 
spcurve_lib.tex(,43) @item @strong{Return:}
spcurve_lib.tex(,44) presentation matrix of i, if i is Cohen-Macaulay of codimension 2 @*
spcurve_lib.tex(,45) a zero matrix otherwise
spcurve_lib.tex(,46) 
spcurve_lib.tex(,47) @end table
spcurve_lib.tex(,48) @strong{Example:}
spcurve_lib.tex(,49) @smallexample
spcurve_lib.tex(,50) @c computed example isCMcod2 d2t_singular/spcurve_lib.doc:48 
spcurve_lib.tex(,51) LIB "spcurve.lib";
spcurve_lib.tex(,52) ring r=32003,(x,y,z),ds;
spcurve_lib.tex(,53) ideal i=xz,yz,x^3-y^4;
spcurve_lib.tex(,54) print(isCMcod2(i));
spcurve_lib.tex(,55) @expansion{} -y,-x2,
spcurve_lib.tex(,56) @expansion{} x, y3, 
spcurve_lib.tex(,57) @expansion{} 0, z   
spcurve_lib.tex(,58) @c end example isCMcod2 d2t_singular/spcurve_lib.doc:48
spcurve_lib.tex(,59) @end smallexample
spcurve_lib.tex(,60) @c ---end content isCMcod2---
spcurve_lib.tex(,61) 
spcurve_lib.tex(,62) @c ------------------- CMtype -------------
spcurve_lib.tex(,63) @node CMtype, matrixT1, isCMcod2, spcurve_lib
spcurve_lib.tex(,64) @subsubsection CMtype
spcurve_lib.tex(,65) @cindex CMtype
spcurve_lib.tex(,66) @c ---content CMtype---
spcurve_lib.tex(,67) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,68) 
spcurve_lib.tex(,69) @table @asis
spcurve_lib.tex(,70) @item @strong{Usage:}
spcurve_lib.tex(,71) CMtype(i); i an ideal, CM of codimension 2
spcurve_lib.tex(,72) 
spcurve_lib.tex(,73) @item @strong{Return:}
spcurve_lib.tex(,74) Cohen-Macaulay type of i (integer)
spcurve_lib.tex(,75) @*(-1, if i is not Cohen-Macaulay of codimension 2)
spcurve_lib.tex(,76) 
spcurve_lib.tex(,77) @end table
spcurve_lib.tex(,78) @strong{Example:}
spcurve_lib.tex(,79) @smallexample
spcurve_lib.tex(,80) @c computed example CMtype d2t_singular/spcurve_lib.doc:75 
spcurve_lib.tex(,81) LIB "spcurve.lib";
spcurve_lib.tex(,82) ring r=32003,(x,y,z),ds;
spcurve_lib.tex(,83) ideal i=xy,xz,yz;
spcurve_lib.tex(,84) CMtype(i);
spcurve_lib.tex(,85) @expansion{} 2
spcurve_lib.tex(,86) @c end example CMtype d2t_singular/spcurve_lib.doc:75
spcurve_lib.tex(,87) @end smallexample
spcurve_lib.tex(,88) @c ---end content CMtype---
spcurve_lib.tex(,89) 
spcurve_lib.tex(,90) @c ------------------- matrixT1 -------------
spcurve_lib.tex(,91) @node matrixT1, semiCMcod2, CMtype, spcurve_lib
spcurve_lib.tex(,92) @subsubsection matrixT1
spcurve_lib.tex(,93) @cindex matrixT1
spcurve_lib.tex(,94) @c ---content matrixT1---
spcurve_lib.tex(,95) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,96) 
spcurve_lib.tex(,97) @table @asis
spcurve_lib.tex(,98) @item @strong{Usage:}
spcurve_lib.tex(,99) matrixT1(M,n); M matrix, n integer
spcurve_lib.tex(,100) 
spcurve_lib.tex(,101) @item @strong{Assume:}
spcurve_lib.tex(,102) M is a presentation matrix of an ideal i, CM of codimension 2;
spcurve_lib.tex(,103) consider i as a family of ideals in a ring in the first n
spcurve_lib.tex(,104) variables where the remaining variables are considered as
spcurve_lib.tex(,105) parameters
spcurve_lib.tex(,106) 
spcurve_lib.tex(,107) @item @strong{Return:}
spcurve_lib.tex(,108) list consisting of the k x (k+1) matrix M and a module K_M such that
spcurve_lib.tex(,109) T1=Mat(k,k+1;R)/K_M is the space of first order deformations of i
spcurve_lib.tex(,110) 
spcurve_lib.tex(,111) @end table
spcurve_lib.tex(,112) @strong{Example:}
spcurve_lib.tex(,113) @smallexample
spcurve_lib.tex(,114) @c computed example matrixT1 d2t_singular/spcurve_lib.doc:108 
spcurve_lib.tex(,115) LIB "spcurve.lib";
spcurve_lib.tex(,116) ring r=32003,(x(1),x(2),x(3)),ds;
spcurve_lib.tex(,117) ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
spcurve_lib.tex(,118) matrix M=isCMcod2(curve);
spcurve_lib.tex(,119) matrixT1(M,3);
spcurve_lib.tex(,120) @expansion{} [1]:
spcurve_lib.tex(,121) @expansion{}    _[1,1]=0
spcurve_lib.tex(,122) @expansion{}    _[1,2]=-x(3)
spcurve_lib.tex(,123) @expansion{}    _[2,1]=-x(2)
spcurve_lib.tex(,124) @expansion{}    _[2,2]=x(2)
spcurve_lib.tex(,125) @expansion{}    _[3,1]=x(1)
spcurve_lib.tex(,126) @expansion{}    _[3,2]=0
spcurve_lib.tex(,127) @expansion{} [2]:
spcurve_lib.tex(,128) @expansion{}    _[1]=gen(5)
spcurve_lib.tex(,129) @expansion{}    _[2]=gen(4)-gen(3)
spcurve_lib.tex(,130) @expansion{}    _[3]=-gen(2)
spcurve_lib.tex(,131) @expansion{}    _[4]=x(1)*gen(5)-x(2)*gen(3)
spcurve_lib.tex(,132) @expansion{}    _[5]=x(1)*gen(6)-x(2)*gen(4)
spcurve_lib.tex(,133) @expansion{}    _[6]=x(2)*gen(3)-x(3)*gen(1)
spcurve_lib.tex(,134) @expansion{}    _[7]=x(2)*gen(4)-x(3)*gen(2)
spcurve_lib.tex(,135) @expansion{}    _[8]=-x(3)*gen(2)
spcurve_lib.tex(,136) @expansion{}    _[9]=x(2)*gen(2)-x(2)*gen(1)
spcurve_lib.tex(,137) @expansion{}    _[10]=x(1)*gen(1)
spcurve_lib.tex(,138) @expansion{}    _[11]=-x(3)*gen(4)
spcurve_lib.tex(,139) @expansion{}    _[12]=x(2)*gen(4)-x(2)*gen(3)
spcurve_lib.tex(,140) @expansion{}    _[13]=x(1)*gen(3)
spcurve_lib.tex(,141) @expansion{}    _[14]=-x(3)*gen(6)
spcurve_lib.tex(,142) @expansion{}    _[15]=x(2)*gen(6)-x(2)*gen(5)
spcurve_lib.tex(,143) @expansion{}    _[16]=x(1)*gen(5)
spcurve_lib.tex(,144) @c end example matrixT1 d2t_singular/spcurve_lib.doc:108
spcurve_lib.tex(,145) @end smallexample
spcurve_lib.tex(,146) @c ---end content matrixT1---
spcurve_lib.tex(,147) 
spcurve_lib.tex(,148) @c ------------------- semiCMcod2 -------------
spcurve_lib.tex(,149) @node semiCMcod2, discr, matrixT1, spcurve_lib
spcurve_lib.tex(,150) @subsubsection semiCMcod2
spcurve_lib.tex(,151) @cindex semiCMcod2
spcurve_lib.tex(,152) @c ---content semiCMcod2---
spcurve_lib.tex(,153) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,154) 
spcurve_lib.tex(,155) @table @asis
spcurve_lib.tex(,156) @item @strong{Usage:}
spcurve_lib.tex(,157) semiCMcod2(M,t1); M matrix, t1 module
spcurve_lib.tex(,158) 
spcurve_lib.tex(,159) @item @strong{Assume:}
spcurve_lib.tex(,160) M is a presentation matrix of an ideal i, CM of codimension 2,
spcurve_lib.tex(,161) and t1 is a presentation of the space of first order deformations
spcurve_lib.tex(,162) of i ((M,t1) as returned by the procedure matrixT1)
spcurve_lib.tex(,163) 
spcurve_lib.tex(,164) @item @strong{Create:}
spcurve_lib.tex(,165) new basering with name rneu
spcurve_lib.tex(,166) 
spcurve_lib.tex(,167) @item @strong{Return:}
spcurve_lib.tex(,168) ideal in rneu describing the semiuniversal deformation of i
spcurve_lib.tex(,169) 
spcurve_lib.tex(,170) @item @strong{Note:}
spcurve_lib.tex(,171) The current basering should not contain any variables named
spcurve_lib.tex(,172) A(j) where j is some integer!
spcurve_lib.tex(,173) 
spcurve_lib.tex(,174) @end table
spcurve_lib.tex(,175) @strong{Example:}
spcurve_lib.tex(,176) @smallexample
spcurve_lib.tex(,177) @c computed example semiCMcod2 d2t_singular/spcurve_lib.doc:147 
spcurve_lib.tex(,178) LIB "spcurve.lib";
spcurve_lib.tex(,179) ring r=32003,(x(1),x(2),x(3)),ds;
spcurve_lib.tex(,180) ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
spcurve_lib.tex(,181) matrix M=isCMcod2(curve);
spcurve_lib.tex(,182) list l=matrixT1(M,3);
spcurve_lib.tex(,183) semiCMcod2(l[1],std(l[2]));
spcurve_lib.tex(,184) @expansion{} _[1]=A(2)*A(3)-x(2)*A(3)-x(1)*x(2)
spcurve_lib.tex(,185) @expansion{} _[2]=A(1)*A(3)+x(1)*x(3)
spcurve_lib.tex(,186) @expansion{} _[3]=-x(2)*A(1)-x(3)*A(2)+x(2)*x(3)
spcurve_lib.tex(,187) @c end example semiCMcod2 d2t_singular/spcurve_lib.doc:147
spcurve_lib.tex(,188) @end smallexample
spcurve_lib.tex(,189) @c ---end content semiCMcod2---
spcurve_lib.tex(,190) 
spcurve_lib.tex(,191) @c ------------------- discr -------------
spcurve_lib.tex(,192) @node discr, qhmatrix, semiCMcod2, spcurve_lib
spcurve_lib.tex(,193) @subsubsection discr
spcurve_lib.tex(,194) @cindex discr
spcurve_lib.tex(,195) @c ---content discr---
spcurve_lib.tex(,196) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,197) 
spcurve_lib.tex(,198) @table @asis
spcurve_lib.tex(,199) @item @strong{Usage:}
spcurve_lib.tex(,200) discr(sem,n); sem ideal, n integer
spcurve_lib.tex(,201) 
spcurve_lib.tex(,202) @item @strong{Assume:}
spcurve_lib.tex(,203) sem is the versal deformation of an ideal of codimension 2. @*
spcurve_lib.tex(,204) the first n variables of the ring are treated as variables
spcurve_lib.tex(,205) all the others as parameters
spcurve_lib.tex(,206) 
spcurve_lib.tex(,207) @item @strong{Return:}
spcurve_lib.tex(,208) ideal describing the discriminant
spcurve_lib.tex(,209) 
spcurve_lib.tex(,210) @item @strong{Note:}
spcurve_lib.tex(,211) This is not a powerful algorithm!
spcurve_lib.tex(,212) 
spcurve_lib.tex(,213) @end table
spcurve_lib.tex(,214) @strong{Example:}
spcurve_lib.tex(,215) @smallexample
spcurve_lib.tex(,216) @c computed example discr d2t_singular/spcurve_lib.doc:183 
spcurve_lib.tex(,217) LIB "spcurve.lib";
spcurve_lib.tex(,218) ring r=32003,(x(1),x(2),x(3)),ds;
spcurve_lib.tex(,219) ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
spcurve_lib.tex(,220) matrix M=isCMcod2(curve);
spcurve_lib.tex(,221) list l=matrixT1(M,3);
spcurve_lib.tex(,222) def sem=semiCMcod2(l[1],std(l[2]));
spcurve_lib.tex(,223) basering;
spcurve_lib.tex(,224) @expansion{} //   characteristic : 32003
spcurve_lib.tex(,225) @expansion{} //   number of vars : 6
spcurve_lib.tex(,226) @expansion{} //        block   1 : ordering ds
spcurve_lib.tex(,227) @expansion{} //                  : names    x(1) x(2) x(3) 
spcurve_lib.tex(,228) @expansion{} //        block   2 : ordering dp
spcurve_lib.tex(,229) @expansion{} //                  : names    A(1) A(2) A(3) 
spcurve_lib.tex(,230) @expansion{} //        block   3 : ordering C
spcurve_lib.tex(,231) discr(sem,3);
spcurve_lib.tex(,232) @expansion{} _[1]=A(1)*A(2)*A(3)
spcurve_lib.tex(,233) @c end example discr d2t_singular/spcurve_lib.doc:183
spcurve_lib.tex(,234) @end smallexample
spcurve_lib.tex(,235) @c ---end content discr---
spcurve_lib.tex(,236) 
spcurve_lib.tex(,237) @c ------------------- qhmatrix -------------
spcurve_lib.tex(,238) @node qhmatrix, relweight, discr, spcurve_lib
spcurve_lib.tex(,239) @subsubsection qhmatrix
spcurve_lib.tex(,240) @cindex qhmatrix
spcurve_lib.tex(,241) @c ---content qhmatrix---
spcurve_lib.tex(,242) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,243) 
spcurve_lib.tex(,244) @table @asis
spcurve_lib.tex(,245) @item @strong{Usage:}
spcurve_lib.tex(,246) qhmatrix(M); M a k x (k+1) matrix
spcurve_lib.tex(,247) 
spcurve_lib.tex(,248) @item @strong{Return:}
spcurve_lib.tex(,249) list, consisting of an integer vector containing the weights of
spcurve_lib.tex(,250) the variables of the basering and an integer matrix giving the
spcurve_lib.tex(,251) weights of the entries of M, if M is quasihomogeneous;
spcurve_lib.tex(,252) zero integer vector and zero integer matrix, if M is not
spcurve_lib.tex(,253) quasihomogeneous, i.e. does not allow row and column weights
spcurve_lib.tex(,254) 
spcurve_lib.tex(,255) @end table
spcurve_lib.tex(,256) @strong{Example:}
spcurve_lib.tex(,257) @smallexample
spcurve_lib.tex(,258) @c computed example qhmatrix d2t_singular/spcurve_lib.doc:217 
spcurve_lib.tex(,259) LIB "spcurve.lib";
spcurve_lib.tex(,260) ring r=0,(x,y,z),ds;
spcurve_lib.tex(,261) matrix M[3][2]=z,0,y,x,x^3,y;
spcurve_lib.tex(,262) qhmatrix(M);
spcurve_lib.tex(,263) @expansion{} [1]:
spcurve_lib.tex(,264) @expansion{}    1,2,1
spcurve_lib.tex(,265) @expansion{} [2]:
spcurve_lib.tex(,266) @expansion{}    1,0,
spcurve_lib.tex(,267) @expansion{}    2,1,
spcurve_lib.tex(,268) @expansion{}    3,2 
spcurve_lib.tex(,269) pmat(M);
spcurve_lib.tex(,270) @expansion{} z,  0, 
spcurve_lib.tex(,271) @expansion{} y,  x, 
spcurve_lib.tex(,272) @expansion{} x3, y
spcurve_lib.tex(,273) @c end example qhmatrix d2t_singular/spcurve_lib.doc:217
spcurve_lib.tex(,274) @end smallexample
spcurve_lib.tex(,275) @c ---end content qhmatrix---
spcurve_lib.tex(,276) 
spcurve_lib.tex(,277) @c ------------------- relweight -------------
spcurve_lib.tex(,278) @node relweight, posweight, qhmatrix, spcurve_lib
spcurve_lib.tex(,279) @subsubsection relweight
spcurve_lib.tex(,280) @cindex relweight
spcurve_lib.tex(,281) @c ---content relweight---
spcurve_lib.tex(,282) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,283) 
spcurve_lib.tex(,284) @table @asis
spcurve_lib.tex(,285) @item @strong{Assume:}
spcurve_lib.tex(,286) N is a non-zero matrix
spcurve_lib.tex(,287) @*W is an integer matrix of the same size as N
spcurve_lib.tex(,288) @*a is an integer vector giving the weights of the variables
spcurve_lib.tex(,289) 
spcurve_lib.tex(,290) @item @strong{Return:}
spcurve_lib.tex(,291) integer, max(a-weighted order(N_ij) - W_ij | all entries ij) @*
spcurve_lib.tex(,292) string "ERROR" if sizes do not match
spcurve_lib.tex(,293) 
spcurve_lib.tex(,294) @end table
spcurve_lib.tex(,295) @strong{Example:}
spcurve_lib.tex(,296) @smallexample
spcurve_lib.tex(,297) @c computed example relweight d2t_singular/spcurve_lib.doc:247 
spcurve_lib.tex(,298) LIB "spcurve.lib";
spcurve_lib.tex(,299) ring r=32003,(x,y,z),ds;
spcurve_lib.tex(,300) matrix N[2][3]=z,0,y,x,x^3,y;
spcurve_lib.tex(,301) intmat W[2][3]=1,1,1,1,1,1;
spcurve_lib.tex(,302) intvec a=1,1,1;
spcurve_lib.tex(,303) relweight(N,W,a);
spcurve_lib.tex(,304) @expansion{} 2
spcurve_lib.tex(,305) @c end example relweight d2t_singular/spcurve_lib.doc:247
spcurve_lib.tex(,306) @end smallexample
spcurve_lib.tex(,307) @c ---end content relweight---
spcurve_lib.tex(,308) 
spcurve_lib.tex(,309) @c ------------------- posweight -------------
spcurve_lib.tex(,310) @node posweight, KSpencerKernel, relweight, spcurve_lib
spcurve_lib.tex(,311) @subsubsection posweight
spcurve_lib.tex(,312) @cindex posweight
spcurve_lib.tex(,313) @c ---content posweight---
spcurve_lib.tex(,314) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,315) 
spcurve_lib.tex(,316) @table @asis
spcurve_lib.tex(,317) @item @strong{Usage:}
spcurve_lib.tex(,318) posweight(M,t1,n[,s]); M matrix, t1 module, n int, s string @*
spcurve_lib.tex(,319) n=0 : all deformations of non-negative weight @*
spcurve_lib.tex(,320) n=1 : only non-constant deformations of non-negative weight @*
spcurve_lib.tex(,321) n=2 : all deformations of positive weight @*
spcurve_lib.tex(,322) As an optional parameter the name of a new ring may be
spcurve_lib.tex(,323) specified.
spcurve_lib.tex(,324) 
spcurve_lib.tex(,325) @item @strong{Assume:}
spcurve_lib.tex(,326) M is a presentation matrix of a Cohen-Macaulay codimension 2
spcurve_lib.tex(,327) ideal and t1 is its T1 space in matrix notation
spcurve_lib.tex(,328) 
spcurve_lib.tex(,329) @item @strong{Create:}
spcurve_lib.tex(,330) new basering (default name: rneu); a different name for this ring
spcurve_lib.tex(,331) may be given as a 4th parameter
spcurve_lib.tex(,332) 
spcurve_lib.tex(,333) @item @strong{Return:}
spcurve_lib.tex(,334) list, consisting of a presentation matrix describing the deformation
spcurve_lib.tex(,335) given by the generators of T1 of non-negative/positive weight
spcurve_lib.tex(,336) and the weight vector for the new variables
spcurve_lib.tex(,337) 
spcurve_lib.tex(,338) @item @strong{Note:}
spcurve_lib.tex(,339) The current basering should not contain any variables named
spcurve_lib.tex(,340) T(i) where i is some integer!
spcurve_lib.tex(,341) 
spcurve_lib.tex(,342) @end table
spcurve_lib.tex(,343) @strong{Example:}
spcurve_lib.tex(,344) @smallexample
spcurve_lib.tex(,345) @c computed example posweight d2t_singular/spcurve_lib.doc:294 
spcurve_lib.tex(,346) LIB "spcurve.lib";
spcurve_lib.tex(,347) ring r=32003,(x(1),x(2),x(3)),ds;
spcurve_lib.tex(,348) ideal curve=(x(3)-x(1)^2)*x(3),(x(3)-x(1)^2)*x(2),x(2)^2-x(1)^7*x(3);
spcurve_lib.tex(,349) matrix M=isCMcod2(curve);
spcurve_lib.tex(,350) list l=matrixT1(M,3);
spcurve_lib.tex(,351) list li=posweight(l[1],std(l[2]),0);
spcurve_lib.tex(,352) pmat(li[1]);
spcurve_lib.tex(,353) @expansion{} T(2)+x(1)*T(1), -x(3)+x(1)^2, 
spcurve_lib.tex(,354) @expansion{} -x(3),          x(2),         
spcurve_lib.tex(,355) @expansion{} x(2),           -x(1)^7
spcurve_lib.tex(,356) li[2];
spcurve_lib.tex(,357) @expansion{} 3,1
spcurve_lib.tex(,358) @c end example posweight d2t_singular/spcurve_lib.doc:294
spcurve_lib.tex(,359) @end smallexample
spcurve_lib.tex(,360) @c ---end content posweight---
spcurve_lib.tex(,361) 
spcurve_lib.tex(,362) @c ------------------- KSpencerKernel -------------
spcurve_lib.tex(,363) @node KSpencerKernel,, posweight, spcurve_lib
spcurve_lib.tex(,364) @subsubsection KSpencerKernel
spcurve_lib.tex(,365) @cindex KSpencerKernel
spcurve_lib.tex(,366) @c ---content KSpencerKernel---
spcurve_lib.tex(,367) Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).
spcurve_lib.tex(,368) 
spcurve_lib.tex(,369) @table @asis
spcurve_lib.tex(,370) @item @strong{Usage:}
spcurve_lib.tex(,371) KSpencerKernel(M[,s][,v]); M matrix, s string, v intvec @*
spcurve_lib.tex(,372) optional parameters (please specify in this order, if both are
spcurve_lib.tex(,373) present):
spcurve_lib.tex(,374) @** s = first of the names of the new rings
spcurve_lib.tex(,375) @*e.g. "R" leads to ring names R and R1
spcurve_lib.tex(,376) @** v of size n(n+1) leads to the following module ordering @*
spcurve_lib.tex(,377) gen(v[1]) > gen(v[2]) > ... > gen(v[n(n+1)]) where the matrix
spcurve_lib.tex(,378) entry ij corresponds to gen((i-1)*n+j)
spcurve_lib.tex(,379) 
spcurve_lib.tex(,380) @item @strong{Assume:}
spcurve_lib.tex(,381) M is a quasihomogeneous n x (n+1) matrix where the n minors define
spcurve_lib.tex(,382) an isolated space curve singularity
spcurve_lib.tex(,383) 
spcurve_lib.tex(,384) @item @strong{Create:}
spcurve_lib.tex(,385) 2 new rings (default names: rneu and reneu)
spcurve_lib.tex(,386) @*different ring names may be specified as a 2nd parameter
spcurve_lib.tex(,387) 
spcurve_lib.tex(,388) @item @strong{Return:}
spcurve_lib.tex(,389) coefficient matrix representing the kernel of the Kodaira-
spcurve_lib.tex(,390) Spencer map of the family of non-negative deformations
spcurve_lib.tex(,391) having the given singularity as special fibre
spcurve_lib.tex(,392) 
spcurve_lib.tex(,393) @item @strong{Note:}
spcurve_lib.tex(,394) * the initial basering should not contain variables with name
spcurve_lib.tex(,395) e(i) or T(i), since those variable names will internally be
spcurve_lib.tex(,396) used by the script
spcurve_lib.tex(,397) @** setting an intvec with 5 entries and name watchProgress
spcurve_lib.tex(,398) shows the progress of the computations: @*
spcurve_lib.tex(,399) watchProgress[1]>0 => option(prot) in groebner commands @*
spcurve_lib.tex(,400) watchProgress[2]>0 => trace output for highcorner @*
spcurve_lib.tex(,401) watchProgress[3]>0 => output of deformed matrix @*
spcurve_lib.tex(,402) watchProgress[4]>0 => result of elimination step @*
spcurve_lib.tex(,403) watchProgress[4]>1 => trace output of multiplications with xyz
spcurve_lib.tex(,404) and subsequent reductions @*
spcurve_lib.tex(,405) watchProgress[5]>0 => matrix representing the kernel using print
spcurve_lib.tex(,406) 
spcurve_lib.tex(,407) @end table
spcurve_lib.tex(,408) @strong{Example:}
spcurve_lib.tex(,409) @smallexample
spcurve_lib.tex(,410) @c computed example KSpencerKernel d2t_singular/spcurve_lib.doc:355 
spcurve_lib.tex(,411) LIB "spcurve.lib";
spcurve_lib.tex(,412) ring r=0,(x,y,z),ds;
spcurve_lib.tex(,413) matrix M[3][2]=z-x^7,0,y^2,z,x^9,y;
spcurve_lib.tex(,414) def KS=KSpencerKernel(M,"ar");
spcurve_lib.tex(,415) print(KS);
spcurve_lib.tex(,416) @expansion{} T(7),   0,      0,      0,     0,     0,     0,     0,  
spcurve_lib.tex(,417) @expansion{} KS[2,1],6*T(3), 3*T(7), 0,     0,     0,     0,     0,  
spcurve_lib.tex(,418) @expansion{} KS[3,1],KS[3,2],KS[3,3],6*T(3),3*T(7),0,     0,     0,  
spcurve_lib.tex(,419) @expansion{} 10*T(4),8*T(1), 7*T(5), 5*T(2),4*T(6),2*T(8),2*T(3),T(7)
spcurve_lib.tex(,420) nameof(basering);
spcurve_lib.tex(,421) @expansion{} ar
spcurve_lib.tex(,422) basering;
spcurve_lib.tex(,423) @expansion{} //   characteristic : 0
spcurve_lib.tex(,424) @expansion{} //   number of vars : 17
spcurve_lib.tex(,425) @expansion{} //        block   1 : ordering Ws
spcurve_lib.tex(,426) @expansion{} //                  : names    e(1) e(2) e(3) e(4) e(5) e(6) x y z 
spcurve_lib.tex(,427) @expansion{} //                  : weights  -21 -10 -32 -21 -27 -16 3 16 21 
spcurve_lib.tex(,428) @expansion{} //        block   2 : ordering wp
spcurve_lib.tex(,429) @expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) T(8) 
spcurve_lib.tex(,430) @expansion{} //                  : weights     8    5    2   10    7    4    1    2 
spcurve_lib.tex(,431) @expansion{} //        block   3 : ordering C
spcurve_lib.tex(,432) @c end example KSpencerKernel d2t_singular/spcurve_lib.doc:355
spcurve_lib.tex(,433) @end smallexample
spcurve_lib.tex(,434) @c ---end content KSpencerKernel---
singular.texi(,495) @c ---------------------------------------------------------
singular.texi(,496) @node spectrum_lib, , spcurve_lib, Singularities
singular.texi(,497) @subsection spectrum_lib
singular.texi(,498) @c include of docu for spectrum.lib
spectrum_lib.tex(,1) @c ---content LibInfo---
spectrum_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/spectrum_lib.doc
spectrum_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/spectrum_lib.doc INSTEAD
spectrum_lib.tex(,4) @c library version: (1.12.2.3,2002/03/06)
spectrum_lib.tex(,5) @c library file: ../Singular/LIB/spectrum.lib
spectrum_lib.tex(,6) @cindex spectrum.lib
spectrum_lib.tex(,7) @cindex spectrum_lib
spectrum_lib.tex(,8) @table @asis
spectrum_lib.tex(,9) @item @strong{Library:}
spectrum_lib.tex(,10) spectrum.lib
spectrum_lib.tex(,11) @item @strong{Purpose:}
spectrum_lib.tex(,12)   Singularity Spectrum for Nondegenerate Singularities
spectrum_lib.tex(,13) @item @strong{Author:}
spectrum_lib.tex(,14) S. Endrass
spectrum_lib.tex(,15) 
spectrum_lib.tex(,16) @end table
spectrum_lib.tex(,17) 
spectrum_lib.tex(,18) @strong{Procedures:}
spectrum_lib.tex(,19) @menu
spectrum_lib.tex(,20) * spectrumnd:: spectrum of nondegenerate isolated singularity f
spectrum_lib.tex(,21) @end menu
spectrum_lib.tex(,22) @c ---end content LibInfo---
spectrum_lib.tex(,23) 
spectrum_lib.tex(,24) @c ------------------- spectrumnd -------------
spectrum_lib.tex(,25) @node spectrumnd,,, spectrum_lib
spectrum_lib.tex(,26) @subsubsection spectrumnd
spectrum_lib.tex(,27) @cindex spectrumnd
spectrum_lib.tex(,28) @c ---content spectrumnd---
spectrum_lib.tex(,29) Procedure from library @code{spectrum.lib} (@pxref{spectrum_lib}).
spectrum_lib.tex(,30) 
spectrum_lib.tex(,31) @table @asis
spectrum_lib.tex(,32) @item @strong{Usage:}
spectrum_lib.tex(,33) spectrumnd(f[,1]); poly f
spectrum_lib.tex(,34) 
spectrum_lib.tex(,35) @item @strong{Assume:}
spectrum_lib.tex(,36) basering has characteristic 0 and local ordering,
spectrum_lib.tex(,37) @*f has isolated singularity at 0 and nondegenerate principal part
spectrum_lib.tex(,38) 
spectrum_lib.tex(,39) @item @strong{Return:}
spectrum_lib.tex(,40) @format
spectrum_lib.tex(,41) list S:
spectrum_lib.tex(,42)   ideal S[1]: spectral numbers in increasing order
spectrum_lib.tex(,43)   intvec S[2]:
spectrum_lib.tex(,44)     int S[2][i]: multiplicity of spectral number S[1][i]
spectrum_lib.tex(,45) @end format
spectrum_lib.tex(,46) 
spectrum_lib.tex(,47) @item @strong{Note:}
spectrum_lib.tex(,48) if a second argument 1 is given,
spectrum_lib.tex(,49) @*no test for a degenerate principal part will be done
spectrum_lib.tex(,50) @*SEE_ALSO: gaussman_lib
spectrum_lib.tex(,51) 
spectrum_lib.tex(,52) @cindex singularities
spectrum_lib.tex(,53) @cindex Gauss-Manin connection
spectrum_lib.tex(,54) @cindex spectrum
spectrum_lib.tex(,55) @end table
spectrum_lib.tex(,56) @strong{Example:}
spectrum_lib.tex(,57) @smallexample
spectrum_lib.tex(,58) @c computed example spectrumnd d2t_singular/spectrum_lib.doc:56 
spectrum_lib.tex(,59) LIB "spectrum.lib";
spectrum_lib.tex(,60) ring R=0,(x,y),ds;
spectrum_lib.tex(,61) poly f=x^31+x^6*y^7+x^2*y^12+x^13*y^2+y^29;
spectrum_lib.tex(,62) spectrumnd(f);
spectrum_lib.tex(,63) @expansion{} [1]:
spectrum_lib.tex(,64) @expansion{}    _[1]=-67/79
spectrum_lib.tex(,65) @expansion{}    _[2]=-62/79
spectrum_lib.tex(,66) @expansion{}    _[3]=-45/58
spectrum_lib.tex(,67) @expansion{}    _[4]=-57/79
spectrum_lib.tex(,68) @expansion{}    _[5]=-41/58
spectrum_lib.tex(,69) @expansion{}    _[6]=-55/79
spectrum_lib.tex(,70) @expansion{}    _[7]=-52/79
spectrum_lib.tex(,71) @expansion{}    _[8]=-37/58
spectrum_lib.tex(,72) @expansion{}    _[9]=-50/79
spectrum_lib.tex(,73) @expansion{}    _[10]=-18/29
spectrum_lib.tex(,74) @expansion{}    _[11]=-47/79
spectrum_lib.tex(,75) @expansion{}    _[12]=-45/79
spectrum_lib.tex(,76) @expansion{}    _[13]=-33/58
spectrum_lib.tex(,77) @expansion{}    _[14]=-16/29
spectrum_lib.tex(,78) @expansion{}    _[15]=-43/79
spectrum_lib.tex(,79) @expansion{}    _[16]=-42/79
spectrum_lib.tex(,80) @expansion{}    _[17]=-40/79
spectrum_lib.tex(,81) @expansion{}    _[18]=-1/2
spectrum_lib.tex(,82) @expansion{}    _[19]=-15/31
spectrum_lib.tex(,83) @expansion{}    _[20]=-14/29
spectrum_lib.tex(,84) @expansion{}    _[21]=-38/79
spectrum_lib.tex(,85) @expansion{}    _[22]=-27/58
spectrum_lib.tex(,86) @expansion{}    _[23]=-14/31
spectrum_lib.tex(,87) @expansion{}    _[24]=-35/79
spectrum_lib.tex(,88) @expansion{}    _[25]=-25/58
spectrum_lib.tex(,89) @expansion{}    _[26]=-13/31
spectrum_lib.tex(,90) @expansion{}    _[27]=-33/79
spectrum_lib.tex(,91) @expansion{}    _[28]=-12/29
spectrum_lib.tex(,92) @expansion{}    _[29]=-23/58
spectrum_lib.tex(,93) @expansion{}    _[30]=-31/79
spectrum_lib.tex(,94) @expansion{}    _[31]=-12/31
spectrum_lib.tex(,95) @expansion{}    _[32]=-30/79
spectrum_lib.tex(,96) @expansion{}    _[33]=-21/58
spectrum_lib.tex(,97) @expansion{}    _[34]=-11/31
spectrum_lib.tex(,98) @expansion{}    _[35]=-28/79
spectrum_lib.tex(,99) @expansion{}    _[36]=-10/29
spectrum_lib.tex(,100) @expansion{}    _[37]=-26/79
spectrum_lib.tex(,101) @expansion{}    _[38]=-19/58
spectrum_lib.tex(,102) @expansion{}    _[39]=-10/31
spectrum_lib.tex(,103) @expansion{}    _[40]=-25/79
spectrum_lib.tex(,104) @expansion{}    _[41]=-9/29
spectrum_lib.tex(,105) @expansion{}    _[42]=-17/58
spectrum_lib.tex(,106) @expansion{}    _[43]=-23/79
spectrum_lib.tex(,107) @expansion{}    _[44]=-9/31
spectrum_lib.tex(,108) @expansion{}    _[45]=-8/29
spectrum_lib.tex(,109) @expansion{}    _[46]=-21/79
spectrum_lib.tex(,110) @expansion{}    _[47]=-15/58
spectrum_lib.tex(,111) @expansion{}    _[48]=-8/31
spectrum_lib.tex(,112) @expansion{}    _[49]=-20/79
spectrum_lib.tex(,113) @expansion{}    _[50]=-7/29
spectrum_lib.tex(,114) @expansion{}    _[51]=-19/79
spectrum_lib.tex(,115) @expansion{}    _[52]=-18/79
spectrum_lib.tex(,116) @expansion{}    _[53]=-7/31
spectrum_lib.tex(,117) @expansion{}    _[54]=-13/58
spectrum_lib.tex(,118) @expansion{}    _[55]=-6/29
spectrum_lib.tex(,119) @expansion{}    _[56]=-16/79
spectrum_lib.tex(,120) @expansion{}    _[57]=-6/31
spectrum_lib.tex(,121) @expansion{}    _[58]=-15/79
spectrum_lib.tex(,122) @expansion{}    _[59]=-11/58
spectrum_lib.tex(,123) @expansion{}    _[60]=-14/79
spectrum_lib.tex(,124) @expansion{}    _[61]=-5/29
spectrum_lib.tex(,125) @expansion{}    _[62]=-13/79
spectrum_lib.tex(,126) @expansion{}    _[63]=-5/31
spectrum_lib.tex(,127) @expansion{}    _[64]=-9/58
spectrum_lib.tex(,128) @expansion{}    _[65]=-11/79
spectrum_lib.tex(,129) @expansion{}    _[66]=-4/29
spectrum_lib.tex(,130) @expansion{}    _[67]=-4/31
spectrum_lib.tex(,131) @expansion{}    _[68]=-10/79
spectrum_lib.tex(,132) @expansion{}    _[69]=-7/58
spectrum_lib.tex(,133) @expansion{}    _[70]=-9/79
spectrum_lib.tex(,134) @expansion{}    _[71]=-3/29
spectrum_lib.tex(,135) @expansion{}    _[72]=-8/79
spectrum_lib.tex(,136) @expansion{}    _[73]=-3/31
spectrum_lib.tex(,137) @expansion{}    _[74]=-7/79
spectrum_lib.tex(,138) @expansion{}    _[75]=-5/58
spectrum_lib.tex(,139) @expansion{}    _[76]=-6/79
spectrum_lib.tex(,140) @expansion{}    _[77]=-2/29
spectrum_lib.tex(,141) @expansion{}    _[78]=-2/31
spectrum_lib.tex(,142) @expansion{}    _[79]=-5/79
spectrum_lib.tex(,143) @expansion{}    _[80]=-3/58
spectrum_lib.tex(,144) @expansion{}    _[81]=-4/79
spectrum_lib.tex(,145) @expansion{}    _[82]=-3/79
spectrum_lib.tex(,146) @expansion{}    _[83]=-1/29
spectrum_lib.tex(,147) @expansion{}    _[84]=-1/31
spectrum_lib.tex(,148) @expansion{}    _[85]=-2/79
spectrum_lib.tex(,149) @expansion{}    _[86]=-1/58
spectrum_lib.tex(,150) @expansion{}    _[87]=-1/79
spectrum_lib.tex(,151) @expansion{}    _[88]=0
spectrum_lib.tex(,152) @expansion{}    _[89]=1/79
spectrum_lib.tex(,153) @expansion{}    _[90]=1/58
spectrum_lib.tex(,154) @expansion{}    _[91]=2/79
spectrum_lib.tex(,155) @expansion{}    _[92]=1/31
spectrum_lib.tex(,156) @expansion{}    _[93]=1/29
spectrum_lib.tex(,157) @expansion{}    _[94]=3/79
spectrum_lib.tex(,158) @expansion{}    _[95]=4/79
spectrum_lib.tex(,159) @expansion{}    _[96]=3/58
spectrum_lib.tex(,160) @expansion{}    _[97]=5/79
spectrum_lib.tex(,161) @expansion{}    _[98]=2/31
spectrum_lib.tex(,162) @expansion{}    _[99]=2/29
spectrum_lib.tex(,163) @expansion{}    _[100]=6/79
spectrum_lib.tex(,164) @expansion{}    _[101]=5/58
spectrum_lib.tex(,165) @expansion{}    _[102]=7/79
spectrum_lib.tex(,166) @expansion{}    _[103]=3/31
spectrum_lib.tex(,167) @expansion{}    _[104]=8/79
spectrum_lib.tex(,168) @expansion{}    _[105]=3/29
spectrum_lib.tex(,169) @expansion{}    _[106]=9/79
spectrum_lib.tex(,170) @expansion{}    _[107]=7/58
spectrum_lib.tex(,171) @expansion{}    _[108]=10/79
spectrum_lib.tex(,172) @expansion{}    _[109]=4/31
spectrum_lib.tex(,173) @expansion{}    _[110]=4/29
spectrum_lib.tex(,174) @expansion{}    _[111]=11/79
spectrum_lib.tex(,175) @expansion{}    _[112]=9/58
spectrum_lib.tex(,176) @expansion{}    _[113]=5/31
spectrum_lib.tex(,177) @expansion{}    _[114]=13/79
spectrum_lib.tex(,178) @expansion{}    _[115]=5/29
spectrum_lib.tex(,179) @expansion{}    _[116]=14/79
spectrum_lib.tex(,180) @expansion{}    _[117]=11/58
spectrum_lib.tex(,181) @expansion{}    _[118]=15/79
spectrum_lib.tex(,182) @expansion{}    _[119]=6/31
spectrum_lib.tex(,183) @expansion{}    _[120]=16/79
spectrum_lib.tex(,184) @expansion{}    _[121]=6/29
spectrum_lib.tex(,185) @expansion{}    _[122]=13/58
spectrum_lib.tex(,186) @expansion{}    _[123]=7/31
spectrum_lib.tex(,187) @expansion{}    _[124]=18/79
spectrum_lib.tex(,188) @expansion{}    _[125]=19/79
spectrum_lib.tex(,189) @expansion{}    _[126]=7/29
spectrum_lib.tex(,190) @expansion{}    _[127]=20/79
spectrum_lib.tex(,191) @expansion{}    _[128]=8/31
spectrum_lib.tex(,192) @expansion{}    _[129]=15/58
spectrum_lib.tex(,193) @expansion{}    _[130]=21/79
spectrum_lib.tex(,194) @expansion{}    _[131]=8/29
spectrum_lib.tex(,195) @expansion{}    _[132]=9/31
spectrum_lib.tex(,196) @expansion{}    _[133]=23/79
spectrum_lib.tex(,197) @expansion{}    _[134]=17/58
spectrum_lib.tex(,198) @expansion{}    _[135]=9/29
spectrum_lib.tex(,199) @expansion{}    _[136]=25/79
spectrum_lib.tex(,200) @expansion{}    _[137]=10/31
spectrum_lib.tex(,201) @expansion{}    _[138]=19/58
spectrum_lib.tex(,202) @expansion{}    _[139]=26/79
spectrum_lib.tex(,203) @expansion{}    _[140]=10/29
spectrum_lib.tex(,204) @expansion{}    _[141]=28/79
spectrum_lib.tex(,205) @expansion{}    _[142]=11/31
spectrum_lib.tex(,206) @expansion{}    _[143]=21/58
spectrum_lib.tex(,207) @expansion{}    _[144]=30/79
spectrum_lib.tex(,208) @expansion{}    _[145]=12/31
spectrum_lib.tex(,209) @expansion{}    _[146]=31/79
spectrum_lib.tex(,210) @expansion{}    _[147]=23/58
spectrum_lib.tex(,211) @expansion{}    _[148]=12/29
spectrum_lib.tex(,212) @expansion{}    _[149]=33/79
spectrum_lib.tex(,213) @expansion{}    _[150]=13/31
spectrum_lib.tex(,214) @expansion{}    _[151]=25/58
spectrum_lib.tex(,215) @expansion{}    _[152]=35/79
spectrum_lib.tex(,216) @expansion{}    _[153]=14/31
spectrum_lib.tex(,217) @expansion{}    _[154]=27/58
spectrum_lib.tex(,218) @expansion{}    _[155]=38/79
spectrum_lib.tex(,219) @expansion{}    _[156]=14/29
spectrum_lib.tex(,220) @expansion{}    _[157]=15/31
spectrum_lib.tex(,221) @expansion{}    _[158]=1/2
spectrum_lib.tex(,222) @expansion{}    _[159]=40/79
spectrum_lib.tex(,223) @expansion{}    _[160]=42/79
spectrum_lib.tex(,224) @expansion{}    _[161]=43/79
spectrum_lib.tex(,225) @expansion{}    _[162]=16/29
spectrum_lib.tex(,226) @expansion{}    _[163]=33/58
spectrum_lib.tex(,227) @expansion{}    _[164]=45/79
spectrum_lib.tex(,228) @expansion{}    _[165]=47/79
spectrum_lib.tex(,229) @expansion{}    _[166]=18/29
spectrum_lib.tex(,230) @expansion{}    _[167]=50/79
spectrum_lib.tex(,231) @expansion{}    _[168]=37/58
spectrum_lib.tex(,232) @expansion{}    _[169]=52/79
spectrum_lib.tex(,233) @expansion{}    _[170]=55/79
spectrum_lib.tex(,234) @expansion{}    _[171]=41/58
spectrum_lib.tex(,235) @expansion{}    _[172]=57/79
spectrum_lib.tex(,236) @expansion{}    _[173]=45/58
spectrum_lib.tex(,237) @expansion{}    _[174]=62/79
spectrum_lib.tex(,238) @expansion{}    _[175]=67/79
spectrum_lib.tex(,239) @expansion{} [2]:
spectrum_lib.tex(,240) @expansion{}    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,\
spectrum_lib.tex(,241)    1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,2,1,1,1\
spectrum_lib.tex(,242)    ,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,4,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,\
spectrum_lib.tex(,243)    1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1\
spectrum_lib.tex(,244)    ,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
spectrum_lib.tex(,245) @c end example spectrumnd d2t_singular/spectrum_lib.doc:56
spectrum_lib.tex(,246) @end smallexample
spectrum_lib.tex(,247) @c ---end content spectrumnd---
singular.texi(,500) @c ----------------------------------------------------------------------------
singular.texi(,501) @node Invariant theory, Symbolic-numerical solving, Singularities, SINGULAR libraries
singular.texi(,502) @section Invariant theory
singular.texi(,503) @cindex Invariant theory
singular.texi(,504) 
singular.texi(,505) @menu
singular.texi(,506) * finvar_lib:: procedures to compute invariant rings of finite groups
singular.texi(,507) * ainvar_lib:: procedures to compute invariants rings of the additive group
singular.texi(,508) * rinvar_lib:: procedures to compute invariants ring of reductive groups
singular.texi(,509) * stratify_lib:: algorithmic stratification by the Greuel-Pfister algorithm
singular.texi(,510) @end menu
singular.texi(,511) 
singular.texi(,512) @c ----------------------------------------------------------
singular.texi(,513) @node finvar_lib, ainvar_lib, Invariant theory, Invariant theory
singular.texi(,514) @subsection finvar_lib
singular.texi(,515) @c include of docu for finvar.lib
finvar_lib.tex(,1) @c ---content LibInfo---
finvar_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/finvar_lib.doc
finvar_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/finvar_lib.doc INSTEAD
finvar_lib.tex(,4) @c library version: (1.32.2.2,2002/08/13)
finvar_lib.tex(,5) @c library file: ../Singular/LIB/finvar.lib
finvar_lib.tex(,6) @cindex finvar.lib
finvar_lib.tex(,7) @cindex finvar_lib
finvar_lib.tex(,8) @table @asis
finvar_lib.tex(,9) @item @strong{Library:}
finvar_lib.tex(,10) finvar.lib
finvar_lib.tex(,11) @item @strong{Purpose:}
finvar_lib.tex(,12)     Invariant Rings of Finite Groups
finvar_lib.tex(,13) @item @strong{Author:}
finvar_lib.tex(,14) Agnes E. Heydtmann, email: agnes@@math.uni-sb.de
finvar_lib.tex(,15) 
finvar_lib.tex(,16) @item @strong{Overview:}
finvar_lib.tex(,17) A library for computing polynomial invariants of finite matrix groups and
finvar_lib.tex(,18) generators of related varieties. The algorithms are based on B. Sturmfels,
finvar_lib.tex(,19) G. Kemper and W. Decker et al..
finvar_lib.tex(,20) 
finvar_lib.tex(,21) @end table
finvar_lib.tex(,22) 
finvar_lib.tex(,23) @strong{Main procedures:}
finvar_lib.tex(,24) @menu
finvar_lib.tex(,25) * invariant_ring:: generators of the invariant ring (i.r.)
finvar_lib.tex(,26) * invariant_ring_random:: generators of the i.r., randomized alg.
finvar_lib.tex(,27) * primary_invariants:: primary invariants (p.i.)
finvar_lib.tex(,28) * primary_invariants_random:: primary invariants, randomized alg.
finvar_lib.tex(,29) @end menu
finvar_lib.tex(,30) @strong{Auxiliary procedures:}
finvar_lib.tex(,31) @menu
finvar_lib.tex(,32) * cyclotomic:: cyclotomic polynomial
finvar_lib.tex(,33) * group_reynolds:: finite group and Reynolds operator (R.o.)
finvar_lib.tex(,34) * molien:: Molien series (M.s.)
finvar_lib.tex(,35) * reynolds_molien:: Reynolds operator and Molien series
finvar_lib.tex(,36) * partial_molien:: partial expansion of Molien series
finvar_lib.tex(,37) * evaluate_reynolds:: image under the Reynolds operator
finvar_lib.tex(,38) * invariant_basis:: basis of homogeneous invariants of a degree
finvar_lib.tex(,39) * invariant_basis_reynolds:: as invariant_basis(), with R.o.
finvar_lib.tex(,40) * primary_char0:: primary invariants in char 0
finvar_lib.tex(,41) * primary_charp:: primary invariant in char p
finvar_lib.tex(,42) * primary_char0_no_molien:: p.i., char 0, without Molien series
finvar_lib.tex(,43) * primary_charp_no_molien:: p.i., char p, without Molien series
finvar_lib.tex(,44) * primary_charp_without:: p.i., char p, without R.o. or Molien series
finvar_lib.tex(,45) * primary_char0_random:: primary invariants in char 0, randomized
finvar_lib.tex(,46) * primary_charp_random:: primary invariants in char p, randomized
finvar_lib.tex(,47) * primary_char0_no_molien_random:: p.i., char 0, without M.s., randomized
finvar_lib.tex(,48) * primary_charp_no_molien_random:: p.i., char p, without M.s., randomized
finvar_lib.tex(,49) * primary_charp_without_random:: p.i., char p, without R.o. or M.s., random.
finvar_lib.tex(,50) * power_products:: exponents for power products
finvar_lib.tex(,51) * secondary_char0:: secondary (s.i.) invariants in char 0
finvar_lib.tex(,52) * secondary_charp:: secondary invariants in char p
finvar_lib.tex(,53) * secondary_no_molien:: secondary invariants, without Molien series
finvar_lib.tex(,54) * secondary_and_irreducibles_no_molien:: s.i. & irreducible s.i., without M.s.
finvar_lib.tex(,55) * secondary_not_cohen_macaulay:: s.i. when invariant ring not Cohen-Macaulay
finvar_lib.tex(,56) * orbit_variety:: ideal of the orbit variety
finvar_lib.tex(,57) * relative_orbit_variety:: ideal of a relative orbit variety
finvar_lib.tex(,58) * image_of_variety:: ideal of the image of a variety
finvar_lib.tex(,59) @end menu
finvar_lib.tex(,60) @c ---end content LibInfo---
finvar_lib.tex(,61) 
finvar_lib.tex(,62) @c ------------------- invariant_ring -------------
finvar_lib.tex(,63) @node invariant_ring, invariant_ring_random,, finvar_lib
finvar_lib.tex(,64) @subsubsection invariant_ring
finvar_lib.tex(,65) @cindex invariant_ring
finvar_lib.tex(,66) @c ---content invariant_ring---
finvar_lib.tex(,67) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,68) 
finvar_lib.tex(,69) @table @asis
finvar_lib.tex(,70) @item @strong{Usage:}
finvar_lib.tex(,71) invariant_ring(G1,G2,...[,flags]);
finvar_lib.tex(,72) @*G1,G2,...: <matrices> generating a finite matrix group, flags: an
finvar_lib.tex(,73) optional <intvec> with three entries: if the first one equals 0, the
finvar_lib.tex(,74) program attempts to compute the Molien series and Reynolds operator,
finvar_lib.tex(,75) if it equals 1, the program is told that the Molien series should not
finvar_lib.tex(,76) be computed, if it equals -1 characteristic 0 is simulated, i.e. the
finvar_lib.tex(,77) Molien series is computed as if the base field were characteristic 0
finvar_lib.tex(,78) (the user must choose a field of large prime characteristic, e.g.
finvar_lib.tex(,79) 32003) and if the first one is anything else, it means that the
finvar_lib.tex(,80) characteristic of the base field divides the group order (i.e. it will
finvar_lib.tex(,81) not even be attempted to compute the Reynolds operator or Molien
finvar_lib.tex(,82) series), the second component should give the size of intervals
finvar_lib.tex(,83) between canceling common factors in the expansion of Molien series, 0
finvar_lib.tex(,84) (the default) means only once after generating all terms, in prime
finvar_lib.tex(,85) characteristic also a negative number can be given to indicate that
finvar_lib.tex(,86) common factors should always be canceled when the expansion is simple
finvar_lib.tex(,87) (the root of the extension field occurs not among the coefficients)
finvar_lib.tex(,88) 
finvar_lib.tex(,89) @item @strong{Return:}
finvar_lib.tex(,90) primary and secondary invariants (both of type <matrix>) generating
finvar_lib.tex(,91) the invariant ring with respect to the matrix group generated by the
finvar_lib.tex(,92) matrices in the input and irreducible secondary invariants (type
finvar_lib.tex(,93) <matrix>) if the Molien series was available
finvar_lib.tex(,94) 
finvar_lib.tex(,95) @item @strong{Display:}
finvar_lib.tex(,96) information about the various stages of the program if the third flag
finvar_lib.tex(,97) does not equal 0
finvar_lib.tex(,98) 
finvar_lib.tex(,99) @item @strong{Theory:}
finvar_lib.tex(,100) Bases of homogeneous invariants are generated successively and those
finvar_lib.tex(,101) are chosen as primary invariants that lower the dimension of the ideal
finvar_lib.tex(,102) generated by the previously found invariants (see "Generating a
finvar_lib.tex(,103) Noetherian Normalization of the Invariant Ring of a Finite Group" by
finvar_lib.tex(,104) Decker, Heydtmann, Schreyer (1998)). In the
finvar_lib.tex(,105) @*non-modular case secondary invariants are calculated by finding a
finvar_lib.tex(,106) basis (in terms of monomials) of the basering modulo the primary
finvar_lib.tex(,107) invariants, mapping to invariants with the Reynolds operator and using
finvar_lib.tex(,108) those or their power products such that they are linearly independent
finvar_lib.tex(,109) modulo the primary invariants (see "Some Algorithms in Invariant
finvar_lib.tex(,110) Theory of Finite Groups" by Kemper and Steel (1997)). In the modular
finvar_lib.tex(,111) case they are generated according to "Generating Invariant Rings of
finvar_lib.tex(,112) Finite Groups over Arbitrary Fields" by Kemper (1996).
finvar_lib.tex(,113) 
finvar_lib.tex(,114) @end table
finvar_lib.tex(,115) @strong{Example:}
finvar_lib.tex(,116) @smallexample
finvar_lib.tex(,117) @c computed example invariant_ring d2t_singular/finvar_lib.doc:115 
finvar_lib.tex(,118) LIB "finvar.lib";
finvar_lib.tex(,119) ring R=0,(x,y,z),dp;
finvar_lib.tex(,120) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,121) matrix P,S,IS=invariant_ring(A);
finvar_lib.tex(,122) print(P);
finvar_lib.tex(,123) @expansion{} z2,x2+y2,x2y2
finvar_lib.tex(,124) print(S);
finvar_lib.tex(,125) @expansion{} 1,xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,126) print(IS);
finvar_lib.tex(,127) @expansion{} xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,128) @c end example invariant_ring d2t_singular/finvar_lib.doc:115
finvar_lib.tex(,129) @end smallexample
finvar_lib.tex(,130) @c ---end content invariant_ring---
finvar_lib.tex(,131) 
finvar_lib.tex(,132) @c ------------------- invariant_ring_random -------------
finvar_lib.tex(,133) @node invariant_ring_random, primary_invariants, invariant_ring, finvar_lib
finvar_lib.tex(,134) @subsubsection invariant_ring_random
finvar_lib.tex(,135) @cindex invariant_ring_random
finvar_lib.tex(,136) @c ---content invariant_ring_random---
finvar_lib.tex(,137) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,138) 
finvar_lib.tex(,139) @table @asis
finvar_lib.tex(,140) @item @strong{Usage:}
finvar_lib.tex(,141) invariant_ring_random(G1,G2,...,r[,flags]);
finvar_lib.tex(,142) @*G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
finvar_lib.tex(,143) where -|r| to |r| is the range of coefficients of random
finvar_lib.tex(,144) combinations of bases elements that serve as primary invariants,
finvar_lib.tex(,145) flags: an optional <intvec> with three entries: if the first equals 0,
finvar_lib.tex(,146) the program attempts to compute the Molien series and Reynolds
finvar_lib.tex(,147) operator, if it equals 1, the program is told that the Molien series
finvar_lib.tex(,148) should not be computed, if it equals -1 characteristic 0 is simulated,
finvar_lib.tex(,149) i.e. the Molien series is computed as if the base field were
finvar_lib.tex(,150) characteristic 0 (the user must choose a field of large prime
finvar_lib.tex(,151) characteristic, e.g. 32003) and if the first one is anything else,
finvar_lib.tex(,152) then the characteristic of the base field divides the group order
finvar_lib.tex(,153) (i.e. we will not even attempt to compute the Reynolds operator or
finvar_lib.tex(,154) Molien series), the second component should give the size of intervals
finvar_lib.tex(,155) between canceling common factors in the expansion of the Molien
finvar_lib.tex(,156) series, 0 (the default) means only once after generating all terms,
finvar_lib.tex(,157) in prime characteristic also a negative number can be given to
finvar_lib.tex(,158) indicate that common factors should always be canceled when the
finvar_lib.tex(,159) expansion is simple (the root of the extension field does not occur
finvar_lib.tex(,160) among the coefficients)
finvar_lib.tex(,161) 
finvar_lib.tex(,162) @item @strong{Return:}
finvar_lib.tex(,163) primary and secondary invariants (both of type <matrix>) generating
finvar_lib.tex(,164) invariant ring with respect to the matrix group generated by the
finvar_lib.tex(,165) matrices in the input and irreducible secondary invariants (type
finvar_lib.tex(,166) <matrix>) if the Molien series was available
finvar_lib.tex(,167) 
finvar_lib.tex(,168) @item @strong{Display:}
finvar_lib.tex(,169) information about the various stages of the program if the third flag
finvar_lib.tex(,170) does not equal 0
finvar_lib.tex(,171) 
finvar_lib.tex(,172) @item @strong{Theory:}
finvar_lib.tex(,173) is the same as for invariant_ring except that random combinations of
finvar_lib.tex(,174) basis elements are chosen as candidates for primary invariants and
finvar_lib.tex(,175) hopefully they lower the dimension of the previously found primary
finvar_lib.tex(,176) invariants by the right amount.
finvar_lib.tex(,177) 
finvar_lib.tex(,178) @end table
finvar_lib.tex(,179) @strong{Example:}
finvar_lib.tex(,180) @smallexample
finvar_lib.tex(,181) @c computed example invariant_ring_random d2t_singular/finvar_lib.doc:176 
finvar_lib.tex(,182) LIB "finvar.lib";
finvar_lib.tex(,183) ring R=0,(x,y,z),dp;
finvar_lib.tex(,184) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,185) matrix P,S,IS=invariant_ring_random(A,1);
finvar_lib.tex(,186) print(P);
finvar_lib.tex(,187) @expansion{} z2,x2+y2,x4+y4-z4
finvar_lib.tex(,188) print(S);
finvar_lib.tex(,189) @expansion{} 1,xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,190) print(IS);
finvar_lib.tex(,191) @expansion{} xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,192) @c end example invariant_ring_random d2t_singular/finvar_lib.doc:176
finvar_lib.tex(,193) @end smallexample
finvar_lib.tex(,194) @c ---end content invariant_ring_random---
finvar_lib.tex(,195) 
finvar_lib.tex(,196) @c ------------------- primary_invariants -------------
finvar_lib.tex(,197) @node primary_invariants, primary_invariants_random, invariant_ring_random, finvar_lib
finvar_lib.tex(,198) @subsubsection primary_invariants
finvar_lib.tex(,199) @cindex primary_invariants
finvar_lib.tex(,200) @c ---content primary_invariants---
finvar_lib.tex(,201) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,202) 
finvar_lib.tex(,203) @table @asis
finvar_lib.tex(,204) @item @strong{Usage:}
finvar_lib.tex(,205) primary_invariants(G1,G2,...[,flags]);
finvar_lib.tex(,206) @*G1,G2,...: <matrices> generating a finite matrix group, flags: an
finvar_lib.tex(,207) optional <intvec> with three entries, if the first one equals 0 (also
finvar_lib.tex(,208) the default), the program attempts to compute the Molien series and
finvar_lib.tex(,209) Reynolds operator, if it equals 1, the program is told that the
finvar_lib.tex(,210) Molien series should not be computed, if it equals -1 characteristic 0
finvar_lib.tex(,211) is simulated, i.e. the Molien series is computed as if the base field
finvar_lib.tex(,212) were characteristic 0 (the user must choose a field of large prime
finvar_lib.tex(,213) characteristic, e.g. 32003) and if the first one is anything else, it
finvar_lib.tex(,214) means that the characteristic of the base field divides the group
finvar_lib.tex(,215) order, the second component should give the size of intervals between
finvar_lib.tex(,216) canceling common factors in the expansion of the Molien series, 0 (the
finvar_lib.tex(,217) default) means only once after generating all terms, in prime
finvar_lib.tex(,218) characteristic also a negative number can be given to indicate that
finvar_lib.tex(,219) common factors should always be canceled when the expansion is simple
finvar_lib.tex(,220) (the root of the extension field occurs not among the coefficients)
finvar_lib.tex(,221) 
finvar_lib.tex(,222) @item @strong{Display:}
finvar_lib.tex(,223) information about the various stages of the program if the third
finvar_lib.tex(,224) flag does not equal 0
finvar_lib.tex(,225) 
finvar_lib.tex(,226) @item @strong{Return:}
finvar_lib.tex(,227) primary invariants (type <matrix>) of the invariant ring and if
finvar_lib.tex(,228) computable Reynolds operator (type <matrix>) and Molien series (type
finvar_lib.tex(,229) <matrix>) or ring name (type string) where the Molien series
finvar_lib.tex(,230) can be found in the char p case; if the first flag is 1 and we are in
finvar_lib.tex(,231) the non-modular case then an <intvec> is returned giving some of the
finvar_lib.tex(,232) degrees where no non-trivial homogeneous invariants can be found
finvar_lib.tex(,233) 
finvar_lib.tex(,234) @item @strong{Theory:}
finvar_lib.tex(,235) Bases of homogeneous invariants are generated successively and those
finvar_lib.tex(,236) are chosen as primary invariants that lower the dimension of the ideal
finvar_lib.tex(,237) generated by the previously found invariants (see paper "Generating a
finvar_lib.tex(,238) Noetherian Normalization of the Invariant Ring of a Finite Group" by
finvar_lib.tex(,239) Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,240) 
finvar_lib.tex(,241) @end table
finvar_lib.tex(,242) @strong{Example:}
finvar_lib.tex(,243) @smallexample
finvar_lib.tex(,244) @c computed example primary_invariants d2t_singular/finvar_lib.doc:236 
finvar_lib.tex(,245) LIB "finvar.lib";
finvar_lib.tex(,246) ring R=0,(x,y,z),dp;
finvar_lib.tex(,247) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,248) list L=primary_invariants(A);
finvar_lib.tex(,249) print(L[1]);
finvar_lib.tex(,250) @expansion{} z2,x2+y2,x2y2
finvar_lib.tex(,251) @c end example primary_invariants d2t_singular/finvar_lib.doc:236
finvar_lib.tex(,252) @end smallexample
finvar_lib.tex(,253) @c ---end content primary_invariants---
finvar_lib.tex(,254) 
finvar_lib.tex(,255) @c ------------------- primary_invariants_random -------------
finvar_lib.tex(,256) @node primary_invariants_random, cyclotomic, primary_invariants, finvar_lib
finvar_lib.tex(,257) @subsubsection primary_invariants_random
finvar_lib.tex(,258) @cindex primary_invariants_random
finvar_lib.tex(,259) @c ---content primary_invariants_random---
finvar_lib.tex(,260) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,261) 
finvar_lib.tex(,262) @table @asis
finvar_lib.tex(,263) @item @strong{Usage:}
finvar_lib.tex(,264) primary_invariants_random(G1,G2,...,r[,flags]);
finvar_lib.tex(,265) @*G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
finvar_lib.tex(,266) where -|r| to |r| is the range of coefficients of the random
finvar_lib.tex(,267) combinations of bases elements, flags: an optional <intvec> with three
finvar_lib.tex(,268) entries, if the first one equals 0 (also the default), the program
finvar_lib.tex(,269) attempts to compute the Molien series and Reynolds operator, if it
finvar_lib.tex(,270) equals 1, the program is told that the Molien series should not be
finvar_lib.tex(,271) computed, if it equals -1 characteristic 0 is simulated, i.e. the
finvar_lib.tex(,272) Molien series is computed as if the base field were characteristic 0
finvar_lib.tex(,273) (the user must choose a field of large prime characteristic, e.g.
finvar_lib.tex(,274) 32003) and if the first one is anything else, it means that the
finvar_lib.tex(,275) characteristic of the base field divides the group order, the second
finvar_lib.tex(,276) component should give the size of intervals between canceling common
finvar_lib.tex(,277) factors in the expansion of the Molien series, 0 (the default) means
finvar_lib.tex(,278) only once after generating all terms, in prime characteristic also a
finvar_lib.tex(,279) negative number can be given to indicate that common factors should
finvar_lib.tex(,280) always be canceled when the expansion is simple (the root of the
finvar_lib.tex(,281) extension field does not occur among the coefficients)
finvar_lib.tex(,282) 
finvar_lib.tex(,283) @item @strong{Display:}
finvar_lib.tex(,284) information about the various stages of the program if the third
finvar_lib.tex(,285) flag does not equal 0
finvar_lib.tex(,286) 
finvar_lib.tex(,287) @item @strong{Return:}
finvar_lib.tex(,288) primary invariants (type <matrix>) of the invariant ring and if
finvar_lib.tex(,289) computable Reynolds operator (type <matrix>) and Molien series (type
finvar_lib.tex(,290) <matrix>), if the first flag is 1 and we are in the non-modular case
finvar_lib.tex(,291) then an <intvec> is returned giving some of the degrees where no
finvar_lib.tex(,292) non-trivial homogeneous invariants can be found
finvar_lib.tex(,293) 
finvar_lib.tex(,294) @item @strong{Theory:}
finvar_lib.tex(,295) Bases of homogeneous invariants are generated successively and random
finvar_lib.tex(,296) linear combinations are chosen as primary invariants that lower the
finvar_lib.tex(,297) dimension of the ideal generated by the previously found invariants
finvar_lib.tex(,298) (see "Generating a Noetherian Normalization of the Invariant Ring of
finvar_lib.tex(,299) a Finite Group" by Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,300) 
finvar_lib.tex(,301) @end table
finvar_lib.tex(,302) @strong{Example:}
finvar_lib.tex(,303) @smallexample
finvar_lib.tex(,304) @c computed example primary_invariants_random d2t_singular/finvar_lib.doc:295 
finvar_lib.tex(,305) LIB "finvar.lib";
finvar_lib.tex(,306) ring R=0,(x,y,z),dp;
finvar_lib.tex(,307) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,308) list L=primary_invariants_random(A,1);
finvar_lib.tex(,309) print(L[1]);
finvar_lib.tex(,310) @expansion{} z2,x2+y2,x4+y4-z4
finvar_lib.tex(,311) @c end example primary_invariants_random d2t_singular/finvar_lib.doc:295
finvar_lib.tex(,312) @end smallexample
finvar_lib.tex(,313) @c ---end content primary_invariants_random---
finvar_lib.tex(,314) 
finvar_lib.tex(,315) @c ------------------- cyclotomic -------------
finvar_lib.tex(,316) @node cyclotomic, group_reynolds, primary_invariants_random, finvar_lib
finvar_lib.tex(,317) @subsubsection cyclotomic
finvar_lib.tex(,318) @cindex cyclotomic
finvar_lib.tex(,319) @c ---content cyclotomic---
finvar_lib.tex(,320) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,321) 
finvar_lib.tex(,322) @table @asis
finvar_lib.tex(,323) @item @strong{Usage:}
finvar_lib.tex(,324) cyclotomic(i); i integer > 0
finvar_lib.tex(,325) 
finvar_lib.tex(,326) @item @strong{Returns:}
finvar_lib.tex(,327) the i-th cyclotomic polynomial (type <poly>) as one in the first ring
finvar_lib.tex(,328) variable
finvar_lib.tex(,329) 
finvar_lib.tex(,330) @item @strong{Theory:}
finvar_lib.tex(,331) x^i-1 is divided by the j-th cyclotomic polynomial where j takes on
finvar_lib.tex(,332) the value of proper divisors of i
finvar_lib.tex(,333) 
finvar_lib.tex(,334) @end table
finvar_lib.tex(,335) @strong{Example:}
finvar_lib.tex(,336) @smallexample
finvar_lib.tex(,337) @c computed example cyclotomic d2t_singular/finvar_lib.doc:327 
finvar_lib.tex(,338) LIB "finvar.lib";
finvar_lib.tex(,339) ring R=0,(x,y,z),dp;
finvar_lib.tex(,340) print(cyclotomic(25));
finvar_lib.tex(,341) @expansion{} x20+x15+x10+x5+1
finvar_lib.tex(,342) @c end example cyclotomic d2t_singular/finvar_lib.doc:327
finvar_lib.tex(,343) @end smallexample
finvar_lib.tex(,344) @c ---end content cyclotomic---
finvar_lib.tex(,345) 
finvar_lib.tex(,346) @c ------------------- group_reynolds -------------
finvar_lib.tex(,347) @node group_reynolds, molien, cyclotomic, finvar_lib
finvar_lib.tex(,348) @subsubsection group_reynolds
finvar_lib.tex(,349) @cindex group_reynolds
finvar_lib.tex(,350) @c ---content group_reynolds---
finvar_lib.tex(,351) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,352) 
finvar_lib.tex(,353) @table @asis
finvar_lib.tex(,354) @item @strong{Usage:}
finvar_lib.tex(,355) group_reynolds(G1,G2,...[,v]);
finvar_lib.tex(,356) @*G1,G2,...: nxn <matrices> generating a finite matrix group, v: an
finvar_lib.tex(,357) optional <int>
finvar_lib.tex(,358) 
finvar_lib.tex(,359) @item @strong{Assume:}
finvar_lib.tex(,360) n is the number of variables of the basering, g the number of group
finvar_lib.tex(,361) elements
finvar_lib.tex(,362) 
finvar_lib.tex(,363) @item @strong{Return:}
finvar_lib.tex(,364) a <list>, the first list element will be a gxn <matrix> representing
finvar_lib.tex(,365) the Reynolds operator if we are in the non-modular case; if the
finvar_lib.tex(,366) characteristic is >0, minpoly==0 and the finite group non-cyclic the
finvar_lib.tex(,367) second list element is an <int> giving the lowest common multiple of
finvar_lib.tex(,368) the matrix group elements' order (used in molien); in general all
finvar_lib.tex(,369) other list elements are nxn <matrices> listing all elements of the
finvar_lib.tex(,370) finite group
finvar_lib.tex(,371) 
finvar_lib.tex(,372) @item @strong{Display:}
finvar_lib.tex(,373) information if v does not equal 0
finvar_lib.tex(,374) 
finvar_lib.tex(,375) @item @strong{Theory:}
finvar_lib.tex(,376) The entire matrix group is generated by getting all left products of
finvar_lib.tex(,377) generators with the new elements from the last run through the loop
finvar_lib.tex(,378) (or the generators themselves during the first run). All the ones that
finvar_lib.tex(,379) have been generated before are thrown out and the program terminates
finvar_lib.tex(,380) when no new elements found in one run. Additionally each time a new
finvar_lib.tex(,381) group element is found the corresponding ring mapping of which the
finvar_lib.tex(,382) Reynolds operator is made up is generated. They are stored in the rows
finvar_lib.tex(,383) of the first return value.
finvar_lib.tex(,384) 
finvar_lib.tex(,385) @end table
finvar_lib.tex(,386) @strong{Example:}
finvar_lib.tex(,387) @smallexample
finvar_lib.tex(,388) @c computed example group_reynolds d2t_singular/finvar_lib.doc:377 
finvar_lib.tex(,389) LIB "finvar.lib";
finvar_lib.tex(,390) ring R=0,(x,y,z),dp;
finvar_lib.tex(,391) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,392) list L=group_reynolds(A);
finvar_lib.tex(,393) print(L[1]);
finvar_lib.tex(,394) @expansion{} y, -x,-z,
finvar_lib.tex(,395) @expansion{} -x,-y,z, 
finvar_lib.tex(,396) @expansion{} -y,x, -z,
finvar_lib.tex(,397) @expansion{} x, y, z  
finvar_lib.tex(,398) print(L[2..size(L)]);
finvar_lib.tex(,399) @expansion{} 0, 1,0,
finvar_lib.tex(,400) @expansion{} -1,0,0,
finvar_lib.tex(,401) @expansion{} 0, 0,-1
finvar_lib.tex(,402) @expansion{} -1,0, 0,
finvar_lib.tex(,403) @expansion{} 0, -1,0,
finvar_lib.tex(,404) @expansion{} 0, 0, 1 
finvar_lib.tex(,405) @expansion{} 0,-1,0,
finvar_lib.tex(,406) @expansion{} 1,0, 0,
finvar_lib.tex(,407) @expansion{} 0,0, -1
finvar_lib.tex(,408) @expansion{} 1,0,0,
finvar_lib.tex(,409) @expansion{} 0,1,0,
finvar_lib.tex(,410) @expansion{} 0,0,1 
finvar_lib.tex(,411) @c end example group_reynolds d2t_singular/finvar_lib.doc:377
finvar_lib.tex(,412) @end smallexample
finvar_lib.tex(,413) @c ---end content group_reynolds---
finvar_lib.tex(,414) 
finvar_lib.tex(,415) @c ------------------- molien -------------
finvar_lib.tex(,416) @node molien, reynolds_molien, group_reynolds, finvar_lib
finvar_lib.tex(,417) @subsubsection molien
finvar_lib.tex(,418) @cindex molien
finvar_lib.tex(,419) @c ---content molien---
finvar_lib.tex(,420) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,421) 
finvar_lib.tex(,422) @table @asis
finvar_lib.tex(,423) @item @strong{Usage:}
finvar_lib.tex(,424) molien(G1,G2,...[,ringname,lcm,flags]);
finvar_lib.tex(,425) @*G1,G2,...: nxn <matrices>, all elements of a finite matrix group,
finvar_lib.tex(,426) ringname: a <string> giving a name for a new ring of characteristic 0
finvar_lib.tex(,427) for the Molien series in case of prime characteristic, lcm: an <int>
finvar_lib.tex(,428) giving the lowest common multiple of the elements' orders in case of
finvar_lib.tex(,429) prime characteristic, minpoly==0 and a non-cyclic group, flags: an
finvar_lib.tex(,430) optional <intvec> with three components: if the first element is not
finvar_lib.tex(,431) equal to 0 characteristic 0 is simulated, i.e. the Molien series is
finvar_lib.tex(,432) computed as if the base field were characteristic 0 (the user must
finvar_lib.tex(,433) choose a field of large prime characteristic, e.g. 32003), the second
finvar_lib.tex(,434) component should give the size of intervals between canceling common
finvar_lib.tex(,435) factors in the expansion of the Molien series, 0 (the default) means
finvar_lib.tex(,436) only once after generating all terms, in prime characteristic also a
finvar_lib.tex(,437) negative number can be given to indicate that common factors should
finvar_lib.tex(,438) always be canceled when the expansion is simple (the root of the
finvar_lib.tex(,439) extension field does not occur among the coefficients)
finvar_lib.tex(,440) 
finvar_lib.tex(,441) @item @strong{Assume:}
finvar_lib.tex(,442) n is the number of variables of the basering, G1,G2... are the group
finvar_lib.tex(,443) elements generated by group_reynolds(), lcm is the second return value
finvar_lib.tex(,444) of group_reynolds()
finvar_lib.tex(,445) 
finvar_lib.tex(,446) @item @strong{Return:}
finvar_lib.tex(,447) in case of characteristic 0 a 1x2 <matrix> giving enumerator and
finvar_lib.tex(,448) denominator of Molien series; in case of prime characteristic a ring
finvar_lib.tex(,449) with the name `ringname` of characteristic 0 is created where the same
finvar_lib.tex(,450) Molien series (named M) is stored
finvar_lib.tex(,451) 
finvar_lib.tex(,452) @item @strong{Display:}
finvar_lib.tex(,453) information if the third component of flags does not equal 0
finvar_lib.tex(,454) 
finvar_lib.tex(,455) @item @strong{Theory:}
finvar_lib.tex(,456) In characteristic 0 the terms 1/det(1-xE) for all group elements of
finvar_lib.tex(,457) the Molien series are computed in a straight forward way. In prime
finvar_lib.tex(,458) characteristic a Brauer lift is involved. The returned matrix gives
finvar_lib.tex(,459) enumerator and denominator of the expanded version where common
finvar_lib.tex(,460) factors have been canceled.
finvar_lib.tex(,461) 
finvar_lib.tex(,462) @end table
finvar_lib.tex(,463) @strong{Example:}
finvar_lib.tex(,464) @smallexample
finvar_lib.tex(,465) @c computed example molien d2t_singular/finvar_lib.doc:438 
finvar_lib.tex(,466) LIB "finvar.lib";
finvar_lib.tex(,467) "         note the case of prime characteristic"; 
finvar_lib.tex(,468) @expansion{}          note the case of prime characteristic
finvar_lib.tex(,469) ring R=0,(x,y,z),dp;
finvar_lib.tex(,470) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,471) list L=group_reynolds(A);
finvar_lib.tex(,472) matrix M=molien(L[2..size(L)]);
finvar_lib.tex(,473) print(M);
finvar_lib.tex(,474) @expansion{} x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
finvar_lib.tex(,475) ring S=3,(x,y,z),dp;
finvar_lib.tex(,476) string newring="alksdfjlaskdjf";
finvar_lib.tex(,477) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,478) list L=group_reynolds(A);
finvar_lib.tex(,479) molien(L[2..size(L)],newring);
finvar_lib.tex(,480) setring alksdfjlaskdjf;
finvar_lib.tex(,481) print(M);
finvar_lib.tex(,482) @expansion{} x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
finvar_lib.tex(,483) setring S;
finvar_lib.tex(,484) kill alksdfjlaskdjf;
finvar_lib.tex(,485) @c end example molien d2t_singular/finvar_lib.doc:438
finvar_lib.tex(,486) @end smallexample
finvar_lib.tex(,487) @c ---end content molien---
finvar_lib.tex(,488) 
finvar_lib.tex(,489) @c ------------------- reynolds_molien -------------
finvar_lib.tex(,490) @node reynolds_molien, partial_molien, molien, finvar_lib
finvar_lib.tex(,491) @subsubsection reynolds_molien
finvar_lib.tex(,492) @cindex reynolds_molien
finvar_lib.tex(,493) @c ---content reynolds_molien---
finvar_lib.tex(,494) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,495) 
finvar_lib.tex(,496) @table @asis
finvar_lib.tex(,497) @item @strong{Usage:}
finvar_lib.tex(,498) reynolds_molien(G1,G2,...[,ringname,flags]);
finvar_lib.tex(,499) @*G1,G2,...: nxn <matrices> generating a finite matrix group, ringname:
finvar_lib.tex(,500) a <string> giving a name for a new ring of characteristic 0 for the
finvar_lib.tex(,501) Molien series in case of prime characteristic, flags: an optional
finvar_lib.tex(,502) <intvec> with three components: if the first element is not equal to 0
finvar_lib.tex(,503) characteristic 0 is simulated, i.e. the Molien series is computed as
finvar_lib.tex(,504) if the base field were characteristic 0 (the user must choose a field
finvar_lib.tex(,505) of large prime characteristic, e.g. 32003) the second component should
finvar_lib.tex(,506) give the size of intervals between canceling common factors in the
finvar_lib.tex(,507) expansion of the Molien series, 0 (the default) means only once after
finvar_lib.tex(,508) generating all terms, in prime characteristic also a negative number
finvar_lib.tex(,509) can be given to indicate that common factors should always be canceled
finvar_lib.tex(,510) when the expansion is simple (the root of the extension field does not
finvar_lib.tex(,511) occur among the coefficients)
finvar_lib.tex(,512) 
finvar_lib.tex(,513) @item @strong{Assume:}
finvar_lib.tex(,514) n is the number of variables of the basering, G1,G2... are the group
finvar_lib.tex(,515) elements generated by group_reynolds(), g is the size of the group
finvar_lib.tex(,516) 
finvar_lib.tex(,517) @item @strong{Return:}
finvar_lib.tex(,518) a gxn <matrix> representing the Reynolds operator is the first return
finvar_lib.tex(,519) value and in case of characteristic 0 a 1x2 <matrix> giving enumerator
finvar_lib.tex(,520) and denominator of Molien series is the second one; in case of prime
finvar_lib.tex(,521) characteristic a ring with the name `ringname` of characteristic 0 is
finvar_lib.tex(,522) created where the same Molien series (named M) is stored
finvar_lib.tex(,523) 
finvar_lib.tex(,524) @item @strong{Display:}
finvar_lib.tex(,525) information if the third component of flags does not equal 0
finvar_lib.tex(,526) 
finvar_lib.tex(,527) @item @strong{Theory:}
finvar_lib.tex(,528) The entire matrix group is generated by getting all left products of
finvar_lib.tex(,529) the generators with new elements from the last run through the loop
finvar_lib.tex(,530) (or the generators themselves during the first run). All the ones that
finvar_lib.tex(,531) have been generated before are thrown out and the program terminates
finvar_lib.tex(,532) when are no new elements found in one run. Additionally each time a
finvar_lib.tex(,533) new group element is found the corresponding ring mapping of which the
finvar_lib.tex(,534) Reynolds operator is made up is generated. They are stored in the rows
finvar_lib.tex(,535) of the first return value. In characteristic 0 the terms 1/det(1-xE)
finvar_lib.tex(,536) is computed whenever a new element E is found. In prime characteristic
finvar_lib.tex(,537) a Brauer lift is involved and the terms are only computed after the
finvar_lib.tex(,538) entire matrix group is generated (to avoid the modular case). The
finvar_lib.tex(,539) returned matrix gives enumerator and denominator of the expanded
finvar_lib.tex(,540) version where common factors have been canceled.
finvar_lib.tex(,541) 
finvar_lib.tex(,542) @end table
finvar_lib.tex(,543) @strong{Example:}
finvar_lib.tex(,544) @smallexample
finvar_lib.tex(,545) @c computed example reynolds_molien d2t_singular/finvar_lib.doc:515 
finvar_lib.tex(,546) LIB "finvar.lib";
finvar_lib.tex(,547) "         note the case of prime characteristic"; 
finvar_lib.tex(,548) @expansion{}          note the case of prime characteristic
finvar_lib.tex(,549) ring R=0,(x,y,z),dp;
finvar_lib.tex(,550) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,551) matrix REY,M=reynolds_molien(A);
finvar_lib.tex(,552) print(REY);
finvar_lib.tex(,553) @expansion{} y, -x,-z,
finvar_lib.tex(,554) @expansion{} -x,-y,z, 
finvar_lib.tex(,555) @expansion{} -y,x, -z,
finvar_lib.tex(,556) @expansion{} x, y, z  
finvar_lib.tex(,557) print(M);
finvar_lib.tex(,558) @expansion{} x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
finvar_lib.tex(,559) ring S=3,(x,y,z),dp;
finvar_lib.tex(,560) string newring="Qadjoint";
finvar_lib.tex(,561) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,562) matrix REY=reynolds_molien(A,newring);
finvar_lib.tex(,563) print(REY);
finvar_lib.tex(,564) @expansion{} y, -x,-z,
finvar_lib.tex(,565) @expansion{} -x,-y,z, 
finvar_lib.tex(,566) @expansion{} -y,x, -z,
finvar_lib.tex(,567) @expansion{} x, y, z  
finvar_lib.tex(,568) setring Qadjoint;
finvar_lib.tex(,569) print(M);
finvar_lib.tex(,570) @expansion{} x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
finvar_lib.tex(,571) setring S;
finvar_lib.tex(,572) kill Qadjoint;
finvar_lib.tex(,573) @c end example reynolds_molien d2t_singular/finvar_lib.doc:515
finvar_lib.tex(,574) @end smallexample
finvar_lib.tex(,575) @c ---end content reynolds_molien---
finvar_lib.tex(,576) 
finvar_lib.tex(,577) @c ------------------- partial_molien -------------
finvar_lib.tex(,578) @node partial_molien, evaluate_reynolds, reynolds_molien, finvar_lib
finvar_lib.tex(,579) @subsubsection partial_molien
finvar_lib.tex(,580) @cindex partial_molien
finvar_lib.tex(,581) @c ---content partial_molien---
finvar_lib.tex(,582) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,583) 
finvar_lib.tex(,584) @table @asis
finvar_lib.tex(,585) @item @strong{Usage:}
finvar_lib.tex(,586) partial_molien(M,n[,p]);
finvar_lib.tex(,587) @*M: a 1x2 <matrix>, n: an <int> indicating number of terms in the
finvar_lib.tex(,588) expansion, p: an optional <poly>
finvar_lib.tex(,589) 
finvar_lib.tex(,590) @item @strong{Assume:}
finvar_lib.tex(,591) M is the return value of molien or the second return value of
finvar_lib.tex(,592) reynolds_molien, p ought to be the second return value of a previous
finvar_lib.tex(,593) run of partial_molien and avoids recalculating known terms
finvar_lib.tex(,594) 
finvar_lib.tex(,595) @item @strong{Return:}
finvar_lib.tex(,596) n terms (type <poly>) of the partial expansion of the Molien series
finvar_lib.tex(,597) (first n if there is no third parameter given, otherwise the next n
finvar_lib.tex(,598) terms depending on a previous calculation) and an intermediate result
finvar_lib.tex(,599) (type <poly>) of the calculation to be used as third parameter in a
finvar_lib.tex(,600) next run of partial_molien
finvar_lib.tex(,601) 
finvar_lib.tex(,602) @item @strong{Theory:}
finvar_lib.tex(,603) The following calculation is implemented:
finvar_lib.tex(,604) @format
finvar_lib.tex(,605) (1+a1x+a2x^2+...+anx^n)/(1+b1x+b2x^2+...+bmx^m)=(1+(a1-b1)x+...
finvar_lib.tex(,606) (1+b1x+b2x^2+...+bmx^m)
finvar_lib.tex(,607) -----------------------
finvar_lib.tex(,608)    (a1-b1)x+(a2-b2)x^2+...
finvar_lib.tex(,609)    (a1-b1)x+b1(a1-b1)x^2+...
finvar_lib.tex(,610) @end format
finvar_lib.tex(,611) 
finvar_lib.tex(,612) @end table
finvar_lib.tex(,613) @strong{Example:}
finvar_lib.tex(,614) @smallexample
finvar_lib.tex(,615) @c computed example partial_molien d2t_singular/finvar_lib.doc:574 
finvar_lib.tex(,616) LIB "finvar.lib";
finvar_lib.tex(,617) ring R=0,(x,y,z),dp;
finvar_lib.tex(,618) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,619) matrix REY,M=reynolds_molien(A);
finvar_lib.tex(,620) poly p(1..2);
finvar_lib.tex(,621) p(1..2)=partial_molien(M,5);
finvar_lib.tex(,622) p(1);
finvar_lib.tex(,623) @expansion{} 4x5+5x4+2x3+2x2+1
finvar_lib.tex(,624) p(1..2)=partial_molien(M,5,p(2));
finvar_lib.tex(,625) p(1);
finvar_lib.tex(,626) @expansion{} 18x10+12x9+13x8+8x7+8x6
finvar_lib.tex(,627) @c end example partial_molien d2t_singular/finvar_lib.doc:574
finvar_lib.tex(,628) @end smallexample
finvar_lib.tex(,629) @c ---end content partial_molien---
finvar_lib.tex(,630) 
finvar_lib.tex(,631) @c ------------------- evaluate_reynolds -------------
finvar_lib.tex(,632) @node evaluate_reynolds, invariant_basis, partial_molien, finvar_lib
finvar_lib.tex(,633) @subsubsection evaluate_reynolds
finvar_lib.tex(,634) @cindex evaluate_reynolds
finvar_lib.tex(,635) @c ---content evaluate_reynolds---
finvar_lib.tex(,636) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,637) 
finvar_lib.tex(,638) @table @asis
finvar_lib.tex(,639) @item @strong{Usage:}
finvar_lib.tex(,640) evaluate_reynolds(REY,I);
finvar_lib.tex(,641) @*REY: a <matrix> representing the Reynolds operator, I: an arbitrary
finvar_lib.tex(,642) <ideal>
finvar_lib.tex(,643) 
finvar_lib.tex(,644) @item @strong{Assume:}
finvar_lib.tex(,645) REY is the first return value of group_reynolds() or reynolds_molien()
finvar_lib.tex(,646) 
finvar_lib.tex(,647) @item @strong{Returns:}
finvar_lib.tex(,648) image of the polynomials defining I under the Reynolds operator
finvar_lib.tex(,649) (type <ideal>)
finvar_lib.tex(,650) 
finvar_lib.tex(,651) @item @strong{Note:}
finvar_lib.tex(,652) the characteristic of the coefficient field of the polynomial ring
finvar_lib.tex(,653) should not divide the order of the finite matrix group
finvar_lib.tex(,654) 
finvar_lib.tex(,655) @item @strong{Theory:}
finvar_lib.tex(,656) REY has been constructed in such a way that each row serves as a ring
finvar_lib.tex(,657) mapping of which the Reynolds operator is made up.
finvar_lib.tex(,658) 
finvar_lib.tex(,659) @end table
finvar_lib.tex(,660) @strong{Example:}
finvar_lib.tex(,661) @smallexample
finvar_lib.tex(,662) @c computed example evaluate_reynolds d2t_singular/finvar_lib.doc:619 
finvar_lib.tex(,663) LIB "finvar.lib";
finvar_lib.tex(,664) ring R=0,(x,y,z),dp;
finvar_lib.tex(,665) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,666) list L=group_reynolds(A);
finvar_lib.tex(,667) ideal I=x2,y2,z2;
finvar_lib.tex(,668) print(evaluate_reynolds(L[1],I));
finvar_lib.tex(,669) @expansion{} 1/2x2+1/2y2,
finvar_lib.tex(,670) @expansion{} 1/2x2+1/2y2,
finvar_lib.tex(,671) @expansion{} z2
finvar_lib.tex(,672) @c end example evaluate_reynolds d2t_singular/finvar_lib.doc:619
finvar_lib.tex(,673) @end smallexample
finvar_lib.tex(,674) @c ---end content evaluate_reynolds---
finvar_lib.tex(,675) 
finvar_lib.tex(,676) @c ------------------- invariant_basis -------------
finvar_lib.tex(,677) @node invariant_basis, invariant_basis_reynolds, evaluate_reynolds, finvar_lib
finvar_lib.tex(,678) @subsubsection invariant_basis
finvar_lib.tex(,679) @cindex invariant_basis
finvar_lib.tex(,680) @c ---content invariant_basis---
finvar_lib.tex(,681) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,682) 
finvar_lib.tex(,683) @table @asis
finvar_lib.tex(,684) @item @strong{Usage:}
finvar_lib.tex(,685) invariant_basis(g,G1,G2,...);
finvar_lib.tex(,686) @*g: an <int> indicating of which degree (>0) the homogeneous basis
finvar_lib.tex(,687) should be, G1,G2,...: <matrices> generating a finite matrix group
finvar_lib.tex(,688) 
finvar_lib.tex(,689) @item @strong{Returns:}
finvar_lib.tex(,690) the basis (type <ideal>) of the space of invariants of degree g
finvar_lib.tex(,691) 
finvar_lib.tex(,692) @item @strong{Theory:}
finvar_lib.tex(,693) A general polynomial of degree g is generated and the generators of
finvar_lib.tex(,694) the matrix group applied. The difference ought to be 0 and this way a
finvar_lib.tex(,695) system of linear equations is created. It is solved by computing
finvar_lib.tex(,696) syzygies.
finvar_lib.tex(,697) 
finvar_lib.tex(,698) @end table
finvar_lib.tex(,699) @strong{Example:}
finvar_lib.tex(,700) @smallexample
finvar_lib.tex(,701) @c computed example invariant_basis d2t_singular/finvar_lib.doc:655 
finvar_lib.tex(,702) LIB "finvar.lib";
finvar_lib.tex(,703) ring R=0,(x,y,z),dp;
finvar_lib.tex(,704) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,705) print(invariant_basis(2,A));
finvar_lib.tex(,706) @expansion{} x2+y2,
finvar_lib.tex(,707) @expansion{} z2
finvar_lib.tex(,708) @c end example invariant_basis d2t_singular/finvar_lib.doc:655
finvar_lib.tex(,709) @end smallexample
finvar_lib.tex(,710) @c ---end content invariant_basis---
finvar_lib.tex(,711) 
finvar_lib.tex(,712) @c ------------------- invariant_basis_reynolds -------------
finvar_lib.tex(,713) @node invariant_basis_reynolds, primary_char0, invariant_basis, finvar_lib
finvar_lib.tex(,714) @subsubsection invariant_basis_reynolds
finvar_lib.tex(,715) @cindex invariant_basis_reynolds
finvar_lib.tex(,716) @c ---content invariant_basis_reynolds---
finvar_lib.tex(,717) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,718) 
finvar_lib.tex(,719) @table @asis
finvar_lib.tex(,720) @item @strong{Usage:}
finvar_lib.tex(,721) invariant_basis_reynolds(REY,d[,flags]);
finvar_lib.tex(,722) @*REY: a <matrix> representing the Reynolds operator, d: an <int>
finvar_lib.tex(,723) indicating of which degree (>0) the homogeneous basis should be, flags:
finvar_lib.tex(,724) an optional <intvec> with two entries: its first component gives the
finvar_lib.tex(,725) dimension of the space (default <0 meaning unknown) and its second
finvar_lib.tex(,726) component is used as the number of polynomials that should be mapped
finvar_lib.tex(,727) to invariants during one call of evaluate_reynolds if the dimension of
finvar_lib.tex(,728) the space is unknown or the number such that number x dimension
finvar_lib.tex(,729) polynomials are mapped to invariants during one call of
finvar_lib.tex(,730) evaluate_reynolds
finvar_lib.tex(,731) 
finvar_lib.tex(,732) @item @strong{Assume:}
finvar_lib.tex(,733) REY is the first return value of group_reynolds() or reynolds_molien()
finvar_lib.tex(,734) and flags[1] given by partial_molien
finvar_lib.tex(,735) 
finvar_lib.tex(,736) @item @strong{Return:}
finvar_lib.tex(,737) the basis (type <ideal>) of the space of invariants of degree d
finvar_lib.tex(,738) 
finvar_lib.tex(,739) @item @strong{Theory:}
finvar_lib.tex(,740) Monomials of degree d are mapped to invariants with the Reynolds
finvar_lib.tex(,741) operator. A linearly independent set is generated with the help of
finvar_lib.tex(,742) minbase.
finvar_lib.tex(,743) 
finvar_lib.tex(,744) @end table
finvar_lib.tex(,745) @strong{Example:}
finvar_lib.tex(,746) @smallexample
finvar_lib.tex(,747) @c computed example invariant_basis_reynolds d2t_singular/finvar_lib.doc:699 
finvar_lib.tex(,748) LIB "finvar.lib";
finvar_lib.tex(,749) ring R=0,(x,y,z),dp;
finvar_lib.tex(,750) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,751) intvec flags=0,1,0;
finvar_lib.tex(,752) matrix REY,M=reynolds_molien(A,flags);
finvar_lib.tex(,753) flags=8,6;
finvar_lib.tex(,754) print(invariant_basis_reynolds(REY,6,flags));
finvar_lib.tex(,755) @expansion{} z6,
finvar_lib.tex(,756) @expansion{} x2z4+y2z4,
finvar_lib.tex(,757) @expansion{} x2y2z2,
finvar_lib.tex(,758) @expansion{} x3yz2-xy3z2,
finvar_lib.tex(,759) @expansion{} x4z2+y4z2,
finvar_lib.tex(,760) @expansion{} x4y2+x2y4,
finvar_lib.tex(,761) @expansion{} x5y-xy5,
finvar_lib.tex(,762) @expansion{} x6+y6
finvar_lib.tex(,763) @c end example invariant_basis_reynolds d2t_singular/finvar_lib.doc:699
finvar_lib.tex(,764) @end smallexample
finvar_lib.tex(,765) @c ---end content invariant_basis_reynolds---
finvar_lib.tex(,766) 
finvar_lib.tex(,767) @c ------------------- primary_char0 -------------
finvar_lib.tex(,768) @node primary_char0, primary_charp, invariant_basis_reynolds, finvar_lib
finvar_lib.tex(,769) @subsubsection primary_char0
finvar_lib.tex(,770) @cindex primary_char0
finvar_lib.tex(,771) @c ---content primary_char0---
finvar_lib.tex(,772) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,773) 
finvar_lib.tex(,774) @table @asis
finvar_lib.tex(,775) @item @strong{Usage:}
finvar_lib.tex(,776) primary_char0(REY,M[,v]);
finvar_lib.tex(,777) @*REY: a <matrix> representing the Reynolds operator, M: a 1x2 <matrix>
finvar_lib.tex(,778) representing the Molien series, v: an optional <int>
finvar_lib.tex(,779) 
finvar_lib.tex(,780) @item @strong{Assume:}
finvar_lib.tex(,781) REY is the first return value of group_reynolds or reynolds_molien and
finvar_lib.tex(,782) M the one of molien or the second one of reynolds_molien
finvar_lib.tex(,783) 
finvar_lib.tex(,784) @item @strong{Display:}
finvar_lib.tex(,785) information about the various stages of the program if v does not
finvar_lib.tex(,786) equal 0
finvar_lib.tex(,787) 
finvar_lib.tex(,788) @item @strong{Return:}
finvar_lib.tex(,789) primary invariants (type <matrix>) of the invariant ring
finvar_lib.tex(,790) 
finvar_lib.tex(,791) @item @strong{Theory:}
finvar_lib.tex(,792) Bases of homogeneous invariants are generated successively and those
finvar_lib.tex(,793) are chosen as primary invariants that lower the dimension of the ideal
finvar_lib.tex(,794) generated by the previously found invariants (see paper "Generating a
finvar_lib.tex(,795) Noetherian Normalization of the Invariant Ring of a Finite Group" by
finvar_lib.tex(,796) Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,797) 
finvar_lib.tex(,798) @end table
finvar_lib.tex(,799) @strong{Example:}
finvar_lib.tex(,800) @smallexample
finvar_lib.tex(,801) @c computed example primary_char0 d2t_singular/finvar_lib.doc:745 
finvar_lib.tex(,802) LIB "finvar.lib";
finvar_lib.tex(,803) ring R=0,(x,y,z),dp;
finvar_lib.tex(,804) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,805) matrix REY,M=reynolds_molien(A);
finvar_lib.tex(,806) matrix P=primary_char0(REY,M);
finvar_lib.tex(,807) print(P);
finvar_lib.tex(,808) @expansion{} z2,x2+y2,x2y2
finvar_lib.tex(,809) @c end example primary_char0 d2t_singular/finvar_lib.doc:745
finvar_lib.tex(,810) @end smallexample
finvar_lib.tex(,811) @c ---end content primary_char0---
finvar_lib.tex(,812) 
finvar_lib.tex(,813) @c ------------------- primary_charp -------------
finvar_lib.tex(,814) @node primary_charp, primary_char0_no_molien, primary_char0, finvar_lib
finvar_lib.tex(,815) @subsubsection primary_charp
finvar_lib.tex(,816) @cindex primary_charp
finvar_lib.tex(,817) @c ---content primary_charp---
finvar_lib.tex(,818) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,819) 
finvar_lib.tex(,820) @table @asis
finvar_lib.tex(,821) @item @strong{Usage:}
finvar_lib.tex(,822) primary_charp(REY,ringname[,v]);
finvar_lib.tex(,823) @*REY: a <matrix> representing the Reynolds operator, ringname: a
finvar_lib.tex(,824) <string> giving the name of a ring where the Molien series is stored,
finvar_lib.tex(,825) v: an optional <int>
finvar_lib.tex(,826) 
finvar_lib.tex(,827) @item @strong{Assume:}
finvar_lib.tex(,828) REY is the first return value of group_reynolds or reynolds_molien and
finvar_lib.tex(,829) ringname gives the name of a ring of characteristic 0 that has been
finvar_lib.tex(,830) created by molien or reynolds_molien
finvar_lib.tex(,831) 
finvar_lib.tex(,832) @item @strong{Display:}
finvar_lib.tex(,833) information about the various stages of the program if v does not
finvar_lib.tex(,834) equal 0
finvar_lib.tex(,835) 
finvar_lib.tex(,836) @item @strong{Return:}
finvar_lib.tex(,837) primary invariants (type <matrix>) of the invariant ring
finvar_lib.tex(,838) 
finvar_lib.tex(,839) @item @strong{Theory:}
finvar_lib.tex(,840) Bases of homogeneous invariants are generated successively and those
finvar_lib.tex(,841) are chosen as primary invariants that lower the dimension of the ideal
finvar_lib.tex(,842) generated by the previously found invariants (see paper "Generating a
finvar_lib.tex(,843) Noetherian Normalization of the Invariant Ring of a Finite Group" by
finvar_lib.tex(,844) Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,845) 
finvar_lib.tex(,846) @end table
finvar_lib.tex(,847) @strong{Example:}
finvar_lib.tex(,848) @smallexample
finvar_lib.tex(,849) @c computed example primary_charp d2t_singular/finvar_lib.doc:792 
finvar_lib.tex(,850) LIB "finvar.lib";
finvar_lib.tex(,851) ring R=3,(x,y,z),dp;
finvar_lib.tex(,852) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,853) list L=group_reynolds(A);
finvar_lib.tex(,854) string newring="alskdfj";
finvar_lib.tex(,855) molien(L[2..size(L)],newring);
finvar_lib.tex(,856) matrix P=primary_charp(L[1],newring);
finvar_lib.tex(,857) if(system("with","Namespaces")) @{ kill Top::`newring`; @}
finvar_lib.tex(,858) kill `newring`;
finvar_lib.tex(,859) print(P);
finvar_lib.tex(,860) @expansion{} z2,x2+y2,x2y2
finvar_lib.tex(,861) @c end example primary_charp d2t_singular/finvar_lib.doc:792
finvar_lib.tex(,862) @end smallexample
finvar_lib.tex(,863) @c ---end content primary_charp---
finvar_lib.tex(,864) 
finvar_lib.tex(,865) @c ------------------- primary_char0_no_molien -------------
finvar_lib.tex(,866) @node primary_char0_no_molien, primary_charp_no_molien, primary_charp, finvar_lib
finvar_lib.tex(,867) @subsubsection primary_char0_no_molien
finvar_lib.tex(,868) @cindex primary_char0_no_molien
finvar_lib.tex(,869) @c ---content primary_char0_no_molien---
finvar_lib.tex(,870) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,871) 
finvar_lib.tex(,872) @table @asis
finvar_lib.tex(,873) @item @strong{Usage:}
finvar_lib.tex(,874) primary_char0_no_molien(REY[,v]);
finvar_lib.tex(,875) @*REY: a <matrix> representing the Reynolds operator, v: an optional
finvar_lib.tex(,876) <int>
finvar_lib.tex(,877) 
finvar_lib.tex(,878) @item @strong{Assume:}
finvar_lib.tex(,879) REY is the first return value of group_reynolds or reynolds_molien
finvar_lib.tex(,880) 
finvar_lib.tex(,881) @item @strong{Display:}
finvar_lib.tex(,882) information about the various stages of the program if v does not
finvar_lib.tex(,883) equal 0
finvar_lib.tex(,884) 
finvar_lib.tex(,885) @item @strong{Return:}
finvar_lib.tex(,886) primary invariants (type <matrix>) of the invariant ring and an
finvar_lib.tex(,887) <intvec> listing some of the degrees where no non-trivial homogeneous
finvar_lib.tex(,888) invariants are to be found
finvar_lib.tex(,889) 
finvar_lib.tex(,890) @item @strong{Theory:}
finvar_lib.tex(,891) Bases of homogeneous invariants are generated successively and those
finvar_lib.tex(,892) are chosen as primary invariants that lower the dimension of the ideal
finvar_lib.tex(,893) generated by the previously found invariants (see paper "Generating a
finvar_lib.tex(,894) Noetherian Normalization of the Invariant Ring of a Finite Group" by
finvar_lib.tex(,895) Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,896) 
finvar_lib.tex(,897) @end table
finvar_lib.tex(,898) @strong{Example:}
finvar_lib.tex(,899) @smallexample
finvar_lib.tex(,900) @c computed example primary_char0_no_molien d2t_singular/finvar_lib.doc:842 
finvar_lib.tex(,901) LIB "finvar.lib";
finvar_lib.tex(,902) ring R=0,(x,y,z),dp;
finvar_lib.tex(,903) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,904) list L=group_reynolds(A);
finvar_lib.tex(,905) list l=primary_char0_no_molien(L[1]);
finvar_lib.tex(,906) print(l[1]);
finvar_lib.tex(,907) @expansion{} z2,x2+y2,x2y2
finvar_lib.tex(,908) @c end example primary_char0_no_molien d2t_singular/finvar_lib.doc:842
finvar_lib.tex(,909) @end smallexample
finvar_lib.tex(,910) @c ---end content primary_char0_no_molien---
finvar_lib.tex(,911) 
finvar_lib.tex(,912) @c ------------------- primary_charp_no_molien -------------
finvar_lib.tex(,913) @node primary_charp_no_molien, primary_charp_without, primary_char0_no_molien, finvar_lib
finvar_lib.tex(,914) @subsubsection primary_charp_no_molien
finvar_lib.tex(,915) @cindex primary_charp_no_molien
finvar_lib.tex(,916) @c ---content primary_charp_no_molien---
finvar_lib.tex(,917) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,918) 
finvar_lib.tex(,919) @table @asis
finvar_lib.tex(,920) @item @strong{Usage:}
finvar_lib.tex(,921) primary_charp_no_molien(REY[,v]);
finvar_lib.tex(,922) @*REY: a <matrix> representing the Reynolds operator, v: an optional
finvar_lib.tex(,923) <int>
finvar_lib.tex(,924) 
finvar_lib.tex(,925) @item @strong{Assume:}
finvar_lib.tex(,926) REY is the first return value of group_reynolds or reynolds_molien
finvar_lib.tex(,927) 
finvar_lib.tex(,928) @item @strong{Display:}
finvar_lib.tex(,929) information about the various stages of the program if v does not
finvar_lib.tex(,930) equal 0
finvar_lib.tex(,931) 
finvar_lib.tex(,932) @item @strong{Return:}
finvar_lib.tex(,933) primary invariants (type <matrix>) of the invariant ring and an
finvar_lib.tex(,934) <intvec> listing some of the degrees where no non-trivial homogeneous
finvar_lib.tex(,935) invariants are to be found
finvar_lib.tex(,936) 
finvar_lib.tex(,937) @item @strong{Theory:}
finvar_lib.tex(,938) Bases of homogeneous invariants are generated successively and those
finvar_lib.tex(,939) are chosen as primary invariants that lower the dimension of the ideal
finvar_lib.tex(,940) generated by the previously found invariants (see paper "Generating a
finvar_lib.tex(,941) Noetherian Normalization of the Invariant Ring of a Finite Group" by
finvar_lib.tex(,942) Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,943) 
finvar_lib.tex(,944) @end table
finvar_lib.tex(,945) @strong{Example:}
finvar_lib.tex(,946) @smallexample
finvar_lib.tex(,947) @c computed example primary_charp_no_molien d2t_singular/finvar_lib.doc:888 
finvar_lib.tex(,948) LIB "finvar.lib";
finvar_lib.tex(,949) ring R=3,(x,y,z),dp;
finvar_lib.tex(,950) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,951) list L=group_reynolds(A);
finvar_lib.tex(,952) list l=primary_charp_no_molien(L[1]);
finvar_lib.tex(,953) print(l[1]);
finvar_lib.tex(,954) @expansion{} z2,x2+y2,x2y2
finvar_lib.tex(,955) @c end example primary_charp_no_molien d2t_singular/finvar_lib.doc:888
finvar_lib.tex(,956) @end smallexample
finvar_lib.tex(,957) @c ---end content primary_charp_no_molien---
finvar_lib.tex(,958) 
finvar_lib.tex(,959) @c ------------------- primary_charp_without -------------
finvar_lib.tex(,960) @node primary_charp_without, primary_char0_random, primary_charp_no_molien, finvar_lib
finvar_lib.tex(,961) @subsubsection primary_charp_without
finvar_lib.tex(,962) @cindex primary_charp_without
finvar_lib.tex(,963) @c ---content primary_charp_without---
finvar_lib.tex(,964) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,965) 
finvar_lib.tex(,966) @table @asis
finvar_lib.tex(,967) @item @strong{Usage:}
finvar_lib.tex(,968) primary_charp_without(G1,G2,...[,v]);
finvar_lib.tex(,969) @*G1,G2,...: <matrices> generating a finite matrix group, v: an optional
finvar_lib.tex(,970) <int>
finvar_lib.tex(,971) 
finvar_lib.tex(,972) @item @strong{Display:}
finvar_lib.tex(,973) information about the various stages of the program if v does not
finvar_lib.tex(,974) equal 0
finvar_lib.tex(,975) 
finvar_lib.tex(,976) @item @strong{Return:}
finvar_lib.tex(,977) primary invariants (type <matrix>) of the invariant ring
finvar_lib.tex(,978) 
finvar_lib.tex(,979) @item @strong{Theory:}
finvar_lib.tex(,980) Bases of homogeneous invariants are generated successively and those
finvar_lib.tex(,981) are chosen as primary invariants that lower the dimension of the ideal
finvar_lib.tex(,982) generated by the previously found invariants (see paper "Generating a
finvar_lib.tex(,983) Noetherian Normalization of the Invariant Ring of a Finite Group" by
finvar_lib.tex(,984) Decker, Heydtmann, Schreyer (1998)). No Reynolds
finvar_lib.tex(,985) @*operator or Molien series is used.
finvar_lib.tex(,986) 
finvar_lib.tex(,987) @end table
finvar_lib.tex(,988) @strong{Example:}
finvar_lib.tex(,989) @smallexample
finvar_lib.tex(,990) @c computed example primary_charp_without d2t_singular/finvar_lib.doc:930 
finvar_lib.tex(,991) LIB "finvar.lib";
finvar_lib.tex(,992) ring R=2,(x,y,z),dp;
finvar_lib.tex(,993) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,994) matrix P=primary_charp_without(A);
finvar_lib.tex(,995) print(P);
finvar_lib.tex(,996) @expansion{} x+y,z,xy
finvar_lib.tex(,997) @c end example primary_charp_without d2t_singular/finvar_lib.doc:930
finvar_lib.tex(,998) @end smallexample
finvar_lib.tex(,999) @c ---end content primary_charp_without---
finvar_lib.tex(,1000) 
finvar_lib.tex(,1001) @c ------------------- primary_char0_random -------------
finvar_lib.tex(,1002) @node primary_char0_random, primary_charp_random, primary_charp_without, finvar_lib
finvar_lib.tex(,1003) @subsubsection primary_char0_random
finvar_lib.tex(,1004) @cindex primary_char0_random
finvar_lib.tex(,1005) @c ---content primary_char0_random---
finvar_lib.tex(,1006) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1007) 
finvar_lib.tex(,1008) @table @asis
finvar_lib.tex(,1009) @item @strong{Usage:}
finvar_lib.tex(,1010) primary_char0_random(REY,M,r[,v]);
finvar_lib.tex(,1011) @*REY: a <matrix> representing the Reynolds operator, M: a 1x2 <matrix>
finvar_lib.tex(,1012) representing the Molien series, r: an <int> where -|r| to |r| is the
finvar_lib.tex(,1013) range of coefficients of the random combinations of bases elements,
finvar_lib.tex(,1014) v: an optional <int>
finvar_lib.tex(,1015) 
finvar_lib.tex(,1016) @item @strong{Assume:}
finvar_lib.tex(,1017) REY is the first return value of group_reynolds or reynolds_molien and
finvar_lib.tex(,1018) M the one of molien or the second one of reynolds_molien
finvar_lib.tex(,1019) 
finvar_lib.tex(,1020) @item @strong{Display:}
finvar_lib.tex(,1021) information about the various stages of the program if v does not
finvar_lib.tex(,1022) equal 0
finvar_lib.tex(,1023) 
finvar_lib.tex(,1024) @item @strong{Return:}
finvar_lib.tex(,1025) primary invariants (type <matrix>) of the invariant ring
finvar_lib.tex(,1026) 
finvar_lib.tex(,1027) @item @strong{Theory:}
finvar_lib.tex(,1028) Bases of homogeneous invariants are generated successively and random
finvar_lib.tex(,1029) linear combinations are chosen as primary invariants that lower the
finvar_lib.tex(,1030) dimension of the ideal generated by the previously found invariants
finvar_lib.tex(,1031) (see "Generating a Noetherian Normalization of the Invariant Ring of
finvar_lib.tex(,1032) a Finite Group" by Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,1033) 
finvar_lib.tex(,1034) @end table
finvar_lib.tex(,1035) @strong{Example:}
finvar_lib.tex(,1036) @smallexample
finvar_lib.tex(,1037) @c computed example primary_char0_random d2t_singular/finvar_lib.doc:976 
finvar_lib.tex(,1038) LIB "finvar.lib";
finvar_lib.tex(,1039) ring R=0,(x,y,z),dp;
finvar_lib.tex(,1040) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1041) matrix REY,M=reynolds_molien(A);
finvar_lib.tex(,1042) matrix P=primary_char0_random(REY,M,1);
finvar_lib.tex(,1043) print(P);
finvar_lib.tex(,1044) @expansion{} z2,x2+y2,x4+y4-z4
finvar_lib.tex(,1045) @c end example primary_char0_random d2t_singular/finvar_lib.doc:976
finvar_lib.tex(,1046) @end smallexample
finvar_lib.tex(,1047) @c ---end content primary_char0_random---
finvar_lib.tex(,1048) 
finvar_lib.tex(,1049) @c ------------------- primary_charp_random -------------
finvar_lib.tex(,1050) @node primary_charp_random, primary_char0_no_molien_random, primary_char0_random, finvar_lib
finvar_lib.tex(,1051) @subsubsection primary_charp_random
finvar_lib.tex(,1052) @cindex primary_charp_random
finvar_lib.tex(,1053) @c ---content primary_charp_random---
finvar_lib.tex(,1054) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1055) 
finvar_lib.tex(,1056) @table @asis
finvar_lib.tex(,1057) @item @strong{Usage:}
finvar_lib.tex(,1058) primary_charp_random(REY,ringname,r[,v]);
finvar_lib.tex(,1059) @*REY: a <matrix> representing the Reynolds operator, ringname: a
finvar_lib.tex(,1060) <string> giving the name of a ring where the Molien series is stored,
finvar_lib.tex(,1061) r: an <int> where -|r| to |r| is the range of coefficients of the
finvar_lib.tex(,1062) random combinations of bases elements, v: an optional <int>
finvar_lib.tex(,1063) 
finvar_lib.tex(,1064) @item @strong{Assume:}
finvar_lib.tex(,1065) REY is the first return value of group_reynolds or reynolds_molien and
finvar_lib.tex(,1066) ringname gives the name of a ring of characteristic 0 that has been
finvar_lib.tex(,1067) created by molien or reynolds_molien
finvar_lib.tex(,1068) 
finvar_lib.tex(,1069) @item @strong{Display:}
finvar_lib.tex(,1070) information about the various stages of the program if v does not
finvar_lib.tex(,1071) equal 0
finvar_lib.tex(,1072) 
finvar_lib.tex(,1073) @item @strong{Return:}
finvar_lib.tex(,1074) primary invariants (type <matrix>) of the invariant ring
finvar_lib.tex(,1075) 
finvar_lib.tex(,1076) @item @strong{Theory:}
finvar_lib.tex(,1077) Bases of homogeneous invariants are generated successively and random
finvar_lib.tex(,1078) linear combinations are chosen as primary invariants that lower the
finvar_lib.tex(,1079) dimension of the ideal generated by the previously found invariants
finvar_lib.tex(,1080) (see "Generating a Noetherian Normalization of the Invariant Ring of
finvar_lib.tex(,1081) a Finite Group" by Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,1082) 
finvar_lib.tex(,1083) @end table
finvar_lib.tex(,1084) @strong{Example:}
finvar_lib.tex(,1085) @smallexample
finvar_lib.tex(,1086) @c computed example primary_charp_random d2t_singular/finvar_lib.doc:1024 
finvar_lib.tex(,1087) LIB "finvar.lib";
finvar_lib.tex(,1088) ring R=3,(x,y,z),dp;
finvar_lib.tex(,1089) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1090) list L=group_reynolds(A);
finvar_lib.tex(,1091) string newring="alskdfj";
finvar_lib.tex(,1092) molien(L[2..size(L)],newring);
finvar_lib.tex(,1093) matrix P=primary_charp_random(L[1],newring,1);
finvar_lib.tex(,1094) if(system("with","Namespaces")) @{ kill Top::`newring`; @}
finvar_lib.tex(,1095) kill `newring`;
finvar_lib.tex(,1096) print(P);
finvar_lib.tex(,1097) @expansion{} z2,x2+y2,x4+y4-z4
finvar_lib.tex(,1098) @c end example primary_charp_random d2t_singular/finvar_lib.doc:1024
finvar_lib.tex(,1099) @end smallexample
finvar_lib.tex(,1100) @c ---end content primary_charp_random---
finvar_lib.tex(,1101) 
finvar_lib.tex(,1102) @c ------------------- primary_char0_no_molien_random -------------
finvar_lib.tex(,1103) @node primary_char0_no_molien_random, primary_charp_no_molien_random, primary_charp_random, finvar_lib
finvar_lib.tex(,1104) @subsubsection primary_char0_no_molien_random
finvar_lib.tex(,1105) @cindex primary_char0_no_molien_random
finvar_lib.tex(,1106) @c ---content primary_char0_no_molien_random---
finvar_lib.tex(,1107) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1108) 
finvar_lib.tex(,1109) @table @asis
finvar_lib.tex(,1110) @item @strong{Usage:}
finvar_lib.tex(,1111) primary_char0_no_molien_random(REY,r[,v]);
finvar_lib.tex(,1112) @*REY: a <matrix> representing the Reynolds operator, r: an <int> where
finvar_lib.tex(,1113) -|r| to |r| is the range of coefficients of the random combinations of
finvar_lib.tex(,1114) bases elements, v: an optional <int>
finvar_lib.tex(,1115) 
finvar_lib.tex(,1116) @item @strong{Assume:}
finvar_lib.tex(,1117) REY is the first return value of group_reynolds or reynolds_molien
finvar_lib.tex(,1118) 
finvar_lib.tex(,1119) @item @strong{Display:}
finvar_lib.tex(,1120) information about the various stages of the program if v does not
finvar_lib.tex(,1121) equal 0
finvar_lib.tex(,1122) 
finvar_lib.tex(,1123) @item @strong{Return:}
finvar_lib.tex(,1124) primary invariants (type <matrix>) of the invariant ring and an
finvar_lib.tex(,1125) <intvec> listing some of the degrees where no non-trivial homogeneous
finvar_lib.tex(,1126) invariants are to be found
finvar_lib.tex(,1127) 
finvar_lib.tex(,1128) @item @strong{Theory:}
finvar_lib.tex(,1129) Bases of homogeneous invariants are generated successively and random
finvar_lib.tex(,1130) linear combinations are chosen as primary invariants that lower the
finvar_lib.tex(,1131) dimension of the ideal generated by the previously found invariants
finvar_lib.tex(,1132) (see "Generating a Noetherian Normalization of the Invariant Ring of
finvar_lib.tex(,1133) a Finite Group" by Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,1134) 
finvar_lib.tex(,1135) @end table
finvar_lib.tex(,1136) @strong{Example:}
finvar_lib.tex(,1137) @smallexample
finvar_lib.tex(,1138) @c computed example primary_char0_no_molien_random d2t_singular/finvar_lib.doc:1075 
finvar_lib.tex(,1139) LIB "finvar.lib";
finvar_lib.tex(,1140) ring R=0,(x,y,z),dp;
finvar_lib.tex(,1141) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1142) list L=group_reynolds(A);
finvar_lib.tex(,1143) list l=primary_char0_no_molien_random(L[1],1);
finvar_lib.tex(,1144) print(l[1]);
finvar_lib.tex(,1145) @expansion{} z2,x2+y2,x4+y4-z4
finvar_lib.tex(,1146) @c end example primary_char0_no_molien_random d2t_singular/finvar_lib.doc:1075
finvar_lib.tex(,1147) @end smallexample
finvar_lib.tex(,1148) @c ---end content primary_char0_no_molien_random---
finvar_lib.tex(,1149) 
finvar_lib.tex(,1150) @c ------------------- primary_charp_no_molien_random -------------
finvar_lib.tex(,1151) @node primary_charp_no_molien_random, primary_charp_without_random, primary_char0_no_molien_random, finvar_lib
finvar_lib.tex(,1152) @subsubsection primary_charp_no_molien_random
finvar_lib.tex(,1153) @cindex primary_charp_no_molien_random
finvar_lib.tex(,1154) @c ---content primary_charp_no_molien_random---
finvar_lib.tex(,1155) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1156) 
finvar_lib.tex(,1157) @table @asis
finvar_lib.tex(,1158) @item @strong{Usage:}
finvar_lib.tex(,1159) primary_charp_no_molien_random(REY,r[,v]);
finvar_lib.tex(,1160) @*REY: a <matrix> representing the Reynolds operator, r: an <int> where
finvar_lib.tex(,1161) -|r| to |r| is the range of coefficients of the random combinations of
finvar_lib.tex(,1162) bases elements, v: an optional <int>
finvar_lib.tex(,1163) 
finvar_lib.tex(,1164) @item @strong{Assume:}
finvar_lib.tex(,1165) REY is the first return value of group_reynolds or reynolds_molien
finvar_lib.tex(,1166) 
finvar_lib.tex(,1167) @item @strong{Display:}
finvar_lib.tex(,1168) information about the various stages of the program if v does not
finvar_lib.tex(,1169) equal 0
finvar_lib.tex(,1170) 
finvar_lib.tex(,1171) @item @strong{Return:}
finvar_lib.tex(,1172) primary invariants (type <matrix>) of the invariant ring and an
finvar_lib.tex(,1173) <intvec> listing some of the degrees where no non-trivial homogeneous
finvar_lib.tex(,1174) invariants are to be found
finvar_lib.tex(,1175) 
finvar_lib.tex(,1176) @item @strong{Theory:}
finvar_lib.tex(,1177) Bases of homogeneous invariants are generated successively and random
finvar_lib.tex(,1178) linear combinations are chosen as primary invariants that lower the
finvar_lib.tex(,1179) dimension of the ideal generated by the previously found invariants
finvar_lib.tex(,1180) (see "Generating a Noetherian Normalization of the Invariant Ring of
finvar_lib.tex(,1181) a Finite Group" by Decker, Heydtmann, Schreyer (1998)).
finvar_lib.tex(,1182) 
finvar_lib.tex(,1183) @end table
finvar_lib.tex(,1184) @strong{Example:}
finvar_lib.tex(,1185) @smallexample
finvar_lib.tex(,1186) @c computed example primary_charp_no_molien_random d2t_singular/finvar_lib.doc:1122 
finvar_lib.tex(,1187) LIB "finvar.lib";
finvar_lib.tex(,1188) ring R=3,(x,y,z),dp;
finvar_lib.tex(,1189) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1190) list L=group_reynolds(A);
finvar_lib.tex(,1191) list l=primary_charp_no_molien_random(L[1],1);
finvar_lib.tex(,1192) print(l[1]);
finvar_lib.tex(,1193) @expansion{} z2,x2+y2,x4+y4-z4
finvar_lib.tex(,1194) @c end example primary_charp_no_molien_random d2t_singular/finvar_lib.doc:1122
finvar_lib.tex(,1195) @end smallexample
finvar_lib.tex(,1196) @c ---end content primary_charp_no_molien_random---
finvar_lib.tex(,1197) 
finvar_lib.tex(,1198) @c ------------------- primary_charp_without_random -------------
finvar_lib.tex(,1199) @node primary_charp_without_random, power_products, primary_charp_no_molien_random, finvar_lib
finvar_lib.tex(,1200) @subsubsection primary_charp_without_random
finvar_lib.tex(,1201) @cindex primary_charp_without_random
finvar_lib.tex(,1202) @c ---content primary_charp_without_random---
finvar_lib.tex(,1203) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1204) 
finvar_lib.tex(,1205) @table @asis
finvar_lib.tex(,1206) @item @strong{Usage:}
finvar_lib.tex(,1207) primary_charp_without_random(G1,G2,...,r[,v]);
finvar_lib.tex(,1208) @*G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
finvar_lib.tex(,1209) where -|r| to |r| is the range of coefficients of the random
finvar_lib.tex(,1210) combinations of bases elements, v: an optional <int>
finvar_lib.tex(,1211) 
finvar_lib.tex(,1212) @item @strong{Display:}
finvar_lib.tex(,1213) information about the various stages of the program if v does not
finvar_lib.tex(,1214) equal 0
finvar_lib.tex(,1215) 
finvar_lib.tex(,1216) @item @strong{Return:}
finvar_lib.tex(,1217) primary invariants (type <matrix>) of the invariant ring
finvar_lib.tex(,1218) 
finvar_lib.tex(,1219) @item @strong{Theory:}
finvar_lib.tex(,1220) Bases of homogeneous invariants are generated successively and random
finvar_lib.tex(,1221) linear combinations are chosen as primary invariants that lower the
finvar_lib.tex(,1222) dimension of the ideal generated by the previously found invariants
finvar_lib.tex(,1223) (see "Generating a Noetherian Normalization of the Invariant Ring of
finvar_lib.tex(,1224) a Finite Group" by Decker, Heydtmann, Schreyer (1998)). No Reynolds
finvar_lib.tex(,1225) operator or Molien series is used.
finvar_lib.tex(,1226) 
finvar_lib.tex(,1227) @end table
finvar_lib.tex(,1228) @strong{Example:}
finvar_lib.tex(,1229) @smallexample
finvar_lib.tex(,1230) @c computed example primary_charp_without_random d2t_singular/finvar_lib.doc:1165 
finvar_lib.tex(,1231) LIB "finvar.lib";
finvar_lib.tex(,1232) ring R=2,(x,y,z),dp;
finvar_lib.tex(,1233) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1234) matrix P=primary_charp_without_random(A,1);
finvar_lib.tex(,1235) print(P);
finvar_lib.tex(,1236) @expansion{} x+y,z,xy
finvar_lib.tex(,1237) @c end example primary_charp_without_random d2t_singular/finvar_lib.doc:1165
finvar_lib.tex(,1238) @end smallexample
finvar_lib.tex(,1239) @c ---end content primary_charp_without_random---
finvar_lib.tex(,1240) 
finvar_lib.tex(,1241) @c ------------------- power_products -------------
finvar_lib.tex(,1242) @node power_products, secondary_char0, primary_charp_without_random, finvar_lib
finvar_lib.tex(,1243) @subsubsection power_products
finvar_lib.tex(,1244) @cindex power_products
finvar_lib.tex(,1245) @c ---content power_products---
finvar_lib.tex(,1246) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1247) 
finvar_lib.tex(,1248) @table @asis
finvar_lib.tex(,1249) @item @strong{Usage:}
finvar_lib.tex(,1250) power_products(dv,d);
finvar_lib.tex(,1251) @*dv: an <intvec> giving the degrees of homogeneous polynomials, d: the
finvar_lib.tex(,1252) degree of the desired power products
finvar_lib.tex(,1253) 
finvar_lib.tex(,1254) @item @strong{Return:}
finvar_lib.tex(,1255) a size(dv)*m <intmat> where each column ought to be interpreted as
finvar_lib.tex(,1256) containing the exponents of the corresponding polynomials. The product
finvar_lib.tex(,1257) of the powers is then homogeneous of degree d.
finvar_lib.tex(,1258) 
finvar_lib.tex(,1259) @end table
finvar_lib.tex(,1260) @strong{Example:}
finvar_lib.tex(,1261) @smallexample
finvar_lib.tex(,1262) @c computed example power_products d2t_singular/finvar_lib.doc:1196 
finvar_lib.tex(,1263) LIB "finvar.lib";
finvar_lib.tex(,1264) intvec dv=5,5,5,10,10;
finvar_lib.tex(,1265) print(power_products(dv,10));
finvar_lib.tex(,1266) @expansion{}      2     1     1     0     0     0     0     0
finvar_lib.tex(,1267) @expansion{}      0     1     0     2     1     0     0     0
finvar_lib.tex(,1268) @expansion{}      0     0     1     0     1     2     0     0
finvar_lib.tex(,1269) @expansion{}      0     0     0     0     0     0     1     0
finvar_lib.tex(,1270) @expansion{}      0     0     0     0     0     0     0     1
finvar_lib.tex(,1271) print(power_products(dv,7));
finvar_lib.tex(,1272) @expansion{}      0
finvar_lib.tex(,1273) @expansion{}      0
finvar_lib.tex(,1274) @expansion{}      0
finvar_lib.tex(,1275) @expansion{}      0
finvar_lib.tex(,1276) @expansion{}      0
finvar_lib.tex(,1277) @c end example power_products d2t_singular/finvar_lib.doc:1196
finvar_lib.tex(,1278) @end smallexample
finvar_lib.tex(,1279) @c ---end content power_products---
finvar_lib.tex(,1280) 
finvar_lib.tex(,1281) @c ------------------- secondary_char0 -------------
finvar_lib.tex(,1282) @node secondary_char0, secondary_charp, power_products, finvar_lib
finvar_lib.tex(,1283) @subsubsection secondary_char0
finvar_lib.tex(,1284) @cindex secondary_char0
finvar_lib.tex(,1285) @c ---content secondary_char0---
finvar_lib.tex(,1286) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1287) 
finvar_lib.tex(,1288) @table @asis
finvar_lib.tex(,1289) @item @strong{Usage:}
finvar_lib.tex(,1290) secondary_char0(P,REY,M[,v]);
finvar_lib.tex(,1291) @*P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
finvar_lib.tex(,1292) representing the Reynolds operator, M: a 1x2 <matrix> giving numerator
finvar_lib.tex(,1293) and denominator of the Molien series, v: an optional <int>
finvar_lib.tex(,1294) 
finvar_lib.tex(,1295) @item @strong{Assume:}
finvar_lib.tex(,1296) n is the number of variables of the basering, g the size of the group,
finvar_lib.tex(,1297) REY is the 1st return value of group_reynolds(), reynolds_molien() or
finvar_lib.tex(,1298) the second one of primary_invariants(), M the return value of molien()
finvar_lib.tex(,1299) or the second one of reynolds_molien() or the third one of
finvar_lib.tex(,1300) primary_invariants()
finvar_lib.tex(,1301) 
finvar_lib.tex(,1302) @item @strong{Return:}
finvar_lib.tex(,1303) secondary invariants of the invariant ring (type <matrix>) and
finvar_lib.tex(,1304) irreducible secondary invariants (type <matrix>)
finvar_lib.tex(,1305) 
finvar_lib.tex(,1306) @item @strong{Display:}
finvar_lib.tex(,1307) information if v does not equal 0
finvar_lib.tex(,1308) 
finvar_lib.tex(,1309) @item @strong{Theory:}
finvar_lib.tex(,1310) The secondary invariants are calculated by finding a basis (in terms
finvar_lib.tex(,1311) of monomials) of the basering modulo the primary invariants, mapping
finvar_lib.tex(,1312) those to invariants with the Reynolds operator and using these images
finvar_lib.tex(,1313) or their power products such that they are linearly independent modulo
finvar_lib.tex(,1314) the primary invariants (see paper "Some Algorithms in Invariant
finvar_lib.tex(,1315) Theory of Finite Groups" by Kemper and Steel (1997)).
finvar_lib.tex(,1316) 
finvar_lib.tex(,1317) @end table
finvar_lib.tex(,1318) @strong{Example:}
finvar_lib.tex(,1319) @smallexample
finvar_lib.tex(,1320) @c computed example secondary_char0 d2t_singular/finvar_lib.doc:1244 
finvar_lib.tex(,1321) LIB "finvar.lib";
finvar_lib.tex(,1322) ring R=0,(x,y,z),dp;
finvar_lib.tex(,1323) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1324) list L=primary_invariants(A);
finvar_lib.tex(,1325) matrix S,IS=secondary_char0(L[1..3]);
finvar_lib.tex(,1326) print(S);
finvar_lib.tex(,1327) @expansion{} 1,xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,1328) print(IS);
finvar_lib.tex(,1329) @expansion{} xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,1330) @c end example secondary_char0 d2t_singular/finvar_lib.doc:1244
finvar_lib.tex(,1331) @end smallexample
finvar_lib.tex(,1332) @c ---end content secondary_char0---
finvar_lib.tex(,1333) 
finvar_lib.tex(,1334) @c ------------------- secondary_charp -------------
finvar_lib.tex(,1335) @node secondary_charp, secondary_no_molien, secondary_char0, finvar_lib
finvar_lib.tex(,1336) @subsubsection secondary_charp
finvar_lib.tex(,1337) @cindex secondary_charp
finvar_lib.tex(,1338) @c ---content secondary_charp---
finvar_lib.tex(,1339) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1340) 
finvar_lib.tex(,1341) @table @asis
finvar_lib.tex(,1342) @item @strong{Usage:}
finvar_lib.tex(,1343) secondary_charp(P,REY,ringname[,v]);
finvar_lib.tex(,1344) @*P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
finvar_lib.tex(,1345) representing the Reynolds operator, ringname: a <string> giving the
finvar_lib.tex(,1346) name of a ring of characteristic 0 where the Molien series is stored,
finvar_lib.tex(,1347) v: an optional <int>
finvar_lib.tex(,1348) 
finvar_lib.tex(,1349) @item @strong{Assume:}
finvar_lib.tex(,1350) n is the number of variables of the basering, g the size of the group,
finvar_lib.tex(,1351) REY is the 1st return value of group_reynolds(), reynolds_molien() or
finvar_lib.tex(,1352) the second one of primary_invariants(), `ringname` is a ring of
finvar_lib.tex(,1353) char 0 that has been created by molien() or reynolds_molien() or
finvar_lib.tex(,1354) primary_invariants()
finvar_lib.tex(,1355) 
finvar_lib.tex(,1356) @item @strong{Return:}
finvar_lib.tex(,1357) secondary invariants of the invariant ring (type <matrix>) and
finvar_lib.tex(,1358) irreducible secondary invariants (type <matrix>)
finvar_lib.tex(,1359) 
finvar_lib.tex(,1360) @item @strong{Display:}
finvar_lib.tex(,1361) information if v does not equal 0
finvar_lib.tex(,1362) 
finvar_lib.tex(,1363) @item @strong{Theory:}
finvar_lib.tex(,1364) Secondary invariants are calculated by finding a basis (in terms of
finvar_lib.tex(,1365) monomials) of the basering modulo primary invariants, mapping those
finvar_lib.tex(,1366) to invariants with the Reynolds operator and using these images or
finvar_lib.tex(,1367) their power products such that they are linearly independent modulo
finvar_lib.tex(,1368) the primary invariants (see paper "Some Algorithms in Invariant
finvar_lib.tex(,1369) Theory of Finite Groups" by Kemper and Steel (1997)).
finvar_lib.tex(,1370) 
finvar_lib.tex(,1371) @end table
finvar_lib.tex(,1372) @strong{Example:}
finvar_lib.tex(,1373) @smallexample
finvar_lib.tex(,1374) @c computed example secondary_charp d2t_singular/finvar_lib.doc:1296 
finvar_lib.tex(,1375) LIB "finvar.lib";
finvar_lib.tex(,1376) ring R=3,(x,y,z),dp;
finvar_lib.tex(,1377) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1378) list L=primary_invariants(A);
finvar_lib.tex(,1379) matrix S,IS=secondary_charp(L[1..size(L)]);
finvar_lib.tex(,1380) print(S);
finvar_lib.tex(,1381) @expansion{} 1,xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,1382) print(IS);
finvar_lib.tex(,1383) @expansion{} xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,1384) @c end example secondary_charp d2t_singular/finvar_lib.doc:1296
finvar_lib.tex(,1385) @end smallexample
finvar_lib.tex(,1386) @c ---end content secondary_charp---
finvar_lib.tex(,1387) 
finvar_lib.tex(,1388) @c ------------------- secondary_no_molien -------------
finvar_lib.tex(,1389) @node secondary_no_molien, secondary_and_irreducibles_no_molien, secondary_charp, finvar_lib
finvar_lib.tex(,1390) @subsubsection secondary_no_molien
finvar_lib.tex(,1391) @cindex secondary_no_molien
finvar_lib.tex(,1392) @c ---content secondary_no_molien---
finvar_lib.tex(,1393) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1394) 
finvar_lib.tex(,1395) @table @asis
finvar_lib.tex(,1396) @item @strong{Usage:}
finvar_lib.tex(,1397) secondary_no_molien(P,REY[,deg_vec,v]);
finvar_lib.tex(,1398) @*P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
finvar_lib.tex(,1399) representing the Reynolds operator, deg_vec: an optional <intvec>
finvar_lib.tex(,1400) listing some degrees where no non-trivial homogeneous invariants can
finvar_lib.tex(,1401) be found, v: an optional <int>
finvar_lib.tex(,1402) 
finvar_lib.tex(,1403) @item @strong{Assume:}
finvar_lib.tex(,1404) n is the number of variables of the basering, g the size of the group,
finvar_lib.tex(,1405) REY is the 1st return value of group_reynolds(), reynolds_molien() or
finvar_lib.tex(,1406) the second one of primary_invariants(), deg_vec is the second return
finvar_lib.tex(,1407) value of primary_char0_no_molien(), primary_charp_no_molien(),
finvar_lib.tex(,1408) primary_char0_no_molien_random() or primary_charp_no_molien_random()
finvar_lib.tex(,1409) 
finvar_lib.tex(,1410) @item @strong{Return:}
finvar_lib.tex(,1411) secondary invariants of the invariant ring (type <matrix>)
finvar_lib.tex(,1412) 
finvar_lib.tex(,1413) @item @strong{Display:}
finvar_lib.tex(,1414) information if v does not equal 0
finvar_lib.tex(,1415) 
finvar_lib.tex(,1416) @item @strong{Theory:}
finvar_lib.tex(,1417) Secondary invariants are calculated by finding a basis (in terms of
finvar_lib.tex(,1418) monomials) of the basering modulo primary invariants, mapping those to
finvar_lib.tex(,1419) invariants with the Reynolds operator and using these images as
finvar_lib.tex(,1420) candidates for secondary invariants.
finvar_lib.tex(,1421) 
finvar_lib.tex(,1422) @end table
finvar_lib.tex(,1423) @strong{Example:}
finvar_lib.tex(,1424) @smallexample
finvar_lib.tex(,1425) @c computed example secondary_no_molien d2t_singular/finvar_lib.doc:1345 
finvar_lib.tex(,1426) LIB "finvar.lib";
finvar_lib.tex(,1427) ring R=0,(x,y,z),dp;
finvar_lib.tex(,1428) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1429) list L=primary_invariants(A,intvec(1,1,0));
finvar_lib.tex(,1430) matrix S=secondary_no_molien(L[1..3]);
finvar_lib.tex(,1431) print(S);
finvar_lib.tex(,1432) @expansion{} 1,xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,1433) @c end example secondary_no_molien d2t_singular/finvar_lib.doc:1345
finvar_lib.tex(,1434) @end smallexample
finvar_lib.tex(,1435) @c ---end content secondary_no_molien---
finvar_lib.tex(,1436) 
finvar_lib.tex(,1437) @c ------------------- secondary_and_irreducibles_no_molien -------------
finvar_lib.tex(,1438) @node secondary_and_irreducibles_no_molien, secondary_not_cohen_macaulay, secondary_no_molien, finvar_lib
finvar_lib.tex(,1439) @subsubsection secondary_and_irreducibles_no_molien
finvar_lib.tex(,1440) @cindex secondary_and_irreducibles_no_molien
finvar_lib.tex(,1441) @c ---content secondary_and_irreducibles_no_molien---
finvar_lib.tex(,1442) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1443) 
finvar_lib.tex(,1444) @table @asis
finvar_lib.tex(,1445) @item @strong{Usage:}
finvar_lib.tex(,1446) secondary_and_irreducibles_no_molien(P,REY[,v]);
finvar_lib.tex(,1447) @*P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
finvar_lib.tex(,1448) representing the Reynolds operator, v: an optional <int>
finvar_lib.tex(,1449) 
finvar_lib.tex(,1450) @item @strong{Assume:}
finvar_lib.tex(,1451) n is the number of variables of the basering, g the size of the group,
finvar_lib.tex(,1452) REY is the 1st return value of group_reynolds(), reynolds_molien() or
finvar_lib.tex(,1453) the second one of primary_invariants()
finvar_lib.tex(,1454) 
finvar_lib.tex(,1455) @item @strong{Return:}
finvar_lib.tex(,1456) secondary invariants of the invariant ring (type <matrix>) and
finvar_lib.tex(,1457) irreducible secondary invariants (type <matrix>)
finvar_lib.tex(,1458) 
finvar_lib.tex(,1459) @item @strong{Display:}
finvar_lib.tex(,1460) information if v does not equal 0
finvar_lib.tex(,1461) 
finvar_lib.tex(,1462) @item @strong{Theory:}
finvar_lib.tex(,1463) Secondary invariants are calculated by finding a basis (in terms of
finvar_lib.tex(,1464) monomials) of the basering modulo primary invariants, mapping those to
finvar_lib.tex(,1465) invariants with the Reynolds operator and using these images or their
finvar_lib.tex(,1466) power products such that they are linearly independent modulo the
finvar_lib.tex(,1467) primary invariants (see paper "Some Algorithms in Invariant Theory of
finvar_lib.tex(,1468) Finite Groups" by Kemper and Steel (1997)).
finvar_lib.tex(,1469) 
finvar_lib.tex(,1470) @end table
finvar_lib.tex(,1471) @strong{Example:}
finvar_lib.tex(,1472) @smallexample
finvar_lib.tex(,1473) @c computed example secondary_and_irreducibles_no_molien d2t_singular/finvar_lib.doc:1392 
finvar_lib.tex(,1474) LIB "finvar.lib";
finvar_lib.tex(,1475) ring R=0,(x,y,z),dp;
finvar_lib.tex(,1476) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1477) list L=primary_invariants(A,intvec(1,1,0));
finvar_lib.tex(,1478) matrix S,IS=secondary_and_irreducibles_no_molien(L[1..2]);
finvar_lib.tex(,1479) print(S);
finvar_lib.tex(,1480) @expansion{} 1,xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,1481) print(IS);
finvar_lib.tex(,1482) @expansion{} xyz,x2z-y2z,x3y-xy3
finvar_lib.tex(,1483) @c end example secondary_and_irreducibles_no_molien d2t_singular/finvar_lib.doc:1392
finvar_lib.tex(,1484) @end smallexample
finvar_lib.tex(,1485) @c ---end content secondary_and_irreducibles_no_molien---
finvar_lib.tex(,1486) 
finvar_lib.tex(,1487) @c ------------------- secondary_not_cohen_macaulay -------------
finvar_lib.tex(,1488) @node secondary_not_cohen_macaulay, orbit_variety, secondary_and_irreducibles_no_molien, finvar_lib
finvar_lib.tex(,1489) @subsubsection secondary_not_cohen_macaulay
finvar_lib.tex(,1490) @cindex secondary_not_cohen_macaulay
finvar_lib.tex(,1491) @c ---content secondary_not_cohen_macaulay---
finvar_lib.tex(,1492) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1493) 
finvar_lib.tex(,1494) @table @asis
finvar_lib.tex(,1495) @item @strong{Usage:}
finvar_lib.tex(,1496) secondary_not_cohen_macaulay(P,G1,G2,...[,v]);
finvar_lib.tex(,1497) @*P: a 1xn <matrix> with primary invariants, G1,G2,...: nxn <matrices>
finvar_lib.tex(,1498) generating a finite matrix group, v: an optional <int>
finvar_lib.tex(,1499) 
finvar_lib.tex(,1500) @item @strong{Assume:}
finvar_lib.tex(,1501) n is the number of variables of the basering
finvar_lib.tex(,1502) 
finvar_lib.tex(,1503) @item @strong{Return:}
finvar_lib.tex(,1504) secondary invariants of the invariant ring (type <matrix>)
finvar_lib.tex(,1505) 
finvar_lib.tex(,1506) @item @strong{Display:}
finvar_lib.tex(,1507) information if v does not equal 0
finvar_lib.tex(,1508) 
finvar_lib.tex(,1509) @item @strong{Theory:}
finvar_lib.tex(,1510) Secondary invariants are generated following "Generating Invariant
finvar_lib.tex(,1511) Rings of Finite Groups over Arbitrary Fields" by Kemper (1996).
finvar_lib.tex(,1512) 
finvar_lib.tex(,1513) @end table
finvar_lib.tex(,1514) @strong{Example:}
finvar_lib.tex(,1515) @smallexample
finvar_lib.tex(,1516) @c computed example secondary_not_cohen_macaulay d2t_singular/finvar_lib.doc:1433 
finvar_lib.tex(,1517) LIB "finvar.lib";
finvar_lib.tex(,1518) ring R=2,(x,y,z),dp;
finvar_lib.tex(,1519) matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
finvar_lib.tex(,1520) list L=primary_invariants(A);
finvar_lib.tex(,1521) matrix S=secondary_not_cohen_macaulay(L[1],A);
finvar_lib.tex(,1522) print(S);
finvar_lib.tex(,1523) @expansion{} 1
finvar_lib.tex(,1524) @c end example secondary_not_cohen_macaulay d2t_singular/finvar_lib.doc:1433
finvar_lib.tex(,1525) @end smallexample
finvar_lib.tex(,1526) @c ---end content secondary_not_cohen_macaulay---
finvar_lib.tex(,1527) 
finvar_lib.tex(,1528) @c ------------------- orbit_variety -------------
finvar_lib.tex(,1529) @node orbit_variety, relative_orbit_variety, secondary_not_cohen_macaulay, finvar_lib
finvar_lib.tex(,1530) @subsubsection orbit_variety
finvar_lib.tex(,1531) @cindex orbit_variety
finvar_lib.tex(,1532) @c ---content orbit_variety---
finvar_lib.tex(,1533) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1534) 
finvar_lib.tex(,1535) @table @asis
finvar_lib.tex(,1536) @item @strong{Usage:}
finvar_lib.tex(,1537) orbit_variety(F,s);
finvar_lib.tex(,1538) @*F: a 1xm <matrix> defining an invariant ring, s: a <string> giving the
finvar_lib.tex(,1539) name for a new ring
finvar_lib.tex(,1540) 
finvar_lib.tex(,1541) @item @strong{Return:}
finvar_lib.tex(,1542) a Groebner basis (type <ideal>, named G) for the ideal defining the
finvar_lib.tex(,1543) orbit variety (i.e. the syzygy ideal) in the new ring (named `s`)
finvar_lib.tex(,1544) 
finvar_lib.tex(,1545) @item @strong{Theory:}
finvar_lib.tex(,1546) The ideal of algebraic relations of the invariant ring generators is
finvar_lib.tex(,1547) calculated, then the variables of the original ring are eliminated and
finvar_lib.tex(,1548) the polynomials that are left over define the orbit variety
finvar_lib.tex(,1549) 
finvar_lib.tex(,1550) @end table
finvar_lib.tex(,1551) @strong{Example:}
finvar_lib.tex(,1552) @smallexample
finvar_lib.tex(,1553) @c computed example orbit_variety d2t_singular/finvar_lib.doc:1469 
finvar_lib.tex(,1554) LIB "finvar.lib";
finvar_lib.tex(,1555) ring R=0,(x,y,z),dp;
finvar_lib.tex(,1556) matrix F[1][7]=x2+y2,z2,x4+y4,1,x2z-1y2z,xyz,x3y-1xy3;
finvar_lib.tex(,1557) string newring="E";
finvar_lib.tex(,1558) orbit_variety(F,newring);
finvar_lib.tex(,1559) print(G);
finvar_lib.tex(,1560) @expansion{} y(4)-1,
finvar_lib.tex(,1561) @expansion{} y(5)*y(6)-y(2)*y(7),
finvar_lib.tex(,1562) @expansion{} y(2)*y(3)-y(5)^2-2*y(6)^2,
finvar_lib.tex(,1563) @expansion{} y(1)^2*y(6)-2*y(3)*y(6)+y(5)*y(7),
finvar_lib.tex(,1564) @expansion{} y(1)^2*y(5)-y(3)*y(5)-2*y(6)*y(7),
finvar_lib.tex(,1565) @expansion{} y(1)^2*y(2)-y(2)*y(3)-2*y(6)^2,
finvar_lib.tex(,1566) @expansion{} y(1)^4-3*y(1)^2*y(3)+2*y(3)^2+2*y(7)^2
finvar_lib.tex(,1567) basering;
finvar_lib.tex(,1568) @expansion{} //   characteristic : 0
finvar_lib.tex(,1569) @expansion{} //   number of vars : 7
finvar_lib.tex(,1570) @expansion{} //        block   1 : ordering dp
finvar_lib.tex(,1571) @expansion{} //                  : names    y(1) y(2) y(3) y(4) y(5) y(6) y(7) 
finvar_lib.tex(,1572) @expansion{} //        block   2 : ordering C
finvar_lib.tex(,1573) @c end example orbit_variety d2t_singular/finvar_lib.doc:1469
finvar_lib.tex(,1574) @end smallexample
finvar_lib.tex(,1575) @c ---end content orbit_variety---
finvar_lib.tex(,1576) 
finvar_lib.tex(,1577) @c ------------------- relative_orbit_variety -------------
finvar_lib.tex(,1578) @node relative_orbit_variety, image_of_variety, orbit_variety, finvar_lib
finvar_lib.tex(,1579) @subsubsection relative_orbit_variety
finvar_lib.tex(,1580) @cindex relative_orbit_variety
finvar_lib.tex(,1581) @c ---content relative_orbit_variety---
finvar_lib.tex(,1582) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1583) 
finvar_lib.tex(,1584) @table @asis
finvar_lib.tex(,1585) @item @strong{Usage:}
finvar_lib.tex(,1586) relative_orbit_variety(I,F,s);
finvar_lib.tex(,1587) @*I: an <ideal> invariant under the action of a group, F: a 1xm
finvar_lib.tex(,1588) <matrix> defining the invariant ring of this group, s: a <string>
finvar_lib.tex(,1589) giving a name for a new ring
finvar_lib.tex(,1590) 
finvar_lib.tex(,1591) @item @strong{Return:}
finvar_lib.tex(,1592) a Groebner basis (type <ideal>, named G) for the ideal defining the
finvar_lib.tex(,1593) relative orbit variety with respect to I in the new ring (named s)
finvar_lib.tex(,1594) 
finvar_lib.tex(,1595) @item @strong{Theory:}
finvar_lib.tex(,1596) A Groebner basis of the ideal of algebraic relations of the invariant
finvar_lib.tex(,1597) ring generators is calculated, then one of the basis elements plus the
finvar_lib.tex(,1598) ideal generators. The variables of the original ring are eliminated
finvar_lib.tex(,1599) and the polynomials that are left define the relative orbit variety
finvar_lib.tex(,1600) with respect to I.
finvar_lib.tex(,1601) 
finvar_lib.tex(,1602) @end table
finvar_lib.tex(,1603) @strong{Example:}
finvar_lib.tex(,1604) @smallexample
finvar_lib.tex(,1605) @c computed example relative_orbit_variety d2t_singular/finvar_lib.doc:1509 
finvar_lib.tex(,1606) LIB "finvar.lib";
finvar_lib.tex(,1607) ring R=0,(x,y,z),dp;
finvar_lib.tex(,1608) matrix F[1][3]=x+y+z,xy+xz+yz,xyz;
finvar_lib.tex(,1609) ideal I=x2+y2+z2-1,x2y+y2z+z2x-2x-2y-2z,xy2+yz2+zx2-2x-2y-2z;
finvar_lib.tex(,1610) string newring="E";
finvar_lib.tex(,1611) relative_orbit_variety(I,F,newring);
finvar_lib.tex(,1612) print(G);
finvar_lib.tex(,1613) @expansion{} 27*y(3)^6-513*y(3)^4+33849*y(3)^2-784,
finvar_lib.tex(,1614) @expansion{} 1475*y(2)+9*y(3)^4-264*y(3)^2+736,
finvar_lib.tex(,1615) @expansion{} 8260*y(1)+9*y(3)^5-87*y(3)^3+5515*y(3)
finvar_lib.tex(,1616) basering;
finvar_lib.tex(,1617) @expansion{} //   characteristic : 0
finvar_lib.tex(,1618) @expansion{} //   number of vars : 3
finvar_lib.tex(,1619) @expansion{} //        block   1 : ordering lp
finvar_lib.tex(,1620) @expansion{} //                  : names    y(1) y(2) y(3) 
finvar_lib.tex(,1621) @expansion{} //        block   2 : ordering C
finvar_lib.tex(,1622) @c end example relative_orbit_variety d2t_singular/finvar_lib.doc:1509
finvar_lib.tex(,1623) @end smallexample
finvar_lib.tex(,1624) @c ---end content relative_orbit_variety---
finvar_lib.tex(,1625) 
finvar_lib.tex(,1626) @c ------------------- image_of_variety -------------
finvar_lib.tex(,1627) @node image_of_variety,, relative_orbit_variety, finvar_lib
finvar_lib.tex(,1628) @subsubsection image_of_variety
finvar_lib.tex(,1629) @cindex image_of_variety
finvar_lib.tex(,1630) @c ---content image_of_variety---
finvar_lib.tex(,1631) Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).
finvar_lib.tex(,1632) 
finvar_lib.tex(,1633) @table @asis
finvar_lib.tex(,1634) @item @strong{Usage:}
finvar_lib.tex(,1635) image_of_variety(I,F);
finvar_lib.tex(,1636) @*I: an arbitrary <ideal>, F: a 1xm <matrix> defining an invariant ring
finvar_lib.tex(,1637) of a some matrix group
finvar_lib.tex(,1638) 
finvar_lib.tex(,1639) @item @strong{Return:}
finvar_lib.tex(,1640) the <ideal> defining the image under that group of the variety defined
finvar_lib.tex(,1641) by I
finvar_lib.tex(,1642) 
finvar_lib.tex(,1643) @item @strong{Theory:}
finvar_lib.tex(,1644) relative_orbit_variety(I,F,s) is called and the newly introduced
finvar_lib.tex(,1645) variables in the output are replaced by the generators of the
finvar_lib.tex(,1646) invariant ring. This ideal in the original variables defines the image
finvar_lib.tex(,1647) of the variety defined by I
finvar_lib.tex(,1648) 
finvar_lib.tex(,1649) @end table
finvar_lib.tex(,1650) @strong{Example:}
finvar_lib.tex(,1651) @smallexample
finvar_lib.tex(,1652) @c computed example image_of_variety d2t_singular/finvar_lib.doc:1548 
finvar_lib.tex(,1653) LIB "finvar.lib";
finvar_lib.tex(,1654) ring R=0,(x,y,z),dp;
finvar_lib.tex(,1655) matrix F[1][3]=x+y+z,xy+xz+yz,xyz;
finvar_lib.tex(,1656) ideal I=xy;
finvar_lib.tex(,1657) print(image_of_variety(I,F));
finvar_lib.tex(,1658) @expansion{} xyz
finvar_lib.tex(,1659) @c end example image_of_variety d2t_singular/finvar_lib.doc:1548
finvar_lib.tex(,1660) @end smallexample
finvar_lib.tex(,1661) @c ---end content image_of_variety---
singular.texi(,517) @c ----------------------------------------------------------
singular.texi(,518) @node ainvar_lib, rinvar_lib, finvar_lib, Invariant theory
singular.texi(,519) @subsection ainvar_lib
singular.texi(,520) @c include of docu for ainvar.lib
ainvar_lib.tex(,1) @c ---content LibInfo---
ainvar_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/ainvar_lib.doc
ainvar_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/ainvar_lib.doc INSTEAD
ainvar_lib.tex(,4) @c library version: (1.6.2.2,2002/04/12)
ainvar_lib.tex(,5) @c library file: ../Singular/LIB/ainvar.lib
ainvar_lib.tex(,6) @cindex ainvar.lib
ainvar_lib.tex(,7) @cindex ainvar_lib
ainvar_lib.tex(,8) @table @asis
ainvar_lib.tex(,9) @item @strong{Library:}
ainvar_lib.tex(,10) ainvar.lib
ainvar_lib.tex(,11) @item @strong{Purpose:}
ainvar_lib.tex(,12)     Invariant Rings of the Additive Group
ainvar_lib.tex(,13) @item @strong{Authors:}
ainvar_lib.tex(,14) Gerhard Pfister (email: pfister@@mathematik.uni-kl.de),
ainvar_lib.tex(,15) Gert-Martin Greuel (email: greuel@@mathematik.uni-kl.de)
ainvar_lib.tex(,16) 
ainvar_lib.tex(,17) @end table
ainvar_lib.tex(,18) 
ainvar_lib.tex(,19) @strong{Procedures:}
ainvar_lib.tex(,20) @menu
ainvar_lib.tex(,21) * invariantRing:: compute ring of invariants of (K,+)-action given by m
ainvar_lib.tex(,22) * derivate:: derivation of f with respect to the vector field m
ainvar_lib.tex(,23) * actionIsProper:: tests whether action defined by m is proper
ainvar_lib.tex(,24) * reduction:: SAGBI reduction of p in the subring generated by I
ainvar_lib.tex(,25) * completeReduction:: complete SAGBI reduction
ainvar_lib.tex(,26) * localInvar:: invariant polynomial under m computed from p,...
ainvar_lib.tex(,27) * furtherInvar:: compute further invariants of m from the given ones
ainvar_lib.tex(,28) * sortier:: sorts generators of id by increasing leading terms
ainvar_lib.tex(,29) @end menu
ainvar_lib.tex(,30) @c ---end content LibInfo---
ainvar_lib.tex(,31) 
ainvar_lib.tex(,32) @c ------------------- invariantRing -------------
ainvar_lib.tex(,33) @node invariantRing, derivate,, ainvar_lib
ainvar_lib.tex(,34) @subsubsection invariantRing
ainvar_lib.tex(,35) @cindex invariantRing
ainvar_lib.tex(,36) @c ---content invariantRing---
ainvar_lib.tex(,37) Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).
ainvar_lib.tex(,38) 
ainvar_lib.tex(,39) @table @asis
ainvar_lib.tex(,40) @item @strong{Usage:}
ainvar_lib.tex(,41) invariantRing(m,p,q,b[,r,pa]); m matrix, p,q poly, b,r int, pa string
ainvar_lib.tex(,42) 
ainvar_lib.tex(,43) @item @strong{Assume:}
ainvar_lib.tex(,44) p,q variables with m(p)=q and q invariant under m
ainvar_lib.tex(,45) @*i.e. if p=x(i) and q=x(j) then m[j,1]=0 and m[i,1]=x(j)
ainvar_lib.tex(,46) 
ainvar_lib.tex(,47) @item @strong{Return:}
ainvar_lib.tex(,48) ideal, containing generators of the ring of invariants of the
ainvar_lib.tex(,49) additive group (K,+) given by the vector field
ainvar_lib.tex(,50) @format
ainvar_lib.tex(,51)          m = m[1,1]*d/dx(1) +...+ m[n,1]*d/dx(n).
ainvar_lib.tex(,52) @end format
ainvar_lib.tex(,53) If b>0 the computation stops after all invariants of degree <= b
ainvar_lib.tex(,54) (and at least one of higher degree) are found or when all invariants
ainvar_lib.tex(,55) are computed.
ainvar_lib.tex(,56) @*If b<=0, the computation continues until all generators
ainvar_lib.tex(,57) of the ring of invariants are computed (should be used only if the
ainvar_lib.tex(,58) ring of invariants is known to be finitely generated otherwise the
ainvar_lib.tex(,59) algorithm might not stop).
ainvar_lib.tex(,60) @*If r=1 a different reduction is used which is sometimes faster
ainvar_lib.tex(,61) (default r=0).
ainvar_lib.tex(,62) 
ainvar_lib.tex(,63) @item @strong{Display:}
ainvar_lib.tex(,64) if pa is given (any string as 5th or 6th argument), the computation
ainvar_lib.tex(,65) pauses whenever new invariants are found and displays them
ainvar_lib.tex(,66) 
ainvar_lib.tex(,67) @item @strong{Theory:}
ainvar_lib.tex(,68) The algorithm to compute the ring of invariants works in char 0
ainvar_lib.tex(,69) or big enough characteristic. (K,+) acts as the exponential of the
ainvar_lib.tex(,70) vector field defined by the matrix m. For background see G.-M. Greuel,
ainvar_lib.tex(,71) G. Pfister, Geometric quotients of unipotent group actions, Proc.
ainvar_lib.tex(,72) London Math. Soc. (3) 67, 75-105 (1993).
ainvar_lib.tex(,73) 
ainvar_lib.tex(,74) @end table
ainvar_lib.tex(,75) @strong{Example:}
ainvar_lib.tex(,76) @smallexample
ainvar_lib.tex(,77) @c computed example invariantRing d2t_singular/ainvar_lib.doc:75 
ainvar_lib.tex(,78) LIB "ainvar.lib";
ainvar_lib.tex(,79) //Winkelmann: free action but Spec(k[x(1),...,x(5)]) --> Spec(invariant ring)
ainvar_lib.tex(,80) //is not surjective
ainvar_lib.tex(,81) ring rw=0,(x(1..5)),dp;
ainvar_lib.tex(,82) matrix m[5][1];
ainvar_lib.tex(,83) m[3,1]=x(1);
ainvar_lib.tex(,84) m[4,1]=x(2);
ainvar_lib.tex(,85) m[5,1]=1+x(1)*x(4)+x(2)*x(3);
ainvar_lib.tex(,86) ideal in=invariantRing(m,x(3),x(1),0);      //compute full invarint ring
ainvar_lib.tex(,87) in;
ainvar_lib.tex(,88) @expansion{} in[1]=x(1)
ainvar_lib.tex(,89) @expansion{} in[2]=x(2)
ainvar_lib.tex(,90) @expansion{} in[3]=x(2)*x(3)*x(4)-x(2)*x(5)+x(4)
ainvar_lib.tex(,91) @expansion{} in[4]=x(1)*x(3)*x(4)-x(1)*x(5)+x(3)
ainvar_lib.tex(,92) //Deveney/Finston: The ring of invariants is not finitely generated
ainvar_lib.tex(,93) ring rf=0,(x(1..7)),dp;
ainvar_lib.tex(,94) matrix m[7][1];
ainvar_lib.tex(,95) m[4,1]=x(1)^3;
ainvar_lib.tex(,96) m[5,1]=x(2)^3;
ainvar_lib.tex(,97) m[6,1]=x(3)^3;
ainvar_lib.tex(,98) m[7,1]=(x(1)*x(2)*x(3))^2;
ainvar_lib.tex(,99) ideal in=invariantRing(m,x(4),x(1),6);      //all invariants up to degree 6
ainvar_lib.tex(,100) in;
ainvar_lib.tex(,101) @expansion{} in[1]=x(1)
ainvar_lib.tex(,102) @expansion{} in[2]=x(3)
ainvar_lib.tex(,103) @expansion{} in[3]=x(2)
ainvar_lib.tex(,104) @expansion{} in[4]=x(3)^3*x(4)-x(1)^3*x(6)
ainvar_lib.tex(,105) @expansion{} in[5]=x(2)^3*x(4)-x(1)^3*x(5)
ainvar_lib.tex(,106) @expansion{} in[6]=x(2)^2*x(3)^2*x(4)-x(1)*x(7)
ainvar_lib.tex(,107) @expansion{} in[7]=x(1)^2*x(2)^2*x(6)-x(3)*x(7)
ainvar_lib.tex(,108) @expansion{} in[8]=x(1)^2*x(3)^2*x(5)-x(2)*x(7)
ainvar_lib.tex(,109) @expansion{} in[9]=x(1)^2*x(2)*x(3)^4*x(4)*x(5)+x(1)^2*x(2)^4*x(3)*x(4)*x(6)-x(1)^5*x(\
ainvar_lib.tex(,110)    2)*x(3)*x(5)*x(6)-2*x(2)^2*x(3)^2*x(4)*x(7)+x(1)*x(7)^2
ainvar_lib.tex(,111) @c end example invariantRing d2t_singular/ainvar_lib.doc:75
ainvar_lib.tex(,112) @end smallexample
ainvar_lib.tex(,113) @c ---end content invariantRing---
ainvar_lib.tex(,114) 
ainvar_lib.tex(,115) @c ------------------- derivate -------------
ainvar_lib.tex(,116) @node derivate, actionIsProper, invariantRing, ainvar_lib
ainvar_lib.tex(,117) @subsubsection derivate
ainvar_lib.tex(,118) @cindex derivate
ainvar_lib.tex(,119) @c ---content derivate---
ainvar_lib.tex(,120) Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).
ainvar_lib.tex(,121) 
ainvar_lib.tex(,122) @table @asis
ainvar_lib.tex(,123) @item @strong{Usage:}
ainvar_lib.tex(,124) derivate(m,id); m matrix, id poly/vector/ideal
ainvar_lib.tex(,125) 
ainvar_lib.tex(,126) @item @strong{Assume:}
ainvar_lib.tex(,127) m is a nx1 matrix, where n = number of variables of the basering
ainvar_lib.tex(,128) 
ainvar_lib.tex(,129) @item @strong{Return:}
ainvar_lib.tex(,130) poly/vector/ideal (same type as input), result of applying the
ainvar_lib.tex(,131) vector field by the matrix m componentwise to id;
ainvar_lib.tex(,132) 
ainvar_lib.tex(,133) @item @strong{Note:}
ainvar_lib.tex(,134) the vector field is m[1,1]*d/dx(1) +...+ m[1,n]*d/dx(n)
ainvar_lib.tex(,135) 
ainvar_lib.tex(,136) @end table
ainvar_lib.tex(,137) @strong{Example:}
ainvar_lib.tex(,138) @smallexample
ainvar_lib.tex(,139) @c computed example derivate d2t_singular/ainvar_lib.doc:123 
ainvar_lib.tex(,140) LIB "ainvar.lib";
ainvar_lib.tex(,141) ring q=0,(x,y,z,u,v,w),dp;
ainvar_lib.tex(,142) poly f=2xz-y2;
ainvar_lib.tex(,143) matrix m[6][1] =x,y,0,u,v;
ainvar_lib.tex(,144) derivate(m,f);
ainvar_lib.tex(,145) @expansion{} -2y2+2xz
ainvar_lib.tex(,146) vector v = [2xz-y2,u6-3];
ainvar_lib.tex(,147) derivate(m,v);
ainvar_lib.tex(,148) @expansion{} 6u6*gen(2)-2y2*gen(1)+2xz*gen(1)
ainvar_lib.tex(,149) derivate(m,ideal(2xz-y2,u6-3));
ainvar_lib.tex(,150) @expansion{} _[1]=-2y2+2xz
ainvar_lib.tex(,151) @expansion{} _[2]=6u6
ainvar_lib.tex(,152) @c end example derivate d2t_singular/ainvar_lib.doc:123
ainvar_lib.tex(,153) @end smallexample
ainvar_lib.tex(,154) @c ---end content derivate---
ainvar_lib.tex(,155) 
ainvar_lib.tex(,156) @c ------------------- actionIsProper -------------
ainvar_lib.tex(,157) @node actionIsProper, reduction, derivate, ainvar_lib
ainvar_lib.tex(,158) @subsubsection actionIsProper
ainvar_lib.tex(,159) @cindex actionIsProper
ainvar_lib.tex(,160) @c ---content actionIsProper---
ainvar_lib.tex(,161) Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).
ainvar_lib.tex(,162) 
ainvar_lib.tex(,163) @table @asis
ainvar_lib.tex(,164) @item @strong{Usage:}
ainvar_lib.tex(,165) actionIsProper(m); m matrix
ainvar_lib.tex(,166) 
ainvar_lib.tex(,167) @item @strong{Assume:}
ainvar_lib.tex(,168) m is a nx1 matrix, where n = number of variables of the basering
ainvar_lib.tex(,169) 
ainvar_lib.tex(,170) @item @strong{Return:}
ainvar_lib.tex(,171) int = 1, if the action defined by m is proper, 0 if not
ainvar_lib.tex(,172) 
ainvar_lib.tex(,173) @item @strong{Note:}
ainvar_lib.tex(,174) m defines a group action which is the exponential of the vector
ainvar_lib.tex(,175) field m[1,1]*d/dx(1) +...+ m[1,n]*d/dx(n)
ainvar_lib.tex(,176) 
ainvar_lib.tex(,177) @end table
ainvar_lib.tex(,178) @strong{Example:}
ainvar_lib.tex(,179) @smallexample
ainvar_lib.tex(,180) @c computed example actionIsProper d2t_singular/ainvar_lib.doc:160 
ainvar_lib.tex(,181) LIB "ainvar.lib";
ainvar_lib.tex(,182) ring rf=0,x(1..7),dp;
ainvar_lib.tex(,183) matrix m[7][1];
ainvar_lib.tex(,184) m[4,1]=x(1)^3;
ainvar_lib.tex(,185) m[5,1]=x(2)^3;
ainvar_lib.tex(,186) m[6,1]=x(3)^3;
ainvar_lib.tex(,187) m[7,1]=(x(1)*x(2)*x(3))^2;
ainvar_lib.tex(,188) actionIsProper(m);
ainvar_lib.tex(,189) @expansion{} 0
ainvar_lib.tex(,190) ring rd=0,x(1..5),dp;
ainvar_lib.tex(,191) matrix m[5][1];
ainvar_lib.tex(,192) m[3,1]=x(1);
ainvar_lib.tex(,193) m[4,1]=x(2);
ainvar_lib.tex(,194) m[5,1]=1+x(1)*x(4)^2;
ainvar_lib.tex(,195) actionIsProper(m);
ainvar_lib.tex(,196) @expansion{} 1
ainvar_lib.tex(,197) @c end example actionIsProper d2t_singular/ainvar_lib.doc:160
ainvar_lib.tex(,198) @end smallexample
ainvar_lib.tex(,199) @c ---end content actionIsProper---
ainvar_lib.tex(,200) 
ainvar_lib.tex(,201) @c ------------------- reduction -------------
ainvar_lib.tex(,202) @node reduction, completeReduction, actionIsProper, ainvar_lib
ainvar_lib.tex(,203) @subsubsection reduction
ainvar_lib.tex(,204) @cindex reduction
ainvar_lib.tex(,205) @c ---content reduction---
ainvar_lib.tex(,206) Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).
ainvar_lib.tex(,207) 
ainvar_lib.tex(,208) @table @asis
ainvar_lib.tex(,209) @item @strong{Usage:}
ainvar_lib.tex(,210) reduction(p,I[,q,n]); p poly, I ideal, [q monomial, n int (optional)]
ainvar_lib.tex(,211) 
ainvar_lib.tex(,212) @item @strong{Return:}
ainvar_lib.tex(,213) a polynomial equal to p-H(f1,...,fr), in case the leading
ainvar_lib.tex(,214) term LT(p) of p is of the form H(LT(f1),...,LT(fr)) for some
ainvar_lib.tex(,215) polynomial H in r variables over the base field, I=f1,...,fr;
ainvar_lib.tex(,216) if q is given, a maximal power a is computed such that q^a divides
ainvar_lib.tex(,217) p-H(f1,...,fr), and then (p-H(f1,...,fr))/q^a is returned;
ainvar_lib.tex(,218) return p if no H is found
ainvar_lib.tex(,219) @*if n=1, a different algorithm is chosen which is sometimes faster
ainvar_lib.tex(,220) (default: n=0; q and n can be given (or not) in any order)
ainvar_lib.tex(,221) 
ainvar_lib.tex(,222) @item @strong{Note:}
ainvar_lib.tex(,223) this is a kind of SAGBI reduction in the subalgebra K[f1,...,fr] of
ainvar_lib.tex(,224) the basering
ainvar_lib.tex(,225) 
ainvar_lib.tex(,226) @end table
ainvar_lib.tex(,227) @strong{Example:}
ainvar_lib.tex(,228) @smallexample
ainvar_lib.tex(,229) @c computed example reduction d2t_singular/ainvar_lib.doc:207 
ainvar_lib.tex(,230) LIB "ainvar.lib";
ainvar_lib.tex(,231) ring q=0,(x,y,z,u,v,w),dp;
ainvar_lib.tex(,232) poly p=x2yz-x2v;
ainvar_lib.tex(,233) ideal dom =x-w,u2w+1,yz-v;
ainvar_lib.tex(,234) reduction(p,dom);
ainvar_lib.tex(,235) @expansion{} 2xyzw-yzw2-2xvw+vw2
ainvar_lib.tex(,236) reduction(p,dom,w);
ainvar_lib.tex(,237) @expansion{} 2xyz-yzw-2xv+vw
ainvar_lib.tex(,238) @c end example reduction d2t_singular/ainvar_lib.doc:207
ainvar_lib.tex(,239) @end smallexample
ainvar_lib.tex(,240) @c ---end content reduction---
ainvar_lib.tex(,241) 
ainvar_lib.tex(,242) @c ------------------- completeReduction -------------
ainvar_lib.tex(,243) @node completeReduction, localInvar, reduction, ainvar_lib
ainvar_lib.tex(,244) @subsubsection completeReduction
ainvar_lib.tex(,245) @cindex completeReduction
ainvar_lib.tex(,246) @c ---content completeReduction---
ainvar_lib.tex(,247) Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).
ainvar_lib.tex(,248) 
ainvar_lib.tex(,249) @table @asis
ainvar_lib.tex(,250) @item @strong{Usage:}
ainvar_lib.tex(,251) completeReduction(p,I[,q,n]); p poly, I ideal, [q monomial, n int]
ainvar_lib.tex(,252) 
ainvar_lib.tex(,253) @item @strong{Return:}
ainvar_lib.tex(,254) a polynomial, the SAGBI reduction of the polynomial p with I
ainvar_lib.tex(,255) via the procedure 'reduction' as long as possible
ainvar_lib.tex(,256) @*if n=1, a different algorithm is chosen which is sometimes faster
ainvar_lib.tex(,257) (default: n=0; q and n can be given (or not) in any order)
ainvar_lib.tex(,258) 
ainvar_lib.tex(,259) @item @strong{Note:}
ainvar_lib.tex(,260) help reduction; shows an explanation of SAGBI reduction
ainvar_lib.tex(,261) 
ainvar_lib.tex(,262) @end table
ainvar_lib.tex(,263) @strong{Example:}
ainvar_lib.tex(,264) @smallexample
ainvar_lib.tex(,265) @c computed example completeReduction d2t_singular/ainvar_lib.doc:241 
ainvar_lib.tex(,266) LIB "ainvar.lib";
ainvar_lib.tex(,267) ring q=0,(x,y,z,u,v,w),dp;
ainvar_lib.tex(,268) poly p=x2yz-x2v;
ainvar_lib.tex(,269) ideal dom =x-w,u2w+1,yz-v;
ainvar_lib.tex(,270) completeReduction(p,dom);
ainvar_lib.tex(,271) @expansion{} 2xyzw-yzw2-2xvw+vw2
ainvar_lib.tex(,272) completeReduction(p,dom,w);
ainvar_lib.tex(,273) @expansion{} 0
ainvar_lib.tex(,274) @c end example completeReduction d2t_singular/ainvar_lib.doc:241
ainvar_lib.tex(,275) @end smallexample
ainvar_lib.tex(,276) @c ---end content completeReduction---
ainvar_lib.tex(,277) 
ainvar_lib.tex(,278) @c ------------------- localInvar -------------
ainvar_lib.tex(,279) @node localInvar, furtherInvar, completeReduction, ainvar_lib
ainvar_lib.tex(,280) @subsubsection localInvar
ainvar_lib.tex(,281) @cindex localInvar
ainvar_lib.tex(,282) @c ---content localInvar---
ainvar_lib.tex(,283) Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).
ainvar_lib.tex(,284) 
ainvar_lib.tex(,285) @table @asis
ainvar_lib.tex(,286) @item @strong{Usage:}
ainvar_lib.tex(,287) localInvar(m,p,q,h); m matrix, p,q,h polynomials
ainvar_lib.tex(,288) 
ainvar_lib.tex(,289) @item @strong{Assume:}
ainvar_lib.tex(,290) m(q) and h are invariant under the vector field m, i.e. m(m(q))=m(h)=0
ainvar_lib.tex(,291) h must be a ring variable
ainvar_lib.tex(,292) 
ainvar_lib.tex(,293) @item @strong{Return:}
ainvar_lib.tex(,294) a polynomial, the invariant polynomial of the vector field
ainvar_lib.tex(,295) @format
ainvar_lib.tex(,296)          m = m[1,1]*d/dx(1) +...+ m[n,1]*d/dx(n)
ainvar_lib.tex(,297) @end format
ainvar_lib.tex(,298) with respect to p,q,h. It is defined as follows: set inv = p if p is
ainvar_lib.tex(,299) invariant, and else as
ainvar_lib.tex(,300) @*inv = m(q)^N * sum_i=1..N-1@{ (-1)^i*(1/i!)*m^i(p)*(q/m(q))^i @}
ainvar_lib.tex(,301) where m^N(p) = 0, m^(N-1)(p) != 0;
ainvar_lib.tex(,302) @*the result is inv divided by h as much as possible
ainvar_lib.tex(,303) 
ainvar_lib.tex(,304) @end table
ainvar_lib.tex(,305) @strong{Example:}
ainvar_lib.tex(,306) @smallexample
ainvar_lib.tex(,307) @c computed example localInvar d2t_singular/ainvar_lib.doc:281 
ainvar_lib.tex(,308) LIB "ainvar.lib";
ainvar_lib.tex(,309) ring q=0,(x,y,z),dp;
ainvar_lib.tex(,310) matrix m[3][1];
ainvar_lib.tex(,311) m[2,1]=x;
ainvar_lib.tex(,312) m[3,1]=y;
ainvar_lib.tex(,313) poly in=localInvar(m,z,y,x);
ainvar_lib.tex(,314) in;
ainvar_lib.tex(,315) @expansion{} -1/2y2+xz
ainvar_lib.tex(,316) @c end example localInvar d2t_singular/ainvar_lib.doc:281
ainvar_lib.tex(,317) @end smallexample
ainvar_lib.tex(,318) @c ---end content localInvar---
ainvar_lib.tex(,319) 
ainvar_lib.tex(,320) @c ------------------- furtherInvar -------------
ainvar_lib.tex(,321) @node furtherInvar, sortier, localInvar, ainvar_lib
ainvar_lib.tex(,322) @subsubsection furtherInvar
ainvar_lib.tex(,323) @cindex furtherInvar
ainvar_lib.tex(,324) @c ---content furtherInvar---
ainvar_lib.tex(,325) Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).
ainvar_lib.tex(,326) 
ainvar_lib.tex(,327) @table @asis
ainvar_lib.tex(,328) @item @strong{Usage:}
ainvar_lib.tex(,329) furtherInvar(m,id,karl,q); m matrix, id,karl ideals, q poly, n int
ainvar_lib.tex(,330) 
ainvar_lib.tex(,331) @item @strong{Assume:}
ainvar_lib.tex(,332) karl,id,q are invariant under the vector field m,
ainvar_lib.tex(,333) @*moreover, q must be a variable
ainvar_lib.tex(,334) 
ainvar_lib.tex(,335) @item @strong{Return:}
ainvar_lib.tex(,336) list of two ideals, the first ideal contains further invariants of
ainvar_lib.tex(,337) the vector field
ainvar_lib.tex(,338) @format
ainvar_lib.tex(,339)          m = sum m[i,1]*d/dx(i) with respect to id,p,q,
ainvar_lib.tex(,340) @end format
ainvar_lib.tex(,341) i.e. we compute elements in the (invariant) subring generated by id
ainvar_lib.tex(,342) which are divisible by q and divide them by q as much as possible
ainvar_lib.tex(,343) the second ideal contains all invariants given before
ainvar_lib.tex(,344) if n=1, a different algorithm is chosen which is sometimes faster
ainvar_lib.tex(,345) (default: n=0)
ainvar_lib.tex(,346) 
ainvar_lib.tex(,347) @end table
ainvar_lib.tex(,348) @strong{Example:}
ainvar_lib.tex(,349) @smallexample
ainvar_lib.tex(,350) @c computed example furtherInvar d2t_singular/ainvar_lib.doc:323 
ainvar_lib.tex(,351) LIB "ainvar.lib";
ainvar_lib.tex(,352) ring r=0,(x,y,z,u),dp;
ainvar_lib.tex(,353) matrix m[4][1];
ainvar_lib.tex(,354) m[2,1]=x;
ainvar_lib.tex(,355) m[3,1]=y;
ainvar_lib.tex(,356) m[4,1]=z;
ainvar_lib.tex(,357) ideal id=localInvar(m,z,y,x),localInvar(m,u,y,x);
ainvar_lib.tex(,358) ideal karl=id,x;
ainvar_lib.tex(,359) list in=furtherInvar(m,id,karl,x);
ainvar_lib.tex(,360) in;
ainvar_lib.tex(,361) @expansion{} [1]:
ainvar_lib.tex(,362) @expansion{}    _[1]=y2z2-8/3xz3-2y3u+6xyzu-3x2u2
ainvar_lib.tex(,363) @expansion{} [2]:
ainvar_lib.tex(,364) @expansion{}    _[1]=-1/2y2+xz
ainvar_lib.tex(,365) @expansion{}    _[2]=1/3y3-xyz+x2u
ainvar_lib.tex(,366) @expansion{}    _[3]=x
ainvar_lib.tex(,367) @c end example furtherInvar d2t_singular/ainvar_lib.doc:323
ainvar_lib.tex(,368) @end smallexample
ainvar_lib.tex(,369) @c ---end content furtherInvar---
ainvar_lib.tex(,370) 
ainvar_lib.tex(,371) @c ------------------- sortier -------------
ainvar_lib.tex(,372) @node sortier,, furtherInvar, ainvar_lib
ainvar_lib.tex(,373) @subsubsection sortier
ainvar_lib.tex(,374) @cindex sortier
ainvar_lib.tex(,375) @c ---content sortier---
ainvar_lib.tex(,376) Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).
ainvar_lib.tex(,377) 
ainvar_lib.tex(,378) @table @asis
ainvar_lib.tex(,379) @item @strong{Usage:}
ainvar_lib.tex(,380) sortier(id); id ideal/module
ainvar_lib.tex(,381) 
ainvar_lib.tex(,382) @item @strong{Return:}
ainvar_lib.tex(,383) the same ideal/module but with generators ordered by there
ainvar_lib.tex(,384) leading term, starting with the smallest
ainvar_lib.tex(,385) 
ainvar_lib.tex(,386) @end table
ainvar_lib.tex(,387) @strong{Example:}
ainvar_lib.tex(,388) @smallexample
ainvar_lib.tex(,389) @c computed example sortier d2t_singular/ainvar_lib.doc:356 
ainvar_lib.tex(,390) LIB "ainvar.lib";
ainvar_lib.tex(,391) ring q=0,(x,y,z,u,v,w),dp;
ainvar_lib.tex(,392) ideal i=w,x,z,y,v;
ainvar_lib.tex(,393) sortier(i);
ainvar_lib.tex(,394) @expansion{} _[1]=w
ainvar_lib.tex(,395) @expansion{} _[2]=v
ainvar_lib.tex(,396) @expansion{} _[3]=z
ainvar_lib.tex(,397) @expansion{} _[4]=y
ainvar_lib.tex(,398) @expansion{} _[5]=x
ainvar_lib.tex(,399) @c end example sortier d2t_singular/ainvar_lib.doc:356
ainvar_lib.tex(,400) @end smallexample
ainvar_lib.tex(,401) @c ---end content sortier---
singular.texi(,522) @c ----------------------------------------------------------
singular.texi(,523) @node rinvar_lib, stratify_lib, ainvar_lib, Invariant theory
singular.texi(,524) @subsection rinvar_lib
singular.texi(,525) @c include of docu for rinvar.lib
rinvar_lib.tex(,1) @c ---content LibInfo---
rinvar_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/rinvar_lib.doc
rinvar_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/rinvar_lib.doc INSTEAD
rinvar_lib.tex(,4) @c library version: (1.7.2.3,2002/02/20)
rinvar_lib.tex(,5) @c library file: ../Singular/LIB/rinvar.lib
rinvar_lib.tex(,6) @cindex rinvar.lib
rinvar_lib.tex(,7) @cindex rinvar_lib
rinvar_lib.tex(,8) @table @asis
rinvar_lib.tex(,9) @item @strong{Library:}
rinvar_lib.tex(,10) rinvar.lib
rinvar_lib.tex(,11) @item @strong{Purpose:}
rinvar_lib.tex(,12)       Invariant Rings of Reductive Groups
rinvar_lib.tex(,13) @item @strong{Author:}
rinvar_lib.tex(,14) Thomas Bayer, tbayer@@in.tum.de
rinvar_lib.tex(,15) @*http://wwwmayr.informatik.tu-muenchen.de/personen/bayert/
rinvar_lib.tex(,16) Current Adress: Institut fuer Informatik, TU Muenchen
rinvar_lib.tex(,17) 
rinvar_lib.tex(,18) @item @strong{Overview:}
rinvar_lib.tex(,19) Implementation based on Derksen's algorithm. Written in the frame of the
rinvar_lib.tex(,20) diploma thesis (advisor: Prof. Gert-Martin Greuel) 'Computations of moduli
rinvar_lib.tex(,21) spaces of semiquasihomogeneous singularities and an implementation in Singular'
rinvar_lib.tex(,22) 
rinvar_lib.tex(,23) @end table
rinvar_lib.tex(,24) 
rinvar_lib.tex(,25) @strong{Procedures:}
rinvar_lib.tex(,26) @menu
rinvar_lib.tex(,27) * HilbertSeries:: Hilbert series of the ideal I w.r.t. weight w
rinvar_lib.tex(,28) * HilbertWeights:: weighted degrees of the generators of I
rinvar_lib.tex(,29) * ImageVariety:: ideal of the image variety F(variety(I))
rinvar_lib.tex(,30) * ImageGroup:: ideal of G w.r.t. the induced representation
rinvar_lib.tex(,31) * InvariantRing:: generators of the invariant ring of G
rinvar_lib.tex(,32) * InvariantQ:: decide if f is invariant w.r.t. G
rinvar_lib.tex(,33) * LinearizeAction:: linearization of the action 'Gaction' of G
rinvar_lib.tex(,34) * LinearActionQ:: decide if action is linear in var(s..nvars)
rinvar_lib.tex(,35) * LinearCombinationQ:: decide if f is in the linear hull of 'base'
rinvar_lib.tex(,36) * MinimalDecomposition:: minimal decomposition of f (like coef)
rinvar_lib.tex(,37) * NullCone:: ideal of the null cone of the action 'act' of G
rinvar_lib.tex(,38) * ReynoldsImage:: image of f under the Reynolds operator 'RO'
rinvar_lib.tex(,39) * ReynoldsOperator:: Reynolds operator of the group G
rinvar_lib.tex(,40) * SimplifyIdeal:: simplify the ideal I (try to reduce variables)
rinvar_lib.tex(,41) * TransferIdeal:: transfer the ideal 'name' from R to basering
rinvar_lib.tex(,42) @end menu
rinvar_lib.tex(,43) @c inserted refs from d2t_singular/rinvar_lib.doc:41
rinvar_lib.tex(,56) @c end inserted refs from d2t_singular/rinvar_lib.doc:41
rinvar_lib.tex(,57) 
rinvar_lib.tex(,58) @c ---end content LibInfo---
rinvar_lib.tex(,59) 
rinvar_lib.tex(,60) @c ------------------- HilbertSeries -------------
rinvar_lib.tex(,61) @node HilbertSeries, HilbertWeights,, rinvar_lib
rinvar_lib.tex(,62) @subsubsection HilbertSeries
rinvar_lib.tex(,63) @cindex HilbertSeries
rinvar_lib.tex(,64) @c ---content HilbertSeries---
rinvar_lib.tex(,65) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,66) 
rinvar_lib.tex(,67) @table @asis
rinvar_lib.tex(,68) @item @strong{Usage:}
rinvar_lib.tex(,69) HilbertSeries(I, w); ideal I, intvec wt
rinvar_lib.tex(,70) 
rinvar_lib.tex(,71) @item @strong{Purpose:}
rinvar_lib.tex(,72) compute the polynomial p of the Hilbert Series,represented by p/q, of
rinvar_lib.tex(,73) the ring K[t_1,...,t_m,y_1,...,y_r]/I1 where 'w' are the weights of
rinvar_lib.tex(,74) the variables, computed, e.g., by 'HilbertWeights', 'I1' is of the
rinvar_lib.tex(,75) form I[1] - y_1,...,I[r] - y_r and is quasihomogeneous w.r.t. 'w'
rinvar_lib.tex(,76) 
rinvar_lib.tex(,77) @item @strong{Return:}
rinvar_lib.tex(,78) intvec
rinvar_lib.tex(,79) 
rinvar_lib.tex(,80) @item @strong{Note:}
rinvar_lib.tex(,81) the leading 0 of the result does not belong to p, but is needed in
rinvar_lib.tex(,82) the hilbert-driven 'std'.
rinvar_lib.tex(,83) 
rinvar_lib.tex(,84) @end table
rinvar_lib.tex(,85) @c ---end content HilbertSeries---
rinvar_lib.tex(,86) 
rinvar_lib.tex(,87) @c ------------------- HilbertWeights -------------
rinvar_lib.tex(,88) @node HilbertWeights, ImageVariety, HilbertSeries, rinvar_lib
rinvar_lib.tex(,89) @subsubsection HilbertWeights
rinvar_lib.tex(,90) @cindex HilbertWeights
rinvar_lib.tex(,91) @c ---content HilbertWeights---
rinvar_lib.tex(,92) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,93) 
rinvar_lib.tex(,94) @table @asis
rinvar_lib.tex(,95) @item @strong{Purpose:}
rinvar_lib.tex(,96) compute the weights of the "slack" variables needed for the
rinvar_lib.tex(,97) computation of the algebraic relations of the generators of 'I' s.t.
rinvar_lib.tex(,98) the Hilbert driven 'std' can be used.
rinvar_lib.tex(,99) 
rinvar_lib.tex(,100) @item @strong{Return:}
rinvar_lib.tex(,101) intvec
rinvar_lib.tex(,102) 
rinvar_lib.tex(,103) @item @strong{Assume:}
rinvar_lib.tex(,104) basering = K[t_1,...,t_m,...], 'I' is quasihomogeneous w.r.t. 'w' and
rinvar_lib.tex(,105) contains only polynomials in t_1,...,t_m
rinvar_lib.tex(,106) 
rinvar_lib.tex(,107) @end table
rinvar_lib.tex(,108) @c ---end content HilbertWeights---
rinvar_lib.tex(,109) 
rinvar_lib.tex(,110) @c ------------------- ImageVariety -------------
rinvar_lib.tex(,111) @node ImageVariety, ImageGroup, HilbertWeights, rinvar_lib
rinvar_lib.tex(,112) @subsubsection ImageVariety
rinvar_lib.tex(,113) @cindex ImageVariety
rinvar_lib.tex(,114) @c ---content ImageVariety---
rinvar_lib.tex(,115) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,116) 
rinvar_lib.tex(,117) @table @asis
rinvar_lib.tex(,118) @item @strong{Usage:}
rinvar_lib.tex(,119) ImageVariety(ideal I, F [, w]);ideal I; F is a list/ideal, intvec w.
rinvar_lib.tex(,120) 
rinvar_lib.tex(,121) @item @strong{Purpose:}
rinvar_lib.tex(,122) compute the Zariski closure of the image of the variety of I under
rinvar_lib.tex(,123) the morphism F.
rinvar_lib.tex(,124) 
rinvar_lib.tex(,125) @item @strong{Note:}
rinvar_lib.tex(,126) if 'I' and 'F' are quasihomogeneous w.r.t. 'w' then the Hilbert-driven
rinvar_lib.tex(,127) 'std' is used.
rinvar_lib.tex(,128) 
rinvar_lib.tex(,129) @item @strong{Return:}
rinvar_lib.tex(,130) polynomial ring over the same ground field, containing the ideal
rinvar_lib.tex(,131) 'imageid'. The variables are Y(1),...,Y(k) where k = size(F)
rinvar_lib.tex(,132) - 'imageid' is the ideal of the Zariski closure of F(X) where
rinvar_lib.tex(,133) X is the variety of I.
rinvar_lib.tex(,134) 
rinvar_lib.tex(,135) @end table
rinvar_lib.tex(,136) @strong{Example:}
rinvar_lib.tex(,137) @smallexample
rinvar_lib.tex(,138) @c computed example ImageVariety d2t_singular/rinvar_lib.doc:125 
rinvar_lib.tex(,139) LIB "rinvar.lib";
rinvar_lib.tex(,140) ring B   = 0,(x,y),dp;
rinvar_lib.tex(,141) ideal I  = x4 - y4;
rinvar_lib.tex(,142) ideal F  = x2, y2, x*y;
rinvar_lib.tex(,143) def R = ImageVariety(I, F);
rinvar_lib.tex(,144) setring R;
rinvar_lib.tex(,145) imageid;
rinvar_lib.tex(,146) @expansion{} imageid[1]=Y(1)*Y(2)-Y(3)^2
rinvar_lib.tex(,147) @expansion{} imageid[2]=Y(1)^2-Y(2)^2
rinvar_lib.tex(,148) @expansion{} imageid[3]=Y(2)^3-Y(1)*Y(3)^2
rinvar_lib.tex(,149) @c end example ImageVariety d2t_singular/rinvar_lib.doc:125
rinvar_lib.tex(,150) @end smallexample
rinvar_lib.tex(,151) @c ---end content ImageVariety---
rinvar_lib.tex(,152) 
rinvar_lib.tex(,153) @c ------------------- ImageGroup -------------
rinvar_lib.tex(,154) @node ImageGroup, InvariantRing, ImageVariety, rinvar_lib
rinvar_lib.tex(,155) @subsubsection ImageGroup
rinvar_lib.tex(,156) @cindex ImageGroup
rinvar_lib.tex(,157) @c ---content ImageGroup---
rinvar_lib.tex(,158) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,159) 
rinvar_lib.tex(,160) @table @asis
rinvar_lib.tex(,161) @item @strong{Usage:}
rinvar_lib.tex(,162) ImageGroup(G, action); ideal G, action;
rinvar_lib.tex(,163) 
rinvar_lib.tex(,164) @item @strong{Purpose:}
rinvar_lib.tex(,165) compute the ideal of the image of G in GL(m,K) induced by the linear
rinvar_lib.tex(,166) action 'action', where G is an algebraic group and 'action' defines
rinvar_lib.tex(,167) an action of G on K^m (size(action) = m).
rinvar_lib.tex(,168) 
rinvar_lib.tex(,169) @item @strong{Return:}
rinvar_lib.tex(,170) ring, a polynomial ring over the same ground field as the basering,
rinvar_lib.tex(,171) containing the ideals 'groupid' and 'actionid'.
rinvar_lib.tex(,172) @*- 'groupid' is the ideal of the image of G (order <= order of G)
rinvar_lib.tex(,173) - 'actionid' defines the linear action of 'groupid' on K^m.
rinvar_lib.tex(,174) 
rinvar_lib.tex(,175) @item @strong{Note:}
rinvar_lib.tex(,176) 'action' and 'actionid' have the same orbits
rinvar_lib.tex(,177) @*all variables which give only rise to 0's in the m x m matrices of G
rinvar_lib.tex(,178) have been omitted.
rinvar_lib.tex(,179) 
rinvar_lib.tex(,180) @item @strong{Assume:}
rinvar_lib.tex(,181) basering K[s(1..r),t(1..m)] has r + m variables, G is the ideal of an
rinvar_lib.tex(,182) algebraic group and F is an action of G on K^m. G contains only the
rinvar_lib.tex(,183) variables s(1)...s(r). The action 'action' is given by polynomials
rinvar_lib.tex(,184) f_1,...,f_m in basering, s.t. on the ring level we have
rinvar_lib.tex(,185) K[t_1,...,t_m] --> K[s_1,...,s_r,t_1,...,t_m]/G
rinvar_lib.tex(,186) @*t_i --> f_i(s_1,...,s_r,t_1,...,t_m)
rinvar_lib.tex(,187) 
rinvar_lib.tex(,188) @end table
rinvar_lib.tex(,189) @strong{Example:}
rinvar_lib.tex(,190) @smallexample
rinvar_lib.tex(,191) @c computed example ImageGroup d2t_singular/rinvar_lib.doc:175 
rinvar_lib.tex(,192) LIB "rinvar.lib";
rinvar_lib.tex(,193) ring B   = 0,(s(1..2), t(1..2)),dp;
rinvar_lib.tex(,194) ideal G = s(1)^3-1, s(2)^10-1;
rinvar_lib.tex(,195) ideal action = s(1)*s(2)^8*t(1), s(1)*s(2)^7*t(2);
rinvar_lib.tex(,196) def R = ImageGroup(G, action);
rinvar_lib.tex(,197) setring R;
rinvar_lib.tex(,198) groupid;
rinvar_lib.tex(,199) @expansion{} groupid[1]=-s(1)+s(2)^4
rinvar_lib.tex(,200) @expansion{} groupid[2]=s(1)^8-s(2)^2
rinvar_lib.tex(,201) @expansion{} groupid[3]=s(1)^7*s(2)^2-1
rinvar_lib.tex(,202) actionid;
rinvar_lib.tex(,203) @expansion{} actionid[1]=s(1)*t(1)
rinvar_lib.tex(,204) @expansion{} actionid[2]=s(2)*t(2)
rinvar_lib.tex(,205) @c end example ImageGroup d2t_singular/rinvar_lib.doc:175
rinvar_lib.tex(,206) @end smallexample
rinvar_lib.tex(,207) @c ---end content ImageGroup---
rinvar_lib.tex(,208) 
rinvar_lib.tex(,209) @c ------------------- InvariantRing -------------
rinvar_lib.tex(,210) @node InvariantRing, InvariantQ, ImageGroup, rinvar_lib
rinvar_lib.tex(,211) @subsubsection InvariantRing
rinvar_lib.tex(,212) @cindex InvariantRing
rinvar_lib.tex(,213) @c ---content InvariantRing---
rinvar_lib.tex(,214) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,215) 
rinvar_lib.tex(,216) @table @asis
rinvar_lib.tex(,217) @item @strong{Usage:}
rinvar_lib.tex(,218) InvariantRing(G, Gact [, opt]); ideal G, Gact; int opt
rinvar_lib.tex(,219) 
rinvar_lib.tex(,220) @item @strong{Purpose:}
rinvar_lib.tex(,221) compute generators of the invariant ring of G w.r.t. the action 'Gact'
rinvar_lib.tex(,222) 
rinvar_lib.tex(,223) @item @strong{Assume:}
rinvar_lib.tex(,224) G is a finite group and 'Gact' is a linear action.
rinvar_lib.tex(,225) 
rinvar_lib.tex(,226) @item @strong{Return:}
rinvar_lib.tex(,227) polynomial ring over a simple extension of the ground field of the
rinvar_lib.tex(,228) basering (the extension might be trivial), containing the ideals
rinvar_lib.tex(,229) 'invars' and 'groupid' and the poly 'newA'
rinvar_lib.tex(,230) @*- 'invars' contains the algebra-generators of the invariant ring
rinvar_lib.tex(,231) - 'groupid' is the ideal of G in the new ring
rinvar_lib.tex(,232) @*- 'newA' if the minpoly changes this is the new representation of the
rinvar_lib.tex(,233) algebraic number, otherwise it is set to 'a'.
rinvar_lib.tex(,234) 
rinvar_lib.tex(,235) @item @strong{Note:}
rinvar_lib.tex(,236) the delivered ring might have a different minimal polynomial
rinvar_lib.tex(,237) 
rinvar_lib.tex(,238) @end table
rinvar_lib.tex(,239) @strong{Example:}
rinvar_lib.tex(,240) @smallexample
rinvar_lib.tex(,241) @c computed example InvariantRing d2t_singular/rinvar_lib.doc:220 
rinvar_lib.tex(,242) LIB "rinvar.lib";
rinvar_lib.tex(,243) ring B = 0, (s(1..2), t(1..2)), dp;
rinvar_lib.tex(,244) ideal G = -s(1)+s(2)^3, s(1)^4-1;
rinvar_lib.tex(,245) ideal action = s(1)*t(1), s(2)*t(2);
rinvar_lib.tex(,246) def R = InvariantRing(std(G), action);
rinvar_lib.tex(,247) setring R;
rinvar_lib.tex(,248) invars;
rinvar_lib.tex(,249) @expansion{} invars[1]=t(1)^4
rinvar_lib.tex(,250) @expansion{} invars[2]=t(1)^3*t(2)^3
rinvar_lib.tex(,251) @expansion{} invars[3]=t(1)^2*t(2)^6
rinvar_lib.tex(,252) @expansion{} invars[4]=t(1)*t(2)^9
rinvar_lib.tex(,253) @expansion{} invars[5]=t(2)^12
rinvar_lib.tex(,254) @c end example InvariantRing d2t_singular/rinvar_lib.doc:220
rinvar_lib.tex(,255) @end smallexample
rinvar_lib.tex(,256) @c ---end content InvariantRing---
rinvar_lib.tex(,257) 
rinvar_lib.tex(,258) @c ------------------- InvariantQ -------------
rinvar_lib.tex(,259) @node InvariantQ, LinearizeAction, InvariantRing, rinvar_lib
rinvar_lib.tex(,260) @subsubsection InvariantQ
rinvar_lib.tex(,261) @cindex InvariantQ
rinvar_lib.tex(,262) @c ---content InvariantQ---
rinvar_lib.tex(,263) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,264) 
rinvar_lib.tex(,265) @table @asis
rinvar_lib.tex(,266) @item @strong{Usage:}
rinvar_lib.tex(,267) InvariantQ(f, G, action); poly f; ideal G, action
rinvar_lib.tex(,268) 
rinvar_lib.tex(,269) @item @strong{Purpose:}
rinvar_lib.tex(,270) check if the polynomial f is invariant w.r.t. G where G acts via
rinvar_lib.tex(,271) 'action' on K^m.
rinvar_lib.tex(,272) 
rinvar_lib.tex(,273) @item @strong{Assume:}
rinvar_lib.tex(,274) basering = K[s_1,...,s_m,t_1,...,t_m] where K = Q of K = Q(a) and
rinvar_lib.tex(,275) minpoly != 0, f contains only t_1,...,t_m, G is the ideal of an
rinvar_lib.tex(,276) algebraic group and a standard basis.
rinvar_lib.tex(,277) 
rinvar_lib.tex(,278) @item @strong{Return:}
rinvar_lib.tex(,279) int;
rinvar_lib.tex(,280) @*0 if f is not invariant,
rinvar_lib.tex(,281) @*1 if f is invariant
rinvar_lib.tex(,282) 
rinvar_lib.tex(,283) @item @strong{Note:}
rinvar_lib.tex(,284) G need not be finite
rinvar_lib.tex(,285) 
rinvar_lib.tex(,286) @end table
rinvar_lib.tex(,287) @c ---end content InvariantQ---
rinvar_lib.tex(,288) 
rinvar_lib.tex(,289) @c ------------------- LinearizeAction -------------
rinvar_lib.tex(,290) @node LinearizeAction, LinearActionQ, InvariantQ, rinvar_lib
rinvar_lib.tex(,291) @subsubsection LinearizeAction
rinvar_lib.tex(,292) @cindex LinearizeAction
rinvar_lib.tex(,293) @c ---content LinearizeAction---
rinvar_lib.tex(,294) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,295) 
rinvar_lib.tex(,296) @table @asis
rinvar_lib.tex(,297) @item @strong{Usage:}
rinvar_lib.tex(,298) LinearizeAction(G,action,r); ideal G, action; int r
rinvar_lib.tex(,299) 
rinvar_lib.tex(,300) @item @strong{Purpose:}
rinvar_lib.tex(,301) linearize the group action 'action' and find an equivariant embedding
rinvar_lib.tex(,302) of K^m where m = size(action).
rinvar_lib.tex(,303) 
rinvar_lib.tex(,304) @item @strong{Assume:}
rinvar_lib.tex(,305) G contains only variables var(1..r) (r = nrs)
rinvar_lib.tex(,306) @*basering = K[s(1..r),t(1..m)], K = Q or K = Q(a) and minpoly != 0.
rinvar_lib.tex(,307) 
rinvar_lib.tex(,308) @item @strong{Return:}
rinvar_lib.tex(,309) polynomial ring containing the ideals 'actionid', 'embedid', 'groupid'
rinvar_lib.tex(,310) - 'actionid' is the ideal defining the linearized action of G
rinvar_lib.tex(,311) - 'embedid' is a parameterization of an equivariant embedding (closed)
rinvar_lib.tex(,312) - 'groupid' is the ideal of G in the new ring
rinvar_lib.tex(,313) 
rinvar_lib.tex(,314) @item @strong{Note:}
rinvar_lib.tex(,315) set printlevel > 0 to see a trace
rinvar_lib.tex(,316) 
rinvar_lib.tex(,317) @end table
rinvar_lib.tex(,318) @strong{Example:}
rinvar_lib.tex(,319) @smallexample
rinvar_lib.tex(,320) @c computed example LinearizeAction d2t_singular/rinvar_lib.doc:294 
rinvar_lib.tex(,321) LIB "rinvar.lib";
rinvar_lib.tex(,322) ring B   = 0,(s(1..5), t(1..3)),dp;
rinvar_lib.tex(,323) ideal G =  s(3)-s(4), s(2)-s(5), s(4)*s(5), s(1)^2*s(4)+s(1)^2*s(5)-1, s(1)^2*s(5)^2-s(5), s(4)^4-s(5)^4+s(1)^2, s(1)^4+s(4)^3-s(5)^3, s(5)^5-s(1)^2*s(5);
rinvar_lib.tex(,324) ideal action = -s(4)*t(1)+s(5)*t(1), -s(4)^2*t(2)+2*s(4)^2*t(3)^2+s(5)^2*t(2), s(4)*t(3)+s(5)*t(3);
rinvar_lib.tex(,325) LinearActionQ(action, 5);
rinvar_lib.tex(,326) @expansion{} 0
rinvar_lib.tex(,327) def R = LinearizeAction(G, action, 5);
rinvar_lib.tex(,328) setring R;
rinvar_lib.tex(,329) R;
rinvar_lib.tex(,330) @expansion{} //   characteristic : 0
rinvar_lib.tex(,331) @expansion{} //   number of vars : 9
rinvar_lib.tex(,332) @expansion{} //        block   1 : ordering dp
rinvar_lib.tex(,333) @expansion{} //                  : names    s(1) s(2) s(3) s(4) s(5) t(1) t(2) t(3) t(\
rinvar_lib.tex(,334)    4) 
rinvar_lib.tex(,335) @expansion{} //        block   2 : ordering C
rinvar_lib.tex(,336) actionid;
rinvar_lib.tex(,337) @expansion{} actionid[1]=-s(4)*t(1)+s(5)*t(1)
rinvar_lib.tex(,338) @expansion{} actionid[2]=-s(4)^2*t(2)+s(5)^2*t(2)+2*s(4)^2*t(4)
rinvar_lib.tex(,339) @expansion{} actionid[3]=s(4)*t(3)+s(5)*t(3)
rinvar_lib.tex(,340) @expansion{} actionid[4]=s(4)^2*t(4)+s(5)^2*t(4)
rinvar_lib.tex(,341) embedid;
rinvar_lib.tex(,342) @expansion{} embedid[1]=t(1)
rinvar_lib.tex(,343) @expansion{} embedid[2]=t(2)
rinvar_lib.tex(,344) @expansion{} embedid[3]=t(3)
rinvar_lib.tex(,345) @expansion{} embedid[4]=t(3)^2
rinvar_lib.tex(,346) groupid;
rinvar_lib.tex(,347) @expansion{} groupid[1]=s(3)-s(4)
rinvar_lib.tex(,348) @expansion{} groupid[2]=s(2)-s(5)
rinvar_lib.tex(,349) @expansion{} groupid[3]=s(4)*s(5)
rinvar_lib.tex(,350) @expansion{} groupid[4]=s(1)^2*s(4)+s(1)^2*s(5)-1
rinvar_lib.tex(,351) @expansion{} groupid[5]=s(1)^2*s(5)^2-s(5)
rinvar_lib.tex(,352) @expansion{} groupid[6]=s(4)^4-s(5)^4+s(1)^2
rinvar_lib.tex(,353) @expansion{} groupid[7]=s(1)^4+s(4)^3-s(5)^3
rinvar_lib.tex(,354) @expansion{} groupid[8]=s(5)^5-s(1)^2*s(5)
rinvar_lib.tex(,355) LinearActionQ(actionid, 5);
rinvar_lib.tex(,356) @expansion{} 1
rinvar_lib.tex(,357) @c end example LinearizeAction d2t_singular/rinvar_lib.doc:294
rinvar_lib.tex(,358) @end smallexample
rinvar_lib.tex(,359) @c ---end content LinearizeAction---
rinvar_lib.tex(,360) 
rinvar_lib.tex(,361) @c ------------------- LinearActionQ -------------
rinvar_lib.tex(,362) @node LinearActionQ, LinearCombinationQ, LinearizeAction, rinvar_lib
rinvar_lib.tex(,363) @subsubsection LinearActionQ
rinvar_lib.tex(,364) @cindex LinearActionQ
rinvar_lib.tex(,365) @c ---content LinearActionQ---
rinvar_lib.tex(,366) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,367) 
rinvar_lib.tex(,368) @table @asis
rinvar_lib.tex(,369) @item @strong{Usage:}
rinvar_lib.tex(,370) LinearActionQ(action,nrs,nrt); ideal action, int nrs
rinvar_lib.tex(,371) 
rinvar_lib.tex(,372) @item @strong{Purpose:}
rinvar_lib.tex(,373) check if the action defined by 'action' is linear w.r.t. the variables
rinvar_lib.tex(,374) var(nrs + 1...nvars(basering)).
rinvar_lib.tex(,375) 
rinvar_lib.tex(,376) @item @strong{Return:}
rinvar_lib.tex(,377) 0 action not linear
rinvar_lib.tex(,378) @*1 action is linear
rinvar_lib.tex(,379) 
rinvar_lib.tex(,380) @end table
rinvar_lib.tex(,381) @strong{Example:}
rinvar_lib.tex(,382) @smallexample
rinvar_lib.tex(,383) @c computed example LinearActionQ d2t_singular/rinvar_lib.doc:333 
rinvar_lib.tex(,384) LIB "rinvar.lib";
rinvar_lib.tex(,385) ring R   = 0,(s(1..5), t(1..3)),dp;
rinvar_lib.tex(,386) ideal G =  s(3)-s(4), s(2)-s(5), s(4)*s(5), s(1)^2*s(4)+s(1)^2*s(5)-1, s(1)^2*s(5)^2-s(5), s(4)^4-s(5)^4+s(1)^2, s(1)^4+s(4)^3-s(5)^3, s(5)^5-s(1)^2*s(5);
rinvar_lib.tex(,387) ideal Gaction = -s(4)*t(1)+s(5)*t(1), -s(4)^2*t(2)+2*s(4)^2*t(3)^2+s(5)^2*t(2), s(4)*t(3)+s(5)*t(3);
rinvar_lib.tex(,388) LinearActionQ(Gaction, 5, 3);
rinvar_lib.tex(,389) @expansion{} // ** too many arguments for LinearActionQ
rinvar_lib.tex(,390) @expansion{} 0
rinvar_lib.tex(,391) @c end example LinearActionQ d2t_singular/rinvar_lib.doc:333
rinvar_lib.tex(,392) @end smallexample
rinvar_lib.tex(,393) @c ---end content LinearActionQ---
rinvar_lib.tex(,394) 
rinvar_lib.tex(,395) @c ------------------- LinearCombinationQ -------------
rinvar_lib.tex(,396) @node LinearCombinationQ, MinimalDecomposition, LinearActionQ, rinvar_lib
rinvar_lib.tex(,397) @subsubsection LinearCombinationQ
rinvar_lib.tex(,398) @cindex LinearCombinationQ
rinvar_lib.tex(,399) @c ---content LinearCombinationQ---
rinvar_lib.tex(,400) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,401) 
rinvar_lib.tex(,402) @table @asis
rinvar_lib.tex(,403) @item @strong{Usage:}
rinvar_lib.tex(,404) LinearCombination(I, f); ideal I, poly f
rinvar_lib.tex(,405) 
rinvar_lib.tex(,406) @item @strong{Purpose:}
rinvar_lib.tex(,407) test if f can be written as a linear combination of the generators of I.
rinvar_lib.tex(,408) 
rinvar_lib.tex(,409) @item @strong{Return:}
rinvar_lib.tex(,410) 0 f is not a linear combination
rinvar_lib.tex(,411) @*1 f is a linear combination
rinvar_lib.tex(,412) 
rinvar_lib.tex(,413) @end table
rinvar_lib.tex(,414) @c ---end content LinearCombinationQ---
rinvar_lib.tex(,415) 
rinvar_lib.tex(,416) @c ------------------- MinimalDecomposition -------------
rinvar_lib.tex(,417) @node MinimalDecomposition, NullCone, LinearCombinationQ, rinvar_lib
rinvar_lib.tex(,418) @subsubsection MinimalDecomposition
rinvar_lib.tex(,419) @cindex MinimalDecomposition
rinvar_lib.tex(,420) @c ---content MinimalDecomposition---
rinvar_lib.tex(,421) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,422) 
rinvar_lib.tex(,423) @table @asis
rinvar_lib.tex(,424) @item @strong{Usage:}
rinvar_lib.tex(,425) MinimalDecomposition(f,a,b); poly f; int a, b.
rinvar_lib.tex(,426) 
rinvar_lib.tex(,427) @item @strong{Purpose:}
rinvar_lib.tex(,428) decompose f as a sum M[1,1]*M[2,1] + ... + M[1,r]*M[2,r] where M[1,i]
rinvar_lib.tex(,429) contains only s(1..a), M[2,i] contains only t(1...b) s.t. r is minimal
rinvar_lib.tex(,430) 
rinvar_lib.tex(,431) @item @strong{Assume:}
rinvar_lib.tex(,432) f polynomial in K[s(1..a),t(1..b)], K = Q or K = Q(a) and minpoly != 0
rinvar_lib.tex(,433) 
rinvar_lib.tex(,434) @item @strong{Return:}
rinvar_lib.tex(,435) 2 x r matrix M s.t. f = M[1,1]*M[2,1] + ... + M[1,r]*M[2,r]
rinvar_lib.tex(,436) 
rinvar_lib.tex(,437) @end table
rinvar_lib.tex(,438) @strong{Example:}
rinvar_lib.tex(,439) @smallexample
rinvar_lib.tex(,440) @c computed example MinimalDecomposition d2t_singular/rinvar_lib.doc:388 
rinvar_lib.tex(,441) LIB "rinvar.lib";
rinvar_lib.tex(,442) ring R = 0, (s(1..2), t(1..2)), dp;
rinvar_lib.tex(,443) poly h = s(1)*(t(1) + t(1)^2) +  (t(2) + t(2)^2)*(s(1)^2 + s(2));
rinvar_lib.tex(,444) matrix M = MinimalDecomposition(h, 2, 2);
rinvar_lib.tex(,445) M;
rinvar_lib.tex(,446) @expansion{} M[1,1]=s(1)^2+s(2)
rinvar_lib.tex(,447) @expansion{} M[1,2]=s(1)
rinvar_lib.tex(,448) @expansion{} M[2,1]=t(2)^2+t(2)
rinvar_lib.tex(,449) @expansion{} M[2,2]=t(1)^2+t(1)
rinvar_lib.tex(,450) M[1,1]*M[2,1] + M[1,2]*M[2,2] - h;
rinvar_lib.tex(,451) @expansion{} 0
rinvar_lib.tex(,452) @c end example MinimalDecomposition d2t_singular/rinvar_lib.doc:388
rinvar_lib.tex(,453) @end smallexample
rinvar_lib.tex(,454) @c ---end content MinimalDecomposition---
rinvar_lib.tex(,455) 
rinvar_lib.tex(,456) @c ------------------- NullCone -------------
rinvar_lib.tex(,457) @node NullCone, ReynoldsImage, MinimalDecomposition, rinvar_lib
rinvar_lib.tex(,458) @subsubsection NullCone
rinvar_lib.tex(,459) @cindex NullCone
rinvar_lib.tex(,460) @c ---content NullCone---
rinvar_lib.tex(,461) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,462) 
rinvar_lib.tex(,463) @table @asis
rinvar_lib.tex(,464) @item @strong{Usage:}
rinvar_lib.tex(,465) NullCone(G, action); ideal G, action
rinvar_lib.tex(,466) 
rinvar_lib.tex(,467) @item @strong{Purpose:}
rinvar_lib.tex(,468) compute the ideal of the null cone of the linear action of G on K^n,
rinvar_lib.tex(,469) given by 'action', by means of Derksen's algorithm
rinvar_lib.tex(,470) 
rinvar_lib.tex(,471) @item @strong{Assume:}
rinvar_lib.tex(,472) basering = K[s(1..r),t(1..n)], K = Q or K = Q(a) and minpoly != 0,
rinvar_lib.tex(,473) G is an ideal of a reductive algebraic group in K[s(1..r)],
rinvar_lib.tex(,474) 'action' is a linear group action of G on K^n (n = ncols(action))
rinvar_lib.tex(,475) 
rinvar_lib.tex(,476) @item @strong{Return:}
rinvar_lib.tex(,477) ideal of the null cone of G.
rinvar_lib.tex(,478) 
rinvar_lib.tex(,479) @item @strong{Note:}
rinvar_lib.tex(,480) the generators of the null cone are homogeneous, but i.g. not invariant
rinvar_lib.tex(,481) 
rinvar_lib.tex(,482) @end table
rinvar_lib.tex(,483) @strong{Example:}
rinvar_lib.tex(,484) @smallexample
rinvar_lib.tex(,485) @c computed example NullCone d2t_singular/rinvar_lib.doc:428 
rinvar_lib.tex(,486) LIB "rinvar.lib";
rinvar_lib.tex(,487) ring R = 0, (s(1..2), x, y), dp;
rinvar_lib.tex(,488) ideal G = -s(1)+s(2)^3, s(1)^4-1;
rinvar_lib.tex(,489) ideal action = s(1)*x, s(2)*y;
rinvar_lib.tex(,490) ideal inv = NullCone(G, action);
rinvar_lib.tex(,491) inv;
rinvar_lib.tex(,492) @expansion{} inv[1]=x^4
rinvar_lib.tex(,493) @expansion{} inv[2]=x^3*y^3
rinvar_lib.tex(,494) @expansion{} inv[3]=x^2*y^6
rinvar_lib.tex(,495) @expansion{} inv[4]=x*y^9
rinvar_lib.tex(,496) @expansion{} inv[5]=y^12
rinvar_lib.tex(,497) @c end example NullCone d2t_singular/rinvar_lib.doc:428
rinvar_lib.tex(,498) @end smallexample
rinvar_lib.tex(,499) @c ---end content NullCone---
rinvar_lib.tex(,500) 
rinvar_lib.tex(,501) @c ------------------- ReynoldsImage -------------
rinvar_lib.tex(,502) @node ReynoldsImage, ReynoldsOperator, NullCone, rinvar_lib
rinvar_lib.tex(,503) @subsubsection ReynoldsImage
rinvar_lib.tex(,504) @cindex ReynoldsImage
rinvar_lib.tex(,505) @c ---content ReynoldsImage---
rinvar_lib.tex(,506) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,507) 
rinvar_lib.tex(,508) @table @asis
rinvar_lib.tex(,509) @item @strong{Usage:}
rinvar_lib.tex(,510) ReynoldsImage(RO, f); list RO, poly f
rinvar_lib.tex(,511) 
rinvar_lib.tex(,512) @item @strong{Purpose:}
rinvar_lib.tex(,513) compute the Reynolds image of the polynomial f where RO represents
rinvar_lib.tex(,514) the Reynolds operator
rinvar_lib.tex(,515) 
rinvar_lib.tex(,516) @item @strong{Return:}
rinvar_lib.tex(,517) poly
rinvar_lib.tex(,518) 
rinvar_lib.tex(,519) @end table
rinvar_lib.tex(,520) @c ---end content ReynoldsImage---
rinvar_lib.tex(,521) 
rinvar_lib.tex(,522) @c ------------------- ReynoldsOperator -------------
rinvar_lib.tex(,523) @node ReynoldsOperator, SimplifyIdeal, ReynoldsImage, rinvar_lib
rinvar_lib.tex(,524) @subsubsection ReynoldsOperator
rinvar_lib.tex(,525) @cindex ReynoldsOperator
rinvar_lib.tex(,526) @c ---content ReynoldsOperator---
rinvar_lib.tex(,527) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,528) 
rinvar_lib.tex(,529) @table @asis
rinvar_lib.tex(,530) @item @strong{Usage:}
rinvar_lib.tex(,531) ReynoldsOperator(G, action [, opt); ideal G, action; int opt
rinvar_lib.tex(,532) 
rinvar_lib.tex(,533) @item @strong{Purpose:}
rinvar_lib.tex(,534) compute the Reynolds operator of the group G which act via 'action'
rinvar_lib.tex(,535) 
rinvar_lib.tex(,536) @item @strong{Return:}
rinvar_lib.tex(,537) polynomial ring R over a simple extension of the ground field of the
rinvar_lib.tex(,538) basering (the extension might be trivial), containing a list
rinvar_lib.tex(,539) 'ROelements', the ideals 'id', 'actionid' and the polynomial 'newA'.
rinvar_lib.tex(,540) R = K(a)[s(1..r),t(1..n)].
rinvar_lib.tex(,541) @*- 'ROelements' is a list of ideal, each ideal represents a
rinvar_lib.tex(,542) substitution map F : R -> R according to the zero-set of G
rinvar_lib.tex(,543) - 'id' is the ideal of G in the new ring
rinvar_lib.tex(,544) @*- 'newA' is the new representation of a' in terms of a. If the
rinvar_lib.tex(,545) basering does not contain a parameter then 'newA' = 'a'.
rinvar_lib.tex(,546) 
rinvar_lib.tex(,547) @item @strong{Assume:}
rinvar_lib.tex(,548) basering = K[s(1..r),t(1..n)], K = Q or K = Q(a') and minpoly != 0,
rinvar_lib.tex(,549) G is the ideal of a finite group in K[s(1..r)], 'action' is a linear
rinvar_lib.tex(,550) group action of G
rinvar_lib.tex(,551) 
rinvar_lib.tex(,552) @end table
rinvar_lib.tex(,553) @c ---end content ReynoldsOperator---
rinvar_lib.tex(,554) 
rinvar_lib.tex(,555) @c ------------------- SimplifyIdeal -------------
rinvar_lib.tex(,556) @node SimplifyIdeal, TransferIdeal, ReynoldsOperator, rinvar_lib
rinvar_lib.tex(,557) @subsubsection SimplifyIdeal
rinvar_lib.tex(,558) @cindex SimplifyIdeal
rinvar_lib.tex(,559) @c ---content SimplifyIdeal---
rinvar_lib.tex(,560) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,561) 
rinvar_lib.tex(,562) @table @asis
rinvar_lib.tex(,563) @item @strong{Purpose:}
rinvar_lib.tex(,564) simplify ideal I to the ideal I', do not change the names of the
rinvar_lib.tex(,565) first m variables, new ideal I' might contain less variables.
rinvar_lib.tex(,566) I' contains variables var(1..m)
rinvar_lib.tex(,567) 
rinvar_lib.tex(,568) @item @strong{Return:}
rinvar_lib.tex(,569) list
rinvar_lib.tex(,570) @*_[1] ideal I'
rinvar_lib.tex(,571) @*_[2] ideal representing a map phi to a ring with probably less vars. s.t.
rinvar_lib.tex(,572) phi(I) = I'
rinvar_lib.tex(,573) @*_[3] list of variables
rinvar_lib.tex(,574) @*_[4] list from 'elimpart'
rinvar_lib.tex(,575) 
rinvar_lib.tex(,576) @end table
rinvar_lib.tex(,577) @c ---end content SimplifyIdeal---
rinvar_lib.tex(,578) 
rinvar_lib.tex(,579) @c ------------------- TransferIdeal -------------
rinvar_lib.tex(,580) @node TransferIdeal,, SimplifyIdeal, rinvar_lib
rinvar_lib.tex(,581) @subsubsection TransferIdeal
rinvar_lib.tex(,582) @cindex TransferIdeal
rinvar_lib.tex(,583) @c ---content TransferIdeal---
rinvar_lib.tex(,584) Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).
rinvar_lib.tex(,585) 
rinvar_lib.tex(,586) @table @asis
rinvar_lib.tex(,587) @end table
rinvar_lib.tex(,588) @c ---end content TransferIdeal---
singular.texi(,527) @c ----------------------------------------------------------
singular.texi(,528) @node stratify_lib, ,rinvar_lib, Invariant theory
singular.texi(,529) @subsection stratify_lib
singular.texi(,530) @c include of docu for stratify.lib
stratify_lib.tex(,1) @c ---content LibInfo---
stratify_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/stratify_lib.doc
stratify_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/stratify_lib.doc INSTEAD
stratify_lib.tex(,4) @c library version: (1.7.2.4,2002/04/11)
stratify_lib.tex(,5) @c library file: ../Singular/LIB/stratify.lib
stratify_lib.tex(,6) @cindex stratify.lib
stratify_lib.tex(,7) @cindex stratify_lib
stratify_lib.tex(,8) @table @asis
stratify_lib.tex(,9) @item @strong{Library:}
stratify_lib.tex(,10) stratify.lib
stratify_lib.tex(,11) @item @strong{Purpose:}
stratify_lib.tex(,12)    Algorithmic Stratification for Unipotent Group-Actions
stratify_lib.tex(,13) @item @strong{Author:}
stratify_lib.tex(,14) Anne Fruehbis-Krueger, anne@@mathematik.uni-kl.de
stratify_lib.tex(,15) 
stratify_lib.tex(,16) @item @strong{Overview:}
stratify_lib.tex(,17) This library provides an implementation of the algorithm
stratify_lib.tex(,18) of Greuel and Pfister introduced in the article <Geometric
stratify_lib.tex(,19) quotients of unipotent group actions>.
stratify_lib.tex(,20) 
stratify_lib.tex(,21) @end table
stratify_lib.tex(,22) 
stratify_lib.tex(,23) @strong{Procedures:}
stratify_lib.tex(,24) @menu
stratify_lib.tex(,25) * prepMat:: list of submatrices corresp. to given filtration
stratify_lib.tex(,26) * stratify:: algorithmic stratification (main procedure)
stratify_lib.tex(,27) @end menu
stratify_lib.tex(,28) @c ---end content LibInfo---
stratify_lib.tex(,29) 
stratify_lib.tex(,30) @c ------------------- prepMat -------------
stratify_lib.tex(,31) @node prepMat, stratify,, stratify_lib
stratify_lib.tex(,32) @subsubsection prepMat
stratify_lib.tex(,33) @cindex prepMat
stratify_lib.tex(,34) @c ---content prepMat---
stratify_lib.tex(,35) Procedure from library @code{stratify.lib} (@pxref{stratify_lib}).
stratify_lib.tex(,36) 
stratify_lib.tex(,37) @table @asis
stratify_lib.tex(,38) @item @strong{Usage:}
stratify_lib.tex(,39) prepMat(M,wr,ws,step);
stratify_lib.tex(,40) @*where M is a matrix, wr is an intvec of size ncols(M),
stratify_lib.tex(,41) ws an intvec of size nrows(M) and step is an integer
stratify_lib.tex(,42) 
stratify_lib.tex(,43) @item @strong{Return:}
stratify_lib.tex(,44) 2 lists of submatrices corresponding to the filtrations
stratify_lib.tex(,45) specified by wr and ws
stratify_lib.tex(,46) @*the first list corresponds to the list for the filtration
stratify_lib.tex(,47) of AdA, i.e. the ranks of these matrices will be the r_i,
stratify_lib.tex(,48) the second one to the list for the filtration of L, i.e.
stratify_lib.tex(,49) the ranks of these matrices will be the s_i
stratify_lib.tex(,50) 
stratify_lib.tex(,51) @item @strong{Note:}
stratify_lib.tex(,52) * the entries of the matrix M are M_ij=delta_i(x_j),
stratify_lib.tex(,53) @** wr is used to determine what subset of the set of all dx_i is
stratify_lib.tex(,54) generating AdF^l(A):
stratify_lib.tex(,55) @*if (k-1)*step <= wr[i] < k*step, then dx_i is in the set of
stratify_lib.tex(,56) generators of AdF^l(A) for all l>=k and the i-th column
stratify_lib.tex(,57) of M appears in each submatrix starting from the k-th
stratify_lib.tex(,58) @** ws is used to determine what subset of the set of all delta_i
stratify_lib.tex(,59) is generating Z_l(L):
stratify_lib.tex(,60) @*if (k-1)*step <= ws[i] < k*step, then delta_i is in the set
stratify_lib.tex(,61) of generators of Z_l(A) for l < k and the i-th row of M
stratify_lib.tex(,62) appears in each submatrix up to the (k-1)th
stratify_lib.tex(,63) @** the entries of wr and ws as well as step should be positive
stratify_lib.tex(,64) integers
stratify_lib.tex(,65) 
stratify_lib.tex(,66) @end table
stratify_lib.tex(,67) @strong{Example:}
stratify_lib.tex(,68) @smallexample
stratify_lib.tex(,69) @c computed example prepMat d2t_singular/stratify_lib.doc:67 
stratify_lib.tex(,70) LIB "stratify.lib";
stratify_lib.tex(,71) ring r=0,(t(1..3)),dp;
stratify_lib.tex(,72) matrix M[2][3]=0,t(1),3*t(2),0,0,t(1);
stratify_lib.tex(,73) print(M);
stratify_lib.tex(,74) @expansion{} 0,t(1),3*t(2),
stratify_lib.tex(,75) @expansion{} 0,0,   t(1)   
stratify_lib.tex(,76) intvec wr=1,3,5;
stratify_lib.tex(,77) intvec ws=2,4;
stratify_lib.tex(,78) int step=2;
stratify_lib.tex(,79) prepMat(M,wr,ws,step);
stratify_lib.tex(,80) @expansion{} [1]:
stratify_lib.tex(,81) @expansion{}    [1]:
stratify_lib.tex(,82) @expansion{}       _[1,1]=0
stratify_lib.tex(,83) @expansion{}       _[2,1]=0
stratify_lib.tex(,84) @expansion{}    [2]:
stratify_lib.tex(,85) @expansion{}       _[1,1]=0
stratify_lib.tex(,86) @expansion{}       _[1,2]=t(1)
stratify_lib.tex(,87) @expansion{}       _[2,1]=0
stratify_lib.tex(,88) @expansion{}       _[2,2]=0
stratify_lib.tex(,89) @expansion{}    [3]:
stratify_lib.tex(,90) @expansion{}       _[1,1]=0
stratify_lib.tex(,91) @expansion{}       _[1,2]=t(1)
stratify_lib.tex(,92) @expansion{}       _[1,3]=3*t(2)
stratify_lib.tex(,93) @expansion{}       _[2,1]=0
stratify_lib.tex(,94) @expansion{}       _[2,2]=0
stratify_lib.tex(,95) @expansion{}       _[2,3]=t(1)
stratify_lib.tex(,96) @expansion{} [2]:
stratify_lib.tex(,97) @expansion{}    [1]:
stratify_lib.tex(,98) @expansion{}       _[1,1]=0
stratify_lib.tex(,99) @expansion{}       _[1,2]=t(1)
stratify_lib.tex(,100) @expansion{}       _[1,3]=3*t(2)
stratify_lib.tex(,101) @expansion{}       _[2,1]=0
stratify_lib.tex(,102) @expansion{}       _[2,2]=0
stratify_lib.tex(,103) @expansion{}       _[2,3]=t(1)
stratify_lib.tex(,104) @expansion{}    [2]:
stratify_lib.tex(,105) @expansion{}       _[1,1]=0
stratify_lib.tex(,106) @expansion{}       _[1,2]=0
stratify_lib.tex(,107) @expansion{}       _[1,3]=t(1)
stratify_lib.tex(,108) @c end example prepMat d2t_singular/stratify_lib.doc:67
stratify_lib.tex(,109) @end smallexample
stratify_lib.tex(,110) @c ---end content prepMat---
stratify_lib.tex(,111) 
stratify_lib.tex(,112) @c ------------------- stratify -------------
stratify_lib.tex(,113) @node stratify,, prepMat, stratify_lib
stratify_lib.tex(,114) @subsubsection stratify
stratify_lib.tex(,115) @cindex stratify
stratify_lib.tex(,116) @c ---content stratify---
stratify_lib.tex(,117) Procedure from library @code{stratify.lib} (@pxref{stratify_lib}).
stratify_lib.tex(,118) 
stratify_lib.tex(,119) @table @asis
stratify_lib.tex(,120) @item @strong{Usage:}
stratify_lib.tex(,121) stratify(M,wr,ws,step);
stratify_lib.tex(,122) @*where M is a matrix, wr is an intvec of size ncols(M),
stratify_lib.tex(,123) ws an intvec of size nrows(M) and step is an integer
stratify_lib.tex(,124) 
stratify_lib.tex(,125) @item @strong{Return:}
stratify_lib.tex(,126) list of lists, each entry of the big list corresponds to one
stratify_lib.tex(,127) locally closed set and has the following entries:
stratify_lib.tex(,128) @*1) intvec giving the corresponding rs-vector
stratify_lib.tex(,129) @*2) ideal determining the closed set
stratify_lib.tex(,130) @*3) list d of polynomials determining the open set D(d[1])
stratify_lib.tex(,131) empty list if there is more than one open set
stratify_lib.tex(,132) @*4-n) lists of polynomials determining open sets which all lead
stratify_lib.tex(,133) to the same rs-vector
stratify_lib.tex(,134) 
stratify_lib.tex(,135) @item @strong{Note:}
stratify_lib.tex(,136) * ring ordering should be global, i.e. the ring should be a
stratify_lib.tex(,137) polynomial ring
stratify_lib.tex(,138) @** the entries of the matrix M are M_ij=delta_i(x_j),
stratify_lib.tex(,139) @** wr is used to determine what subset of the set of all dx_i is
stratify_lib.tex(,140) generating AdF^l(A):
stratify_lib.tex(,141) @*if (k-1)*step < wr[i] <= k*step, then dx_i is in the set of
stratify_lib.tex(,142) generators of AdF^l(A) for all l>=k
stratify_lib.tex(,143) @** ws is used to determine what subset of the set of all delta_i
stratify_lib.tex(,144) is generating Z_l(L):
stratify_lib.tex(,145) @*if (k-1)*step <= ws[i] < k*step, then delta_i is in the set
stratify_lib.tex(,146) of generators of Z_l(A) for l < k
stratify_lib.tex(,147) @** the entries of wr and ws as well as step should be positive
stratify_lib.tex(,148) integers
stratify_lib.tex(,149) @** the filtrations have to be known, no sanity checks concerning
stratify_lib.tex(,150) the filtrations are performed !!!
stratify_lib.tex(,151) 
stratify_lib.tex(,152) @end table
stratify_lib.tex(,153) @strong{Example:}
stratify_lib.tex(,154) @smallexample
stratify_lib.tex(,155) @c computed example stratify d2t_singular/stratify_lib.doc:123 
stratify_lib.tex(,156) LIB "stratify.lib";
stratify_lib.tex(,157) ring r=0,(t(1..3)),dp;
stratify_lib.tex(,158) matrix M[2][3]=0,t(1),3*t(2),0,0,t(1);
stratify_lib.tex(,159) intvec wr=1,3,5;
stratify_lib.tex(,160) intvec ws=2,4;
stratify_lib.tex(,161) int step=2;
stratify_lib.tex(,162) stratify(M,wr,ws,step);
stratify_lib.tex(,163) @expansion{} [1]:
stratify_lib.tex(,164) @expansion{}    [1]:
stratify_lib.tex(,165) @expansion{}       0,0,0,0
stratify_lib.tex(,166) @expansion{}    [2]:
stratify_lib.tex(,167) @expansion{}       _[1]=t(2)
stratify_lib.tex(,168) @expansion{}       _[2]=t(1)
stratify_lib.tex(,169) @expansion{}    [3]:
stratify_lib.tex(,170) @expansion{}       [1]:
stratify_lib.tex(,171) @expansion{}          1
stratify_lib.tex(,172) @expansion{} [2]:
stratify_lib.tex(,173) @expansion{}    [1]:
stratify_lib.tex(,174) @expansion{}       0,1,0,1
stratify_lib.tex(,175) @expansion{}    [2]:
stratify_lib.tex(,176) @expansion{}       _[1]=t(1)
stratify_lib.tex(,177) @expansion{}    [3]:
stratify_lib.tex(,178) @expansion{}       [1]:
stratify_lib.tex(,179) @expansion{}          t(2)
stratify_lib.tex(,180) @expansion{}       [2]:
stratify_lib.tex(,181) @expansion{}          t(2)
stratify_lib.tex(,182) @expansion{} [3]:
stratify_lib.tex(,183) @expansion{}    [1]:
stratify_lib.tex(,184) @expansion{}       1,2,1,2
stratify_lib.tex(,185) @expansion{}    [2]:
stratify_lib.tex(,186) @expansion{}       _[1]=0
stratify_lib.tex(,187) @expansion{}    [3]:
stratify_lib.tex(,188) @expansion{}       [1]:
stratify_lib.tex(,189) @expansion{}          t(1)
stratify_lib.tex(,190) @expansion{}       [2]:
stratify_lib.tex(,191) @expansion{}          t(1)
stratify_lib.tex(,192) @c end example stratify d2t_singular/stratify_lib.doc:123
stratify_lib.tex(,193) @end smallexample
stratify_lib.tex(,194) @c ---end content stratify---
singular.texi(,532) @c ----------------------------------------------------------------------------
singular.texi(,533) @node Symbolic-numerical solving, Visualization, Invariant theory, SINGULAR libraries
singular.texi(,534) @section Symbolic-numerical solving
singular.texi(,535) @cindex Symbolic-numerical solving
singular.texi(,536) 
singular.texi(,537) @menu
singular.texi(,538) * presolve_lib:: procedures for pre-solving polynomial equations
singular.texi(,539) * solve_lib:: procedures to solve polynomial systems
singular.texi(,540) * triang_lib:: procedures for decomposing zero-dimensional ideals
singular.texi(,541) * ntsolve_lib:: one real solution of polynomial systems (Newton iteration)
singular.texi(,542) * zeroset_lib:: procedures for roots and factorization
singular.texi(,543) @end menu
singular.texi(,544) 
singular.texi(,545) @c ---------------------------------------------------------
singular.texi(,546) @node presolve_lib, solve_lib, Symbolic-numerical solving, Symbolic-numerical solving
singular.texi(,547) @subsection presolve_lib
singular.texi(,548) @c include of docu for presolve.lib
presolve_lib.tex(,1) @c ---content LibInfo---
presolve_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/presolve_lib.doc
presolve_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/presolve_lib.doc INSTEAD
presolve_lib.tex(,4) @c library version: (1.17.2.7,2003/06/12)
presolve_lib.tex(,5) @c library file: ../Singular/LIB/presolve.lib
presolve_lib.tex(,6) @cindex presolve.lib
presolve_lib.tex(,7) @cindex presolve_lib
presolve_lib.tex(,8) @table @asis
presolve_lib.tex(,9) @item @strong{Library:}
presolve_lib.tex(,10) presolve.lib
presolve_lib.tex(,11) @item @strong{Purpose:}
presolve_lib.tex(,12)      Pre-Solving of Polynomial Equations
presolve_lib.tex(,13) @item @strong{Author:}
presolve_lib.tex(,14) Gert-Martin Greuel, email: greuel@@mathematik.uni-kl.de,
presolve_lib.tex(,15) 
presolve_lib.tex(,16) @end table
presolve_lib.tex(,17) 
presolve_lib.tex(,18) @strong{Procedures:}
presolve_lib.tex(,19) @menu
presolve_lib.tex(,20) * degreepart:: elements of id of total degree >= d1 and <= d2
presolve_lib.tex(,21) * elimlinearpart:: linear part eliminated from id
presolve_lib.tex(,22) * elimpart:: partial elimination of vars [among first n vars]
presolve_lib.tex(,23) * elimpartanyr:: factors of p partially eliminated from i in any ring
presolve_lib.tex(,24) * fastelim:: fast elimination of factors of p from i [options]
presolve_lib.tex(,25) * findvars:: ideal of variables occurring in id [more information]
presolve_lib.tex(,26) * hilbvec:: intvec of Hilbert-series of id [in char c and ord o]
presolve_lib.tex(,27) * linearpart:: elements of id of total degree <=1
presolve_lib.tex(,28) * tolessvars:: maps id to new basering having only vars occurring in id
presolve_lib.tex(,29) * solvelinearpart:: reduced std-basis of linear part of id
presolve_lib.tex(,30) * sortandmap:: map to new basering with vars sorted w.r.t. complexity
presolve_lib.tex(,31) * sortvars:: sort vars w.r.t. complexity in id [different blocks]
presolve_lib.tex(,32) * shortid:: generators of id having <= n terms
presolve_lib.tex(,33) * valvars:: valuation of vars w.r.t. to their complexity in id
presolve_lib.tex(,34) * idealSimplify:: eliminates variables which are linear in id
presolve_lib.tex(,35) * idealSplit:: intersection of the ideals has the same radical as id
presolve_lib.tex(,36) @end menu
presolve_lib.tex(,37) @c ---end content LibInfo---
presolve_lib.tex(,38) 
presolve_lib.tex(,39) @c ------------------- degreepart -------------
presolve_lib.tex(,40) @node degreepart, elimlinearpart,, presolve_lib
presolve_lib.tex(,41) @subsubsection degreepart
presolve_lib.tex(,42) @cindex degreepart
presolve_lib.tex(,43) @c ---content degreepart---
presolve_lib.tex(,44) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,45) 
presolve_lib.tex(,46) @table @asis
presolve_lib.tex(,47) @item @strong{Usage:}
presolve_lib.tex(,48) degreepart(id,d1,d2[,v]); id=ideal/module, d1,d1=integers, v=intvec
presolve_lib.tex(,49) 
presolve_lib.tex(,50) @item @strong{Return:}
presolve_lib.tex(,51) generators of id of [v-weighted] total degree >= d1 and <= d2
presolve_lib.tex(,52) (default: v = 1,...,1)
presolve_lib.tex(,53) 
presolve_lib.tex(,54) @end table
presolve_lib.tex(,55) @strong{Example:}
presolve_lib.tex(,56) @smallexample
presolve_lib.tex(,57) @c reused example degreepart d2t_singular/presolve_lib.doc:55 
presolve_lib.tex(,58) LIB "presolve.lib";
presolve_lib.tex(,59) ring r=0,(x,y,z),dp;
presolve_lib.tex(,60) ideal i=1+x+x2+x3+x4,3,xz+y3+z8;
presolve_lib.tex(,61) degreepart(i,0,4);
presolve_lib.tex(,62) @expansion{} _[1]=x4+x3+x2+x+1
presolve_lib.tex(,63) @expansion{} _[2]=3
presolve_lib.tex(,64) module m=[x,y,z],x*[x3,y2,z],[1,x2,z3,0,1];
presolve_lib.tex(,65) intvec v=2,3,6;
presolve_lib.tex(,66) show(degreepart(m,8,8,v));
presolve_lib.tex(,67) @expansion{} // module, 1 generator(s)
presolve_lib.tex(,68) @expansion{} [x4,xy2,xz]
presolve_lib.tex(,69) @c end example degreepart d2t_singular/presolve_lib.doc:55
presolve_lib.tex(,70) @end smallexample
presolve_lib.tex(,71) @c ---end content degreepart---
presolve_lib.tex(,72) 
presolve_lib.tex(,73) @c ------------------- elimlinearpart -------------
presolve_lib.tex(,74) @node elimlinearpart, elimpart, degreepart, presolve_lib
presolve_lib.tex(,75) @subsubsection elimlinearpart
presolve_lib.tex(,76) @cindex elimlinearpart
presolve_lib.tex(,77) @c ---content elimlinearpart---
presolve_lib.tex(,78) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,79) 
presolve_lib.tex(,80) @table @asis
presolve_lib.tex(,81) @item @strong{Usage:}
presolve_lib.tex(,82) elimlinearpart(i[,n]); i=ideal, n=integer,@*
presolve_lib.tex(,83) default: n=nvars(basering)
presolve_lib.tex(,84) 
presolve_lib.tex(,85) @item @strong{Return:}
presolve_lib.tex(,86) list L with 5 entries:
presolve_lib.tex(,87)   @format
presolve_lib.tex(,88)   L[1]: (interreduced) ideal obtained from i by substituing
presolve_lib.tex(,89)         from the first n variables those, which appear in a linear part
presolve_lib.tex(,90)         of i, by putting this part into triangular form
presolve_lib.tex(,91)   L[2]: ideal of variables which have been substituted
presolve_lib.tex(,92)   L[3]: ideal, j-th element defines substitution of j-th var in [2]
presolve_lib.tex(,93)   L[4]: ideal of variables of basering, eliminated ones are set to 0
presolve_lib.tex(,94)   L[5]: ideal, describing the map from the basering to itself such that
presolve_lib.tex(,95)         L[1] is the image of i
presolve_lib.tex(,96)   @end format
presolve_lib.tex(,97) 
presolve_lib.tex(,98) @item @strong{Note:}
presolve_lib.tex(,99) the procedure does always interreduce the ideal i internally w.r.t.
presolve_lib.tex(,100) ordering dp.
presolve_lib.tex(,101) 
presolve_lib.tex(,102) @end table
presolve_lib.tex(,103) @strong{Example:}
presolve_lib.tex(,104) @smallexample
presolve_lib.tex(,105) @c reused example elimlinearpart d2t_singular/presolve_lib.doc:99 
presolve_lib.tex(,106) LIB "presolve.lib";
presolve_lib.tex(,107) ring s=0,(x,y,z),dp;
presolve_lib.tex(,108) ideal i = x3+y2+z,x2y2+z3,y+z+1;
presolve_lib.tex(,109) elimlinearpart(i);
presolve_lib.tex(,110) @expansion{} [1]:
presolve_lib.tex(,111) @expansion{}    _[1]=x3+z2+3z+1
presolve_lib.tex(,112) @expansion{}    _[2]=x2z2+2x2z+z3+x2
presolve_lib.tex(,113) @expansion{} [2]:
presolve_lib.tex(,114) @expansion{}    _[1]=y
presolve_lib.tex(,115) @expansion{} [3]:
presolve_lib.tex(,116) @expansion{}    _[1]=y+z+1
presolve_lib.tex(,117) @expansion{} [4]:
presolve_lib.tex(,118) @expansion{}    _[1]=x
presolve_lib.tex(,119) @expansion{}    _[2]=0
presolve_lib.tex(,120) @expansion{}    _[3]=z
presolve_lib.tex(,121) @expansion{} [5]:
presolve_lib.tex(,122) @expansion{}    _[1]=x
presolve_lib.tex(,123) @expansion{}    _[2]=-z-1
presolve_lib.tex(,124) @expansion{}    _[3]=z
presolve_lib.tex(,125) @c end example elimlinearpart d2t_singular/presolve_lib.doc:99
presolve_lib.tex(,126) @end smallexample
presolve_lib.tex(,127) @c ---end content elimlinearpart---
presolve_lib.tex(,128) 
presolve_lib.tex(,129) @c ------------------- elimpart -------------
presolve_lib.tex(,130) @node elimpart, elimpartanyr, elimlinearpart, presolve_lib
presolve_lib.tex(,131) @subsubsection elimpart
presolve_lib.tex(,132) @cindex elimpart
presolve_lib.tex(,133) @c ---content elimpart---
presolve_lib.tex(,134) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,135) 
presolve_lib.tex(,136) @table @asis
presolve_lib.tex(,137) @item @strong{Usage:}
presolve_lib.tex(,138) elimpart(i [,n,e] ); i=ideal, n,e=integers
presolve_lib.tex(,139) @*n : only the first n vars are considered for substitution,@*
presolve_lib.tex(,140) e =0: substitute from linear part of i (same as elimlinearpart)@*
presolve_lib.tex(,141) e!=0: eliminate also by direct substitution@*
presolve_lib.tex(,142) (default: n = nvars(basering), e = 1)
presolve_lib.tex(,143) 
presolve_lib.tex(,144) @item @strong{Return:}
presolve_lib.tex(,145) list of 5 objects:
presolve_lib.tex(,146)   @format
presolve_lib.tex(,147)   [1]: ideal obtained by substituting from the first n variables those
presolve_lib.tex(,148)        from i, which appear in the linear part of i (or, if e!=0, which
presolve_lib.tex(,149)        can be expressed directly in the remaining vars)
presolve_lib.tex(,150)   [2]: ideal, variables which have been substituted
presolve_lib.tex(,151)   [3]: ideal, i-th element defines substitution of i-th var in [2]
presolve_lib.tex(,152)   [4]: ideal of variables of basering, substituted ones are set to 0
presolve_lib.tex(,153)   [5]: ideal, describing the map from the basering, say k[x(1..m)], to
presolve_lib.tex(,154)        itself onto k[..variables fom [4]..] and [1] is the image of i
presolve_lib.tex(,155)   @end format
presolve_lib.tex(,156) The ideal i is generated by [1] and [3] in k[x(1..m)], the map [5]
presolve_lib.tex(,157) maps [3] to 0, hence induces an isomorphism
presolve_lib.tex(,158)   @format
presolve_lib.tex(,159)             k[x(1..m)]/i -> k[..variables fom [4]..]/[1]
presolve_lib.tex(,160)   @end format
presolve_lib.tex(,161) 
presolve_lib.tex(,162) @item @strong{Note:}
presolve_lib.tex(,163) If the basering has ordering (c,dp), this is faster for big ideals,
presolve_lib.tex(,164) since it avoids internal ring change and mapping.
presolve_lib.tex(,165) 
presolve_lib.tex(,166) @end table
presolve_lib.tex(,167) @strong{Example:}
presolve_lib.tex(,168) @smallexample
presolve_lib.tex(,169) @c reused example elimpart d2t_singular/presolve_lib.doc:148 
presolve_lib.tex(,170) LIB "presolve.lib";
presolve_lib.tex(,171) ring s=0,(x,y,z),dp;
presolve_lib.tex(,172) ideal i =x2+y2,x2+y+1;
presolve_lib.tex(,173) elimpart(i,3,0);
presolve_lib.tex(,174) @expansion{} [1]:
presolve_lib.tex(,175) @expansion{}    _[1]=y2-y-1
presolve_lib.tex(,176) @expansion{}    _[2]=x2+y+1
presolve_lib.tex(,177) @expansion{} [2]:
presolve_lib.tex(,178) @expansion{}    _[1]=0
presolve_lib.tex(,179) @expansion{} [3]:
presolve_lib.tex(,180) @expansion{}    _[1]=0
presolve_lib.tex(,181) @expansion{} [4]:
presolve_lib.tex(,182) @expansion{}    _[1]=x
presolve_lib.tex(,183) @expansion{}    _[2]=y
presolve_lib.tex(,184) @expansion{}    _[3]=z
presolve_lib.tex(,185) @expansion{} [5]:
presolve_lib.tex(,186) @expansion{}    _[1]=x
presolve_lib.tex(,187) @expansion{}    _[2]=y
presolve_lib.tex(,188) @expansion{}    _[3]=z
presolve_lib.tex(,189) elimpart(i,3,1);
presolve_lib.tex(,190) @expansion{} [1]:
presolve_lib.tex(,191) @expansion{}    _[1]=x4+3x2+1
presolve_lib.tex(,192) @expansion{} [2]:
presolve_lib.tex(,193) @expansion{}    _[1]=y
presolve_lib.tex(,194) @expansion{} [3]:
presolve_lib.tex(,195) @expansion{}    _[1]=x2+y+1
presolve_lib.tex(,196) @expansion{} [4]:
presolve_lib.tex(,197) @expansion{}    _[1]=x
presolve_lib.tex(,198) @expansion{}    _[2]=0
presolve_lib.tex(,199) @expansion{}    _[3]=z
presolve_lib.tex(,200) @expansion{} [5]:
presolve_lib.tex(,201) @expansion{}    _[1]=x
presolve_lib.tex(,202) @expansion{}    _[2]=-x2-1
presolve_lib.tex(,203) @expansion{}    _[3]=z
presolve_lib.tex(,204) @c end example elimpart d2t_singular/presolve_lib.doc:148
presolve_lib.tex(,205) @end smallexample
presolve_lib.tex(,206) @c ---end content elimpart---
presolve_lib.tex(,207) 
presolve_lib.tex(,208) @c ------------------- elimpartanyr -------------
presolve_lib.tex(,209) @node elimpartanyr, fastelim, elimpart, presolve_lib
presolve_lib.tex(,210) @subsubsection elimpartanyr
presolve_lib.tex(,211) @cindex elimpartanyr
presolve_lib.tex(,212) @c ---content elimpartanyr---
presolve_lib.tex(,213) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,214) 
presolve_lib.tex(,215) @table @asis
presolve_lib.tex(,216) @item @strong{Usage:}
presolve_lib.tex(,217) elimpartanyr(i [,p,e] ); i=ideal, p=polynomial, e=integer@*
presolve_lib.tex(,218) p: product of vars to be eliminated,@*
presolve_lib.tex(,219) e =0: substitute from linear part of i (same as elimlinearpart)@*
presolve_lib.tex(,220) e!=0: eliminate also by direct substitution@*
presolve_lib.tex(,221) (default: p=product of all vars, e=1)
presolve_lib.tex(,222) 
presolve_lib.tex(,223) @item @strong{Return:}
presolve_lib.tex(,224) list of 6 objects:
presolve_lib.tex(,225)   @format
presolve_lib.tex(,226)   [1]: (interreduced) ideal obtained by substituting from i those vars
presolve_lib.tex(,227)        appearing in p, which occur in the linear part of i (or which can
presolve_lib.tex(,228)        be expressed directly in the remaining variables, if e!=0)
presolve_lib.tex(,229)   [2]: ideal, variables which have been substituted
presolve_lib.tex(,230)   [3]: ideal, i-th element defines substitution of i-th var in [2]
presolve_lib.tex(,231)   [4]: ideal of variables of basering, substituted ones are set to 0
presolve_lib.tex(,232)   [5]: ideal, describing the map from the basering, say k[x(1..m)], to
presolve_lib.tex(,233)        itself onto k[..variables fom [4]..] and [1] is the image of i
presolve_lib.tex(,234)   [6]: int, # of vars considered for substitution (= # of factors of p)
presolve_lib.tex(,235)   @end format
presolve_lib.tex(,236) The ideal i is generated by [1] and [3] in k[x(1..m)], the map [5]
presolve_lib.tex(,237) maps [3] to 0, hence induces an isomorphism
presolve_lib.tex(,238)   @format
presolve_lib.tex(,239)             k[x(1..m)]/i -> k[..variables fom [4]..]/[1]
presolve_lib.tex(,240)   @end format
presolve_lib.tex(,241) 
presolve_lib.tex(,242) @item @strong{Note:}
presolve_lib.tex(,243) the proc uses @code{execute} to create a ring with ordering dp and vars
presolve_lib.tex(,244) placed correctly and then applies @code{elimpart}.
presolve_lib.tex(,245) 
presolve_lib.tex(,246) @end table
presolve_lib.tex(,247) @strong{Example:}
presolve_lib.tex(,248) @smallexample
presolve_lib.tex(,249) @c reused example elimpartanyr d2t_singular/presolve_lib.doc:199 
presolve_lib.tex(,250) LIB "presolve.lib";
presolve_lib.tex(,251) ring s=0,(x,y,z),dp;
presolve_lib.tex(,252) ideal i = x3+y2+z,x2y2+z3,y+z+1;
presolve_lib.tex(,253) elimpartanyr(i,z);
presolve_lib.tex(,254) @expansion{} [1]:
presolve_lib.tex(,255) @expansion{}    _[1]=x3+y2-y-1
presolve_lib.tex(,256) @expansion{}    _[2]=x2y2-y3-3y2-3y-1
presolve_lib.tex(,257) @expansion{} [2]:
presolve_lib.tex(,258) @expansion{}    _[1]=z
presolve_lib.tex(,259) @expansion{} [3]:
presolve_lib.tex(,260) @expansion{}    _[1]=y+z+1
presolve_lib.tex(,261) @expansion{} [4]:
presolve_lib.tex(,262) @expansion{}    _[1]=0
presolve_lib.tex(,263) @expansion{}    _[2]=x
presolve_lib.tex(,264) @expansion{}    _[3]=y
presolve_lib.tex(,265) @expansion{} [5]:
presolve_lib.tex(,266) @expansion{}    _[1]=-y-1
presolve_lib.tex(,267) @expansion{}    _[2]=x
presolve_lib.tex(,268) @expansion{}    _[3]=y
presolve_lib.tex(,269) @expansion{} [6]:
presolve_lib.tex(,270) @expansion{}    1
presolve_lib.tex(,271) @c end example elimpartanyr d2t_singular/presolve_lib.doc:199
presolve_lib.tex(,272) @end smallexample
presolve_lib.tex(,273) @c ---end content elimpartanyr---
presolve_lib.tex(,274) 
presolve_lib.tex(,275) @c ------------------- fastelim -------------
presolve_lib.tex(,276) @node fastelim, findvars, elimpartanyr, presolve_lib
presolve_lib.tex(,277) @subsubsection fastelim
presolve_lib.tex(,278) @cindex fastelim
presolve_lib.tex(,279) @c ---content fastelim---
presolve_lib.tex(,280) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,281) 
presolve_lib.tex(,282) @table @asis
presolve_lib.tex(,283) @item @strong{Usage:}
presolve_lib.tex(,284) fastelim(i,p[h,o,a,b,e,m]); i=ideal, p=polynomial; h,o,a,b,e=integers
presolve_lib.tex(,285) p: product of variables to be eliminated;@*
presolve_lib.tex(,286) Optional parameters:
presolve_lib.tex(,287)   @format
presolve_lib.tex(,288)   - h !=0: use Hilbert-series driven std-basis computation
presolve_lib.tex(,289)   - o !=0: use proc @code{valvars} for a - hopefully - optimal ordering of vars
presolve_lib.tex(,290)   - a !=0: order vars to be eliminated w.r.t. increasing complexity
presolve_lib.tex(,291)   - b !=0: order vars not to be eliminated w.r.t. increasing complexity
presolve_lib.tex(,292)   - e !=0: use @code{elimpart} first to eliminate easy part
presolve_lib.tex(,293)   - m !=0: compute a minimal system of generators
presolve_lib.tex(,294)   @end format
presolve_lib.tex(,295) (default: h,o,a,b,e,m = 0,1,0,0,0,0)
presolve_lib.tex(,296) 
presolve_lib.tex(,297) @item @strong{Return:}
presolve_lib.tex(,298) ideal obtained from i by eliminating those variables, which occur in p
presolve_lib.tex(,299) 
presolve_lib.tex(,300) @end table
presolve_lib.tex(,301) @strong{Example:}
presolve_lib.tex(,302) @smallexample
presolve_lib.tex(,303) @c reused example fastelim d2t_singular/presolve_lib.doc:236 
presolve_lib.tex(,304) LIB "presolve.lib";
presolve_lib.tex(,305) ring s=31991,(e,f,x,y,z,t,u,v,w,a,b,c,d),dp;
presolve_lib.tex(,306) ideal i = w2+f2-1, x2+t2+a2-1,  y2+u2+b2-1, z2+v2+c2-1,
presolve_lib.tex(,307) d2+e2-1, f4+2u, wa+tf, xy+tu+ab;
presolve_lib.tex(,308) fastelim(i,xytua,1,1);       //with hilb,valvars
presolve_lib.tex(,309) @expansion{} _[1]=f2+w2-1
presolve_lib.tex(,310) @expansion{} _[2]=z2+v2+c2-1
presolve_lib.tex(,311) @expansion{} _[3]=e2+d2-1
presolve_lib.tex(,312) fastelim(i,xytua,1,0,1);     //with hilb,minbase
presolve_lib.tex(,313) @expansion{} _[1]=z2+v2+c2-1
presolve_lib.tex(,314) @expansion{} _[2]=f2+w2-1
presolve_lib.tex(,315) @expansion{} _[3]=e2+d2-1
presolve_lib.tex(,316) @c end example fastelim d2t_singular/presolve_lib.doc:236
presolve_lib.tex(,317) @end smallexample
presolve_lib.tex(,318) @c ---end content fastelim---
presolve_lib.tex(,319) 
presolve_lib.tex(,320) @c ------------------- findvars -------------
presolve_lib.tex(,321) @node findvars, hilbvec, fastelim, presolve_lib
presolve_lib.tex(,322) @subsubsection findvars
presolve_lib.tex(,323) @cindex findvars
presolve_lib.tex(,324) @c ---content findvars---
presolve_lib.tex(,325) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,326) 
presolve_lib.tex(,327) @table @asis
presolve_lib.tex(,328) @item @strong{Usage:}
presolve_lib.tex(,329) findvars(id [,any] ); id=poly/ideal/vector/module/matrix, any=any type
presolve_lib.tex(,330) 
presolve_lib.tex(,331) @item @strong{Return:}
presolve_lib.tex(,332) if no second argument is present: ideal of variables occurring in id,@*
presolve_lib.tex(,333) if a second argument is given (of any type): list L with 4 entries:
presolve_lib.tex(,334)   @format
presolve_lib.tex(,335)   L[1]: ideal of variables occurring in id
presolve_lib.tex(,336)   L[2]: intvec of variables occurring in id
presolve_lib.tex(,337)   L[3]: ideal of variables not occurring in id
presolve_lib.tex(,338)   L[4]: intvec of variables not occurring in id
presolve_lib.tex(,339)   @end format
presolve_lib.tex(,340) 
presolve_lib.tex(,341) @end table
presolve_lib.tex(,342) @strong{Example:}
presolve_lib.tex(,343) @smallexample
presolve_lib.tex(,344) @c reused example findvars d2t_singular/presolve_lib.doc:271 
presolve_lib.tex(,345) LIB "presolve.lib";
presolve_lib.tex(,346) ring s  = 0,(e,f,x,y,t,u,v,w,a,d),dp;
presolve_lib.tex(,347) ideal i = w2+f2-1, x2+t2+a2-1;
presolve_lib.tex(,348) findvars(i);
presolve_lib.tex(,349) @expansion{} _[1]=f
presolve_lib.tex(,350) @expansion{} _[2]=x
presolve_lib.tex(,351) @expansion{} _[3]=t
presolve_lib.tex(,352) @expansion{} _[4]=w
presolve_lib.tex(,353) @expansion{} _[5]=a
presolve_lib.tex(,354) findvars(i,1);
presolve_lib.tex(,355) @expansion{} [1]:
presolve_lib.tex(,356) @expansion{}    _[1]=f
presolve_lib.tex(,357) @expansion{}    _[2]=x
presolve_lib.tex(,358) @expansion{}    _[3]=t
presolve_lib.tex(,359) @expansion{}    _[4]=w
presolve_lib.tex(,360) @expansion{}    _[5]=a
presolve_lib.tex(,361) @expansion{} [2]:
presolve_lib.tex(,362) @expansion{}    2,3,5,8,9
presolve_lib.tex(,363) @expansion{} [3]:
presolve_lib.tex(,364) @expansion{}    _[1]=e
presolve_lib.tex(,365) @expansion{}    _[2]=y
presolve_lib.tex(,366) @expansion{}    _[3]=u
presolve_lib.tex(,367) @expansion{}    _[4]=v
presolve_lib.tex(,368) @expansion{}    _[5]=d
presolve_lib.tex(,369) @expansion{} [4]:
presolve_lib.tex(,370) @expansion{}    1,4,6,7,10
presolve_lib.tex(,371) @c end example findvars d2t_singular/presolve_lib.doc:271
presolve_lib.tex(,372) @end smallexample
presolve_lib.tex(,373) @c ---end content findvars---
presolve_lib.tex(,374) 
presolve_lib.tex(,375) @c ------------------- hilbvec -------------
presolve_lib.tex(,376) @node hilbvec, linearpart, findvars, presolve_lib
presolve_lib.tex(,377) @subsubsection hilbvec
presolve_lib.tex(,378) @cindex hilbvec
presolve_lib.tex(,379) @c ---content hilbvec---
presolve_lib.tex(,380) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,381) 
presolve_lib.tex(,382) @table @asis
presolve_lib.tex(,383) @item @strong{Usage:}
presolve_lib.tex(,384) hilbvec(id[,c,o]); id=poly/ideal/vector/module/matrix, c,o=strings,@*
presolve_lib.tex(,385) c=char, o=ordering used by @code{hilb}@*
presolve_lib.tex(,386) (default: c="32003", o="dp")
presolve_lib.tex(,387) 
presolve_lib.tex(,388) @item @strong{Return:}
presolve_lib.tex(,389) intvec of 1-st Hilbert-series of id, computed in char c and ordering o
presolve_lib.tex(,390) 
presolve_lib.tex(,391) @item @strong{Note:}
presolve_lib.tex(,392) id must be homogeneous (i.e. all vars have weight 1)
presolve_lib.tex(,393) 
presolve_lib.tex(,394) @end table
presolve_lib.tex(,395) @strong{Example:}
presolve_lib.tex(,396) @smallexample
presolve_lib.tex(,397) @c reused example hilbvec d2t_singular/presolve_lib.doc:303 
presolve_lib.tex(,398) LIB "presolve.lib";
presolve_lib.tex(,399) ring s   = 0,(e,f,x,y,z,t,u,v,w,a,b,c,d,H),dp;
presolve_lib.tex(,400) ideal id = w2+f2-1, x2+t2+a2-1,  y2+u2+b2-1, z2+v2+c2-1,
presolve_lib.tex(,401) d2+e2-1, f4+2u, wa+tf, xy+tu+ab;
presolve_lib.tex(,402) id = homog(id,H);
presolve_lib.tex(,403) hilbvec(id);
presolve_lib.tex(,404) @expansion{} 1,0,-7,0,20,0,-28,0,14,0,14,0,-28,0,20,0,-7,0,1,0
presolve_lib.tex(,405) @c end example hilbvec d2t_singular/presolve_lib.doc:303
presolve_lib.tex(,406) @end smallexample
presolve_lib.tex(,407) @c ---end content hilbvec---
presolve_lib.tex(,408) 
presolve_lib.tex(,409) @c ------------------- linearpart -------------
presolve_lib.tex(,410) @node linearpart, tolessvars, hilbvec, presolve_lib
presolve_lib.tex(,411) @subsubsection linearpart
presolve_lib.tex(,412) @cindex linearpart
presolve_lib.tex(,413) @c ---content linearpart---
presolve_lib.tex(,414) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,415) 
presolve_lib.tex(,416) @table @asis
presolve_lib.tex(,417) @item @strong{Usage:}
presolve_lib.tex(,418) linearpart(id); id=ideal/module
presolve_lib.tex(,419) 
presolve_lib.tex(,420) @item @strong{Return:}
presolve_lib.tex(,421) generators of id of total degree <= 1
presolve_lib.tex(,422) 
presolve_lib.tex(,423) @end table
presolve_lib.tex(,424) @strong{Example:}
presolve_lib.tex(,425) @smallexample
presolve_lib.tex(,426) @c reused example linearpart d2t_singular/presolve_lib.doc:331 
presolve_lib.tex(,427) LIB "presolve.lib";
presolve_lib.tex(,428) ring r=0,(x,y,z),dp;
presolve_lib.tex(,429) ideal i=1+x+x2+x3,3,x+3y+5z;
presolve_lib.tex(,430) linearpart(i);
presolve_lib.tex(,431) @expansion{} _[1]=3
presolve_lib.tex(,432) @expansion{} _[2]=x+3y+5z
presolve_lib.tex(,433) module m=[x,y,z],x*[x3,y2,z],[1,x2,z3,0,1];
presolve_lib.tex(,434) show(linearpart(m));
presolve_lib.tex(,435) @expansion{} // module, 1 generator(s)
presolve_lib.tex(,436) @expansion{} [x,y,z]
presolve_lib.tex(,437) @c end example linearpart d2t_singular/presolve_lib.doc:331
presolve_lib.tex(,438) @end smallexample
presolve_lib.tex(,439) @c ---end content linearpart---
presolve_lib.tex(,440) 
presolve_lib.tex(,441) @c ------------------- tolessvars -------------
presolve_lib.tex(,442) @node tolessvars, solvelinearpart, linearpart, presolve_lib
presolve_lib.tex(,443) @subsubsection tolessvars
presolve_lib.tex(,444) @cindex tolessvars
presolve_lib.tex(,445) @c ---content tolessvars---
presolve_lib.tex(,446) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,447) 
presolve_lib.tex(,448) @table @asis
presolve_lib.tex(,449) @item @strong{Usage:}
presolve_lib.tex(,450) tolessvars(id [,s1,s2] ); id poly/ideal/vector/module/matrix,
presolve_lib.tex(,451) s1,s2=strings@*
presolve_lib.tex(,452) s1: name of new ring,@*
presolve_lib.tex(,453) s2: new ordering@*
presolve_lib.tex(,454) (default: s1="R(n)" where n is the # of vars in the new ring,
presolve_lib.tex(,455) s2="dp" or "ds" depending whether the first block of the old
presolve_lib.tex(,456) ordering is a p- resp. an s-ordering)
presolve_lib.tex(,457) 
presolve_lib.tex(,458) @item @strong{Create:}
presolve_lib.tex(,459) nothing, if id contains all vars of the basering.@*
presolve_lib.tex(,460) Else, create a ring with same char as the basering, but possibly less
presolve_lib.tex(,461) variables (only those variables which actually occur in id) and map
presolve_lib.tex(,462) id to the new ring, which will be the basering after the proc has
presolve_lib.tex(,463) finished.
presolve_lib.tex(,464) 
presolve_lib.tex(,465) @item @strong{Display:}
presolve_lib.tex(,466) If printlevel >=0, display ideal of vars, which have been omitted from
presolve_lib.tex(,467) the old ring
presolve_lib.tex(,468) 
presolve_lib.tex(,469) @item @strong{Return:}
presolve_lib.tex(,470) the original ideal id (see NOTE)
presolve_lib.tex(,471) 
presolve_lib.tex(,472) @item @strong{Note:}
presolve_lib.tex(,473) You must not type, say, 'ideal id=tolessvars(id);' since the ring
presolve_lib.tex(,474) to which 'id' would belong will only be defined by the r.h.s.. But you
presolve_lib.tex(,475) may type 'def id=tolessvars(id);' or 'list id=tolessvars(id);'
presolve_lib.tex(,476) since then 'id' does not a priory belong to a ring, its type will
presolve_lib.tex(,477) be defined by the right hand side. Moreover, do not use a name which
presolve_lib.tex(,478) occurs in the old ring, for the same reason.
presolve_lib.tex(,479) 
presolve_lib.tex(,480) @end table
presolve_lib.tex(,481) @strong{Example:}
presolve_lib.tex(,482) @smallexample
presolve_lib.tex(,483) @c reused example tolessvars d2t_singular/presolve_lib.doc:384 
presolve_lib.tex(,484) LIB "presolve.lib";
presolve_lib.tex(,485) ring r  = 0,(x,y,z),dp;
presolve_lib.tex(,486) ideal i = y2-x3,x-3,y-2x;
presolve_lib.tex(,487) def j   = tolessvars(i,"R_r","lp");
presolve_lib.tex(,488) @expansion{} 
presolve_lib.tex(,489) @expansion{} // variables which did not occur:
presolve_lib.tex(,490) @expansion{} z
presolve_lib.tex(,491) @expansion{} // basering is now R_r
presolve_lib.tex(,492) show(basering);
presolve_lib.tex(,493) @expansion{} // ring: (0),(x,y),(lp(2),C);
presolve_lib.tex(,494) @expansion{} // minpoly = 0
presolve_lib.tex(,495) @expansion{} // objects belonging to this ring:
presolve_lib.tex(,496) @expansion{} // j                    [0]  ideal, 3 generator(s)
presolve_lib.tex(,497) j;
presolve_lib.tex(,498) @expansion{} j[1]=-x3+y2
presolve_lib.tex(,499) @expansion{} j[2]=x-3
presolve_lib.tex(,500) @expansion{} j[3]=-2x+y
presolve_lib.tex(,501) kill R_r;
presolve_lib.tex(,502) @c end example tolessvars d2t_singular/presolve_lib.doc:384
presolve_lib.tex(,503) @end smallexample
presolve_lib.tex(,504) @c ---end content tolessvars---
presolve_lib.tex(,505) 
presolve_lib.tex(,506) @c ------------------- solvelinearpart -------------
presolve_lib.tex(,507) @node solvelinearpart, sortandmap, tolessvars, presolve_lib
presolve_lib.tex(,508) @subsubsection solvelinearpart
presolve_lib.tex(,509) @cindex solvelinearpart
presolve_lib.tex(,510) @c ---content solvelinearpart---
presolve_lib.tex(,511) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,512) 
presolve_lib.tex(,513) @table @asis
presolve_lib.tex(,514) @item @strong{Usage:}
presolve_lib.tex(,515) solvelinearpart(id [,n] ); id=ideal/module, n=integer,@*
presolve_lib.tex(,516) (default: n=0)
presolve_lib.tex(,517) 
presolve_lib.tex(,518) @item @strong{Return:}
presolve_lib.tex(,519) (interreduced) generators of id of degree <=1 in reduced triangular
presolve_lib.tex(,520) form if n=0 [non-reduced triangular form if n!=0]
presolve_lib.tex(,521) 
presolve_lib.tex(,522) @item @strong{Assume:}
presolve_lib.tex(,523) monomial ordering is a global ordering (p-ordering)
presolve_lib.tex(,524) 
presolve_lib.tex(,525) @item @strong{Note:}
presolve_lib.tex(,526) may be used to solve a system of linear equations
presolve_lib.tex(,527) see proc @code{gauss_row} from 'matrix.lib' for a different method
presolve_lib.tex(,528) 
presolve_lib.tex(,529) @item @strong{Warning:}
presolve_lib.tex(,530) the result is very likely to be false for 'real' coefficients, use
presolve_lib.tex(,531) char 0 instead!
presolve_lib.tex(,532) 
presolve_lib.tex(,533) @end table
presolve_lib.tex(,534) @strong{Example:}
presolve_lib.tex(,535) @smallexample
presolve_lib.tex(,536) @c reused example solvelinearpart d2t_singular/presolve_lib.doc:426 
presolve_lib.tex(,537) LIB "presolve.lib";
presolve_lib.tex(,538) // Solve the system of linear equations:
presolve_lib.tex(,539) //         3x +   y +  z -  u = 2
presolve_lib.tex(,540) //         3x +  8y + 6z - 7u = 1
presolve_lib.tex(,541) //        14x + 10y + 6z - 7u = 0
presolve_lib.tex(,542) //         7x +  4y + 3z - 3u = 3
presolve_lib.tex(,543) ring r = 0,(x,y,z,u),lp;
presolve_lib.tex(,544) ideal i= 3x +   y +  z -  u,
presolve_lib.tex(,545) 13x +  8y + 6z - 7u,
presolve_lib.tex(,546) 14x + 10y + 6z - 7u,
presolve_lib.tex(,547) 7x +  4y + 3z - 3u;
presolve_lib.tex(,548) ideal j= 2,1,0,3;
presolve_lib.tex(,549) j = i-j;                        // difference of 1x4 matrices
presolve_lib.tex(,550) // compute reduced triangular form, setting
presolve_lib.tex(,551) solvelinearpart(j);             // the RHS equal 0 gives the solutions!
presolve_lib.tex(,552) @expansion{} _[1]=u-4
presolve_lib.tex(,553) @expansion{} _[2]=z-4
presolve_lib.tex(,554) @expansion{} _[3]=y+1
presolve_lib.tex(,555) @expansion{} _[4]=x-1
presolve_lib.tex(,556) solvelinearpart(j,1); "";       // triangular form, not reduced
presolve_lib.tex(,557) @expansion{} _[1]=u-4
presolve_lib.tex(,558) @expansion{} _[2]=3z-8u+20
presolve_lib.tex(,559) @expansion{} _[3]=18y-6z+7u+14
presolve_lib.tex(,560) @expansion{} _[4]=13x+8y+6z-7u-1
presolve_lib.tex(,561) @expansion{} 
presolve_lib.tex(,562) @c end example solvelinearpart d2t_singular/presolve_lib.doc:426
presolve_lib.tex(,563) @end smallexample
presolve_lib.tex(,564) @c ---end content solvelinearpart---
presolve_lib.tex(,565) 
presolve_lib.tex(,566) @c ------------------- sortandmap -------------
presolve_lib.tex(,567) @node sortandmap, sortvars, solvelinearpart, presolve_lib
presolve_lib.tex(,568) @subsubsection sortandmap
presolve_lib.tex(,569) @cindex sortandmap
presolve_lib.tex(,570) @c ---content sortandmap---
presolve_lib.tex(,571) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,572) 
presolve_lib.tex(,573) @table @asis
presolve_lib.tex(,574) @item @strong{Usage:}
presolve_lib.tex(,575) sortandmap(id,s1,s2[,n1,p1,n2,p2...,o1,m1,o2,m2...]);@*
presolve_lib.tex(,576) id=poly/ideal/vector/module,@*
presolve_lib.tex(,577) s1,s2 = strings (names for new ring and mapped id),@*
presolve_lib.tex(,578) p1,p2,...= polynomials (product of variables),@*
presolve_lib.tex(,579) n1,n2,...= integers,@*
presolve_lib.tex(,580) o1,o2,...= strings,@*
presolve_lib.tex(,581) m1,m2,...= integers@*
presolve_lib.tex(,582) (default: p1=product of all vars, n1=0, o1="dp",m1=0)
presolve_lib.tex(,583) @*the last pi (containing the remaining vars) may be omitted
presolve_lib.tex(,584) 
presolve_lib.tex(,585) @item @strong{Create:}
presolve_lib.tex(,586) a new ring and map id into it, the new ring has same char as basering
presolve_lib.tex(,587) but with new ordering and vars sorted in the following manner:
presolve_lib.tex(,588)   @format
presolve_lib.tex(,589)   - each block of vars occurring in pi is sorted w.r.t. its complexity in id,
presolve_lib.tex(,590)   - ni controls the sorting in i-th block (= vars occurring in pi):
presolve_lib.tex(,591)     ni=0 (resp.!=0) means that less (resp. more) complex vars come first
presolve_lib.tex(,592)   - oi and mi define the monomial ordering of the i-th block:
presolve_lib.tex(,593)     if mi =0, oi=ordstr(i-th block)
presolve_lib.tex(,594)     if mi!=0, the ordering of the i-th block itself is a blockordering,
presolve_lib.tex(,595)       each subblock having ordstr=oi, such that vars of same complexity are
presolve_lib.tex(,596)       in one block
presolve_lib.tex(,597)   @end format
presolve_lib.tex(,598) Note that only simple ordstrings oi are allowed:
presolve_lib.tex(,599) @*"lp","dp","Dp","ls","ds","Ds".
presolve_lib.tex(,600) 
presolve_lib.tex(,601) @item @strong{Return:}
presolve_lib.tex(,602) nothing
presolve_lib.tex(,603) 
presolve_lib.tex(,604) @item @strong{Note:}
presolve_lib.tex(,605) We define a variable x to be more complex than y (with respect to id)
presolve_lib.tex(,606) if val(x) > val(y) lexicographically, where val(x) denotes the
presolve_lib.tex(,607) valuation vector of x:@*
presolve_lib.tex(,608) consider id as list of polynomials in x with coefficients in the
presolve_lib.tex(,609) remaining variables. Then:@*
presolve_lib.tex(,610) val(x) = (maximal occurring power of x, # of all monomials in leading
presolve_lib.tex(,611) coefficient, # of all monomials in coefficient of next smaller power
presolve_lib.tex(,612) of x,...).
presolve_lib.tex(,613) 
presolve_lib.tex(,614) @end table
presolve_lib.tex(,615) @strong{Example:}
presolve_lib.tex(,616) @smallexample
presolve_lib.tex(,617) @c reused example sortandmap d2t_singular/presolve_lib.doc:498 
presolve_lib.tex(,618) LIB "presolve.lib";
presolve_lib.tex(,619) ring s = 32003,(x,y,z),dp;
presolve_lib.tex(,620) ideal i=x3+y2,xz+z2;
presolve_lib.tex(,621) sortandmap(i,"R_r","i");
presolve_lib.tex(,622) // i is now an ideal in the new basering R_r
presolve_lib.tex(,623) show(R_r);
presolve_lib.tex(,624) @expansion{} // ring: (32003),(y,z,x),(dp(3),C);
presolve_lib.tex(,625) @expansion{} // minpoly = 0
presolve_lib.tex(,626) @expansion{} // objects belonging to this ring:
presolve_lib.tex(,627) @expansion{} // i                    [0]  ideal, 2 generator(s)
presolve_lib.tex(,628) kill R_r; setring s;
presolve_lib.tex(,629) sortandmap(i,"R_r","i",1,xy,0,z,0,"ds",0,"lp",0);
presolve_lib.tex(,630) show(R_r);
presolve_lib.tex(,631) @expansion{} // ring: (32003),(x,y,z),(ds(2),lp(1),C);
presolve_lib.tex(,632) @expansion{} // minpoly = 0
presolve_lib.tex(,633) @expansion{} // objects belonging to this ring:
presolve_lib.tex(,634) @expansion{} // i                    [0]  ideal, 2 generator(s)
presolve_lib.tex(,635) kill R_r;
presolve_lib.tex(,636) @c end example sortandmap d2t_singular/presolve_lib.doc:498
presolve_lib.tex(,637) @end smallexample
presolve_lib.tex(,638) @c ---end content sortandmap---
presolve_lib.tex(,639) 
presolve_lib.tex(,640) @c ------------------- sortvars -------------
presolve_lib.tex(,641) @node sortvars, shortid, sortandmap, presolve_lib
presolve_lib.tex(,642) @subsubsection sortvars
presolve_lib.tex(,643) @cindex sortvars
presolve_lib.tex(,644) @c ---content sortvars---
presolve_lib.tex(,645) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,646) 
presolve_lib.tex(,647) @table @asis
presolve_lib.tex(,648) @item @strong{Usage:}
presolve_lib.tex(,649) sortvars(id[,n1,p1,n2,p2,...]);@*
presolve_lib.tex(,650) id=poly/ideal/vector/module,@*
presolve_lib.tex(,651) p1,p2,...= polynomials (product of vars),@*
presolve_lib.tex(,652) n1,n2,...=integers@*
presolve_lib.tex(,653) (default: p1=product of all vars, n1=0)
presolve_lib.tex(,654) @*the last pi (containing the remaining vars) may be omitted
presolve_lib.tex(,655) 
presolve_lib.tex(,656) @item @strong{Compute:}
presolve_lib.tex(,657) sort variables with respect to their complexity in id
presolve_lib.tex(,658) 
presolve_lib.tex(,659) @item @strong{Return:}
presolve_lib.tex(,660) list of two elements, an ideal and a list:
presolve_lib.tex(,661)   @format
presolve_lib.tex(,662)   [1]: ideal, variables of basering sorted w.r.t their complexity in id
presolve_lib.tex(,663)        ni controls the ordering in i-th block (= vars occurring in pi):
presolve_lib.tex(,664)        ni=0 (resp.!=0) means that less (resp. more) complex vars come first
presolve_lib.tex(,665)   [2]: a list with 4 entries for each pi:
presolve_lib.tex(,666)        ideal ai : vars of pi in correct order,
presolve_lib.tex(,667)        intvec vi: permutation vector describing the ordering in ai,
presolve_lib.tex(,668)        intmat Mi: valuation matrix of ai, the columns of Mi being the
presolve_lib.tex(,669)                   valuation vectors of the vars in ai
presolve_lib.tex(,670)        intvec wi: size of 1-st, 2-nd,... block of identical columns of Mi
presolve_lib.tex(,671)                   (vars with same valuation)
presolve_lib.tex(,672)   @end format
presolve_lib.tex(,673) 
presolve_lib.tex(,674) @item @strong{Note:}
presolve_lib.tex(,675) We define a variable x to be more complex than y (with respect to id)
presolve_lib.tex(,676) if val(x) > val(y) lexicographically, where val(x) denotes the
presolve_lib.tex(,677) valuation vector of x:@*
presolve_lib.tex(,678) consider id as list of polynomials in x with coefficients in the
presolve_lib.tex(,679) remaining variables. Then:@*
presolve_lib.tex(,680) val(x) = (maximal occurring power of x, # of all monomials in leading
presolve_lib.tex(,681) coefficient, # of all monomials in coefficient of next smaller power
presolve_lib.tex(,682) of x,...).
presolve_lib.tex(,683) 
presolve_lib.tex(,684) @end table
presolve_lib.tex(,685) @strong{Example:}
presolve_lib.tex(,686) @smallexample
presolve_lib.tex(,687) @c reused example sortvars d2t_singular/presolve_lib.doc:560 
presolve_lib.tex(,688) LIB "presolve.lib";
presolve_lib.tex(,689) ring s=0,(x,y,z,w),dp;
presolve_lib.tex(,690) ideal i = x3+y2+yw2,xz+z2,xyz-w2;
presolve_lib.tex(,691) sortvars(i,0,xy,1,zw);
presolve_lib.tex(,692) @expansion{} [1]:
presolve_lib.tex(,693) @expansion{}    _[1]=y
presolve_lib.tex(,694) @expansion{}    _[2]=x
presolve_lib.tex(,695) @expansion{}    _[3]=w
presolve_lib.tex(,696) @expansion{}    _[4]=z
presolve_lib.tex(,697) @expansion{} [2]:
presolve_lib.tex(,698) @expansion{}    [1]:
presolve_lib.tex(,699) @expansion{}       _[1]=y
presolve_lib.tex(,700) @expansion{}       _[2]=x
presolve_lib.tex(,701) @expansion{}    [2]:
presolve_lib.tex(,702) @expansion{}       2,1
presolve_lib.tex(,703) @expansion{}    [3]:
presolve_lib.tex(,704) @expansion{}       2,3,
presolve_lib.tex(,705) @expansion{}       1,1,
presolve_lib.tex(,706) @expansion{}       2,0,
presolve_lib.tex(,707) @expansion{}       0,2 
presolve_lib.tex(,708) @expansion{}    [4]:
presolve_lib.tex(,709) @expansion{}       1,1
presolve_lib.tex(,710) @expansion{}    [5]:
presolve_lib.tex(,711) @expansion{}       _[1]=w
presolve_lib.tex(,712) @expansion{}       _[2]=z
presolve_lib.tex(,713) @expansion{}    [6]:
presolve_lib.tex(,714) @expansion{}       2,1
presolve_lib.tex(,715) @expansion{}    [7]:
presolve_lib.tex(,716) @expansion{}       2,2,
presolve_lib.tex(,717) @expansion{}       2,1,
presolve_lib.tex(,718) @expansion{}       0,2 
presolve_lib.tex(,719) @expansion{}    [8]:
presolve_lib.tex(,720) @expansion{}       1,1
presolve_lib.tex(,721) @c end example sortvars d2t_singular/presolve_lib.doc:560
presolve_lib.tex(,722) @end smallexample
presolve_lib.tex(,723) @c ---end content sortvars---
presolve_lib.tex(,724) 
presolve_lib.tex(,725) @c ------------------- shortid -------------
presolve_lib.tex(,726) @node shortid, valvars, sortvars, presolve_lib
presolve_lib.tex(,727) @subsubsection shortid
presolve_lib.tex(,728) @cindex shortid
presolve_lib.tex(,729) @c ---content shortid---
presolve_lib.tex(,730) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,731) 
presolve_lib.tex(,732) @table @asis
presolve_lib.tex(,733) @item @strong{Usage:}
presolve_lib.tex(,734) shortid(id,n[,e]); id= ideal/module, n,e=integers
presolve_lib.tex(,735) 
presolve_lib.tex(,736) @item @strong{Return:}
presolve_lib.tex(,737) - if called with two arguments or e=0:
presolve_lib.tex(,738) @* same type as id, containing generators of id having <= n terms.
presolve_lib.tex(,739) @* - if called with three arguments and e!=0:
presolve_lib.tex(,740) @* a list L:
presolve_lib.tex(,741) @* L[1]: same type as id, containing generators of id having <= n terms.
presolve_lib.tex(,742) @* L[2]: number of corresponding generator of id
presolve_lib.tex(,743) 
presolve_lib.tex(,744) @item @strong{Note:}
presolve_lib.tex(,745) May be used to compute partial standard basis in case id is to hard
presolve_lib.tex(,746) 
presolve_lib.tex(,747) @end table
presolve_lib.tex(,748) @strong{Example:}
presolve_lib.tex(,749) @smallexample
presolve_lib.tex(,750) @c reused example shortid d2t_singular/presolve_lib.doc:594 
presolve_lib.tex(,751) LIB "presolve.lib";
presolve_lib.tex(,752) ring s=0,(x,y,z,w),dp;
presolve_lib.tex(,753) ideal i = (x3+y2+yw2)^2,(xz+z2)^2,xyz-w2-xzw; 
presolve_lib.tex(,754) shortid(i,3);
presolve_lib.tex(,755) @expansion{} _[1]=x2z2+2xz3+z4
presolve_lib.tex(,756) @expansion{} _[2]=xyz-xzw-w2
presolve_lib.tex(,757) @c end example shortid d2t_singular/presolve_lib.doc:594
presolve_lib.tex(,758) @end smallexample
presolve_lib.tex(,759) @c ---end content shortid---
presolve_lib.tex(,760) 
presolve_lib.tex(,761) @c ------------------- valvars -------------
presolve_lib.tex(,762) @node valvars, idealSimplify, shortid, presolve_lib
presolve_lib.tex(,763) @subsubsection valvars
presolve_lib.tex(,764) @cindex valvars
presolve_lib.tex(,765) @c ---content valvars---
presolve_lib.tex(,766) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,767) 
presolve_lib.tex(,768) @table @asis
presolve_lib.tex(,769) @item @strong{Usage:}
presolve_lib.tex(,770) valvars(id[,n1,p1,n2,p2,...]);@*
presolve_lib.tex(,771) id=poly/ideal/vector/module,@*
presolve_lib.tex(,772) p1,p2,...= polynomials (product of vars),@*
presolve_lib.tex(,773) n1,n2,...= integers,
presolve_lib.tex(,774) 
presolve_lib.tex(,775) ni controls the ordering of vars occurring in pi: ni=0 (resp.!=0) means
presolve_lib.tex(,776) that less (resp. more) complex vars come first@*
presolve_lib.tex(,777) (default: p1=product of all vars, n1=0)
presolve_lib.tex(,778) @*the last pi (containing the remaining vars) may be omitted
presolve_lib.tex(,779) 
presolve_lib.tex(,780) @item @strong{Compute:}
presolve_lib.tex(,781) valuation (complexity) of variables with respect to id.@*
presolve_lib.tex(,782) ni controls the ordering of vars occurring in pi:@*
presolve_lib.tex(,783) ni=0 (resp.!=0) means that less (resp. more) complex vars come first.
presolve_lib.tex(,784) 
presolve_lib.tex(,785) @item @strong{Return:}
presolve_lib.tex(,786) list with 3 entries:
presolve_lib.tex(,787)   @format
presolve_lib.tex(,788)   [1]: intvec, say v, describing the permutation such that the permuted
presolve_lib.tex(,789)        ringvariables are ordered with respect to their complexity in id
presolve_lib.tex(,790)   [2]: list of intvecs, i-th intvec, say v(i) describing permutation
presolve_lib.tex(,791)        of vars in a(i) such that v=v(1),v(2),...
presolve_lib.tex(,792)   [3]: list of ideals and intmat's, say a(i) and M(i), where
presolve_lib.tex(,793)        a(i): factors of pi,
presolve_lib.tex(,794)        M(i): valuation matrix of a(i), such that the j-th column of M(i)
presolve_lib.tex(,795)              is the valuation vector of j-th generator of a(i)
presolve_lib.tex(,796)          @end format
presolve_lib.tex(,797) 
presolve_lib.tex(,798) @item @strong{Note:}
presolve_lib.tex(,799) Use @code{sortvars} in order to actually sort the variables!
presolve_lib.tex(,800) We define a variable x to be more complex than y (with respect to id)
presolve_lib.tex(,801) if val(x) > val(y) lexicographically, where val(x) denotes the
presolve_lib.tex(,802) valuation vector of x:@*
presolve_lib.tex(,803) consider id as list of polynomials in x with coefficients in the
presolve_lib.tex(,804) remaining variables. Then:@*
presolve_lib.tex(,805) val(x) = (maximal occurring power of x, # of all monomials in leading
presolve_lib.tex(,806) coefficient, # of all monomials in coefficient of next smaller power
presolve_lib.tex(,807) of x,...).
presolve_lib.tex(,808) 
presolve_lib.tex(,809) @end table
presolve_lib.tex(,810) @strong{Example:}
presolve_lib.tex(,811) @smallexample
presolve_lib.tex(,812) @c reused example valvars d2t_singular/presolve_lib.doc:654 
presolve_lib.tex(,813) LIB "presolve.lib";
presolve_lib.tex(,814) ring s=0,(x,y,z,a,b),dp;
presolve_lib.tex(,815) ideal i=ax2+ay3-b2x,abz+by2;
presolve_lib.tex(,816) valvars (i,0,xyz);
presolve_lib.tex(,817) @expansion{} [1]:
presolve_lib.tex(,818) @expansion{}    3,1,2,4,5
presolve_lib.tex(,819) @expansion{} [2]:
presolve_lib.tex(,820) @expansion{}    [1]:
presolve_lib.tex(,821) @expansion{}       3,1,2
presolve_lib.tex(,822) @expansion{}    [2]:
presolve_lib.tex(,823) @expansion{}       1,2
presolve_lib.tex(,824) @expansion{} [3]:
presolve_lib.tex(,825) @expansion{}    [1]:
presolve_lib.tex(,826) @expansion{}       _[1]=x
presolve_lib.tex(,827) @expansion{}       _[2]=y
presolve_lib.tex(,828) @expansion{}       _[3]=z
presolve_lib.tex(,829) @expansion{}    [2]:
presolve_lib.tex(,830) @expansion{}       2,3,1,
presolve_lib.tex(,831) @expansion{}       1,1,1,
presolve_lib.tex(,832) @expansion{}       1,1,0 
presolve_lib.tex(,833) @expansion{}    [3]:
presolve_lib.tex(,834) @expansion{}       _[1]=a
presolve_lib.tex(,835) @expansion{}       _[2]=b
presolve_lib.tex(,836) @expansion{}    [4]:
presolve_lib.tex(,837) @expansion{}       1,2,
presolve_lib.tex(,838) @expansion{}       3,1,
presolve_lib.tex(,839) @expansion{}       0,2 
presolve_lib.tex(,840) @c end example valvars d2t_singular/presolve_lib.doc:654
presolve_lib.tex(,841) @end smallexample
presolve_lib.tex(,842) @c ---end content valvars---
presolve_lib.tex(,843) 
presolve_lib.tex(,844) @c ------------------- idealSimplify -------------
presolve_lib.tex(,845) @node idealSimplify, idealSplit, valvars, presolve_lib
presolve_lib.tex(,846) @subsubsection idealSimplify
presolve_lib.tex(,847) @cindex idealSimplify
presolve_lib.tex(,848) @c ---content idealSimplify---
presolve_lib.tex(,849) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,850) 
presolve_lib.tex(,851) @table @asis
presolve_lib.tex(,852) @item @strong{Usage:}
presolve_lib.tex(,853) idealSimplify(id); id ideal
presolve_lib.tex(,854) 
presolve_lib.tex(,855) @item @strong{Return:}
presolve_lib.tex(,856) ideal I = eliminate(Id,m) m is a product of variables
presolve_lib.tex(,857) which are only linearly involved in the generators of id
presolve_lib.tex(,858) 
presolve_lib.tex(,859) @end table
presolve_lib.tex(,860) @strong{Example:}
presolve_lib.tex(,861) @smallexample
presolve_lib.tex(,862) @c reused example idealSimplify d2t_singular/presolve_lib.doc:681 
presolve_lib.tex(,863) LIB "presolve.lib";
presolve_lib.tex(,864) ring r=0,(x,y,z,w,t),dp;
presolve_lib.tex(,865) ideal i=
presolve_lib.tex(,866) t,
presolve_lib.tex(,867) x3+y2+2z,
presolve_lib.tex(,868) x2+3y,
presolve_lib.tex(,869) x2+y2+z2,
presolve_lib.tex(,870) w2+z;
presolve_lib.tex(,871) ideal j=idealSimplify(i);
presolve_lib.tex(,872) ideal k=eliminate(i,zyt);
presolve_lib.tex(,873) reduce(k,std(j));
presolve_lib.tex(,874) @expansion{} _[1]=0
presolve_lib.tex(,875) @expansion{} _[2]=0
presolve_lib.tex(,876) reduce(j,std(k));
presolve_lib.tex(,877) @expansion{} _[1]=0
presolve_lib.tex(,878) @expansion{} _[2]=0
presolve_lib.tex(,879) @c end example idealSimplify d2t_singular/presolve_lib.doc:681
presolve_lib.tex(,880) @end smallexample
presolve_lib.tex(,881) @c ---end content idealSimplify---
presolve_lib.tex(,882) 
presolve_lib.tex(,883) @c ------------------- idealSplit -------------
presolve_lib.tex(,884) @node idealSplit,, idealSimplify, presolve_lib
presolve_lib.tex(,885) @subsubsection idealSplit
presolve_lib.tex(,886) @cindex idealSplit
presolve_lib.tex(,887) @c ---content idealSplit---
presolve_lib.tex(,888) Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).
presolve_lib.tex(,889) 
presolve_lib.tex(,890) @table @asis
presolve_lib.tex(,891) @item @strong{Usage:}
presolve_lib.tex(,892) idealSplit(id,timeF,timeS); id ideal and optional
presolve_lib.tex(,893) @*timeF ,timeS integers to bound the time which can be used
presolve_lib.tex(,894) for factorization resp. standard basis computation
presolve_lib.tex(,895) 
presolve_lib.tex(,896) @item @strong{Return:}
presolve_lib.tex(,897) a list of ideals such that their intersection
presolve_lib.tex(,898) @*has the same radical as id
presolve_lib.tex(,899) 
presolve_lib.tex(,900) @end table
presolve_lib.tex(,901) @strong{Example:}
presolve_lib.tex(,902) @smallexample
presolve_lib.tex(,903) @c reused example idealSplit d2t_singular/presolve_lib.doc:718 
presolve_lib.tex(,904) LIB "presolve.lib";
presolve_lib.tex(,905) ring r=32003,(b,s,t,u,v,w,x,y,z),dp;
presolve_lib.tex(,906) ideal i=
presolve_lib.tex(,907) bv+su,
presolve_lib.tex(,908) bw+tu,
presolve_lib.tex(,909) sw+tv,
presolve_lib.tex(,910) by+sx,
presolve_lib.tex(,911) bz+tx,
presolve_lib.tex(,912) sz+ty,
presolve_lib.tex(,913) uy+vx,
presolve_lib.tex(,914) uz+wx,
presolve_lib.tex(,915) vz+wy,
presolve_lib.tex(,916) bvz;
presolve_lib.tex(,917) idealSplit(i);
presolve_lib.tex(,918) @expansion{} [1]:
presolve_lib.tex(,919) @expansion{}    _[1]=x
presolve_lib.tex(,920) @expansion{}    _[2]=u
presolve_lib.tex(,921) @expansion{}    _[3]=t
presolve_lib.tex(,922) @expansion{}    _[4]=s
presolve_lib.tex(,923) @expansion{}    _[5]=b
presolve_lib.tex(,924) @expansion{}    _[6]=wy+vz
presolve_lib.tex(,925) @expansion{} [2]:
presolve_lib.tex(,926) @expansion{}    _[1]=z
presolve_lib.tex(,927) @expansion{}    _[2]=w
presolve_lib.tex(,928) @expansion{}    _[3]=t
presolve_lib.tex(,929) @expansion{}    _[4]=s
presolve_lib.tex(,930) @expansion{}    _[5]=b
presolve_lib.tex(,931) @expansion{}    _[6]=vx+uy
presolve_lib.tex(,932) @expansion{} [3]:
presolve_lib.tex(,933) @expansion{}    _[1]=z
presolve_lib.tex(,934) @expansion{}    _[2]=x
presolve_lib.tex(,935) @expansion{}    _[3]=w
presolve_lib.tex(,936) @expansion{}    _[4]=u
presolve_lib.tex(,937) @expansion{}    _[5]=t
presolve_lib.tex(,938) @expansion{}    _[6]=b
presolve_lib.tex(,939) @expansion{} [4]:
presolve_lib.tex(,940) @expansion{}    _[1]=z
presolve_lib.tex(,941) @expansion{}    _[2]=y
presolve_lib.tex(,942) @expansion{}    _[3]=x
presolve_lib.tex(,943) @expansion{}    _[4]=t
presolve_lib.tex(,944) @expansion{}    _[5]=s
presolve_lib.tex(,945) @expansion{}    _[6]=b
presolve_lib.tex(,946) @expansion{} [5]:
presolve_lib.tex(,947) @expansion{}    _[1]=z
presolve_lib.tex(,948) @expansion{}    _[2]=y
presolve_lib.tex(,949) @expansion{}    _[3]=x
presolve_lib.tex(,950) @expansion{}    _[4]=u
presolve_lib.tex(,951) @expansion{}    _[5]=b
presolve_lib.tex(,952) @expansion{}    _[6]=tv+sw
presolve_lib.tex(,953) @expansion{} [6]:
presolve_lib.tex(,954) @expansion{}    _[1]=z
presolve_lib.tex(,955) @expansion{}    _[2]=y
presolve_lib.tex(,956) @expansion{}    _[3]=x
presolve_lib.tex(,957) @expansion{}    _[4]=w
presolve_lib.tex(,958) @expansion{}    _[5]=t
presolve_lib.tex(,959) @expansion{}    _[6]=su+bv
presolve_lib.tex(,960) @expansion{} [7]:
presolve_lib.tex(,961) @expansion{}    _[1]=w
presolve_lib.tex(,962) @expansion{}    _[2]=v
presolve_lib.tex(,963) @expansion{}    _[3]=u
presolve_lib.tex(,964) @expansion{}    _[4]=t
presolve_lib.tex(,965) @expansion{}    _[5]=s
presolve_lib.tex(,966) @expansion{}    _[6]=b
presolve_lib.tex(,967) @expansion{} [8]:
presolve_lib.tex(,968) @expansion{}    _[1]=x
presolve_lib.tex(,969) @expansion{}    _[2]=w
presolve_lib.tex(,970) @expansion{}    _[3]=v
presolve_lib.tex(,971) @expansion{}    _[4]=u
presolve_lib.tex(,972) @expansion{}    _[5]=b
presolve_lib.tex(,973) @expansion{}    _[6]=ty+sz
presolve_lib.tex(,974) @expansion{} [9]:
presolve_lib.tex(,975) @expansion{}    _[1]=z
presolve_lib.tex(,976) @expansion{}    _[2]=w
presolve_lib.tex(,977) @expansion{}    _[3]=v
presolve_lib.tex(,978) @expansion{}    _[4]=u
presolve_lib.tex(,979) @expansion{}    _[5]=t
presolve_lib.tex(,980) @expansion{}    _[6]=sx+by
presolve_lib.tex(,981) @expansion{} [10]:
presolve_lib.tex(,982) @expansion{}    _[1]=z
presolve_lib.tex(,983) @expansion{}    _[2]=y
presolve_lib.tex(,984) @expansion{}    _[3]=x
presolve_lib.tex(,985) @expansion{}    _[4]=w
presolve_lib.tex(,986) @expansion{}    _[5]=v
presolve_lib.tex(,987) @expansion{}    _[6]=u
presolve_lib.tex(,988) @expansion{} [11]:
presolve_lib.tex(,989) @expansion{}    _[1]=y
presolve_lib.tex(,990) @expansion{}    _[2]=v
presolve_lib.tex(,991) @expansion{}    _[3]=t
presolve_lib.tex(,992) @expansion{}    _[4]=s
presolve_lib.tex(,993) @expansion{}    _[5]=b
presolve_lib.tex(,994) @expansion{}    _[6]=wx+uz
presolve_lib.tex(,995) @expansion{} [12]:
presolve_lib.tex(,996) @expansion{}    _[1]=y
presolve_lib.tex(,997) @expansion{}    _[2]=x
presolve_lib.tex(,998) @expansion{}    _[3]=v
presolve_lib.tex(,999) @expansion{}    _[4]=u
presolve_lib.tex(,1000) @expansion{}    _[5]=s
presolve_lib.tex(,1001) @expansion{}    _[6]=b
presolve_lib.tex(,1002) @expansion{} [13]:
presolve_lib.tex(,1003) @expansion{}    _[1]=z
presolve_lib.tex(,1004) @expansion{}    _[2]=y
presolve_lib.tex(,1005) @expansion{}    _[3]=x
presolve_lib.tex(,1006) @expansion{}    _[4]=v
presolve_lib.tex(,1007) @expansion{}    _[5]=s
presolve_lib.tex(,1008) @expansion{}    _[6]=tu+bw
presolve_lib.tex(,1009) @expansion{} [14]:
presolve_lib.tex(,1010) @expansion{}    _[1]=z
presolve_lib.tex(,1011) @expansion{}    _[2]=y
presolve_lib.tex(,1012) @expansion{}    _[3]=w
presolve_lib.tex(,1013) @expansion{}    _[4]=v
presolve_lib.tex(,1014) @expansion{}    _[5]=t
presolve_lib.tex(,1015) @expansion{}    _[6]=s
presolve_lib.tex(,1016) @expansion{} [15]:
presolve_lib.tex(,1017) @expansion{}    _[1]=y
presolve_lib.tex(,1018) @expansion{}    _[2]=w
presolve_lib.tex(,1019) @expansion{}    _[3]=v
presolve_lib.tex(,1020) @expansion{}    _[4]=u
presolve_lib.tex(,1021) @expansion{}    _[5]=s
presolve_lib.tex(,1022) @expansion{}    _[6]=tx+bz
presolve_lib.tex(,1023) @c end example idealSplit d2t_singular/presolve_lib.doc:718
presolve_lib.tex(,1024) @end smallexample
presolve_lib.tex(,1025) @c ---end content idealSplit---
singular.texi(,550) @c ---------------------------------------------------------
singular.texi(,551) @node solve_lib, triang_lib, presolve_lib, Symbolic-numerical solving
singular.texi(,552) @subsection solve_lib
singular.texi(,553) @c include of docu for solve.lib
solve_lib.tex(,1) @c ---content LibInfo---
solve_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/solve_lib.doc
solve_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/solve_lib.doc INSTEAD
solve_lib.tex(,4) @c library version: (1.21.2.14,2003/05/16)
solve_lib.tex(,5) @c library file: ../Singular/LIB/solve.lib
solve_lib.tex(,6) @cindex solve.lib
solve_lib.tex(,7) @cindex solve_lib
solve_lib.tex(,8) @table @asis
solve_lib.tex(,9) @item @strong{Library:}
solve_lib.tex(,10) solve.lib
solve_lib.tex(,11) @item @strong{Purpose:}
solve_lib.tex(,12)      Complex Solving of Polynomial Systems
solve_lib.tex(,13) @item @strong{Author:}
solve_lib.tex(,14) Moritz Wenk, email: wenk@@mathematik.uni-kl.de
solve_lib.tex(,15) @*Wilfred Pohl, email: pohl@@mathematik.uni-kl.de
solve_lib.tex(,16) 
solve_lib.tex(,17) @end table
solve_lib.tex(,18) 
solve_lib.tex(,19) @strong{Procedures:}
solve_lib.tex(,20) @menu
solve_lib.tex(,21) * laguerre_solve:: find all roots of univariate polynomial p
solve_lib.tex(,22) * solve:: all roots of 0-dim. ideal i using triangular sets
solve_lib.tex(,23) * ures_solve:: find all roots of 0-dimensional ideal i with resultants
solve_lib.tex(,24) * mp_res_mat:: multipolynomial resultant matrix of ideal i
solve_lib.tex(,25) * interpolate:: interpolate poly from evaluation points i and results j
solve_lib.tex(,26) * fglm_solve:: find roots of 0-dim. ideal using FGLM and lex_solve
solve_lib.tex(,27) * lex_solve:: find roots of reduced lexicographic standard basis
solve_lib.tex(,28) * simplexOut:: prints solution of simplex in nice format
solve_lib.tex(,29) * triangLf_solve:: find roots using triangular sys. (factorizing Lazard)
solve_lib.tex(,30) * triangM_solve:: find roots of given triangular system (Moeller)
solve_lib.tex(,31) * triangL_solve:: find roots using triangular system (Lazard)
solve_lib.tex(,32) * triang_solve:: find roots of given triangular system
solve_lib.tex(,33) @end menu
solve_lib.tex(,34) @c ---end content LibInfo---
solve_lib.tex(,35) 
solve_lib.tex(,36) @c ------------------- laguerre_solve -------------
solve_lib.tex(,37) @node laguerre_solve, solve,, solve_lib
solve_lib.tex(,38) @subsubsection laguerre_solve
solve_lib.tex(,39) @cindex laguerre_solve
solve_lib.tex(,40) @c ---content laguerre_solve---
solve_lib.tex(,41) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,42) 
solve_lib.tex(,43) @table @asis
solve_lib.tex(,44) @item @strong{Usage:}
solve_lib.tex(,45) laguerre_solve(f [, m, l, n, s] ); f = polynomial,@*
solve_lib.tex(,46) m, l, n, s = integers (control parameters of the method)
solve_lib.tex(,47) @format
solve_lib.tex(,48)  m: precision of output in digits ( 4 <= m), if basering is not ring of 
solve_lib.tex(,49)       complex numbers;
solve_lib.tex(,50)  l: precision of internal computation in decimal digits ( l >=8 )
solve_lib.tex(,51)       only if the basering is not complex or complex with smaller precision;
solve_lib.tex(,52)  n: control of multiplicity of roots or of splitting of f into
solve_lib.tex(,53)       squarefree factors
solve_lib.tex(,54)       n < 0, no split of f (good, if all roots are simple)
solve_lib.tex(,55)       n >= 0, try to split
solve_lib.tex(,56)       n = 0, return only different roots
solve_lib.tex(,57)       n > 0, find all roots (with multiplicity)
solve_lib.tex(,58)  s: s != 0, returns ERROR if  | f(root) | > 0.1^m (when computing in the 
solve_lib.tex(,59)       current ring)
solve_lib.tex(,60)  ( default: m, l, n, s = 8, 30, 1, 0 )
solve_lib.tex(,61) @end format
solve_lib.tex(,62) 
solve_lib.tex(,63) @item @strong{Assume:}
solve_lib.tex(,64) f is a univariate polynomial;@*
solve_lib.tex(,65) basering has characteristic 0 and is either complex or without
solve_lib.tex(,66) parameters.
solve_lib.tex(,67) 
solve_lib.tex(,68) @item @strong{Return:}
solve_lib.tex(,69) list of (complex) roots of the polynomial f, depending on n. The
solve_lib.tex(,70) result is of type
solve_lib.tex(,71) @format
solve_lib.tex(,72)  string: if the basering is not complex,
solve_lib.tex(,73)  number: otherwise.
solve_lib.tex(,74) @end format
solve_lib.tex(,75) 
solve_lib.tex(,76) @item @strong{Note:}
solve_lib.tex(,77) If printlevel >0: displays comments ( default = 0 ).
solve_lib.tex(,78) @*If s != 0 and if the procedure stops with ERROR, try a higher
solve_lib.tex(,79) internal precision m.
solve_lib.tex(,80) 
solve_lib.tex(,81) @end table
solve_lib.tex(,82) @strong{Example:}
solve_lib.tex(,83) @smallexample
solve_lib.tex(,84) @c reused example laguerre_solve d2t_singular/solve_lib.doc:82 
solve_lib.tex(,85) LIB "solve.lib";
solve_lib.tex(,86) // Find all roots of an univariate polynomial using Laguerre's method:
solve_lib.tex(,87) ring rs1= 0,(x,y),lp;
solve_lib.tex(,88) poly f = 15x5 + x3 + x2 - 10;
solve_lib.tex(,89) // 10 digits precision
solve_lib.tex(,90) laguerre_solve(f,10);
solve_lib.tex(,91) @expansion{} [1]:
solve_lib.tex(,92) @expansion{}    (0.2930464644-i*0.9003002396)
solve_lib.tex(,93) @expansion{} [2]:
solve_lib.tex(,94) @expansion{}    (0.2930464644+i*0.9003002396)
solve_lib.tex(,95) @expansion{} [3]:
solve_lib.tex(,96) @expansion{}    (-0.7392783383-i*0.5355190078)
solve_lib.tex(,97) @expansion{} [4]:
solve_lib.tex(,98) @expansion{}    (-0.7392783383+i*0.5355190078)
solve_lib.tex(,99) @expansion{} [5]:
solve_lib.tex(,100) @expansion{}    0.8924637479
solve_lib.tex(,101) // Now with complex coefficients,
solve_lib.tex(,102) // internal precision is 30 digits (default)
solve_lib.tex(,103) printlevel=2;
solve_lib.tex(,104) ring rsc= (real,10,i),x,lp;
solve_lib.tex(,105) poly f = (15.4+i*5)*x^5 + (25.0e-2+i*2)*x^3 + x2 - 10*i;
solve_lib.tex(,106) list l = laguerre_solve(f);
solve_lib.tex(,107) @expansion{} //BEGIN laguerre_solve
solve_lib.tex(,108) @expansion{} //control: complex ring with precision 30
solve_lib.tex(,109) @expansion{} //working in:  ring lagc=(complex,30,30),x,lp;
solve_lib.tex(,110) @expansion{} //         polynomial has complex coefficients
solve_lib.tex(,111) @expansion{} //split in working ring:
solve_lib.tex(,112) @expansion{} // split without result
solve_lib.tex(,113) @expansion{} //END laguerre_solve
solve_lib.tex(,114) l;
solve_lib.tex(,115) @expansion{} [1]:
solve_lib.tex(,116) @expansion{}    (0.04588498039+i*0.9133296179)
solve_lib.tex(,117) @expansion{} [2]:
solve_lib.tex(,118) @expansion{}    (0.5037408279-i*0.8058051828)
solve_lib.tex(,119) @expansion{} [3]:
solve_lib.tex(,120) @expansion{}    (-0.5462895588-i*0.6796668873)
solve_lib.tex(,121) @expansion{} [4]:
solve_lib.tex(,122) @expansion{}    (0.8524014357+i*0.2163760334)
solve_lib.tex(,123) @expansion{} [5]:
solve_lib.tex(,124) @expansion{}    (-0.8557376852+i*0.3557664188)
solve_lib.tex(,125) // check result, value of substituted poly should be near to zero
solve_lib.tex(,126) // remember that l contains a list of strings
solve_lib.tex(,127) // in the case of a different ring
solve_lib.tex(,128) subst(f,x,l[1]);
solve_lib.tex(,129) @expansion{} 0
solve_lib.tex(,130) subst(f,x,l[2]);
solve_lib.tex(,131) @expansion{} 0
solve_lib.tex(,132) @c end example laguerre_solve d2t_singular/solve_lib.doc:82
solve_lib.tex(,133) @end smallexample
solve_lib.tex(,134) @c ---end content laguerre_solve---
solve_lib.tex(,135) 
solve_lib.tex(,136) @c ------------------- solve -------------
solve_lib.tex(,137) @node solve, ures_solve, laguerre_solve, solve_lib
solve_lib.tex(,138) @subsubsection solve
solve_lib.tex(,139) @cindex solve
solve_lib.tex(,140) @c ---content solve---
solve_lib.tex(,141) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,142) 
solve_lib.tex(,143) @table @asis
solve_lib.tex(,144) @item @strong{Assume:}
solve_lib.tex(,145) the ideal is 0-dimensional;@*
solve_lib.tex(,146) basering has characteristic 0 and is either complex or
solve_lib.tex(,147) without parameters;
solve_lib.tex(,148) 
solve_lib.tex(,149) @item @strong{Return:}
solve_lib.tex(,150) list of solutions of the ideal G, depending on n; one solution is a
solve_lib.tex(,151) list of complex numbers in the generated output ring (the new
solve_lib.tex(,152) basering).
solve_lib.tex(,153) @format
solve_lib.tex(,154)  The result is a list L
solve_lib.tex(,155)     n  = 0: a list of all different solutions (L[i]),
solve_lib.tex(,156)     n != 0: a list of two elements,
solve_lib.tex(,157)             L[i][1] contains all different solutions with the same multiplicity
solve_lib.tex(,158)             L[i][2] the multiplicity
solve_lib.tex(,159)  L is ordered w.r.t. multiplicity (the smallest first).
solve_lib.tex(,160) @end format
solve_lib.tex(,161) 
solve_lib.tex(,162) @item @strong{Note:}
solve_lib.tex(,163) If the problem is not 0-dim. the procedure stops with ERROR, if the
solve_lib.tex(,164) ideal G is not a lex. standard basis, it is generated with internal
solve_lib.tex(,165) computation (Hilbert driven), if the input-ring (with char 0) has
solve_lib.tex(,166) the name "<A>", the lexicographical and complex output-ring has the
solve_lib.tex(,167) name "<A>C".
solve_lib.tex(,168) 
solve_lib.tex(,169) @end table
solve_lib.tex(,170) @strong{Example:}
solve_lib.tex(,171) @smallexample
solve_lib.tex(,172) @c reused example solve d2t_singular/solve_lib.doc:141 
solve_lib.tex(,173) LIB "solve.lib";
solve_lib.tex(,174) // Find all roots of a multivariate ideal using triangular sets:
solve_lib.tex(,175) int d=4;// with these 3 parameters you may construct
solve_lib.tex(,176) int t=3;// very hard problems for 'solve'
solve_lib.tex(,177) int s=2;
solve_lib.tex(,178) int i;
solve_lib.tex(,179) ring A=0,(x(1..d)),dp;
solve_lib.tex(,180) poly p=-1;
solve_lib.tex(,181) for(i=d;i>0;i--)@{p=p+x(i)^s;@}
solve_lib.tex(,182) ideal I=x(d)^t-x(d)^s+p;
solve_lib.tex(,183) for(i=d-1;i>0;i--)@{I=x(i)^t-x(i)^s+p,I;@}
solve_lib.tex(,184) I;
solve_lib.tex(,185) @expansion{} I[1]=x(1)^3+x(2)^2+x(3)^2+x(4)^2-1
solve_lib.tex(,186) @expansion{} I[2]=x(2)^3+x(1)^2+x(3)^2+x(4)^2-1
solve_lib.tex(,187) @expansion{} I[3]=x(3)^3+x(1)^2+x(2)^2+x(4)^2-1
solve_lib.tex(,188) @expansion{} I[4]=x(4)^3+x(1)^2+x(2)^2+x(3)^2-1
solve_lib.tex(,189) // the mutiplicity is
solve_lib.tex(,190) vdim(std(I));
solve_lib.tex(,191) @expansion{} 81
solve_lib.tex(,192) list l1=solve(I,6,0);
solve_lib.tex(,193) @expansion{} // name of new current ring: AC
solve_lib.tex(,194) // the current ring is
solve_lib.tex(,195) AC;
solve_lib.tex(,196) @expansion{} //   characteristic : 0 (complex:6 digits, additional 6 digits)
solve_lib.tex(,197) @expansion{} //   1 parameter    : i 
solve_lib.tex(,198) @expansion{} //   minpoly        : (i^2+1)
solve_lib.tex(,199) @expansion{} //   number of vars : 4
solve_lib.tex(,200) @expansion{} //        block   1 : ordering lp
solve_lib.tex(,201) @expansion{} //                  : names    x(1) x(2) x(3) x(4) 
solve_lib.tex(,202) @expansion{} //        block   2 : ordering C
solve_lib.tex(,203) // you must start with char. 0
solve_lib.tex(,204) setring A;
solve_lib.tex(,205) list l2=solve(I,6,1);
solve_lib.tex(,206) @expansion{} // name of current ring: AC
solve_lib.tex(,207) // the number of different solutions is
solve_lib.tex(,208) size(l1);
solve_lib.tex(,209) @expansion{} 37
solve_lib.tex(,210) // this is equal to
solve_lib.tex(,211) size(l2[1][1])+size(l2[2][1]);
solve_lib.tex(,212) @expansion{} 37
solve_lib.tex(,213) // the number of solutions with multiplicity is
solve_lib.tex(,214) size(l2[1][1])*l2[1][2]+size(l2[2][1])*l2[2][2];
solve_lib.tex(,215) @expansion{} 81
solve_lib.tex(,216) // the solutions with multiplicity
solve_lib.tex(,217) l2[2][2];
solve_lib.tex(,218) @expansion{} 12
solve_lib.tex(,219) // are
solve_lib.tex(,220) l2[2][1];
solve_lib.tex(,221) @expansion{} [1]:
solve_lib.tex(,222) @expansion{}    [1]:
solve_lib.tex(,223) @expansion{}       0
solve_lib.tex(,224) @expansion{}    [2]:
solve_lib.tex(,225) @expansion{}       0
solve_lib.tex(,226) @expansion{}    [3]:
solve_lib.tex(,227) @expansion{}       1
solve_lib.tex(,228) @expansion{}    [4]:
solve_lib.tex(,229) @expansion{}       0
solve_lib.tex(,230) @expansion{} [2]:
solve_lib.tex(,231) @expansion{}    [1]:
solve_lib.tex(,232) @expansion{}       0
solve_lib.tex(,233) @expansion{}    [2]:
solve_lib.tex(,234) @expansion{}       1
solve_lib.tex(,235) @expansion{}    [3]:
solve_lib.tex(,236) @expansion{}       0
solve_lib.tex(,237) @expansion{}    [4]:
solve_lib.tex(,238) @expansion{}       0
solve_lib.tex(,239) @expansion{} [3]:
solve_lib.tex(,240) @expansion{}    [1]:
solve_lib.tex(,241) @expansion{}       1
solve_lib.tex(,242) @expansion{}    [2]:
solve_lib.tex(,243) @expansion{}       0
solve_lib.tex(,244) @expansion{}    [3]:
solve_lib.tex(,245) @expansion{}       0
solve_lib.tex(,246) @expansion{}    [4]:
solve_lib.tex(,247) @expansion{}       0
solve_lib.tex(,248) @expansion{} [4]:
solve_lib.tex(,249) @expansion{}    [1]:
solve_lib.tex(,250) @expansion{}       0
solve_lib.tex(,251) @expansion{}    [2]:
solve_lib.tex(,252) @expansion{}       0
solve_lib.tex(,253) @expansion{}    [3]:
solve_lib.tex(,254) @expansion{}       0
solve_lib.tex(,255) @expansion{}    [4]:
solve_lib.tex(,256) @expansion{}       1
solve_lib.tex(,257) @c end example solve d2t_singular/solve_lib.doc:141
solve_lib.tex(,258) @end smallexample
solve_lib.tex(,259) @c ---end content solve---
solve_lib.tex(,260) 
solve_lib.tex(,261) @c ------------------- ures_solve -------------
solve_lib.tex(,262) @node ures_solve, mp_res_mat, solve, solve_lib
solve_lib.tex(,263) @subsubsection ures_solve
solve_lib.tex(,264) @cindex ures_solve
solve_lib.tex(,265) @c ---content ures_solve---
solve_lib.tex(,266) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,267) 
solve_lib.tex(,268) @table @asis
solve_lib.tex(,269) @item @strong{Usage:}
solve_lib.tex(,270) ures_solve(i [, k, p] ); i = ideal, k, p = integers
solve_lib.tex(,271) @format
solve_lib.tex(,272)    k=0: use sparse resultant matrix of Gelfand, Kapranov and Zelevinsky,
solve_lib.tex(,273)    k=1: use resultant matrix of Macaulay which works only for
solve_lib.tex(,274)           homogeneous ideals,
solve_lib.tex(,275)    p>0: defines precision of the long floats for internal computation
solve_lib.tex(,276)           if the basering is not complex (in decimal digits),
solve_lib.tex(,277)    (default: k=0, p=30)
solve_lib.tex(,278) @end format
solve_lib.tex(,279) 
solve_lib.tex(,280) @item @strong{Assume:}
solve_lib.tex(,281) i is a zerodimensional ideal with
solve_lib.tex(,282) @*nvars(basering) = ncols(i) = number of vars
solve_lib.tex(,283) @*actually occurring in i,
solve_lib.tex(,284) 
solve_lib.tex(,285) @item @strong{Return:}
solve_lib.tex(,286) list of all (complex) roots of the polynomial system i = 0; the
solve_lib.tex(,287) result is of type
solve_lib.tex(,288) @format
solve_lib.tex(,289)    string: if the basering is not complex,
solve_lib.tex(,290)    number: otherwise.
solve_lib.tex(,291) @end format
solve_lib.tex(,292) 
solve_lib.tex(,293) @end table
solve_lib.tex(,294) @strong{Example:}
solve_lib.tex(,295) @smallexample
solve_lib.tex(,296) @c reused example ures_solve d2t_singular/solve_lib.doc:211 
solve_lib.tex(,297) LIB "solve.lib";
solve_lib.tex(,298) // compute the intersection points of two curves
solve_lib.tex(,299) ring rsq = 0,(x,y),lp;
solve_lib.tex(,300) ideal gls=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
solve_lib.tex(,301) ures_solve(gls,0,16);
solve_lib.tex(,302) @expansion{} [1]:
solve_lib.tex(,303) @expansion{}    [1]:
solve_lib.tex(,304) @expansion{}       1
solve_lib.tex(,305) @expansion{}    [2]:
solve_lib.tex(,306) @expansion{}       -3
solve_lib.tex(,307) @expansion{} [2]:
solve_lib.tex(,308) @expansion{}    [1]:
solve_lib.tex(,309) @expansion{}       -1
solve_lib.tex(,310) @expansion{}    [2]:
solve_lib.tex(,311) @expansion{}       3
solve_lib.tex(,312) @expansion{} [3]:
solve_lib.tex(,313) @expansion{}    [1]:
solve_lib.tex(,314) @expansion{}       2.82842712474619
solve_lib.tex(,315) @expansion{}    [2]:
solve_lib.tex(,316) @expansion{}       1.414213562373095
solve_lib.tex(,317) @expansion{} [4]:
solve_lib.tex(,318) @expansion{}    [1]:
solve_lib.tex(,319) @expansion{}       -2.82842712474619
solve_lib.tex(,320) @expansion{}    [2]:
solve_lib.tex(,321) @expansion{}       -1.414213562373095
solve_lib.tex(,322) // result is a list (x,y)-coordinates as strings
solve_lib.tex(,323) // now with complex coefficient field, precision is 20 digits
solve_lib.tex(,324) ring rsc= (real,20,I),(x,y),lp;
solve_lib.tex(,325) ideal i = (2+3*I)*x2 + (0.35+I*45.0e-2)*y2 - 8, x2 + xy + (42.7)*y2;
solve_lib.tex(,326) list l= ures_solve(i,0,10);
solve_lib.tex(,327) // result is a list of (x,y)-coordinates of complex numbers
solve_lib.tex(,328) l;
solve_lib.tex(,329) @expansion{} [1]:
solve_lib.tex(,330) @expansion{}    [1]:
solve_lib.tex(,331) @expansion{}       (-1.315392899374542198+I*0.70468233142752928117)
solve_lib.tex(,332) @expansion{}    [2]:
solve_lib.tex(,333) @expansion{}       (0.12292646536251281054+I*0.19245727404407015049)
solve_lib.tex(,334) @expansion{} [2]:
solve_lib.tex(,335) @expansion{}    [1]:
solve_lib.tex(,336) @expansion{}       (1.315392899374542198-I*0.70468233142752928117)
solve_lib.tex(,337) @expansion{}    [2]:
solve_lib.tex(,338) @expansion{}       (-0.12292646536251281054-I*0.19245727404407015049)
solve_lib.tex(,339) @expansion{} [3]:
solve_lib.tex(,340) @expansion{}    [1]:
solve_lib.tex(,341) @expansion{}       (1.31584587549391830705-I*0.70396753310002259573)
solve_lib.tex(,342) @expansion{}    [2]:
solve_lib.tex(,343) @expansion{}       (0.092006639590217681983+I*0.20902112035965287775)
solve_lib.tex(,344) @expansion{} [4]:
solve_lib.tex(,345) @expansion{}    [1]:
solve_lib.tex(,346) @expansion{}       (-1.31584587549391830705+I*0.70396753310002259573)
solve_lib.tex(,347) @expansion{}    [2]:
solve_lib.tex(,348) @expansion{}       (-0.092006639590217681983-I*0.20902112035965287775)
solve_lib.tex(,349) // check the result
solve_lib.tex(,350) subst(subst(i[1],x,l[1][1]),y,l[1][2]);
solve_lib.tex(,351) @expansion{} 0
solve_lib.tex(,352) @c end example ures_solve d2t_singular/solve_lib.doc:211
solve_lib.tex(,353) @end smallexample
solve_lib.tex(,354) @c ---end content ures_solve---
solve_lib.tex(,355) 
solve_lib.tex(,356) @c ------------------- mp_res_mat -------------
solve_lib.tex(,357) @node mp_res_mat, interpolate, ures_solve, solve_lib
solve_lib.tex(,358) @subsubsection mp_res_mat
solve_lib.tex(,359) @cindex mp_res_mat
solve_lib.tex(,360) @c ---content mp_res_mat---
solve_lib.tex(,361) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,362) 
solve_lib.tex(,363) @table @asis
solve_lib.tex(,364) @item @strong{Usage:}
solve_lib.tex(,365) mp_res_mat(i [, k] ); i ideal, k integer,
solve_lib.tex(,366) @format
solve_lib.tex(,367)     k=0: sparse resultant matrix of Gelfand, Kapranov and Zelevinsky,
solve_lib.tex(,368)     k=1: resultant matrix of Macaulay (k=0 is default)
solve_lib.tex(,369) @end format
solve_lib.tex(,370) 
solve_lib.tex(,371) @item @strong{Assume:}
solve_lib.tex(,372) The number of elements in the input system must be the number of
solve_lib.tex(,373) variables in the basering plus one;
solve_lib.tex(,374) @*if k=1 then i must be homogeneous.
solve_lib.tex(,375) 
solve_lib.tex(,376) @item @strong{Return:}
solve_lib.tex(,377) module representing the multipolynomial resultant matrix
solve_lib.tex(,378) 
solve_lib.tex(,379) @end table
solve_lib.tex(,380) @strong{Example:}
solve_lib.tex(,381) @smallexample
solve_lib.tex(,382) @c reused example mp_res_mat d2t_singular/solve_lib.doc:256 
solve_lib.tex(,383) LIB "solve.lib";
solve_lib.tex(,384) // compute resultant matrix in ring with parameters (sparse resultant matrix)
solve_lib.tex(,385) ring rsq= (0,u0,u1,u2),(x1,x2),lp;
solve_lib.tex(,386) ideal i= u0+u1*x1+u2*x2,x1^2 + x2^2 - 10,x1^2 + x1*x2 + 2*x2^2 - 16;
solve_lib.tex(,387) module m = mp_res_mat(i);
solve_lib.tex(,388) print(m);
solve_lib.tex(,389) @expansion{} -16,0,  -10,0,  (u0),0,   0,  0,   0,   0,  
solve_lib.tex(,390) @expansion{} 0,  -16,0,  -10,(u2),(u0),0,  0,   0,   0,  
solve_lib.tex(,391) @expansion{} 2,  0,  1,  0,  0,   (u2),0,  0,   0,   0,  
solve_lib.tex(,392) @expansion{} 0,  2,  0,  1,  0,   0,   0,  0,   0,   0,  
solve_lib.tex(,393) @expansion{} 0,  0,  0,  0,  (u1),0,   -10,(u0),0,   -16,
solve_lib.tex(,394) @expansion{} 1,  0,  0,  0,  0,   (u1),0,  (u2),(u0),0,  
solve_lib.tex(,395) @expansion{} 0,  1,  0,  0,  0,   0,   1,  0,   (u2),2,  
solve_lib.tex(,396) @expansion{} 1,  0,  1,  0,  0,   0,   0,  (u1),0,   0,  
solve_lib.tex(,397) @expansion{} 0,  1,  0,  1,  0,   0,   0,  0,   (u1),1,  
solve_lib.tex(,398) @expansion{} 0,  0,  0,  0,  0,   0,   1,  0,   0,   1   
solve_lib.tex(,399) // computing sparse resultant
solve_lib.tex(,400) det(m);
solve_lib.tex(,401) @expansion{} (-2*u0^4+18*u0^2*u1^2+4*u0^2*u1*u2+22*u0^2*u2^2-16*u1^4+80*u1^3*u2-52*u1^\
solve_lib.tex(,402)    2*u2^2-120*u1*u2^3-36*u2^4)
solve_lib.tex(,403) // compute resultant matrix (Macaulay resultant matrix)
solve_lib.tex(,404) ring rdq= (0,u0,u1,u2),(x0,x1,x2),lp;
solve_lib.tex(,405) ideal h=  homog(imap(rsq,i),x0);
solve_lib.tex(,406) h;
solve_lib.tex(,407) @expansion{} h[1]=(u0)*x0+(u1)*x1+(u2)*x2
solve_lib.tex(,408) @expansion{} h[2]=-10*x0^2+x1^2+x2^2
solve_lib.tex(,409) @expansion{} h[3]=-16*x0^2+x1^2+x1*x2+2*x2^2
solve_lib.tex(,410) module m = mp_res_mat(h,1);
solve_lib.tex(,411) print(m);
solve_lib.tex(,412) @expansion{} x0, x1, x2, 0, 0, 0, 0,0, 0, 0,
solve_lib.tex(,413) @expansion{} 0,  x0, 0,  x1,x2,0, 0,0, 0, 0,
solve_lib.tex(,414) @expansion{} 0,  0,  x0, 0, x1,x2,0,0, 0, 0,
solve_lib.tex(,415) @expansion{} -10,0,  0,  1, 0, 1, 0,0, 0, 0,
solve_lib.tex(,416) @expansion{} 0,  0,  0,  0, x0,0, 0,x1,x2,0,
solve_lib.tex(,417) @expansion{} -16,0,  0,  1, 1, 2, 0,0, 0, 0,
solve_lib.tex(,418) @expansion{} 0,  -10,0,  0, 0, 0, 1,0, 1, 0,
solve_lib.tex(,419) @expansion{} 0,  0,  -10,0, 0, 0, 0,1, 0, 1,
solve_lib.tex(,420) @expansion{} 0,  -16,0,  0, 0, 0, 1,1, 2, 0,
solve_lib.tex(,421) @expansion{} 0,  0,  -16,0, 0, 0, 0,1, 1, 2 
solve_lib.tex(,422) // computing Macaulay resultant (should be the same as above!)
solve_lib.tex(,423) det(m);
solve_lib.tex(,424) @expansion{} 2*x0^4-18*x0^2*x1^2-4*x0^2*x1*x2-22*x0^2*x2^2+16*x1^4-80*x1^3*x2+52*x1^2*\
solve_lib.tex(,425)    x2^2+120*x1*x2^3+36*x2^4
solve_lib.tex(,426) // compute numerical sparse resultant matrix
solve_lib.tex(,427) setring rsq;
solve_lib.tex(,428) ideal ir= 15+2*x1+5*x2,x1^2 + x2^2 - 10,x1^2 + x1*x2 + 2*x2^2 - 16;
solve_lib.tex(,429) module mn = mp_res_mat(ir);
solve_lib.tex(,430) print(mn);
solve_lib.tex(,431) @expansion{} 15,0, -10,0,  0, 0, 0,  -16,0,  0,  
solve_lib.tex(,432) @expansion{} 5, 15,0,  -10,0, 0, 0,  0,  -16,0,  
solve_lib.tex(,433) @expansion{} 0, 5, 1,  0,  0, 0, 0,  2,  0,  0,  
solve_lib.tex(,434) @expansion{} 0, 0, 0,  1,  0, 0, 0,  0,  2,  0,  
solve_lib.tex(,435) @expansion{} 2, 0, 0,  0,  15,0, -10,0,  0,  -16,
solve_lib.tex(,436) @expansion{} 0, 2, 0,  0,  5, 15,0,  1,  0,  0,  
solve_lib.tex(,437) @expansion{} 0, 0, 0,  0,  0, 5, 1,  0,  1,  2,  
solve_lib.tex(,438) @expansion{} 0, 0, 1,  0,  2, 0, 0,  1,  0,  0,  
solve_lib.tex(,439) @expansion{} 0, 0, 0,  1,  0, 2, 0,  0,  1,  1,  
solve_lib.tex(,440) @expansion{} 0, 0, 0,  0,  0, 0, 1,  0,  0,  1   
solve_lib.tex(,441) // computing sparse resultant
solve_lib.tex(,442) det(mn);
solve_lib.tex(,443) @expansion{} -7056
solve_lib.tex(,444) @c end example mp_res_mat d2t_singular/solve_lib.doc:256
solve_lib.tex(,445) @end smallexample
solve_lib.tex(,446) @c ---end content mp_res_mat---
solve_lib.tex(,447) 
solve_lib.tex(,448) @c ------------------- interpolate -------------
solve_lib.tex(,449) @node interpolate, fglm_solve, mp_res_mat, solve_lib
solve_lib.tex(,450) @subsubsection interpolate
solve_lib.tex(,451) @cindex interpolate
solve_lib.tex(,452) @c ---content interpolate---
solve_lib.tex(,453) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,454) 
solve_lib.tex(,455) @table @asis
solve_lib.tex(,456) @item @strong{Usage:}
solve_lib.tex(,457) interpolate(p,v,d); p,v=ideals of numbers, d=integer
solve_lib.tex(,458) 
solve_lib.tex(,459) @item @strong{Assume:}
solve_lib.tex(,460) Ground field K is the field of rational numbers, p and v are lists
solve_lib.tex(,461) of elements of the ground field K with p[j] != -1,0,1, size(p) = n
solve_lib.tex(,462) (= number of vars) and size(v)=N=(d+1)^n.
solve_lib.tex(,463) 
solve_lib.tex(,464) @item @strong{Return:}
solve_lib.tex(,465) poly f, the unique polynomial f of degree n*d with prescribed values
solve_lib.tex(,466) v[i] at the points p(i)=(p[1]^(i-1),..,p[n]^(i-1)), i=1,..,N.
solve_lib.tex(,467) 
solve_lib.tex(,468) @item @strong{Note:}
solve_lib.tex(,469) mainly useful when n=1, i.e. f is satisfying f(p^(i-1)) = v[i],
solve_lib.tex(,470) i=1..d+1.
solve_lib.tex(,471) 
solve_lib.tex(,472) @end table
solve_lib.tex(,473) @strong{Example:}
solve_lib.tex(,474) @smallexample
solve_lib.tex(,475) @c reused example interpolate d2t_singular/solve_lib.doc:311 
solve_lib.tex(,476) LIB "solve.lib";
solve_lib.tex(,477) ring r1 = 0,(x),lp;
solve_lib.tex(,478) // determine f with deg(f) = 4 and
solve_lib.tex(,479) // v = values of f at points 3^0, 3^1, 3^2, 3^3, 3^4
solve_lib.tex(,480) ideal v=16,0,11376,1046880,85949136;
solve_lib.tex(,481) interpolate( 3, v, 4 );
solve_lib.tex(,482) @expansion{} 2x4-22x2+36
solve_lib.tex(,483) @c end example interpolate d2t_singular/solve_lib.doc:311
solve_lib.tex(,484) @end smallexample
solve_lib.tex(,485) @c inserted refs from d2t_singular/solve_lib.doc:320
solve_lib.tex(,496) @c end inserted refs from d2t_singular/solve_lib.doc:320
solve_lib.tex(,497) 
solve_lib.tex(,498) @c ---end content interpolate---
solve_lib.tex(,499) 
solve_lib.tex(,500) @c ------------------- fglm_solve -------------
solve_lib.tex(,501) @node fglm_solve, lex_solve, interpolate, solve_lib
solve_lib.tex(,502) @subsubsection fglm_solve
solve_lib.tex(,503) @cindex fglm_solve
solve_lib.tex(,504) @c ---content fglm_solve---
solve_lib.tex(,505) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,506) 
solve_lib.tex(,507) @table @asis
solve_lib.tex(,508) @item @strong{Usage:}
solve_lib.tex(,509) fglm_solve(i [, p] ); i ideal, p integer
solve_lib.tex(,510) 
solve_lib.tex(,511) @item @strong{Assume:}
solve_lib.tex(,512) the ground field has char 0.
solve_lib.tex(,513) 
solve_lib.tex(,514) @item @strong{Return:}
solve_lib.tex(,515) a list of numbers, the complex roots of i;
solve_lib.tex(,516) @*p>0: gives precision of complex numbers in decimal digits (default:
solve_lib.tex(,517) p=30).
solve_lib.tex(,518) 
solve_lib.tex(,519) @item @strong{Note:}
solve_lib.tex(,520) The procedure uses a standard basis of i to determine all complex
solve_lib.tex(,521) roots of i.
solve_lib.tex(,522) @*It creates a ring rC with the same number of variables but with
solve_lib.tex(,523) complex coefficients (and precision p).
solve_lib.tex(,524) 
solve_lib.tex(,525) @end table
solve_lib.tex(,526) @strong{Example:}
solve_lib.tex(,527) @smallexample
solve_lib.tex(,528) @c reused example fglm_solve d2t_singular/solve_lib.doc:354 
solve_lib.tex(,529) LIB "solve.lib";
solve_lib.tex(,530) ring r = 0,(x,y),lp;
solve_lib.tex(,531) // compute the intersection points of two curves
solve_lib.tex(,532) ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
solve_lib.tex(,533) fglm_solve(s,10);
solve_lib.tex(,534) @expansion{} // name of new ring: rC
solve_lib.tex(,535) @expansion{} // list of roots: rlist
solve_lib.tex(,536) rlist;
solve_lib.tex(,537) @expansion{} [1]:
solve_lib.tex(,538) @expansion{}    [1]:
solve_lib.tex(,539) @expansion{}       2.8284271247
solve_lib.tex(,540) @expansion{}    [2]:
solve_lib.tex(,541) @expansion{}       1.4142135624
solve_lib.tex(,542) @expansion{} [2]:
solve_lib.tex(,543) @expansion{}    [1]:
solve_lib.tex(,544) @expansion{}       -2.8284271247
solve_lib.tex(,545) @expansion{}    [2]:
solve_lib.tex(,546) @expansion{}       -1.4142135624
solve_lib.tex(,547) @expansion{} [3]:
solve_lib.tex(,548) @expansion{}    [1]:
solve_lib.tex(,549) @expansion{}       1
solve_lib.tex(,550) @expansion{}    [2]:
solve_lib.tex(,551) @expansion{}       -3
solve_lib.tex(,552) @expansion{} [4]:
solve_lib.tex(,553) @expansion{}    [1]:
solve_lib.tex(,554) @expansion{}       -1
solve_lib.tex(,555) @expansion{}    [2]:
solve_lib.tex(,556) @expansion{}       3
solve_lib.tex(,557) @c end example fglm_solve d2t_singular/solve_lib.doc:354
solve_lib.tex(,558) @end smallexample
solve_lib.tex(,559) @c ---end content fglm_solve---
solve_lib.tex(,560) 
solve_lib.tex(,561) @c ------------------- lex_solve -------------
solve_lib.tex(,562) @node lex_solve, simplexOut, fglm_solve, solve_lib
solve_lib.tex(,563) @subsubsection lex_solve
solve_lib.tex(,564) @cindex lex_solve
solve_lib.tex(,565) @c ---content lex_solve---
solve_lib.tex(,566) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,567) 
solve_lib.tex(,568) @table @asis
solve_lib.tex(,569) @item @strong{Usage:}
solve_lib.tex(,570) lex_solve( i[,p] ); i=ideal, p=integer,
solve_lib.tex(,571)  @format
solve_lib.tex(,572)   p>0: gives precision of complex numbers in decimal digits (default: p=30).
solve_lib.tex(,573)  @end format
solve_lib.tex(,574) 
solve_lib.tex(,575) @item @strong{Assume:}
solve_lib.tex(,576) i is a reduced lexicographical Groebner bases of a zero-dimensional
solve_lib.tex(,577) ideal, sorted by increasing leading terms.
solve_lib.tex(,578) 
solve_lib.tex(,579) @item @strong{Return:}
solve_lib.tex(,580) nothing
solve_lib.tex(,581) 
solve_lib.tex(,582) @item @strong{Create:}
solve_lib.tex(,583) The procedure creates a complec ring with the same variables but
solve_lib.tex(,584) with complex coefficients (and precision p).
solve_lib.tex(,585) @*In this ring a list rlist of numbers is created, in which the complex
solve_lib.tex(,586) roots of i are stored.
solve_lib.tex(,587) 
solve_lib.tex(,588) @end table
solve_lib.tex(,589) @strong{Example:}
solve_lib.tex(,590) @smallexample
solve_lib.tex(,591) @c reused example lex_solve d2t_singular/solve_lib.doc:395 
solve_lib.tex(,592) LIB "solve.lib";
solve_lib.tex(,593) ring r = 0,(x,y),lp;
solve_lib.tex(,594) // compute the intersection points of two curves
solve_lib.tex(,595) ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
solve_lib.tex(,596) lex_solve(stdfglm(s),10);
solve_lib.tex(,597) @expansion{} // name of new ring: rC
solve_lib.tex(,598) @expansion{} // list of roots: rlist
solve_lib.tex(,599) rlist;
solve_lib.tex(,600) @expansion{} [1]:
solve_lib.tex(,601) @expansion{}    [1]:
solve_lib.tex(,602) @expansion{}       2.8284271247
solve_lib.tex(,603) @expansion{}    [2]:
solve_lib.tex(,604) @expansion{}       1.4142135624
solve_lib.tex(,605) @expansion{} [2]:
solve_lib.tex(,606) @expansion{}    [1]:
solve_lib.tex(,607) @expansion{}       -2.8284271247
solve_lib.tex(,608) @expansion{}    [2]:
solve_lib.tex(,609) @expansion{}       -1.4142135624
solve_lib.tex(,610) @expansion{} [3]:
solve_lib.tex(,611) @expansion{}    [1]:
solve_lib.tex(,612) @expansion{}       1
solve_lib.tex(,613) @expansion{}    [2]:
solve_lib.tex(,614) @expansion{}       -3
solve_lib.tex(,615) @expansion{} [4]:
solve_lib.tex(,616) @expansion{}    [1]:
solve_lib.tex(,617) @expansion{}       -1
solve_lib.tex(,618) @expansion{}    [2]:
solve_lib.tex(,619) @expansion{}       3
solve_lib.tex(,620) @c end example lex_solve d2t_singular/solve_lib.doc:395
solve_lib.tex(,621) @end smallexample
solve_lib.tex(,622) @c ---end content lex_solve---
solve_lib.tex(,623) 
solve_lib.tex(,624) @c ------------------- simplexOut -------------
solve_lib.tex(,625) @node simplexOut, triangLf_solve, lex_solve, solve_lib
solve_lib.tex(,626) @subsubsection simplexOut
solve_lib.tex(,627) @cindex simplexOut
solve_lib.tex(,628) @c ---content simplexOut---
solve_lib.tex(,629) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,630) 
solve_lib.tex(,631) @table @asis
solve_lib.tex(,632) @item @strong{Usage:}
solve_lib.tex(,633) simplexOut(l); l list
solve_lib.tex(,634) 
solve_lib.tex(,635) @item @strong{Assume:}
solve_lib.tex(,636) l is the output of simplex.
solve_lib.tex(,637) 
solve_lib.tex(,638) @item @strong{Return:}
solve_lib.tex(,639) nothing. The procedure prints the computed solution of simplex
solve_lib.tex(,640) (as strings) in a nice format.
solve_lib.tex(,641) 
solve_lib.tex(,642) @end table
solve_lib.tex(,643) @strong{Example:}
solve_lib.tex(,644) @smallexample
solve_lib.tex(,645) @c reused example simplexOut d2t_singular/solve_lib.doc:427 
solve_lib.tex(,646) LIB "solve.lib";
solve_lib.tex(,647) ring r = (real,10),(x),lp;
solve_lib.tex(,648) // consider the max. problem:
solve_lib.tex(,649) //
solve_lib.tex(,650) //    maximize  x(1) + x(2) + 3*x(3) - 0.5*x(4)
solve_lib.tex(,651) //
solve_lib.tex(,652) //  with constraints:   x(1) +          2*x(3)          <= 740
solve_lib.tex(,653) //                             2*x(2)          - 7*x(4) <=   0
solve_lib.tex(,654) //                               x(2) -   x(3) + 2*x(4) >=   0.5
solve_lib.tex(,655) //                      x(1) +   x(2) +   x(3) +   x(4)  =   9
solve_lib.tex(,656) //
solve_lib.tex(,657) matrix sm[5][5]=   0, 1, 1, 3,-0.5,
solve_lib.tex(,658) 740,-1, 0,-2, 0,
solve_lib.tex(,659) 0, 0,-2, 0, 7,
solve_lib.tex(,660) 0.5, 0,-1, 1,-2,
solve_lib.tex(,661) 9,-1,-1,-1,-1;
solve_lib.tex(,662) int n = 4;  // number of constraints
solve_lib.tex(,663) int m = 4;  // number of variables
solve_lib.tex(,664) int m1= 2;  // number of <= constraints
solve_lib.tex(,665) int m2= 1;  // number of >= constraints
solve_lib.tex(,666) int m3= 1;  // number of == constraints
solve_lib.tex(,667) list sol=simplex(sm, n, m, m1, m2, m3);
solve_lib.tex(,668) simplexOut(sol);
solve_lib.tex(,669) @expansion{} z = 17.025
solve_lib.tex(,670) @expansion{} x2 = 3.325
solve_lib.tex(,671) @expansion{} x4 = 0.95
solve_lib.tex(,672) @expansion{} x3 = 4.725
solve_lib.tex(,673) @c end example simplexOut d2t_singular/solve_lib.doc:427
solve_lib.tex(,674) @end smallexample
solve_lib.tex(,675) @c inserted refs from d2t_singular/solve_lib.doc:453
solve_lib.tex(,686) @c end inserted refs from d2t_singular/solve_lib.doc:453
solve_lib.tex(,687) 
solve_lib.tex(,688) @c ---end content simplexOut---
solve_lib.tex(,689) 
solve_lib.tex(,690) @c ------------------- triangLf_solve -------------
solve_lib.tex(,691) @node triangLf_solve, triangM_solve, simplexOut, solve_lib
solve_lib.tex(,692) @subsubsection triangLf_solve
solve_lib.tex(,693) @cindex triangLf_solve
solve_lib.tex(,694) @c ---content triangLf_solve---
solve_lib.tex(,695) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,696) 
solve_lib.tex(,697) @table @asis
solve_lib.tex(,698) @item @strong{Usage:}
solve_lib.tex(,699) triangLf_solve(i [, p] ); i ideal, p integer,
solve_lib.tex(,700) @*p>0: gives precision of complex numbers in digits (default: p=30).
solve_lib.tex(,701) 
solve_lib.tex(,702) @item @strong{Assume:}
solve_lib.tex(,703) the ground field has char 0; i is a zero-dimensional ideal
solve_lib.tex(,704) 
solve_lib.tex(,705) @item @strong{Return:}
solve_lib.tex(,706) nothing
solve_lib.tex(,707) 
solve_lib.tex(,708) @item @strong{Create:}
solve_lib.tex(,709) The procedure creates a ring rC with the same number of variables but
solve_lib.tex(,710) with complex coefficients (and precision p).@*
solve_lib.tex(,711) In rC a list rlist of numbers is created, in which the complex
solve_lib.tex(,712) roots of i are stored.@*
solve_lib.tex(,713) The proc uses a triangular system (Lazard's Algorithm with
solve_lib.tex(,714) factorization) computed from a standard basis to determine recursively
solve_lib.tex(,715) all complex roots with Laguerre's algorithm of input ideal i.
solve_lib.tex(,716) 
solve_lib.tex(,717) @end table
solve_lib.tex(,718) @strong{Example:}
solve_lib.tex(,719) @smallexample
solve_lib.tex(,720) @c reused example triangLf_solve d2t_singular/solve_lib.doc:489 
solve_lib.tex(,721) LIB "solve.lib";
solve_lib.tex(,722) ring r = 0,(x,y),lp;
solve_lib.tex(,723) // compute the intersection points of two curves
solve_lib.tex(,724) ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
solve_lib.tex(,725) triangLf_solve(s,10);
solve_lib.tex(,726) @expansion{} // name of new ring: rC
solve_lib.tex(,727) @expansion{} // list of roots: rlist
solve_lib.tex(,728) rlist;
solve_lib.tex(,729) @expansion{} [1]:
solve_lib.tex(,730) @expansion{}    [1]:
solve_lib.tex(,731) @expansion{}       -1
solve_lib.tex(,732) @expansion{}    [2]:
solve_lib.tex(,733) @expansion{}       3
solve_lib.tex(,734) @expansion{} [2]:
solve_lib.tex(,735) @expansion{}    [1]:
solve_lib.tex(,736) @expansion{}       1
solve_lib.tex(,737) @expansion{}    [2]:
solve_lib.tex(,738) @expansion{}       -3
solve_lib.tex(,739) @expansion{} [3]:
solve_lib.tex(,740) @expansion{}    [1]:
solve_lib.tex(,741) @expansion{}       2.8284271247
solve_lib.tex(,742) @expansion{}    [2]:
solve_lib.tex(,743) @expansion{}       1.4142135624
solve_lib.tex(,744) @expansion{} [4]:
solve_lib.tex(,745) @expansion{}    [1]:
solve_lib.tex(,746) @expansion{}       -2.8284271247
solve_lib.tex(,747) @expansion{}    [2]:
solve_lib.tex(,748) @expansion{}       -1.4142135624
solve_lib.tex(,749) @c end example triangLf_solve d2t_singular/solve_lib.doc:489
solve_lib.tex(,750) @end smallexample
solve_lib.tex(,751) @c ---end content triangLf_solve---
solve_lib.tex(,752) 
solve_lib.tex(,753) @c ------------------- triangM_solve -------------
solve_lib.tex(,754) @node triangM_solve, triangL_solve, triangLf_solve, solve_lib
solve_lib.tex(,755) @subsubsection triangM_solve
solve_lib.tex(,756) @cindex triangM_solve
solve_lib.tex(,757) @c ---content triangM_solve---
solve_lib.tex(,758) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,759) 
solve_lib.tex(,760) @table @asis
solve_lib.tex(,761) @item @strong{Usage:}
solve_lib.tex(,762) triangM_solve(i [, p ] ); i=ideal, p=integer,
solve_lib.tex(,763) @*p>0: gives precision of complex numbers in digits (default: p=30).
solve_lib.tex(,764) 
solve_lib.tex(,765) @item @strong{Assume:}
solve_lib.tex(,766) the ground field has char 0;@*
solve_lib.tex(,767) i zero-dimensional ideal
solve_lib.tex(,768) 
solve_lib.tex(,769) @item @strong{Return:}
solve_lib.tex(,770) nothing
solve_lib.tex(,771) 
solve_lib.tex(,772) @item @strong{Create:}
solve_lib.tex(,773) The procedure creates a ring rC with the same number of variables but
solve_lib.tex(,774) with complex coefficients (and precision p).@*
solve_lib.tex(,775) In rC a list rlist of numbers is created, in which the complex
solve_lib.tex(,776) roots of i are stored.@*
solve_lib.tex(,777) The proc uses a triangular system (Moellers Algorithm) computed from a
solve_lib.tex(,778) standard basis to determine recursively all complex roots with
solve_lib.tex(,779) Laguerre's algorithm of input ideal i.
solve_lib.tex(,780) 
solve_lib.tex(,781) @end table
solve_lib.tex(,782) @strong{Example:}
solve_lib.tex(,783) @smallexample
solve_lib.tex(,784) @c reused example triangM_solve d2t_singular/solve_lib.doc:531 
solve_lib.tex(,785) LIB "solve.lib";
solve_lib.tex(,786) ring r = 0,(x,y),lp;
solve_lib.tex(,787) // compute the intersection points of two curves
solve_lib.tex(,788) ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
solve_lib.tex(,789) triangM_solve(s,10);
solve_lib.tex(,790) @expansion{} // name of new ring: rC
solve_lib.tex(,791) @expansion{} // list of roots: rlist
solve_lib.tex(,792) rlist;
solve_lib.tex(,793) @expansion{} [1]:
solve_lib.tex(,794) @expansion{}    [1]:
solve_lib.tex(,795) @expansion{}       2.8284271247
solve_lib.tex(,796) @expansion{}    [2]:
solve_lib.tex(,797) @expansion{}       1.4142135624
solve_lib.tex(,798) @expansion{} [2]:
solve_lib.tex(,799) @expansion{}    [1]:
solve_lib.tex(,800) @expansion{}       -2.8284271247
solve_lib.tex(,801) @expansion{}    [2]:
solve_lib.tex(,802) @expansion{}       -1.4142135624
solve_lib.tex(,803) @expansion{} [3]:
solve_lib.tex(,804) @expansion{}    [1]:
solve_lib.tex(,805) @expansion{}       1
solve_lib.tex(,806) @expansion{}    [2]:
solve_lib.tex(,807) @expansion{}       -3
solve_lib.tex(,808) @expansion{} [4]:
solve_lib.tex(,809) @expansion{}    [1]:
solve_lib.tex(,810) @expansion{}       -1
solve_lib.tex(,811) @expansion{}    [2]:
solve_lib.tex(,812) @expansion{}       3
solve_lib.tex(,813) @c end example triangM_solve d2t_singular/solve_lib.doc:531
solve_lib.tex(,814) @end smallexample
solve_lib.tex(,815) @c ---end content triangM_solve---
solve_lib.tex(,816) 
solve_lib.tex(,817) @c ------------------- triangL_solve -------------
solve_lib.tex(,818) @node triangL_solve, triang_solve, triangM_solve, solve_lib
solve_lib.tex(,819) @subsubsection triangL_solve
solve_lib.tex(,820) @cindex triangL_solve
solve_lib.tex(,821) @c ---content triangL_solve---
solve_lib.tex(,822) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,823) 
solve_lib.tex(,824) @table @asis
solve_lib.tex(,825) @item @strong{Usage:}
solve_lib.tex(,826) triangL_solve(i [, p] ); i=ideal, p=integer,@*
solve_lib.tex(,827) p>0: gives precision of complex numbers in digits (default: p=30).
solve_lib.tex(,828) 
solve_lib.tex(,829) @item @strong{Assume:}
solve_lib.tex(,830) the ground field has char 0; i is a zero-dimensional ideal.
solve_lib.tex(,831) 
solve_lib.tex(,832) @item @strong{Return:}
solve_lib.tex(,833) nothing
solve_lib.tex(,834) 
solve_lib.tex(,835) @item @strong{Create:}
solve_lib.tex(,836) The procedure creates a ring rC with the same number of variables but
solve_lib.tex(,837) with complex coefficients (and precision p).@*
solve_lib.tex(,838) In rC a list rlist of numbers is created, in which the complex
solve_lib.tex(,839) roots of i are stored.@*
solve_lib.tex(,840) The proc uses a triangular system (Lazard's Algorithm) computed from
solve_lib.tex(,841) a standard basis to determine recursively all complex roots with
solve_lib.tex(,842) Laguerre's algorithm of input ideal i.
solve_lib.tex(,843) 
solve_lib.tex(,844) @end table
solve_lib.tex(,845) @strong{Example:}
solve_lib.tex(,846) @smallexample
solve_lib.tex(,847) @c reused example triangL_solve d2t_singular/solve_lib.doc:572 
solve_lib.tex(,848) LIB "solve.lib";
solve_lib.tex(,849) ring r = 0,(x,y),lp;
solve_lib.tex(,850) // compute the intersection points of two curves
solve_lib.tex(,851) ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
solve_lib.tex(,852) triangL_solve(s,10);
solve_lib.tex(,853) @expansion{} // name of new ring: rC
solve_lib.tex(,854) @expansion{} // list of roots: rlist
solve_lib.tex(,855) rlist;
solve_lib.tex(,856) @expansion{} [1]:
solve_lib.tex(,857) @expansion{}    [1]:
solve_lib.tex(,858) @expansion{}       2.8284271247
solve_lib.tex(,859) @expansion{}    [2]:
solve_lib.tex(,860) @expansion{}       1.4142135624
solve_lib.tex(,861) @expansion{} [2]:
solve_lib.tex(,862) @expansion{}    [1]:
solve_lib.tex(,863) @expansion{}       -2.8284271247
solve_lib.tex(,864) @expansion{}    [2]:
solve_lib.tex(,865) @expansion{}       -1.4142135624
solve_lib.tex(,866) @expansion{} [3]:
solve_lib.tex(,867) @expansion{}    [1]:
solve_lib.tex(,868) @expansion{}       1
solve_lib.tex(,869) @expansion{}    [2]:
solve_lib.tex(,870) @expansion{}       -3
solve_lib.tex(,871) @expansion{} [4]:
solve_lib.tex(,872) @expansion{}    [1]:
solve_lib.tex(,873) @expansion{}       -1
solve_lib.tex(,874) @expansion{}    [2]:
solve_lib.tex(,875) @expansion{}       3
solve_lib.tex(,876) @c end example triangL_solve d2t_singular/solve_lib.doc:572
solve_lib.tex(,877) @end smallexample
solve_lib.tex(,878) @c ---end content triangL_solve---
solve_lib.tex(,879) 
solve_lib.tex(,880) @c ------------------- triang_solve -------------
solve_lib.tex(,881) @node triang_solve,, triangL_solve, solve_lib
solve_lib.tex(,882) @subsubsection triang_solve
solve_lib.tex(,883) @cindex triang_solve
solve_lib.tex(,884) @c ---content triang_solve---
solve_lib.tex(,885) Procedure from library @code{solve.lib} (@pxref{solve_lib}).
solve_lib.tex(,886) 
solve_lib.tex(,887) @table @asis
solve_lib.tex(,888) @item @strong{Usage:}
solve_lib.tex(,889) triang_solve(l,p [, d] ); l=list, p,d=integers,@*
solve_lib.tex(,890) l a list of finitely many triangular systems, such that the union of
solve_lib.tex(,891) their varieties equals the variety of the initial ideal.@*
solve_lib.tex(,892) p>0: gives precision of complex numbers in digits,@*
solve_lib.tex(,893) d>0: gives precision (1<d<p) for near-zero-determination,@*
solve_lib.tex(,894) (default: d=1/2*p).
solve_lib.tex(,895) 
solve_lib.tex(,896) @item @strong{Assume:}
solve_lib.tex(,897) the ground field has char 0;@*
solve_lib.tex(,898) l was computed using Algorithm of Lazard or Algorithm of Moeller
solve_lib.tex(,899) (see triang.lib).
solve_lib.tex(,900) 
solve_lib.tex(,901) @item @strong{Return:}
solve_lib.tex(,902) nothing
solve_lib.tex(,903) 
solve_lib.tex(,904) @item @strong{Create:}
solve_lib.tex(,905) The procedure creates a ring rC with the same number of variables but
solve_lib.tex(,906) with complex coefficients (and precision p).@*
solve_lib.tex(,907) In rC a list rlist of numbers is created, in which the complex
solve_lib.tex(,908) roots of i are stored.@*
solve_lib.tex(,909) 
solve_lib.tex(,910) @end table
solve_lib.tex(,911) @strong{Example:}
solve_lib.tex(,912) @smallexample
solve_lib.tex(,913) @c reused example triang_solve d2t_singular/solve_lib.doc:616 
solve_lib.tex(,914) LIB "solve.lib";
solve_lib.tex(,915) ring r = 0,(x,y),lp;
solve_lib.tex(,916) // compute the intersection points of two curves
solve_lib.tex(,917) ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
solve_lib.tex(,918) triang_solve(triangLfak(stdfglm(s)),10);
solve_lib.tex(,919) @expansion{} // name of new ring: rC
solve_lib.tex(,920) @expansion{} // list of roots: rlist
solve_lib.tex(,921) rlist;
solve_lib.tex(,922) @expansion{} [1]:
solve_lib.tex(,923) @expansion{}    [1]:
solve_lib.tex(,924) @expansion{}       -1
solve_lib.tex(,925) @expansion{}    [2]:
solve_lib.tex(,926) @expansion{}       3
solve_lib.tex(,927) @expansion{} [2]:
solve_lib.tex(,928) @expansion{}    [1]:
solve_lib.tex(,929) @expansion{}       1
solve_lib.tex(,930) @expansion{}    [2]:
solve_lib.tex(,931) @expansion{}       -3
solve_lib.tex(,932) @expansion{} [3]:
solve_lib.tex(,933) @expansion{}    [1]:
solve_lib.tex(,934) @expansion{}       2.8284271247
solve_lib.tex(,935) @expansion{}    [2]:
solve_lib.tex(,936) @expansion{}       1.4142135624
solve_lib.tex(,937) @expansion{} [4]:
solve_lib.tex(,938) @expansion{}    [1]:
solve_lib.tex(,939) @expansion{}       -2.8284271247
solve_lib.tex(,940) @expansion{}    [2]:
solve_lib.tex(,941) @expansion{}       -1.4142135624
solve_lib.tex(,942) @c end example triang_solve d2t_singular/solve_lib.doc:616
solve_lib.tex(,943) @end smallexample
solve_lib.tex(,944) @c ---end content triang_solve---
singular.texi(,555) @c ---------------------------------------------------------
singular.texi(,556) @node triang_lib, ntsolve_lib,  solve_lib, Symbolic-numerical solving
singular.texi(,557) @subsection triang_lib
singular.texi(,558) @c include of docu for triang.lib
triang_lib_noEx.tex(,1) @c ---content LibInfo---
triang_lib_noEx.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/triang_lib.doc
triang_lib_noEx.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/triang_lib.doc INSTEAD
triang_lib_noEx.tex(,4) @c library version: (1.7,2001/02/19)
triang_lib_noEx.tex(,5) @c library file: ../Singular/LIB/triang.lib
triang_lib_noEx.tex(,6) @cindex triang.lib
triang_lib_noEx.tex(,7) @cindex triang_lib
triang_lib_noEx.tex(,8) @table @asis
triang_lib_noEx.tex(,9) @item @strong{Library:}
triang_lib_noEx.tex(,10) triang.lib
triang_lib_noEx.tex(,11) @item @strong{Purpose:}
triang_lib_noEx.tex(,12)    Decompose Zero-dimensional Ideals into Triangular Sets
triang_lib_noEx.tex(,13) @item @strong{Author:}
triang_lib_noEx.tex(,14) D. Hillebrand
triang_lib_noEx.tex(,15) 
triang_lib_noEx.tex(,16) @end table
triang_lib_noEx.tex(,17) 
triang_lib_noEx.tex(,18) @strong{Procedures:}
triang_lib_noEx.tex(,19) @menu
triang_lib_noEx.tex(,20) * triangL:: Decomposition of (G) into triangular systems (Lazard).
triang_lib_noEx.tex(,21) * triangLfak:: Decomp. of (G) into tri. systems plus factorization.
triang_lib_noEx.tex(,22) * triangM:: Decomposition of (G) into triangular systems (Moeller).
triang_lib_noEx.tex(,23) * triangMH:: Decomp. of (G) into tri. syst. with disjoint varieties.
triang_lib_noEx.tex(,24) @end menu
triang_lib_noEx.tex(,25) @c ---end content LibInfo---
triang_lib_noEx.tex(,26) 
triang_lib_noEx.tex(,27) @c ------------------- triangL -------------
triang_lib_noEx.tex(,28) @node triangL, triangLfak,, triang_lib
triang_lib_noEx.tex(,29) @subsubsection triangL
triang_lib_noEx.tex(,30) @cindex triangL
triang_lib_noEx.tex(,31) @c ---content triangL---
triang_lib_noEx.tex(,32) Procedure from library @code{triang.lib} (@pxref{triang_lib}).
triang_lib_noEx.tex(,33) 
triang_lib_noEx.tex(,34) @table @asis
triang_lib_noEx.tex(,35) @item @strong{Usage:}
triang_lib_noEx.tex(,36) triangL(G); G=ideal
triang_lib_noEx.tex(,37) 
triang_lib_noEx.tex(,38) @item @strong{Assume:}
triang_lib_noEx.tex(,39) G is the reduced lexicographical Groebner bases of the
triang_lib_noEx.tex(,40) zero-dimensional ideal (G), sorted by increasing leading terms.
triang_lib_noEx.tex(,41) 
triang_lib_noEx.tex(,42) @item @strong{Return:}
triang_lib_noEx.tex(,43) a list of finitely many triangular systems, such that
triang_lib_noEx.tex(,44) the union of their varieties equals the variety of (G).
triang_lib_noEx.tex(,45) 
triang_lib_noEx.tex(,46) @item @strong{Note:}
triang_lib_noEx.tex(,47) Algorithm of Lazard (see: Lazard, D.: Solving zero-dimensional
triang_lib_noEx.tex(,48) algebraic systems, J. Symb. Comp. 13, 117 - 132, 1992).
triang_lib_noEx.tex(,49) 
triang_lib_noEx.tex(,50) @end table
triang_lib_noEx.tex(,51) @strong{Example:}
triang_lib_noEx.tex(,52) @smallexample
triang_lib_noEx.tex(,53) @c skipped computation of example triangL d2t_singular/triang_lib.doc:51 
triang_lib_noEx.tex(,54) LIB "triang.lib";
triang_lib_noEx.tex(,55) ring rC5 = 0,(e,d,c,b,a),lp;
triang_lib_noEx.tex(,56) triangL(stdfglm(cyclic(5)));
triang_lib_noEx.tex(,57) @end smallexample
triang_lib_noEx.tex(,58) @c ---end content triangL---
triang_lib_noEx.tex(,59) 
triang_lib_noEx.tex(,60) @c ------------------- triangLfak -------------
triang_lib_noEx.tex(,61) @node triangLfak, triangM, triangL, triang_lib
triang_lib_noEx.tex(,62) @subsubsection triangLfak
triang_lib_noEx.tex(,63) @cindex triangLfak
triang_lib_noEx.tex(,64) @c ---content triangLfak---
triang_lib_noEx.tex(,65) Procedure from library @code{triang.lib} (@pxref{triang_lib}).
triang_lib_noEx.tex(,66) 
triang_lib_noEx.tex(,67) @table @asis
triang_lib_noEx.tex(,68) @item @strong{Usage:}
triang_lib_noEx.tex(,69) triangLfak(G); G=ideal
triang_lib_noEx.tex(,70) 
triang_lib_noEx.tex(,71) @item @strong{Assume:}
triang_lib_noEx.tex(,72) G is the reduced lexicographical Groebner bases of the
triang_lib_noEx.tex(,73) zero-dimensional ideal (G), sorted by increasing leading terms.
triang_lib_noEx.tex(,74) 
triang_lib_noEx.tex(,75) @item @strong{Return:}
triang_lib_noEx.tex(,76) a list of finitely many triangular systems, such that
triang_lib_noEx.tex(,77) the union of their varieties equals the variety of (G).
triang_lib_noEx.tex(,78) 
triang_lib_noEx.tex(,79) @item @strong{Note:}
triang_lib_noEx.tex(,80) Algorithm of Lazard with factorization (see: Lazard, D.: Solving
triang_lib_noEx.tex(,81) zero-dimensional algebraic systems, J. Symb. Comp. 13, 117 - 132, 1992).
triang_lib_noEx.tex(,82) 
triang_lib_noEx.tex(,83) @item @strong{Remark:}
triang_lib_noEx.tex(,84) each polynomial of the triangular systems is factorized.
triang_lib_noEx.tex(,85) 
triang_lib_noEx.tex(,86) @end table
triang_lib_noEx.tex(,87) @strong{Example:}
triang_lib_noEx.tex(,88) @smallexample
triang_lib_noEx.tex(,89) @c skipped computation of example triangLfak d2t_singular/triang_lib.doc:88 
triang_lib_noEx.tex(,90) LIB "triang.lib";
triang_lib_noEx.tex(,91) ring rC5 = 0,(e,d,c,b,a),lp;
triang_lib_noEx.tex(,92) triangLfak(stdfglm(cyclic(5)));
triang_lib_noEx.tex(,93) @end smallexample
triang_lib_noEx.tex(,94) @c ---end content triangLfak---
triang_lib_noEx.tex(,95) 
triang_lib_noEx.tex(,96) @c ------------------- triangM -------------
triang_lib_noEx.tex(,97) @node triangM, triangMH, triangLfak, triang_lib
triang_lib_noEx.tex(,98) @subsubsection triangM
triang_lib_noEx.tex(,99) @cindex triangM
triang_lib_noEx.tex(,100) @c ---content triangM---
triang_lib_noEx.tex(,101) Procedure from library @code{triang.lib} (@pxref{triang_lib}).
triang_lib_noEx.tex(,102) 
triang_lib_noEx.tex(,103) @table @asis
triang_lib_noEx.tex(,104) @item @strong{Usage:}
triang_lib_noEx.tex(,105) triangM(G[,i]); G=ideal, i=integer,@*
triang_lib_noEx.tex(,106) 
triang_lib_noEx.tex(,107) @item @strong{Assume:}
triang_lib_noEx.tex(,108) G is the reduced lexicographical Groebner bases of the
triang_lib_noEx.tex(,109) zero-dimensional ideal (G), sorted by increasing leading terms.
triang_lib_noEx.tex(,110) 
triang_lib_noEx.tex(,111) @item @strong{Return:}
triang_lib_noEx.tex(,112) a list of finitely many triangular systems, such that
triang_lib_noEx.tex(,113) the union of their varieties equals the variety of (G).
triang_lib_noEx.tex(,114) If i = 2, then each polynomial of the triangular systems
triang_lib_noEx.tex(,115) is factorized.
triang_lib_noEx.tex(,116) 
triang_lib_noEx.tex(,117) @item @strong{Note:}
triang_lib_noEx.tex(,118) Algorithm of Moeller (see: Moeller, H.M.:
triang_lib_noEx.tex(,119) @*On decomposing systems of polynomial equations with
triang_lib_noEx.tex(,120) @*finitely many solutions, Appl. Algebra Eng. Commun. Comput. 4,
triang_lib_noEx.tex(,121) 217 - 230, 1993).
triang_lib_noEx.tex(,122) 
triang_lib_noEx.tex(,123) @end table
triang_lib_noEx.tex(,124) @strong{Example:}
triang_lib_noEx.tex(,125) @smallexample
triang_lib_noEx.tex(,126) @c skipped computation of example triangM d2t_singular/triang_lib.doc:126 
triang_lib_noEx.tex(,127) LIB "triang.lib";
triang_lib_noEx.tex(,128) ring rC5 = 0,(e,d,c,b,a),lp;
triang_lib_noEx.tex(,129) triangM(stdfglm(cyclic(5))); //oder: triangM(stdfglm(cyclic(5)),2);
triang_lib_noEx.tex(,130) @end smallexample
triang_lib_noEx.tex(,131) @c ---end content triangM---
triang_lib_noEx.tex(,132) 
triang_lib_noEx.tex(,133) @c ------------------- triangMH -------------
triang_lib_noEx.tex(,134) @node triangMH,, triangM, triang_lib
triang_lib_noEx.tex(,135) @subsubsection triangMH
triang_lib_noEx.tex(,136) @cindex triangMH
triang_lib_noEx.tex(,137) @c ---content triangMH---
triang_lib_noEx.tex(,138) Procedure from library @code{triang.lib} (@pxref{triang_lib}).
triang_lib_noEx.tex(,139) 
triang_lib_noEx.tex(,140) @table @asis
triang_lib_noEx.tex(,141) @item @strong{Usage:}
triang_lib_noEx.tex(,142) triangMH(G[,i]); G=ideal, i=integer
triang_lib_noEx.tex(,143) 
triang_lib_noEx.tex(,144) @item @strong{Assume:}
triang_lib_noEx.tex(,145) G is the reduced lexicographical Groebner bases of the
triang_lib_noEx.tex(,146) zero-dimensional ideal (G), sorted by increasing leading terms.
triang_lib_noEx.tex(,147) 
triang_lib_noEx.tex(,148) @item @strong{Return:}
triang_lib_noEx.tex(,149) a list of finitely many triangular systems, such that
triang_lib_noEx.tex(,150) the disjoint union of their varieties equals the variety of (G).
triang_lib_noEx.tex(,151) If i = 2, then each polynomial of the triangular systems is factorized.
triang_lib_noEx.tex(,152) 
triang_lib_noEx.tex(,153) @item @strong{Note:}
triang_lib_noEx.tex(,154) Algorithm of Moeller and Hillebrand (see: Moeller, H.M.:
triang_lib_noEx.tex(,155) On decomposing systems of polynomial equations with finitely many
triang_lib_noEx.tex(,156) solutions, Appl. Algebra Eng. Commun. Comput. 4, 217 - 230, 1993 and
triang_lib_noEx.tex(,157) Hillebrand, D.: Triangulierung nulldimensionaler Ideale -
triang_lib_noEx.tex(,158) Implementierung und Vergleich zweier Algorithmen, master thesis,
triang_lib_noEx.tex(,159) Universitaet Dortmund, Fachbereich Mathematik, Prof. Dr. H.M. Moeller,
triang_lib_noEx.tex(,160) 1999).
triang_lib_noEx.tex(,161) 
triang_lib_noEx.tex(,162) @end table
triang_lib_noEx.tex(,163) @strong{Example:}
triang_lib_noEx.tex(,164) @smallexample
triang_lib_noEx.tex(,165) @c skipped computation of example triangMH d2t_singular/triang_lib.doc:166 
triang_lib_noEx.tex(,166) LIB "triang.lib";
triang_lib_noEx.tex(,167) ring rC5 = 0,(e,d,c,b,a),lp;
triang_lib_noEx.tex(,168) triangMH(stdfglm(cyclic(5)));
triang_lib_noEx.tex(,169) @end smallexample
triang_lib_noEx.tex(,170) @c ---end content triangMH---
singular.texi(,560) @c ---------------------------------------------------------
singular.texi(,561) @node ntsolve_lib, zeroset_lib, triang_lib, Symbolic-numerical solving
singular.texi(,562) @subsection ntsolve_lib
singular.texi(,563) @c include of docu for ntsolve.lib
ntsolve_lib.tex(,1) @c ---content LibInfo---
ntsolve_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/ntsolve_lib.doc
ntsolve_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/ntsolve_lib.doc INSTEAD
ntsolve_lib.tex(,4) @c library version: (1.12.2.1,2002/04/12)
ntsolve_lib.tex(,5) @c library file: ../Singular/LIB/ntsolve.lib
ntsolve_lib.tex(,6) @cindex ntsolve.lib
ntsolve_lib.tex(,7) @cindex ntsolve_lib
ntsolve_lib.tex(,8) @table @asis
ntsolve_lib.tex(,9) @item @strong{Library:}
ntsolve_lib.tex(,10) ntsolve.lib
ntsolve_lib.tex(,11) @item @strong{Purpose:}
ntsolve_lib.tex(,12)      Real Newton Solving of Polynomial Systems
ntsolve_lib.tex(,13) @item @strong{Authors:}
ntsolve_lib.tex(,14) Wilfred Pohl, email: pohl@@mathematik.uni-kl.de
ntsolve_lib.tex(,15) @*Dietmar Hillebrand
ntsolve_lib.tex(,16) 
ntsolve_lib.tex(,17) @end table
ntsolve_lib.tex(,18) 
ntsolve_lib.tex(,19) @strong{Procedures:}
ntsolve_lib.tex(,20) @menu
ntsolve_lib.tex(,21) * nt_solve:: find one real root of 0-dimensional ideal G
ntsolve_lib.tex(,22) * triMNewton:: find one real root for 0-dim triangular system G
ntsolve_lib.tex(,23) @end menu
ntsolve_lib.tex(,24) @c ---end content LibInfo---
ntsolve_lib.tex(,25) 
ntsolve_lib.tex(,26) @c ------------------- nt_solve -------------
ntsolve_lib.tex(,27) @node nt_solve, triMNewton,, ntsolve_lib
ntsolve_lib.tex(,28) @subsubsection nt_solve
ntsolve_lib.tex(,29) @cindex nt_solve
ntsolve_lib.tex(,30) @c ---content nt_solve---
ntsolve_lib.tex(,31) Procedure from library @code{ntsolve.lib} (@pxref{ntsolve_lib}).
ntsolve_lib.tex(,32) 
ntsolve_lib.tex(,33) @table @asis
ntsolve_lib.tex(,34) @item @strong{Usage:}
ntsolve_lib.tex(,35) nt_solve(gls,ini[,ipar]); gls,ini= ideals, ipar=list/intvec,@*
ntsolve_lib.tex(,36) gls: contains the equations, for which a solution will be computed
ntsolve_lib.tex(,37) ini: ideal of initial values (approximate solutions to start with),@*
ntsolve_lib.tex(,38) ipar: control integers (default: ipar = 100,10)
ntsolve_lib.tex(,39)   @format
ntsolve_lib.tex(,40)  ipar[1]: max. number of iterations
ntsolve_lib.tex(,41)  ipar[2]: accuracy (we have the l_2-norm ||.||): accept solution @code{sol}
ntsolve_lib.tex(,42)           if ||gls(sol)|| < eps0*(0.1^ipar[2])
ntsolve_lib.tex(,43)           where eps0 = ||gls(ini)|| is the initial error
ntsolve_lib.tex(,44)   @end format
ntsolve_lib.tex(,45) 
ntsolve_lib.tex(,46) @item @strong{Assume:}
ntsolve_lib.tex(,47) gls is a zerodimensional ideal with nvars(basering) = size(gls) (>1)
ntsolve_lib.tex(,48) 
ntsolve_lib.tex(,49) @item @strong{Return:}
ntsolve_lib.tex(,50) ideal, coordinates of one solution (if found), 0 else
ntsolve_lib.tex(,51) 
ntsolve_lib.tex(,52) @item @strong{Note:}
ntsolve_lib.tex(,53) if printlevel >0: displays comments (default =0)
ntsolve_lib.tex(,54) 
ntsolve_lib.tex(,55) @end table
ntsolve_lib.tex(,56) @strong{Example:}
ntsolve_lib.tex(,57) @smallexample
ntsolve_lib.tex(,58) @c computed example nt_solve d2t_singular/ntsolve_lib.doc:56 
ntsolve_lib.tex(,59) LIB "ntsolve.lib";
ntsolve_lib.tex(,60) ring rsq = (real,40),(x,y,z,w),lp;
ntsolve_lib.tex(,61) ideal gls =  x2+y2+z2-10, y2+z3+w-8, xy+yz+xz+w5 - 1,w3+y;
ntsolve_lib.tex(,62) ideal ini = 3.1,2.9,1.1,0.5;
ntsolve_lib.tex(,63) intvec ipar = 200,0;
ntsolve_lib.tex(,64) ideal sol = nt_solve(gls,ini,ipar);
ntsolve_lib.tex(,65) sol;
ntsolve_lib.tex(,66) @expansion{} sol[1]=0.8698104581550055082008024750939710335537
ntsolve_lib.tex(,67) @expansion{} sol[2]=2.8215774457503246008496262517717182369409
ntsolve_lib.tex(,68) @expansion{} sol[3]=1.1323120084664179900060940157112668717318
ntsolve_lib.tex(,69) @expansion{} sol[4]=-1.413071026406678849397999475590194239628
ntsolve_lib.tex(,70) @c end example nt_solve d2t_singular/ntsolve_lib.doc:56
ntsolve_lib.tex(,71) @end smallexample
ntsolve_lib.tex(,72) @c ---end content nt_solve---
ntsolve_lib.tex(,73) 
ntsolve_lib.tex(,74) @c ------------------- triMNewton -------------
ntsolve_lib.tex(,75) @node triMNewton,, nt_solve, ntsolve_lib
ntsolve_lib.tex(,76) @subsubsection triMNewton
ntsolve_lib.tex(,77) @cindex triMNewton
ntsolve_lib.tex(,78) @c ---content triMNewton---
ntsolve_lib.tex(,79) Procedure from library @code{ntsolve.lib} (@pxref{ntsolve_lib}).
ntsolve_lib.tex(,80) 
ntsolve_lib.tex(,81) @table @asis
ntsolve_lib.tex(,82) @item @strong{Usage:}
ntsolve_lib.tex(,83) triMNewton(G,a[,ipar]); G,a= ideals, ipar=list/intvec
ntsolve_lib.tex(,84) 
ntsolve_lib.tex(,85) @item @strong{Assume:}
ntsolve_lib.tex(,86) G: g1,..,gn, a triangular system of n equations in n vars, i.e.
ntsolve_lib.tex(,87) gi=gi(var(n-i+1),..,var(n)),@*
ntsolve_lib.tex(,88) a: ideal of numbers, coordinates of an approximation of a common
ntsolve_lib.tex(,89) zero of G to start with (with a[i] to be substituted in var(i)),@*
ntsolve_lib.tex(,90) ipar: control integer vector (default: ipar = 100,10)
ntsolve_lib.tex(,91)   @format
ntsolve_lib.tex(,92)   ipar[1]: max. number of iterations
ntsolve_lib.tex(,93)   ipar[2]: accuracy (we have as norm |.| absolute value ):
ntsolve_lib.tex(,94)            accept solution @code{sol} if |G(sol)| < |G(a)|*(0.1^ipar[2]).
ntsolve_lib.tex(,95)   @end format
ntsolve_lib.tex(,96) 
ntsolve_lib.tex(,97) @item @strong{Return:}
ntsolve_lib.tex(,98) an ideal, coordinates of a better approximation of a zero of G
ntsolve_lib.tex(,99) 
ntsolve_lib.tex(,100) @end table
ntsolve_lib.tex(,101) @strong{Example:}
ntsolve_lib.tex(,102) @smallexample
ntsolve_lib.tex(,103) @c computed example triMNewton d2t_singular/ntsolve_lib.doc:97 
ntsolve_lib.tex(,104) LIB "ntsolve.lib";
ntsolve_lib.tex(,105) ring r = (real,30),(z,y,x),(lp);
ntsolve_lib.tex(,106) ideal i = x^2-1,y^2+x4-3,z2-y4+x-1;
ntsolve_lib.tex(,107) ideal a = 2,3,4;
ntsolve_lib.tex(,108) intvec e = 20,10;
ntsolve_lib.tex(,109) ideal l = triMNewton(i,a,e);
ntsolve_lib.tex(,110) l;
ntsolve_lib.tex(,111) @expansion{} l[1]=-2.000000000042265738880279143423
ntsolve_lib.tex(,112) @expansion{} l[2]=1.41421356237309504880168872421
ntsolve_lib.tex(,113) @expansion{} l[3]=1
ntsolve_lib.tex(,114) @c end example triMNewton d2t_singular/ntsolve_lib.doc:97
ntsolve_lib.tex(,115) @end smallexample
ntsolve_lib.tex(,116) @c ---end content triMNewton---
singular.texi(,565) @c ---------------------------------------------------------
singular.texi(,566) @node zeroset_lib, , ntsolve_lib, Symbolic-numerical solving
singular.texi(,567) @subsection zeroset_lib
singular.texi(,568) @c include of docu for zeroset.lib
zeroset_lib.tex(,1) @c ---content LibInfo---
zeroset_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/zeroset_lib.doc
zeroset_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/zeroset_lib.doc INSTEAD
zeroset_lib.tex(,4) @c library version: (1.7.2.2,2002/02/20)
zeroset_lib.tex(,5) @c library file: ../Singular/LIB/zeroset.lib
zeroset_lib.tex(,6) @cindex zeroset.lib
zeroset_lib.tex(,7) @cindex zeroset_lib
zeroset_lib.tex(,8) @table @asis
zeroset_lib.tex(,9) @item @strong{Library:}
zeroset_lib.tex(,10) zeroset.lib
zeroset_lib.tex(,11) @item @strong{Purpose:}
zeroset_lib.tex(,12)       Procedures For Roots and Factorization
zeroset_lib.tex(,13) @item @strong{Author:}
zeroset_lib.tex(,14) Thomas Bayer, email: tbayer@@mathematik.uni-kl.de
zeroset_lib.tex(,15) @*http://wwwmayr.informatik.tu-muenchen.de/personen/bayert/
zeroset_lib.tex(,16) Current Adress: Institut fuer Informatik, TU Muenchen
zeroset_lib.tex(,17) 
zeroset_lib.tex(,18) @item @strong{Overview:}
zeroset_lib.tex(,19) Algorithms for finding the zero-set of a zero-dim. ideal in Q(a)[x_1,..,x_n],
zeroset_lib.tex(,20) Roots and Factorization of univariate polynomials over Q(a)[t]
zeroset_lib.tex(,21) where a is an algebraic number. Written in the frame of the
zeroset_lib.tex(,22) diploma thesis (advisor: Prof. Gert-Martin Greuel) 'Computations of moduli
zeroset_lib.tex(,23) spaces of semiquasihomogeneous singularities and an implementation in Singular'.
zeroset_lib.tex(,24) This library is meant as a preliminary extension of the functionality
zeroset_lib.tex(,25) of Singular for univariate factorization of polynomials over simple algebraic
zeroset_lib.tex(,26) extensions in characteristic 0.
zeroset_lib.tex(,27) @*Subprocedures with postfix 'Main' require that the ring contains a variable
zeroset_lib.tex(,28) 'a' and no parameters, and the ideal 'mpoly', where 'minpoly' from the
zeroset_lib.tex(,29) basering is stored.
zeroset_lib.tex(,30) 
zeroset_lib.tex(,31) @end table
zeroset_lib.tex(,32) 
zeroset_lib.tex(,33) @strong{Procedures:}
zeroset_lib.tex(,34) @menu
zeroset_lib.tex(,35) * EGCD:: gcd over an algebraic extension field of Q
zeroset_lib.tex(,36) * Factor:: factorization of f over an algebraic extension field
zeroset_lib.tex(,37) * Quotient:: quotient q of f w.r.t. g (in f = q*g + remainder)
zeroset_lib.tex(,38) * Remainder:: remainder of the division of f by g
zeroset_lib.tex(,39) * Roots:: computes all roots of f in an extension field of Q
zeroset_lib.tex(,40) * SQFRNorm:: norm of f (f must be squarefree)
zeroset_lib.tex(,41) * ZeroSet:: zero-set of the 0-dim. ideal I
zeroset_lib.tex(,42) @end menu
zeroset_lib.tex(,43) @strong{Auxiliary procedures:}
zeroset_lib.tex(,44) @menu
zeroset_lib.tex(,45) * EGCDMain:: gcd over an algebraic extension field of Q
zeroset_lib.tex(,46) * FactorMain:: factorization of f over an algebraic extension field
zeroset_lib.tex(,47) * InvertNumberMain:: inverts an element of an algebraic extension field
zeroset_lib.tex(,48) * QuotientMain:: quotient of f w.r.t. g
zeroset_lib.tex(,49) * RemainderMain:: remainder of the division of f by g
zeroset_lib.tex(,50) * RootsMain:: computes all roots of f, might extend the ground field
zeroset_lib.tex(,51) * SQFRNormMain:: norm of f (f must be squarefree)
zeroset_lib.tex(,52) * ContainedQ:: f in data ?
zeroset_lib.tex(,53) * SameQ:: a == b (list a,b)
zeroset_lib.tex(,54) @end menu
zeroset_lib.tex(,55) @c ---end content LibInfo---
zeroset_lib.tex(,56) 
zeroset_lib.tex(,57) @c ------------------- EGCD -------------
zeroset_lib.tex(,58) @node EGCD, Factor,, zeroset_lib
zeroset_lib.tex(,59) @subsubsection EGCD
zeroset_lib.tex(,60) @cindex EGCD
zeroset_lib.tex(,61) @c ---content EGCD---
zeroset_lib.tex(,62) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,63) 
zeroset_lib.tex(,64) @table @asis
zeroset_lib.tex(,65) @item @strong{Usage:}
zeroset_lib.tex(,66) EGCD(f, g); where f,g are polynomials
zeroset_lib.tex(,67) 
zeroset_lib.tex(,68) @item @strong{Purpose:}
zeroset_lib.tex(,69) compute the polynomial gcd of f and g over Q(a)[x]
zeroset_lib.tex(,70) 
zeroset_lib.tex(,71) @item @strong{Return:}
zeroset_lib.tex(,72) polynomial h s.t. h is a greatest common divisor of f and g (not nec.
zeroset_lib.tex(,73) monic)
zeroset_lib.tex(,74) 
zeroset_lib.tex(,75) @item @strong{Assume:}
zeroset_lib.tex(,76) basering = Q(a)[t]
zeroset_lib.tex(,77) 
zeroset_lib.tex(,78) @end table
zeroset_lib.tex(,79) @strong{Example:}
zeroset_lib.tex(,80) @smallexample
zeroset_lib.tex(,81) @c computed example EGCD d2t_singular/zeroset_lib.doc:79 
zeroset_lib.tex(,82) LIB "zeroset.lib";
zeroset_lib.tex(,83) ring R = (0,a), x, lp;
zeroset_lib.tex(,84) minpoly = a2+1;
zeroset_lib.tex(,85) poly f =  x4 - 1;
zeroset_lib.tex(,86) poly g = x2 - 2*a*x - 1;
zeroset_lib.tex(,87) EGCD(f, g);
zeroset_lib.tex(,88) @expansion{} (-4a)*x-4
zeroset_lib.tex(,89) @c end example EGCD d2t_singular/zeroset_lib.doc:79
zeroset_lib.tex(,90) @end smallexample
zeroset_lib.tex(,91) @c ---end content EGCD---
zeroset_lib.tex(,92) 
zeroset_lib.tex(,93) @c ------------------- Factor -------------
zeroset_lib.tex(,94) @node Factor, Quotient, EGCD, zeroset_lib
zeroset_lib.tex(,95) @subsubsection Factor
zeroset_lib.tex(,96) @cindex Factor
zeroset_lib.tex(,97) @c ---content Factor---
zeroset_lib.tex(,98) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,99) 
zeroset_lib.tex(,100) @table @asis
zeroset_lib.tex(,101) @item @strong{Usage:}
zeroset_lib.tex(,102) Factor(f); where f is a polynomial
zeroset_lib.tex(,103) 
zeroset_lib.tex(,104) @item @strong{Purpose:}
zeroset_lib.tex(,105) compute the factorization of the squarefree poly f over Q(a)[t]
zeroset_lib.tex(,106) 
zeroset_lib.tex(,107) @item @strong{Return:}
zeroset_lib.tex(,108) list with two entries
zeroset_lib.tex(,109)   @format
zeroset_lib.tex(,110)   _[1] = factors (monic), first entry is the leading coefficient
zeroset_lib.tex(,111)   _[2] = multiplicities (not yet implemented)
zeroset_lib.tex(,112)   @end format
zeroset_lib.tex(,113) 
zeroset_lib.tex(,114) @item @strong{Assume:}
zeroset_lib.tex(,115) basering must be the univariate polynomial ring over a field, which
zeroset_lib.tex(,116) is Q or a simple extension of Q given by a minpoly.
zeroset_lib.tex(,117) 
zeroset_lib.tex(,118) @item @strong{Note:}
zeroset_lib.tex(,119) if basering = Q[t] then this is the built-in @code{factorize}
zeroset_lib.tex(,120) 
zeroset_lib.tex(,121) @end table
zeroset_lib.tex(,122) @strong{Example:}
zeroset_lib.tex(,123) @smallexample
zeroset_lib.tex(,124) @c computed example Factor d2t_singular/zeroset_lib.doc:121 
zeroset_lib.tex(,125) LIB "zeroset.lib";
zeroset_lib.tex(,126) ring R = (0,a), x, lp;
zeroset_lib.tex(,127) minpoly = a2+1;
zeroset_lib.tex(,128) poly f =  x4 - 1;
zeroset_lib.tex(,129) list fl = Factor(f);
zeroset_lib.tex(,130) fl;
zeroset_lib.tex(,131) @expansion{} [1]:
zeroset_lib.tex(,132) @expansion{}    _[1]=1
zeroset_lib.tex(,133) @expansion{}    _[2]=(40a+60)*x+(40a+60)
zeroset_lib.tex(,134) @expansion{}    _[3]=(1/65a-29/130)*x+(-1/65a+29/130)
zeroset_lib.tex(,135) @expansion{}    _[4]=(4a)*x+4
zeroset_lib.tex(,136) @expansion{}    _[5]=(7/520a+1/130)*x+(1/130a-7/520)
zeroset_lib.tex(,137) @expansion{} [2]:
zeroset_lib.tex(,138) @expansion{}    _[1]=1
zeroset_lib.tex(,139) @expansion{}    _[2]=1
zeroset_lib.tex(,140) @expansion{}    _[3]=1
zeroset_lib.tex(,141) @expansion{}    _[4]=1
zeroset_lib.tex(,142) @expansion{}    _[5]=1
zeroset_lib.tex(,143) fl[1][1]*fl[1][2]*fl[1][3]*fl[1][4]*fl[1][5] - f;
zeroset_lib.tex(,144) @expansion{} 0
zeroset_lib.tex(,145) @c end example Factor d2t_singular/zeroset_lib.doc:121
zeroset_lib.tex(,146) @end smallexample
zeroset_lib.tex(,147) @c ---end content Factor---
zeroset_lib.tex(,148) 
zeroset_lib.tex(,149) @c ------------------- Quotient -------------
zeroset_lib.tex(,150) @node Quotient, Remainder, Factor, zeroset_lib
zeroset_lib.tex(,151) @subsubsection Quotient
zeroset_lib.tex(,152) @cindex Quotient
zeroset_lib.tex(,153) @c ---content Quotient---
zeroset_lib.tex(,154) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,155) 
zeroset_lib.tex(,156) @table @asis
zeroset_lib.tex(,157) @item @strong{Usage:}
zeroset_lib.tex(,158) Quotient(f, g); where f,g are polynomials;
zeroset_lib.tex(,159) 
zeroset_lib.tex(,160) @item @strong{Purpose:}
zeroset_lib.tex(,161) compute the quotient q and remainder r s.t. f = g*q + r, deg(r) < deg(g)
zeroset_lib.tex(,162) 
zeroset_lib.tex(,163) @item @strong{Return:}
zeroset_lib.tex(,164) list of polynomials
zeroset_lib.tex(,165)   @format
zeroset_lib.tex(,166)   _[1] = quotient  q
zeroset_lib.tex(,167)   _[2] = remainder r
zeroset_lib.tex(,168)   @end format
zeroset_lib.tex(,169) 
zeroset_lib.tex(,170) @item @strong{Assume:}
zeroset_lib.tex(,171) basering = Q[x] or Q(a)[x]
zeroset_lib.tex(,172) 
zeroset_lib.tex(,173) @end table
zeroset_lib.tex(,174) @strong{Example:}
zeroset_lib.tex(,175) @smallexample
zeroset_lib.tex(,176) @c computed example Quotient d2t_singular/zeroset_lib.doc:160 
zeroset_lib.tex(,177) LIB "zeroset.lib";
zeroset_lib.tex(,178) ring R = (0,a), x, lp;
zeroset_lib.tex(,179) minpoly = a2+1;
zeroset_lib.tex(,180) poly f =  x4 - 2;
zeroset_lib.tex(,181) poly g = x - a;
zeroset_lib.tex(,182) list qr = Quotient(f, g);
zeroset_lib.tex(,183) qr;
zeroset_lib.tex(,184) @expansion{} [1]:
zeroset_lib.tex(,185) @expansion{}    x3+(a)*x2-x+(-a)
zeroset_lib.tex(,186) @expansion{} [2]:
zeroset_lib.tex(,187) @expansion{}    0
zeroset_lib.tex(,188) qr[1]*g + qr[2] - f;
zeroset_lib.tex(,189) @expansion{} 1
zeroset_lib.tex(,190) @c end example Quotient d2t_singular/zeroset_lib.doc:160
zeroset_lib.tex(,191) @end smallexample
zeroset_lib.tex(,192) @c ---end content Quotient---
zeroset_lib.tex(,193) 
zeroset_lib.tex(,194) @c ------------------- Remainder -------------
zeroset_lib.tex(,195) @node Remainder, Roots, Quotient, zeroset_lib
zeroset_lib.tex(,196) @subsubsection Remainder
zeroset_lib.tex(,197) @cindex Remainder
zeroset_lib.tex(,198) @c ---content Remainder---
zeroset_lib.tex(,199) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,200) 
zeroset_lib.tex(,201) @table @asis
zeroset_lib.tex(,202) @item @strong{Usage:}
zeroset_lib.tex(,203) Remainder(f, g); where f,g are polynomials
zeroset_lib.tex(,204) 
zeroset_lib.tex(,205) @item @strong{Purpose:}
zeroset_lib.tex(,206) compute the remainder of the division of f by g, i.e. a polynomial r
zeroset_lib.tex(,207) s.t. f = g*q + r, deg(r) < deg(g).
zeroset_lib.tex(,208) 
zeroset_lib.tex(,209) @item @strong{Return:}
zeroset_lib.tex(,210) poly
zeroset_lib.tex(,211) 
zeroset_lib.tex(,212) @item @strong{Assume:}
zeroset_lib.tex(,213) basering = Q[x] or Q(a)[x]
zeroset_lib.tex(,214) 
zeroset_lib.tex(,215) @end table
zeroset_lib.tex(,216) @strong{Example:}
zeroset_lib.tex(,217) @smallexample
zeroset_lib.tex(,218) @c computed example Remainder d2t_singular/zeroset_lib.doc:197 
zeroset_lib.tex(,219) LIB "zeroset.lib";
zeroset_lib.tex(,220) ring R = (0,a), x, lp;
zeroset_lib.tex(,221) minpoly = a2+1;
zeroset_lib.tex(,222) poly f =  x4 - 1;
zeroset_lib.tex(,223) poly g = x3 - 1;
zeroset_lib.tex(,224) Remainder(f, g);
zeroset_lib.tex(,225) @expansion{} x-1
zeroset_lib.tex(,226) @c end example Remainder d2t_singular/zeroset_lib.doc:197
zeroset_lib.tex(,227) @end smallexample
zeroset_lib.tex(,228) @c ---end content Remainder---
zeroset_lib.tex(,229) 
zeroset_lib.tex(,230) @c ------------------- Roots -------------
zeroset_lib.tex(,231) @node Roots, SQFRNorm, Remainder, zeroset_lib
zeroset_lib.tex(,232) @subsubsection Roots
zeroset_lib.tex(,233) @cindex Roots
zeroset_lib.tex(,234) @c ---content Roots---
zeroset_lib.tex(,235) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,236) 
zeroset_lib.tex(,237) @table @asis
zeroset_lib.tex(,238) @item @strong{Usage:}
zeroset_lib.tex(,239) Roots(f); where f is a polynomial
zeroset_lib.tex(,240) 
zeroset_lib.tex(,241) @item @strong{Purpose:}
zeroset_lib.tex(,242) compute all roots of f in a finite extension of the ground field
zeroset_lib.tex(,243) without multiplicities.
zeroset_lib.tex(,244) 
zeroset_lib.tex(,245) @item @strong{Return:}
zeroset_lib.tex(,246) ring, a polynomial ring over an extension field of the ground field,
zeroset_lib.tex(,247) containing a list 'roots' and polynomials 'newA' and 'f':
zeroset_lib.tex(,248)   @format
zeroset_lib.tex(,249)   - 'roots' is the list of roots of the polynomial f (no multiplicities)
zeroset_lib.tex(,250)   - if the ground field is Q(a') and the extension field is Q(a), then
zeroset_lib.tex(,251)     'newA' is the representation of a' in Q(a). 
zeroset_lib.tex(,252)     If the basering contains a parameter 'a' and the minpoly remains unchanged
zeroset_lib.tex(,253)     then 'newA' = 'a'.
zeroset_lib.tex(,254)     If the basering does not contain a parameter then 'newA' = 'a' (default).
zeroset_lib.tex(,255)   - 'f' is the polynomial f in Q(a) (a' being substituted by 'newA')
zeroset_lib.tex(,256)   @end format
zeroset_lib.tex(,257) 
zeroset_lib.tex(,258) @item @strong{Assume:}
zeroset_lib.tex(,259) ground field to be Q or a simple extension of Q given by a minpoly
zeroset_lib.tex(,260) 
zeroset_lib.tex(,261) @end table
zeroset_lib.tex(,262) @strong{Example:}
zeroset_lib.tex(,263) @smallexample
zeroset_lib.tex(,264) @c computed example Roots d2t_singular/zeroset_lib.doc:242 
zeroset_lib.tex(,265) LIB "zeroset.lib";
zeroset_lib.tex(,266) ring R = (0,a), x, lp;
zeroset_lib.tex(,267) minpoly = a2+1;
zeroset_lib.tex(,268) poly f = x3 - a;
zeroset_lib.tex(,269) def R1 = Roots(f);
zeroset_lib.tex(,270) @expansion{} 
zeroset_lib.tex(,271) @expansion{} // 'Roots' created a new ring which contains the list 'roots' and
zeroset_lib.tex(,272) @expansion{} // the polynomials 'f' and 'newA'
zeroset_lib.tex(,273) @expansion{} // To access the roots, newA and the new representation of f, type
zeroset_lib.tex(,274) @expansion{}    def R = Roots(f); setring R; roots; newA; f;
zeroset_lib.tex(,275) @expansion{} 
zeroset_lib.tex(,276) setring R1;
zeroset_lib.tex(,277) minpoly;
zeroset_lib.tex(,278) @expansion{} (a4-a2+1)
zeroset_lib.tex(,279) newA;
zeroset_lib.tex(,280) @expansion{} (a3)
zeroset_lib.tex(,281) f;
zeroset_lib.tex(,282) @expansion{} x3+(-a3)
zeroset_lib.tex(,283) roots;
zeroset_lib.tex(,284) @expansion{} [1]:
zeroset_lib.tex(,285) @expansion{}    (-a3)
zeroset_lib.tex(,286) @expansion{} [2]:
zeroset_lib.tex(,287) @expansion{}    (a3-a)
zeroset_lib.tex(,288) @expansion{} [3]:
zeroset_lib.tex(,289) @expansion{}    (a)
zeroset_lib.tex(,290) map F;
zeroset_lib.tex(,291) F[1] = roots[1];
zeroset_lib.tex(,292) F(f);
zeroset_lib.tex(,293) @expansion{} 0
zeroset_lib.tex(,294) @c end example Roots d2t_singular/zeroset_lib.doc:242
zeroset_lib.tex(,295) @end smallexample
zeroset_lib.tex(,296) @c ---end content Roots---
zeroset_lib.tex(,297) 
zeroset_lib.tex(,298) @c ------------------- SQFRNorm -------------
zeroset_lib.tex(,299) @node SQFRNorm, ZeroSet, Roots, zeroset_lib
zeroset_lib.tex(,300) @subsubsection SQFRNorm
zeroset_lib.tex(,301) @cindex SQFRNorm
zeroset_lib.tex(,302) @c ---content SQFRNorm---
zeroset_lib.tex(,303) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,304) 
zeroset_lib.tex(,305) @table @asis
zeroset_lib.tex(,306) @item @strong{Usage:}
zeroset_lib.tex(,307) SQFRNorm(f); where f is a polynomial
zeroset_lib.tex(,308) 
zeroset_lib.tex(,309) @item @strong{Purpose:}
zeroset_lib.tex(,310) compute the norm of the squarefree polynomial f in Q(a)[x].
zeroset_lib.tex(,311) 
zeroset_lib.tex(,312) @item @strong{Return:}
zeroset_lib.tex(,313) list with 3 entries
zeroset_lib.tex(,314)   @format
zeroset_lib.tex(,315)   _[1] = squarefree norm of g (poly)
zeroset_lib.tex(,316)   _[2] = g (= f(x - s*a)) (poly)
zeroset_lib.tex(,317)   _[3] = s (int)
zeroset_lib.tex(,318)   @end format
zeroset_lib.tex(,319) 
zeroset_lib.tex(,320) @item @strong{Assume:}
zeroset_lib.tex(,321) f must be squarefree, basering = Q(a)[x] and minpoly != 0.
zeroset_lib.tex(,322) 
zeroset_lib.tex(,323) @item @strong{Note:}
zeroset_lib.tex(,324) the norm is an element of Q[x]
zeroset_lib.tex(,325) 
zeroset_lib.tex(,326) @end table
zeroset_lib.tex(,327) @strong{Example:}
zeroset_lib.tex(,328) @smallexample
zeroset_lib.tex(,329) @c computed example SQFRNorm d2t_singular/zeroset_lib.doc:291 
zeroset_lib.tex(,330) LIB "zeroset.lib";
zeroset_lib.tex(,331) ring R = (0,a), x, lp;
zeroset_lib.tex(,332) minpoly = a2+1;
zeroset_lib.tex(,333) poly f =  x4 - 2*x + 1;
zeroset_lib.tex(,334) SQFRNorm(f);
zeroset_lib.tex(,335) @expansion{} [1]:
zeroset_lib.tex(,336) @expansion{}    x8+4*x6-4*x5+8*x4+8*x3-4*x2+8*x+8
zeroset_lib.tex(,337) @expansion{} [2]:
zeroset_lib.tex(,338) @expansion{}    x4+(-4a)*x3-6*x2+(4a-2)*x+(2a+2)
zeroset_lib.tex(,339) @expansion{} [3]:
zeroset_lib.tex(,340) @expansion{}    1
zeroset_lib.tex(,341) @c end example SQFRNorm d2t_singular/zeroset_lib.doc:291
zeroset_lib.tex(,342) @end smallexample
zeroset_lib.tex(,343) @c ---end content SQFRNorm---
zeroset_lib.tex(,344) 
zeroset_lib.tex(,345) @c ------------------- ZeroSet -------------
zeroset_lib.tex(,346) @node ZeroSet, EGCDMain, SQFRNorm, zeroset_lib
zeroset_lib.tex(,347) @subsubsection ZeroSet
zeroset_lib.tex(,348) @cindex ZeroSet
zeroset_lib.tex(,349) @c ---content ZeroSet---
zeroset_lib.tex(,350) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,351) 
zeroset_lib.tex(,352) @table @asis
zeroset_lib.tex(,353) @item @strong{Usage:}
zeroset_lib.tex(,354) ZeroSet(I [,opt] ); I=ideal, opt=integer
zeroset_lib.tex(,355) 
zeroset_lib.tex(,356) @item @strong{Purpose:}
zeroset_lib.tex(,357) compute the zero-set of the zero-dim. ideal I, in a finite extension
zeroset_lib.tex(,358) of the ground field.
zeroset_lib.tex(,359) 
zeroset_lib.tex(,360) @item @strong{Return:}
zeroset_lib.tex(,361) ring, a polynomial ring over an extension field of the ground field,
zeroset_lib.tex(,362) containing a list 'zeroset', a polynomial 'newA', and an
zeroset_lib.tex(,363) ideal 'id':
zeroset_lib.tex(,364)   @format
zeroset_lib.tex(,365)   - 'zeroset' is the list of the zeros of the ideal I, each zero is an ideal.
zeroset_lib.tex(,366)   - if the ground field is Q(a') and the extension field is Q(a), then
zeroset_lib.tex(,367)     'newA' is the representation of a' in Q(a).
zeroset_lib.tex(,368)     If the basering contains a parameter 'a' and the minpoly remains unchanged
zeroset_lib.tex(,369)     then 'newA' = 'a'.
zeroset_lib.tex(,370)     If the basering does not contain a parameter then 'newA' = 'a' (default).    
zeroset_lib.tex(,371)   - 'id' is the ideal I in Q(a)[x_1,...] (a' substituted by 'newA')
zeroset_lib.tex(,372)   @end format
zeroset_lib.tex(,373) 
zeroset_lib.tex(,374) @item @strong{Assume:}
zeroset_lib.tex(,375) dim(I) = 0, and ground field to be Q or a simple extension of Q given
zeroset_lib.tex(,376) by a minpoly.
zeroset_lib.tex(,377) 
zeroset_lib.tex(,378) @item @strong{Options:}
zeroset_lib.tex(,379) opt = 0 no primary decomposition (default)
zeroset_lib.tex(,380) @*opt > 0 primary decomposition
zeroset_lib.tex(,381) 
zeroset_lib.tex(,382) @item @strong{Note:}
zeroset_lib.tex(,383) If I contains an algebraic number (parameter) then 'I' must be
zeroset_lib.tex(,384) transformed w.r.t. 'newA' in the new ring.
zeroset_lib.tex(,385) 
zeroset_lib.tex(,386) @end table
zeroset_lib.tex(,387) @strong{Example:}
zeroset_lib.tex(,388) @smallexample
zeroset_lib.tex(,389) @c computed example ZeroSet d2t_singular/zeroset_lib.doc:345 
zeroset_lib.tex(,390) LIB "zeroset.lib";
zeroset_lib.tex(,391) ring R = (0,a), (x,y,z), lp;
zeroset_lib.tex(,392) minpoly = a2 + 1;
zeroset_lib.tex(,393) ideal I = x2 - 1/2, a*z - 1, y - 2;
zeroset_lib.tex(,394) def T = ZeroSet(I);
zeroset_lib.tex(,395) @expansion{} 1
zeroset_lib.tex(,396) setring T;
zeroset_lib.tex(,397) minpoly;
zeroset_lib.tex(,398) @expansion{} (4a4+4a2+9)
zeroset_lib.tex(,399) newA;
zeroset_lib.tex(,400) @expansion{} (1/3a3+5/6a)
zeroset_lib.tex(,401) id;
zeroset_lib.tex(,402) @expansion{} id[1]=(1/3a3+5/6a)*z-1
zeroset_lib.tex(,403) @expansion{} id[2]=y-2
zeroset_lib.tex(,404) @expansion{} id[3]=2*x2-1
zeroset_lib.tex(,405) zeroset;
zeroset_lib.tex(,406) @expansion{} [1]:
zeroset_lib.tex(,407) @expansion{}    _[1]=(1/3a3-1/6a)
zeroset_lib.tex(,408) @expansion{}    _[2]=2
zeroset_lib.tex(,409) @expansion{}    _[3]=(-1/3a3-5/6a)
zeroset_lib.tex(,410) @expansion{} [2]:
zeroset_lib.tex(,411) @expansion{}    _[1]=(-1/3a3+1/6a)
zeroset_lib.tex(,412) @expansion{}    _[2]=2
zeroset_lib.tex(,413) @expansion{}    _[3]=(-1/3a3-5/6a)
zeroset_lib.tex(,414) map F1 = basering, zeroset[1];
zeroset_lib.tex(,415) map F2 = basering, zeroset[2];
zeroset_lib.tex(,416) F1(id);
zeroset_lib.tex(,417) @expansion{} _[1]=0
zeroset_lib.tex(,418) @expansion{} _[2]=0
zeroset_lib.tex(,419) @expansion{} _[3]=0
zeroset_lib.tex(,420) F2(id);
zeroset_lib.tex(,421) @expansion{} _[1]=0
zeroset_lib.tex(,422) @expansion{} _[2]=0
zeroset_lib.tex(,423) @expansion{} _[3]=0
zeroset_lib.tex(,424) @c end example ZeroSet d2t_singular/zeroset_lib.doc:345
zeroset_lib.tex(,425) @end smallexample
zeroset_lib.tex(,426) @c ---end content ZeroSet---
zeroset_lib.tex(,427) 
zeroset_lib.tex(,428) @c ------------------- EGCDMain -------------
zeroset_lib.tex(,429) @node EGCDMain, FactorMain, ZeroSet, zeroset_lib
zeroset_lib.tex(,430) @subsubsection EGCDMain
zeroset_lib.tex(,431) @cindex EGCDMain
zeroset_lib.tex(,432) @c ---content EGCDMain---
zeroset_lib.tex(,433) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,434) 
zeroset_lib.tex(,435) @table @asis
zeroset_lib.tex(,436) @item @strong{Purpose:}
zeroset_lib.tex(,437) compute the polynomial gcd of f and g over Q(a)[x]
zeroset_lib.tex(,438) 
zeroset_lib.tex(,439) @item @strong{Return:}
zeroset_lib.tex(,440) poly
zeroset_lib.tex(,441) 
zeroset_lib.tex(,442) @item @strong{Assume:}
zeroset_lib.tex(,443) basering = Q[x,a] and ideal mpoly is defined (it might be 0),
zeroset_lib.tex(,444) this represents the ring Q(a)[x] together with its minimal polynomial.
zeroset_lib.tex(,445) 
zeroset_lib.tex(,446) @end table
zeroset_lib.tex(,447) @c ---end content EGCDMain---
zeroset_lib.tex(,448) 
zeroset_lib.tex(,449) @c ------------------- FactorMain -------------
zeroset_lib.tex(,450) @node FactorMain, InvertNumberMain, EGCDMain, zeroset_lib
zeroset_lib.tex(,451) @subsubsection FactorMain
zeroset_lib.tex(,452) @cindex FactorMain
zeroset_lib.tex(,453) @c ---content FactorMain---
zeroset_lib.tex(,454) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,455) 
zeroset_lib.tex(,456) @table @asis
zeroset_lib.tex(,457) @item @strong{Purpose:}
zeroset_lib.tex(,458) compute the factorization of the squarefree poly f over Q(a)[t],
zeroset_lib.tex(,459) minpoly = p(a).
zeroset_lib.tex(,460) 
zeroset_lib.tex(,461) @item @strong{Return:}
zeroset_lib.tex(,462) list with 2 entries
zeroset_lib.tex(,463)   @format
zeroset_lib.tex(,464)   _[1] = factors, first is a constant
zeroset_lib.tex(,465)   _[2] = multiplicities (not yet implemented)
zeroset_lib.tex(,466)   @end format
zeroset_lib.tex(,467) 
zeroset_lib.tex(,468) @item @strong{Assume:}
zeroset_lib.tex(,469) basering = Q[x,a], representing Q(a)[x]. An ideal mpoly must
zeroset_lib.tex(,470) be defined, representing the minimal polynomial (it might be 0!).
zeroset_lib.tex(,471) 
zeroset_lib.tex(,472) @end table
zeroset_lib.tex(,473) @c ---end content FactorMain---
zeroset_lib.tex(,474) 
zeroset_lib.tex(,475) @c ------------------- InvertNumberMain -------------
zeroset_lib.tex(,476) @node InvertNumberMain, QuotientMain, FactorMain, zeroset_lib
zeroset_lib.tex(,477) @subsubsection InvertNumberMain
zeroset_lib.tex(,478) @cindex InvertNumberMain
zeroset_lib.tex(,479) @c ---content InvertNumberMain---
zeroset_lib.tex(,480) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,481) 
zeroset_lib.tex(,482) @table @asis
zeroset_lib.tex(,483) @item @strong{Usage:}
zeroset_lib.tex(,484) InvertNumberMain(f); where f is a polynomial
zeroset_lib.tex(,485) 
zeroset_lib.tex(,486) @item @strong{Purpose:}
zeroset_lib.tex(,487) compute 1/f if f is a number in Q(a) i.e., f is represented by a
zeroset_lib.tex(,488) polynomial in Q[a].
zeroset_lib.tex(,489) 
zeroset_lib.tex(,490) @item @strong{Return:}
zeroset_lib.tex(,491) poly 1/f
zeroset_lib.tex(,492) 
zeroset_lib.tex(,493) @item @strong{Assume:}
zeroset_lib.tex(,494) basering = Q[x_1,...,x_n,a], ideal mpoly must be defined and != 0 !
zeroset_lib.tex(,495) 
zeroset_lib.tex(,496) @end table
zeroset_lib.tex(,497) @c ---end content InvertNumberMain---
zeroset_lib.tex(,498) 
zeroset_lib.tex(,499) @c ------------------- QuotientMain -------------
zeroset_lib.tex(,500) @node QuotientMain, RemainderMain, InvertNumberMain, zeroset_lib
zeroset_lib.tex(,501) @subsubsection QuotientMain
zeroset_lib.tex(,502) @cindex QuotientMain
zeroset_lib.tex(,503) @c ---content QuotientMain---
zeroset_lib.tex(,504) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,505) 
zeroset_lib.tex(,506) @table @asis
zeroset_lib.tex(,507) @item @strong{Usage:}
zeroset_lib.tex(,508) QuotientMain(f, g); where f,g are polynomials
zeroset_lib.tex(,509) 
zeroset_lib.tex(,510) @item @strong{Purpose:}
zeroset_lib.tex(,511) compute the quotient q and remainder r s.t. f = g*q + r, deg(r) < deg(g)
zeroset_lib.tex(,512) 
zeroset_lib.tex(,513) @item @strong{Return:}
zeroset_lib.tex(,514) list of polynomials
zeroset_lib.tex(,515)   @format
zeroset_lib.tex(,516)   _[1] = quotient  q
zeroset_lib.tex(,517)   _[2] = remainder r
zeroset_lib.tex(,518)   @end format
zeroset_lib.tex(,519) 
zeroset_lib.tex(,520) @item @strong{Assume:}
zeroset_lib.tex(,521) basering = Q[x,a] and ideal mpoly is defined (it might be 0),
zeroset_lib.tex(,522) this represents the ring Q(a)[x] together with its minimal polynomial.
zeroset_lib.tex(,523) 
zeroset_lib.tex(,524) @end table
zeroset_lib.tex(,525) @c ---end content QuotientMain---
zeroset_lib.tex(,526) 
zeroset_lib.tex(,527) @c ------------------- RemainderMain -------------
zeroset_lib.tex(,528) @node RemainderMain, RootsMain, QuotientMain, zeroset_lib
zeroset_lib.tex(,529) @subsubsection RemainderMain
zeroset_lib.tex(,530) @cindex RemainderMain
zeroset_lib.tex(,531) @c ---content RemainderMain---
zeroset_lib.tex(,532) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,533) 
zeroset_lib.tex(,534) @table @asis
zeroset_lib.tex(,535) @item @strong{Usage:}
zeroset_lib.tex(,536) RemainderMain(f, g); where f,g are polynomials
zeroset_lib.tex(,537) 
zeroset_lib.tex(,538) @item @strong{Purpose:}
zeroset_lib.tex(,539) compute the remainder r s.t. f = g*q + r, deg(r) < deg(g)
zeroset_lib.tex(,540) 
zeroset_lib.tex(,541) @item @strong{Return:}
zeroset_lib.tex(,542) poly
zeroset_lib.tex(,543) 
zeroset_lib.tex(,544) @item @strong{Assume:}
zeroset_lib.tex(,545) basering = Q[x,a] and ideal mpoly is defined (it might be 0),
zeroset_lib.tex(,546) this represents the ring Q(a)[x] together with its minimal polynomial.
zeroset_lib.tex(,547) 
zeroset_lib.tex(,548) @end table
zeroset_lib.tex(,549) @c ---end content RemainderMain---
zeroset_lib.tex(,550) 
zeroset_lib.tex(,551) @c ------------------- RootsMain -------------
zeroset_lib.tex(,552) @node RootsMain, SQFRNormMain, RemainderMain, zeroset_lib
zeroset_lib.tex(,553) @subsubsection RootsMain
zeroset_lib.tex(,554) @cindex RootsMain
zeroset_lib.tex(,555) @c ---content RootsMain---
zeroset_lib.tex(,556) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,557) 
zeroset_lib.tex(,558) @table @asis
zeroset_lib.tex(,559) @item @strong{Usage:}
zeroset_lib.tex(,560) RootsMain(f); where f is a polynomial
zeroset_lib.tex(,561) 
zeroset_lib.tex(,562) @item @strong{Purpose:}
zeroset_lib.tex(,563) compute all roots of f in a finite extension of the ground field
zeroset_lib.tex(,564) without multiplicities.
zeroset_lib.tex(,565) 
zeroset_lib.tex(,566) @item @strong{Return:}
zeroset_lib.tex(,567) list, all entries are polynomials
zeroset_lib.tex(,568)   @format
zeroset_lib.tex(,569)   _[1] = roots of f, each entry is a polynomial
zeroset_lib.tex(,570)   _[2] = 'newA' - if the ground field is Q(a') and the extension field
zeroset_lib.tex(,571)          is Q(a), then 'newA' is the representation of a' in Q(a)
zeroset_lib.tex(,572)   _[3] = minpoly of the algebraic extension of the ground field
zeroset_lib.tex(,573)   @end format
zeroset_lib.tex(,574) 
zeroset_lib.tex(,575) @item @strong{Assume:}
zeroset_lib.tex(,576) basering = Q[x,a] ideal mpoly must be defined, it might be 0!
zeroset_lib.tex(,577) 
zeroset_lib.tex(,578) @item @strong{Note:}
zeroset_lib.tex(,579) might change the ideal mpoly !!
zeroset_lib.tex(,580) 
zeroset_lib.tex(,581) @end table
zeroset_lib.tex(,582) @c ---end content RootsMain---
zeroset_lib.tex(,583) 
zeroset_lib.tex(,584) @c ------------------- SQFRNormMain -------------
zeroset_lib.tex(,585) @node SQFRNormMain, ContainedQ, RootsMain, zeroset_lib
zeroset_lib.tex(,586) @subsubsection SQFRNormMain
zeroset_lib.tex(,587) @cindex SQFRNormMain
zeroset_lib.tex(,588) @c ---content SQFRNormMain---
zeroset_lib.tex(,589) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,590) 
zeroset_lib.tex(,591) @table @asis
zeroset_lib.tex(,592) @item @strong{Usage:}
zeroset_lib.tex(,593) SQFRNorm(f); where f is a polynomial
zeroset_lib.tex(,594) 
zeroset_lib.tex(,595) @item @strong{Purpose:}
zeroset_lib.tex(,596) compute the norm of the squarefree polynomial f in Q(a)[x].
zeroset_lib.tex(,597) 
zeroset_lib.tex(,598) @item @strong{Return:}
zeroset_lib.tex(,599) list with 3 entries
zeroset_lib.tex(,600)   @format
zeroset_lib.tex(,601)   _[1] = squarefree norm of g (poly)
zeroset_lib.tex(,602)   _[2] = g (= f(x - s*a)) (poly)
zeroset_lib.tex(,603)   _[3] = s (int)
zeroset_lib.tex(,604)   @end format
zeroset_lib.tex(,605) 
zeroset_lib.tex(,606) @item @strong{Assume:}
zeroset_lib.tex(,607) f must be squarefree, basering = Q[x,a] and ideal mpoly is equal to
zeroset_lib.tex(,608) 'minpoly',this represents the ring Q(a)[x] together with 'minpoly'.
zeroset_lib.tex(,609) 
zeroset_lib.tex(,610) @item @strong{Note:}
zeroset_lib.tex(,611) the norm is an element of Q[x]
zeroset_lib.tex(,612) 
zeroset_lib.tex(,613) @end table
zeroset_lib.tex(,614) @c ---end content SQFRNormMain---
zeroset_lib.tex(,615) 
zeroset_lib.tex(,616) @c ------------------- ContainedQ -------------
zeroset_lib.tex(,617) @node ContainedQ, SameQ, SQFRNormMain, zeroset_lib
zeroset_lib.tex(,618) @subsubsection ContainedQ
zeroset_lib.tex(,619) @cindex ContainedQ
zeroset_lib.tex(,620) @c ---content ContainedQ---
zeroset_lib.tex(,621) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,622) 
zeroset_lib.tex(,623) @table @asis
zeroset_lib.tex(,624) @item @strong{Usage:}
zeroset_lib.tex(,625) ContainedQ(data, f [, opt]); data=list; f=any type, opt=integer
zeroset_lib.tex(,626) 
zeroset_lib.tex(,627) @item @strong{Purpose:}
zeroset_lib.tex(,628) test if f is an element of data.
zeroset_lib.tex(,629) 
zeroset_lib.tex(,630) @item @strong{Return:}
zeroset_lib.tex(,631) int
zeroset_lib.tex(,632) @*0 if f not contained in data
zeroset_lib.tex(,633) @*1 if f contained in data
zeroset_lib.tex(,634) 
zeroset_lib.tex(,635) @item @strong{Options:}
zeroset_lib.tex(,636) opt = 0 : use '==' for comparing f with elements from data@*
zeroset_lib.tex(,637) opt = 1 : use @code{SameQ} for comparing f with elements from data
zeroset_lib.tex(,638) 
zeroset_lib.tex(,639) @end table
zeroset_lib.tex(,640) @c ---end content ContainedQ---
zeroset_lib.tex(,641) 
zeroset_lib.tex(,642) @c ------------------- SameQ -------------
zeroset_lib.tex(,643) @node SameQ,, ContainedQ, zeroset_lib
zeroset_lib.tex(,644) @subsubsection SameQ
zeroset_lib.tex(,645) @cindex SameQ
zeroset_lib.tex(,646) @c ---content SameQ---
zeroset_lib.tex(,647) Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).
zeroset_lib.tex(,648) 
zeroset_lib.tex(,649) @table @asis
zeroset_lib.tex(,650) @item @strong{Usage:}
zeroset_lib.tex(,651) SameQ(a, b); a,b=list/intvec
zeroset_lib.tex(,652) 
zeroset_lib.tex(,653) @item @strong{Purpose:}
zeroset_lib.tex(,654) test a == b elementwise, i.e., a[i] = b[i].
zeroset_lib.tex(,655) 
zeroset_lib.tex(,656) @item @strong{Return:}
zeroset_lib.tex(,657) int
zeroset_lib.tex(,658) @*0 if a != b
zeroset_lib.tex(,659) @*1 if a == b
zeroset_lib.tex(,660) 
zeroset_lib.tex(,661) @end table
zeroset_lib.tex(,662) @c ---end content SameQ---
singular.texi(,570) 
singular.texi(,571) @c ----------------------------------------------------------------------------
singular.texi(,572) @node Visualization, Coding theory, Symbolic-numerical solving, SINGULAR libraries
singular.texi(,573) @section Visualization
singular.texi(,574) @cindex Visualization
singular.texi(,575) 
singular.texi(,576) @menu
singular.texi(,577) * graphics_lib:: procedures to draw  with Mathematica
singular.texi(,578) * latex_lib:: procedures for typesetting in TeX
singular.texi(,579) * paramet_lib:: procedures for parametrizations
singular.texi(,580) * surf_lib:: interface to the surf program
singular.texi(,581) @end menu
singular.texi(,582) 
singular.texi(,583) @c ---------------------------------------------------------
singular.texi(,584) @node graphics_lib, latex_lib, Visualization, Visualization
singular.texi(,585) @subsection graphics_lib
singular.texi(,586) @c include of docu for graphics.lib
graphics_lib_noEx.tex(,1) @c ---content LibInfo---
graphics_lib_noEx.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/graphics_lib.doc
graphics_lib_noEx.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/graphics_lib.doc INSTEAD
graphics_lib_noEx.tex(,4) @c library version: (1.10,2001/02/19)
graphics_lib_noEx.tex(,5) @c library file: ../Singular/LIB/graphics.lib
graphics_lib_noEx.tex(,6) @cindex graphics.lib
graphics_lib_noEx.tex(,7) @cindex graphics_lib
graphics_lib_noEx.tex(,8) @table @asis
graphics_lib_noEx.tex(,9) @item @strong{Library:}
graphics_lib_noEx.tex(,10) graphics.lib
graphics_lib_noEx.tex(,11) @item @strong{Purpose:}
graphics_lib_noEx.tex(,12)     Procedures to use Graphics with Mathematica
graphics_lib_noEx.tex(,13) @item @strong{Author:}
graphics_lib_noEx.tex(,14) Christian Gorzel, gorzelc@@math.uni-muenster.de
graphics_lib_noEx.tex(,15) 
graphics_lib_noEx.tex(,16) @end table
graphics_lib_noEx.tex(,17) 
graphics_lib_noEx.tex(,18) @strong{Procedures:}
graphics_lib_noEx.tex(,19) @menu
graphics_lib_noEx.tex(,20) * staircase:: Mathematica text for displaying staircase of I
graphics_lib_noEx.tex(,21) * mathinit:: string for loading Mathematica's ImplicitPlot
graphics_lib_noEx.tex(,22) * mplot:: Mathematica text for various plots
graphics_lib_noEx.tex(,23) @end menu
graphics_lib_noEx.tex(,24) @c ---end content LibInfo---
graphics_lib_noEx.tex(,25) 
graphics_lib_noEx.tex(,26) @c ------------------- staircase -------------
graphics_lib_noEx.tex(,27) @node staircase, mathinit,, graphics_lib
graphics_lib_noEx.tex(,28) @subsubsection staircase
graphics_lib_noEx.tex(,29) @cindex staircase
graphics_lib_noEx.tex(,30) @c ---content staircase---
graphics_lib_noEx.tex(,31) Procedure from library @code{graphics.lib} (@pxref{graphics_lib}).
graphics_lib_noEx.tex(,32) 
graphics_lib_noEx.tex(,33) @table @asis
graphics_lib_noEx.tex(,34) @item @strong{Usage:}
graphics_lib_noEx.tex(,35) staircase(s,I); s a string, I ideal in two variables
graphics_lib_noEx.tex(,36) 
graphics_lib_noEx.tex(,37) @item @strong{Return:}
graphics_lib_noEx.tex(,38) string with Mathematica input for displaying staircase diagrams of an
graphics_lib_noEx.tex(,39) ideal I, i.e. exponent vectors of the initial ideal of I
graphics_lib_noEx.tex(,40) 
graphics_lib_noEx.tex(,41) @item @strong{Note:}
graphics_lib_noEx.tex(,42) ideal I should be given by a standard basis. Let s="" and copy and
graphics_lib_noEx.tex(,43) paste the result into a Mathematica notebook.
graphics_lib_noEx.tex(,44) 
graphics_lib_noEx.tex(,45) @end table
graphics_lib_noEx.tex(,46) @strong{Example:}
graphics_lib_noEx.tex(,47) @smallexample
graphics_lib_noEx.tex(,48) @c skipped computation of example staircase d2t_singular/graphics_lib.doc:46 
graphics_lib_noEx.tex(,49) LIB "graphics.lib";
graphics_lib_noEx.tex(,50) ring r0 = 0,(x,y),ls;
graphics_lib_noEx.tex(,51) ideal I = -1x2y6-1x4y2, 7x6y5+1/2x7y4+6x4y6;
graphics_lib_noEx.tex(,52) staircase("",std(I));
graphics_lib_noEx.tex(,53) ring r1 = 0,(x,y),dp;
graphics_lib_noEx.tex(,54) ideal I = fetch(r0,I);
graphics_lib_noEx.tex(,55) staircase("",std(I));
graphics_lib_noEx.tex(,56) ring r2 = 0,(x,y),wp(2,3);
graphics_lib_noEx.tex(,57) ideal I = fetch(r0,I);
graphics_lib_noEx.tex(,58) staircase("",std(I));
graphics_lib_noEx.tex(,59) // Paste the output into a Mathematica notebook
graphics_lib_noEx.tex(,60) // active evalutation of the cell with SHIFT RETURN
graphics_lib_noEx.tex(,61) @end smallexample
graphics_lib_noEx.tex(,62) @c ---end content staircase---
graphics_lib_noEx.tex(,63) 
graphics_lib_noEx.tex(,64) @c ------------------- mathinit -------------
graphics_lib_noEx.tex(,65) @node mathinit, mplot, staircase, graphics_lib
graphics_lib_noEx.tex(,66) @subsubsection mathinit
graphics_lib_noEx.tex(,67) @cindex mathinit
graphics_lib_noEx.tex(,68) @c ---content mathinit---
graphics_lib_noEx.tex(,69) Procedure from library @code{graphics.lib} (@pxref{graphics_lib}).
graphics_lib_noEx.tex(,70) 
graphics_lib_noEx.tex(,71) @table @asis
graphics_lib_noEx.tex(,72) @item @strong{Usage:}
graphics_lib_noEx.tex(,73) mathinit();
graphics_lib_noEx.tex(,74) 
graphics_lib_noEx.tex(,75) @item @strong{Return:}
graphics_lib_noEx.tex(,76) initializing string for loading Mathematica's ImplicitPlot
graphics_lib_noEx.tex(,77) 
graphics_lib_noEx.tex(,78) @end table
graphics_lib_noEx.tex(,79) @strong{Example:}
graphics_lib_noEx.tex(,80) @smallexample
graphics_lib_noEx.tex(,81) @c skipped computation of example mathinit d2t_singular/graphics_lib.doc:80 
graphics_lib_noEx.tex(,82) LIB "graphics.lib";
graphics_lib_noEx.tex(,83) mathinit();
graphics_lib_noEx.tex(,84) // Paste the output into a Mathematica notebook
graphics_lib_noEx.tex(,85) // active evalutation of the cell with SHIFT RETURN
graphics_lib_noEx.tex(,86) @end smallexample
graphics_lib_noEx.tex(,87) @c ---end content mathinit---
graphics_lib_noEx.tex(,88) 
graphics_lib_noEx.tex(,89) @c ------------------- mplot -------------
graphics_lib_noEx.tex(,90) @node mplot,, mathinit, graphics_lib
graphics_lib_noEx.tex(,91) @subsubsection mplot
graphics_lib_noEx.tex(,92) @cindex mplot
graphics_lib_noEx.tex(,93) @c ---content mplot---
graphics_lib_noEx.tex(,94) Procedure from library @code{graphics.lib} (@pxref{graphics_lib}).
graphics_lib_noEx.tex(,95) 
graphics_lib_noEx.tex(,96) @table @asis
graphics_lib_noEx.tex(,97) @item @strong{Usage:}
graphics_lib_noEx.tex(,98) mplot(fname, I [,I1,I2,..,s] ); fname=string; I,I1,I2,..=ideals,
graphics_lib_noEx.tex(,99) s=string representing the plot region.@*
graphics_lib_noEx.tex(,100) Use the ideals I1,I2,.. in order to produce multiple plots (they need
graphics_lib_noEx.tex(,101) to have the same number of entries as I!).
graphics_lib_noEx.tex(,102) 
graphics_lib_noEx.tex(,103) @item @strong{Return:}
graphics_lib_noEx.tex(,104) string, text with Mathematica commands to display a plot
graphics_lib_noEx.tex(,105) 
graphics_lib_noEx.tex(,106) @item @strong{Note:}
graphics_lib_noEx.tex(,107) The plotregion is defaulted to -1,1 around zero.
graphics_lib_noEx.tex(,108) @*For implicit given curves enter first the string returned by
graphics_lib_noEx.tex(,109) proc mathinit into Mathematica in order to load ImplicitPlot.
graphics_lib_noEx.tex(,110) The following conventions for I are used:
graphics_lib_noEx.tex(,111)   @format
graphics_lib_noEx.tex(,112)   - ideal with 2 entries in one variable means a parametrised plane curve,
graphics_lib_noEx.tex(,113)   - ideal with 3 entries in one variable means a parametrised space curve,
graphics_lib_noEx.tex(,114)   - ideal with 3 entries in two variables means a parametrised surface,
graphics_lib_noEx.tex(,115)   - ideal with 2 entries in two variables means an implicit curve
graphics_lib_noEx.tex(,116)     given as I[1]==I[2],
graphics_lib_noEx.tex(,117)   - ideal with 1 entry (or one polynomial) in two variables means
graphics_lib_noEx.tex(,118)     an implicit curve given as  f == 0,
graphics_lib_noEx.tex(,119)   @end format
graphics_lib_noEx.tex(,120) 
graphics_lib_noEx.tex(,121) @end table
graphics_lib_noEx.tex(,122) @strong{Example:}
graphics_lib_noEx.tex(,123) @smallexample
graphics_lib_noEx.tex(,124) @c skipped computation of example mplot d2t_singular/graphics_lib.doc:124 
graphics_lib_noEx.tex(,125) LIB "graphics.lib";
graphics_lib_noEx.tex(,126) // ---------  plane curves ------------
graphics_lib_noEx.tex(,127) ring rr0 = 0,x,dp; export rr0;
graphics_lib_noEx.tex(,128) ideal I = x3 + x, x2;
graphics_lib_noEx.tex(,129) ideal J = x2, -x+x3;
graphics_lib_noEx.tex(,130) mplot("",I,J,"-2,2");
graphics_lib_noEx.tex(,131) // Paste the output into a Mathematica notebook
graphics_lib_noEx.tex(,132) // active evalutation of the cell with SHIFT RETURN
graphics_lib_noEx.tex(,133) // --------- space curves --------------
graphics_lib_noEx.tex(,134) I = x3,-1/10x3+x2,x2;
graphics_lib_noEx.tex(,135) mplot("",I);
graphics_lib_noEx.tex(,136) // Paste the output into a Mathematica notebook
graphics_lib_noEx.tex(,137) // active evalutation of the cell with SHIFT RETURN
graphics_lib_noEx.tex(,138) // ----------- surfaces -------------------
graphics_lib_noEx.tex(,139) ring rr1 = 0,(x,y),dp; export rr1;
graphics_lib_noEx.tex(,140) ideal J = xy,y,x2;
graphics_lib_noEx.tex(,141) mplot("",J,"-2,1","1,2");
graphics_lib_noEx.tex(,142) // Paste the output into a Mathematica notebook
graphics_lib_noEx.tex(,143) // active evalutation of the cell with SHIFT RETURN
graphics_lib_noEx.tex(,144) kill rr0,rr1;
graphics_lib_noEx.tex(,145) @end smallexample
graphics_lib_noEx.tex(,146) @c ---end content mplot---
singular.texi(,588) @c ---------------------------------------------------------
singular.texi(,589) @node latex_lib, paramet_lib, graphics_lib, Visualization
singular.texi(,590) @subsection latex_lib
singular.texi(,591) @c include of docu for latex.lib
latex_lib.tex(,1) @c ---content LibInfo---
latex_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/latex_lib.doc
latex_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/latex_lib.doc INSTEAD
latex_lib.tex(,4) @c library version: (1.19.2.1,2002/02/20)
latex_lib.tex(,5) @c library file: ../Singular/LIB/latex.lib
latex_lib.tex(,6) @cindex latex.lib
latex_lib.tex(,7) @cindex latex_lib
latex_lib.tex(,8) @table @asis
latex_lib.tex(,9) @item @strong{Library:}
latex_lib.tex(,10) latex.lib
latex_lib.tex(,11) @item @strong{Purpose:}
latex_lib.tex(,12)     Typesetting of Singular-Objects in LaTeX2e
latex_lib.tex(,13) @item @strong{Author:}
latex_lib.tex(,14) Christian Gorzel, gorzelc@@math.uni-muenster.de
latex_lib.tex(,15) 
latex_lib.tex(,16) @end table
latex_lib.tex(,17) 
latex_lib.tex(,18) @strong{Procedures:}
latex_lib.tex(,19) @menu
latex_lib.tex(,20) * closetex:: writes closing line for LaTeX-document
latex_lib.tex(,21) * opentex:: writes header for LaTeX-file fnm
latex_lib.tex(,22) * tex:: calls LaTeX2e for LaTeX-file fnm
latex_lib.tex(,23) * texdemo:: produces a file explaining the features of this lib
latex_lib.tex(,24) * texfactorize:: creates string in LaTeX-format for factors of poly f
latex_lib.tex(,25) * texmap:: creates string in LaTeX-format for map m:r1->r2
latex_lib.tex(,26) * texname:: creates string in LaTeX-format for identifier
latex_lib.tex(,27) * texobj:: creates string in LaTeX-format for any (basic) type
latex_lib.tex(,28) * texpoly:: creates string in LaTeX-format for poly
latex_lib.tex(,29) * texproc:: creates string in LaTeX-format of text from proc p
latex_lib.tex(,30) * texring:: creates string in LaTeX-format for ring/qring
latex_lib.tex(,31) * rmx:: removes .aux and .log files of LaTeX-files
latex_lib.tex(,32) * xdvi:: calls xdvi for dvi-files
latex_lib.tex(,33) @end menu
latex_lib.tex(,34) @table @asis
latex_lib.tex(,35) @item @strong{Global variables:}
latex_lib.tex(,36) TeXwidth, TeXnofrac, TeXbrack, TeXproj, TeXaligned, TeXreplace, NoDollars
latex_lib.tex(,37) are used to control the typesetting.
latex_lib.tex(,38) Call @code{texdemo();} to obtain a LaTeX2e file @code{texlibdemo.tex}
latex_lib.tex(,39) explaining the features of @code{latex.lib} and its global variables.
latex_lib.tex(,40) @format
latex_lib.tex(,41)   @code{TeXwidth} (int) -1, 0, 1..9, >9:  controls breaking of long polynomials
latex_lib.tex(,42)   @code{TeXnofrac} (int) flag:  write 1/2 instead of \frac@{1@}@{2@}
latex_lib.tex(,43)   @code{TeXbrack} (string) "@{", "(", "<", "|", empty string: 
latex_lib.tex(,44)                                    controls brackets around ideals and matrices
latex_lib.tex(,45)   @code{TeXproj} (int) flag:  write ":" instead of "," in vectors
latex_lib.tex(,46)   @code{TeXaligned} (int) flag:  write maps (and ideals) aligned
latex_lib.tex(,47)   @code{TeXreplace} (list) list entries = 2 strings:  replacing symbols
latex_lib.tex(,48)   @code{NoDollars} (int) flag:  suppresses surrounding $ signs
latex_lib.tex(,49) @end format
latex_lib.tex(,50) 
latex_lib.tex(,51) @end table
latex_lib.tex(,52) @c ---end content LibInfo---
latex_lib.tex(,53) 
latex_lib.tex(,54) @c ------------------- closetex -------------
latex_lib.tex(,55) @node closetex, opentex,, latex_lib
latex_lib.tex(,56) @subsubsection closetex
latex_lib.tex(,57) @cindex closetex
latex_lib.tex(,58) @c ---content closetex---
latex_lib.tex(,59) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,60) 
latex_lib.tex(,61) @table @asis
latex_lib.tex(,62) @item @strong{Usage:}
latex_lib.tex(,63) closetex(fname); fname string
latex_lib.tex(,64) 
latex_lib.tex(,65) @item @strong{Return:}
latex_lib.tex(,66) nothing; writes a LaTeX2e closing line into file @code{<fname>}.
latex_lib.tex(,67) 
latex_lib.tex(,68) @item @strong{Note:}
latex_lib.tex(,69) preceding ">>" are deleted and suffix ".tex" (if not given)
latex_lib.tex(,70) is added to @code{fname}.
latex_lib.tex(,71) 
latex_lib.tex(,72) @end table
latex_lib.tex(,73) @strong{Example:}
latex_lib.tex(,74) @smallexample
latex_lib.tex(,75) @c computed example closetex d2t_singular/latex_lib.doc:73 
latex_lib.tex(,76) LIB "latex.lib";
latex_lib.tex(,77) opentex("exmpl");
latex_lib.tex(,78) texobj("exmpl","@{\\large \\bf hello@}");
latex_lib.tex(,79) closetex("exmpl");
latex_lib.tex(,80) @c end example closetex d2t_singular/latex_lib.doc:73
latex_lib.tex(,81) @end smallexample
latex_lib.tex(,82) @c ---end content closetex---
latex_lib.tex(,83) 
latex_lib.tex(,84) @c ------------------- opentex -------------
latex_lib.tex(,85) @node opentex, tex, closetex, latex_lib
latex_lib.tex(,86) @subsubsection opentex
latex_lib.tex(,87) @cindex opentex
latex_lib.tex(,88) @c ---content opentex---
latex_lib.tex(,89) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,90) 
latex_lib.tex(,91) @table @asis
latex_lib.tex(,92) @item @strong{Usage:}
latex_lib.tex(,93) opentex(fname); fname string
latex_lib.tex(,94) 
latex_lib.tex(,95) @item @strong{Return:}
latex_lib.tex(,96) nothing; writes a LaTeX2e header into a new file @code{<fname>}.
latex_lib.tex(,97) 
latex_lib.tex(,98) @item @strong{Note:}
latex_lib.tex(,99) preceding ">>" are deleted and suffix ".tex" (if not given)
latex_lib.tex(,100) is added to @code{fname}.
latex_lib.tex(,101) 
latex_lib.tex(,102) @end table
latex_lib.tex(,103) @strong{Example:}
latex_lib.tex(,104) @smallexample
latex_lib.tex(,105) @c computed example opentex d2t_singular/latex_lib.doc:103 
latex_lib.tex(,106) LIB "latex.lib";
latex_lib.tex(,107) opentex("exmpl");
latex_lib.tex(,108) texobj("exmpl","hello");
latex_lib.tex(,109) closetex("exmpl");
latex_lib.tex(,110) @c end example opentex d2t_singular/latex_lib.doc:103
latex_lib.tex(,111) @end smallexample
latex_lib.tex(,112) @c ---end content opentex---
latex_lib.tex(,113) 
latex_lib.tex(,114) @c ------------------- tex -------------
latex_lib.tex(,115) @node tex, texdemo, opentex, latex_lib
latex_lib.tex(,116) @subsubsection tex
latex_lib.tex(,117) @cindex tex
latex_lib.tex(,118) @c ---content tex---
latex_lib.tex(,119) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,120) 
latex_lib.tex(,121) @table @asis
latex_lib.tex(,122) @item @strong{Usage:}
latex_lib.tex(,123) tex(fname); fname string
latex_lib.tex(,124) 
latex_lib.tex(,125) @item @strong{Return:}
latex_lib.tex(,126) nothing; calls latex (LaTeX2e) for compiling the file fname
latex_lib.tex(,127) 
latex_lib.tex(,128) @item @strong{Note:}
latex_lib.tex(,129) preceding ">>" are deleted and suffix ".tex" (if not given)
latex_lib.tex(,130) is added to @code{fname}.
latex_lib.tex(,131) 
latex_lib.tex(,132) @end table
latex_lib.tex(,133) @strong{Example:}
latex_lib.tex(,134) @smallexample
latex_lib.tex(,135) @c computed example tex d2t_singular/latex_lib.doc:133 
latex_lib.tex(,136) LIB "latex.lib";
latex_lib.tex(,137) ring r;
latex_lib.tex(,138) ideal I = maxideal(7);
latex_lib.tex(,139) opentex("exp001");              // open latex2e document
latex_lib.tex(,140) texobj("exp001","An ideal ",I);
latex_lib.tex(,141) closetex("exp001");
latex_lib.tex(,142) tex("exp001"); 
latex_lib.tex(,143) @expansion{} calling  latex2e  for : exp001.tex 
latex_lib.tex(,144) @expansion{} 
latex_lib.tex(,145) @expansion{} This is TeX, Version 3.14159 (Web2C 7.3.1)
latex_lib.tex(,146) @expansion{} (exp001.tex
latex_lib.tex(,147) @expansion{} LaTeX2e <1998/12/01> patch level 1
latex_lib.tex(,148) @expansion{} Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
latex_lib.tex(,149)    man, i
latex_lib.tex(,150) @expansion{} talian, nohyphenation, loaded.
latex_lib.tex(,151) @expansion{} (/usr/share/texmf/tex/latex/base/article.cls
latex_lib.tex(,152) @expansion{} Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
latex_lib.tex(,153) @expansion{} (/usr/share/texmf/tex/latex/base/size10.clo))
latex_lib.tex(,154) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
latex_lib.tex(,155) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amstext.sty
latex_lib.tex(,156) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
latex_lib.tex(,157) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
latex_lib.tex(,158) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
latex_lib.tex(,159) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
latex_lib.tex(,160) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
latex_lib.tex(,161) @expansion{} No file exp001.aux.
latex_lib.tex(,162) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
latex_lib.tex(,163) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
latex_lib.tex(,164) @expansion{} Output written on exp001.dvi (1 page, 2912 bytes).
latex_lib.tex(,165) @expansion{} Transcript written on exp001.log.
latex_lib.tex(,166) system("sh","rm exp001.*");
latex_lib.tex(,167) @expansion{} 0
latex_lib.tex(,168) @c end example tex d2t_singular/latex_lib.doc:133
latex_lib.tex(,169) @end smallexample
latex_lib.tex(,170) @c ---end content tex---
latex_lib.tex(,171) 
latex_lib.tex(,172) @c ------------------- texdemo -------------
latex_lib.tex(,173) @node texdemo, texfactorize, tex, latex_lib
latex_lib.tex(,174) @subsubsection texdemo
latex_lib.tex(,175) @cindex texdemo
latex_lib.tex(,176) @c ---content texdemo---
latex_lib.tex(,177) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,178) 
latex_lib.tex(,179) @table @asis
latex_lib.tex(,180) @item @strong{Usage:}
latex_lib.tex(,181) texdemo();
latex_lib.tex(,182) 
latex_lib.tex(,183) @item @strong{Return:}
latex_lib.tex(,184) nothing; generates a LaTeX2e file called @code{texlibdemo.tex}
latex_lib.tex(,185) explaining the features of @code{latex.lib} and its global variables.
latex_lib.tex(,186) 
latex_lib.tex(,187) @item @strong{Note:}
latex_lib.tex(,188) this proc may take some time.
latex_lib.tex(,189) 
latex_lib.tex(,190) @end table
latex_lib.tex(,191) @c ---end content texdemo---
latex_lib.tex(,192) 
latex_lib.tex(,193) @c ------------------- texfactorize -------------
latex_lib.tex(,194) @node texfactorize, texmap, texdemo, latex_lib
latex_lib.tex(,195) @subsubsection texfactorize
latex_lib.tex(,196) @cindex texfactorize
latex_lib.tex(,197) @c ---content texfactorize---
latex_lib.tex(,198) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,199) 
latex_lib.tex(,200) @table @asis
latex_lib.tex(,201) @item @strong{Usage:}
latex_lib.tex(,202) texfactorize(fname,f); fname string, f poly
latex_lib.tex(,203) 
latex_lib.tex(,204) @item @strong{Return:}
latex_lib.tex(,205) if @code{fname=""}: string, f as a product of its irreducible
latex_lib.tex(,206) factors@*
latex_lib.tex(,207) otherwise: append this string to the file @code{<fname>}, and
latex_lib.tex(,208) return nothing.
latex_lib.tex(,209) 
latex_lib.tex(,210) @item @strong{Note:}
latex_lib.tex(,211) preceding ">>" are deleted and suffix ".tex" (if not given)
latex_lib.tex(,212) is added to @code{fname}.
latex_lib.tex(,213) 
latex_lib.tex(,214) @end table
latex_lib.tex(,215) @strong{Example:}
latex_lib.tex(,216) @smallexample
latex_lib.tex(,217) @c computed example texfactorize d2t_singular/latex_lib.doc:191 
latex_lib.tex(,218) LIB "latex.lib";
latex_lib.tex(,219) ring r2 = 13,(x,y),dp;
latex_lib.tex(,220) poly f = (x+1+y)^2*x3y*(2x-2y)*y12;
latex_lib.tex(,221) texfactorize("",f);
latex_lib.tex(,222) @expansion{} $-2\cdot x^@{3@}\cdot y^@{13@}\cdot (-x+y)\cdot (x+y+1)^@{2@}$
latex_lib.tex(,223) ring R49 = (7,a),x,dp;
latex_lib.tex(,224) minpoly = a2+a+3;
latex_lib.tex(,225) poly f = (a24x5+x3)*a2x6*(x+1)^2;
latex_lib.tex(,226) f;
latex_lib.tex(,227) @expansion{} (a+3)*x13+(2a-1)*x12+(-2a+1)*x10+(-a-3)*x9
latex_lib.tex(,228) texfactorize("",f);
latex_lib.tex(,229) @expansion{} $(a+3)\cdot (x-1)\cdot (x+1)^@{3@}\cdot x^@{9@}$
latex_lib.tex(,230) @c end example texfactorize d2t_singular/latex_lib.doc:191
latex_lib.tex(,231) @end smallexample
latex_lib.tex(,232) @c ---end content texfactorize---
latex_lib.tex(,233) 
latex_lib.tex(,234) @c ------------------- texmap -------------
latex_lib.tex(,235) @node texmap, texname, texfactorize, latex_lib
latex_lib.tex(,236) @subsubsection texmap
latex_lib.tex(,237) @cindex texmap
latex_lib.tex(,238) @c ---content texmap---
latex_lib.tex(,239) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,240) 
latex_lib.tex(,241) @table @asis
latex_lib.tex(,242) @item @strong{Usage:}
latex_lib.tex(,243) texmap(fname,m,@@r1,@@r2); fname string, m string/map, @@r1,@@r2 rings
latex_lib.tex(,244) 
latex_lib.tex(,245) @item @strong{Return:}
latex_lib.tex(,246) if @code{fname=""}: string, the map m from @@r1 to @@r2 (preceded
latex_lib.tex(,247) by its name if m = string) in TeX-typesetting;@*
latex_lib.tex(,248) otherwise: append this string to the file @code{<fname>}, and
latex_lib.tex(,249) return nothing.
latex_lib.tex(,250) 
latex_lib.tex(,251) @item @strong{Note:}
latex_lib.tex(,252) preceding ">>" are deleted in @code{fname}, and suffix ".tex"
latex_lib.tex(,253) (if not given) is added to @code{fname}.
latex_lib.tex(,254) If m is a string then it has to be the name of an existing map
latex_lib.tex(,255) from @@r1 to @@r2.
latex_lib.tex(,256) 
latex_lib.tex(,257) @end table
latex_lib.tex(,258) @strong{Example:}
latex_lib.tex(,259) @smallexample
latex_lib.tex(,260) @c computed example texmap d2t_singular/latex_lib.doc:231 
latex_lib.tex(,261) LIB "latex.lib";
latex_lib.tex(,262) // -------- prepare for example ---------
latex_lib.tex(,263) if (defined(TeXaligned)) @{int Teali=TeXaligned; kill TeXaligned;@}
latex_lib.tex(,264) if (defined(TeXreplace)) @{list Terep=TeXreplace; kill TeXreplace;@}
latex_lib.tex(,265) // -------- the example starts here ---------
latex_lib.tex(,266) //
latex_lib.tex(,267) string fname = "tldemo";
latex_lib.tex(,268) ring @@r1=0,(x,y,z),dp;
latex_lib.tex(,269) if(system("with","Namespaces")) @{ exportto(Current, @@r1); @}
latex_lib.tex(,270) else @{ export @@r1; @}
latex_lib.tex(,271) @expansion{} // ** `@@r1` is already global
latex_lib.tex(,272) ring r2=0,(u,v),dp;
latex_lib.tex(,273) map @@phi =(@@r1,u2,uv -v,v2); export @@phi;
latex_lib.tex(,274) @expansion{} // ** `@@phi` is already global
latex_lib.tex(,275) list TeXreplace;
latex_lib.tex(,276) TeXreplace[1] = list("@@phi","\\phi");    // @@phi --> \phi
latex_lib.tex(,277) export TeXreplace;
latex_lib.tex(,278) @expansion{} // ** `TeXreplace` is already global
latex_lib.tex(,279) texmap("","@@phi",@@r1,r2);                // standard form
latex_lib.tex(,280) @expansion{} $$
latex_lib.tex(,281) @expansion{} \begin@{array@}@{rcc@}
latex_lib.tex(,282) @expansion{} \phi:\Q[x,y,z] & \longrightarrow & \Q[u,v]\\[2mm]
latex_lib.tex(,283) @expansion{} \left(x,y,z\right) & \longmapsto & 
latex_lib.tex(,284) @expansion{}  \left(
latex_lib.tex(,285) @expansion{} \begin@{array@}@{c@}
latex_lib.tex(,286) @expansion{} u^@{2@}\\
latex_lib.tex(,287) @expansion{} uv-v\\
latex_lib.tex(,288) @expansion{} v^@{2@}
latex_lib.tex(,289) @expansion{} \end@{array@}
latex_lib.tex(,290) @expansion{} \right)
latex_lib.tex(,291) @expansion{} \end@{array@}
latex_lib.tex(,292) @expansion{} $$
latex_lib.tex(,293) //
latex_lib.tex(,294) int TeXaligned; export TeXaligned;       // map in one line
latex_lib.tex(,295) @expansion{} // ** `TeXaligned` is already global
latex_lib.tex(,296) texmap("",@@phi,@@r1,r2);
latex_lib.tex(,297) @expansion{} $\Q[x,y,z]\longrightarrow\Q[u,v], \ \left(x,y,z\right)\longmapsto \left(u\
latex_lib.tex(,298)    ^@{2@},uv-v,v^@{2@}\right)$
latex_lib.tex(,299) //
latex_lib.tex(,300) kill @@r1,TeXreplace,TeXaligned;
latex_lib.tex(,301) //
latex_lib.tex(,302) // --- restore global variables if previously defined ---
latex_lib.tex(,303) if (defined(Teali)) @{int TeXaligned=Teali; export TeXaligned; kill Teali;@}
latex_lib.tex(,304) if (defined(Terep)) @{list TeXreplace=Terep; export TeXreplace; kill Terep;@}
latex_lib.tex(,305) @c end example texmap d2t_singular/latex_lib.doc:231
latex_lib.tex(,306) @end smallexample
latex_lib.tex(,307) @c ---end content texmap---
latex_lib.tex(,308) 
latex_lib.tex(,309) @c ------------------- texname -------------
latex_lib.tex(,310) @node texname, texobj, texmap, latex_lib
latex_lib.tex(,311) @subsubsection texname
latex_lib.tex(,312) @cindex texname
latex_lib.tex(,313) @c ---content texname---
latex_lib.tex(,314) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,315) 
latex_lib.tex(,316) @table @asis
latex_lib.tex(,317) @item @strong{Usage:}
latex_lib.tex(,318) texname(fname,s); fname,s strings
latex_lib.tex(,319) 
latex_lib.tex(,320) @item @strong{Return:}
latex_lib.tex(,321) if @code{fname=""}: string, the transformed string s, where the
latex_lib.tex(,322) following rules apply:
latex_lib.tex(,323) @smallexample
latex_lib.tex(,324)       s' + "~"             -->  "\\tilde@{"+ s' +"@}"
latex_lib.tex(,325)      "_" + int             -->       "_@{" + int +"@}" 
latex_lib.tex(,326)   "[" + s' + "]"           -->      "_@{" + s' + "@}"
latex_lib.tex(,327)    "A..Z" + int            --> "A..Z" + "^@{" + int + "@}"    
latex_lib.tex(,328)    "a..z" + int            --> "a..z" + "_@{" + int + "@}"
latex_lib.tex(,329) "(" + int + "," + s' + ")" --> "_@{"+ int +"@}" + "^@{" + s'+"@}"
latex_lib.tex(,330) @end smallexample
latex_lib.tex(,331) Anyhow, strings which begin with a @code{"@{"} are only changed
latex_lib.tex(,332) by deleting the first and last character (intended to remove the
latex_lib.tex(,333) surrounding curly brackets).
latex_lib.tex(,334) 
latex_lib.tex(,335) if @code{fname!=""}: append the transformed string s to the file
latex_lib.tex(,336) @code{<fname>}, and return nothing.
latex_lib.tex(,337) 
latex_lib.tex(,338) @item @strong{Note:}
latex_lib.tex(,339) preceding ">>" are deleted in @code{fname}, and suffix ".tex"
latex_lib.tex(,340) (if not given) is added to @code{fname}.
latex_lib.tex(,341) 
latex_lib.tex(,342) @end table
latex_lib.tex(,343) @strong{Example:}
latex_lib.tex(,344) @smallexample
latex_lib.tex(,345) @c computed example texname d2t_singular/latex_lib.doc:297 
latex_lib.tex(,346) LIB "latex.lib";
latex_lib.tex(,347) ring r = 0,(x,y),lp;
latex_lib.tex(,348) poly f = 3xy4 + 2xy2 + x5y3 + x + y6;
latex_lib.tex(,349) texname("","@{f(10)@}");
latex_lib.tex(,350) @expansion{} f(10)
latex_lib.tex(,351) texname("","f(10) =");
latex_lib.tex(,352) @expansion{} f_@{10@} =
latex_lib.tex(,353) texname("","n1");
latex_lib.tex(,354) @expansion{} n_@{1@}
latex_lib.tex(,355) texname("","T1_12");
latex_lib.tex(,356) @expansion{} T^@{1@}_@{12@}
latex_lib.tex(,357) texname("","g'_11");
latex_lib.tex(,358) @expansion{} g'_@{11@}
latex_lib.tex(,359) texname("","f23");
latex_lib.tex(,360) @expansion{} f_@{23@}
latex_lib.tex(,361) texname("","M[2,3]");
latex_lib.tex(,362) @expansion{} M_@{2,3@}
latex_lib.tex(,363) texname("","A(0,3);");
latex_lib.tex(,364) @expansion{} A_@{0@}^@{3@};
latex_lib.tex(,365) texname("","E~(3)");
latex_lib.tex(,366) @expansion{} \tilde@{E@}_@{3@}
latex_lib.tex(,367) @c end example texname d2t_singular/latex_lib.doc:297
latex_lib.tex(,368) @end smallexample
latex_lib.tex(,369) @c ---end content texname---
latex_lib.tex(,370) 
latex_lib.tex(,371) @c ------------------- texobj -------------
latex_lib.tex(,372) @node texobj, texpoly, texname, latex_lib
latex_lib.tex(,373) @subsubsection texobj
latex_lib.tex(,374) @cindex texobj
latex_lib.tex(,375) @c ---content texobj---
latex_lib.tex(,376) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,377) 
latex_lib.tex(,378) @table @asis
latex_lib.tex(,379) @item @strong{Usage:}
latex_lib.tex(,380) texobj(fname,l); fname string, l list
latex_lib.tex(,381) 
latex_lib.tex(,382) @item @strong{Return:}
latex_lib.tex(,383) if @code{fname=""}: string, the entries of l in LaTeX-typesetting;@*
latex_lib.tex(,384) otherwise: append this string to the file @code{<fname>}, and
latex_lib.tex(,385) return nothing.
latex_lib.tex(,386) 
latex_lib.tex(,387) @item @strong{Note:}
latex_lib.tex(,388) preceding ">>" are deleted in @code{fname}, and suffix ".tex"
latex_lib.tex(,389) (if not given) is added to @code{fname}.
latex_lib.tex(,390) 
latex_lib.tex(,391) @end table
latex_lib.tex(,392) @strong{Example:}
latex_lib.tex(,393) @smallexample
latex_lib.tex(,394) @c computed example texobj d2t_singular/latex_lib.doc:337 
latex_lib.tex(,395) LIB "latex.lib";
latex_lib.tex(,396) // -------- prepare for example ---------
latex_lib.tex(,397) if (defined(TeXaligned)) @{int Teali=TeXaligned; kill TeXaligned;@}
latex_lib.tex(,398) if (defined(TeXbrack))@{string Tebra=TeXbrack; kill TeXbrack;@}
latex_lib.tex(,399) //
latex_lib.tex(,400) //  --------------  typesetting for polynomials ----------
latex_lib.tex(,401) ring r = 0,(x,y),lp;
latex_lib.tex(,402) poly f = x5y3 + 3xy4 + 2xy2 + y6;
latex_lib.tex(,403) f;
latex_lib.tex(,404) @expansion{} x5y3+3xy4+2xy2+y6
latex_lib.tex(,405) texobj("",f);
latex_lib.tex(,406) @expansion{} $$\begin@{array@}@{rl@}
latex_lib.tex(,407) @expansion{} & x^@{5@}y^@{3@}+3xy^@{4@}+2xy^@{2@}+y^@{6@}\\
latex_lib.tex(,408) @expansion{} \end@{array@}
latex_lib.tex(,409) @expansion{} $$
latex_lib.tex(,410) @expansion{} 
latex_lib.tex(,411) //  --------------  typesetting for ideals ----------
latex_lib.tex(,412) ideal G = jacob(f);
latex_lib.tex(,413) G;
latex_lib.tex(,414) @expansion{} G[1]=5x4y3+3y4+2y2
latex_lib.tex(,415) @expansion{} G[2]=3x5y2+12xy3+4xy+6y5
latex_lib.tex(,416) texobj("",G);
latex_lib.tex(,417) @expansion{} $$\left(
latex_lib.tex(,418) @expansion{} \begin@{array@}@{c@}
latex_lib.tex(,419) @expansion{} 5x^@{4@}y^@{3@}+3y^@{4@}+2y^@{2@}, \\
latex_lib.tex(,420) @expansion{} 3x^@{5@}y^@{2@}+12xy^@{3@}+4xy+6y^@{5@}
latex_lib.tex(,421) @expansion{} \end@{array@}
latex_lib.tex(,422) @expansion{} \right)$$
latex_lib.tex(,423) @expansion{} 
latex_lib.tex(,424) //  --------------  variation of typesetting for ideals ----------
latex_lib.tex(,425) int TeXaligned = 1; export TeXaligned;
latex_lib.tex(,426) @expansion{} // ** `TeXaligned` is already global
latex_lib.tex(,427) string TeXbrack = "<"; export TeXbrack;
latex_lib.tex(,428) @expansion{} // ** `TeXbrack` is already global
latex_lib.tex(,429) texobj("",G);
latex_lib.tex(,430) @expansion{} $\left<5x^@{4@}y^@{3@}+3y^@{4@}+2y^@{2@},3x^@{5@}y^@{2@}+12xy^@{3@}+4xy+6y^@{5@}\right>$
latex_lib.tex(,431) @expansion{} 
latex_lib.tex(,432) kill TeXaligned, TeXbrack;
latex_lib.tex(,433) //  --------------  typesetting for matrices ----------
latex_lib.tex(,434) matrix J = jacob(G);
latex_lib.tex(,435) texobj("",J);
latex_lib.tex(,436) @expansion{} $$\left(
latex_lib.tex(,437) @expansion{} \begin@{array@}@{*@{2@}@{c@}@}
latex_lib.tex(,438) @expansion{} 20x^@{3@}y^@{3@} & 15x^@{4@}y^@{2@}+12y^@{3@}+4y \\
latex_lib.tex(,439) @expansion{} 15x^@{4@}y^@{2@}+12y^@{3@}+4y & 6x^@{5@}y+36xy^@{2@}+4x+30y^@{4@}
latex_lib.tex(,440) @expansion{} \end@{array@}
latex_lib.tex(,441) @expansion{} \right)
latex_lib.tex(,442) @expansion{} $$
latex_lib.tex(,443) @expansion{} 
latex_lib.tex(,444) //  --------------  typesetting for intmats ----------
latex_lib.tex(,445) intmat m[3][4] = 9,2,4,5,2,5,-2,4,-6,10,-1,2,7;
latex_lib.tex(,446) texobj("",m);
latex_lib.tex(,447) @expansion{} $$\left(
latex_lib.tex(,448) @expansion{} \begin@{array@}@{*@{4@}@{r@}@}
latex_lib.tex(,449) @expansion{} 9 & 2 & 4 & 5\\
latex_lib.tex(,450) @expansion{} 2 & 5 & -2 & 4\\
latex_lib.tex(,451) @expansion{} -6 & 10 & -1 & 2
latex_lib.tex(,452) @expansion{} \end@{array@}
latex_lib.tex(,453) @expansion{} \right)
latex_lib.tex(,454) @expansion{} $$
latex_lib.tex(,455) @expansion{} 
latex_lib.tex(,456) //
latex_lib.tex(,457) // --- restore global variables if previously defined ---
latex_lib.tex(,458) if (defined(Teali))@{int TeXaligned=Teali; export TeXaligned; kill Teali;@}
latex_lib.tex(,459) if (defined(Tebra))@{string TeXbrack=Tebra; export TeXbrack; kill Tebra;@}
latex_lib.tex(,460) @c end example texobj d2t_singular/latex_lib.doc:337
latex_lib.tex(,461) @end smallexample
latex_lib.tex(,462) @c ---end content texobj---
latex_lib.tex(,463) 
latex_lib.tex(,464) @c ------------------- texpoly -------------
latex_lib.tex(,465) @node texpoly, texproc, texobj, latex_lib
latex_lib.tex(,466) @subsubsection texpoly
latex_lib.tex(,467) @cindex texpoly
latex_lib.tex(,468) @c ---content texpoly---
latex_lib.tex(,469) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,470) 
latex_lib.tex(,471) @table @asis
latex_lib.tex(,472) @item @strong{Usage:}
latex_lib.tex(,473) texpoly(fname,p); fname string, p poly
latex_lib.tex(,474) 
latex_lib.tex(,475) @item @strong{Return:}
latex_lib.tex(,476) if @code{fname=""}: string, the poly p in LaTeX-typesetting;@*
latex_lib.tex(,477) otherwise: append this string to the file @code{<fname>}, and
latex_lib.tex(,478) return nothing.
latex_lib.tex(,479) 
latex_lib.tex(,480) @item @strong{Note:}
latex_lib.tex(,481) preceding ">>" are deleted in @code{fname}, and suffix ".tex"
latex_lib.tex(,482) (if not given) is added to @code{fname}.
latex_lib.tex(,483) 
latex_lib.tex(,484) @end table
latex_lib.tex(,485) @strong{Example:}
latex_lib.tex(,486) @smallexample
latex_lib.tex(,487) @c computed example texpoly d2t_singular/latex_lib.doc:394 
latex_lib.tex(,488) LIB "latex.lib";
latex_lib.tex(,489) ring r0=0,(x,y,z),dp;
latex_lib.tex(,490) poly f = -1x^2 + 2;
latex_lib.tex(,491) texpoly("",f);
latex_lib.tex(,492) @expansion{} $-x^@{2@}+2$
latex_lib.tex(,493) ring rr= real,(x,y,z),dp;
latex_lib.tex(,494) texpoly("",2x2y23z);
latex_lib.tex(,495) @expansion{} $2.000x^@{2@}y^@{23@}z$
latex_lib.tex(,496) ring r7= 7,(x,y,z),dp;
latex_lib.tex(,497) poly f = 2x2y23z;
latex_lib.tex(,498) texpoly("",f);
latex_lib.tex(,499) @expansion{} $2x^@{2@}y^@{23@}z$
latex_lib.tex(,500) ring rab =(0,a,b),(x,y,z),dp;
latex_lib.tex(,501) poly f = (-2a2 +b3 -2)/a * x2y4z5 + (a2+1)*x + a+1;
latex_lib.tex(,502) f;
latex_lib.tex(,503) @expansion{} (-2a2+b3-2)/(a)*x2y4z5+(a2+1)*x+(a+1)
latex_lib.tex(,504) texpoly("",f);
latex_lib.tex(,505) @expansion{} $-\frac@{2a^@{2@}-b^@{3@}+2@}@{a@}x^@{2@}y^@{4@}z^@{5@}+(a^@{2@}+1)x+(a+1)$
latex_lib.tex(,506) @c end example texpoly d2t_singular/latex_lib.doc:394
latex_lib.tex(,507) @end smallexample
latex_lib.tex(,508) @c ---end content texpoly---
latex_lib.tex(,509) 
latex_lib.tex(,510) @c ------------------- texproc -------------
latex_lib.tex(,511) @node texproc, texring, texpoly, latex_lib
latex_lib.tex(,512) @subsubsection texproc
latex_lib.tex(,513) @cindex texproc
latex_lib.tex(,514) @c ---content texproc---
latex_lib.tex(,515) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,516) 
latex_lib.tex(,517) @table @asis
latex_lib.tex(,518) @item @strong{Usage:}
latex_lib.tex(,519) texproc(fname,pname); fname,pname strings
latex_lib.tex(,520) 
latex_lib.tex(,521) @item @strong{Assume:}
latex_lib.tex(,522) @code{`pname`} is a procedure.
latex_lib.tex(,523) 
latex_lib.tex(,524) @item @strong{Return:}
latex_lib.tex(,525) if @code{fname=""}: string, the proc @code{`pname`} in a verbatim
latex_lib.tex(,526) environment in LaTeX-typesetting;@*
latex_lib.tex(,527) otherwise: append this string to the file @code{<fname>}, and
latex_lib.tex(,528) return nothing.
latex_lib.tex(,529) 
latex_lib.tex(,530) @item @strong{Note:}
latex_lib.tex(,531) preceding ">>" are deleted in @code{fname}, and suffix ".tex"
latex_lib.tex(,532) (if not given) is added to @code{fname}.@*
latex_lib.tex(,533) @code{texproc} cannot be applied to itself correctly.
latex_lib.tex(,534) 
latex_lib.tex(,535) @end table
latex_lib.tex(,536) @strong{Example:}
latex_lib.tex(,537) @smallexample
latex_lib.tex(,538) @c computed example texproc d2t_singular/latex_lib.doc:440 
latex_lib.tex(,539) LIB "latex.lib";
latex_lib.tex(,540) proc exp(int i,int j,list #)
latex_lib.tex(,541) @{ string s;
latex_lib.tex(,542) if (size(#))
latex_lib.tex(,543) @{
latex_lib.tex(,544) for(i;i<=j;i++)
latex_lib.tex(,545) @{ s = s + string(j) + string(#); @}
latex_lib.tex(,546) @}
latex_lib.tex(,547) return(s);
latex_lib.tex(,548) @}
latex_lib.tex(,549) export exp;
latex_lib.tex(,550) @expansion{} // ** `exp` is already global
latex_lib.tex(,551) texproc("","exp");
latex_lib.tex(,552) @expansion{} \begin@{verbatim@}
latex_lib.tex(,553) @expansion{} proc exp(int i,int j,list #)
latex_lib.tex(,554) @expansion{} @{ 
latex_lib.tex(,555) @expansion{}  string s;
latex_lib.tex(,556) @expansion{} if (size(#))
latex_lib.tex(,557) @expansion{} @{
latex_lib.tex(,558) @expansion{} for(i;i<=j;i++)
latex_lib.tex(,559) @expansion{} @{ s = s + string(j) + string(#); @}
latex_lib.tex(,560) @expansion{} @}
latex_lib.tex(,561) @expansion{} return(s);
latex_lib.tex(,562) @expansion{} 
latex_lib.tex(,563) @expansion{} @}
latex_lib.tex(,564) @expansion{} \end@{verbatim@}
latex_lib.tex(,565) @expansion{} 
latex_lib.tex(,566) kill exp;
latex_lib.tex(,567) @c end example texproc d2t_singular/latex_lib.doc:440
latex_lib.tex(,568) @end smallexample
latex_lib.tex(,569) @c ---end content texproc---
latex_lib.tex(,570) 
latex_lib.tex(,571) @c ------------------- texring -------------
latex_lib.tex(,572) @node texring, rmx, texproc, latex_lib
latex_lib.tex(,573) @subsubsection texring
latex_lib.tex(,574) @cindex texring
latex_lib.tex(,575) @c ---content texring---
latex_lib.tex(,576) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,577) 
latex_lib.tex(,578) @table @asis
latex_lib.tex(,579) @item @strong{Usage:}
latex_lib.tex(,580) texring(fname, r[,L]); fname string, r ring, L list
latex_lib.tex(,581) 
latex_lib.tex(,582) @item @strong{Return:}
latex_lib.tex(,583) if @code{fname=""}: string, the ring in TeX-typesetting;@*
latex_lib.tex(,584) otherwise: append this string to the file @code{<fname>} and
latex_lib.tex(,585) return nothing.
latex_lib.tex(,586) 
latex_lib.tex(,587) @item @strong{Note:}
latex_lib.tex(,588) preceding ">>" are deleted and suffix ".tex" (if not given)
latex_lib.tex(,589) is added to @code{fname}.@*
latex_lib.tex(,590) The optional list L is assumed to be a list of strings which control,
latex_lib.tex(,591) e.g., the symbol for the field of coefficients.@*
latex_lib.tex(,592) For more details call @code{texdemo();} (generates a LaTeX2e
latex_lib.tex(,593) file called @code{texlibdemo.tex} which explains all features of
latex_lib.tex(,594) @code{texring}).
latex_lib.tex(,595) 
latex_lib.tex(,596) @end table
latex_lib.tex(,597) @strong{Example:}
latex_lib.tex(,598) @smallexample
latex_lib.tex(,599) @c computed example texring d2t_singular/latex_lib.doc:486 
latex_lib.tex(,600) LIB "latex.lib";
latex_lib.tex(,601) ring r0 = 0,(x,y),dp;                // char = 0, polynomial ordering
latex_lib.tex(,602) texring("",r0);
latex_lib.tex(,603) @expansion{} $\Q[x,y]$
latex_lib.tex(,604) //
latex_lib.tex(,605) ring r7 =7,(x(0..2)),ds;             // char = 7, local ordering
latex_lib.tex(,606) texring("",r7);
latex_lib.tex(,607) @expansion{} $\Z_@{7@}[[x_@{0@},x_@{1@},x_@{2@}]]$
latex_lib.tex(,608) //
latex_lib.tex(,609) ring r1 = 0,(x1,x2,y1,y2),wp(1,2,3,4);
latex_lib.tex(,610) texring("",r1);
latex_lib.tex(,611) @expansion{} $\Q[x_@{1@},x_@{2@},y_@{1@},y_@{2@}]$
latex_lib.tex(,612) //
latex_lib.tex(,613) ring rr = real,(x),dp;               // real numbers
latex_lib.tex(,614) texring("",rr);
latex_lib.tex(,615) @expansion{} $\R[x]$
latex_lib.tex(,616) //
latex_lib.tex(,617) ring rabc =(0,t1,t2,t3),(x,y),dp;    // ring with parameters
latex_lib.tex(,618) texring("",rabc);
latex_lib.tex(,619) @expansion{} $\Q(t_@{1@},t_@{2@},t_@{3@})[x,y]$
latex_lib.tex(,620) //
latex_lib.tex(,621) ring ralg = (7,a),(x1,x2),ds;        // algebraic extension
latex_lib.tex(,622) minpoly = a2-a+3;
latex_lib.tex(,623) texring("",ralg);
latex_lib.tex(,624) @expansion{} $\Z_@{7@}(a)[[x_@{1@},x_@{2@}]]$
latex_lib.tex(,625) texring("",ralg,"mipo");
latex_lib.tex(,626) @expansion{} $\Z_@{7@}(a)/(a^@{2@}-a+3)[[x_@{1@},x_@{2@}]]$
latex_lib.tex(,627) //
latex_lib.tex(,628) ring r49=(49,a),x,dp;                // Galois field  
latex_lib.tex(,629) texring("",r49);
latex_lib.tex(,630) @expansion{} $\F_@{49@}[x]$
latex_lib.tex(,631) //
latex_lib.tex(,632) setring r0;                          // quotient ring
latex_lib.tex(,633) ideal i = x2-y3;
latex_lib.tex(,634) qring q = std(i);
latex_lib.tex(,635) texring("",q);
latex_lib.tex(,636) @expansion{} $\Q[x,y]/\left(y^@{3@}-x^@{2@}\right)
latex_lib.tex(,637) @expansion{} $
latex_lib.tex(,638) //
latex_lib.tex(,639) // ------------------ additional features -------------------
latex_lib.tex(,640) ring r9 =0,(x(0..9)),ds;
latex_lib.tex(,641) texring("",r9,1);
latex_lib.tex(,642) @expansion{} $\Q[[x_@{0@},\ldots,x_@{9@}]]$
latex_lib.tex(,643) texring("",r9,"C","@{","^G");
latex_lib.tex(,644) @expansion{} $\C\@{x_@{0@},x_@{1@},x_@{2@},x_@{3@},x_@{4@},x_@{5@},x_@{6@},x_@{7@},x_@{8@},x_@{9@}\@}^G$
latex_lib.tex(,645) //
latex_lib.tex(,646) ring rxy = 0,(x(1..5),y(1..6)),ds;
latex_lib.tex(,647) intvec v = 5,6;
latex_lib.tex(,648) texring("",rxy,v);
latex_lib.tex(,649) @expansion{} $\Q[[x_@{1@},\ldots,x_@{5@},y_@{1@},\ldots,y_@{6@}]]$
latex_lib.tex(,650) @c end example texring d2t_singular/latex_lib.doc:486
latex_lib.tex(,651) @end smallexample
latex_lib.tex(,652) @c ---end content texring---
latex_lib.tex(,653) 
latex_lib.tex(,654) @c ------------------- rmx -------------
latex_lib.tex(,655) @node rmx, xdvi, texring, latex_lib
latex_lib.tex(,656) @subsubsection rmx
latex_lib.tex(,657) @cindex rmx
latex_lib.tex(,658) @c ---content rmx---
latex_lib.tex(,659) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,660) 
latex_lib.tex(,661) @table @asis
latex_lib.tex(,662) @item @strong{Usage:}
latex_lib.tex(,663) rmx(fname); fname string
latex_lib.tex(,664) 
latex_lib.tex(,665) @item @strong{Return:}
latex_lib.tex(,666) nothing; removes the @code{.log} and @code{.aux} files associated to
latex_lib.tex(,667) the LaTeX file <fname>.@*
latex_lib.tex(,668) 
latex_lib.tex(,669) @item @strong{Note:}
latex_lib.tex(,670) If @code{fname} ends by @code{".dvi"} or @code{".tex"}, the
latex_lib.tex(,671) @code{.dvi} or @code{.tex} file will be deleted, too.
latex_lib.tex(,672) 
latex_lib.tex(,673) @end table
latex_lib.tex(,674) @strong{Example:}
latex_lib.tex(,675) @smallexample
latex_lib.tex(,676) @c computed example rmx d2t_singular/latex_lib.doc:550 
latex_lib.tex(,677) LIB "latex.lib";
latex_lib.tex(,678) ring r;
latex_lib.tex(,679) poly f = x+y+z;
latex_lib.tex(,680) opentex("exp001");              // defaulted latex2e document
latex_lib.tex(,681) texobj("exp001","A polynom",f);
latex_lib.tex(,682) closetex("exp001");
latex_lib.tex(,683) tex("exp001");
latex_lib.tex(,684) @expansion{} calling  latex2e  for : exp001.tex 
latex_lib.tex(,685) @expansion{} 
latex_lib.tex(,686) @expansion{} This is TeX, Version 3.14159 (Web2C 7.3.1)
latex_lib.tex(,687) @expansion{} (exp001.tex
latex_lib.tex(,688) @expansion{} LaTeX2e <1998/12/01> patch level 1
latex_lib.tex(,689) @expansion{} Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
latex_lib.tex(,690)    man, i
latex_lib.tex(,691) @expansion{} talian, nohyphenation, loaded.
latex_lib.tex(,692) @expansion{} (/usr/share/texmf/tex/latex/base/article.cls
latex_lib.tex(,693) @expansion{} Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
latex_lib.tex(,694) @expansion{} (/usr/share/texmf/tex/latex/base/size10.clo))
latex_lib.tex(,695) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
latex_lib.tex(,696) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amstext.sty
latex_lib.tex(,697) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
latex_lib.tex(,698) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
latex_lib.tex(,699) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
latex_lib.tex(,700) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
latex_lib.tex(,701) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
latex_lib.tex(,702) @expansion{} No file exp001.aux.
latex_lib.tex(,703) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
latex_lib.tex(,704) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
latex_lib.tex(,705) @expansion{} Output written on exp001.dvi (1 page, 308 bytes).
latex_lib.tex(,706) @expansion{} Transcript written on exp001.log.
latex_lib.tex(,707) rmx("exp001");   // removes aux and log file of exp001
latex_lib.tex(,708) system("sh","rm exp001.*");
latex_lib.tex(,709) @expansion{} 0
latex_lib.tex(,710) @c end example rmx d2t_singular/latex_lib.doc:550
latex_lib.tex(,711) @end smallexample
latex_lib.tex(,712) @c ---end content rmx---
latex_lib.tex(,713) 
latex_lib.tex(,714) @c ------------------- xdvi -------------
latex_lib.tex(,715) @node xdvi,, rmx, latex_lib
latex_lib.tex(,716) @subsubsection xdvi
latex_lib.tex(,717) @cindex xdvi
latex_lib.tex(,718) @c ---content xdvi---
latex_lib.tex(,719) Procedure from library @code{latex.lib} (@pxref{latex_lib}).
latex_lib.tex(,720) 
latex_lib.tex(,721) @table @asis
latex_lib.tex(,722) @item @strong{Usage:}
latex_lib.tex(,723) xdvi(fname[,style]); fname,style = string
latex_lib.tex(,724) 
latex_lib.tex(,725) @item @strong{Return:}
latex_lib.tex(,726) nothing; displays dvi-file fname.dvi with previewer xdvi
latex_lib.tex(,727) 
latex_lib.tex(,728) @item @strong{Note:}
latex_lib.tex(,729) ending .dvi may miss in fname
latex_lib.tex(,730) @*style overwrites the default setting xdvi
latex_lib.tex(,731) 
latex_lib.tex(,732) @end table
latex_lib.tex(,733) @strong{Example:}
latex_lib.tex(,734) @smallexample
latex_lib.tex(,735) @c computed example xdvi d2t_singular/latex_lib.doc:585 
latex_lib.tex(,736) LIB "latex.lib";
latex_lib.tex(,737) intmat m[3][4] = 9,2,4,5,2,5,-2,4,-6,10,-1,2,7;
latex_lib.tex(,738) opentex("exp001"); 
latex_lib.tex(,739) texobj("exp001","An intmat:  ",m);
latex_lib.tex(,740) closetex("exp001");
latex_lib.tex(,741) tex("exp001");
latex_lib.tex(,742) @expansion{} calling  latex2e  for : exp001.tex 
latex_lib.tex(,743) @expansion{} 
latex_lib.tex(,744) @expansion{} This is TeX, Version 3.14159 (Web2C 7.3.1)
latex_lib.tex(,745) @expansion{} (exp001.tex
latex_lib.tex(,746) @expansion{} LaTeX2e <1998/12/01> patch level 1
latex_lib.tex(,747) @expansion{} Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
latex_lib.tex(,748)    man, i
latex_lib.tex(,749) @expansion{} talian, nohyphenation, loaded.
latex_lib.tex(,750) @expansion{} (/usr/share/texmf/tex/latex/base/article.cls
latex_lib.tex(,751) @expansion{} Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
latex_lib.tex(,752) @expansion{} (/usr/share/texmf/tex/latex/base/size10.clo))
latex_lib.tex(,753) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
latex_lib.tex(,754) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amstext.sty
latex_lib.tex(,755) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
latex_lib.tex(,756) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
latex_lib.tex(,757) @expansion{} (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
latex_lib.tex(,758) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
latex_lib.tex(,759) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
latex_lib.tex(,760) @expansion{} No file exp001.aux.
latex_lib.tex(,761) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
latex_lib.tex(,762) @expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
latex_lib.tex(,763) @expansion{} Output written on exp001.dvi (1 page, 524 bytes).
latex_lib.tex(,764) @expansion{} Transcript written on exp001.log.
latex_lib.tex(,765) xdvi("exp001");
latex_lib.tex(,766) @expansion{} calling  xdvi  for : exp001 
latex_lib.tex(,767) @expansion{} 
latex_lib.tex(,768) system("sh","rm exp001.*");
latex_lib.tex(,769) @expansion{} 0
latex_lib.tex(,770) @c end example xdvi d2t_singular/latex_lib.doc:585
latex_lib.tex(,771) @end smallexample
latex_lib.tex(,772) @c ---end content xdvi---
singular.texi(,593) @c ---------------------------------------------------------
singular.texi(,594) @node paramet_lib, surf_lib, latex_lib, Visualization
singular.texi(,595) @subsection paramet_lib
singular.texi(,596) @c include of docu for paramet.lib
paramet_lib.tex(,1) @c ---content LibInfo---
paramet_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/paramet_lib.doc
paramet_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/paramet_lib.doc INSTEAD
paramet_lib.tex(,4) @c library version: (1.11.2.1,2002/10/21)
paramet_lib.tex(,5) @c library file: ../Singular/LIB/paramet.lib
paramet_lib.tex(,6) @cindex paramet.lib
paramet_lib.tex(,7) @cindex paramet_lib
paramet_lib.tex(,8) @table @asis
paramet_lib.tex(,9) @item @strong{Library:}
paramet_lib.tex(,10) paramet.lib
paramet_lib.tex(,11) @item @strong{Purpose:}
paramet_lib.tex(,12)    Parametrization of Varieties
paramet_lib.tex(,13) @item @strong{Author:}
paramet_lib.tex(,14) Thomas Keilen, keilen@@mathematik.uni-kl.de
paramet_lib.tex(,15) 
paramet_lib.tex(,16) @end table
paramet_lib.tex(,17) 
paramet_lib.tex(,18) @strong{Procedures:}
paramet_lib.tex(,19) @menu
paramet_lib.tex(,20) * parametrize:: parametrizes a prime ideal via the normalization
paramet_lib.tex(,21) * parametrizepd:: calculates the prim.dec. and parametrizes the components
paramet_lib.tex(,22) * parametrizesing:: parametrizes an isolated plane curve singularity
paramet_lib.tex(,23) @end menu
paramet_lib.tex(,24) @table @asis
paramet_lib.tex(,25) @item @strong{Overview:}
paramet_lib.tex(,26) A library to compute parametrizations of algebraic varieties (if possible)
paramet_lib.tex(,27) with the aid of a normalization, or a primary decomposition, resp. to compute
paramet_lib.tex(,28) a parametrization of a plane curve singularity with the aid of a
paramet_lib.tex(,29) Hamburger-Noether expansion.
paramet_lib.tex(,30) 
paramet_lib.tex(,31) @end table
paramet_lib.tex(,32) @c inserted refs from d2t_singular/paramet_lib.doc:30
paramet_lib.tex(,47) @c end inserted refs from d2t_singular/paramet_lib.doc:30
paramet_lib.tex(,48) 
paramet_lib.tex(,49) @c ---end content LibInfo---
paramet_lib.tex(,50) 
paramet_lib.tex(,51) @c ------------------- parametrize -------------
paramet_lib.tex(,52) @node parametrize, parametrizepd,, paramet_lib
paramet_lib.tex(,53) @subsubsection parametrize
paramet_lib.tex(,54) @cindex parametrize
paramet_lib.tex(,55) @c ---content parametrize---
paramet_lib.tex(,56) Procedure from library @code{paramet.lib} (@pxref{paramet_lib}).
paramet_lib.tex(,57) 
paramet_lib.tex(,58) @table @asis
paramet_lib.tex(,59) @item @strong{Usage:}
paramet_lib.tex(,60) parametrize(I); I ideal in an arbitrary number of variables,
paramet_lib.tex(,61) whose radical is prime, in a ring with global ordering
paramet_lib.tex(,62) 
paramet_lib.tex(,63) @item @strong{Create:}
paramet_lib.tex(,64) If the parametrization is successful, the basering will be changed to
paramet_lib.tex(,65) the parametrization ring, that is to the ring PR=0,(s,t),dp;
paramet_lib.tex(,66) respectively PR=0,t(1..d),dp;, depending on the dimension of the
paramet_lib.tex(,67) parametrized variety.
paramet_lib.tex(,68) 
paramet_lib.tex(,69) @item @strong{Return:}
paramet_lib.tex(,70) a list containing the parametrization ideal resp. the original ideal,
paramet_lib.tex(,71) the number of variables needed for the parametrization resp. 0, and
paramet_lib.tex(,72) 1 resp. 0 depending on whether the parametrization was successful
paramet_lib.tex(,73) or not
paramet_lib.tex(,74) 
paramet_lib.tex(,75) @cindex parametrization
paramet_lib.tex(,76) @cindex normalization
paramet_lib.tex(,77) @end table
paramet_lib.tex(,78) @strong{Example:}
paramet_lib.tex(,79) @smallexample
paramet_lib.tex(,80) @c computed example parametrize d2t_singular/paramet_lib.doc:65 
paramet_lib.tex(,81) LIB "paramet.lib";
paramet_lib.tex(,82) ring RING=0,(x,y,z),dp;
paramet_lib.tex(,83) ideal I=z2-y2x2+x3;
paramet_lib.tex(,84) parametrize(I);
paramet_lib.tex(,85) @expansion{} [1]:
paramet_lib.tex(,86) @expansion{}    _[1]=s2-t2
paramet_lib.tex(,87) @expansion{}    _[2]=s
paramet_lib.tex(,88) @expansion{}    _[3]=s2t-t3
paramet_lib.tex(,89) @expansion{} [2]:
paramet_lib.tex(,90) @expansion{}    2
paramet_lib.tex(,91) @expansion{} [3]:
paramet_lib.tex(,92) @expansion{}    1
paramet_lib.tex(,93) @c end example parametrize d2t_singular/paramet_lib.doc:65
paramet_lib.tex(,94) @end smallexample
paramet_lib.tex(,95) @c inserted refs from d2t_singular/paramet_lib.doc:72
paramet_lib.tex(,112) @c end inserted refs from d2t_singular/paramet_lib.doc:72
paramet_lib.tex(,113) 
paramet_lib.tex(,114) @c ---end content parametrize---
paramet_lib.tex(,115) 
paramet_lib.tex(,116) @c ------------------- parametrizepd -------------
paramet_lib.tex(,117) @node parametrizepd, parametrizesing, parametrize, paramet_lib
paramet_lib.tex(,118) @subsubsection parametrizepd
paramet_lib.tex(,119) @cindex parametrizepd
paramet_lib.tex(,120) @c ---content parametrizepd---
paramet_lib.tex(,121) Procedure from library @code{paramet.lib} (@pxref{paramet_lib}).
paramet_lib.tex(,122) 
paramet_lib.tex(,123) @table @asis
paramet_lib.tex(,124) @item @strong{Usage:}
paramet_lib.tex(,125) parametrizepd(I); I ideal in a polynomial ring with global ordering
paramet_lib.tex(,126) 
paramet_lib.tex(,127) @item @strong{Create:}
paramet_lib.tex(,128) If the parametrization is successful, the basering will be changed to
paramet_lib.tex(,129) the parametrization ring, that is to the ring PR=0,(s,t),dp;
paramet_lib.tex(,130) respectively PR=0,t(1..d),dp;, depending on the dimension of the
paramet_lib.tex(,131) parametrized variety.
paramet_lib.tex(,132) 
paramet_lib.tex(,133) @item @strong{Return:}
paramet_lib.tex(,134) a list of lists, where each entry contains the parametrization
paramet_lib.tex(,135) of a primary component of I resp. 0, the number of variables
paramet_lib.tex(,136) resp. 0, and 1 resp. 0 depending on whether the parametrization
paramet_lib.tex(,137) of the component was successful or not
paramet_lib.tex(,138) 
paramet_lib.tex(,139) @cindex parametrization
paramet_lib.tex(,140) @cindex normalization
paramet_lib.tex(,141) @end table
paramet_lib.tex(,142) @strong{Example:}
paramet_lib.tex(,143) @smallexample
paramet_lib.tex(,144) @c computed example parametrizepd d2t_singular/paramet_lib.doc:106 
paramet_lib.tex(,145) LIB "paramet.lib";
paramet_lib.tex(,146) ring RING=0,(x,y,z),dp;
paramet_lib.tex(,147) ideal I=(x2-y2z2+z3)*(x2-z2-z3),(x2-y2z2+z3)*yz;
paramet_lib.tex(,148) parametrizepd(I);
paramet_lib.tex(,149) @expansion{} [1]:
paramet_lib.tex(,150) @expansion{}    [1]:
paramet_lib.tex(,151) @expansion{}       _[1]=s2t-t3
paramet_lib.tex(,152) @expansion{}       _[2]=s
paramet_lib.tex(,153) @expansion{}       _[3]=s2-t2
paramet_lib.tex(,154) @expansion{}    [2]:
paramet_lib.tex(,155) @expansion{}       2
paramet_lib.tex(,156) @expansion{}    [3]:
paramet_lib.tex(,157) @expansion{}       1
paramet_lib.tex(,158) @expansion{} [2]:
paramet_lib.tex(,159) @expansion{}    [1]:
paramet_lib.tex(,160) @expansion{}       _[1]=0
paramet_lib.tex(,161) @expansion{}       _[2]=s
paramet_lib.tex(,162) @expansion{}       _[3]=0
paramet_lib.tex(,163) @expansion{}    [2]:
paramet_lib.tex(,164) @expansion{}       1
paramet_lib.tex(,165) @expansion{}    [3]:
paramet_lib.tex(,166) @expansion{}       1
paramet_lib.tex(,167) @expansion{} [3]:
paramet_lib.tex(,168) @expansion{}    [1]:
paramet_lib.tex(,169) @expansion{}       _[1]=s3-s
paramet_lib.tex(,170) @expansion{}       _[2]=0
paramet_lib.tex(,171) @expansion{}       _[3]=s2-1
paramet_lib.tex(,172) @expansion{}    [2]:
paramet_lib.tex(,173) @expansion{}       1
paramet_lib.tex(,174) @expansion{}    [3]:
paramet_lib.tex(,175) @expansion{}       1
paramet_lib.tex(,176) @c end example parametrizepd d2t_singular/paramet_lib.doc:106
paramet_lib.tex(,177) @end smallexample
paramet_lib.tex(,178) @c inserted refs from d2t_singular/paramet_lib.doc:113
paramet_lib.tex(,193) @c end inserted refs from d2t_singular/paramet_lib.doc:113
paramet_lib.tex(,194) 
paramet_lib.tex(,195) @c ---end content parametrizepd---
paramet_lib.tex(,196) 
paramet_lib.tex(,197) @c ------------------- parametrizesing -------------
paramet_lib.tex(,198) @node parametrizesing,, parametrizepd, paramet_lib
paramet_lib.tex(,199) @subsubsection parametrizesing
paramet_lib.tex(,200) @cindex parametrizesing
paramet_lib.tex(,201) @c ---content parametrizesing---
paramet_lib.tex(,202) Procedure from library @code{paramet.lib} (@pxref{paramet_lib}).
paramet_lib.tex(,203) 
paramet_lib.tex(,204) @table @asis
paramet_lib.tex(,205) @item @strong{Usage:}
paramet_lib.tex(,206) parametrizesing(f); f a polynomial in two variables, ordering ls or ds
paramet_lib.tex(,207) 
paramet_lib.tex(,208) @item @strong{Create:}
paramet_lib.tex(,209) If the parametrization is successful, the basering will be changed to
paramet_lib.tex(,210) the parametrization ring, that is to the ring 0,(x,y),ls;
paramet_lib.tex(,211) 
paramet_lib.tex(,212) @item @strong{Return:}
paramet_lib.tex(,213) a list containing the parametrizations of the different branches of the
paramet_lib.tex(,214) singularity at the origin resp. 0, if f was not of the desired kind
paramet_lib.tex(,215) 
paramet_lib.tex(,216) @cindex parametrization
paramet_lib.tex(,217) @cindex curve singularities
paramet_lib.tex(,218) @end table
paramet_lib.tex(,219) @strong{Example:}
paramet_lib.tex(,220) @smallexample
paramet_lib.tex(,221) @c computed example parametrizesing d2t_singular/paramet_lib.doc:143 
paramet_lib.tex(,222) LIB "paramet.lib";
paramet_lib.tex(,223) ring RING=0,(x,y),ls;
paramet_lib.tex(,224) poly f=(x^2-y^3)*(x^2-y^2-y^3);
paramet_lib.tex(,225) parametrizesing(f);
paramet_lib.tex(,226) @expansion{} [1]:
paramet_lib.tex(,227) @expansion{}    _[1]=x
paramet_lib.tex(,228) @expansion{}    _[2]=x-1/2x2
paramet_lib.tex(,229) @expansion{} [2]:
paramet_lib.tex(,230) @expansion{}    _[1]=x
paramet_lib.tex(,231) @expansion{}    _[2]=-x-1/2x2
paramet_lib.tex(,232) @expansion{} [3]:
paramet_lib.tex(,233) @expansion{}    _[1]=x3
paramet_lib.tex(,234) @expansion{}    _[2]=x2
paramet_lib.tex(,235) @c end example parametrizesing d2t_singular/paramet_lib.doc:143
paramet_lib.tex(,236) @end smallexample
paramet_lib.tex(,237) @c inserted refs from d2t_singular/paramet_lib.doc:150
paramet_lib.tex(,252) @c end inserted refs from d2t_singular/paramet_lib.doc:150
paramet_lib.tex(,253) 
paramet_lib.tex(,254) @c ---end content parametrizesing---
singular.texi(,598) @c ---------------------------------------------------------
singular.texi(,599) @node surf_lib,, paramet_lib, Visualization
singular.texi(,600) @subsection surf_lib
singular.texi(,601) @c include of docu for surf.lib
surf_lib_noEx.tex(,1) @c ---content LibInfo---
surf_lib_noEx.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/surf_lib.doc
surf_lib_noEx.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/surf_lib.doc INSTEAD
surf_lib_noEx.tex(,4) @c library version: (1.19.2.6,2002/07/17)
surf_lib_noEx.tex(,5) @c library file: ../Singular/LIB/surf.lib
surf_lib_noEx.tex(,6) @cindex surf.lib
surf_lib_noEx.tex(,7) @cindex surf_lib
surf_lib_noEx.tex(,8) @table @asis
surf_lib_noEx.tex(,9) @item @strong{Library:}
surf_lib_noEx.tex(,10) surf.lib
surf_lib_noEx.tex(,11) @item @strong{Purpose:}
surf_lib_noEx.tex(,12)     Procedures for Graphics with Surf
surf_lib_noEx.tex(,13) @item @strong{Author:}
surf_lib_noEx.tex(,14) Hans Schoenemann,
surf_lib_noEx.tex(,15) @*the program surf is written by Stefan Endrass
surf_lib_noEx.tex(,16) 
surf_lib_noEx.tex(,17) @item @strong{Note:}
surf_lib_noEx.tex(,18) To use this library requires the program @code{surf} to be installed.
surf_lib_noEx.tex(,19)  @code{surf} is only available for Linux PCs and Sun workstations.
surf_lib_noEx.tex(,20)  You can download @code{surf} either from
surf_lib_noEx.tex(,21)   @uref{http://sourceforge.net/projects/surf}
surf_lib_noEx.tex(,22)   or from @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils/}.
surf_lib_noEx.tex(,23) 
surf_lib_noEx.tex(,24) @end table
surf_lib_noEx.tex(,25) 
surf_lib_noEx.tex(,26) @strong{Procedures:}
surf_lib_noEx.tex(,27) @menu
surf_lib_noEx.tex(,28) * plot:: plots plane curves and surfaces
surf_lib_noEx.tex(,29) @end menu
surf_lib_noEx.tex(,30) @c ---end content LibInfo---
surf_lib_noEx.tex(,31) 
surf_lib_noEx.tex(,32) @c ------------------- plot -------------
surf_lib_noEx.tex(,33) @node plot,,, surf_lib
surf_lib_noEx.tex(,34) @subsubsection plot
surf_lib_noEx.tex(,35) @cindex plot
surf_lib_noEx.tex(,36) @c ---content plot---
surf_lib_noEx.tex(,37) Procedure from library @code{surf.lib} (@pxref{surf_lib}).
surf_lib_noEx.tex(,38) 
surf_lib_noEx.tex(,39) @table @asis
surf_lib_noEx.tex(,40) @item @strong{Usage:}
surf_lib_noEx.tex(,41) plot(I); I ideal or poly
surf_lib_noEx.tex(,42) 
surf_lib_noEx.tex(,43) @item @strong{Assume:}
surf_lib_noEx.tex(,44) I defines a plane curve or a surface given by one equation
surf_lib_noEx.tex(,45) 
surf_lib_noEx.tex(,46) @item @strong{Return:}
surf_lib_noEx.tex(,47) nothing
surf_lib_noEx.tex(,48) 
surf_lib_noEx.tex(,49) @item @strong{Note:}
surf_lib_noEx.tex(,50) requires the external program 'surf' to be installed
surf_lib_noEx.tex(,51) 
surf_lib_noEx.tex(,52) @end table
surf_lib_noEx.tex(,53) @strong{Example:}
surf_lib_noEx.tex(,54) @smallexample
surf_lib_noEx.tex(,55) @c skipped computation of example plot d2t_singular/surf_lib.doc:53 
surf_lib_noEx.tex(,56) LIB "surf.lib";
surf_lib_noEx.tex(,57) // ---------  plane curves ------------
surf_lib_noEx.tex(,58) ring rr0 = 0,(x1,x2),dp;
surf_lib_noEx.tex(,59) ideal I = x1^3 - x2^2;
surf_lib_noEx.tex(,60) plot(I);
surf_lib_noEx.tex(,61) ring rr1 = 0,(x,y,z),dp;
surf_lib_noEx.tex(,62) ideal I(1) = 2x2-1/2x3 +1-y+1;
surf_lib_noEx.tex(,63) plot(I(1));
surf_lib_noEx.tex(,64) //  ---- Singular Logo --------------
surf_lib_noEx.tex(,65) poly logo = ((x+3)^3 + 2*(x+3)^2 - y^2)*(x^3 - y^2)*((x-3)^3-2*(x-3)^2-y^2);
surf_lib_noEx.tex(,66) plot(logo);
surf_lib_noEx.tex(,67) // Steiner surface
surf_lib_noEx.tex(,68) ideal J(2) = x^2*y^2+x^2*z^2+y^2*z^2-17*x*y*z;
surf_lib_noEx.tex(,69) plot(J(2));
surf_lib_noEx.tex(,70) // --------------------
surf_lib_noEx.tex(,71) plot(x*(x2-y2)+z2);
surf_lib_noEx.tex(,72) // E7
surf_lib_noEx.tex(,73) plot(x^3-x*y^3+z^2);
surf_lib_noEx.tex(,74) // Whitney umbrella
surf_lib_noEx.tex(,75) plot(z^2-x^2*y);
surf_lib_noEx.tex(,76) @end smallexample
surf_lib_noEx.tex(,77) @c ---end content plot---
singular.texi(,603) 
singular.texi(,604) @c ----------------------------------------------------------------------------
singular.texi(,605) @node Coding theory, , Visualization, SINGULAR libraries
singular.texi(,606) @section Coding theory
singular.texi(,607) @cindex Coding theory
singular.texi(,608) 
singular.texi(,609) @menu
singular.texi(,610) * brnoeth_lib:: Brill-Noether algorithm, Weierstrass semigroups and AG codes
singular.texi(,611) @end menu
singular.texi(,612) 
singular.texi(,613) @c ---------------------------------------------------------
singular.texi(,614) @node brnoeth_lib, , , Coding theory
singular.texi(,615) @subsection brnoeth_lib
singular.texi(,616) @c include of docu for brnoeth.lib
brnoeth_lib.tex(,1) @c ---content LibInfo---
brnoeth_lib.tex(,2) @comment This file was generated by doc2tex.pl from d2t_singular/brnoeth_lib.doc
brnoeth_lib.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/brnoeth_lib.doc INSTEAD
brnoeth_lib.tex(,4) @c library version: (1.11.2.5,2002/10/18)
brnoeth_lib.tex(,5) @c library file: ../Singular/LIB/brnoeth.lib
brnoeth_lib.tex(,6) @cindex brnoeth.lib
brnoeth_lib.tex(,7) @cindex brnoeth_lib
brnoeth_lib.tex(,8) @table @asis
brnoeth_lib.tex(,9) @item @strong{Library:}
brnoeth_lib.tex(,10) brnoeth.lib
brnoeth_lib.tex(,11) @item @strong{Purpose:}
brnoeth_lib.tex(,12)   Brill-Noether Algorithm, Weierstrass-SG and AG-codes
brnoeth_lib.tex(,13) @item @strong{Authors:}
brnoeth_lib.tex(,14) Jose Ignacio Farran Martin, ignfar@@eis.uva.es
brnoeth_lib.tex(,15) @*Christoph Lossen, lossen@@mathematik.uni-kl.de
brnoeth_lib.tex(,16) 
brnoeth_lib.tex(,17) @item @strong{Overview:}
brnoeth_lib.tex(,18) Implementation of the Brill-Noether algorithm for solving the
brnoeth_lib.tex(,19) Riemann-Roch problem and applications in Algebraic Geometry codes.
brnoeth_lib.tex(,20) The computation of Weierstrass semigroups is also implemented.@*
brnoeth_lib.tex(,21) The procedures are intended only for plane (singular) curves defined over
brnoeth_lib.tex(,22) a prime field of positive characteristic.@*
brnoeth_lib.tex(,23) For more information about the library see the end of the file brnoeth.lib.
brnoeth_lib.tex(,24) 
brnoeth_lib.tex(,25) @end table
brnoeth_lib.tex(,26) 
brnoeth_lib.tex(,27) @strong{Main procedures:}
brnoeth_lib.tex(,28) @menu
brnoeth_lib.tex(,29) * Adj_div:: computes the conductor of a curve
brnoeth_lib.tex(,30) * NSplaces:: computes non-singular places with given degrees
brnoeth_lib.tex(,31) * BrillNoether:: computes a vector space basis of the linear system L(D)
brnoeth_lib.tex(,32) * Weierstrass:: computes the Weierstrass semigroup of C at P up to m
brnoeth_lib.tex(,33) * extcurve:: extends the curve C to an extension of degree d
brnoeth_lib.tex(,34) * AGcode_L:: computes the evaluation AG code with divisors G and D
brnoeth_lib.tex(,35) * AGcode_Omega:: computes the residual AG code with divisors G and D
brnoeth_lib.tex(,36) * prepSV:: preprocessing for the basic decoding algorithm
brnoeth_lib.tex(,37) * decodeSV:: decoding of a word with the basic decoding algorithm
brnoeth_lib.tex(,38) @end menu
brnoeth_lib.tex(,39) @strong{Auxiliary procedures:}
brnoeth_lib.tex(,40) @menu
brnoeth_lib.tex(,41) * closed_points:: computes the zero-set of a zero-dim. ideal in 2 vars
brnoeth_lib.tex(,42) * dual_code:: computes the dual code
brnoeth_lib.tex(,43) * sys_code:: computes an equivalent systematic code
brnoeth_lib.tex(,44) * permute_L:: applies a permutation to a list
brnoeth_lib.tex(,45) @end menu
brnoeth_lib.tex(,46) @cindex Weierstrass semigroup
brnoeth_lib.tex(,47) @cindex Algebraic Geometry codes
brnoeth_lib.tex(,48) @cindex Brill-Noether algorithm
brnoeth_lib.tex(,49) @c inserted refs from d2t_singular/brnoeth_lib.doc:47
brnoeth_lib.tex(,62) @c end inserted refs from d2t_singular/brnoeth_lib.doc:47
brnoeth_lib.tex(,63) 
brnoeth_lib.tex(,64) @c ---end content LibInfo---
brnoeth_lib.tex(,65) 
brnoeth_lib.tex(,66) @c ------------------- Adj_div -------------
brnoeth_lib.tex(,67) @node Adj_div, NSplaces,, brnoeth_lib
brnoeth_lib.tex(,68) @subsubsection Adj_div
brnoeth_lib.tex(,69) @cindex Adj_div
brnoeth_lib.tex(,70) @c ---content Adj_div---
brnoeth_lib.tex(,71) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,72) 
brnoeth_lib.tex(,73) @table @asis
brnoeth_lib.tex(,74) @item @strong{Usage:}
brnoeth_lib.tex(,75) Adj_div( f [,l] ); f a poly, [l a list]
brnoeth_lib.tex(,76) 
brnoeth_lib.tex(,77) @item @strong{Return:}
brnoeth_lib.tex(,78) list L with the computed data:
brnoeth_lib.tex(,79)   @format
brnoeth_lib.tex(,80)   L[1] a list of rings: L[1][1]=aff_r (affine), L[1][2]=Proj_R (projective),
brnoeth_lib.tex(,81)   L[2] an intvec with 2 entries (degree, genus),
brnoeth_lib.tex(,82)   L[3] a list of intvec (closed places),
brnoeth_lib.tex(,83)   L[4] an intvec (conductor),
brnoeth_lib.tex(,84)   L[5] a list of lists:
brnoeth_lib.tex(,85)      L[5][d][1] a (local) ring over an extension of degree d,
brnoeth_lib.tex(,86)      L[5][d][2] an intvec (degrees of base points of places of degree d)
brnoeth_lib.tex(,87)   @end format
brnoeth_lib.tex(,88) 
brnoeth_lib.tex(,89) @item @strong{Note:}
brnoeth_lib.tex(,90) @code{Adj_div(f);} computes and stores the fundamental data of the
brnoeth_lib.tex(,91) plane curve defined by f as needed for AG codes.
brnoeth_lib.tex(,92) @*In the affine ring you can find the following data:
brnoeth_lib.tex(,93)    @format
brnoeth_lib.tex(,94)    poly CHI:  affine equation of the curve,
brnoeth_lib.tex(,95)    ideal Aff_SLocus:  affine singular locus (std),
brnoeth_lib.tex(,96)    list Inf_Points:  points at infinity
brnoeth_lib.tex(,97)             Inf_Points[1]:  singular points
brnoeth_lib.tex(,98)             Inf_Points[2]:  non-singular points,
brnoeth_lib.tex(,99)    list Aff_SPoints:  affine singular points (if not empty).
brnoeth_lib.tex(,100)    @end format
brnoeth_lib.tex(,101) In the projective ring you can find the projective equation
brnoeth_lib.tex(,102) CHI of the curve (poly).
brnoeth_lib.tex(,103) @*In the local rings L[5][d][1] you find:
brnoeth_lib.tex(,104)    @format
brnoeth_lib.tex(,105)    list POINTS:  base points of the places of degree d,
brnoeth_lib.tex(,106)    list LOC_EQS:  local equations of the curve at the base points,
brnoeth_lib.tex(,107)    list BRANCHES:  Hamburger-Noether developments of the places,
brnoeth_lib.tex(,108)    list PARAMETRIZATIONS:  local parametrizations of the places,
brnoeth_lib.tex(,109)    @end format
brnoeth_lib.tex(,110) Each entry of the list L[3] corresponds to one closed place (i.e.,
brnoeth_lib.tex(,111) a place and all its conjugates) which is represented by an intvec
brnoeth_lib.tex(,112) of size two, the first entry is the degree of the place (in
brnoeth_lib.tex(,113) particular, it tells the local ring where to find the data
brnoeth_lib.tex(,114) describing one representative of the closed place), and the
brnoeth_lib.tex(,115) second one is the position of those data in the lists POINTS, etc.,
brnoeth_lib.tex(,116) inside this local ring.@*
brnoeth_lib.tex(,117) In the intvec L[4] (conductor) the i-th entry corresponds to the
brnoeth_lib.tex(,118) i-th entry in the list of places L[3].
brnoeth_lib.tex(,119) 
brnoeth_lib.tex(,120) With no optional arguments, the conductor is computed by
brnoeth_lib.tex(,121) local invariants of the singularities; otherwise it is computed
brnoeth_lib.tex(,122) by the Dedekind formula. @*
brnoeth_lib.tex(,123) An affine point is represented by a list P where P[1] is std
brnoeth_lib.tex(,124) of a prime ideal and P[2] is an intvec containing the position
brnoeth_lib.tex(,125) of the places above P in the list of closed places L[3]. @*
brnoeth_lib.tex(,126) If the point is at infinity, P[1] is a homogeneous irreducible
brnoeth_lib.tex(,127) polynomial in two variables.
brnoeth_lib.tex(,128) 
brnoeth_lib.tex(,129) If @code{printlevel>=0} additional comments are displayed (default:
brnoeth_lib.tex(,130) @code{printlevel=0}).
brnoeth_lib.tex(,131) 
brnoeth_lib.tex(,132) @cindex Hamburger-Noether expansions
brnoeth_lib.tex(,133) @cindex adjunction divisor
brnoeth_lib.tex(,134) @end table
brnoeth_lib.tex(,135) @strong{Example:}
brnoeth_lib.tex(,136) @smallexample
brnoeth_lib.tex(,137) @c computed example Adj_div d2t_singular/brnoeth_lib.doc:124 
brnoeth_lib.tex(,138) LIB "brnoeth.lib";
brnoeth_lib.tex(,139) int plevel=printlevel;
brnoeth_lib.tex(,140) printlevel=-1;
brnoeth_lib.tex(,141) ring s=2,(x,y),lp;
brnoeth_lib.tex(,142) list C=Adj_div(y9+y8+xy6+x2y3+y2+x3);
brnoeth_lib.tex(,143) @expansion{} The genus of the curve is 3
brnoeth_lib.tex(,144) def aff_R=C[1][1];      // the affine ring
brnoeth_lib.tex(,145) setring aff_R;
brnoeth_lib.tex(,146) listvar(aff_R);         // data in the affine ring
brnoeth_lib.tex(,147) @expansion{} // aff_R                [0]  *ring
brnoeth_lib.tex(,148) @expansion{} // Inf_Points           [0]  list, size: 2
brnoeth_lib.tex(,149) @expansion{} // Aff_SPoints          [0]  list, size: 3
brnoeth_lib.tex(,150) @expansion{} // Aff_SLocus           [0]  ideal (SB), 2 generator(s)
brnoeth_lib.tex(,151) @expansion{} // CHI                  [0]  poly
brnoeth_lib.tex(,152) CHI;                    // affine equation of the curve
brnoeth_lib.tex(,153) @expansion{} x3+x2y3+xy6+y9+y8+y2
brnoeth_lib.tex(,154) Aff_SLocus;             // ideal of the affine singular locus
brnoeth_lib.tex(,155) @expansion{} Aff_SLocus[1]=y8+y2
brnoeth_lib.tex(,156) @expansion{} Aff_SLocus[2]=x2+y6
brnoeth_lib.tex(,157) Aff_SPoints[1];         // 1st affine singular point: (1:1:1), no.1
brnoeth_lib.tex(,158) @expansion{} [1]:
brnoeth_lib.tex(,159) @expansion{}    _[1]=y2+y+1
brnoeth_lib.tex(,160) @expansion{}    _[2]=x+1
brnoeth_lib.tex(,161) @expansion{} [2]:
brnoeth_lib.tex(,162) @expansion{}    1
brnoeth_lib.tex(,163) Inf_Points[1];          // singular point(s) at infinity: (1:0:0), no.4
brnoeth_lib.tex(,164) @expansion{} [1]:
brnoeth_lib.tex(,165) @expansion{}    [1]:
brnoeth_lib.tex(,166) @expansion{}       y
brnoeth_lib.tex(,167) @expansion{}    [2]:
brnoeth_lib.tex(,168) @expansion{}       4
brnoeth_lib.tex(,169) Inf_Points[2];          // list of non-singular points at infinity
brnoeth_lib.tex(,170) @expansion{} empty list
brnoeth_lib.tex(,171) //
brnoeth_lib.tex(,172) def proj_R=C[1][2];     // the projective ring
brnoeth_lib.tex(,173) setring proj_R;
brnoeth_lib.tex(,174) CHI;                    // projective equation of the curve
brnoeth_lib.tex(,175) @expansion{} x3z6+x2y3z4+xy6z2+y9+y8z+y2z7
brnoeth_lib.tex(,176) C[2][1];                // degree of the curve
brnoeth_lib.tex(,177) @expansion{} 9
brnoeth_lib.tex(,178) C[2][2];                // genus of the curve
brnoeth_lib.tex(,179) @expansion{} 3
brnoeth_lib.tex(,180) C[3];                   // list of computed places
brnoeth_lib.tex(,181) @expansion{} [1]:
brnoeth_lib.tex(,182) @expansion{}    2,1
brnoeth_lib.tex(,183) @expansion{} [2]:
brnoeth_lib.tex(,184) @expansion{}    1,1
brnoeth_lib.tex(,185) @expansion{} [3]:
brnoeth_lib.tex(,186) @expansion{}    1,2
brnoeth_lib.tex(,187) @expansion{} [4]:
brnoeth_lib.tex(,188) @expansion{}    1,3
brnoeth_lib.tex(,189) C[4];                   // adjunction divisor (all points are singular!)
brnoeth_lib.tex(,190) @expansion{} 2,2,2,42
brnoeth_lib.tex(,191) //
brnoeth_lib.tex(,192) // we look at the place(s) of degree 2 by changing to the ring
brnoeth_lib.tex(,193) C[5][2][1];
brnoeth_lib.tex(,194) @expansion{} //   characteristic : 2
brnoeth_lib.tex(,195) @expansion{} //   1 parameter    : a 
brnoeth_lib.tex(,196) @expansion{} //   minpoly        : ...
brnoeth_lib.tex(,197) @expansion{} //   number of vars : 3
brnoeth_lib.tex(,198) @expansion{} //        block   1 : ordering ls
brnoeth_lib.tex(,199) @expansion{} //                  : names    x y t 
brnoeth_lib.tex(,200) @expansion{} //        block   2 : ordering C
brnoeth_lib.tex(,201) def S(2)=C[5][2][1];
brnoeth_lib.tex(,202) setring S(2);
brnoeth_lib.tex(,203) POINTS;                // base point(s) of place(s) of degree 2: (1:a:1)
brnoeth_lib.tex(,204) @expansion{} [1]:
brnoeth_lib.tex(,205) @expansion{}    [1]:
brnoeth_lib.tex(,206) @expansion{}       1
brnoeth_lib.tex(,207) @expansion{}    [2]:
brnoeth_lib.tex(,208) @expansion{}       (a)
brnoeth_lib.tex(,209) @expansion{}    [3]:
brnoeth_lib.tex(,210) @expansion{}       1
brnoeth_lib.tex(,211) LOC_EQS;               // local equation(s)
brnoeth_lib.tex(,212) @expansion{} [1]:
brnoeth_lib.tex(,213) @expansion{}    y2+y3+(a+1)*y4+y6+(a+1)*y8+y9+(a)*xy2+(a+1)*xy4+xy6+(a+1)*x2y+(a)*x2y2\
brnoeth_lib.tex(,214)    +x2y3+x3
brnoeth_lib.tex(,215) PARAMETRIZATIONS;      // parametrization(s) and exactness
brnoeth_lib.tex(,216) @expansion{} [1]:
brnoeth_lib.tex(,217) @expansion{}    [1]:
brnoeth_lib.tex(,218) @expansion{}       _[1]=t2+(a+1)*t3
brnoeth_lib.tex(,219) @expansion{}       _[2]=t3+(a+1)*t4
brnoeth_lib.tex(,220) @expansion{}    [2]:
brnoeth_lib.tex(,221) @expansion{}       3,4
brnoeth_lib.tex(,222) BRANCHES;              // Hamburger-Noether development
brnoeth_lib.tex(,223) @expansion{} [1]:
brnoeth_lib.tex(,224) @expansion{}    [1]:
brnoeth_lib.tex(,225) @expansion{}       _[1,1]=0
brnoeth_lib.tex(,226) @expansion{}       _[1,2]=x
brnoeth_lib.tex(,227) @expansion{}       _[1,3]=0
brnoeth_lib.tex(,228) @expansion{}       _[2,1]=0
brnoeth_lib.tex(,229) @expansion{}       _[2,2]=1
brnoeth_lib.tex(,230) @expansion{}       _[2,3]=(a+1)
brnoeth_lib.tex(,231) @expansion{}    [2]:
brnoeth_lib.tex(,232) @expansion{}       1,-4
brnoeth_lib.tex(,233) @expansion{}    [3]:
brnoeth_lib.tex(,234) @expansion{}       0
brnoeth_lib.tex(,235) @expansion{}    [4]:
brnoeth_lib.tex(,236) @expansion{}       y+(a+1)*xy+(a)*x2y+(a)*x2y2+(a+1)*x3+x3y+x3y3+(a)*x4+(a+1)*x4y2+(a+\
brnoeth_lib.tex(,237)    1)*x4y3+x5+x5y2+(a)*x6+(a+1)*x6y2+x6y4+x6y5+x7y+(a+1)*x8+(a+1)*x8y+x8y4+(\
brnoeth_lib.tex(,238)    a+1)*x8y6+x9+x9y7+(a+1)*x10+x11y6+(a+1)*x12y4+x13y5+x14+x14y+x15y4+x16+(a\
brnoeth_lib.tex(,239)    +1)*x16y2+x17y3+x19y2+(a+1)*x20+x21y+x23
brnoeth_lib.tex(,240) printlevel=plevel;
brnoeth_lib.tex(,241) @c end example Adj_div d2t_singular/brnoeth_lib.doc:124
brnoeth_lib.tex(,242) @end smallexample
brnoeth_lib.tex(,243) @c inserted refs from d2t_singular/brnoeth_lib.doc:158
brnoeth_lib.tex(,256) @c end inserted refs from d2t_singular/brnoeth_lib.doc:158
brnoeth_lib.tex(,257) 
brnoeth_lib.tex(,258) @c ---end content Adj_div---
brnoeth_lib.tex(,259) 
brnoeth_lib.tex(,260) @c ------------------- NSplaces -------------
brnoeth_lib.tex(,261) @node NSplaces, BrillNoether, Adj_div, brnoeth_lib
brnoeth_lib.tex(,262) @subsubsection NSplaces
brnoeth_lib.tex(,263) @cindex NSplaces
brnoeth_lib.tex(,264) @c ---content NSplaces---
brnoeth_lib.tex(,265) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,266) 
brnoeth_lib.tex(,267) @table @asis
brnoeth_lib.tex(,268) @item @strong{Usage:}
brnoeth_lib.tex(,269) NSplaces( h, CURVE ), where h is an intvec and CURVE is a list
brnoeth_lib.tex(,270) 
brnoeth_lib.tex(,271) @item @strong{Return:}
brnoeth_lib.tex(,272) list L with updated data of CURVE after computing all non-singular
brnoeth_lib.tex(,273) affine closed places whose degrees are in the intvec h: @*
brnoeth_lib.tex(,274)    @format
brnoeth_lib.tex(,275)    in L[1][1]: (affine ring) lists Aff_Points(d) with affine non-singular
brnoeth_lib.tex(,276)                (closed) points of degree d (if non-empty),
brnoeth_lib.tex(,277)    in L[3]:    the newly computed closed places are added,
brnoeth_lib.tex(,278)    in L[5]:    local rings created/updated to store (repres. of) new places.
brnoeth_lib.tex(,279)    @end format
brnoeth_lib.tex(,280) See @ref{Adj_div} for a description of the entries in L.
brnoeth_lib.tex(,281) 
brnoeth_lib.tex(,282) @item @strong{Note:}
brnoeth_lib.tex(,283) The list_expression should be the output of the procedure Adj_div.@*
brnoeth_lib.tex(,284) If @code{printlevel>=0} additional comments are displayed (default:
brnoeth_lib.tex(,285) @code{printlevel=0}).
brnoeth_lib.tex(,286) 
brnoeth_lib.tex(,287) @end table
brnoeth_lib.tex(,288) @strong{Example:}
brnoeth_lib.tex(,289) @smallexample
brnoeth_lib.tex(,290) @c computed example NSplaces d2t_singular/brnoeth_lib.doc:194 
brnoeth_lib.tex(,291) LIB "brnoeth.lib";
brnoeth_lib.tex(,292) int plevel=printlevel;
brnoeth_lib.tex(,293) printlevel=-1;
brnoeth_lib.tex(,294) ring s=2,(x,y),lp;
brnoeth_lib.tex(,295) list C=Adj_div(x3y+y3+x);
brnoeth_lib.tex(,296) @expansion{} The genus of the curve is 3
brnoeth_lib.tex(,297) // The list of computed places:
brnoeth_lib.tex(,298) C[3];
brnoeth_lib.tex(,299) @expansion{} [1]:
brnoeth_lib.tex(,300) @expansion{}    1,1
brnoeth_lib.tex(,301) @expansion{} [2]:
brnoeth_lib.tex(,302) @expansion{}    1,2
brnoeth_lib.tex(,303) // create places up to degree 4
brnoeth_lib.tex(,304) list L=NSplaces(1..4,C);
brnoeth_lib.tex(,305) // The list of computed places is now:
brnoeth_lib.tex(,306) L[3];
brnoeth_lib.tex(,307) @expansion{} [1]:
brnoeth_lib.tex(,308) @expansion{}    1,1
brnoeth_lib.tex(,309) @expansion{} [2]:
brnoeth_lib.tex(,310) @expansion{}    1,2
brnoeth_lib.tex(,311) @expansion{} [3]:
brnoeth_lib.tex(,312) @expansion{}    1,3
brnoeth_lib.tex(,313) @expansion{} [4]:
brnoeth_lib.tex(,314) @expansion{}    2,1
brnoeth_lib.tex(,315) @expansion{} [5]:
brnoeth_lib.tex(,316) @expansion{}    3,1
brnoeth_lib.tex(,317) @expansion{} [6]:
brnoeth_lib.tex(,318) @expansion{}    3,2
brnoeth_lib.tex(,319) @expansion{} [7]:
brnoeth_lib.tex(,320) @expansion{}    3,3
brnoeth_lib.tex(,321) @expansion{} [8]:
brnoeth_lib.tex(,322) @expansion{}    3,4
brnoeth_lib.tex(,323) @expansion{} [9]:
brnoeth_lib.tex(,324) @expansion{}    3,5
brnoeth_lib.tex(,325) @expansion{} [10]:
brnoeth_lib.tex(,326) @expansion{}    3,6
brnoeth_lib.tex(,327) @expansion{} [11]:
brnoeth_lib.tex(,328) @expansion{}    3,7
brnoeth_lib.tex(,329) @expansion{} [12]:
brnoeth_lib.tex(,330) @expansion{}    4,1
brnoeth_lib.tex(,331) @expansion{} [13]:
brnoeth_lib.tex(,332) @expansion{}    4,2
brnoeth_lib.tex(,333) @expansion{} [14]:
brnoeth_lib.tex(,334) @expansion{}    4,3
brnoeth_lib.tex(,335) // e.g., affine non-singular points of degree 4 :
brnoeth_lib.tex(,336) def aff_r=L[1][1];
brnoeth_lib.tex(,337) setring aff_r;
brnoeth_lib.tex(,338) Aff_Points(4);
brnoeth_lib.tex(,339) @expansion{} [1]:
brnoeth_lib.tex(,340) @expansion{}    [1]:
brnoeth_lib.tex(,341) @expansion{}       _[1]=y2+y+1
brnoeth_lib.tex(,342) @expansion{}       _[2]=x2+xy+x+1
brnoeth_lib.tex(,343) @expansion{}    [2]:
brnoeth_lib.tex(,344) @expansion{}       12
brnoeth_lib.tex(,345) @expansion{} [2]:
brnoeth_lib.tex(,346) @expansion{}    [1]:
brnoeth_lib.tex(,347) @expansion{}       _[1]=y4+y3+y2+y+1
brnoeth_lib.tex(,348) @expansion{}       _[2]=x+y2+y+1
brnoeth_lib.tex(,349) @expansion{}    [2]:
brnoeth_lib.tex(,350) @expansion{}       13
brnoeth_lib.tex(,351) @expansion{} [3]:
brnoeth_lib.tex(,352) @expansion{}    [1]:
brnoeth_lib.tex(,353) @expansion{}       _[1]=y4+y3+1
brnoeth_lib.tex(,354) @expansion{}       _[2]=x+y3+y
brnoeth_lib.tex(,355) @expansion{}    [2]:
brnoeth_lib.tex(,356) @expansion{}       14
brnoeth_lib.tex(,357) // e.g., base point of the 1st place of degree 4 :
brnoeth_lib.tex(,358) def S(4)=L[5][4][1];
brnoeth_lib.tex(,359) setring S(4);
brnoeth_lib.tex(,360) POINTS[1];
brnoeth_lib.tex(,361) @expansion{} [1]:
brnoeth_lib.tex(,362) @expansion{}    (a3)
brnoeth_lib.tex(,363) @expansion{} [2]:
brnoeth_lib.tex(,364) @expansion{}    (a2+a)
brnoeth_lib.tex(,365) @expansion{} [3]:
brnoeth_lib.tex(,366) @expansion{}    1
brnoeth_lib.tex(,367) printlevel=plevel;
brnoeth_lib.tex(,368) @c end example NSplaces d2t_singular/brnoeth_lib.doc:194
brnoeth_lib.tex(,369) @end smallexample
brnoeth_lib.tex(,370) @c inserted refs from d2t_singular/brnoeth_lib.doc:217
brnoeth_lib.tex(,383) @c end inserted refs from d2t_singular/brnoeth_lib.doc:217
brnoeth_lib.tex(,384) 
brnoeth_lib.tex(,385) @c ---end content NSplaces---
brnoeth_lib.tex(,386) 
brnoeth_lib.tex(,387) @c ------------------- BrillNoether -------------
brnoeth_lib.tex(,388) @node BrillNoether, Weierstrass, NSplaces, brnoeth_lib
brnoeth_lib.tex(,389) @subsubsection BrillNoether
brnoeth_lib.tex(,390) @cindex BrillNoether
brnoeth_lib.tex(,391) @c ---content BrillNoether---
brnoeth_lib.tex(,392) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,393) 
brnoeth_lib.tex(,394) @table @asis
brnoeth_lib.tex(,395) @item @strong{Usage:}
brnoeth_lib.tex(,396) BrillNoether(G,CURVE); G an intvec, CURVE a list
brnoeth_lib.tex(,397) 
brnoeth_lib.tex(,398) @item @strong{Return:}
brnoeth_lib.tex(,399) list of ideals (each of them with two homogeneous generators,
brnoeth_lib.tex(,400) which represent the numerator, resp. denominator, of a rational
brnoeth_lib.tex(,401) function).@*
brnoeth_lib.tex(,402) The corresponding rational functions form a vector basis of the
brnoeth_lib.tex(,403) linear system L(G), G a rational divisor over a non-singular curve.
brnoeth_lib.tex(,404) 
brnoeth_lib.tex(,405) @item @strong{Note:}
brnoeth_lib.tex(,406) The procedure must be called from the ring CURVE[1][2], where
brnoeth_lib.tex(,407) CURVE is the output of the procedure @code{NSplaces}. @*
brnoeth_lib.tex(,408) The intvec G represents a rational divisor supported on the closed
brnoeth_lib.tex(,409) places of CURVE[3] (e.g. @code{G=2,0,-1;} means 2 times the closed
brnoeth_lib.tex(,410) place 1 minus 1 times the closed place 3).
brnoeth_lib.tex(,411) 
brnoeth_lib.tex(,412) @end table
brnoeth_lib.tex(,413) @strong{Example:}
brnoeth_lib.tex(,414) @smallexample
brnoeth_lib.tex(,415) @c computed example BrillNoether d2t_singular/brnoeth_lib.doc:251 
brnoeth_lib.tex(,416) LIB "brnoeth.lib";
brnoeth_lib.tex(,417) int plevel=printlevel;
brnoeth_lib.tex(,418) printlevel=-1;
brnoeth_lib.tex(,419) ring s=2,(x,y),lp;
brnoeth_lib.tex(,420) list C=Adj_div(x3y+y3+x);
brnoeth_lib.tex(,421) @expansion{} The genus of the curve is 3
brnoeth_lib.tex(,422) C=NSplaces(1..4,C);
brnoeth_lib.tex(,423) // the first 3 Places in C[3] are of degree 1.
brnoeth_lib.tex(,424) // we define the rational divisor G = 4*C[3][1]+4*C[3][3] (of degree 8):
brnoeth_lib.tex(,425) intvec G=4,0,4;
brnoeth_lib.tex(,426) def R=C[1][2];
brnoeth_lib.tex(,427) setring R;
brnoeth_lib.tex(,428) list LG=BrillNoether(G,C);
brnoeth_lib.tex(,429) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,430) // here is the vector basis of L(G):
brnoeth_lib.tex(,431) LG;
brnoeth_lib.tex(,432) @expansion{} [1]:
brnoeth_lib.tex(,433) @expansion{}    _[1]=1
brnoeth_lib.tex(,434) @expansion{}    _[2]=1
brnoeth_lib.tex(,435) @expansion{} [2]:
brnoeth_lib.tex(,436) @expansion{}    _[1]=y
brnoeth_lib.tex(,437) @expansion{}    _[2]=x
brnoeth_lib.tex(,438) @expansion{} [3]:
brnoeth_lib.tex(,439) @expansion{}    _[1]=z
brnoeth_lib.tex(,440) @expansion{}    _[2]=x
brnoeth_lib.tex(,441) @expansion{} [4]:
brnoeth_lib.tex(,442) @expansion{}    _[1]=y2
brnoeth_lib.tex(,443) @expansion{}    _[2]=x2
brnoeth_lib.tex(,444) @expansion{} [5]:
brnoeth_lib.tex(,445) @expansion{}    _[1]=xz2+y3
brnoeth_lib.tex(,446) @expansion{}    _[2]=x3
brnoeth_lib.tex(,447) @expansion{} [6]:
brnoeth_lib.tex(,448) @expansion{}    _[1]=xyz2+y4
brnoeth_lib.tex(,449) @expansion{}    _[2]=x4
brnoeth_lib.tex(,450) printlevel=plevel;
brnoeth_lib.tex(,451) @c end example BrillNoether d2t_singular/brnoeth_lib.doc:251
brnoeth_lib.tex(,452) @end smallexample
brnoeth_lib.tex(,453) @c inserted refs from d2t_singular/brnoeth_lib.doc:269
brnoeth_lib.tex(,468) @c end inserted refs from d2t_singular/brnoeth_lib.doc:269
brnoeth_lib.tex(,469) 
brnoeth_lib.tex(,470) @c ---end content BrillNoether---
brnoeth_lib.tex(,471) 
brnoeth_lib.tex(,472) @c ------------------- Weierstrass -------------
brnoeth_lib.tex(,473) @node Weierstrass, extcurve, BrillNoether, brnoeth_lib
brnoeth_lib.tex(,474) @subsubsection Weierstrass
brnoeth_lib.tex(,475) @cindex Weierstrass
brnoeth_lib.tex(,476) @c ---content Weierstrass---
brnoeth_lib.tex(,477) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,478) 
brnoeth_lib.tex(,479) @table @asis
brnoeth_lib.tex(,480) @item @strong{Usage:}
brnoeth_lib.tex(,481) Weierstrass( i, m, CURVE ); i,m integers and CURVE a list
brnoeth_lib.tex(,482) 
brnoeth_lib.tex(,483) @item @strong{Return:}
brnoeth_lib.tex(,484) list WS of two lists:
brnoeth_lib.tex(,485)   @format
brnoeth_lib.tex(,486)   WS[1] list of integers (Weierstr. semigroup of the curve at place i up to m)
brnoeth_lib.tex(,487)   WS[2] list of ideals (the associated rational functions)
brnoeth_lib.tex(,488)   @end format
brnoeth_lib.tex(,489) 
brnoeth_lib.tex(,490) @item @strong{Note:}
brnoeth_lib.tex(,491) The procedure must be called from the ring CURVE[1][2],
brnoeth_lib.tex(,492) where CURVE is the output of the procedure @code{NSplaces}.
brnoeth_lib.tex(,493) @* i represents the place CURVE[3][i].
brnoeth_lib.tex(,494) @* Rational functions are represented by numerator/denominator
brnoeth_lib.tex(,495) in form of ideals with two homogeneous generators.
brnoeth_lib.tex(,496) 
brnoeth_lib.tex(,497) @item @strong{Warning:}
brnoeth_lib.tex(,498) The place must be rational, i.e., necessarily CURVE[3][i][1]=1. @*
brnoeth_lib.tex(,499) 
brnoeth_lib.tex(,500) @end table
brnoeth_lib.tex(,501) @strong{Example:}
brnoeth_lib.tex(,502) @smallexample
brnoeth_lib.tex(,503) @c computed example Weierstrass d2t_singular/brnoeth_lib.doc:306 
brnoeth_lib.tex(,504) LIB "brnoeth.lib";
brnoeth_lib.tex(,505) int plevel=printlevel;
brnoeth_lib.tex(,506) printlevel=-1;
brnoeth_lib.tex(,507) ring s=2,(x,y),lp;
brnoeth_lib.tex(,508) list C=Adj_div(x3y+y3+x);
brnoeth_lib.tex(,509) @expansion{} The genus of the curve is 3
brnoeth_lib.tex(,510) C=NSplaces(1..4,C);
brnoeth_lib.tex(,511) def R=C[1][2];
brnoeth_lib.tex(,512) setring R;
brnoeth_lib.tex(,513) // Place C[3][1] has degree 1 (i.e it is rational);
brnoeth_lib.tex(,514) list WS=Weierstrass(1,7,C);
brnoeth_lib.tex(,515) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,516) // the first part of the list is the Weierstrass semigroup up to 7 :
brnoeth_lib.tex(,517) WS[1];
brnoeth_lib.tex(,518) @expansion{} [1]:
brnoeth_lib.tex(,519) @expansion{}    0
brnoeth_lib.tex(,520) @expansion{} [2]:
brnoeth_lib.tex(,521) @expansion{}    3
brnoeth_lib.tex(,522) @expansion{} [3]:
brnoeth_lib.tex(,523) @expansion{}    5
brnoeth_lib.tex(,524) @expansion{} [4]:
brnoeth_lib.tex(,525) @expansion{}    6
brnoeth_lib.tex(,526) @expansion{} [5]:
brnoeth_lib.tex(,527) @expansion{}    7
brnoeth_lib.tex(,528) // and the second part are the corresponding functions :
brnoeth_lib.tex(,529) WS[2];
brnoeth_lib.tex(,530) @expansion{} [1]:
brnoeth_lib.tex(,531) @expansion{}    _[1]=1
brnoeth_lib.tex(,532) @expansion{}    _[2]=1
brnoeth_lib.tex(,533) @expansion{} [2]:
brnoeth_lib.tex(,534) @expansion{}    _[1]=y
brnoeth_lib.tex(,535) @expansion{}    _[2]=z
brnoeth_lib.tex(,536) @expansion{} [3]:
brnoeth_lib.tex(,537) @expansion{}    _[1]=xy
brnoeth_lib.tex(,538) @expansion{}    _[2]=z2
brnoeth_lib.tex(,539) @expansion{} [4]:
brnoeth_lib.tex(,540) @expansion{}    _[1]=y2
brnoeth_lib.tex(,541) @expansion{}    _[2]=z2
brnoeth_lib.tex(,542) @expansion{} [5]:
brnoeth_lib.tex(,543) @expansion{}    _[1]=y3
brnoeth_lib.tex(,544) @expansion{}    _[2]=xz2
brnoeth_lib.tex(,545) printlevel=plevel;
brnoeth_lib.tex(,546) @c end example Weierstrass d2t_singular/brnoeth_lib.doc:306
brnoeth_lib.tex(,547) @end smallexample
brnoeth_lib.tex(,548) @c inserted refs from d2t_singular/brnoeth_lib.doc:324
brnoeth_lib.tex(,563) @c end inserted refs from d2t_singular/brnoeth_lib.doc:324
brnoeth_lib.tex(,564) 
brnoeth_lib.tex(,565) @c ---end content Weierstrass---
brnoeth_lib.tex(,566) 
brnoeth_lib.tex(,567) @c ------------------- extcurve -------------
brnoeth_lib.tex(,568) @node extcurve, AGcode_L, Weierstrass, brnoeth_lib
brnoeth_lib.tex(,569) @subsubsection extcurve
brnoeth_lib.tex(,570) @cindex extcurve
brnoeth_lib.tex(,571) @c ---content extcurve---
brnoeth_lib.tex(,572) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,573) 
brnoeth_lib.tex(,574) @table @asis
brnoeth_lib.tex(,575) @item @strong{Usage:}
brnoeth_lib.tex(,576) extcurve( d, CURVE ); d an integer, CURVE a list
brnoeth_lib.tex(,577) 
brnoeth_lib.tex(,578) @item @strong{Return:}
brnoeth_lib.tex(,579) list L which is the update of the list CURVE with additional entries
brnoeth_lib.tex(,580)    @format
brnoeth_lib.tex(,581)    L[1][3]: ring (p,a),(x,y),lp (affine),
brnoeth_lib.tex(,582)    L[1][4]: ring (p,a),(x,y,z),lp (projective),
brnoeth_lib.tex(,583)    L[1][5]: ring (p,a),(x,y,t),ls (local),
brnoeth_lib.tex(,584)    L[2][3]: int  (the number of rational places),
brnoeth_lib.tex(,585)    @end format
brnoeth_lib.tex(,586) the rings being defined over a field extension of degree d. @*
brnoeth_lib.tex(,587) If d<2 then @code{extcurve(d,CURVE);} creates a list L which
brnoeth_lib.tex(,588) is the update of the list CURVE with additional entries
brnoeth_lib.tex(,589)    @format
brnoeth_lib.tex(,590)    L[1][5]: ring p,(x,y,t),ls,
brnoeth_lib.tex(,591)    L[2][3]: int  (the number of computed places over the base field).
brnoeth_lib.tex(,592)    @end format
brnoeth_lib.tex(,593) In both cases, in the ring L[1][5] lists with the data for all the
brnoeth_lib.tex(,594) computed rational places (after a field extension of degree d) are
brnoeth_lib.tex(,595) created (see @ref{Adj_div}):
brnoeth_lib.tex(,596)    @format
brnoeth_lib.tex(,597)    lists POINTS, LOC_EQS, BRANCHES, PARAMETRIZATIONS.
brnoeth_lib.tex(,598)    @end format
brnoeth_lib.tex(,599) 
brnoeth_lib.tex(,600) @item @strong{Note:}
brnoeth_lib.tex(,601) The list CURVE should be the output of @code{NSplaces},
brnoeth_lib.tex(,602) and must contain (at least) one place of degree d. @*
brnoeth_lib.tex(,603) You actually need all the places with degree dividing d.
brnoeth_lib.tex(,604) Otherwise, not all the places are computed, but only part of them. @*
brnoeth_lib.tex(,605) This procedure must be executed before constructing AG codes,
brnoeth_lib.tex(,606) even if no extension is needed. The ring L[1][4] must be active
brnoeth_lib.tex(,607) when constructing codes over the field extension.@*
brnoeth_lib.tex(,608) 
brnoeth_lib.tex(,609) @end table
brnoeth_lib.tex(,610) @strong{Example:}
brnoeth_lib.tex(,611) @smallexample
brnoeth_lib.tex(,612) @c computed example extcurve d2t_singular/brnoeth_lib.doc:375 
brnoeth_lib.tex(,613) LIB "brnoeth.lib";
brnoeth_lib.tex(,614) int plevel=printlevel;
brnoeth_lib.tex(,615) printlevel=-1;
brnoeth_lib.tex(,616) ring s=2,(x,y),lp;
brnoeth_lib.tex(,617) list C=Adj_div(x5+y2+y);
brnoeth_lib.tex(,618) @expansion{} The genus of the curve is 2
brnoeth_lib.tex(,619) C=NSplaces(1..4,C);
brnoeth_lib.tex(,620) // since we have all points up to degree 4, we can extend the curve
brnoeth_lib.tex(,621) // to that extension, in order to get rational points over F_16;
brnoeth_lib.tex(,622) C=extcurve(4,C);
brnoeth_lib.tex(,623) @expansion{} Total number of rational places : NrRatPl = 33
brnoeth_lib.tex(,624) // e.g., display the basepoint of place no. 32:
brnoeth_lib.tex(,625) def R=C[1][5];
brnoeth_lib.tex(,626) setring R;
brnoeth_lib.tex(,627) POINTS[32];
brnoeth_lib.tex(,628) @expansion{} [1]:
brnoeth_lib.tex(,629) @expansion{}    (a3+a2+a+1)
brnoeth_lib.tex(,630) @expansion{} [2]:
brnoeth_lib.tex(,631) @expansion{}    (a2+a)
brnoeth_lib.tex(,632) @expansion{} [3]:
brnoeth_lib.tex(,633) @expansion{}    1
brnoeth_lib.tex(,634) printlevel=plevel;
brnoeth_lib.tex(,635) @c end example extcurve d2t_singular/brnoeth_lib.doc:375
brnoeth_lib.tex(,636) @end smallexample
brnoeth_lib.tex(,637) @c inserted refs from d2t_singular/brnoeth_lib.doc:392
brnoeth_lib.tex(,656) @c end inserted refs from d2t_singular/brnoeth_lib.doc:392
brnoeth_lib.tex(,657) 
brnoeth_lib.tex(,658) @c ---end content extcurve---
brnoeth_lib.tex(,659) 
brnoeth_lib.tex(,660) @c ------------------- AGcode_L -------------
brnoeth_lib.tex(,661) @node AGcode_L, AGcode_Omega, extcurve, brnoeth_lib
brnoeth_lib.tex(,662) @subsubsection AGcode_L
brnoeth_lib.tex(,663) @cindex AGcode_L
brnoeth_lib.tex(,664) @c ---content AGcode_L---
brnoeth_lib.tex(,665) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,666) 
brnoeth_lib.tex(,667) @table @asis
brnoeth_lib.tex(,668) @item @strong{Usage:}
brnoeth_lib.tex(,669) AGcode_L( G, D, EC ); G,D intvec, EC a list
brnoeth_lib.tex(,670) 
brnoeth_lib.tex(,671) @item @strong{Return:}
brnoeth_lib.tex(,672) a generator matrix for the evaluation AG code defined by the
brnoeth_lib.tex(,673) divisors G and D.
brnoeth_lib.tex(,674) 
brnoeth_lib.tex(,675) @item @strong{Note:}
brnoeth_lib.tex(,676) The procedure must be called within the ring EC[1][4],
brnoeth_lib.tex(,677) where EC is the output of @code{extcurve(d)} (or within
brnoeth_lib.tex(,678) the ring EC[1][2] if d=1). @*
brnoeth_lib.tex(,679) The entry i in the intvec D refers to the i-th rational
brnoeth_lib.tex(,680) place in EC[1][5] (i.e., to POINTS[i], etc., see @ref{extcurve}).@*
brnoeth_lib.tex(,681) The intvec G represents a rational divisor (see @ref{BrillNoether}
brnoeth_lib.tex(,682) for more details).@*
brnoeth_lib.tex(,683) The code evaluates the vector basis of L(G) at the rational
brnoeth_lib.tex(,684) places given by D.
brnoeth_lib.tex(,685) 
brnoeth_lib.tex(,686) @item @strong{Warnings:}
brnoeth_lib.tex(,687) G should satisfy 
brnoeth_lib.tex(,694) , which is
brnoeth_lib.tex(,695) not checked by the algorithm.
brnoeth_lib.tex(,696) @*G and D should have disjoint supports (checked by the algorithm).
brnoeth_lib.tex(,697) 
brnoeth_lib.tex(,698) @end table
brnoeth_lib.tex(,699) @strong{Example:}
brnoeth_lib.tex(,700) @smallexample
brnoeth_lib.tex(,701) @c computed example AGcode_L d2t_singular/brnoeth_lib.doc:432 
brnoeth_lib.tex(,702) LIB "brnoeth.lib";
brnoeth_lib.tex(,703) int plevel=printlevel;
brnoeth_lib.tex(,704) printlevel=-1;
brnoeth_lib.tex(,705) ring s=2,(x,y),lp;
brnoeth_lib.tex(,706) list HC=Adj_div(x3+y2+y);
brnoeth_lib.tex(,707) @expansion{} The genus of the curve is 1
brnoeth_lib.tex(,708) HC=NSplaces(1..2,HC);
brnoeth_lib.tex(,709) HC=extcurve(2,HC);
brnoeth_lib.tex(,710) @expansion{} Total number of rational places : NrRatPl = 9
brnoeth_lib.tex(,711) def ER=HC[1][4];
brnoeth_lib.tex(,712) setring ER;
brnoeth_lib.tex(,713) intvec G=5;      // the rational divisor G = 5*HC[3][1]
brnoeth_lib.tex(,714) intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
brnoeth_lib.tex(,715) // let us construct the corresponding evaluation AG code :
brnoeth_lib.tex(,716) matrix C=AGcode_L(G,D,HC);
brnoeth_lib.tex(,717) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,718) // here is a linear code of type [8,5,>=3] over F_4
brnoeth_lib.tex(,719) print(C);
brnoeth_lib.tex(,720) @expansion{} 0,0,(a),  (a+1),1,  1,    (a+1),(a),  
brnoeth_lib.tex(,721) @expansion{} 1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),
brnoeth_lib.tex(,722) @expansion{} 1,1,1,    1,    1,  1,    1,    1,    
brnoeth_lib.tex(,723) @expansion{} 0,0,(a+1),(a),  1,  1,    (a),  (a+1),
brnoeth_lib.tex(,724) @expansion{} 0,0,(a+1),(a),  (a),(a+1),1,    1     
brnoeth_lib.tex(,725) printlevel=plevel;
brnoeth_lib.tex(,726) @c end example AGcode_L d2t_singular/brnoeth_lib.doc:432
brnoeth_lib.tex(,727) @end smallexample
brnoeth_lib.tex(,728) @c inserted refs from d2t_singular/brnoeth_lib.doc:451
brnoeth_lib.tex(,745) @c end inserted refs from d2t_singular/brnoeth_lib.doc:451
brnoeth_lib.tex(,746) 
brnoeth_lib.tex(,747) @c ---end content AGcode_L---
brnoeth_lib.tex(,748) 
brnoeth_lib.tex(,749) @c ------------------- AGcode_Omega -------------
brnoeth_lib.tex(,750) @node AGcode_Omega, prepSV, AGcode_L, brnoeth_lib
brnoeth_lib.tex(,751) @subsubsection AGcode_Omega
brnoeth_lib.tex(,752) @cindex AGcode_Omega
brnoeth_lib.tex(,753) @c ---content AGcode_Omega---
brnoeth_lib.tex(,754) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,755) 
brnoeth_lib.tex(,756) @table @asis
brnoeth_lib.tex(,757) @item @strong{Usage:}
brnoeth_lib.tex(,758) AGcode_Omega( G, D, EC ); G,D intvec, EC a list
brnoeth_lib.tex(,759) 
brnoeth_lib.tex(,760) @item @strong{Return:}
brnoeth_lib.tex(,761) a generator matrix for the residual AG code defined by the
brnoeth_lib.tex(,762) divisors G and D.
brnoeth_lib.tex(,763) 
brnoeth_lib.tex(,764) @item @strong{Note:}
brnoeth_lib.tex(,765) The procedure must be called within the ring EC[1][4],
brnoeth_lib.tex(,766) where EC is the output of @code{extcurve(d)} (or within
brnoeth_lib.tex(,767) the ring EC[1][2] if d=1). @*
brnoeth_lib.tex(,768) The entry i in the intvec D refers to the i-th rational
brnoeth_lib.tex(,769) place in EC[1][5] (i.e., to POINTS[i], etc., see @ref{extcurve}).@*
brnoeth_lib.tex(,770) The intvec G represents a rational divisor (see @ref{BrillNoether}
brnoeth_lib.tex(,771) for more details).@*
brnoeth_lib.tex(,772) The code computes the residues of a vector space basis of
brnoeth_lib.tex(,773) 
brnoeth_lib.tex(,780)  at the rational places given by D.
brnoeth_lib.tex(,781) 
brnoeth_lib.tex(,782) @item @strong{Warnings:}
brnoeth_lib.tex(,783) G should satisfy 
brnoeth_lib.tex(,790) , which is
brnoeth_lib.tex(,791) not checked by the algorithm.
brnoeth_lib.tex(,792) @*G and D should have disjoint supports (checked by the algorithm).
brnoeth_lib.tex(,793) 
brnoeth_lib.tex(,794) @end table
brnoeth_lib.tex(,795) @strong{Example:}
brnoeth_lib.tex(,796) @smallexample
brnoeth_lib.tex(,797) @c computed example AGcode_Omega d2t_singular/brnoeth_lib.doc:491 
brnoeth_lib.tex(,798) LIB "brnoeth.lib";
brnoeth_lib.tex(,799) int plevel=printlevel;
brnoeth_lib.tex(,800) printlevel=-1;
brnoeth_lib.tex(,801) ring s=2,(x,y),lp;
brnoeth_lib.tex(,802) list HC=Adj_div(x3+y2+y);
brnoeth_lib.tex(,803) @expansion{} The genus of the curve is 1
brnoeth_lib.tex(,804) HC=NSplaces(1..2,HC);
brnoeth_lib.tex(,805) HC=extcurve(2,HC);
brnoeth_lib.tex(,806) @expansion{} Total number of rational places : NrRatPl = 9
brnoeth_lib.tex(,807) def ER=HC[1][4];
brnoeth_lib.tex(,808) setring ER;
brnoeth_lib.tex(,809) intvec G=5;      // the rational divisor G = 5*HC[3][1]
brnoeth_lib.tex(,810) intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
brnoeth_lib.tex(,811) // let us construct the corresponding residual AG code :
brnoeth_lib.tex(,812) matrix C=AGcode_Omega(G,D,HC);
brnoeth_lib.tex(,813) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,814) // here is a linear code of type [8,3,>=5] over F_4
brnoeth_lib.tex(,815) print(C);
brnoeth_lib.tex(,816) @expansion{} 0,    (a),(a),(a),  (a+1),1,0,  0,
brnoeth_lib.tex(,817) @expansion{} (a+1),1,  (a),0,    (a),  0,(a),0,
brnoeth_lib.tex(,818) @expansion{} (a+1),0,  (a),(a+1),(a+1),0,0,  1 
brnoeth_lib.tex(,819) printlevel=plevel;
brnoeth_lib.tex(,820) @c end example AGcode_Omega d2t_singular/brnoeth_lib.doc:491
brnoeth_lib.tex(,821) @end smallexample
brnoeth_lib.tex(,822) @c inserted refs from d2t_singular/brnoeth_lib.doc:510
brnoeth_lib.tex(,839) @c end inserted refs from d2t_singular/brnoeth_lib.doc:510
brnoeth_lib.tex(,840) 
brnoeth_lib.tex(,841) @c ---end content AGcode_Omega---
brnoeth_lib.tex(,842) 
brnoeth_lib.tex(,843) @c ------------------- prepSV -------------
brnoeth_lib.tex(,844) @node prepSV, decodeSV, AGcode_Omega, brnoeth_lib
brnoeth_lib.tex(,845) @subsubsection prepSV
brnoeth_lib.tex(,846) @cindex prepSV
brnoeth_lib.tex(,847) @c ---content prepSV---
brnoeth_lib.tex(,848) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,849) 
brnoeth_lib.tex(,850) @table @asis
brnoeth_lib.tex(,851) @item @strong{Usage:}
brnoeth_lib.tex(,852) prepSV( G, D, F, EC ); G,D,F intvecs and EC a list
brnoeth_lib.tex(,853) 
brnoeth_lib.tex(,854) @item @strong{Return:}
brnoeth_lib.tex(,855) list E of size n+3, where n=size(D). All its entries but E[n+3]
brnoeth_lib.tex(,856) are matrices:
brnoeth_lib.tex(,857)    @format
brnoeth_lib.tex(,858)    E[1]:  parity check matrix for the current AG code
brnoeth_lib.tex(,859)    E[2] ... E[n+2]:  matrices used in the procedure decodeSV
brnoeth_lib.tex(,860)    E[n+3]:  intvec with
brnoeth_lib.tex(,861)        E[n+3][1]: correction capacity 
brnoeth_lib.tex(,868)  of the algorithm
brnoeth_lib.tex(,869)        E[n+3][2]: designed Goppa distance 
brnoeth_lib.tex(,876)  of the current AG code
brnoeth_lib.tex(,877)    @end format
brnoeth_lib.tex(,878) 
brnoeth_lib.tex(,879) @item @strong{Note:}
brnoeth_lib.tex(,880) Computes the preprocessing for the basic (Skorobogatov-Vladut)
brnoeth_lib.tex(,881) decoding algorithm.@*
brnoeth_lib.tex(,882) The procedure must be called within the ring EC[1][4], where EC is
brnoeth_lib.tex(,883) the output of @code{extcurve(d)} (or in the ring EC[1][2] if d=1) @*
brnoeth_lib.tex(,884) The intvec G and F represent rational divisors (see
brnoeth_lib.tex(,885) @ref{BrillNoether} for more details).@*
brnoeth_lib.tex(,886) The intvec D refers to rational places (see @ref{AGcode_Omega}
brnoeth_lib.tex(,887) for more details.).
brnoeth_lib.tex(,888) The current AG code is @code{AGcode_Omega(G,D,EC)}.@*
brnoeth_lib.tex(,889) If you know the exact minimum distance d and you want to use it in
brnoeth_lib.tex(,890) @code{decodeSV} instead of 
brnoeth_lib.tex(,897) , you can change the value
brnoeth_lib.tex(,898) of E[n+3][2] to d before applying decodeSV.
brnoeth_lib.tex(,899) @*If you have a systematic encoding for the current code and want to
brnoeth_lib.tex(,900) keep it during the decoding, you must previously permute D (using
brnoeth_lib.tex(,901) @code{permute_L(D,P);}), e.g., according to the permutation
brnoeth_lib.tex(,902) P=L[3], L being the output of @code{sys_code}.
brnoeth_lib.tex(,903) 
brnoeth_lib.tex(,904) @item @strong{Warnings:}
brnoeth_lib.tex(,905) F must be a divisor with support disjoint from the support of D and
brnoeth_lib.tex(,906) with degree 
brnoeth_lib.tex(,913) , where
brnoeth_lib.tex(,914) 
brnoeth_lib.tex(,921) .@*
brnoeth_lib.tex(,922) G should satisfy 
brnoeth_lib.tex(,929) , which is
brnoeth_lib.tex(,930) not checked by the algorithm.
brnoeth_lib.tex(,931) @*G and D should also have disjoint supports (checked by the
brnoeth_lib.tex(,932) algorithm).
brnoeth_lib.tex(,933) 
brnoeth_lib.tex(,934) @cindex SV-decoding algorithm, preprocessing
brnoeth_lib.tex(,935) @end table
brnoeth_lib.tex(,936) @strong{Example:}
brnoeth_lib.tex(,937) @smallexample
brnoeth_lib.tex(,938) @c computed example prepSV d2t_singular/brnoeth_lib.doc:569 
brnoeth_lib.tex(,939) LIB "brnoeth.lib";
brnoeth_lib.tex(,940) int plevel=printlevel;
brnoeth_lib.tex(,941) printlevel=-1;
brnoeth_lib.tex(,942) ring s=2,(x,y),lp;
brnoeth_lib.tex(,943) list HC=Adj_div(x3+y2+y);
brnoeth_lib.tex(,944) @expansion{} The genus of the curve is 1
brnoeth_lib.tex(,945) HC=NSplaces(1..2,HC);
brnoeth_lib.tex(,946) HC=extcurve(2,HC);
brnoeth_lib.tex(,947) @expansion{} Total number of rational places : NrRatPl = 9
brnoeth_lib.tex(,948) def ER=HC[1][4];
brnoeth_lib.tex(,949) setring ER;
brnoeth_lib.tex(,950) intvec G=5;      // the rational divisor G = 5*HC[3][1]
brnoeth_lib.tex(,951) intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
brnoeth_lib.tex(,952) // construct the corresp. residual AG code of type [8,3,>=5] over F_4:
brnoeth_lib.tex(,953) matrix C=AGcode_Omega(G,D,HC);
brnoeth_lib.tex(,954) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,955) // we can correct 1 error and the genus is 1, thus F must have degree 2
brnoeth_lib.tex(,956) // and support disjoint from that of D;
brnoeth_lib.tex(,957) intvec F=2;
brnoeth_lib.tex(,958) list SV=prepSV(G,D,F,HC);
brnoeth_lib.tex(,959) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,960) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,961) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,962) // now everything is prepared to decode with the basic algorithm;
brnoeth_lib.tex(,963) // for example, here is a parity check matrix to compute the syndrome :
brnoeth_lib.tex(,964) print(SV[1]);
brnoeth_lib.tex(,965) @expansion{} 0,0,(a),  (a+1),1,  1,    (a+1),(a),  
brnoeth_lib.tex(,966) @expansion{} 1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),
brnoeth_lib.tex(,967) @expansion{} 1,1,1,    1,    1,  1,    1,    1,    
brnoeth_lib.tex(,968) @expansion{} 0,0,(a+1),(a),  1,  1,    (a),  (a+1),
brnoeth_lib.tex(,969) @expansion{} 0,0,(a+1),(a),  (a),(a+1),1,    1     
brnoeth_lib.tex(,970) // and here you have the correction capacity of the algorithm :
brnoeth_lib.tex(,971) int epsilon=SV[size(D)+3][1];
brnoeth_lib.tex(,972) epsilon;
brnoeth_lib.tex(,973) @expansion{} 1
brnoeth_lib.tex(,974) printlevel=plevel;
brnoeth_lib.tex(,975) @c end example prepSV d2t_singular/brnoeth_lib.doc:569
brnoeth_lib.tex(,976) @end smallexample
brnoeth_lib.tex(,977) @c inserted refs from d2t_singular/brnoeth_lib.doc:596
brnoeth_lib.tex(,996) @c end inserted refs from d2t_singular/brnoeth_lib.doc:596
brnoeth_lib.tex(,997) 
brnoeth_lib.tex(,998) @c ---end content prepSV---
brnoeth_lib.tex(,999) 
brnoeth_lib.tex(,1000) @c ------------------- decodeSV -------------
brnoeth_lib.tex(,1001) @node decodeSV, closed_points, prepSV, brnoeth_lib
brnoeth_lib.tex(,1002) @subsubsection decodeSV
brnoeth_lib.tex(,1003) @cindex decodeSV
brnoeth_lib.tex(,1004) @c ---content decodeSV---
brnoeth_lib.tex(,1005) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,1006) 
brnoeth_lib.tex(,1007) @table @asis
brnoeth_lib.tex(,1008) @item @strong{Usage:}
brnoeth_lib.tex(,1009) decodeSV( y, K ); y a row-matrix and K a list
brnoeth_lib.tex(,1010) 
brnoeth_lib.tex(,1011) @item @strong{Return:}
brnoeth_lib.tex(,1012) a codeword (row-matrix) if possible, resp. the 0-matrix (of size
brnoeth_lib.tex(,1013) 1) if decoding is impossible.
brnoeth_lib.tex(,1014) @*For decoding the basic (Skorobogatov-Vladut) decoding algorithm
brnoeth_lib.tex(,1015) is applied.
brnoeth_lib.tex(,1016) 
brnoeth_lib.tex(,1017) @item @strong{Note:}
brnoeth_lib.tex(,1018) The list_expression should be the output K of the procedure
brnoeth_lib.tex(,1019) @code{prepSV}.@*
brnoeth_lib.tex(,1020) The matrix_expression should be a (1 x n)-matrix, where
brnoeth_lib.tex(,1021) n = ncols(K[1]).@*
brnoeth_lib.tex(,1022) The decoding may fail if the number of errors is greater than
brnoeth_lib.tex(,1023) the correction capacity of the algorithm.
brnoeth_lib.tex(,1024) 
brnoeth_lib.tex(,1025) @cindex SV-decoding algorithm
brnoeth_lib.tex(,1026) @end table
brnoeth_lib.tex(,1027) @strong{Example:}
brnoeth_lib.tex(,1028) @smallexample
brnoeth_lib.tex(,1029) @c computed example decodeSV d2t_singular/brnoeth_lib.doc:631 
brnoeth_lib.tex(,1030) LIB "brnoeth.lib";
brnoeth_lib.tex(,1031) int plevel=printlevel;
brnoeth_lib.tex(,1032) printlevel=-1;
brnoeth_lib.tex(,1033) ring s=2,(x,y),lp;
brnoeth_lib.tex(,1034) list HC=Adj_div(x3+y2+y);
brnoeth_lib.tex(,1035) @expansion{} The genus of the curve is 1
brnoeth_lib.tex(,1036) HC=NSplaces(1..2,HC);
brnoeth_lib.tex(,1037) HC=extcurve(2,HC);
brnoeth_lib.tex(,1038) @expansion{} Total number of rational places : NrRatPl = 9
brnoeth_lib.tex(,1039) def ER=HC[1][4];
brnoeth_lib.tex(,1040) setring ER;
brnoeth_lib.tex(,1041) intvec G=5;      // the rational divisor G = 5*HC[3][1]
brnoeth_lib.tex(,1042) intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
brnoeth_lib.tex(,1043) // construct the corresp. residual AG code of type [8,3,>=5] over F_4:
brnoeth_lib.tex(,1044) matrix C=AGcode_Omega(G,D,HC);
brnoeth_lib.tex(,1045) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,1046) // we can correct 1 error and the genus is 1, thus F must have degree 2
brnoeth_lib.tex(,1047) // and support disjoint from that of D
brnoeth_lib.tex(,1048) intvec F=2;
brnoeth_lib.tex(,1049) list SV=prepSV(G,D,F,HC);
brnoeth_lib.tex(,1050) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,1051) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,1052) @expansion{} Vector basis successfully computed 
brnoeth_lib.tex(,1053) // now we produce 1 error on the zero-codeword :
brnoeth_lib.tex(,1054) matrix y[1][8];
brnoeth_lib.tex(,1055) y[1,3]=a;
brnoeth_lib.tex(,1056) // and then we decode :
brnoeth_lib.tex(,1057) print(decodeSV(y,SV));
brnoeth_lib.tex(,1058) @expansion{} 0,0,0,0,0,0,0,0
brnoeth_lib.tex(,1059) printlevel=plevel;
brnoeth_lib.tex(,1060) @c end example decodeSV d2t_singular/brnoeth_lib.doc:631
brnoeth_lib.tex(,1061) @end smallexample
brnoeth_lib.tex(,1062) @c inserted refs from d2t_singular/brnoeth_lib.doc:657
brnoeth_lib.tex(,1077) @c end inserted refs from d2t_singular/brnoeth_lib.doc:657
brnoeth_lib.tex(,1078) 
brnoeth_lib.tex(,1079) @c ---end content decodeSV---
brnoeth_lib.tex(,1080) 
brnoeth_lib.tex(,1081) @c ------------------- closed_points -------------
brnoeth_lib.tex(,1082) @node closed_points, dual_code, decodeSV, brnoeth_lib
brnoeth_lib.tex(,1083) @subsubsection closed_points
brnoeth_lib.tex(,1084) @cindex closed_points
brnoeth_lib.tex(,1085) @c ---content closed_points---
brnoeth_lib.tex(,1086) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,1087) 
brnoeth_lib.tex(,1088) @table @asis
brnoeth_lib.tex(,1089) @item @strong{Usage:}
brnoeth_lib.tex(,1090) closed_points(I); I an ideal
brnoeth_lib.tex(,1091) 
brnoeth_lib.tex(,1092) @item @strong{Return:}
brnoeth_lib.tex(,1093) list of prime ideals (each a Groebner basis), corresponding to
brnoeth_lib.tex(,1094) the (distinct affine closed) points of V(I)
brnoeth_lib.tex(,1095) 
brnoeth_lib.tex(,1096) @item @strong{Note:}
brnoeth_lib.tex(,1097) The ideal must have dimension 0, the basering must have 2
brnoeth_lib.tex(,1098) variables, the ordering must be lp, and the base field must
brnoeth_lib.tex(,1099) be finite and prime.@*
brnoeth_lib.tex(,1100) It might be convenient to set the option(redSB) in advance.
brnoeth_lib.tex(,1101) 
brnoeth_lib.tex(,1102) @end table
brnoeth_lib.tex(,1103) @strong{Example:}
brnoeth_lib.tex(,1104) @smallexample
brnoeth_lib.tex(,1105) @c computed example closed_points d2t_singular/brnoeth_lib.doc:687 
brnoeth_lib.tex(,1106) LIB "brnoeth.lib";
brnoeth_lib.tex(,1107) ring s=2,(x,y),lp;
brnoeth_lib.tex(,1108) // this is just the affine plane over F_4 :
brnoeth_lib.tex(,1109) ideal I=x4+x,y4+y;
brnoeth_lib.tex(,1110) list L=closed_points(I);
brnoeth_lib.tex(,1111) // and here you have all the points :
brnoeth_lib.tex(,1112) L;
brnoeth_lib.tex(,1113) @expansion{} [1]:
brnoeth_lib.tex(,1114) @expansion{}    _[1]=y2+y+1
brnoeth_lib.tex(,1115) @expansion{}    _[2]=x+y
brnoeth_lib.tex(,1116) @expansion{} [2]:
brnoeth_lib.tex(,1117) @expansion{}    _[1]=y2+y+1
brnoeth_lib.tex(,1118) @expansion{}    _[2]=x+1
brnoeth_lib.tex(,1119) @expansion{} [3]:
brnoeth_lib.tex(,1120) @expansion{}    _[1]=y2+y+1
brnoeth_lib.tex(,1121) @expansion{}    _[2]=x+y+1
brnoeth_lib.tex(,1122) @expansion{} [4]:
brnoeth_lib.tex(,1123) @expansion{}    _[1]=y2+y+1
brnoeth_lib.tex(,1124) @expansion{}    _[2]=x
brnoeth_lib.tex(,1125) @expansion{} [5]:
brnoeth_lib.tex(,1126) @expansion{}    _[1]=y+1
brnoeth_lib.tex(,1127) @expansion{}    _[2]=x2+x+1
brnoeth_lib.tex(,1128) @expansion{} [6]:
brnoeth_lib.tex(,1129) @expansion{}    _[1]=y+1
brnoeth_lib.tex(,1130) @expansion{}    _[2]=x+1
brnoeth_lib.tex(,1131) @expansion{} [7]:
brnoeth_lib.tex(,1132) @expansion{}    _[1]=y+1
brnoeth_lib.tex(,1133) @expansion{}    _[2]=x
brnoeth_lib.tex(,1134) @expansion{} [8]:
brnoeth_lib.tex(,1135) @expansion{}    _[1]=y
brnoeth_lib.tex(,1136) @expansion{}    _[2]=x2+x+1
brnoeth_lib.tex(,1137) @expansion{} [9]:
brnoeth_lib.tex(,1138) @expansion{}    _[1]=y
brnoeth_lib.tex(,1139) @expansion{}    _[2]=x+1
brnoeth_lib.tex(,1140) @expansion{} [10]:
brnoeth_lib.tex(,1141) @expansion{}    _[1]=y
brnoeth_lib.tex(,1142) @expansion{}    _[2]=x
brnoeth_lib.tex(,1143) @c end example closed_points d2t_singular/brnoeth_lib.doc:687
brnoeth_lib.tex(,1144) @end smallexample
brnoeth_lib.tex(,1145) @c inserted refs from d2t_singular/brnoeth_lib.doc:697
brnoeth_lib.tex(,1156) @c end inserted refs from d2t_singular/brnoeth_lib.doc:697
brnoeth_lib.tex(,1157) 
brnoeth_lib.tex(,1158) @c ---end content closed_points---
brnoeth_lib.tex(,1159) 
brnoeth_lib.tex(,1160) @c ------------------- dual_code -------------
brnoeth_lib.tex(,1161) @node dual_code, sys_code, closed_points, brnoeth_lib
brnoeth_lib.tex(,1162) @subsubsection dual_code
brnoeth_lib.tex(,1163) @cindex dual_code
brnoeth_lib.tex(,1164) @c ---content dual_code---
brnoeth_lib.tex(,1165) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,1166) 
brnoeth_lib.tex(,1167) @table @asis
brnoeth_lib.tex(,1168) @item @strong{Usage:}
brnoeth_lib.tex(,1169) dual_code(G); G a matrix of numbers
brnoeth_lib.tex(,1170) 
brnoeth_lib.tex(,1171) @item @strong{Return:}
brnoeth_lib.tex(,1172) a generator matrix of the dual code generated by G
brnoeth_lib.tex(,1173) 
brnoeth_lib.tex(,1174) @item @strong{Note:}
brnoeth_lib.tex(,1175) The input should be a matrix G of numbers. @*
brnoeth_lib.tex(,1176) The output is also a parity check matrix for the code defined by G
brnoeth_lib.tex(,1177) 
brnoeth_lib.tex(,1178) @cindex linear code, dual
brnoeth_lib.tex(,1179) @end table
brnoeth_lib.tex(,1180) @strong{Example:}
brnoeth_lib.tex(,1181) @smallexample
brnoeth_lib.tex(,1182) @c computed example dual_code d2t_singular/brnoeth_lib.doc:725 
brnoeth_lib.tex(,1183) LIB "brnoeth.lib";
brnoeth_lib.tex(,1184) ring s=2,T,lp;
brnoeth_lib.tex(,1185) // here is the Hamming code of length 7 and dimension 3
brnoeth_lib.tex(,1186) matrix G[3][7]=1,0,1,0,1,0,1,0,1,1,0,0,1,1,0,0,0,1,1,1,1;
brnoeth_lib.tex(,1187) print(G);
brnoeth_lib.tex(,1188) @expansion{} 1,0,1,0,1,0,1,
brnoeth_lib.tex(,1189) @expansion{} 0,1,1,0,0,1,1,
brnoeth_lib.tex(,1190) @expansion{} 0,0,0,1,1,1,1 
brnoeth_lib.tex(,1191) matrix H=dual_code(G);
brnoeth_lib.tex(,1192) print(H);
brnoeth_lib.tex(,1193) @expansion{} 1,1,1,0,0,0,0,
brnoeth_lib.tex(,1194) @expansion{} 1,0,0,1,1,0,0,
brnoeth_lib.tex(,1195) @expansion{} 0,1,0,1,0,1,0,
brnoeth_lib.tex(,1196) @expansion{} 1,1,0,1,0,0,1 
brnoeth_lib.tex(,1197) @c end example dual_code d2t_singular/brnoeth_lib.doc:725
brnoeth_lib.tex(,1198) @end smallexample
brnoeth_lib.tex(,1199) @c ---end content dual_code---
brnoeth_lib.tex(,1200) 
brnoeth_lib.tex(,1201) @c ------------------- sys_code -------------
brnoeth_lib.tex(,1202) @node sys_code, permute_L, dual_code, brnoeth_lib
brnoeth_lib.tex(,1203) @subsubsection sys_code
brnoeth_lib.tex(,1204) @cindex sys_code
brnoeth_lib.tex(,1205) @c ---content sys_code---
brnoeth_lib.tex(,1206) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,1207) 
brnoeth_lib.tex(,1208) @table @asis
brnoeth_lib.tex(,1209) @item @strong{Usage:}
brnoeth_lib.tex(,1210) sys_code(C); C is a matrix of constants
brnoeth_lib.tex(,1211) 
brnoeth_lib.tex(,1212) @item @strong{Return:}
brnoeth_lib.tex(,1213) list L with:
brnoeth_lib.tex(,1214)    @format
brnoeth_lib.tex(,1215)    L[1] is the generator matrix in standard form of an equivalent code,
brnoeth_lib.tex(,1216)    L[2] is the parity check matrix in standard form of such code,
brnoeth_lib.tex(,1217)    L[3] is an intvec which represents the needed permutation.
brnoeth_lib.tex(,1218)    @end format
brnoeth_lib.tex(,1219) 
brnoeth_lib.tex(,1220) @item @strong{Note:}
brnoeth_lib.tex(,1221) Computes a systematic code which is equivalent to the given one.@*
brnoeth_lib.tex(,1222) The input should be a matrix of numbers.@*
brnoeth_lib.tex(,1223) The output has to be interpreted as follows: if the input was
brnoeth_lib.tex(,1224) the generator matrix of an AG code then one should apply the
brnoeth_lib.tex(,1225) permutation L[3] to the divisor D of rational points by means
brnoeth_lib.tex(,1226) of @code{permute_L(D,L[3]);} before continuing to work with the
brnoeth_lib.tex(,1227) code (for instance, if you want to use the systematic encoding
brnoeth_lib.tex(,1228) together with a decoding algorithm).
brnoeth_lib.tex(,1229) 
brnoeth_lib.tex(,1230) @cindex linear code, systematic
brnoeth_lib.tex(,1231) @end table
brnoeth_lib.tex(,1232) @strong{Example:}
brnoeth_lib.tex(,1233) @smallexample
brnoeth_lib.tex(,1234) @c computed example sys_code d2t_singular/brnoeth_lib.doc:770 
brnoeth_lib.tex(,1235) LIB "brnoeth.lib";
brnoeth_lib.tex(,1236) ring s=3,T,lp;
brnoeth_lib.tex(,1237) matrix C[2][5]=0,1,0,1,1,0,1,0,0,1;
brnoeth_lib.tex(,1238) print(C);
brnoeth_lib.tex(,1239) @expansion{} 0,1,0,1,1,
brnoeth_lib.tex(,1240) @expansion{} 0,1,0,0,1 
brnoeth_lib.tex(,1241) list L=sys_code(C);
brnoeth_lib.tex(,1242) L[3];
brnoeth_lib.tex(,1243) @expansion{} 2,4,3,1,5
brnoeth_lib.tex(,1244) // here is the generator matrix in standard form
brnoeth_lib.tex(,1245) print(L[1]);
brnoeth_lib.tex(,1246) @expansion{} 1,0,0,0,1,
brnoeth_lib.tex(,1247) @expansion{} 0,1,0,0,0 
brnoeth_lib.tex(,1248) // here is the control matrix in standard form
brnoeth_lib.tex(,1249) print(L[2]);
brnoeth_lib.tex(,1250) @expansion{} 0, 0,1,0,0,
brnoeth_lib.tex(,1251) @expansion{} 0, 0,0,1,0,
brnoeth_lib.tex(,1252) @expansion{} -1,0,0,0,1 
brnoeth_lib.tex(,1253) // we can check that both codes are dual to each other
brnoeth_lib.tex(,1254) print(L[1]*transpose(L[2]));
brnoeth_lib.tex(,1255) @expansion{} 0,0,0,
brnoeth_lib.tex(,1256) @expansion{} 0,0,0 
brnoeth_lib.tex(,1257) @c end example sys_code d2t_singular/brnoeth_lib.doc:770
brnoeth_lib.tex(,1258) @end smallexample
brnoeth_lib.tex(,1259) @c inserted refs from d2t_singular/brnoeth_lib.doc:785
brnoeth_lib.tex(,1274) @c end inserted refs from d2t_singular/brnoeth_lib.doc:785
brnoeth_lib.tex(,1275) 
brnoeth_lib.tex(,1276) @c ---end content sys_code---
brnoeth_lib.tex(,1277) 
brnoeth_lib.tex(,1278) @c ------------------- permute_L -------------
brnoeth_lib.tex(,1279) @node permute_L,, sys_code, brnoeth_lib
brnoeth_lib.tex(,1280) @subsubsection permute_L
brnoeth_lib.tex(,1281) @cindex permute_L
brnoeth_lib.tex(,1282) @c ---content permute_L---
brnoeth_lib.tex(,1283) Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).
brnoeth_lib.tex(,1284) 
brnoeth_lib.tex(,1285) @table @asis
brnoeth_lib.tex(,1286) @item @strong{Usage:}
brnoeth_lib.tex(,1287) permute_L( L, P ); L,P either intvecs or lists
brnoeth_lib.tex(,1288) 
brnoeth_lib.tex(,1289) @item @strong{Return:}
brnoeth_lib.tex(,1290) list obtained from L by applying the permutation given by P.
brnoeth_lib.tex(,1291) 
brnoeth_lib.tex(,1292) @item @strong{Note:}
brnoeth_lib.tex(,1293) If P is a list, all entries must be integers.
brnoeth_lib.tex(,1294) 
brnoeth_lib.tex(,1295) @end table
brnoeth_lib.tex(,1296) @strong{Example:}
brnoeth_lib.tex(,1297) @smallexample
brnoeth_lib.tex(,1298) @c computed example permute_L d2t_singular/brnoeth_lib.doc:811 
brnoeth_lib.tex(,1299) LIB "brnoeth.lib";
brnoeth_lib.tex(,1300) list L=list();
brnoeth_lib.tex(,1301) L[1]="a";
brnoeth_lib.tex(,1302) L[2]="b";
brnoeth_lib.tex(,1303) L[3]="c";
brnoeth_lib.tex(,1304) L[4]="d";
brnoeth_lib.tex(,1305) intvec P=1,3,4,2;
brnoeth_lib.tex(,1306) // the list L is permuted according to P :
brnoeth_lib.tex(,1307) permute_L(L,P);
brnoeth_lib.tex(,1308) @expansion{} [1]:
brnoeth_lib.tex(,1309) @expansion{}    a
brnoeth_lib.tex(,1310) @expansion{} [2]:
brnoeth_lib.tex(,1311) @expansion{}    c
brnoeth_lib.tex(,1312) @expansion{} [3]:
brnoeth_lib.tex(,1313) @expansion{}    d
brnoeth_lib.tex(,1314) @expansion{} [4]:
brnoeth_lib.tex(,1315) @expansion{}    b
brnoeth_lib.tex(,1316) @c end example permute_L d2t_singular/brnoeth_lib.doc:811
brnoeth_lib.tex(,1317) @end smallexample
brnoeth_lib.tex(,1318) @c inserted refs from d2t_singular/brnoeth_lib.doc:823
brnoeth_lib.tex(,1333) @c end inserted refs from d2t_singular/brnoeth_lib.doc:823
brnoeth_lib.tex(,1334) 
brnoeth_lib.tex(,1335) @c ---end content permute_L---
singular.texi(,618) @c ----------------------------------------------------------
singular.texi(,619) @node Release Notes, Index, SINGULAR libraries, Top
singular.texi(,620) @chapter Release Notes
singular.texi(,621) @cindex Release Notes
platform.tex(,1) @comment -*-texinfo-*-
platform.tex(,2) @comment This file was generated by doc2tex.pl from platform.doc
platform.tex(,3) @comment DO NOT EDIT DIRECTLY, BUT EDIT platform.doc INSTEAD
platform.tex(,4) @comment Id: platform.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
platform.tex(,5) @comment this file contains Release notes and various howto's
platform.tex(,6) 
platform.tex(,7) @c The following directives are necessary for proper compilation
platform.tex(,8) @c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
platform.tex(,9) @c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
platform.tex(,10) @c `makeinfo' but is a great help in editing this file (emacs
platform.tex(,11) @c ignores the `@ignore').
platform.tex(,24) 
platform.tex(,25) @menu
platform.tex(,26) * News and changes::
platform.tex(,27) * Downloading instructions::
platform.tex(,28) * Unix installation instructions::
platform.tex(,29) * Windows installation instructions::
platform.tex(,30) * Macintosh installation instructions::
platform.tex(,31) @end menu
platform.tex(,32) 
platform.tex(,33) @c ----------------------------------------------------------
platform.tex(,34) @node News and changes, Downloading instructions,,Release Notes
platform.tex(,35) @section News and changes
platform.tex(,36) @cindex news
platform.tex(,37) @cindex changes
platform.tex(,38) 
NEWS.texi(,1) @comment -*-texinfo-*-
NEWS.texi(,2) @comment Id: NEWS.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
NEWS.texi(,3) @comment this file contains the News about Singular versions
NEWS.texi(,4) @comment Unix
NEWS.texi(,8) 
NEWS.texi(,9) @majorheading NEWS in SINGULAR 2-0-4
NEWS.texi(,10) 
NEWS.texi(,16) 
NEWS.texi(,22) 
NEWS.texi(,23) The current version 2-0-4 is an update to the 
NEWS.texi(,24) release series version 2-0. 
NEWS.texi(,25) 
NEWS.texi(,26) Changes with respect to version 2-0-3:
NEWS.texi(,27) 
NEWS.texi(,28) @heading Factorizing algorithms revisited
NEWS.texi(,29) Starting with version 2-0-4, we use NTL (by Victor Shoup) for factoring
NEWS.texi(,30) univariate polynomials. The multivariate factoring code in libfac/factory
NEWS.texi(,31) does now also work over algebraic extension fields.
NEWS.texi(,32) 
NEWS.texi(,33) @heading Help system is configurable via LIB/help.cnf
NEWS.texi(,34) The help browsers of Singular can be configured via the file
NEWS.texi(,35) LIB/help.cnf, also the addition of new help browsers is possible.
NEWS.texi(,36) 
NEWS.texi(,37) @heading Extensions of the ring concept
NEWS.texi(,38) 
NEWS.texi(,39) @table @asis
NEWS.texi(,40) @item new coefficient domains: arbitrary long real and complex numbers
NEWS.texi(,41) @item no restriction on number of parameters
NEWS.texi(,42) @item degree bound on exponent values (maximum is now 2^31, standard 2^15)
NEWS.texi(,43) @item non-positives weights get a better handling (converts wp/Wp to ws/Ws)
NEWS.texi(,44) @item handle blocks of mixed orders correctly
NEWS.texi(,45) @item maximal prime characteristic is now 2147483629 instead of 32003
NEWS.texi(,46) @c @item TBC: parameters over real/complex
NEWS.texi(,47) @c @item TBC: declaration with "ring of ring".
NEWS.texi(,48) @end table
NEWS.texi(,49) 
NEWS.texi(,50) @heading Changes in @sc{Singular} libraries
NEWS.texi(,51) The documentation of libraries was generally improved.
NEWS.texi(,52) @table @asis
NEWS.texi(nref,53) @item @ref{equising_lib}
NEWS.texi(,54) procedures esStratum, isEquising now also for reducible polynomials
NEWS.texi(,55) @*new procedures: tau_es (codim of mu-const stratum in semi-universal def. base);
NEWS.texi(,56) esIdeal ((Wahl's) equisingularity ideal)
NEWS.texi(nref,57) @item @ref{gaussman_lib}
NEWS.texi(,58) added bernstein: roots of the Bernstein polynomial of t
NEWS.texi(nref,59) @item @ref{hnoether_lib}
NEWS.texi(,60) HNdevelop, reddevelop, essdevelop are obsolete, replaced by hnexpansion
NEWS.texi(,61) @*multsequence is "repaired" (since branches computed by hnexpansion
NEWS.texi(,62) et al) are now ordered according to the needs of multsequence.
NEWS.texi(,63) @*newtonpoly needs no longer that ordering of the basering is ls
NEWS.texi(,64) @*new procedures: is_NND      test if f is Newton non-degenerate
NEWS.texi(nref,65) @item @ref{homolog_lib}
NEWS.texi(,66) new procedures: depth, fitting, flatteningStrat, isCM, isFlat, isLocallyFree,
NEWS.texi(,67) isReg, KoszulHomology, tensorMod, Tor
NEWS.texi(nref,68) @item @ref{matrix_lib}
NEWS.texi(,69) in proc tensor(A,B):  check if ncols(A)==0
NEWS.texi(nref,70) @item @ref{normal_lib}
NEWS.texi(,71) new procedure: deltaLoc(f,S);      (sum of) delta invariant(s) at conjugated
NEWS.texi(,72) singular points
NEWS.texi(,73) @*proc genus makes now use of is_NND of hnoether.lib
NEWS.texi(nref,74) @item @ref{primdec_lib}
NEWS.texi(,75) optimizations again
NEWS.texi(nref,76) @item @ref{solve_lib}
NEWS.texi(,77) procedure laguerre_solve ignores no longer the 2nd parameter (precision of 
NEWS.texi(,78) internal computation)
NEWS.texi(,79) @* new procedure simplexOut:     prints solution of simplex in nice format
NEWS.texi(,80) @end table
NEWS.texi(,81) 
NEWS.texi(,82) @heading Internal Changes
NEWS.texi(,83) @table @asis
NEWS.texi(,84) @item normal form computation uses
NEWS.texi(,85) Bucket representation of polynomials.
NEWS.texi(,86) @item factorization
NEWS.texi(,87) revisited, missing cases implemented
NEWS.texi(,88) @item NTL
NEWS.texi(,89) NTL is used for univariate factorization
NEWS.texi(,90) @item source code
NEWS.texi(,91) adapted for use with gcc 3.1/3.2, gmp 4.x
NEWS.texi(,92) @end table
NEWS.texi(,93) 
NEWS.texi(,94) @heading Porting
NEWS.texi(,95) @itemize @bullet
NEWS.texi(,96) @item Singular is available for ix86-libc5, ix86-libc6, HPUX_9, HPUX_10,
NEWS.texi(,97) SunOS-4, SunOS-5, IRIX-6, ix86-Win (Windows 95/98/ME/NT/2K/XP),
NEWS.texi(,98) FreeBSD 4.x, MacOS X
NEWS.texi(,99) @c @item @code{dbm} functionality is not available on 
NEWS.texi(,100) Windows 95/98/ME/NT/2K/XP and MacOS X
NEWS.texi(,101) @item @code{MP} functionality is not available on
NEWS.texi(,102) Windows 95/98/ME/NT/2K/XP and MacOS X.
NEWS.texi(,103) @item Singular 2-0-2 was the last version for MacOS 9
NEWS.texi(,104) @end itemize
platform.tex(,40) 
platform.tex(,41) @c ----------------------------------------------------------
platform.tex(,42) @node Downloading instructions, Unix installation instructions, News and changes, Release Notes
platform.tex(,43) @section Downloading instructions
platform.tex(,44) @cindex downloading
platform.tex(,45) @cindex instructions, downloading
platform.tex(,46) @cindex howto, download
platform.tex(,47) 
platform.tex(,48) @sc{Singular} is available as binary program for most common hard-
platform.tex(,49) and software platforms. Release versions of @sc{Singular} can be
platform.tex(,50) downloaded with ftp from our FTP site
platform.tex(,51) @display
platform.tex(,52) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/},
platform.tex(,53) @end display
platform.tex(,54) or, using your favorite WWW browser, from
platform.tex(,55) @display
platform.tex(,56) @uref{http://www.mathematik.uni-kl.de/ftp/pub/Math/Singular/}.
platform.tex(,57) @end display
platform.tex(,58) 
README_download.texi(,1) @comment -*-texinfo-*-
README_download.texi(,2) @comment Id: README_download.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
README_download.texi(,3) @c FILE: README_download.texi
README_download.texi(,4) @c PURPOSE: downloading instructions, to be includeded in manual and README_ftp
README_download.texi(,5) @c
README_download.texi(,6) 
README_download.texi(,10) 
README_download.texi(,11) @heading To download @sc{Singular} for a Unix platform
README_download.texi(,12) 
README_download.texi(,13) Make sure that you have approximately 20 MByte of free disk space and follow
README_download.texi(,14) these steps.
README_download.texi(,15) 
README_download.texi(,16) @enumerate
README_download.texi(,17) @item
README_download.texi(,18) You need to download two (archive) files:
README_download.texi(,19) @table @code
README_download.texi(,20) @item Singular-2-0-4-share.tar.gz 
README_download.texi(,21) contains architecture independent data like documentation and libraries
README_download.texi(,22) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-share.tar.gz}
README_download.texi(,23) @item Singular-2-0-4-<uname>.tar.gz
README_download.texi(,24) contains architecture dependent executables, like the @sc{Singular}
README_download.texi(,25) program.
README_download.texi(,26) @end table
README_download.texi(,27) @code{<uname>} is a description of the processor and operating
README_download.texi(,28) system for which @sc{Singular} is compiled. Choose one of the following:
README_download.texi(,29) @multitable @columnfractions .2 .8
README_download.texi(,30) @item @code{ix86-Linux}
README_download.texi(,31) @tab PC's running under Linux with @code{libc} version 6 (e.g., for SuSe
README_download.texi(,32) Linux distribution version >= 6; RedHat Linux distribution version >= 5.2).
README_download.texi(,33) @*
README_download.texi(,34) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-Linux.tar.gz}
README_download.texi(,35) @item @code{ix86-Linux-libc5}
README_download.texi(,36) @tab PC's running under Linux with @code{libc} version 5 (if you are not 
README_download.texi(,37) sure which @code{libc} version you have, run @code{ldd /bin/ls}).
README_download.texi(,38) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-Linux-libc5.tar.gz}
README_download.texi(,39) @item @code{ix86-freebsd}
README_download.texi(,40) @tab 's running under FreeBSD
README_download.texi(,41) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-freebsd.tar.gz}
README_download.texi(,42) @item @code{ix86-Win}
README_download.texi(,43) @tab PC's running Windows 95/98/ME/NT/2K/XP which have Cygwin version 1.3.9 (or
README_download.texi(,44) higher) already installed. Unless you are familiar with Cygwin, we
README_download.texi(,45) recommend that you download one of the self-extracting archives as
README_download.texi(,46) described below.
README_download.texi(,47) @item @code{HPUX-9}
README_download.texi(,48) @tab HP workstations running under HPUX version 9
README_download.texi(,49) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-HPUX-9.tar.gz}
README_download.texi(,50) @item @code{HPUX-10}
README_download.texi(,51) @tab HP workstations running under HPUX version 10
README_download.texi(,52) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-HPUX-10.tar.gz}
README_download.texi(,53) @item @code{SunOS-5}
README_download.texi(,54) @tab Sun workstations running Solaris version 5
README_download.texi(,55) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-SunOS-5.tar.gz}
README_download.texi(,56) @item @code{IRIX-6}
README_download.texi(,57) @tab IRIX workstations running IRIX version 6
README_download.texi(,58) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-IRIX-6.tar.gz}
README_download.texi(,59) @item @code{AIX-4}
README_download.texi(,60) @tab AIX workstations running AIX version 4
README_download.texi(,61) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-AIX-4.tar.gz}
README_download.texi(,62) @item @code{PowerMacintosh-darwin}
README_download.texi(,63) @tab PowerMacintosh running Mac OS X
README_download.texi(,64) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/OsX/Singular-2-0-4-PowerMacintosh-darwin.tar.gz}
README_download.texi(,65) @item @code{DecAlpha-Linux}
README_download.texi(,66) @tab Digital Dec Alpha running Linux (RedHat 5.2)
README_download.texi(,67) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-DecAlpha-Linux.tar.gz}
README_download.texi(,68) @item @code{DecAlpha-OSF1}
README_download.texi(,69) @tab Digital Dec Alpha running OSF 1
README_download.texi(,70) @*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-DecAlpha-OSF1.tar.gz}
README_download.texi(,71) @end multitable
README_download.texi(,72) Please contact us if
README_download.texi(,73) you can not find an appropriate architecture dependent archive.
README_download.texi(,74) 
README_download.texi(,75) @item
README_download.texi(,76) Simply change to the directory in which you wish to install
README_download.texi(,77) @sc{Singular} (usually wherever you install 3rd-party software):
README_download.texi(,78) @smallexample
README_download.texi(,79) cd /usr/local/	
README_download.texi(,80) @end smallexample
README_download.texi(,81) 
README_download.texi(,82) @sc{Singular} specific subdirectories will be created in such a way
README_download.texi(,83) that multiple versions and multiple architecture dependent files
README_download.texi(,84) of @sc{Singular} can peaceably coexist under the same @code{/usr/local/}
README_download.texi(,85) tree.
README_download.texi(,86) 
README_download.texi(,87) @item
README_download.texi(,88) Unpack the archives:
README_download.texi(,89) @smallexample
README_download.texi(,90) gzip -dc Singular-2-0-4-<uname>.tar.gz | tar -pxf -
README_download.texi(,91) gzip -dc Singular-2-0-4-share.tar.gz | tar -pxf -
README_download.texi(,92) @end smallexample
README_download.texi(,93) If you have downloaded @code{Singular-2-0-4-share.zip},
README_download.texi(,94) unpack with 
README_download.texi(,95) @smallexample
README_download.texi(,96) unzip -u Singular-2-0-4-share.zip
README_download.texi(,97) @end smallexample
README_download.texi(,98) 
README_download.texi(,99) @item 
README_download.texi(,100) After unpacking, see the created file
README_download.texi(,101) @code{Singular/2-0-4/INSTALL} (which is also located at
README_download.texi(,102) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/INSTALL_unix.html}
README_download.texi(,103) for details on how to finish the installation.
README_download.texi(,104) @end enumerate
README_download.texi(,105) 
README_download.texi(,106) @heading To download @sc{Singular} for Windows 95/98/ME/NT/2K/XP
README_download.texi(,107) 
README_download.texi(,108) @enumerate
README_download.texi(,109) @item
README_download.texi(,110) Download one of the following self-extracting archives:
README_download.texi(,111) @table @code
README_download.texi(,112) @item @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/Singular-2-0-4-Compact.exe,Singular-2-0-4-Compact.exe}
README_download.texi(,113) Minimal archive to download. Installs Singular and minimal set of needed
README_download.texi(,114) tools and DLLs.
README_download.texi(,115) @item @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/Singular-2-0-4-Typical.exe,Singular-2-0-4-Typical.exe}
README_download.texi(,116) Typical archive to download. Installs Singular and the XEmacs editor to
README_download.texi(,117) run ESingular.
README_download.texi(,118) @end table
README_download.texi(,119) 
README_download.texi(,120) @item 
README_download.texi(,121) Double-click (or, execute), the self-extracting archives, and
README_download.texi(,122) @strong{carefully} follow the instructions given there.
README_download.texi(,123) 
README_download.texi(,124) @item 
README_download.texi(,125) If, while running setup, you obtain the following message 
README_download.texi(,126) @code{Setup failed to launch installation engine:} 
README_download.texi(,127) @code{Error loading type library/DLL}, then you need to download and execute Microsoft DCOM98 package
README_download.texi(,128) @uref{http://www.microsoft.com/com/dcom/dcom98/download.asp}. 
README_download.texi(,129) Such a problem could appear on Win 95/98.
README_download.texi(,130) 
README_download.texi(,131) @item
README_download.texi(,132) In case of problems, see the created file 
README_download.texi(,133) @code{/etc/INSTALL.txt} (which is also located at
README_download.texi(,134) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/INSTALL_win.htm}
README_download.texi(,135) for details on how to finish the installation.
README_download.texi(,136) @end enumerate
README_download.texi(,137) 
README_download.texi(,138) @heading To download @sc{Singular} for the Macintosh
README_download.texi(,139) For the @sc{Singular} version for Mac OS X refer to the Unix section.
README_download.texi(,140) @*The @sc{Singular} version for Mac OS 9 is available as 
README_download.texi(,141) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-2-html.sea.hqx} (documentation) and @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-2-ppc-MPW.sea.hqx} (binaries and libraries). 
README_download.texi(,142) The file @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/INSTALL_mac.html}
README_download.texi(,143) gives details on how to finish the installation.
README_download.texi(,144) 
README_download.texi(,145) 
README_download.texi(,146) 
platform.tex(,60) 
platform.tex(,61) @c ----------------------------------------------------------
platform.tex(,62) @node Unix installation instructions, Windows installation instructions,Downloading instructions, Release Notes
platform.tex(,63) @section Unix installation instructions
platform.tex(,64) @cindex Unix installation
platform.tex(,65) @cindex instructions, Unix installation
platform.tex(,66) @cindex howto, install on Unix
platform.tex(,67) 
INSTALL_unix.texi(,1) @comment -*-texinfo-*-
INSTALL_unix.texi(,2) @comment Id: INSTALL_unix.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
INSTALL_unix.texi(,3) @c FILE: INSTALL_unix.texi
INSTALL_unix.texi(,4) @c PURPOSE: Installation instruction for Singular on Unix
INSTALL_unix.texi(,5) @c
INSTALL_unix.texi(,6) 
INSTALL_unix.texi(,10) 
INSTALL_unix.texi(,14) 
INSTALL_unix.texi(,16) @set _UNAME <uname>
INSTALL_unix.texi(,18) 
INSTALL_unix.texi(,22) 
INSTALL_unix.texi(,23) To install @sc{Singular} on a
INSTALL_unix.texi(,28) Unix
INSTALL_unix.texi(,30) platform, you need the following two
INSTALL_unix.texi(,31) archives:
INSTALL_unix.texi(,32) @table @code
INSTALL_unix.texi(,33) @item Singular-2-0-4-share.tar.gz
INSTALL_unix.texi(,34) contains architecture independent data like documentation and libraries
INSTALL_unix.texi(,35) (alternatively, you may also download
INSTALL_unix.texi(,36) @code{Singular-2-0-4-share.zip}).
INSTALL_unix.texi(,37) @item Singular-2-0-4-<uname>.tar.gz
INSTALL_unix.texi(,38) contains architecture dependent executables, like the @sc{Singular}
INSTALL_unix.texi(,39) program.
INSTALL_unix.texi(,40) @end table
INSTALL_unix.texi(,42) @*
INSTALL_unix.texi(,43) @code{<uname>} is a description of the processor and operating system
INSTALL_unix.texi(,44) for which @sc{Singular} is compiled (e.g, @code{ix86-Linux}). Please contact us if
INSTALL_unix.texi(,45) you can not find an appropriate architecture dependent archive.
INSTALL_unix.texi(,47) 
INSTALL_unix.texi(,48) You can obtain these (and other) archives from
INSTALL_unix.texi(,49) @display
INSTALL_unix.texi(,50) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular}.
INSTALL_unix.texi(,51) @end display
INSTALL_unix.texi(,52) 
INSTALL_unix.texi(,54) 
INSTALL_unix.texi(,55) @heading To install SINGULAR
INSTALL_unix.texi(,56) 
INSTALL_unix.texi(,57) Make sure that you have approximately 12MByte of free disk space and follow
INSTALL_unix.texi(,58) these steps.
INSTALL_unix.texi(,59) @enumerate
INSTALL_unix.texi(,60) @item
INSTALL_unix.texi(,61) Simply change to the directory in which you wish to install
INSTALL_unix.texi(,62) @sc{Singular} (usually wherever you install 3rd-party software), for example:
INSTALL_unix.texi(,63) @smallexample
INSTALL_unix.texi(,64) cd /usr/local
INSTALL_unix.texi(,65) or
INSTALL_unix.texi(,66) mkdir install;cd install 
INSTALL_unix.texi(,67) (you do not need root privileges in this case)
INSTALL_unix.texi(,68) @end smallexample
INSTALL_unix.texi(,69) 
INSTALL_unix.texi(,70) @sc{Singular} specific subdirectories will be created in such a way
INSTALL_unix.texi(,71) that multiple versions and multiple architecture dependent files
INSTALL_unix.texi(,72) of @sc{Singular} can peaceably coexist under the same @code{/usr/local}
INSTALL_unix.texi(,73) tree.
INSTALL_unix.texi(,74) 
INSTALL_unix.texi(,75) @item
INSTALL_unix.texi(,76) Unpack the archives:
INSTALL_unix.texi(,77) @smallexample
INSTALL_unix.texi(,78) gzip -dc <path_to>/Singular-2-0-4-<uname>.tar.gz | tar -pxf -
INSTALL_unix.texi(,79) gzip -dc <path_to>/Singular-2-0-4-share.tar.gz | tar -pxf -
INSTALL_unix.texi(,80) @end smallexample
INSTALL_unix.texi(,81) @c version 2-0-x does not have *-share.zip:
INSTALL_unix.texi(,82) @c If you have downloaded @code{Singular-@value{VERSION}-share.zip},
INSTALL_unix.texi(,83) @c unpack with
INSTALL_unix.texi(,84) @c @smallexample
INSTALL_unix.texi(,85) @c unzip -u Singular-@value{VERSION}-share.zip
INSTALL_unix.texi(,86) @c @end smallexample
INSTALL_unix.texi(,87) 
INSTALL_unix.texi(,88) This creates the the directory Singular/2-0-4 with 
INSTALL_unix.texi(,89) @multitable @columnfractions .36 .64
INSTALL_unix.texi(,90) @item (sub)directories
INSTALL_unix.texi(,91) @tab  which contain
INSTALL_unix.texi(,92) @item @code{<uname>}
INSTALL_unix.texi(,93) @tab @code{Singular} and @code{ESingular} executables
INSTALL_unix.texi(,94) @item @code{LIB}
INSTALL_unix.texi(,95) @tab @sc{Singular} libraries (@code{*.lib} files)
INSTALL_unix.texi(,96) @item @code{emacs}
INSTALL_unix.texi(,97) @tab files for the @sc{Singular} Emacs user interface
INSTALL_unix.texi(,98) @item @code{info}
INSTALL_unix.texi(,99) @tab info files of @sc{Singular} manual
INSTALL_unix.texi(,100) @item @code{html}
INSTALL_unix.texi(,101) @tab html files of @sc{Singular} manual
INSTALL_unix.texi(,102) @item @code{doc}
INSTALL_unix.texi(,103) @tab miscellaneous documentation files
INSTALL_unix.texi(,104) @item @code{examples}
INSTALL_unix.texi(,105) @tab @sc{Singular} examples (@code{*.sing} files)
INSTALL_unix.texi(,106) @end multitable
INSTALL_unix.texi(,107) 
INSTALL_unix.texi(,108) For the executable to work, the directory layout must look pretty much
INSTALL_unix.texi(,109) like this; the executable looks for "sibling" directories at run-time
INSTALL_unix.texi(,110) to figure out where its @sc{Singular} libraries and on-line
INSTALL_unix.texi(,111) documentation files are. These constraints on the local directory layout
INSTALL_unix.texi(,112) are necessary to avoid having to hard-code pathnames into the
INSTALL_unix.texi(,113) executables, or require that environment variables be set before
INSTALL_unix.texi(,114) running the executable. In particular, you @strong{must not move or copy}
INSTALL_unix.texi(,115) the @sc{Singular} executables to another place, but use soft-links
INSTALL_unix.texi(,116) instead.
INSTALL_unix.texi(,117) @end enumerate
INSTALL_unix.texi(,118) 
INSTALL_unix.texi(,119) The following steps are optional:
INSTALL_unix.texi(,120) 
INSTALL_unix.texi(,121) @itemize @bullet
INSTALL_unix.texi(,122) @item
INSTALL_unix.texi(,123) Arrange that typing @code{Singular} at the shell prompt starts up the
INSTALL_unix.texi(,124) installed @sc{Singular} executable.
INSTALL_unix.texi(,125) 
INSTALL_unix.texi(,126) If you have root permission, do:
INSTALL_unix.texi(,127) @smallexample
INSTALL_unix.texi(,128) ln -s `pwd`/Singular/2-0-4/<uname>/Singular  /usr/local/bin/Singular-2-0-4
INSTALL_unix.texi(,129) ln -s `pwd`/Singular/2-0-4/<uname>/ESingular  /usr/local/bin/ESingular-2-0-4
INSTALL_unix.texi(,130) ln -s /usr/local/bin/Singular-2-0-4 /usr/local/bin/Singular
INSTALL_unix.texi(,131) ln -s /usr/local/bin/ESingular-2-0-4 /usr/local/bin/ESingular
INSTALL_unix.texi(,132) @end smallexample
INSTALL_unix.texi(,133) 	
INSTALL_unix.texi(,134) Otherwise, append the directory
INSTALL_unix.texi(,135) @code{`pwd`/Singular/2-0-4/<uname>/} to your @code{$PATH}
INSTALL_unix.texi(,136) environment variable. For the @code{csh} (or, @code{tcsh}) shell do:
INSTALL_unix.texi(,137) @smallexample
INSTALL_unix.texi(,138) set path=(`pwd`/Singular/2-0-4/<uname> $path)
INSTALL_unix.texi(,139) @end smallexample
INSTALL_unix.texi(,140) For the @code{bash} (or, @code{ksh}) shell do:
INSTALL_unix.texi(,141) @smallexample
INSTALL_unix.texi(,142) export PATH=`pwd`/Singular/2-0-4/<uname>/:$PATH
INSTALL_unix.texi(,143) @end smallexample
INSTALL_unix.texi(,144) 
INSTALL_unix.texi(,145) You also might want to adjust your personal start-up files
INSTALL_unix.texi(,146) (@code{~/.cshrc} for @code{csh}, @code{~/.tcshrc} for @code{tcsh}, or
INSTALL_unix.texi(,147) @code{~/.profile} for @code{bash}) accordingly,
INSTALL_unix.texi(,148) so that the @code{$PATH} variable is set automatically each time you login.
INSTALL_unix.texi(,149) 
INSTALL_unix.texi(,150) @strong{IMPORTANT:} Do @emph{never} move or copy the file
INSTALL_unix.texi(,151) @code{Singular/2-0-4/<uname>/Singular} to another
INSTALL_unix.texi(,152) place, but use soft-links instead.
INSTALL_unix.texi(,153) 
INSTALL_unix.texi(,154) @item
INSTALL_unix.texi(,155) If you wish to use any of following features of
INSTALL_unix.texi(,156) @sc{Singular}, make sure that the respective programs are installed on your system:
INSTALL_unix.texi(,157) 
INSTALL_unix.texi(,158) @multitable @columnfractions .5 .5
INSTALL_unix.texi(,159) @item @strong{Feature} @tab @strong{Requires}
INSTALL_unix.texi(,160) @item running @code{ESingular}, or @code{Singular} within Emacs
INSTALL_unix.texi(,161) @tab @uref{http://www.fsf.org/software/emacs/emacs.html,,Emacs} version
INSTALL_unix.texi(,162) 20 or higher, or, @uref{http://www.xemacs.org,,XEmacs} version 20.3 or
INSTALL_unix.texi(,163) higher (ESingular is only included in the Linux distribution,
INSTALL_unix.texi(,164) on other Unix platforms you can download the
INSTALL_unix.texi(,165) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/src/,,
INSTALL_unix.texi(,166) Singular emacs lisp files} but we give no warranties for specific platforms).
INSTALL_unix.texi(,167) @item on-line @code{html} help
INSTALL_unix.texi(,168) @tab @uref{http://www.netscape.com,,netscape} browser
INSTALL_unix.texi(,169) @item on-line @code{info} help
INSTALL_unix.texi(,170) @tab @uref{http://www.texinfo.org,,info}, or
INSTALL_unix.texi(,171) @uref{http://math-www.uni-paderborn.de/~axel/tkinfo/,,tkinfo} texinfo browser programs
INSTALL_unix.texi(,172) @item TAB completion and history mechanism of ASCII-terminal interface
INSTALL_unix.texi(,173) @tab shared @uref{ftp://ftp.de.uu.net/pub/gnu/readline/,,readline}
INSTALL_unix.texi(,174) library, i.e. @code{/usr/lib/libreadline.so}
INSTALL_unix.texi(,175) @item visualization of curves and surfaces
INSTALL_unix.texi(,176) @tab
INSTALL_unix.texi(,177) @uref{http://www.mathematik.uni-mainz.de/AlgebraischeGeometrie/surf/surf.shtml,,surf}
INSTALL_unix.texi(,178) version 0.9 or higher (only available for Linux and Solaris).
INSTALL_unix.texi(,179) @end multitable
INSTALL_unix.texi(,180) 
INSTALL_unix.texi(,181) You may download most of these programs from
INSTALL_unix.texi(,182) @display
INSTALL_unix.texi(,183) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils/}.
INSTALL_unix.texi(,184) @end display
INSTALL_unix.texi(,185) 
INSTALL_unix.texi(,186) @item Customize the on-line help system:
INSTALL_unix.texi(,187) 
INSTALL_unix.texi(,188) By default, on-line help is displayed in the @code{html} format using
INSTALL_unix.texi(,189) the @code{netscape} program.
INSTALL_unix.texi(,190) 
INSTALL_unix.texi(,191) However, this behavior can be customized in several ways
INSTALL_unix.texi(,192) using the @sc{Singular} commands @code{system("--browser",<browser>)}
INSTALL_unix.texi(,193) and @code{system("--allow-net", 1)} (or, by starting up @sc{Singular}
INSTALL_unix.texi(,194) with the respective command line options).
INSTALL_unix.texi(,195) 
INSTALL_unix.texi(,196) In particular, creating the file
INSTALL_unix.texi(,197) @code{Singular/2-0-4/LIB/.singularrc} and putting the
INSTALL_unix.texi(,198) @sc{Singular} command
INSTALL_unix.texi(,199) @smallexample
INSTALL_unix.texi(,200) system("--allow-net", 1);
INSTALL_unix.texi(,201) @end smallexample
INSTALL_unix.texi(,202) in it, allows the on-line help system to fetch its @code{html} pages
INSTALL_unix.texi(,203) from @uref{http://www.singular.uni-kl.de, Singular's WWW
INSTALL_unix.texi(,204) home site}
INSTALL_unix.texi(,205) in case its local html pages are not found. That is, you may delete your
INSTALL_unix.texi(,206) local html pages, after setting this option.
INSTALL_unix.texi(,207) 
INSTALL_unix.texi(,208) See also
INSTALL_unix.texi(,210) @ref{The online help system}, @ref{Command line options}, and
INSTALL_unix.texi(,211) @ref{Startup sequence},
INSTALL_unix.texi(,217) for more details on customizing the on-line help system.
INSTALL_unix.texi(,218) 
INSTALL_unix.texi(,219) @item
INSTALL_unix.texi(,220) Add the line
INSTALL_unix.texi(,221) @smallexample
INSTALL_unix.texi(,222) * Singular:(singular.hlp).     A system for polynomial computations
INSTALL_unix.texi(,223) @end smallexample
INSTALL_unix.texi(,224) to your system-wide @code{dir} file (usually @code{/usr/info/dir} or
INSTALL_unix.texi(,225) @code{/usr/local/info/dir} and  copy or soft-link the file
INSTALL_unix.texi(,226) @code{Singular/2-0-4/info/singular.hlp}
INSTALL_unix.texi(,227) to the directory of your @code{dir} file.
INSTALL_unix.texi(,228) @*This assures that the
INSTALL_unix.texi(,229) @sc{Singular} manual can be  accessed from stand-alone texinfo
INSTALL_unix.texi(,230) browser programs such as @code{info} or @code{Emacs}.
INSTALL_unix.texi(,231) (It is not necessary for the use of the help system from within @code{Singular}.)
INSTALL_unix.texi(,232) @end itemize
INSTALL_unix.texi(,233) 
INSTALL_unix.texi(,234) @heading Troubleshooting
INSTALL_unix.texi(,235) 
INSTALL_unix.texi(,236) @itemize @bullet
INSTALL_unix.texi(,237) @item General: @sc{Singular} can not find its libraries or on-line help
INSTALL_unix.texi(,238) @enumerate
INSTALL_unix.texi(,239) @item
INSTALL_unix.texi(,240) Make sure that you have read and/or execute permission the files and
INSTALL_unix.texi(,241) directories of the Singular distribution. If in doubt, @code{cd} to the
INSTALL_unix.texi(,242) directory where you unpacked @sc{Singular}, and do (as root, if
INSTALL_unix.texi(,243) necessary):
INSTALL_unix.texi(,244) @smallexample
INSTALL_unix.texi(,245) chmod -R a+rX Singular
INSTALL_unix.texi(,246) @end smallexample
INSTALL_unix.texi(,247) 
INSTALL_unix.texi(,248) @item
INSTALL_unix.texi(,249) Start up @sc{Singular}, and issue the command @code{system("Singular");}.
INSTALL_unix.texi(,250) If this does not return the correct and expanded location of the
INSTALL_unix.texi(,251) @sc{Singular} executable, then you found a bug in @sc{Singular}, which we
INSTALL_unix.texi(,252) ask you to report (see below).
INSTALL_unix.texi(,253) @item
INSTALL_unix.texi(,254) Check whether the directories containing the libraries and on-line help
INSTALL_unix.texi(,255) files can be found by @sc{Singular}: If @code{$bindir} denotes the
INSTALL_unix.texi(,256) directory where the @sc{Singular} executable resides, then @sc{Singular}
INSTALL_unix.texi(,257) looks for library files as follows:
INSTALL_unix.texi(,258) @* (0) the current directory
INSTALL_unix.texi(,259) @* (1) all dirs of the environment variable SINGULARPATH
INSTALL_unix.texi(,260) @* (2) @code{$bindir/LIB}
INSTALL_unix.texi(,261) @* (3) @code{$bindir/../LIB}
INSTALL_unix.texi(,262) @* (4) @code{/usr/local/Singular/2-0-4/LIB}
INSTALL_unix.texi(,263) @* (4) @code{/usr/local/Singular/LIB}
INSTALL_unix.texi(,264) @* The on-line @code{info} files need to be at  @code{$bindir/../info} and the
INSTALL_unix.texi(,265) @code{html} pages at @code{$bindir/../html}.
INSTALL_unix.texi(,266) @end enumerate
INSTALL_unix.texi(,267) 
INSTALL_unix.texi(,268) You can inspect the found library and @code{info}/@code{html}
INSTALL_unix.texi(,269) directories by starting up @sc{Singular} with the
INSTALL_unix.texi(,270) @code{--version} option, or by issuing the @sc{Singular} command
INSTALL_unix.texi(,271) @code{system("--version");}.
INSTALL_unix.texi(,272) 
INSTALL_unix.texi(,273) @item Under SuSE-Linux, @sc{ESingular} does not display a prompt:
INSTALL_unix.texi(,274) @cindex SuSE, ESingular bug
INSTALL_unix.texi(,275) @cindex ESingular, no prompt
INSTALL_unix.texi(,276) @cindex bug, ESingular
INSTALL_unix.texi(,277) This is due to the very restrictive access rights of @code{/dev/pty*} of
INSTALL_unix.texi(,278) the standard @uref{http:/www.suse.de,SuSE} distribution (starting from
INSTALL_unix.texi(,279) version 6.3 on). As root, do one of the following: Either
INSTALL_unix.texi(,280) @example
INSTALL_unix.texi(,281) chmod 666 /dev/pty*
INSTALL_unix.texi(,282) @end example
INSTALL_unix.texi(,283) or,
INSTALL_unix.texi(,284) @example
INSTALL_unix.texi(,285) chmod g+s $(which emacs)
INSTALL_unix.texi(,286) chgrp tty $(which emacs)
INSTALL_unix.texi(,287) chmod g+s $(which xemacs)
INSTALL_unix.texi(,288) chgrp tty $(which xemacs)
INSTALL_unix.texi(,289) @end example
INSTALL_unix.texi(,290) See also @uref{http://sdb.suse.de/sdb/de/html/ke_devpts-63.html} for
INSTALL_unix.texi(,291) details.
INSTALL_unix.texi(,292) 
INSTALL_unix.texi(,293) @item For @code{HPUX} systems:
INSTALL_unix.texi(,294) @*The /etc/termcap files which are pre-installed on these systems are
INSTALL_unix.texi(,295) broken which leads to messages like
INSTALL_unix.texi(,296) @example
INSTALL_unix.texi(,297) Name collision between 9826 9836
INSTALL_unix.texi(,298) @end example
INSTALL_unix.texi(,299) when @sc{Singular} is started. To fix this, you can get fixed termcap
INSTALL_unix.texi(,300) files from @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils}
INSTALL_unix.texi(,301) by downloading the files termcap-<uname-description> and either
INSTALL_unix.texi(,302) replace your /etc/termcap file by the file found there, or view, and
INSTALL_unix.texi(,303) redo the respective changes by @code{diff}'ing the downloaded and the
INSTALL_unix.texi(,304) original file.
INSTALL_unix.texi(,305) 
INSTALL_unix.texi(,306) @item For @code{ix86-Linux} systems:
INSTALL_unix.texi(,307) @*Due to some incompatibilities of shared libraries, the start-up of
INSTALL_unix.texi(,308) @sc{Singular} might fail with messages like
INSTALL_unix.texi(,309) @example
INSTALL_unix.texi(,310)   Can not find shared library ...
INSTALL_unix.texi(,311) @end example
INSTALL_unix.texi(,312) For DEBIAN systems, try to do
INSTALL_unix.texi(,313) @code{ln -s /usr/lib/libncurses.so /usr/lib/libncurses.so.4}.
INSTALL_unix.texi(,314) @*If this fails (and on other systems)
INSTALL_unix.texi(,315) download and install
INSTALL_unix.texi(,316) @code{Singular-2-0-4-ix86-Linux-static.tar.gz}.
INSTALL_unix.texi(,317) 
INSTALL_unix.texi(,318) @item For @code{AIX} systems:
INSTALL_unix.texi(,319) @*The default @code{info} program of the system is not GNU's texinfo
INSTALL_unix.texi(,320) browser which is used to display the on-line documentation in the
INSTALL_unix.texi(,321) @code{info} format. Therefore, the distribution of the AIX executable
INSTALL_unix.texi(,322) already contains the @code{info} browser program.
INSTALL_unix.texi(,323) If you remove this program, make sure that the GNU
INSTALL_unix.texi(,324) @code{info} program is executed if you call '@code{info}' from your shell.
INSTALL_unix.texi(,325) 
INSTALL_unix.texi(,326) @item For any other troubles:
INSTALL_unix.texi(,327) @*Please send an email to @email{singular@@mathematik.uni-kl.de}
INSTALL_unix.texi(,328) and include the header which is displayed by starting up @sc{Singular}
INSTALL_unix.texi(,329) with the @code{-v} option, and a description of your machine (issue the
INSTALL_unix.texi(,330) command @code{uname -a} on your shell) in your report.
INSTALL_unix.texi(,331) @end itemize
INSTALL_unix.texi(,332) 
INSTALL_unix.texi(,334) 
INSTALL_unix.texi(,339) 
platform.tex(,69) 
platform.tex(,70) @c ----------------------------------------------------------
platform.tex(,71) @node Windows installation instructions, Macintosh installation instructions, Unix installation instructions, Release Notes
platform.tex(,72) @section Windows installation instructions
platform.tex(,73) @cindex Windows installation
platform.tex(,74) @cindex instructions, Windows installation
platform.tex(,75) @cindex howto, install on Windows
platform.tex(,76) 
INSTALL_win.texi(,1) @comment -*-texinfo-*-
INSTALL_win.texi(,2) @comment Id: INSTALL_win.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
INSTALL_win.texi(,3) @c FILE:    INSTALL.texi
INSTALL_win.texi(,4) @c PURPOSE: Installation instructions for Singular on MSWindows
INSTALL_win.texi(,5) @c          This file is displayed during installation and copied to
INSTALL_win.texi(,6) @c          /etc/INSTALL
INSTALL_win.texi(,7) 
INSTALL_win.texi(,8) @c use set CD for producing a special INSTALL_win which will be opened
INSTALL_win.texi(,9) @c by the autorun on the Singular CD
INSTALL_win.texi(,10) 
INSTALL_win.texi(,14) 
INSTALL_win.texi(,18) 
INSTALL_win.texi(,22) 
INSTALL_win.texi(,23) @heading For the impatient:
INSTALL_win.texi(,24) @itemize
INSTALL_win.texi(,25) @item
INSTALL_win.texi(,26) If you run Windows NT/2K/XP, make sure you are logged in with the
INSTALL_win.texi(,27) @code{Administrator} rights.
INSTALL_win.texi(,28) @item
INSTALL_win.texi(,29) If you have some older version of @code{Singular} installed, please uninstall it
INSTALL_win.texi(,30) before installing @code{Singular-2-0-4}. It is recommended to
INSTALL_win.texi(,31) install the new @code{Singular} in the same directory where the previous
INSTALL_win.texi(,32) version was installed. Thus your existing environment will be used automatically.
INSTALL_win.texi(,33) @item 
INSTALL_win.texi(,34) If you have @code{Cygwin} or @code{XEmacs} installed and they do not belong
INSTALL_win.texi(,35) of some previous @code{Singular} installation,
INSTALL_win.texi(,36) please read the information below.
INSTALL_win.texi(,37) @item
INSTALL_win.texi(,38) Execute the self-extracting installation archive and
INSTALL_win.texi(,39) @strong{carefully} follow the instructions given there. 
INSTALL_win.texi(,40) Setup will analyze your system, create the corresponding configuration
INSTALL_win.texi(,41) and give you further tips on the installation process.
INSTALL_win.texi(,42) @item
INSTALL_win.texi(,43) In case of troubles, see the installed files @code{/etc/INSTALL.txt},
INSTALL_win.texi(,44) @code{/etc/TROUBLESHOOTING.txt} or visit
INSTALL_win.texi(,45) the @strong{Singular Forum} at @uref{http://www.singular.uni-kl.de/forum}.
INSTALL_win.texi(,46) @end itemize
INSTALL_win.texi(,47) 
INSTALL_win.texi(,53) 
INSTALL_win.texi(,54) @heading Installation preliminaries
INSTALL_win.texi(,55) 
INSTALL_win.texi(,56) Running @code{Singular} on MS Windows requires that the Cygwin DLL
INSTALL_win.texi(,57) (dynamically linked library) version 1.3.9 or higher is installed on your
INSTALL_win.texi(,58) system (see @uref{http://sources.redhat.com/cygwin/} for details about
INSTALL_win.texi(,59) Cygwin). We install and configure @code{Cygwin} version 1.3.9 automatically, if
INSTALL_win.texi(,60) the @code{BasicCygwin} component is selected (default setting).
INSTALL_win.texi(,61) 
INSTALL_win.texi(,62) To run @code{ESingular} (i.e. @code{Singular} within its Emacs interface) on
INSTALL_win.texi(,63) MS Windows requires furthermore that the @code{XEmacs} editor is installed on
INSTALL_win.texi(,64) your system. We install and configure @code{XEmacs} version 21.1.13 automatically, if the @code{XEmacs} component is selected.
INSTALL_win.texi(,65) 
INSTALL_win.texi(,66) @cindex Windows installation, components
INSTALL_win.texi(,67) @cindex Components of Windows installation
INSTALL_win.texi(,68) 
INSTALL_win.texi(,69) The @code{Singular} installation is divided into the following
INSTALL_win.texi(,70) components (you see them explicitly if you choose the Custom Setup Type
INSTALL_win.texi(,71) during the installation):
INSTALL_win.texi(,72) @table @code
INSTALL_win.texi(,73) @item @strong{Program Files:}
INSTALL_win.texi(,74)         @table @code
INSTALL_win.texi(,75) @item Singular
INSTALL_win.texi(,76) Contains the @code{Singular} Program, documentation and example files.
INSTALL_win.texi(,77) @*All files of this component are installed under the directory
INSTALL_win.texi(,78) @code{/usr/local/Singular/2-0-4}
INSTALL_win.texi(,79) @item BasicCygwin
INSTALL_win.texi(,80) Contains the Cygwin DLL and basic tools/programs (like @code{bash} or
INSTALL_win.texi(,81) @code{info}) of the  Cygwin environment.
INSTALL_win.texi(,82) @*The Cygwin DLL and programs are installed in the directory
INSTALL_win.texi(,83) @code{/bin}. Miscellaneous documentation and configuration files are
INSTALL_win.texi(,84) installed into the directory @code{/etc}.
INSTALL_win.texi(,85) @item XEmacs
INSTALL_win.texi(,86) Contains the Cygwin port of the @code{XEmacs} editor (see
INSTALL_win.texi(,87) @url{http://www.xemacs.org} for more about @code{XEmacs}) version 21.1.13.
INSTALL_win.texi(,88) @*All files of this component are installed under the directory
INSTALL_win.texi(,89) @code{/usr/local}.
INSTALL_win.texi(,90) @item ESingular
INSTALL_win.texi(,91) Contains the @code{ESingular}, the most comfortable Singular interface.
INSTALL_win.texi(,92) Requires @code{XEmacs} to run.
INSTALL_win.texi(,93)         @end table
INSTALL_win.texi(,94) @item @strong{Remark:}
INSTALL_win.texi(,95) All essential DLLs, some programs and symbolic links are installed in the directory
INSTALL_win.texi(,96) @code{/usr/local/Singular/2-0-4/ix86-Win}, which must be present in your @code{PATH} system variable.
INSTALL_win.texi(,97) @item @strong{Help Files:}
INSTALL_win.texi(,98) @table @code
INSTALL_win.texi(,99) @item WinHelp
INSTALL_win.texi(,100) Contains Singular Manual, converted to Windows help format (.hlp).
INSTALL_win.texi(,101) We recommend to install it, because it is small in size. Moreover,
INSTALL_win.texi(,102) we set it as default help browser in all the Singular executables.
INSTALL_win.texi(,103) @item HTML Help
INSTALL_win.texi(,104) Contains the "native" Singular Manual. It's not included by default,
INSTALL_win.texi(,105) because it is much bigger than WinHelp, though it has better typesetting
INSTALL_win.texi(,106) of mathematical formulae.
INSTALL_win.texi(,107) @end table
INSTALL_win.texi(,108) @end table
INSTALL_win.texi(,109) 
INSTALL_win.texi(,110) The Typical Setup Type of the Singular-2-0-4-Typical.exe contains
INSTALL_win.texi(,111) @code{BasicCygwin}, @code{Singular}, 
INSTALL_win.texi(,112) @code{XEmacs}, @code{ESingular}, @code{WinHelp} and @code{HTML Help} 
INSTALL_win.texi(,113) components. The Compact Setup Type does not contain only the @code{HTML Help} component.
INSTALL_win.texi(,114) 
INSTALL_win.texi(,116) @heading Downloading preliminaries
INSTALL_win.texi(,117) 
INSTALL_win.texi(,118) To install @code{Singular} on a PC running Windows 95/98/ME/NT/2K/XP, you need
INSTALL_win.texi(,119) to download @strong{one} of the following archive files:
INSTALL_win.texi(,120) 
INSTALL_win.texi(,121) Minimal archive: @uref{Singular-2-0-4-Compact.exe, Singular-2-0-4-Compact.exe}      (@code{BasicCygwin}, @code{Singular}, @code{WinHelp} components)
INSTALL_win.texi(,122) 
INSTALL_win.texi(,123) Typical archive : @uref{Singular-2-0-4-Typical.exe, Singular-2-0-4-Typical.exe}      (@code{BasicCygwin}, @code{Singular}, @code{XEmacs}, @code{ESingular}, @code{WinHelp}, @code{HTML Help} components)
INSTALL_win.texi(,124) 
INSTALL_win.texi(,125) You can obtain these (and other) archives 
INSTALL_win.texi(,126) either from the @code{WINDOWS} directory on the @code{Singular} CD or from
INSTALL_win.texi(,127) @display
INSTALL_win.texi(,128) @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/}.
INSTALL_win.texi(,129) @end display
INSTALL_win.texi(,130) 
INSTALL_win.texi(,132) 
INSTALL_win.texi(,149) 
INSTALL_win.texi(,150) @heading Installing Singular
INSTALL_win.texi(,151) 
INSTALL_win.texi(,152) The recent Setup program analyzes your system, e.g. it detects
INSTALL_win.texi(,153) whether Cygwin and XEmacs are present and functional. Then it gives you
INSTALL_win.texi(,154) hints and/or error messages with instructions during the installation.
INSTALL_win.texi(,155) 
INSTALL_win.texi(,156) @table @code
INSTALL_win.texi(,157) @item If you have Cygwin installed
INSTALL_win.texi(,158)         If the version of @code{cygwin1.dll} is not less than 1.3.9,
INSTALL_win.texi(,159)         you will be prompted that the @code{BasicCygwin} component will not
INSTALL_win.texi(,160)         be installed. Moreover, the existing Cygwin root directory will be proposed as
INSTALL_win.texi(,161)         the default installation directory. You can accept it, then
INSTALL_win.texi(,162)         @code{Singular} will be placed into the existing Cygwin environment.
INSTALL_win.texi(,163)         If you choose another destination, @code{Singular} will use Cygwin
INSTALL_win.texi(,164)         programs anyway. If your Cygwin has incorrect settings (like
INSTALL_win.texi(,165)         inconsistent mount points among the important ones), @code{Singular}
INSTALL_win.texi(,166)         Setup will correct them. 
INSTALL_win.texi(,167) @*      If setup could not detect @code{cygwin}, present in the system, you
INSTALL_win.texi(,168)         can try to break the installation, start it once more, choose the
INSTALL_win.texi(,169)         "Custom" setup type and unselect the @code{BasicCygwin} component.
INSTALL_win.texi(,170) 
INSTALL_win.texi(,171) @item If you have XEmacs installed
INSTALL_win.texi(,172)         The @code{Cygwin} port of @code{XEmacs} version 21.1.13 together 
INSTALL_win.texi(,173)         with the most
INSTALL_win.texi(,174)         important packages is included in the distribution. The use of 
INSTALL_win.texi(,175)         non-@code{Cygwin} ports or earlier @code{Cygwin} ports has some 
INSTALL_win.texi(,176)         quirks and does not work 
INSTALL_win.texi(,177)         properly together with @code{Singular} (i.e., running @code{ESingular} 
INSTALL_win.texi(,178)         results in problems). Nevertheless, if you want to test the
INSTALL_win.texi(,179)         compatibility of @code{ESingular} with your own @code{XEmacs}, just
INSTALL_win.texi(,180)         de-select the XEmacs component, but leave @code{ESingular} selected.
INSTALL_win.texi(,181)         If your @code{XEmacs} happens to be incompatible with ESingular, you can
INSTALL_win.texi(,182)         install just the XEmacs component and use in fact two different
INSTALL_win.texi(,183)         @code{XEmacs} programs. 
INSTALL_win.texi(,184)         The setup program will search for @code{XEmacs} and packages 
INSTALL_win.texi(,185)         in @code{<TARGETDIR>/usr/local/lib} (here @code{<TARGETDIR>} is the directory which you selected while running setup). If you have @code{Cygwin} and the Cygwin port of
INSTALL_win.texi(,186)         @code{XEmacs}, you might have @code{XEmacs} installed there. To avoid overwriting your @code{XEmacs} files, setup will ask you what to do.
INSTALL_win.texi(,187) @end table
INSTALL_win.texi(,188) 
INSTALL_win.texi(,194) 
INSTALL_win.texi(,195) @heading Customizing Singular
INSTALL_win.texi(,196) 
INSTALL_win.texi(,197) The following step(s) are optional:
INSTALL_win.texi(,198) @itemize
INSTALL_win.texi(,199) @item
INSTALL_win.texi(,200) To conveniently access all files on your computer, mount the drives of
INSTALL_win.texi(,201) your disk(s):
INSTALL_win.texi(,202) @enumerate
INSTALL_win.texi(,203) @item
INSTALL_win.texi(,204) Open a rxvt terminal (from Start->Programs->Singular 2.0->Tools).
INSTALL_win.texi(,205) @item
INSTALL_win.texi(,206) For each drive (letter) issue the following command (the drive @code{C:}
INSTALL_win.texi(,207) is used in the example):
INSTALL_win.texi(,208) @example
INSTALL_win.texi(,209) mount -f -s -t C: /C
INSTALL_win.texi(,210) @end example
INSTALL_win.texi(,211) @end enumerate
INSTALL_win.texi(,212) After mounting the drive(s) this way, you can conveniently access the
INSTALL_win.texi(,213) files on a drive from the @code{bash} shell and from @code{XEmacs} using the @code{/C/} prefix. Otherwise, you need to type @code{/cygdrive/C} - that is
INSTALL_win.texi(,214) the Cygwin convention. You can get more information on @code{mount} command by invoking @code{mount --help}. Command @code{umount} unmount the selected
INSTALL_win.texi(,215) mount point.
INSTALL_win.texi(,216) 
INSTALL_win.texi(,217) 
INSTALL_win.texi(,218) @item
INSTALL_win.texi(,219) Create your personal @code{HOME} directory.
INSTALL_win.texi(,220) @*Various applications (e.g., @code{bash} or @code{XEmacs}) store
INSTALL_win.texi(,221) user-specific configuration/customization files in the @code{HOME}
INSTALL_win.texi(,222) directory of the current user. During the installation, the @code{HOME}
INSTALL_win.texi(,223) directory is globally set for all users to @code{/home/Singular}. To
INSTALL_win.texi(,224) create your individual  @code{HOME} directory follow these steps:
INSTALL_win.texi(,225) @enumerate
INSTALL_win.texi(,226) @item
INSTALL_win.texi(,227) Create a directory (folder), say, @code{C:\home\MyHome}.
INSTALL_win.texi(,228) @item
INSTALL_win.texi(,229) Copy all files from @code{/home/Singular} to @code{C:\home\MyHome}.
INSTALL_win.texi(,230) @item
INSTALL_win.texi(,231) Set the @emph{user} environment variable @code{HOME} to @code{C:\home\MyHome}:
INSTALL_win.texi(,232) @*On Windows 95/98/ME, edit the respective line the @code{AUTOEXEC.BAT}
INSTALL_win.texi(,233) file.
INSTALL_win.texi(,234) @*On Windows NT/2K/XP add an entry in your @code{Environment} control
INSTALL_win.texi(,235) panel.
INSTALL_win.texi(,236) @item
INSTALL_win.texi(,237) Restart your computer (On Windows 95/98/ME).
INSTALL_win.texi(,238) @end enumerate
INSTALL_win.texi(,239) You may furthermore examine the files copied into your @code{HOME}
INSTALL_win.texi(,240) directory and adjust (i.e. edit) them to your personal
INSTALL_win.texi(,241) preferences/needs. System-wide settings are stored in the file 
INSTALL_win.texi(,242) @code{/etc/profile}.
INSTALL_win.texi(,243) 
INSTALL_win.texi(,244) @end itemize
INSTALL_win.texi(,245) 
INSTALL_win.texi(,246) @heading Uninstalling Singular
INSTALL_win.texi(,247) 
INSTALL_win.texi(,248) You can uninstall individual or all installed components by opening the
INSTALL_win.texi(,249) @code{Software} shortcut of the @code{Control panel}. 
INSTALL_win.texi(,250) Simply double-click the @code{Singular} item and
INSTALL_win.texi(,251) follow the instructions given there.
INSTALL_win.texi(,252) 
INSTALL_win.texi(,253) 
INSTALL_win.texi(,254) For any other troubles,
INSTALL_win.texi(,255) please send an email to @email{singular@@mathematik.uni-kl.de}
INSTALL_win.texi(,256) and include the header which is displayed by starting up @code{Singular}
INSTALL_win.texi(,257) with the @code{-v} option, and a description of your machine and
INSTALL_win.texi(,258) operating system.
INSTALL_win.texi(,259) 
INSTALL_win.texi(,261) 
INSTALL_win.texi(,266) 
platform.tex(,78) 
platform.tex(,79) @c ----------------------------------------------------------
platform.tex(,80) @node Macintosh installation instructions,,Windows installation instructions, Release Notes
platform.tex(,81) @section Macintosh installation instructions
platform.tex(,82) @cindex Macintosh installation
platform.tex(,83) @cindex instructions, Macintosh installation
platform.tex(,84) @cindex howto, install on Macintosh
platform.tex(,85) 
platform.tex(,86) For the SINGULAR version for Mac OS X refer to the Unix section.
platform.tex(,87) The SINGULAR version for Mac OS 9 is available as
platform.tex(,88) `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-4-html.sea.hqx'
platform.tex(,89) (documentation) and
platform.tex(,90) `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-4-ppc-MPW.sea.hqx'
platform.tex(,91) (binaries and libraries).  The file
platform.tex(,92) `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/INSTALL_mac.txt'
platform.tex(,93) gives details on how to finish the installation.
platform.tex(,94) 
INSTALL_mac.texi(,1) @comment -*-texinfo-*-
INSTALL_mac.texi(,2) @comment Id: INSTALL_mac.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
INSTALL_mac.texi(,3) @c FILE:    INSTALL_classicMac.texi
INSTALL_mac.texi(,4) @c PURPOSE: Installation instructions for Singular on Macintosh
INSTALL_mac.texi(,5) 
INSTALL_mac.texi(,9) 
INSTALL_mac.texi(,13) 
INSTALL_mac.texi(,14) @heading Installation preliminaries
INSTALL_mac.texi(,15) 
INSTALL_mac.texi(,16) This is the final distribution of @sc{Singular} as MPW tool.
INSTALL_mac.texi(,17) Newer versions of @sc{Singular} will only be available for MacOS X (which is handled like other @sc{Unix}-systems).
INSTALL_mac.texi(,18) To install @sc{Singular} on a Macintosh (PPC only), you need the file @code{Singular-2-0-2-ppc-MPW.sea.hqx} resp. @code{Singular-2-0-2-ppc-MPW.hqx} which you can obtain by public ftp from @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular}.
INSTALL_mac.texi(,19) Furthermore, you need MacOS version >= 8.5 with an installed MPW shell. 
INSTALL_mac.texi(,20) This version works also without Carbon.
INSTALL_mac.texi(,21) 
INSTALL_mac.texi(,23) 
INSTALL_mac.texi(,24) 
INSTALL_mac.texi(,25) @heading Installing @sc{Singular} on MacOS X
INSTALL_mac.texi(,26) 
INSTALL_mac.texi(,27) Please see @uref{INSTALL_unix.html}. 
INSTALL_mac.texi(,28) In contrast to other Unix systems, under MacOS X, @sc{Singular} is only available as a shell command and there is no Emacs interface.
INSTALL_mac.texi(,29) Enter @code{Singular} in a terminal under Aqua to run @sc{Singular}.
INSTALL_mac.texi(,30) Alternatively, you may choose @code{Terminal} as the application to open the file @code{Singular} with and put it into the dock.
INSTALL_mac.texi(,31) 
INSTALL_mac.texi(,32) 
INSTALL_mac.texi(,33) @heading Installing Singular
INSTALL_mac.texi(,34) 
INSTALL_mac.texi(,35) @enumerate
INSTALL_mac.texi(,36) 
INSTALL_mac.texi(,37) @item
INSTALL_mac.texi(,38) Make sure that you have MPW  installed on your system. 
INSTALL_mac.texi(,39) See below for instructions on how to install MPW and how to avoid conflicts with the @code{Carbon.lib}.
INSTALL_mac.texi(,40) 
INSTALL_mac.texi(,41) @item
INSTALL_mac.texi(,42) Download the file @code{Singular-2-0-2-ppc-MPW.sea.hqx}.
INSTALL_mac.texi(,43) 
INSTALL_mac.texi(,44) @item
INSTALL_mac.texi(,45) Expand the downloaded file using a standard Expander (like Compact Pro or StuffIt) to obtain the corresponding self-extracting @code{Singular-2-0-2-ppc-MPW.sea} file.
INSTALL_mac.texi(,46) 
INSTALL_mac.texi(,47) @item
INSTALL_mac.texi(,48) Click on the self-extracting @code{Singular-2-0-2-ppc-MPW.sea} file. 
INSTALL_mac.texi(,49) This  will create a new folder named @code{Singular:} which contains the @sc{Singular} program in the subfolder @code{2-0-2:ppc-MPW:}. 
INSTALL_mac.texi(,50) Do not change the structure of the subfolders.
INSTALL_mac.texi(,51) 
INSTALL_mac.texi(,52) @item
INSTALL_mac.texi(,53) Make the folder which contains the executable to the working directory of the MPW shell. 
INSTALL_mac.texi(,54) To start @sc{Singular}, you need to type @code{Singular} in the MPW worksheet. 
INSTALL_mac.texi(,55) Clicking on the @sc{Singular} icon on the desktop, starts up the MPW shell (the working directory of the MPW shell is then the directory of the executable). 
INSTALL_mac.texi(,56) If you start the MPW shell manually, you must set the working directory to the directory of the @sc{Singular} program. 
INSTALL_mac.texi(,57) You may use the directory menu or write into the startup file of the MPW shell the line
INSTALL_mac.texi(,58) @smallexample
INSTALL_mac.texi(,59) setdirectory "@{Boot@}"Singular:2-0-2:ppc-MPW:
INSTALL_mac.texi(,60) @end smallexample
INSTALL_mac.texi(,61) if @code{"@{Boot@}"Singular:2-0-2:ppc-MPW:} is the folder of the executable.
INSTALL_mac.texi(,62) 
INSTALL_mac.texi(,63) After unpacking, you will have a directory structure like:
INSTALL_mac.texi(,64) @table @code
INSTALL_mac.texi(,65) @item Singular:2-0-2:ppc-MPW:Singular
INSTALL_mac.texi(,66) Singular executable
INSTALL_mac.texi(,67) @item Singular:2-0-2:ppc-MPW:libparse
INSTALL_mac.texi(,68) parser for Singular libraries
INSTALL_mac.texi(,69) @item Singular:2-0-2:LIB:
INSTALL_mac.texi(,70) Singular libraries
INSTALL_mac.texi(,71) @item Singular:2-0-2:LIB:gftables:
INSTALL_mac.texi(,72) Singular gftables
INSTALL_mac.texi(,73) @item Singular:2-0-2:doc:singular.idx
INSTALL_mac.texi(,74) index of inline help
INSTALL_mac.texi(,75) @item Singular:2-0-2:doc:singular.hlp
INSTALL_mac.texi(,76) file for inline help
INSTALL_mac.texi(,77) @item Singular:2-0-2:README
INSTALL_mac.texi(,78) information of the distribution
INSTALL_mac.texi(,79) @item Singular:2-0-2:README.hlml
INSTALL_mac.texi(,80) @item Singular:2-0-2:COPYING
INSTALL_mac.texi(,81) license information
INSTALL_mac.texi(,82) @item Singular:2-0-2:COPYING.html
INSTALL_mac.texi(,83) @item Singular:2-0-2:NEWS
INSTALL_mac.texi(,84) news in the distribution
INSTALL_mac.texi(,85) @item Singular:2-0-2:NEWS.html
INSTALL_mac.texi(,86) @item Singular:2-0-2:INSTALL
INSTALL_mac.texi(,87) instructions like this file
INSTALL_mac.texi(,88) @end table
INSTALL_mac.texi(,89) 
INSTALL_mac.texi(,90) The @sc{Singular} libraries have a special form to work here. 
INSTALL_mac.texi(,91) Do not use the libraries from other distributions. 
INSTALL_mac.texi(,92) They are not compatible. 
INSTALL_mac.texi(,93) A supplementary file is @code{Singular-2-0-2-html.sea.hqx} which contains the html pages. 
INSTALL_mac.texi(,94) You can use this with a browser but not from the program @sc{Singular}.
INSTALL_mac.texi(,95) The self-extracting archive will create the folder @code{html:} and you may extract it at @code{"@{Boot@}"Singular:2-0-2:}.
INSTALL_mac.texi(,96) 
INSTALL_mac.texi(,97) @end enumerate
INSTALL_mac.texi(,98) 
INSTALL_mac.texi(,99) 
INSTALL_mac.texi(,100) @heading Installing MPW
INSTALL_mac.texi(,101) 
INSTALL_mac.texi(,102) The final version of MPW is downloadable from Apple at @uref{ftp://ftp.apple.com/developer/Tool_Chest/Core_Mac_OS_Tools/MPW_etc./MPW-GM_Images/}.
INSTALL_mac.texi(,103) Older versions of @code{Carbon.lib} may conflict with the latest MPW. 
INSTALL_mac.texi(,104) In this case, you need to update @code{Carbon.lib} or work without it.
INSTALL_mac.texi(,105) 
INSTALL_mac.texi(,106) 
INSTALL_mac.texi(,107) @heading Restrictions
INSTALL_mac.texi(,108) 
INSTALL_mac.texi(,109) Some typical Unix features of @sc{Singular} are not working with MPW, e.g. links and cooperation with other programs like XEmacs and xterm.
INSTALL_mac.texi(,110) 
INSTALL_mac.texi(,111) For any other troubles, please send an email to @email{singular@@mathematik.uni-kl.de} and include the header which is displayed by starting up @sc{Singular}
INSTALL_mac.texi(,112) with the @code{-v} option, and a description of your machine and operating system.
INSTALL_mac.texi(,113) 
INSTALL_mac.texi(,114) 
INSTALL_mac.texi(,116) 
singular.texi(,623) 
singular.texi(,624) @c ----------------------------------------------------------
singular.texi(,625) @node Index, , Release Notes, Top
singular.texi(,626) @chapter Index
singular.texi(,627) @cindex Index
singular.texi(,628) @printindex cp
singular.texi(,629) @c ---------------------------------------------------------
singular.texi(,630) 
singular.texi(,631) @c generate table of content and short table of content
singular.texi(,632) @contents
singular.texi(,633) @bye
