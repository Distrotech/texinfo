D.4.6.1 normal
..............
Procedure from library normal.lib (see normal_lib).

Usage:
normal(i [,choose]); i a radical ideal, choose empty, 1 or "wd"
if choose=1 the normalization of the associated primes is computed
(which is sometimes more efficient);
if choose="wd" the delta invariant is computed
simultaneously; this may take much more time in the reducible case,
since the factorizing standard basis algorithm cannot be used.

Assume:
The ideal must be radical, for non-radical ideals the output may
be wrong (i=radical(i); makes i radical)

Return:
a list of rings, say nor and in case of choose="wd" an
integer at the end of the list.
Each ring nor[i] contains two ideals with given names
norid and normap such that

- the direct sum of the rings nor[i]/norid is the
normalization of basering/id;

- normap gives the normalization map from basering/id to
nor[i]/norid (for each i).

Note:
to use the i-th ring type: def R=nor[i]; setring R;.

 Increasing printlevel displays more comments (default: printlevel=0).

 Not implemented for local or mixed orderings.

 If the input ideal i is weighted homogeneous a weighted ordering may
be used (qhweight(i); computes weights).

Example:
LIB "normal.lib";
ring r=32003,(x,y,z),wp(2,1,2);
ideal i=z3-xy4;
list nor=normal(i);
==> 
==> // 'normal' created a list of 1 ring(s).
==> // nor[1+1] is the delta-invariant in case of choose=wd.
==> // To see the rings, type (if the name of your list is nor):
==>      show( nor);
==> // To access the 1-st ring and map (similar for the others), type:
==>      def R = nor[1]; setring R;  norid; normap;
==> // R/norid is the 1-st ring of the normalization and
==> // normap the map from the original basering to R/norid
show(nor);
==> // list, 1 element(s):
==> [1]:
==>    // ring: (32003),(T(1),T(2),T(3)),(a(2,1,1),dp(3),C);
==>    // minpoly = 0
==> // objects belonging to this ring:
==> // normap               [0]  ideal, 3 generator(s)
==> // norid                [0]  ideal, 1 generator(s)
def r1=nor[1];
setring r1;
norid;
==> norid[1]=T(3)3-T(1)T(2)
normap;
==> normap[1]=T(1)
==> normap[2]=T(2)
==> normap[3]=T(2)T(3)
ring s=0,(x,y),dp;
ideal i=(x-y^2)^2 - y*x^3;
nor=normal(i,"wd");
==> 
==> // 'normal' created a list of 1 ring(s).
==> // nor[1+1] is the delta-invariant in case of choose=wd.
==> // To see the rings, type (if the name of your list is nor):
==>      show( nor);
==> // To access the 1-st ring and map (similar for the others), type:
==>      def R = nor[1]; setring R;  norid; normap;
==> // R/norid is the 1-st ring of the normalization and
==> // normap the map from the original basering to R/norid
//the delta-invariant
nor[size(nor)];
==> 3

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
