D.6.1.8 reynolds_molien
.......................
Procedure from library finvar.lib (see finvar_lib).

Usage:
reynolds_molien(G1,G2,...[,ringname,flags]);

G1,G2,...: nxn <matrices> generating a finite matrix group, ringname:
a <string> giving a name for a new ring of characteristic 0 for the
Molien series in case of prime characteristic, flags: an optional
<intvec> with three components: if the first element is not equal to 0
characteristic 0 is simulated, i.e. the Molien series is computed as
if the base field were characteristic 0 (the user must choose a field
of large prime characteristic, e.g. 32003) the second component should
give the size of intervals between canceling common factors in the
expansion of the Molien series, 0 (the default) means only once after
generating all terms, in prime characteristic also a negative number
can be given to indicate that common factors should always be canceled
when the expansion is simple (the root of the extension field does not
occur among the coefficients)

Assume:
n is the number of variables of the basering, G1,G2... are the group
elements generated by group_reynolds(), g is the size of the group

Return:
a gxn <matrix> representing the Reynolds operator is the first return
value and in case of characteristic 0 a 1x2 <matrix> giving enumerator
and denominator of Molien series is the second one; in case of prime
characteristic a ring with the name `ringname` of characteristic 0 is
created where the same Molien series (named M) is stored

Display:
information if the third component of flags does not equal 0

Theory:
The entire matrix group is generated by getting all left products of
the generators with new elements from the last run through the loop
(or the generators themselves during the first run). All the ones that
have been generated before are thrown out and the program terminates
when are no new elements found in one run. Additionally each time a
new group element is found the corresponding ring mapping of which the
Reynolds operator is made up is generated. They are stored in the rows
of the first return value. In characteristic 0 the terms 1/det(1-xE)
is computed whenever a new element E is found. In prime characteristic
a Brauer lift is involved and the terms are only computed after the
entire matrix group is generated (to avoid the modular case). The
returned matrix gives enumerator and denominator of the expanded
version where common factors have been canceled.

Example:
LIB "finvar.lib";
"         note the case of prime characteristic"; 
==>          note the case of prime characteristic
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix REY,M=reynolds_molien(A);
print(REY);
==> y, -x,-z,
==> -x,-y,z, 
==> -y,x, -z,
==> x, y, z  
print(M);
==> x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
ring S=3,(x,y,z),dp;
string newring="Qadjoint";
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix REY=reynolds_molien(A,newring);
print(REY);
==> y, -x,-z,
==> -x,-y,z, 
==> -y,x, -z,
==> x, y, z  
setring Qadjoint;
print(M);
==> x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
setring S;
kill Qadjoint;

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
