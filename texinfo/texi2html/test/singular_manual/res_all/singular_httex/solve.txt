D.7.2.2 solve
.............
Procedure from library solve.lib (see solve_lib).

Assume:
the ideal is 0-dimensional;

basering has characteristic 0 and is either complex or
without parameters;

Return:
list of solutions of the ideal G, depending on n; one solution is a
list of complex numbers in the generated output ring (the new
basering).
 The result is a list L
    n  = 0: a list of all different solutions (L[i]),
    n != 0: a list of two elements,
            L[i][1] contains all different solutions with the same multiplicity
            L[i][2] the multiplicity
 L is ordered w.r.t. multiplicity (the smallest first).

Note:
If the problem is not 0-dim. the procedure stops with ERROR, if the
ideal G is not a lex. standard basis, it is generated with internal
computation (Hilbert driven), if the input-ring (with char 0) has
the name "<A>", the lexicographical and complex output-ring has the
name "<A>C".

Example:
LIB "solve.lib";
// Find all roots of a multivariate ideal using triangular sets:
int d=4;// with these 3 parameters you may construct
int t=3;// very hard problems for 'solve'
int s=2;
int i;
ring A=0,(x(1..d)),dp;
poly p=-1;
for(i=d;i>0;i--){p=p+x(i)^s;}
ideal I=x(d)^t-x(d)^s+p;
for(i=d-1;i>0;i--){I=x(i)^t-x(i)^s+p,I;}
I;
==> I[1]=x(1)^3+x(2)^2+x(3)^2+x(4)^2-1
==> I[2]=x(2)^3+x(1)^2+x(3)^2+x(4)^2-1
==> I[3]=x(3)^3+x(1)^2+x(2)^2+x(4)^2-1
==> I[4]=x(4)^3+x(1)^2+x(2)^2+x(3)^2-1
// the mutiplicity is
vdim(std(I));
==> 81
list l1=solve(I,6,0);
==> // name of new current ring: AC
// the current ring is
AC;
==> //   characteristic : 0 (complex:6 digits, additional 6 digits)
==> //   1 parameter    : i 
==> //   minpoly        : (i^2+1)
==> //   number of vars : 4
==> //        block   1 : ordering lp
==> //                  : names    x(1) x(2) x(3) x(4) 
==> //        block   2 : ordering C
// you must start with char. 0
setring A;
list l2=solve(I,6,1);
==> // name of current ring: AC
// the number of different solutions is
size(l1);
==> 37
// this is equal to
size(l2[1][1])+size(l2[2][1]);
==> 37
// the number of solutions with multiplicity is
size(l2[1][1])*l2[1][2]+size(l2[2][1])*l2[2][2];
==> 81
// the solutions with multiplicity
l2[2][2];
==> 12
// are
l2[2][1];
==> [1]:
==>    [1]:
==>       0
==>    [2]:
==>       0
==>    [3]:
==>       1
==>    [4]:
==>       0
==> [2]:
==>    [1]:
==>       0
==>    [2]:
==>       1
==>    [3]:
==>       0
==>    [4]:
==>       0
==> [3]:
==>    [1]:
==>       1
==>    [2]:
==>       0
==>    [3]:
==>       0
==>    [4]:
==>       0
==> [4]:
==>    [1]:
==>       0
==>    [2]:
==>       0
==>    [3]:
==>       0
==>    [4]:
==>       1

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
