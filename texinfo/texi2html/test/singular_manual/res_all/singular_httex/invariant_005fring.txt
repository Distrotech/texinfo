D.6.1.1 invariant_ring
......................
Procedure from library finvar.lib (see finvar_lib).

Usage:
invariant_ring(G1,G2,...[,flags]);

G1,G2,...: <matrices> generating a finite matrix group, flags: an
optional <intvec> with three entries: if the first one equals 0, the
program attempts to compute the Molien series and Reynolds operator,
if it equals 1, the program is told that the Molien series should not
be computed, if it equals -1 characteristic 0 is simulated, i.e. the
Molien series is computed as if the base field were characteristic 0
(the user must choose a field of large prime characteristic, e.g.
32003) and if the first one is anything else, it means that the
characteristic of the base field divides the group order (i.e. it will
not even be attempted to compute the Reynolds operator or Molien
series), the second component should give the size of intervals
between canceling common factors in the expansion of Molien series, 0
(the default) means only once after generating all terms, in prime
characteristic also a negative number can be given to indicate that
common factors should always be canceled when the expansion is simple
(the root of the extension field occurs not among the coefficients)

Return:
primary and secondary invariants (both of type <matrix>) generating
the invariant ring with respect to the matrix group generated by the
matrices in the input and irreducible secondary invariants (type
<matrix>) if the Molien series was available

Display:
information about the various stages of the program if the third flag
does not equal 0

Theory:
Bases of homogeneous invariants are generated successively and those
are chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1998)). In the

non-modular case secondary invariants are calculated by finding a
basis (in terms of monomials) of the basering modulo the primary
invariants, mapping to invariants with the Reynolds operator and using
those or their power products such that they are linearly independent
modulo the primary invariants (see "Some Algorithms in Invariant
Theory of Finite Groups" by Kemper and Steel (1997)). In the modular
case they are generated according to "Generating Invariant Rings of
Finite Groups over Arbitrary Fields" by Kemper (1996).

Example:
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix P,S,IS=invariant_ring(A);
print(P);
==> z2,x2+y2,x2y2
print(S);
==> 1,xyz,x2z-y2z,x3y-xy3
print(IS);
==> xyz,x2z-y2z,x3y-xy3

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
