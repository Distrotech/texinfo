A.16 Cyclic roots
=================

We write a procedure returning a string that enables us to create
automatically the ideal of cyclic roots over the basering with n
variables. The procedure assumes that the variables consist of a single
letter each (hence no indexed variables are allowed; the procedure
cyclic in poly.lib does not have this restriction). Then
we compute a standard basis of this ideal and some numerical
information.  (This ideal is used as a classical benchmark for standard
basis computations).

// We call the procedure 'cyclic':
proc cyclic (int n)
{
   string vs = varstr(basering)+varstr(basering);
   int c=find(vs,",");
   while ( c!=0 )
   {
      vs=vs[1,c-1]+vs[c+1,size(vs)];
      c=find(vs,",");
   }
   string t,s;
   int i,j;
   for ( j=1; j<=n-1; j=j+1 )
   {
      t="";
      for ( i=1; i <=n; i=i+1 )
      {
         t = t + vs[i,j] + "+";
      }
      t = t[1,size(t)-1] + ","+newline;
      s=s+t;
   }
   s=s+vs[1,n]+"-1";
   return (s);
}

ring r=0,(a,b,c,d,e),lp;         // basering, char 0, lex ordering
string sc=cyclic(nvars(basering));
sc;                              // the string of the ideal
==> a+b+c+d+e,
==> ab+bc+cd+de+ea,
==> abc+bcd+cde+dea+eab,
==> abcd+bcde+cdea+deab+eabc,
==> abcde-1
execute("ideal i="+sc+";");      // this defines the ideal of cyclic roots
i;
==> i[1]=a+b+c+d+e
==> i[2]=ab+bc+cd+ae+de
==> i[3]=abc+bcd+abe+ade+cde
==> i[4]=abcd+abce+abde+acde+bcde
==> i[5]=abcde-1
timer=1;
ideal j=std(i);
==> //used time: 7.5 sec
size(j);                         // number of elements in the std basis
==> 11
degree(j);
==> // codimension = 5
==> // dimension   = 0
==> // degree      = 70
<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
