D.4.1.11 finitenessTest
.......................
Procedure from library algebra.lib (see algebra_lib).

Usage:
finitenessTest(J[,v]); J ideal, v intvec (say v1,...,vr with vi>0)

Return:
         a list l with l[1] integer, l[2], l[3], l[4] ideals
         - l[1] = 1 if var(v1),...,var(vr) are in l[2] and 0 else
         - l[2] (resp. l[3]) contains those variables which occur,
           (resp. occur not) as pure power in the leading term of one of the
           generators of J,
         - l[4] contains those J[i] for which the leading term is a pure power
           of a variable (which is then in l[2])
         (default: v = [1,2,..,nvars(basering)])

Theory:
If J is a standard basis of an ideal generated by x_1 - f_1(y),...,
x_n - f_n with y_j ordered lexicographically and y_j >> x_i, then,
if y_i appears as pure power in the leading term of J[k]. J[k] defines
an integral relation for y_i over the y_(i+1),... and the f's.
Moreover, in this situation, if l[2] = y_1,...,y_r, then K[y_1,...y_r]
is finite over K[f_1..f_n]. If J contains furthermore polynomials
h_j(y), then K[y_1,...y_z]/<h_j> is finite over K[f_1..f_n].

Example:
LIB "algebra.lib";
ring s = 0,(x,y,z,a,b,c),(lp(3),dp);
ideal i= a -(xy)^3+x2-z, b -y2-1, c -z3;
ideal j = a -(xy)^3+x2-z, b -y2-1, c -z3, xy;
finitenessTest(std(i),1..3);
==> [1]:
==>    0
==> [2]:
==>    _[1]=y
==>    _[2]=z
==> [3]:
==>    _[1]=x
==>    _[2]=a
==>    _[3]=b
==>    _[4]=c
==> [4]:
==>    _[1]=z3-c
==>    _[2]=y2-b+1
finitenessTest(std(j),1..3);
==> [1]:
==>    1
==> [2]:
==>    _[1]=x
==>    _[2]=y
==>    _[3]=z
==> [3]:
==>    _[1]=a
==>    _[2]=b
==>    _[3]=c
==> [4]:
==>    _[1]=z3-c
==>    _[2]=y2-b+1
==>    _[3]=x2-z+a
<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
