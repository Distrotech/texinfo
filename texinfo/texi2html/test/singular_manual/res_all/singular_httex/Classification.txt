A.26 Classification
===================

Classification of isolated hypersurface singularities with respect to
right equivalence is provided by the command classify of the
library classify.lib. The classification is done using the
algorithm of Arnold. Before entering this algorithm, a first guess based
on the Hilbert polynomial of the Milnor algebra is made.

  LIB "classify.lib";
  ring r=0,(x,y,z),ds;
  poly p=singularity("E[6k+2]",2)[1];
  p=p+z^2;
  p;
==> z2+x3+xy6+y8
  // We received an E_14 singularity in normal form
  // from the database of normal forms. Since only the residual
  // part is saved in the database, we added z^2 to get an E_14
  // of embedding dimension 3.
  //
  // Now we apply a coordinate change in order to deal with a
  // singularity which is not in normal form:
  map phi=r,x+y,y+z,x;
  poly q=phi(p);
  // Yes, q really looks ugly, now:
  q;
==> x2+x3+3x2y+3xy2+y3+xy6+y7+6xy5z+6y6z+15xy4z2+15y5z2+20xy3z3+20y4z3+15xy2z\
   4+15y3z4+6xyz5+6y2z5+xz6+yz6+y8+8y7z+28y6z2+56y5z3+70y4z4+56y3z5+28y2z6+8\
   yz7+z8
  // Classification
  classify(q);
==> About the singularity :
==>           Milnor number(f)   = 14
==>           Corank(f)          = 2
==>           Determinacy       <= 12
==> Guessing type via Milnorcode:   E[6k+2]=E[14]
==> 
==> Computing normal form ...
==> I have to apply the splitting lemma. This will take some time....:-)
==>    Arnold step number 9
==> The singularity
==>    x3-9/4x4+27/4x5-189/8x6+737/8x7+6x6y+15x5y2+20x4y3+15x3y4+6x2y5+xy6-24\
   089/64x8-x7y+11/2x6y2+26x5y3+95/2x4y4+47x3y5+53/2x2y6+8xy7+y8+104535/64x9\
   +27x8y+135/2x7y2+90x6y3+135/2x5y4+27x4y5+9/2x3y6-940383/128x10-405/4x9y-2\
   025/8x8y2-675/2x7y3-2025/8x6y4-405/4x5y5-135/8x4y6+4359015/128x11+1701/4x\
   10y+8505/8x9y2+2835/2x8y3+8505/8x7y4+1701/4x6y5+567/8x5y6-82812341/512x12\
   -15333/8x11y-76809/16x10y2-25735/4x9y3-78525/16x8y4-16893/8x7y5-8799/16x6\
   y6-198x5y7-495/4x4y8-55x3y9-33/2x2y10-3xy11-1/4y12
==> is R-equivalent to E[14].
==>    Milnor number = 14
==>    modality      = 1
==> 2z2+x3+xy6+y8
  // The library also provides routines to determine the corank of q
  // and its residual part without going through the whole
  // classification algorithm.
  corank(q);
==> 2
  morsesplit(q);
==> y3-9/4y4+27/4y5-189/8y6+737/8y7+6y6z+15y5z2+20y4z3+15y3z4+6y2z5+yz6-24089\
   /64y8-y7z+11/2y6z2+26y5z3+95/2y4z4+47y3z5+53/2y2z6+8yz7+z8+104535/64y9+27\
   y8z+135/2y7z2+90y6z3+135/2y5z4+27y4z5+9/2y3z6-940383/128y10-405/4y9z-2025\
   /8y8z2-675/2y7z3-2025/8y6z4-405/4y5z5-135/8y4z6+4359015/128y11+1701/4y10z\
   +8505/8y9z2+2835/2y8z3+8505/8y7z4+1701/4y6z5+567/8y5z6-82812341/512y12-15\
   333/8y11z-76809/16y10z2-25735/4y9z3-78525/16y8z4-16893/8y7z5-8799/16y6z6-\
   198y5z7-495/4y4z8-55y3z9-33/2y2z10-3yz11-1/4z12
<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
