D.5.5.1 hnexpansion
...................
Procedure from library hnoether.lib (see hnoether_lib).

Usage:
hnexpansion(f); or hnexpansion(f,"ess"); f poly

Usage:
hnexpansion(f); f poly

Assume:
f is a bivariate polynomial (in the first 2 ring variables)

Create:
ring with variables x,y and ordering ls over a
field extension of the current basering's ground field, 
since the Hamburger-Noether development usually does not exist
in the originally given basering. The field extension is chosen
minimally.

Moreover, in the ring a list hne of lists hne[i] is
created (corresponding to the output of develop(f[i]),
f[i] a branch of f, but the last entry being omitted).

hne[i][1]; matrix:
         Each row contains the coefficients of the corresponding line of the
         Hamburger-Noether expansion (HNE) for f[i]. The end of the line is
         marked in the matrix by the first ring variable (usually x).
hne[i][2]; intvec:
         indicating the length of lines of the HNE
hne[i][3]; int:
         0  if the 1st ring variable was transversal (with respect to f[i]), 

         1  if the variables were changed at the beginning of the
            computation, 

        -1  if an error has occurred.
hne[i][4]; poly:
         the transformed polynomial of f[i] to make it possible to extend the
         Hamburger-Noether development a posteriori without having to do
         all the previous calculation once again (0 if not needed)

Return:
a list, say hn, containing the created ring

Note:
to use the ring type: def HNEring=hn[i]; setring HNEring;.


If f is known to be irreducible as a power series, develop(f)
could be chosen instead to avoid the change of basering. 

Increasing printlevel leads to more and more comments.

Usage:
hnexpansion(f,"ess"); f poly

Assume:
f is a bivariate polynomial (in the first 2 ring variables)

Create:
ring with variables x,y and ordering ls over a
field extension of the current basering's ground field, 
since the Hamburger-Noether development usually does not exist
in the originally given basering. The field extension is chosen
minimally.


Moreover, in the ring a list hne of lists hne[i] is
created (corresponding to the output of develop(f[i]), f[i] an
"essential" branch of f, but the last entry being omitted). See
hnexpansion above for more details.

Return:
a list, say hn, containing the created ring

Note:
to use the ring type: def hnering=hn[i]; setring hnering;.


Alternatively you may use the procedure sethnering and type:
sethnering(hn);


If the HNE needs a field extension, some of the branches will be
conjugate. In this case hnexpansion(f,"ess") reduces the
computation to one representative for each group of conjugate
branches.

Note that the degree of each branch is in general less than the degree
of the field extension in which all HNEs can be put.

Use hnexpansion(f) to compute a complete HNE, i.e., a HNE for
all branches.

Increasing printlevel leads to more and more comments.

Example:
LIB "hnoether.lib";
ring r=0,(x,y),ls;
list hn=hnexpansion(x4-y6);
show(hn);
==> // list, 1 element(s):
==> [1]:
==>    // ring: (0),(x,y),(ls(2),C);
==>    // minpoly = 0
==> // objects belonging to this ring:
==> // hne                  [0]  list, size: 2
def hnering=hn[1];
setring hnering;
size(hne);           // number of branches
==> 2
print(hne[1][1]);    // HN-matrix of 1st branch
==> 0,x,0,
==> 0,1,x 
parametrisation(hne);    // parametrization of the two branches
==> [1]:
==>    _[1]=x3
==>    _[2]=x2
==> [2]:
==>    _[1]=-x3
==>    _[2]=-x2
/////////////////////////////////////////////////////////
ring s=2,(x,y),ls;
poly f=(x4+x2y+y2)*(x3+xy2+y3);
// --------- compute all branches: ---------
hn=hnexpansion(f);
==> // new minimal polynomial: a6+a5+a3+a2+1
hnering=hn[1];
setring hnering;
displayHNE(hne[1]);   // HN-matrix of 1st branch
==> HNE[1]=y+(a^4+a+1)*z(0)
==> HNE[2]=x+z(0)
displayHNE(hne[4]);   // HN-matrix of 4th branch
==> HNE[1]=y+(a^4+a^2+a+1)*z(0)^2
==> HNE[2]=x+z(0)
setring s;
// --- compute only one of conjugate branches: ---
hn=hnexpansion(f,"ess");
==> // new minimal polynomial: a6+a5+a3+a2+1
hnering=hn[1];
setring hnering;
displayHNE(hne);
==> // Hamburger-Noether development of branch nr.1:
==> HNE[1]=y+(a^4+a^2)*z(0)
==> HNE[2]=x+z(0)
==> 
==> // Hamburger-Noether development of branch nr.2:
==> HNE[1]=y+(a^4+a^2+a)*z(0)^2
==> HNE[2]=x+z(0)
==> 
// no. 1 of hnexpansion(f,"ess") represents no. 1 - 3 of hnexpansion(f) and
// no. 2 of hnexpansion(f,"ess") represents no. 4 + 5 of hnexpansion(f)
See also:
develop;
displayHNE;
extdevelop;
parametrisation.


<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
