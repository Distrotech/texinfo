A.12 Computation of Ext
=======================

We start by showing how to calculate the 
$n$
-th Ext group of an
ideal. The ingredients to do this are by the definition of Ext the
following: calculate a (minimal) resolution at least up to length

$n$
, apply the Hom-functor, and calculate the 
$n$
-th homology
group, that is form the quotient
$\hbox{\rm ker} / \hbox{\rm Im}$
in the resolution sequence.

The Hom functor is given simply by transposing (hence dualizing) the
module or the corresponding matrix with the command transpose.
The image of the 
$(n-1)$
-st map is generated by the columns of the
corresponding matrix. To calculate the kernel apply the command
syz at the 
$(n-1)$
-st transposed entry of the resolution.
Finally, the quotient is obtained by the command modulo, which
gives for two modules A = ker, B = Im the module of relations of
$A/(A \cap B)$
in the usual way. As we have a chain complex this is obviously the same
as ker/Im.

We collect these statements in the following short procedure:

proc ext(int n, ideal I)
{
  resolution rs = mres(I,n+1);
  module tAn    = transpose(rs[n+1]);
  module tAn_1  = transpose(rs[n]);
  module ext_n  = modulo(syz(tAn),tAn_1);
  return(ext_n);
}

Now consider the following example:

ring r5 = 32003,(a,b,c,d,e),dp;
ideal I = a2b2+ab2c+b2cd, a2c2+ac2d+c2de,a2d2+ad2e+bd2e,a2e2+abe2+bce2;
print(ext(2,I));
==> 1,0,0,0,0,0,0,
==> 0,1,0,0,0,0,0,
==> 0,0,1,0,0,0,0,
==> 0,0,0,1,0,0,0,
==> 0,0,0,0,1,0,0,
==> 0,0,0,0,0,1,0,
==> 0,0,0,0,0,0,1
ext(3,I);   // too big to be displayed here

The library homolog.lib contains several procedures for computing
Ext-modules and related modules, which are much more general and
sophisticated then the above one. They are used in the following
example.

If 
$M$
 is a module, then
$\hbox{Ext}^1(M,M)$, resp.\ $\hbox{Ext}^2(M,M)$,
are the modules of infinitesimal deformations, resp. of obstructions, of

$M$
 (like T1 and T2 for a singularity).  Similar to the treatment
for singularities, the semiuniversal deformation of 
$M$
 can be
computed (if
$\hbox{Ext}^1$
is finite dimensional) with the help of
$\hbox{Ext}^1$, $\hbox{Ext}^2$
and the cup product. There is an extra procedure for
$\hbox{Ext}^k(R/J,R)$
if 
$J$
 is an ideal in 
$R$
 since this is faster than the
general Ext.

We compute
* the infinitesimal deformations
($=\hbox{Ext}^1(K,K)$)
and obstructions
($=\hbox{Ext}^2(K,K)$)
of the residue field 
$K=R/m$
 of an ordinary cusp,
$R=Loc_m K[x,y]/(x^2-y^3)$, $m=(x,y)$.
To compute
$\hbox{Ext}^1(m,m)$
we have to apply Ext(1,syz(m),syz(m)) with
syz(m) the first syzygy module of 
$m$
, which is isomorphic to
$\hbox{Ext}^2(K,K)$.
* $\hbox{Ext}^k(R/i,R)$
for some ideal 
$i$
 and with an extra option.

  LIB "homolog.lib";
  ring R=0,(x,y),ds;
  ideal i=x2-y3;
  qring q = std(i);      // defines the quotient ring Loc_m k[x,y]/(x2-y3)
  ideal m = maxideal(1);
  module T1K = Ext(1,m,m);  // computes Ext^1(R/m,R/m)
==> // dimension of Ext^1:  0
==> // vdim of Ext^1:       2
==> 
  print(T1K);
==> 0,  0,y,x,0,y,0,    x2-y3,
==> -y2,x,x,0,y,0,x2-y3,0,    
==> 1,  0,0,0,0,0,0,    0     
  printlevel=2;             // gives more explanation
  module T2K=Ext(2,m,m);    // computes Ext^2(R/m,R/m)
==> // Computing Ext^2 (help Ext; gives an explanation):
==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
==> // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
==> // then Hom(F2,G0)-->Hom(F3,G0) is given by:
==> y2,x,
==> x, y 
==> // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
==> -y,x,  x,0,y,0,
==> x, -y2,0,x,0,y 
==> 
==> // dimension of Ext^2:  0
==> // vdim of Ext^2:       2
==> 
  print(std(T2K));
==> -y2,0,x,0,y,
==> 0,  x,0,y,0,
==> 1,  0,0,0,0 
  printlevel=0;
  module E = Ext(1,syz(m),syz(m));
==> // dimension of Ext^1:  0
==> // vdim of Ext^1:       2
==> 
  print(std(E));
==> -y,x, 0, 0,0,x,0,y,
==> 0, -y,-y,0,x,0,y,0,
==> 0, 0, 0, 1,0,0,0,0,
==> 0, 0, 1, 0,0,0,0,0,
==> 0, 1, 0, 0,0,0,0,0,
==> 1, 0, 0, 0,0,0,0,0 
  //The matrices which we have just computed are presentation matrices
  //of the modules T2K and E. Hence we may ignore those columns
  //containing 1 as an entry and see that T2K and E are isomorphic
  //as expected, but differently presented.
  //-------------------------------------------
  ring S=0,(x,y,z),dp;
  ideal  i = x2y,y2z,z3x;
  module E = Ext_R(2,i);
==> // dimension of Ext^2:  1
==> 
  print(E);
==> 0,y,0,z2,
==> z,0,0,-x,
==> 0,0,x,-y 
  // if a 3-rd argument is given (of any type)
  // a list of Ext^k(R/i,R), a SB of Ext^k(R/i,R) and a vector space basis
  // is returned:
  list LE = Ext_R(3,i,"");
==> // dimension of Ext^3:  0
==> // vdim of Ext^3:       2
==> 
  LE;
==> [1]:
==>    _[1]=y*gen(1)
==>    _[2]=x*gen(1)
==>    _[3]=z2*gen(1)
==> [2]:
==>    _[1]=y*gen(1)
==>    _[2]=x*gen(1)
==>    _[3]=z2*gen(1)
==> [3]:
==>    _[1,1]=z
==>    _[1,2]=1
  print(LE[2]);
==> y,x,z2
  print(kbase(LE[2]));
==> z,1
<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
