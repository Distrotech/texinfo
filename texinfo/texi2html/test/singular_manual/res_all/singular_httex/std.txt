5.1.121 std
-----------
Syntax:
std ( ideal_expression)

std ( module_expression)

std ( ideal_expression, intvec_expression )

std ( module_expression, intvec_expression )

std ( ideal_expression, intvec_expression, intvec_expression )

std ( module_expression, intvec_expression, intvec_expression )

std ( ideal_expression, poly_expression )

std ( module_expression, vector_expression )
Type:
ideal or module
Purpose:
returns a standard basis of an ideal or module with respect to the
monomial ordering of the basering.
A standard basis is a set of generators such that
the leading terms generate the leading ideal, resp. module.

Use an optional
second argument of type intvec as Hilbert series
(result of hilb(i,1), see hilb),
if the ideal, resp. module, is homogeneous
(Hilbert driven standard basis computation, stdhilb).
If the ideal is quasihomogeneous with some weights w and if the Hilbert series
is computed w.r.t. to these weights, then use w as third argument.

Use an optional second argument of type poly, resp. vector,
to construct the standard basis from an already computed one (given as the
first argument) and one additional generator (the second argument).
Note:
The
standard basis is computed with a (more or less) straight-forward
implementation of the classical
Buchberger (resp. Mora) algorithm. For global orderings, use the
groebner command instead (see groebner), which heuristically
chooses the "best" algorithm to compute a Groebner basis.

To view the progress of long running computations, use
option(prot) (see option(prot)).

Example:
  // local computation
  ring r=32003,(x,y,z),ds;
  poly s1=1x2y+151xyz10+169y21;
  poly s2=1xz14+6x2y4+3z24;
  poly s3=5y10z10x+2y20z10+y10z20+11x3;
  ideal i=s1,s2,s3;
  ideal j=std(i);
  degree(j);
==> 0
  // Hilbert driven elimination (standard)
  ring rhom=32003,(x,y,z,h),dp;
  ideal i=homog(imap(r,i),h);
  ideal j=std(i);
  intvec iv=hilb(j,1);
  ring rlex=32003,(x,y,z,h),lp;
  ideal i=fetch(rhom,i);
  ideal j=std(i,iv);
  j=subst(j,h,1);
  j[1];
==> z64
  // Hilbert driven elimination (ideal is quasihomogeneous)
  intvec w=10,1,1;
  ring whom=32003,(x,y,z),wp(w);
  ideal i=fetch(r,i);
  ideal j=std(i);
  intvec iw=hilb(j,1,w);
  ring wlex=32003,(x,y,z),lp;
  ideal i=fetch(whom,i);
  ideal j=std(i,iw,w);
  j[1];
==> z64
See
facstd;
fglm;
groebner;
ideal;
mstd;
option;
ring;
stdfglm;
stdhilb.

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
