D.4.1.2 module_containment
..........................
Procedure from library algebra.lib (see algebra_lib).

Usage:
module_containment(p,P,M[,k]); p poly, P ideal, M ideal, k int

 P = P[1],...,P[n] generators of a subalgebra of the basering,

 M = M[1],...,M[m] generators of a module over the subalgebra K[P]

Assume:
ncols(P) = nvars(basering), the P[i] are algebraically independent

Return:
         - k=0 (or if k is not given), an integer:
           1    : if p is contained in the module <M[1],...,M[m]> over K[P]
           0    : if p is not contained in <M[1],...,M[m]>
         - k=1, a list, say l, of size 2, l[1] integer, l[2] ring:
           l[1]=1 : if p is in <M[1],...,M[m]> and then the ring l[2] contains
             the polynomial check = h(y(1),...,y(m),z(1),...,z(n)) if
             p = h(M[1],...,M[m],P[1],...,P[n])
           l[1]=0 : if p is in not in <M[1],...,M[m]>, then l[2] contains the
             poly check = h(x,y(1),...,y(m),z(1),...,z(n)) if p satisfies
             the nonlinear relation p = h(x,M[1],...,M[m],P[1],...,P[n]) where
             x = x(1),...,x(n) denote the variables of the basering

Display:
the polynomial h(y(1),...,y(m),z(1),...,z(n)) if k=0, resp.
a comment how to access the relation check if k=1, provided
printlevel >= voice+1 (default).

Theory:
The ideal of algebraic relations of all the generators p1,...,pn,
s1,...,st given by P and S is computed introducing new variables y(j),
z(i) and the product order: x^a*y^b*z^c > x^d*y^e*z^f if x^a > x^d
with respect to the lp ordering or else if z^c > z^f with respect to
the dp ordering or else if y^b > y^e with respect to the lp ordering
again. p reduces to a polynomial only in the y(j) and z(i), linear in
the z(i) <=> p is contained in the module.

Example:
LIB "algebra.lib";
int p = printlevel; printlevel = 1;
ring R=0,(x,y,z),dp;
ideal P = x2+y2,z2,x4+y4;           //algebra generators
ideal M = 1,x2z-1y2z,xyz,x3y-1xy3;  //module generators
poly p1=
x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
module_containment(p1,P,M);
==> // y(2)*z(2)*z(3)^2+z(1)^3*z(2)^2
==> 1
poly p2=z;
list l = module_containment(p2,P,M,1);
==> 
==> // 'module_containment' created a ring as 2nd element of the list. The
==> // ring contains the poly check which defines the algebraic relation
==> // for p. To access to the ring and see check you must give the ring
==> // a name, e.g.:
==>      def S = l[2]; setring S; check;
==>       
l[1];
==> 0
def S = l[2]; setring S; check;
==> x(3)
printlevel=p;

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
