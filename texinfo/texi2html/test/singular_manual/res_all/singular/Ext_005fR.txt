D.4.3.4 Ext_R
.............
Procedure from library homolog.lib (see homolog_lib).

Usage:
Ext_R(v,M[,p]); v int resp. intvec , M module, p int

Compute:
A presentation of Ext^k(M',R); for k=v[1],v[2],..., M'=coker(M).
Let
  0 <-- M' <-- F0 <-M-- F1 <-- F2 <-- ...
be a free resolution of M'. If
        0 --> F0* -A1-> F1* -A2-> F2* -A3-> ...
is the dual sequence, Fi*=Hom(Fi,R), then Ext^k = ker(Ak+1)/im(Ak)
is presented as in the following exact sequences:
    R^p --syz(Ak+1)-> Fk* ---Ak+1---->  Fk+1* ,
    R^q ----Ext^k---> R^p --syz(Ak+1)-> Fk*/im(Ak).
Hence, Ext^k=modulo(syz(Ak+1),Ak) presents Ext^k(M',R).

Return:
- module Ext, a presentation of Ext^k(M',R) if v is of type int

- a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.

- In case of a third argument of type int return a list l:
     l[1] = module Ext^k resp. list of Ext^k
     l[2] = SB of Ext^k resp. list of SB of Ext^k
     l[3] = matrix resp. list of matrices, each representing a kbase of Ext^k 
              (if finite dimensional)

Display:
printlevel >=0: (affine) dimension of Ext^k for each k (default)
printlevel >=1: Ak, Ak+1 and kbase of Ext^k in Fk*

Note:
In order to compute Ext^k(M,R) use the command Ext_R(k,syz(M));
or the 2 commands: list L=mres(M,2); Ext_R(k,L[2]);

Example:
LIB "homolog.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 0,(x,y,z),dp;
ideal i    = x2y,y2z,z3x;
module E   = Ext_R(1,i);    //computes Ext^1(r/i,r)
==> // Computing Ext^1:
==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
==> // then F1*-->F2* is given by:
==> x2, -yz,0,  
==> 0,  z3, -xy,
==> xz2,0,  -y2 
==> // and F0*-->F1* is given by:
==> y2z,
==> x2y,
==> xz3 
==> 
==> // dimension of Ext^1:  -1
==> 
is_zero(E);
==> 1
qring R    = std(x2+yz);
intvec v   = 0,2;
printlevel = 2;             //shows what is going on
ideal i    = x,y,z;         //computes Ext^i(r/(x,y,z),r/(x2+yz)), i=0,2
list L     = Ext_R(v,i,1);  //over the qring R=r/(x2+yz), std and kbase
==> // Computing Ext^0:
==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
==> // then F0*-->F1* is given by:
==> z,
==> y,
==> x 
==> // and F-1*-->F0* is given by:
==> 0
==> 
==> // dimension of Ext^0:  -1
==> 
==> // columns of matrix are kbase of Ext^0 in F0*:
==> 0
==> 
==> // Computing Ext^2:
==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
==> // then F2*-->F3* is given by:
==> x,-y,z, 0,
==> z,x, 0, z,
==> 0,0, x, y,
==> 0,0, -z,x 
==> // and F1*-->F2* is given by:
==> y,-z,0, 
==> x,0, -z,
==> 0,x, -y,
==> 0,z, x  
==> 
==> // dimension of Ext^2:  0
==> // vdim of Ext^2:       1
==> 
==> // columns of matrix are kbase of Ext^2 in F2*:
==> x, 
==> -z,
==> 0, 
==> 0  
==> 
printlevel = p;

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
