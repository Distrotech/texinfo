5.1.42 groebner
---------------
Procedure from library standard.lib (see standard_lib).

Syntax:
groebner ( ideal_expression ) 

groebner ( module_expression ) 

groebner ( ideal_expression, int_expression ) 

groebner ( module_expression, int_expression )

Type:
type of the first argument

Purpose:
computes the standard basis of the first argument I
(ideal or module), by a heuristically chosen method: if the
ordering of the current ring is a local ordering, or if it is a
non-block ordering and the current ring has no parameters, then
std(I) is returned. Otherwise, I is mapped into a
ring with no parameters and ordering dp, where its Hilbert series
is computed. This is followed by a Hilbert-series based std
computation in the original ring.

Note:
If a 2nd argument wait is given, then the computation proceeds
at most wait seconds. That is, if no result could be computed in
wait seconds, then the computation is interrupted, 0 is returned,
a warning message is displayed, and the global variable
groebner_error is defined.

Example:
  ring r=0,(a,b,c,d),lp;
option(prot);
ideal i=a+b+c+d,ab+ad+bc+cd,abc+abd+acd+bcd,abcd-1; // cyclic 4
groebner(i);
==> std in (0),(a,b,c,d,@t),(dp,C)
==> [63:1]1(3)s2(2)s3s4-s5ss6-s7--
==> product criterion:8 chain criterion:5
==> std with hilb in  (0),(a,b,c,d,@t),(lp(4),C)
==> [63:1]1(3)s2(2)s3s4-s5ss6shhhh8shh
==> product criterion:9 chain criterion:8
==> hilbert series criterion:6
==> dehomogenization
==> imap to original ring
==> simplification
==> _[1]=c2d6-c2d2-d4+1
==> _[2]=c3d2+c2d3-c-d
==> _[3]=bd4-b+d5-d
==> _[4]=bc-bd5+c2d4+cd-d6-d2
==> _[5]=b2+2bd+d2
==> _[6]=a+b+c+d
ring rp=(0,a,b),(c,d), lp;
ideal i=imap(r,i);
ideal j=groebner(i);
==> std in 0,(c,d,a,b,@t),(dp,C)
==> [63:1]1(3)s2(2)s3s4-s5ss6-s7--
==> product criterion:8 chain criterion:5
==> std with hilb in  (0),(c,d,a,b,@t),(lp(2),C, dp(3))
==> [63:3]1(3)s2(2)s3s4-s5ss6shhhh8shh
==> product criterion:9 chain criterion:8
==> hilbert series criterion:6
==> dehomogenization
==> imap to original ring
==> simplification
option(noprot);
j; simplify(j,1); std(i);
==> j[1]=(a3b2+a2b3-a-b)
==> _[1]=1
==> _[1]=1
if (system("with","MP")) {groebner(i,0);}
==> // ** groebner did not finish
==> _[1]=0
defined(groebner_error);
==> 1
See also:
std;
stdfglm;
stdhilb.


<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
