D.5.3.5 control_Matrix
......................
Procedure from library equising.lib (see equising_lib).

Assume:
L is the output of multsequence(reddevelop(f)).

Return:
list M of 4 intmat's:
  M[1] contains the multiplicities at the respective infinitely near points 
       p[i,j] (i=step of blowup+1, j=branch) - if branches j=k,...,k+m pass 
       through the same p[i,j] then the multiplicity is stored in M[1][k,j], 
       while M[1][k+1]=...=M[1][k+m]=0.   
  M[2] contains the number of branches meeting at p[i,j] (again, the information 
       is stored according to the above rule)   
  M[3] contains the information about the splitting of M[1][i,j] with respect to 
       different tangents of branches at p[i,j] (information is stored only for 
       minimal j>=k corresponding to a new tangent direction). 
       The entries are the sum of multiplicities of all branches with the 
       respective tangent.
  M[4] contains the maximal sum of higher multiplicities for a branch passing 
       through p[i,j] ( = degree Bound for blowing up)  

Note:
the branches are ordered in such a way that only consecutive branches
can meet at an infinitely near point. 

the final rows of the matrices M[1],...,M[3] is (1,1,1,...,1), and
correspond to infinitely near points such that the strict transforms
of the branches are smooth and intersect the exceptional divisor
transversally.

See also:
multsequence.

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
