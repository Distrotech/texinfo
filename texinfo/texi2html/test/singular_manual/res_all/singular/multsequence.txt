D.5.5.9 multsequence
....................
Procedure from library hnoether.lib (see hnoether_lib).

Usage:
multsequence(INPUT); INPUT list or poly

Assume:
INPUT is the output of develop(f), or of extdevelop(develop(f),n),
or one entry in the list hne of the ring created by hnexpansion(f).

Return:
intvec corresponding to the multiplicity sequence of (a branch)
of the curve (the same as invariants(INPUT)[6]).

Assume:
INPUT is a bivariate polynomial, or the output of hnexpansion(f),
or the list hne in the ring created by hnexpansion(f).

Return:
list of two integer matrices:

multsequence(INPUT)[1][i,*]
   contains the multiplicities of the branches at their infinitely near point
   of 0 in its (i-1) order neighbourhood (i.e., i=1: multiplicity of the
   branches themselves, i=2: multiplicity of their 1st quadratic transformed,
   etc., 

   Hence, multsequence(INPUT)[1][*,j] is the multiplicity sequence
   of branch j.
multsequence(INPUT)[2][i,*]:
   contains the information which of these infinitely near points coincide.

Note:
The order of elements of the list hne obtained from hnexpansion(f[,"ess")
must not be changed (because then the coincident infinitely near points
couldn't be grouped together, cf. meaning of 2nd intmat in example).
Hence, it is not wise to compute the HNE of several polynomials
separately, put them into a list INPUT and call multsequence(INPUT). 

Use displayMultsequence to produce a better readable output for
reducible curves on the screen. 

In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of hnexpansion and use it as input instead of
the polynomial itself.

Example:
LIB "hnoether.lib";
// -------- prepare for example ---------
if (nameof(basering)=="HNEring") {
def rettering=HNEring;
kill HNEring;
}
// ------ the example starts here -------
ring r=0,(x,y),dp;
list hn=hnexpansion((x6-y10)*(x+y2-y3)*(x+y2+y3));   // 4 branches
def HNEring=hn[1];
setring HNEring;
multsequence(hne[1]),"  |  ",multsequence(hne[2]),"  |  ",
multsequence(hne[3]),"  |  ",multsequence(hne[4]);
==> 3,2,1,1   |   3,2,1,1   |   1   |   1
multsequence(hne);
==> [1]:
==>    3,3,1,1,
==>    2,2,1,1,
==>    1,1,1,1,
==>    1,1,1,1,
==>    1,1,1,1 
==> [2]:
==>    4,0,0,0,
==>    4,0,0,0,
==>    2,2,0,0,
==>    2,1,1,0,
==>    1,1,1,1 
// The meaning of the entries of the 2nd matrix is as follows:
displayMultsequence(hne);
==> [(3,3,1,1)],
==> [(2,2,1,1)],
==> [(1,1),(1,1)],
==> [(1,1),(1),(1)],
==> [(1),(1),(1),(1)]
// --- restore HNEring if previously defined ---
kill HNEring,r;
if (defined(rettering)) {
setring rettering;
def HNEring=rettering;
export HNEring;
}
See also:
develop;
displayMultsequence;
hnexpansion;
separateHNE.


<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
