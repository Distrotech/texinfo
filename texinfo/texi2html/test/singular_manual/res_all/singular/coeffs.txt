5.1.10 coeffs
-------------

Syntax:
coeffs ( poly_expression , ring_variable )

coeffs ( ideal_expression, ring_variable )

coeffs ( vector_expression, ring_variable )

coeffs ( module_expression, ring_variable )

coeffs ( poly_expression, ring_variable, matrix_name )

coeffs ( ideal_expression, ring_variable, matrix_name )

coeffs ( vector_expression, ring_variable, matrix_name )

coeffs ( module_expression, ring_variable, matrix_name )
Type:
matrix
Purpose:
develops each polynomial of the first argument, say J,
as a univariate polynomial in the given ring_variable,
say z, and returns the coefficients as a k x d
matrix M,
where:
    d-1 = maximum z-degree of all occurring polynomials
      k = 1 if J is a polynomial,
      k = number of generators  if J is an ideal.
If J is a vector or a module this procedure is repeated for each
component and the resulting matrices are appended.

The third argument is used to return the matrix T of coefficients
such that {\tt matrix}(J) = T*M.
Note:
coeffs returns the coefficient 0 at the appropriate place if a monomial
is not present, while coef considers only monomials which really occur
in the given expression. 

If
$M=(m_{ij})$
then the j-th generator of an ideal J is equal to
$$J_j = z^0 \cdot m_{1j} + z^1 \cdot m_{2j} + ... + z^{d-1} \cdot m_{dj},$$
while for a module J the i-th component of the j-th generator is
equal to the entry [i,j] of {\tt matrix}(J), and we get
$$ J_{i,j} = z^0 \cdot m_{(i-1)d+1,j} + z^1 \cdot m_{(i-1)d+2,j} + ... +
z^{d-1} \cdot m_{id,j}.$$

Example:
  ring r;
  poly f=(x+y)^3;
  matrix M=coeffs(f,y);
  print(M);
==> x3, 
==> 3x2,
==> 3x, 
==> 1   
  ideal i=f,xyz+z10y4;
  print(coeffs(i,y));
==> x3, 0, 
==> 3x2,xz,
==> 3x, 0, 
==> 1,  0, 
==> 0,  z10
Syntax:
coeffs ( ideal_expression, ideal_expression )

coeffs ( module_expression, module_expression )

coeffs ( ideal_expression, ideal_expression, product_of_ringvars )

coeffs ( module_expression, module_expression, product_of_ringvars )
Type:
matrix
Purpose:
let the first argument be M,
the second argument  be K (a set of monomials, resp. vectors with monomial
entries, in the variables appearing in P),
the third argument be the product P of variables to consider (if this
argument is not given, then the product of all ring variables is taken
as default argument).

M is supposed to consist of elements of (resp. have entries in)
a finitely generated module
over a ring in the variables not appearing in P. K should contain the
generators of M over this smaller ring.
Then coeffs(M,K,P) returns a matrix A of coefficients with K*A=M
such that the entries of A do not contain any variable from P.

If K does not contain all generators that are necessary to express
M, then K*A=M' where M' is the part of M that can be expressed.

Example:
  ring r=32003,(x,y,z),dp;
  ideal M=x2z+y3,xy;
  print(coeffs(M,ideal(x2,xy,y2),xy));
==> z,0,
==> 0,1,
==> 0,0 
  print(coeffs(M,ideal(x2,xy,y2)));
==> 0,0,
==> 0,1,
==> 0,0 
See
coef;
kbase.
<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
