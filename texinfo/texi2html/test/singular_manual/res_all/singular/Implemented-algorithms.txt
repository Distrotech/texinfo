3.4 Implemented algorithms
==========================

The basic algorithm in SINGULAR is a general standard basis algorithm for
any monomial ordering which is compatible with the natural semi-group
structure of the exponents. This includes well-orderings
(Buchberger algorithm to compute a Groebner basis)
and tangent cone orderings (Mora algorithm) as special cases.

Nonetheless, there are a lot of other important algorithms:
* Algorithms to compute the standard operations on ideals and modules:
intersection, ideal quotient, elimination, etc.

* Different Syzygy algorithms and algorithms to compute free resolutions
of modules.

* Combinatorial algorithms to compute dimensions, Hilbert series,
multiplicities, etc.

* Algorithms for univariate and multivariate polynomial factorization,
resultant and gcd computations.

Commands to compute standard bases
----------------------------------
facstd
facstd

computes a list of Groebner bases via the Factorizing Groebner Basis
Algorithm, i.e., their intersection has the same radical as the original ideal. It need not
be a Groebner basis of the given ideal.

The intersection of the zero-sets is the zero-set of the given ideal.
fglm
fglm

computes a Groebner basis provided that a reduced Groebner basis
w.r.t. another ordering is given.

Implements the so-called FGLM (Faugere, Gianni, Lazard, Mora) algorithm.
The given ideal must be zero-dimensional.
groebner
groebner

computes a standard resp. Groebner bases using a heuristically chosen
method.

This is the preferred method to compute a standard resp. Groebner
bases.
mstd
mstd

computes a standard basis and a minimal set of generators.
std
std

computes a standard resp. Groebner basis.
stdfglm
stdfglm

computes a Groebner basis in a ring with a "difficult" ordering
(e.g., lexicographical) via std w.r.t. a "simple" ordering and
fglm.

The given ideal must be zero-dimensional.
stdhilb
stdhilb

computes a Groebner basis in a ring with a "difficult" ordering
(e.g., lexicographical) via std w.r.t. a "simple" ordering
and a std computation guided by the Hilbert series.

Further processing of standard bases
------------------------------------
The next commands require the input to be a standard basis.

degree
degree

computes the (Krull) dimension, codimension and the multiplicity.

The result is only displayed on the screen.
dim
dim

computes the dimension of the ideal resp. module.
highcorner
highcorner

computes the smallest monomial not contained in the ideal resp. module.
The ideal resp. module has to be finite dimensional as a vector space
over the ground field.
hilb
hilb

computes the first, and resp. or, second Hilbert series of an ideal
resp. module.
kbase
kbase
 computes a vector space basis (consisting of monomials) of
the quotient of a ring by an ideal resp. of a free module by a
submodule.

The ideal resp. module has to be finite dimensional as a vector space
over the ground field and has to be represented by a standard basis w.r.t.
the ring ordering.
mult
mult

computes the degree of the monomial ideal resp. module generated by
the leading monomials of the input.
reduce
reduce

reduces a polynomial, vector, ideal or module to its normal form with
respect to an ideal or module represented by a standard basis.
vdim
vdim

computes the vector space dimension of a ring (resp. free module)
modulo an ideal (resp. module).

Commands to compute resolutions
-------------------------------
res
res

computes a free resolution of an ideal or module using a heuristically
chosen method.
This is the preferred method to compute free resolutions of ideals or
modules.
lres
lres

computes a free resolution of an ideal or module with La Scala's
method. The input needs to be homogeneous.
mres
mres

computes a minimal free resolution of an ideal or module with the Syzygy
method.
sres
sres

computes a free resolution of an ideal or module with Schreyer's
method. The input has to be a standard basis.
nres
nres

computes a free resolution of an ideal or module with the standard basis
method.
syz
syz

computes the first Syzygy (i.e., the module of relations of the
given generators).

Further processing of resolutions
---------------------------------
betti
betti

computes the graded Betti numbers of a module from a free resolution.
minres
minres

minimizes a free resolution of an ideal or module.
regularity
regularity

computes the regularity of a homogeneous ideal resp. module from a given
minimal free resolution.

Processing of polynomials
-------------------------
char_series
char_series

computes characteristic sets of polynomial ideals.
extgcd
extgcd

computes the extended gcd of two polynomials.

Implemented as extended Euclidean Algorithm.  Applicable for univariate
polynomials only.
factorize
factorize

computes factorization of univariate and multivariate polynomials into
irreducible factors.

The most basic algorithm is univariate factorization in prime
characteristic.  The Cantor-Zassenhaus Algorithm is used in this case.
For characteristic 0, a univariate Hensel-lifting is done to lift from
prime characteristic to characteristic 0.  For multivariate
factorization in any characteristic, the problem is reduced to the
univariate case first, then a multivariate Hensel-lifting is used to
lift the univariate factorization.

Note that there is no factorization of polynomials over algebraic
extensions of Q.
gcd
gcd

computes greatest common divisors of univariate and multivariate polynomials.

For prime characteristic, a subresultant gcd is used.  In characteristic 0, a
modular algorithm is used for the univariate case.  For the multivariate case,
the EZGCD is used.

Note that there is no gcd calculation for polynomials over algebraic
extensions of Q.
resultant
resultant

computes the resultant of two univariate polynomials using the subresultant
algorithm.

Multivariate polynomials are considered as univariate polynomials in the
main variable (which has to be specified by the user).
vandermonde
vandermonde

interpolates a polynomial from its values at several points

Matrix computations
-------------------
bareiss
bareiss

implements sparse Gauss-Bareiss method for elimination (matrix
triangularization) in arbitrary integral domains.
det
det

computes the determinant of a square matrix.

For matrices with integer entries a modular algorithm is used.  For
other domains the Gauss-Bareiss method is used.
minor
minor

computes all minors (=subdeterminants) of a given size for a matrix.

Numeric computations
--------------------
laguerre
laguerre

computes all (complex) roots of a univariate polynomial
uressolve
uressolve

find all roots of 0-dimensional ideal i with multivariate resultants

Controlling computations
------------------------
option
option

allows setting of options for manipulating the behavior of computations
(such as reduction strategies) and for showing protocol information indicating
the progress of a computation.

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
