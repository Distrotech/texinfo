6.3 Miscellaneous oddities
==========================

1. integer division

If two numerical constants (i.e., two sequences of digits) are divided
using the / operator, the surrounding whitespace determines
which division to use: if there is no space between the constants and
the / operator (e.g., "3/2"), both numerical constants are
treated as of type number and the current ring division is
used. If there is at least one space surrounding the / operator
(e.g., "3 / 2"), both numerical constants are treated as of type
int and an integer division is performed. To avoid confusion, use
the div operator instead of / for integer division and an
explicit type cast to number for ring division. Note, that this
problem does only occur for divisions of numerical constants.
  ring r=32002,x,dp;
  3/2;    // ring division
==> -15994
  3 / 2;  // integer division
==> 1
  3 div 2;
==> 1
  number(3) / number(2);
==> -15994
  number a=3;
  number b=2;
  a/b;
==> -15994
  int c=3;
  int d=2;
  c / d;
==> 1


2. monomials and precedence

The computation of a monomial has precedence over all operators:
  ring r=0,(x,y),dp;
  2xy^2 == (2*x*y)^2;
==> 1
  2xy^2 == 2x*y^2;
==> 0
  2x*y^2 == 2*x * (y^2);
==> 1

3. meaning of mult

For an arbitrary ideal or module i, mult(i) returns the
multiplicity of the ideal generated by the leading monomials of the
given generators of i, hence depends on the monomial ordering!

A standard mistake is to interpret degree(i) or mult(i)
for an inhomogeneous ideal i as the degree of the homogenization
or as something like the 'degree of the affine part'. For the ordering
dp (degree reverse lexicographical) the converse is true: if
i is given by a standard basis, mult(i) is the degree of
the homogeneous ideal obtained by homogenization of i and then
putting the homogenizing variable to 0, hence it is the degree of the
part at infinity (this can also be checked by looking at the initial
ideal).

4. size of ideals

size counts the non-zero entries of an ideal or module. Use
ncols to determine the actual number of entries in the ideal or module.

5. computations in qring

In order to speed up computations in quotient rings, SINGULAR
usually does not reduce polynomials w.r.t. the quotient ideal; rather
the given representative is used as long as possible during
computations. If it is necessary, reduction is done during standard base
computations. To reduce a polynomial f by hand w.r.t. the
current quotient ideal use the command reduce(f,std(0))
(see reduce).

6. substring selection

To extract substrings from a string, square brackets are used,
enclosing either two comma-separated ints or an
intvec. Although two comma-separated ints represent an
intvec, they mean different things in substring access. Square
brackets enclosing two ints (e.g. s[2,6]) return a
substring where the first integer denotes the starting position and the
second integer denotes the length of the substring. The result is
returned as a string. Square brackets enclosing an intvec
(e.g. s[intvec(2,6)]) return the characters of the string at the
position given by the values of the intvec. The result is
returned as an expression list of strings. 

  string s = "one-word";
  s[2,6];     // a substring starting at the second char
==> ne-wor
  size(_);
==> 6
  intvec v = 2,6;
  s[v];      // the second and the sixth char
==> n o
  string st = s[v];  // stick together by an assignment
  st;
==> no
  size(_);
==> 2
  v = 2,6,8;
  s[v];
==> n o d



<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
