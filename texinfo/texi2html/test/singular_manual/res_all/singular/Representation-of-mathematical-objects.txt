B.1 Representation of mathematical objects
==========================================

SINGULAR distinguishes between objects which do not belong to a ring
and those which belong to a specific ring (see Rings and orderings).
We comment only on the latter ones.

Internally all ring-dependent objects are polynomials or structures built from
polynomials (and some additional information).
Note that SINGULAR stores (and hence prints) a polynomial automatically
w.r.t. the monomial ordering.

Hence, in order to define such an object in SINGULAR,
one has to give a list of polynomials in a specific format.

For ideals, resp. matrices, this is straight forward:
The user gives a list of polynomials
which generate the ideal, resp. which are the entries of the matrix.
(The number of rows and columns has to be given when creating the matrix.)

A vector  in SINGULAR is always an element of a free module over the
basering. It is given as a list of polynomials in one of the following
formats
$[f_1,...,f_n]$ or $f_1*gen(1)+...+f_n*gen(n)$, where $gen(i)$
denotes the i-th canonical generator of a free module (with 1 at place i and
0 everywhere else).
Both forms are equivalent. A vector is internally represented in
the second form with the
$gen(i)$
being "special" ring variables, ordered accordingly to the monomial ordering.
Therefore, the form
$[f_1,...,f_n]$
is given as output only if the monomial ordering gives priority to the
component, i.e., is of the form (c,...) (see Module orderings).  However, in any case the procedure show from the
library inout.lib displays the bracket format.

A vector
$v=[f_1,...,f_n]$
should always be considered as a column vector in a free module
of rank equal to
nrows($v$)
where 
nrows($v$)
is equal to the maximal index 
$r$
such that
$f_r \not= 0$.
This is due to the fact, that internally 
$v$
is a polynomial in a sparse representation, i.e.,
$f_i*gen(i)$
is not stored if
$f_i=0$
(for reasons of efficiency), hence the last 0-entries of 
$v$
are lost.
Only more complex structures are able to keep the rank.

A module 
$M$
in SINGULAR is given by a list of vectors
$v_1,...,v_k$
which generate the module as a submodule of the free module of rank
equal to 
nrows($M$)
which is the maximum of
nrows($v_i$).

If one wants to create a module with a larger rank than given by its
generators, one has to use the command attrib(M,"rank",r) (see
attrib, nrows) or to define a matrix first, then converting it
into a module.  Modules in SINGULAR are almost the same as
matrices, they may be considered as sparse representations of matrices.
A module of a matrix is generated by the columns of the matrix and a
matrix of a module has as columns the generators of the module.  These
conversions preserve the rank and the number of generators, resp. the
number of rows and columns.

By the above remarks it might appear that SINGULAR is only able to handle
submodules of a free module. However, this is not true. SINGULAR
can compute with any finitely generated module over the basering 
$R$.
Such a module, say 
$N$,
is not represented by its generators but by its
(generators and) relations. This means that
$N = R^n/M$ where $n$ 
is the number of generators of 
$N$ and $M \subseteq R^n$
is the module of relations.
In other words, defining  a module 
$M$
as a submodule of a free module
$R^n$
can also be considered as the definition of
$N = R^n/M$.

Note that most functions, when applied to a module 
$M$,
really deal with
$M$.
However, there are some functions which deal with 
$N = R^n/M$ instead of $M$.

For example, std(M) computes a standard basis of 
$M$
(and thus gives another representation of 
$N$ as $N = R^n/$std($M$)).
However, dim(M), resp. vdim(M), returns
dim$(R^n/M)$, resp.@: dim$_k(R^n/M)$
(if M is given by a standard basis).

The function syz(M)  returns the first syzygy module of 
$M$,
i.e., the module 
of relations of the given generators of 
$M$
which is equal to the second syzygy module of 
$N$.
Refer to the description of each function in
Functions to get information which module the function deals with.

The numbering in res and other commands for computing resolutions
refers to a resolution of
$N = R^n/M$
(see res; Syzygies and resolutions).

It is possible to compute in any field which is a valid ground field in
SINGULAR.  For doing so, one has to define a ring with the desired
ground field and at least one variable. The elements of the field are of
type number, but may also be considered as polynomials (of degree
0). Large computations should be faster if the elements of the field are
defined as numbers.

The above remarks do also apply to quotient rings. Polynomial data are
stored internally in the same manner, the only difference is that this
polynomial representation is in general not unique. reduce(f,std(0))
computes a normal form of a polynomial f in a quotient ring (cf.
reduce).

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.gnu.org/software/texinfo/"><i>texi2html</i></a>.
</font>

</body>
</html>
