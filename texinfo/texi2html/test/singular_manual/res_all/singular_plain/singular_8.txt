Annexe B Polynomial data
************************


* Representation of mathematical objects::
* Monomial orderings::

B.1 Representation of mathematical objects
==========================================

SINGULAR distinguishes between objects which do not belong to a ring
and those which belong to a specific ring (see Rings and orderings).
We comment only on the latter ones.

Internally all ring-dependent objects are polynomials or structures built from
polynomials (and some additional information).
Note that SINGULAR stores (and hence prints) a polynomial automatically
w.r.t. the monomial ordering.

Hence, in order to define such an object in SINGULAR,
one has to give a list of polynomials in a specific format.

For ideals, resp. matrices, this is straight forward:
The user gives a list of polynomials
which generate the ideal, resp. which are the entries of the matrix.
(The number of rows and columns has to be given when creating the matrix.)

A vector  in SINGULAR is always an element of a free module over the
basering. It is given as a list of polynomials in one of the following
formats
denotes the i-th canonical generator of a free module (with 1 at place i and
0 everywhere else).
Both forms are equivalent. A vector is internally represented in
the second form with the
being "special" ring variables, ordered accordingly to the monomial ordering.
Therefore, the form
is given as output only if the monomial ordering gives priority to the
component, i.e., is of the form (c,...) (see Module orderings).  However, in any case the procedure show from the
library inout.lib displays the bracket format.

A vector
should always be considered as a column vector in a free module
of rank equal to
where 
is equal to the maximal index 
such that
This is due to the fact, that internally 
is a polynomial in a sparse representation, i.e.,
is not stored if
(for reasons of efficiency), hence the last 0-entries of 
are lost.
Only more complex structures are able to keep the rank.

A module 
in SINGULAR is given by a list of vectors
which generate the module as a submodule of the free module of rank
equal to 
which is the maximum of

If one wants to create a module with a larger rank than given by its
generators, one has to use the command attrib(M,"rank",r) (see
attrib, nrows) or to define a matrix first, then converting it
into a module.  Modules in SINGULAR are almost the same as
matrices, they may be considered as sparse representations of matrices.
A module of a matrix is generated by the columns of the matrix and a
matrix of a module has as columns the generators of the module.  These
conversions preserve the rank and the number of generators, resp. the
number of rows and columns.

By the above remarks it might appear that SINGULAR is only able to handle
submodules of a free module. However, this is not true. SINGULAR
can compute with any finitely generated module over the basering 
Such a module, say 
is not represented by its generators but by its
(generators and) relations. This means that
is the number of generators of 
is the module of relations.
In other words, defining  a module 
as a submodule of a free module
can also be considered as the definition of

Note that most functions, when applied to a module 
really deal with
However, there are some functions which deal with 

For example, std(M) computes a standard basis of 
(and thus gives another representation of 
However, dim(M), resp. vdim(M), returns
(if M is given by a standard basis).

The function syz(M)  returns the first syzygy module of 
i.e., the module 
of relations of the given generators of 
which is equal to the second syzygy module of 
Refer to the description of each function in
Functions to get information which module the function deals with.

The numbering in res and other commands for computing resolutions
refers to a resolution of
(see res; Syzygies and resolutions).

It is possible to compute in any field which is a valid ground field in
SINGULAR.  For doing so, one has to define a ring with the desired
ground field and at least one variable. The elements of the field are of
type number, but may also be considered as polynomials (of degree
0). Large computations should be faster if the elements of the field are
defined as numbers.

The above remarks do also apply to quotient rings. Polynomial data are
stored internally in the same manner, the only difference is that this
polynomial representation is in general not unique. reduce(f,std(0))
computes a normal form of a polynomial f in a quotient ring (cf.
reduce).

B.2 Monomial orderings
======================

* Introduction to orderings::
* General definitions for orderings::
* Global orderings::
* Local orderings::
* Module orderings::
* Matrix orderings::
* Product orderings::
* Extra weight vector::

B.2.1 Introduction to orderings
-------------------------------

SINGULAR offers a great variety of monomial orderings which provide
an enormous functionality, if used diligently. However, this
flexibility might also be confusing for the novice user.  Therefore, we
recommend to those not familiar with monomial orderings to generally use
the ordering dp for computations in the polynomial ring
resp.  ds for computations in the localization 

For inhomogeneous input ideals,  standard (resp. groebner) bases
computations are generally faster 
with the orderings 
(resp. 
if the input is quasihomogeneous w.r.t. the weights 

If the output needs to be "triangular" (resp. "block-triangular"), the
lexicographical ordering lp (resp. lexicographical
block-orderings) need to be used. However, these orderings usually
result in much less efficient computations.


B.2.2 General definitions for orderings
---------------------------------------

 See the literature cited in References.

It is known that any monomial ordering can be represented by a matrix 
but, of course, only integer coefficients are of relevance in
practice.


Note that the definition of a ring includes the definition of its
monomial ordering (see 
Rings and orderings). SINGULAR offers the monomial orderings
described in the following sections. 


B.2.3 Global orderings
----------------------


lp:
lexicographical ordering:


rp:
reverse lexicographical ordering:


dp:
degree reverse lexicographical ordering:


Dp:
degree lexicographical ordering:


wp:
weighted reverse lexicographical ordering:


 is defined as dp
 but with
Wp:
weighted lexicographical ordering:


 is defined as Dp
 but with
B.2.4 Local orderings
---------------------

For ls, ds, Ds and, if the weights are positive integers, also for ws and
Ws,  we have
 the localization of 
at the maximal ideal

ls:
negative lexicographical ordering:


ds:
negative degree reverse lexicographical ordering:


Ds:
negative degree lexicographical ordering:


ws:
(general) weighted reverse lexicographical ordering:


 a nonzero integer,
 any integer (including 0),
 is defined as ds
 but with
Ws:
(general) weighted lexicographical ordering:


 a nonzero integer,
 any integer (including 0),
 is defined as Ds
 but with

B.2.5 Module orderings
----------------------

SINGULAR offers also orderings on the set of "monomials"

We have two possibilities: either to give priority to the component of a
vector in 
or (which is the default in SINGULAR) to give priority
to the coefficients.
The orderings (<,c) and (<,C) give priority to the
coefficients; whereas
(c,<) and (C,<) give priority to the components.

Let < be any of the monomial orderings of 
as above.

(<,C):



Example:
  ring r = 0, (x,y,z), ds;
  // the same as ring r = 0, (x,y,z), (ds, C);
  [x+y2,z3+xy];
==> x*gen(1)+xy*gen(2)+y2*gen(1)+z3*gen(2)
  [x,x,x];
==> x*gen(3)+x*gen(2)+x*gen(1)

(C,<):

Example:
  ring r = 0, (x,y,z), (C,lp);
  [x+y2,z3+xy];
==> xy*gen(2)+z3*gen(2)+x*gen(1)+y2*gen(1)
  [x,x,x];
==> x*gen(3)+x*gen(2)+x*gen(1)

(<,c):

Example:
  ring r = 0, (x,y,z), (lp,c);
  [x+y2,z3+xy];
==> xy*gen(2)+x*gen(1)+y2*gen(1)+z3*gen(2)
  [x,x,x];
==> x*gen(1)+x*gen(2)+x*gen(3)

(c,<):

Example:
  ring r = 0, (x,y,z), (c,lp);
  [x+y2,z3+xy];
==> [x+y2,xy+z3]
  [x,x,x];
==> [x,x,x]

(up to permutation) unless the ordering starts with c.
In all cases SINGULAR can read input in both formats.

B.2.6 Matrix orderings
----------------------

Let 
be an invertible 
 with integer coefficients and

The M-ordering < is defined as follows:



Thus,
with respect to the lexicographical ordering.

The following matrices represent (for 3 variables) the global and
local orderings defined above (note that the matrix is not uniquely determined
by the ordering):


Product orderings (see next section) represented by  a matrix:


Orderings with extra weight vector (see below) represented by  a matrix:



Example:
  ring r = 0, (x,y,z), M(1, 0, 0,   0, 1, 0,   0, 0, 1);

which may also be written as:
  intmat m[3][3]=1, 0, 0, 0, 1, 0, 0, 0, 1;
  m;
==> 1,0,0,
==> 0,1,0,
==> 0,0,1 
  ring r = 0, (x,y,z), M(m);
  r;
==> //   characteristic : 0
==> //   number of vars : 3
==> //        block   1 : ordering M
==> //                  : names    x y z 
==> //                  : weights  1 0 0 
==> //                  : weights  0 1 0 
==> //                  : weights  0 0 1 
==> //        block   2 : ordering C

If the ring has 
variables and the matrix contains less than 
entries an error message is given, if there are more entries,
the last ones are ignored.

WARNING: SINGULAR
does not check whether the matrix has full rank.   In such a case some
computations might not terminate, others might give a nonsense result.

Having these matrix orderings SINGULAR can compute standard bases for
any monomial ordering which is compatible with the natural semigroup structure.
In practice the global and local orderings together with block orderings should be
sufficient in most cases. These orderings are faster than the corresponding
matrix orderings, since evaluating a matrix product is time consuming.

B.2.7 Product orderings
-----------------------

Let
be two ordered sets of variables,

Inductively one defines the product ordering of more than two monomial
orderings.

In SINGULAR, any of the above global orderings, local orderings or matrix
orderings may be combined (in an arbitrary manner and length) to a product
ordering.   E.g., (lp(3), M(1, 2, 3, 1, 1, 1, 1, 0, 0), ds(4),
ws(1,2,3)) 
defines: lp on the first 3 variables, the matrix ordering
M(1, 2, 3, 1, 1, 1, 1, 0, 0) on the next 3 variables,
ds on the next 4 variables and
ws(1,2,3) on the last 3 variables.

B.2.8 Extra weight vector
-------------------------

any integers (including 0), defines
and



An extra weight vector does not define a monomial ordering by itself:
it can only be used in combination with other orderings
to insert an extra line of weights into the ordering
matrix.


Example:
ring r = 0, (x,y,z),  (a(1,2,3),wp(4,5,2));
ring s = 0, (x,y,z),  (a(1,2,3),dp);
ring q = 0, (a,b,c,d),(lp(1),a(1,2,3),ds);

