Annexe A Examples
*****************



* Milnor and Tjurina::
* Procedures and LIB::
* Critical points::
* Saturation::
* Long coefficients::
* Parameters::
* T1 and T2::
* Deformations::
* Finite fields::
* Elimination::
* Free resolution::
* Computation of Ext::
* Polar curves::
* Depth::
* Formatting output::
* Cyclic roots::
* G_a -Invariants::
* Invariants of a finite group::
* Factorization::
* Puiseux pairs::
* Primary decomposition::
* Normalization::
* Branches of an Isolated Space Curve Singularity::
* Kernel of module homomorphisms::
* Algebraic dependence::
* Classification::
* Fast lexicographical GB::
* Parallelization with MPtcp links::







A.1 Milnor and Tjurina
======================

The Milnor number, resp. the Tjurina number, of a power
series f in
is
jacob(f) is the ideal generated by the partials
of f. tjurina(f) is finite, if and only if f has an
isolated singularity. The same holds for milnor(f) if
K has characteristic 0.
SINGULAR displays -1 if the dimension is infinite.

SINGULAR cannot compute with infinite power series. But it can
work in
the localization of
at the maximal ideal
To do this one has to define an
s-ordering like ds, Ds, ls, ws, Ws or an appropriate matrix
ordering (look at the manual to get information about the possible
monomial orderings in SINGULAR, or type help Monomial orderings;
to get a menu of possible orderings. For further help type, e.g.,
help local orderings;).
See Monomial orderings.

We shall show in the example below how to realize the following:
* set option prot to have a short protocol during standard basis
computation
* define the ring r1 with char 32003, variables x,y,z, monomial
  ordering ds, series ring (i.e., K[x,y,z] localized at (x,y,z))
* list the information about r1 by typing its name
* define the integers a,b,c,t
* define a polynomial f (depending on a,b,c,t) and display it
* define the jacobian ideal i of f
* compute a standard basis of i
* compute the Milnor number (=250) with vdim and create and display
  a string in order to comment the result
  (text between quotes "  "; is a 'string')
* compute a standard basis of i+(f)
* compute the Tjurina number (=195) with vdim
* then compute the Milnor number (=248) and the Tjurina number
(=195) for t=1
* reset the option to noprot

  option(prot);
  ring r1 = 32003,(x,y,z),ds;
  r1;
==> //   characteristic : 32003
==> //   number of vars : 3
==> //        block   1 : ordering ds
==> //                  : names    x y z 
==> //        block   2 : ordering C
  int a,b,c,t=11,5,3,0;
  poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
           x^(c-2)*y^c*(y^2+t*x)^2;
  f;
==> y5+x5y2+x2y2z3+xy7+z9+x11
  ideal i=jacob(f);
  i;
==> i[1]=5x4y2+2xy2z3+y7+11x10
==> i[2]=5y4+2x5y+2x2yz3+7xy6
==> i[3]=3x2y2z2+9z8
  ideal j=std(i);
==> [1023:2]7(2)s8s10s11s12s(3)s13(4)s(5)s14(6)s(7)15--.s(6)-16.-.s(5)17.s(7)\
   s--s18(6).--19-..sH(24)20(3)...21....22....23.--24-
==> product criterion:10 chain criterion:69
  "The Milnor number of f(11,5,3) for t=0 is", vdim(j);
==> The Milnor number of f(11,5,3) for t=0 is 250
  j=i+f;    // overwrite j
  j=std(j);
==> [1023:2]7(3)s8(2)s10s11(3)ss12(4)s(5)s13(6)s(8)s14(9).s(10).15--sH(23)(8)\
   ...16......17.......sH(21)(9)sH(20)16(10).17...........18.......19..----.\
   .sH(19)
==> product criterion:10 chain criterion:53
  vdim(j);  // compute the Tjurina number for t=0
==> 195
  t=1;
  f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
    +x^(c-2)*y^c*(y^2+t*x)^2;
  ideal i1=jacob(f);
  ideal j1=std(i1);
==> [1023:2]7(2)s8s10s11s12s13(3)ss(4)s14(5)s(6)s15(7).....s(8)16.s...s(9)..1\
   7............s18(10).....s(11)..-.19.......sH(24)(10).....20...........21\
   ..........22.............................23..............................\
   .24.----------.25.26
==> product criterion:11 chain criterion:83
  "The Milnor number of f(11,5,3) for t=1:",vdim(j1);
==> The Milnor number of f(11,5,3) for t=1: 248
  vdim(std(j1+f));   // compute the Tjurina number for t=1
==> [1023:2]7(16)s8(15)s10s11ss(16)-12.s-s13s(17)s(18)s(19)-s(18).-14-s(17)-s\
   (16)ss(17)s15(18)..-s...--.16....-.......s(16).sH(23)s(18)...17..........\
   18.........sH(20)17(17)....................18..........19..---....-.-....\
   .....20.-----...s17(9).........18..............19..-.......20.-......21..\
   .......sH(19)16(5).....18......19.-----
==> product criterion:15 chain criterion:174
==> 195
  option(noprot);

A.2 Procedures and LIB
======================

The computation of the Milnor number (for an arbitrary isolated complete
intersection singularity ICIS) and the Tjurina number (for an arbitrary
isolated singularity) can be done by using procedures from the library
sing.lib. For a hypersurface singularity it is very easy to write a
procedure which computes the Milnor number and the Tjurina number.

We shall demonstrate:
* load the library sing.lib
* define a local ring in 2 variables and characteristic 0
* define a plane curve singularity
* compute Milnor number and Tjurina number by using the procedures
milnor and tjurina
* write your own procedures:
(A procedure has a list of input parameters and of return values, both
lists may be empty.)
  --   the procedure mil which must be called with one parameter, a
  polynomial.
  The name g is local to the procedure and is killed automatically.
  mil returns the Milnor number (and displays a comment).
  --   the procedure tjur where the parameters are not specified. They
  are referred
  to by #[1] for the 1st, #[2] for the 2nd parameter, etc.
  tjur returns the Tjurina number (and displays a comment).
  --   the procedure milrina which returns a list consisting of two
  integers,
  the Milnor and the Tjurina number.
  
LIB "sing.lib";
// you should get the information that sing.lib has been loaded
// together with some other libraries which are needed by sing.lib
ring r = 0,(x,y),ds;
poly f = x7+y7+(x-y)^2*x2y2;
milnor(f);
==> 28
tjurina(f);
==> 24

proc mil (poly g)
{
   "Milnor number:";
   return(vdim(std(jacob(g))));
}
mil(f);
==> Milnor number:
==> 28

proc tjur
{
   "Tjurina number:";
   return(vdim(std(jacob(#[1])+#[1])));
}
tjur(f);
==> Tjurina number:
==> 24

proc milrina (poly f)
{
   ideal j=jacob(f);
   list L=vdim(std(j)),vdim(std(j+f));
   return(L);
}
milrina(f);     // a list containing Milnor and Tjurina number
==> [1]:
==>    28
==> [2]:
==>    24
milrina(f)[2];  // the second element of the list
==> 24

A.3 Critical points
===================

The same computation which computes the Milnor, resp. the Tjurina,
number, but with ordering dp instead of ds (i.e., in
instead of
gives:
* the number of critical points of f in the affine plane
(counted with multiplicities)
* the number of singular points of f on the affine plane curve f=0
(counted with multiplicities).

We start with the ring r1 from section Milnor and Tjurina and its elements.

The following will be realized below:
* reset the protocol option and activate the timer
* define the ring r2 with char 32003, variables x,y,z and monomial
  ordering dp (= degrevlex) (i.e., the polynomial ring = K[x,y,z]).
* Note that polynomials, ideals, matrices (of polys), vectors,
  modules belong to a ring, hence we have to define f and jacob(f)
  again in r2. Since these objects are local to a ring, we may use
  the same names.
  Instead of defining f again we map it from ring r1 to r2
  by using the imap command
  (imap is a convenient way to map variables
  from some ring identically to variables with the same name in the
  basering, even if the ground field is different. Compare with fetch
  which works for almost identical rings,
  e.g., if the rings differ only by the ordering or by the names of the
  variables and which may be used to rename variables).
  Integers and strings, however, do not belong to any ring. Once
  defined they are globally known.
* The result of the computation here (together with the previous one in
 Milnor and Tjurina) shows that (for t=0)
= 250 (previously computed) while
= 536. Hence f has 286 critical points,
  counted with multiplicity, outside the origin.
  Moreover, since
= 195 =
the affine surface f=0 is smooth outside the origin.

  ring r1 = 32003,(x,y,z),ds;
  int a,b,c,t=11,5,3,0;
  poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
           x^(c-2)*y^c*(y^2+t*x)^2;
  option(noprot);
  timer=1;
  ring r2 = 32003,(x,y,z),dp;
  poly f=imap(r1,f);
  ideal j=jacob(f);
  vdim(std(j));
==> 536
  vdim(std(j+f));
==> 195
  timer=0;  // reset timer

A.4 Saturation
==============

Since in the example above, the ideal 
 has the same vdim
in the polynomial ring and in the localization at 0 (each 195),

 is smooth outside 0.
Hence 
 contains some power of the maximal ideal 
. We shall
check this in a different manner:
For any two ideals 
 in the basering 
 let

denote the saturation of 
 with respect to 
. This defines,
geometrically, the closure of the complement of V(
) in V(
)
(V(
) denotes the variety defined by 
).
In our case, 
 must be the whole ring, hence
generated by 1.

The saturation is computed by the procedure sat in
elim.lib by computing iterated ideal quotients with the maximal
ideal.  sat returns a list of two elements: the saturated ideal
and the number of iterations.  (Note that maxideal(n) denotes the
n-th power of the maximal ideal).

  LIB "elim.lib";         // loading library elim.lib
  // you should get the information that elim.lib has been loaded
  // together with some other libraries which are needed by it
  option(noprot);         // no protocol
  ring r2 = 32003,(x,y,z),dp;
  poly f = x^11+y^5+z^(3*3)+x^(3+2)*y^(3-1)+x^(3-1)*y^(3-1)*z3+
    x^(3-2)*y^3*(y^2)^2;
  ideal j=jacob(f);
  sat(j+f,maxideal(1));
==> [1]:
==>    _[1]=1
==> [2]:
==>    17
  // list the variables defined so far:
  listvar();
==> // r2                   [0]  *ring
==> //      j                    [0]  ideal, 3 generator(s)
==> //      f                    [0]  poly
==> // LIB                  [0]  string standard.lib,elim.li..., 83 char(s)

A.5 Long coefficients
=====================

The following innocent example produces in its standard basis
extremely long coefficients in char 0 for the lexicographical
ordering.
But a very small deformation does not (the undeformed
example is degenerate with respect to the Newton boundary).
This example demonstrates that it might be wise, for complicated
examples, to do the calculation first in positive char (e.g., 32003).
It has been shown, that in complicated examples, more than 95 percent of
the time needed for a standard basis computation is used in the
computation of the coefficients (in char 0).
The representation of long integers with real is demonstrated.

timer = 1;                              // activate the timer
option(prot);
ring R0 = 0,(x,y),lp;
poly f = x5+y11+xy9+x3y9;
ideal i = jacob(f);
ideal i1 = i,i[1]*i[2];                 // undeformed ideal
ideal i2 = i,i[1]*i[2]+1/1000000*x5y8;  // deformation of i1
i1; i2;
==> i1[1]=5x4+3x2y9+y9
==> i1[2]=9x3y8+9xy8+11y10
==> i1[3]=45x7y8+27x5y17+45x5y8+55x4y10+36x3y17+33x2y19+9xy17+11y19
==> i2[1]=5x4+3x2y9+y9
==> i2[2]=9x3y8+9xy8+11y10
==> i2[3]=45x7y8+27x5y17+45000001/1000000x5y8+55x4y10+36x3y17+33x2y19+9xy17+1\
   1y19
ideal j = std(i1);
==> [65535:1]11(2)ss19s20s21s22(3)-23-s27s28s29s30s31s32s33s34s35s36s37s38s39\
   s40s70-
==> product criterion:1 chain criterion:30
j;
==> j[1]=264627y39+26244y35-1323135y30-131220y26+1715175y21+164025y17+1830125\
   y16
==> j[2]=12103947791971846719838321886393392913750065060875xy8-28639152114168\
   3198701331939250003266767738632875y38-31954402206909026926764622877573565\
   78554430672591y37+57436621420822663849721381265738895282846320y36+1657764\
   214948799497573918210031067353932439400y35+213018481589308191195677223898\
   98682697001205500y34+1822194158663066565585991976961565719648069806148y33\
   -4701709279892816135156972313196394005220175y32-1351872269688192267600786\
   97600850686824231975y31-3873063305929810816961516976025038053001141375y30\
   +1325886675843874047990382005421144061861290080000y29+1597720195476063141\
   9467945895542406089526966887310y28-26270181336309092660633348002625330426\
   7126525y27-7586082690893335269027136248944859544727953125y26-867853074106\
   49464602285843351672148965395945625y25-5545808143273594102173252331151835\
   700278863924745y24+19075563013460437364679153779038394895638325y23+548562\
   322715501761058348996776922561074021125y22+157465452677648386073957464715\
   68100780933983125y21-1414279129721176222978654235817359505555191156250y20\
   -20711190069445893615213399650035715378169943423125y19+272942733337472665\
   573418092977905322984009750y18+789065115845334505801847294677413365720955\
   3750y17+63554897038491686787729656061044724651089803125y16-22099251729923\
   906699732244761028266074350255961625y14+147937139679655904353579489722585\
   91339027857296625y10
==> j[3]=5x4+3x2y9+y9
// Compute average coefficient length (=51) by
//   - converting j[2] to a string in order to compute the number
//   of characters
//   - divide this by the number of monomials:
size(string(j[2]))/size(j[2]);
==> 51
vdim(j);
==> 63
// For a better representation normalize the long coefficients
// of the polynomial j[2] and map it  to real:
poly p=(1/12103947791971846719838321886393392913750065060875)*j[2];
ring R1=real,(x,y),lp;
short=0; // force the long output format
poly p=imap(R0,p);
p;
==> x*y^8-2.366e-02*y^38-2.640e-01*y^37+4.745e-06*y^36+1.370e-04*y^35+1.760e-\
   03*y^34+1.505e-01*y^33+3.884e-07*y^32-1.117e-05*y^31-3.200e-04*y^30+1.095\
   e-01*y^29+1.320e+00*y^28-2.170e-05*y^27-6.267e-04*y^26-7.170e-03*y^25-4.5\
   82e-01*y^24+1.576e-06*y^23+4.532e-05*y^22+1.301e-03*y^21-1.168e-01*y^20-1\
   .711e+00*y^19+2.255e-05*y^18+6.519e-04*y^17+5.251e-03*y^16-1.826e+00*y^14\
   +1.222e+00*y^10
// Compute a standard basis for the deformed ideal:
setring R0;
j = std(i2);
==> [65535:1]11(2)ss19s20s21s22(3)-s23(2)s27.28.s29(3)s30.s31ss32sss33sss34ss\
   35--38-
==> product criterion:11 chain criterion:21
j;
==> j[1]=y16
==> j[2]=65610xy8+17393508y27+7223337y23+545292y19+6442040y18-119790y14+80190\
   y10
==> j[3]=5x4+3x2y9+y9
vdim(j);
==> 40
A.6 Parameters
==============

Let us deform the above ideal now by introducing a parameter t
and compute over the ground field Q(t).
We compute the dimension at the generic point,
i.e.,
(This gives the
same result as for the deformed ideal above. Hence, the above small
deformation was "generic".)

For almost all
this is the same as
where

  ring Rt = (0,t),(x,y),lp;
  Rt;
==> //   characteristic : 0
==> //   1 parameter    : t 
==> //   minpoly        : 0
==> //   number of vars : 2
==> //        block   1 : ordering lp
==> //                  : names    x y 
==> //        block   2 : ordering C
  poly f = x5+y11+xy9+x3y9;
  ideal i = jacob(f);
  ideal j = i,i[1]*i[2]+t*x5y8;  // deformed ideal, parameter t
  vdim(std(j));
==> 40
  ring R=0,(x,y),lp;
  ideal i=imap(Rt,i);
  int a=random(1,30000);
  ideal j=i,i[1]*i[2]+a*x5y8;  // deformed ideal, fixed integer a
  vdim(std(j));
==> 40

A.7 T1 and T2
=============


, resp. 
, of an ideal 
 usually denote the modules of
infinitesimal deformations, resp. of obstructions.
In SINGULAR there are procedures T_1 and T_2 in
sing.lib such that
T_1(j) and T_2(j) compute a standard basis of
a presentation of these modules.
If T_1 and T_2 are finite dimensional K-vector spaces (e.g., for isolated
singularities), a basis can be computed by applying
kbase(T_1(j));, resp. kbase(T_2(j));, the dimensions by
applying vdim.
For a complete intersection j the procedure Tjurina also
computes T_1, but faster (T_2=0 in this case).
For a non complete intersection, it is faster to use the procedure T_12
instead of T_1 and T_2.
Type help T_1; (or help T_2; or help T_12;) to obtain
more detailed information about these procedures.

We give three examples, the first being a hypersurface, the second a complete
intersection, the third no complete intersection:
* load sing.lib
* check whether the ideal j is a complete intersection. It is, if
     number of variables = dimension + minimal number of generators
* compute the Tjurina number
* compute a vector space basis (kbase) of T_1
* compute the Hilbert function of T_1
* create a polynomial encoding the Hilbert series
* compute the dimension of T_2

  LIB "sing.lib";
  ring R=32003,(x,y,z),ds;
  // ---------------------------------------
  // hypersurface case (from series T[p,q,r]):
  int p,q,r = 3,3,4;
  poly f = x^p+y^q+z^r+xyz;
  tjurina(f);
==> 8
  // Tjurina number = 8
  kbase(Tjurina(f));
==> // Tjurina number = 8
==> _[1]=z3
==> _[2]=z2
==> _[3]=yz
==> _[4]=xz
==> _[5]=z
==> _[6]=y
==> _[7]=x
==> _[8]=1
  // ---------------------------------------
  // complete intersection case (from series P[k,l]):
  int k,l =3,2;
  ideal j=xy,x^k+y^l+z2;
  dim(std(j));          // Krull dimension
==> 1
  size(minbase(j));     // minimal number of generators
==> 2
  tjurina(j);           // Tjurina number
==> 6
  module T=Tjurina(j);
==> // Tjurina number = 6
  kbase(T);             // a sparse output of the k-basis of T_1
==> _[1]=z*gen(1)
==> _[2]=gen(1)
==> _[3]=y*gen(2)
==> _[4]=x2*gen(2)
==> _[5]=x*gen(2)
==> _[6]=gen(2)
  print(kbase(T));      // columns of matrix are a k-basis of T_1
==> z,1,0,0, 0,0,
==> 0,0,y,x2,x,1 
  // ---------------------------------------
  // general case (cone over rational normal curve of degree 4):
  ring r1=0,(x,y,z,u,v),ds;
  matrix m[2][4]=x,y,z,u,y,z,u,v;
  ideal i=minor(m,2);   // 2x2 minors of matrix m
  module M=T_1(i);       // a presentation matrix of T_1
==> // dim T_1 = 4
  vdim(M);              // Tjurina number
==> 4
  hilb(M);              // display of both Hilbert series
==> //         4 t^0
==> //       -20 t^1
==> //        40 t^2
==> //       -40 t^3
==> //        20 t^4
==> //        -4 t^5
==> 
==> //         4 t^0
==> // dimension (local)   = 0
==> // multiplicity = 4
  intvec v1=hilb(M,1);  // first Hilbert series as intvec
  intvec v2=hilb(M,2);  // second Hilbert series as intvec
  v1;
==> 4,-20,40,-40,20,-4,0
  v2;
==> 4,0
  v1[3];                // 3rd coefficient of the 1st Hilbert series
==> 40
  module N=T_2(i);
==> // dim T_2 = 3
// In some cases it might be useful to have a polynomial in some ring
// encoding the Hilbert series. This polynomial can then be
// differentiated, evaluated etc. It can be done as follows:
ring H = 0,t,ls;
poly h1;
int ii;
for (ii=1; ii<=size(v1); ii=ii+1)
{
   h1=h1+v1[ii]*t^(ii-1);
}
h1;                   // 1st Hilbert series
==> 4-20t+40t2-40t3+20t4-4t5
diff(h1,t);           // differentiate  h1
==> -20+80t-120t2+80t3-20t4
subst(h1,t,1);        // substitute t by 1
==> 0

// The procedures T_1, T_2, T_12 may be called with two arguments and then
// they return a list with more information (type help T_1; etc.)
// e.g., T_12(i,<any>); returns a list with 9 nonempty objects where
// _[1] = std basis of T_1-module, _[2] = std basis of T_2-module,
// _[3]= vdim of T_1, _[4]= vdim of T_2
setring r1;           // make r1 again the basering
list L = T_12(i,1);
==> // dim T_1  =  4
==> // dim T_2  =  3
kbase(L[1]);          // kbase of T_1
==> _[1]=1*gen(2)
==> _[2]=1*gen(3)
==> _[3]=1*gen(6)
==> _[4]=1*gen(7)
kbase(L[2]);          // kbase of T_2
==> _[1]=1*gen(6)
==> _[2]=1*gen(8)
==> _[3]=1*gen(9)
L[3];                 // vdim of T_1
==> 4
L[4];                 // vdim of T_2
==> 3
A.8 Deformations
================

* The libraries sing.lib, resp. deform.lib, contain procedures
to compute total and base space of the
miniversal (= semiuniversal) deformation of an
isolated complete intersection singularity, resp. arbitrary isolated
singularity.
* The procedure deform in sing.lib returns a matrix whose columns
represent all 1st order deformations. More precisely, if

* The procedure versal in deform.lib computes a formal
miniversal deformation up to a certain order which can be
prescribed by the user. For a complete intersection the 1st order
part is already miniversal.
* The procedure versal extends the basering to a new ring with
additional deformation parameters which contains the equations for the
miniversal base space and the miniversal total space.
* There are default names for the objects created, but the user may also
choose his own names.
* If the user sets printlevel=2; before running versal, some
intermediate results are shown. This is useful since versal
is already complicated and might run for some time on more
complicated examples. (type help versal;)

We compute for the same examples as in the preceding section
the miniversal deformations:

  LIB "deform.lib";
  ring R=32003,(x,y,z),ds;
  //----------------------------------------------------
  // hypersurface case (from series T[p,q,r]):
  int p,q,r = 3,3,4;
  poly f = x^p+y^q+z^r+xyz;
  print(deform(f));
==> z3,z2,yz,xz,z,y,x,1
  // the miniversal deformation of f=0 is the projection from the
  // miniversal total space to the miniversal base space:
  // { (A,B,C,D,E,F,G,H,x,y,z) | x3+y3+xyz+z4+A+Bx+Cxz+Dy+Eyz+Fz+Gz2+Hz3 =0 }
  //  --> { (A,B,C,D,E,F,G,H) }
  //----------------------------------------------------
  // complete intersection case (from series P[k,l]):
  int k,l =3,2;
  ideal j=xy,x^k+y^l+z2;
  print(deform(j));
==> 0,0, 0,0,z,1,
==> y,x2,x,1,0,0 
  versal(j);                  // using default names
==> // smooth base space
==> // ready: T_1 and T_2
==> 
==> // Result belongs to ring Px.
==> // Equations of total space of miniversal deformation are 
==> // given by Fs, equations of miniversal base space by Js.
==> // Make Px the basering and list objects defined in Px by typing:
==>    setring Px; show(Px);
==>    listvar(matrix);
==> // NOTE: rings Qx, Px, So are alive!
==> // (use 'kill_rings("");' to remove)
  setring Px;
  show(Px);                   // show is a procedure from inout.lib
==> // ring: (32003),(A,B,C,D,E,F,x,y,z),(ds(6),ds(3),C);
==> // minpoly = 0
==> // objects belonging to this ring:
==> // Rs                   [0]  matrix 2 x 1
==> // Fs                   [0]  matrix 1 x 2
==> // Js                   [0]  matrix 1 x 0
  listvar(matrix);
==> // Rs                   [0]  matrix 2 x 1
==> // Fs                   [0]  matrix 1 x 2
==> // Js                   [0]  matrix 1 x 0
  // ___ Equations of miniversal base space ___:
  Js;
==> 
  // ___ Equations of miniversal total space ___:
  Fs;
==> Fs[1,1]=xy+Ez+F
==> Fs[1,2]=y2+z2+x3+Ay+Bx2+Cx+D
  // the miniversal deformation of V(j) is the projection from the
  // miniversal total space to the miniversal base space:
  // { (A,B,C,D,E,F,x,y,z) | xy+F+Ez=0, y2+z2+x3+D+Cx+Bx2+Ay=0 }
  //  --> { (A,B,C,D,E,F) }
  //----------------------------------------------------
  // general case (cone over rational normal curve of degree 4):
  ring r1=0,(x,y,z,u,v),ds;
  matrix m[2][4]=x,y,z,u,y,z,u,v;
  ideal i=minor(m,2);                 // 2x2 minors of matrix m
  int time=timer;
  // Def_r is the name of the miniversal base space with
  // parameters A(1),...,A(4)
  versal(i,0,"Def_r","A(");
==> // ready: T_1 and T_2
==> 
==> // Result belongs to ring Def_rPx.
==> // Equations of total space of miniversal deformation are 
==> // given by Fs, equations of miniversal base space by Js.
==> // Make Def_rPx the basering and list objects defined in Def_rPx by typin\
   g:
==>    setring Def_rPx; show(Def_rPx);
==>    listvar(matrix);
==> // NOTE: rings Def_rQx, Def_rPx, Def_rSo are alive!
==> // (use 'kill_rings("Def_r");' to remove)
  "// used time:",timer-time,"sec";   // time of last command
==> // used time: 1 sec
  // the miniversal deformation of V(i) is the projection from the
  // miniversal total space to the miniversal base space:
  // { (A(1..4),x,y,z,u,v) |
  //         -y^2+x*z+A(2)*x-A(3)*y=0, -y*z+x*u-A(1)*x-A(3)*z=0,
  //         -y*u+x*v-A(3)*u-A(4)*z=0, -z^2+y*u-A(1)*y-A(2)*z=0,
  //         -z*u+y*v-A(2)*u-A(4)*u=0, -u^2+z*v+A(1)*u-A(4)*v=0 }
  //  --> { A(1..4) |
  //         -A(1)*A(4) = A(3)*A(4) = -A(2)*A(4)-A(4)^2 = 0 }
  //----------------------------------------------------

A.9 Finite fields
=================

We define a variety in 
-space of codimension 2 defined by
polynomials of degree 
 with generic coefficients over the prime
field 
 and look for zeros on the torus. First over the prime
field and then in the finite extension field with
elements.
In general there will be many more solutions in the second case.
(Since the SINGULAR language is interpreted, the evaluation of many
for-loops is not very fast):

  int p=3;  int n=3;  int d=5; int k=2;
  ring rp = p,(x(1..n)),dp;
  int s = size(maxideal(d));
  s;
==> 21
  // create a dense homogeneous ideal m, all generators of degree d, with
  // generic (random) coefficients:
  ideal m = maxideal(d)*random(p,s,n-2);
  m;
==> m[1]=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^3*x\
   (3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5
  // look for zeros on the torus by checking all points (with no component 0)
  // of the affine n-space over the field with p elements :
  ideal mt;
  int i(1..n);                    // initialize integers i(1),...,i(n)
  int l;
  s=0;
  for (i(1)=1;i(1)<p;i(1)=i(1)+1)
  {
    for (i(2)=1;i(2)<p;i(2)=i(2)+1)
    {
      for (i(3)=1;i(3)<p;i(3)=i(3)+1)
      {
        mt=m;
        for (l=1;l<=n;l=l+1)
        {
          mt=subst(mt,x(l),i(l));
        }
        if (size(mt)==0)
        {
          "solution:",i(1..n);
          s=s+1;
        }
      }
    }
  }
==> solution: 1 1 2
==> solution: 1 2 1
==> solution: 1 2 2
==> solution: 2 1 1
==> solution: 2 1 2
==> solution: 2 2 1
  "//",s,"solutions over GF("+string(p)+")";
==> // 6 solutions over GF(3)
  // Now go to the field with p^3 elements:
  // As long as there is no map from Z/p to the field with p^3 elements
  // implemented, use the following trick: convert the ideal to be mapped
  // to the new ring to a string and then execute this string in the
  // new ring
  string ms="ideal m="+string(m)+";";
  ms;
==> ideal m=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^\
   3*x(3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5;
  // define a ring rpk with p^k elements, call the primitive element z. Hence
  // 'solution exponent: 0 1 5' means that (z^0,z^1,z^5) is a solution
  ring rpk=(p^k,z),(x(1..n)),dp;
  rpk;
==> //   # ground field : 9
==> //   primitive element : z
==> //   minpoly        : 1*z^2+1*z^1+2*z^0
==> //   number of vars : 3
==> //        block   1 : ordering dp
==> //                  : names    x(1) x(2) x(3) 
==> //        block   2 : ordering C
  execute(ms);
  s=0;
  ideal mt;
  for (i(1)=0;i(1)<p^k-1;i(1)=i(1)+1)
  {
    for (i(2)=0;i(2)<p^k-1;i(2)=i(2)+1)
    {
      for (i(3)=0;i(3)<p^k-1;i(3)=i(3)+1)
      {
        mt=m;
        for (l=1;l<=n;l=l+1)
        {
          mt=subst(mt,x(l),z^i(l));
        }
        if (size(mt)==0)
        {
          "solution exponent:",i(1..n);
          s=s+1;
        }
      }
    }
  }
==> solution exponent: 0 0 2
==> solution exponent: 0 0 4
==> solution exponent: 0 0 6
==> solution exponent: 0 1 0
==> solution exponent: 0 3 0
==> solution exponent: 0 4 0
==> solution exponent: 0 4 4
==> solution exponent: 0 4 5
==> solution exponent: 0 4 7
==> solution exponent: 1 1 3
==> solution exponent: 1 1 5
==> solution exponent: 1 1 7
==> solution exponent: 1 2 1
==> solution exponent: 1 4 1
==> solution exponent: 1 5 0
==> solution exponent: 1 5 1
==> solution exponent: 1 5 5
==> solution exponent: 1 5 6
==> solution exponent: 2 2 0
==> solution exponent: 2 2 4
==> solution exponent: 2 2 6
==> solution exponent: 2 3 2
==> solution exponent: 2 5 2
==> solution exponent: 2 6 1
==> solution exponent: 2 6 2
==> solution exponent: 2 6 6
==> solution exponent: 2 6 7
==> solution exponent: 3 3 1
==> solution exponent: 3 3 5
==> solution exponent: 3 3 7
==> solution exponent: 3 4 3
==> solution exponent: 3 6 3
==> solution exponent: 3 7 0
==> solution exponent: 3 7 2
==> solution exponent: 3 7 3
==> solution exponent: 3 7 7
==> solution exponent: 4 0 0
==> solution exponent: 4 0 1
==> solution exponent: 4 0 3
==> solution exponent: 4 0 4
==> solution exponent: 4 4 0
==> solution exponent: 4 4 2
==> solution exponent: 4 4 6
==> solution exponent: 4 5 4
==> solution exponent: 4 7 4
==> solution exponent: 5 0 5
==> solution exponent: 5 1 1
==> solution exponent: 5 1 2
==> solution exponent: 5 1 4
==> solution exponent: 5 1 5
==> solution exponent: 5 5 1
==> solution exponent: 5 5 3
==> solution exponent: 5 5 7
==> solution exponent: 5 6 5
==> solution exponent: 6 1 6
==> solution exponent: 6 2 2
==> solution exponent: 6 2 3
==> solution exponent: 6 2 5
==> solution exponent: 6 2 6
==> solution exponent: 6 6 0
==> solution exponent: 6 6 2
==> solution exponent: 6 6 4
==> solution exponent: 6 7 6
==> solution exponent: 7 0 7
==> solution exponent: 7 2 7
==> solution exponent: 7 3 3
==> solution exponent: 7 3 4
==> solution exponent: 7 3 6
==> solution exponent: 7 3 7
==> solution exponent: 7 7 1
==> solution exponent: 7 7 3
==> solution exponent: 7 7 5
  "//",s,"solutions over GF("+string(p^k)+")";
==> // 72 solutions over GF(9)
A.10 Elimination
================

Elimination is the algebraic counterpart of the geometric concept of
projection. If
is a polynomial map,
the Zariski-closure of the image is the zero-set of the ideal
i.e, of the ideal j obtained from J by eliminating the variables
This can be done by computing a standard basis of J with respect to a product
ordering where the block of t-variables precedes the block of
x-variables and then selecting those polynomials which do not contain
any t. In SINGULAR the most convenient way is to use the
eliminate command.
In contrast to the first method, with eliminate the result needs not be a
standard basis in the given ordering.
Hence, there may be cases where the first method is the preferred one.

WARNING: In the case of a local or a mixed ordering, elimination needs special
care. f may be considered as a map of germs
but even
if this map germ is finite, we are in general not able to compute the image
germ because for this we would need an implementation of the Weierstrass
preparation theorem. What we can compute, and what eliminate actually does,
is the following: let V(J) be the zero-set of J in
then the
closure of the image of V(J) under the projection
Note that this germ contains also those components
of V(J) which meet the fiber of pr outside the origin.
This is achieved by an ordering with the block of t-variables having a
global ordering (and preceding the x-variables) and the x-variables having
a local ordering. In a local situation we propose eliminate with
ordering ls.

In any case, if the input is weighted homogeneous (=quasihomogeneous),
the weights given to the variables should be chosen accordingly.
SINGULAR offers a function weight which proposes,
given an ideal or module, integer weights for the variables, such that
the ideal, resp. module, is as homogeneous as possible with respect to these weights.
The function finds correct weights, if the input is weighted homogeneous
(but is rather slow for many variables). In order to check, whether the
input is quasihomogeneous, use the function qhweight, which returns
an intvec of correct weights if the input is quasihomogeneous and an intvec
of zeros otherwise.

Let us give two examples:
1. First we compute the equations of the simple space curve
   consisting of two tangential cusps given in parametric form.
2. We compute weights for the equations such that the
   equations are quasihomogeneous w.r.t. these weights.
3. Then we compute the tangent developable of the rational
   normal curve in

  // 1. Compute equations of curve given in parametric form:
  // Two transversal cusps in (k^3,0):
  ring r1 = 0,(t,x,y,z),ls;
  ideal i1 = x-t2,y-t3,z;        // parametrization of the first branch
  ideal i2 = y-t2,z-t3,x;        // parametrization of the second branch
  ideal j1 = eliminate(i1,t);
  j1;                            // equations of the first branch
==> j1[1]=z
==> j1[2]=y2-x3
  ideal j2 = eliminate(i2,t);
  j2;                            // equations of the second branch
==> j2[1]=x
==> j2[2]=z2-y3
  // Now map to a ring with only x,y,z as variables and compute the
  // intersection of j1 and j2 there:
  ring r2 = 0,(x,y,z),ds;
  ideal j1= imap(r1,j1);         // imap is a convenient ringmap for
  ideal j2= imap(r1,j2);         // inclusions and projections of rings
  ideal i = intersect(j1,j2);
  i;                             // equations of both branches
==> i[1]=z2-y3+x3y
==> i[2]=xz
==> i[3]=xy2-x4
==> i[4]=x3z
  //
  // 2. Compute the weights:
  intvec v= qhweight(i);         // compute weights
  v;
==> 4,6,9
  //
  // 3. Compute the tangent developable
  // The tangent developable of a projective variety given parametrically
  // by F=(f1,...,fn) : P^r --> P^n is the union of all tangent spaces
  // of the image. The tangent space at a smooth point F(t1,...,tr)
  // is given as the image of the tangent space at (t1,...,tr) under
  // the tangent map (affine coordinates)
  //   T(t1,...,tr): (y1,...,yr) --> jacob(f)*transpose((y1,...,yr))
  // where jacob(f) denotes the jacobian matrix of f with respect to the
  // t's evaluated at the point (t1,...,tr).
  // Hence we have to create the graph of this map and then to eliminate
  // the t's and y's.
  // The rational normal curve in P^4 is given as the image of
  //        F(s,t) = (s4,s3t,s2t2,st3,t4)
  // each component being homogeneous of degree 4.
  ring P = 0,(s,t,x,y,a,b,c,d,e),dp;
  ideal M = maxideal(1);
  ideal F = M[1..2];     // take the 1st two generators of M
  F=F^4;
  // simplify(...,2); deletes 0-columns
  matrix jac = simplify(jacob(F),2);
  ideal T = x,y;
  ideal J = jac*transpose(T);
  ideal H = M[5..9];
  ideal i = H-J;         // this is tricky: difference between two
                         // ideals is not defined, but between two
                         // matrices. By automatic type conversion
                         // the ideals are converted to matrices,
                         // subtracted and afterwards converted
                         // to an ideal. Note that '+' is defined
                         // and adds (concatenates) two ideals
  i;
==> i[1]=-4s3x+a
==> i[2]=-3s2tx-s3y+b
==> i[3]=-2st2x-2s2ty+c
==> i[4]=-t3x-3st2y+d
==> i[5]=-4t3y+e
  // Now we define a ring with product ordering and weights 4
  // for the variables a,...,e.
  // Then we map i from P to P1 and eliminate s,t,x,y from i.
  ring P1 = 0,(s,t,x,y,a,b,c,d,e),(dp(4),wp(4,4,4,4,4));
  ideal i = fetch(P,i);
  ideal j= eliminate(i,stxy);    // equations of tangent developable
  j;
==> j[1]=3c2-4bd+ae
==> j[2]=2bcd-3ad2-3b2e+4ace
==> j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde
  // We can use the product ordering to eliminate s,t,x,y from i
  // by a std-basis computation.
  // We need proc 'nselect' from elim.lib.
  LIB "elim.lib";
  j = std(i);                    // compute a std basis j
  j = nselect(j,1,4);            // select generators from j not
  j;                             // containing variable 1,...,4
==> j[1]=3c2-4bd+ae
==> j[2]=2bcd-3ad2-3b2e+4ace
==> j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde


A.11 Free resolution
====================

In SINGULAR a free resolution of a module or ideal has its own type:
resolution. It is a structure that stores all information related to
free resolutions. This allows partial computations of resolutions via
the command res. After applying res, only a pre-format of the
resolution is computed which allows to determine invariants like
Betti-numbers or homological dimension. To see the differentials
of the complex, a resolution must be converted into the type list which
yields a list of modules: the k-th module in this
list is the first syzygy-module (module of relations) of the (k-1)st module.
There are the following commands to compute a resolution:
res
res

computes a free resolution of an ideal or module using a heuristically
chosen method.
This is the preferred method to compute free resolutions of ideals or
modules.
lres
lres

computes a free resolution of an ideal or module with La Scala's
method. The input needs to be homogeneous.
mres
mres

computes a minimal free resolution of an ideal or module with the syzygy
method.
sres
sres

computes a free resolution of an ideal or module with Schreyer's
method. The input has to be a standard basis.
nres
nres

computes a free resolution of an ideal or module with the standard basis
method.
minres
minres

minimizes a free resolution of an ideal or module.
syz
syz

computes the first syzygy module.
res(i,r), lres(i,r), sres(i,r), mres(i,r),
nres(i,r) compute the first r modules of the resolution
of i, resp. the full resolution if r=0 and the basering is not a qring.
See the manual for a precise description of these commands.

Note: The command betti does not require a minimal
resolution for the minimal betti numbers.

Now let's look at an example which uses resolutions: The Hilbert-Burch
theorem says that the ideal i of a reduced curve in
has a free resolution of length 2 and that i is given by the 2x2 minors
of the 2nd matrix in the resolution.
We test this for two transversal cusps in
Afterwards we compute the resolution of the ideal j of the tangent developable
of the rational normal curve in
from above.
Finally we demonstrate the use of the type resolution in connection with
the lres command.

  // Two transversal cusps in (k^3,0):
  ring r2 =0,(x,y,z),ds;
  ideal i =z2-1y3+x3y,xz,-1xy2+x4,x3z;
  resolution rs=mres(i,0);   // computes a minimal resolution
  rs;                        // the standard representation of complexes
==>   1       3       2       
==> r2 <--  r2 <--  r2
==> 
==> 0       1       2       
==> 
    list resi=rs;            // convertion to a list
  print(resi[1]);            // the 1st module is i minimized
==> xz,
==> z2-y3+x3y,
==> xy2-x4
  print(resi[2]);            // the 1st syzygy module of i
==> -z,-y2+x3,
==> x, 0,     
==> y, z      
  resi[3];                   // the 2nd syzygy module of i
==> _[1]=0
  ideal j=minor(resi[2],2);
  reduce(j,std(i));          // check whether j is contained in i
==> _[1]=0
==> _[2]=0
==> _[3]=0
  size(reduce(i,std(j)));    // check whether i is contained in j
==> 0
  // size(<ideal>) counts the non-zero generators
  // ---------------------------------------------
  // The tangent developable of the rational normal curve in P^4:
  ring P = 0,(a,b,c,d,e),dp;
  ideal j= 3c2-4bd+ae, -2bcd+3ad2+3b2e-4ace,
           8b2d2-9acd2-9b2ce+9ac2e+2abde-1a2e2;
  resolution rs=mres(j,0);
  rs;
==>  1      2      1      
==> P <--  P <--  P
==> 
==> 0      1      2      
==> 
  list L=rs;
  print(L[2]);
==> 2bcd-3ad2-3b2e+4ace,
==> -3c2+4bd-ae         
  // create an intmat with graded betti numbers
  intmat B=betti(rs);
  // this gives a nice output of betti numbers
  print(B,"betti");
==>            0     1     2
==> ------------------------
==>     0:     1     -     -
==>     1:     -     1     -
==>     2:     -     1     -
==>     3:     -     -     1
==> ------------------------
==> total:     1     2     1
  // the user has access to all betti numbers
  // the 2-nd column of B:
  B[1..4,2];
==> 0 1 1 0
  ring cyc5=32003,(a,b,c,d,e,h),dp;
  ideal i=
  a+b+c+d+e,
  ab+bc+cd+de+ea,
  abc+bcd+cde+dea+eab,
  abcd+bcde+cdea+deab+eabc,
  h5-abcde;
  resolution rs=lres(i,0);   //computes the resolution according La Scala
  rs;                        //the shape of the minimal resolution
==>     1         5         10         10         5         1         
==> cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
==> 
==> 0         1         2          3          4         5         
==> resolution not minimized yet
==> 
  print(betti(rs),"betti");  //shows the Betti-numbers of cyclic 5
==>            0     1     2     3     4     5
==> ------------------------------------------
==>     0:     1     1     -     -     -     -
==>     1:     -     1     1     -     -     -
==>     2:     -     1     1     -     -     -
==>     3:     -     1     2     1     -     -
==>     4:     -     1     2     1     -     -
==>     5:     -     -     2     2     -     -
==>     6:     -     -     1     2     1     -
==>     7:     -     -     1     2     1     -
==>     8:     -     -     -     1     1     -
==>     9:     -     -     -     1     1     -
==>    10:     -     -     -     -     1     1
==> ------------------------------------------
==> total:     1     5    10    10     5     1
  dim(rs);                   //the homological dimension
==> 4
  size(list(rs));            //gets the full (non-reduced) resolution
==> 6
  minres(rs);                //minimizes the resolution
==>     1         5         10         10         5         1         
==> cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
==> 
==> 0         1         2          3          4         5         
==> 
  size(list(rs));            //gets the minimized resolution
==> 6


A.12 Computation of Ext
=======================

We start by showing how to calculate the 
-th Ext group of an
ideal. The ingredients to do this are by the definition of Ext the
following: calculate a (minimal) resolution at least up to length

, apply the Hom-functor, and calculate the 
-th homology
group, that is form the quotient
in the resolution sequence.

The Hom functor is given simply by transposing (hence dualizing) the
module or the corresponding matrix with the command transpose.
The image of the 
-st map is generated by the columns of the
corresponding matrix. To calculate the kernel apply the command
syz at the 
-st transposed entry of the resolution.
Finally, the quotient is obtained by the command modulo, which
gives for two modules A = ker, B = Im the module of relations of
in the usual way. As we have a chain complex this is obviously the same
as ker/Im.

We collect these statements in the following short procedure:

proc ext(int n, ideal I)
{
  resolution rs = mres(I,n+1);
  module tAn    = transpose(rs[n+1]);
  module tAn_1  = transpose(rs[n]);
  module ext_n  = modulo(syz(tAn),tAn_1);
  return(ext_n);
}

Now consider the following example:

ring r5 = 32003,(a,b,c,d,e),dp;
ideal I = a2b2+ab2c+b2cd, a2c2+ac2d+c2de,a2d2+ad2e+bd2e,a2e2+abe2+bce2;
print(ext(2,I));
==> 1,0,0,0,0,0,0,
==> 0,1,0,0,0,0,0,
==> 0,0,1,0,0,0,0,
==> 0,0,0,1,0,0,0,
==> 0,0,0,0,1,0,0,
==> 0,0,0,0,0,1,0,
==> 0,0,0,0,0,0,1
ext(3,I);   // too big to be displayed here

The library homolog.lib contains several procedures for computing
Ext-modules and related modules, which are much more general and
sophisticated then the above one. They are used in the following
example.

If 
 is a module, then
are the modules of infinitesimal deformations, resp. of obstructions, of

 (like T1 and T2 for a singularity).  Similar to the treatment
for singularities, the semiuniversal deformation of 
 can be
computed (if
is finite dimensional) with the help of
and the cup product. There is an extra procedure for
if 
 is an ideal in 
 since this is faster than the
general Ext.

We compute
* the infinitesimal deformations
and obstructions
of the residue field 
 of an ordinary cusp,
To compute
we have to apply Ext(1,syz(m),syz(m)) with
syz(m) the first syzygy module of 
, which is isomorphic to
* for some ideal 
 and with an extra option.

  LIB "homolog.lib";
  ring R=0,(x,y),ds;
  ideal i=x2-y3;
  qring q = std(i);      // defines the quotient ring Loc_m k[x,y]/(x2-y3)
  ideal m = maxideal(1);
  module T1K = Ext(1,m,m);  // computes Ext^1(R/m,R/m)
==> // dimension of Ext^1:  0
==> // vdim of Ext^1:       2
==> 
  print(T1K);
==> 0,  0,y,x,0,y,0,    x2-y3,
==> -y2,x,x,0,y,0,x2-y3,0,    
==> 1,  0,0,0,0,0,0,    0     
  printlevel=2;             // gives more explanation
  module T2K=Ext(2,m,m);    // computes Ext^2(R/m,R/m)
==> // Computing Ext^2 (help Ext; gives an explanation):
==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
==> // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
==> // then Hom(F2,G0)-->Hom(F3,G0) is given by:
==> y2,x,
==> x, y 
==> // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
==> -y,x,  x,0,y,0,
==> x, -y2,0,x,0,y 
==> 
==> // dimension of Ext^2:  0
==> // vdim of Ext^2:       2
==> 
  print(std(T2K));
==> -y2,0,x,0,y,
==> 0,  x,0,y,0,
==> 1,  0,0,0,0 
  printlevel=0;
  module E = Ext(1,syz(m),syz(m));
==> // dimension of Ext^1:  0
==> // vdim of Ext^1:       2
==> 
  print(std(E));
==> -y,x, 0, 0,0,x,0,y,
==> 0, -y,-y,0,x,0,y,0,
==> 0, 0, 0, 1,0,0,0,0,
==> 0, 0, 1, 0,0,0,0,0,
==> 0, 1, 0, 0,0,0,0,0,
==> 1, 0, 0, 0,0,0,0,0 
  //The matrices which we have just computed are presentation matrices
  //of the modules T2K and E. Hence we may ignore those columns
  //containing 1 as an entry and see that T2K and E are isomorphic
  //as expected, but differently presented.
  //-------------------------------------------
  ring S=0,(x,y,z),dp;
  ideal  i = x2y,y2z,z3x;
  module E = Ext_R(2,i);
==> // dimension of Ext^2:  1
==> 
  print(E);
==> 0,y,0,z2,
==> z,0,0,-x,
==> 0,0,x,-y 
  // if a 3-rd argument is given (of any type)
  // a list of Ext^k(R/i,R), a SB of Ext^k(R/i,R) and a vector space basis
  // is returned:
  list LE = Ext_R(3,i,"");
==> // dimension of Ext^3:  0
==> // vdim of Ext^3:       2
==> 
  LE;
==> [1]:
==>    _[1]=y*gen(1)
==>    _[2]=x*gen(1)
==>    _[3]=z2*gen(1)
==> [2]:
==>    _[1]=y*gen(1)
==>    _[2]=x*gen(1)
==>    _[3]=z2*gen(1)
==> [3]:
==>    _[1,1]=z
==>    _[1,2]=1
  print(LE[2]);
==> y,x,z2
  print(kbase(LE[2]));
==> z,1
A.13 Polar curves
=================

The polar curve of a hypersurface given by a polynomial
with respect to 
 (we may consider 
 as a family of
hypersurfaces parametrized by 
) is defined as the Zariski
closure of
if this happens to be a curve.  Some authors consider
itself as polar curve.

We may consider projective hypersurfaces
affine hypersurfaces
or germs of hypersurfaces
getting in this way
projective, affine or local polar curves.

Now let us compute this for a family of curves.  We need the library
elim.lib for saturation and sing.lib for the singular
locus.

  LIB "elim.lib";
  LIB "sing.lib";
  // Affine polar curve:
  ring R = 0,(x,z,t),dp;              // global ordering dp
  poly f = z5+xz3+x2-tz6;
  dim_slocus(f);                      // dimension of singular locus
==> 1
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // dim V(j)
==> 1
  dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
==> 1
  // j defines a curve, but to get the polar curve we must remove the
  // branches contained in f=0 (they exist since dim V(j,f) = 1). This
  // gives the polar curve set theoretically. But for the structure we
  // may take either j:f or j:f^k for k sufficiently large. The first is
  // just the ideal quotient, the second the iterated ideal quotient
  // or saturation. In our case both coincide.
  ideal q = quotient(j,ideal(f));     // ideal quotient
  ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
  ideal sq = std(q);
  dim(sq);
==> 1
  // 1-dimensional, hence q defines the affine polar curve
  //
  // to check that q and qsat are the same, we show both inclusions, i.e.,
  // both reductions must give the 0-ideal
  size(reduce(qsat,sq));
==> 0
  size(reduce(q,std(qsat)));
==> 0
  qsat;
==> qsat[1]=12zt+3z-10
==> qsat[2]=5z2+12xt+3x
==> qsat[3]=144xt2+72xt+9x+50z
  // We see that the affine polar curve does not pass through the origin,
  // hence we expect the local polar "curve" to be empty
  // ------------------------------------------------
  // Local polar curve:
  ring r = 0,(x,z,t),ds;              // local ordering ds
  poly f = z5+xz3+x2-tz6;
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // V(j) 1-dimensional
==> 1
  dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
==> 1
  ideal q = quotient(j,ideal(f));     // ideal quotient
  q;
==> q[1]=1
  // The local polar "curve" is empty, i.e., V(j) is contained in V(f)
  // ------------------------------------------------
  // Projective polar curve: (we need "sing.lib" and "elim.lib")
  ring P = 0,(x,z,t,y),dp;            // global ordering dp
  poly f = z5y+xz3y2+x2y4-tz6;
                                      // but consider t as parameter
  dim_slocus(f);              // projective 1-dimensional singular locus
==> 2
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // V(j), projective 1-dimensional
==> 2
  dim(std(j+ideal(f)));               // V(j,f) also projective 1-dimensional
==> 2
  ideal q = quotient(j,ideal(f));
  ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
  dim(std(qsat));
==> 2
  // projective 1-dimensional, hence q and/or qsat define the projective
  // polar curve. In this case, q and qsat are not the same, we needed
  // 2 quotients.
  // Let us check both reductions:
  size(reduce(qsat,std(q)));
==> 4
  size(reduce(q,std(qsat)));
==> 0
  // Hence q is contained in qsat but not conversely
  q;
==> q[1]=12zty+3zy-10y2
==> q[2]=60z2t-36xty-9xy-50zy
  qsat;
==> qsat[1]=12zt+3z-10y
==> qsat[2]=12xty+5z2+3xy
==> qsat[3]=144xt2+72xt+9x+50z
==> qsat[4]=z3+2xy2
  //
  // Now consider again the affine polar curve,
  // homogenize it with respect to y (deg t=0) and compare:
  // affine polar curve:
  ideal qa = 12zt+3z-10,5z2+12xt+3x,-144xt2-72xt-9x-50z;
  // homogenized:
  ideal qh = 12zt+3z-10y,5z2+12xyt+3xy,-144xt2-72xt-9x-50z;
  size(reduce(qh,std(qsat)));
==> 0
  size(reduce(qsat,std(qh)));
==> 0
  // both ideals coincide
A.14 Depth
==========

We compute the depth of the module of Kaehler differentials
of the variety defined by the 
-minors of a generic symmetric
We do this by computing the resolution over the polynomial
ring.  Then, by the Auslander-Buchsbaum formula, the depth is equal to
the number of variables minus the length of a minimal resolution.  This
example was suggested by U. Vetter in order to check whether his bound
could be improved.

  LIB "matrix.lib"; LIB "sing.lib";
  int n = 4;
  int m = 3;
  int N = n*(n+1)/2;           // will become number of variables
  ring R = 32003,x(1..N),dp;
  matrix X = symmat(n);        // proc from matrix.lib
                               // creates the symmetric generic nxn matrix
  print(X);
==> x(1),x(2),x(3),x(4),
==> x(2),x(5),x(6),x(7),
==> x(3),x(6),x(8),x(9),
==> x(4),x(7),x(9),x(10)
  ideal J = minor(X,m);
  J=std(J);
  // Kaehler differentials D_k(R)
  // of R=k[x1..xn]/J:
  module D = J*freemodule(N)+transpose(jacob(J));
  ncols(D);
==> 110
  nrows(D);
==> 10
  //
  // Note: D is a submodule with 110 generators of a free module
  // of rank 10 over a polynomial ring in 10 variables.
  // Compute a full resolution of D with sres.
  // This takes about 17 sec on a Mac PB 520c and 2 sec an a HP 735
  int time = timer;
  module sD = std(D);
  list Dres = sres(sD,0);                // the full resolution
  timer-time;                            // time used for std + sres
==> 0
  intmat B = betti(Dres);
  print(B,"betti");
==>            0     1     2     3     4     5     6
==> ------------------------------------------------
==>     0:    10     -     -     -     -     -     -
==>     1:     -    10     -     -     -     -     -
==>     2:     -    84   144    60     -     -     -
==>     3:     -     -    35    80    60    16     1
==> ------------------------------------------------
==> total:    10    94   179   140    60    16     1
  N-ncols(B)+1;                          // the desired depth
==> 4

A.15 Formatting output
======================

We show how to insert the result of a computation inside a text
by using strings.
First we compute the powers of 2 and comment the result with some text.
Then we do the same and give the output a nice format by computing and
adding appropriate space.

  // The powers of 2:
  int  n;
  for (n = 2; n <= 128; n = n * 2)
  {"n = " + string (n);}
==> n = 2
==> n = 4
==> n = 8
==> n = 16
==> n = 32
==> n = 64
==> n = 128
  // The powers of 2 in a nice format
  int j;
  string space = "";
  for (n = 2; n <= 128; n = n * 2)
  {
    space = "";
    for (j = 1; j <= 5 - size (string (n)); j = j+1)
    { space = space + " "; }
    "n =" + space + string (n);
  }
==> n =    2
==> n =    4
==> n =    8
==> n =   16
==> n =   32
==> n =   64
==> n =  128

A.16 Cyclic roots
=================

We write a procedure returning a string that enables us to create
automatically the ideal of cyclic roots over the basering with n
variables. The procedure assumes that the variables consist of a single
letter each (hence no indexed variables are allowed; the procedure
cyclic in poly.lib does not have this restriction). Then
we compute a standard basis of this ideal and some numerical
information.  (This ideal is used as a classical benchmark for standard
basis computations).

// We call the procedure 'cyclic':
proc cyclic (int n)
{
   string vs = varstr(basering)+varstr(basering);
   int c=find(vs,",");
   while ( c!=0 )
   {
      vs=vs[1,c-1]+vs[c+1,size(vs)];
      c=find(vs,",");
   }
   string t,s;
   int i,j;
   for ( j=1; j<=n-1; j=j+1 )
   {
      t="";
      for ( i=1; i <=n; i=i+1 )
      {
         t = t + vs[i,j] + "+";
      }
      t = t[1,size(t)-1] + ","+newline;
      s=s+t;
   }
   s=s+vs[1,n]+"-1";
   return (s);
}

ring r=0,(a,b,c,d,e),lp;         // basering, char 0, lex ordering
string sc=cyclic(nvars(basering));
sc;                              // the string of the ideal
==> a+b+c+d+e,
==> ab+bc+cd+de+ea,
==> abc+bcd+cde+dea+eab,
==> abcd+bcde+cdea+deab+eabc,
==> abcde-1
execute("ideal i="+sc+";");      // this defines the ideal of cyclic roots
i;
==> i[1]=a+b+c+d+e
==> i[2]=ab+bc+cd+ae+de
==> i[3]=abc+bcd+abe+ade+cde
==> i[4]=abcd+abce+abde+acde+bcde
==> i[5]=abcde-1
timer=1;
ideal j=std(i);
==> //used time: 7.5 sec
size(j);                         // number of elements in the std basis
==> 11
degree(j);
==> // codimension = 5
==> // dimension   = 0
==> // degree      = 70
A.17 G_a -Invariants
====================

We work in characteristic 0 and use the Lie algebra generated by one
vector field of the form
  LIB "ainvar.lib";
  int n=5;
  int i;
  ring s=32003,(x(1..n)),wp(1,2,3,4,5);
  // definition of the vector field m=sum m[i,1]*d/dx(i)
  matrix m[n][1];
  for (i=1;i<=n-1;i=i+1)
  {
     m[i+1,1]=x(i);
  }
  // computation of the ring of invariants
  ideal in=invariantRing(m,x(2),x(1),0);
  in;   //invariant ring is generated by 5 invariants
==> in[1]=x(1)
==> in[2]=x(2)^2-2*x(1)*x(3)
==> in[3]=x(3)^2-2*x(2)*x(4)+2*x(1)*x(5)
==> in[4]=x(2)^3-3*x(1)*x(2)*x(3)+3*x(1)^2*x(4)
==> in[5]=x(3)^3-3*x(2)*x(3)*x(4)-15997*x(1)*x(4)^2+3*x(2)^2*x(5)-6*x(1)*x(3)\
   *x(5)
  ring q=32003,(x,y,z,u,v,w),dp;
  matrix m[6][1];
  m[2,1]=x;
  m[3,1]=y;
  m[5,1]=u;
  m[6,1]=v;
  // the vector field is: xd/dy+yd/dz+ud/dv+vd/dw
  ideal in=invariantRing(m,y,x,0);
  in; //invariant ring is generated by 6 invariants
==> in[1]=x
==> in[2]=u
==> in[3]=v2-2uw
==> in[4]=zu-yv+xw
==> in[5]=yu-xv
==> in[6]=y2-2xz
A.18 Invariants of a finite group
=================================

Two algorithms to compute the invariant ring are implemented in
SINGULAR, invariant_ring and invariant_ring_random,
both by Agnes E. Heydtmann (agnes@math.uni-sb.de).

Bases of homogeneous invariants are generated successively and those are
chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1997) to appear in JSC).  In the
non-modular case secondary invariants are calculated by finding a basis
(in terms of monomials) of the basering modulo the primary invariants,
mapping to invariants with the Reynolds operator and using those or
their power products such that they are linearly independent modulo the
primary invariants (see paper "Some Algorithms in Invariant Theory of
Finite Groups" by Kemper and Steel (1997)).  In the modular case they
are generated according to "Generating Invariant Rings of Finite Groups
over Arbitrary Fields" by Kemper (1996, to appear in JSC).

We calculate now an example from Sturmfels: "Algorithms in Invariant
Theory 2.3.7":

  LIB "finvar.lib";
  ring R=0,(x,y,z),dp;
  matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
  // the group G is generated by A in Gl(3,Q);
  print(A);
==> 0, 1,0,
==> -1,0,0,
==> 0, 0,-1
  print(A*A*A*A); // the fourth power of A is 1
==> 1,0,0,
==> 0,1,0,
==> 0,0,1 
  // Use the first method to compute the invariants of G:
  matrix B(1..3);
  B(1..3)=invariant_ring(A);
  // SINGULAR returns 2 matrices, the first containing
  // primary invariants and the second secondary
  // invariants, i.e., module generators over a Noetherian
  // normalization
  // the third result are the irreducible secondary invariants
  // if the Molien series was available
  print(B(1));
==> z2,x2+y2,x2y2
  print(B(2));
==> 1,xyz,x2z-y2z,x3y-xy3
  print(B(3));
==> xyz,x2z-y2z,x3y-xy3
  // Use the second method,
  // with random numbers between -1 and 1:
  B(1..3)=invariant_ring_random(A,1);
  print(B(1..3));
==> z2,x2+y2,x4+y4-z4
==> 1,xyz,x2z-y2z,x3y-xy3
==> xyz,x2z-y2z,x3y-xy3
A.19 Factorization
==================

The factorization of polynomials is implemented in the C++ libraries
Factory (written mainly by Ruediger Stobbe) and libfac (written by
Michael Messollen) which are part of the SINGULAR system.

  ring r = 0,(x,y),dp;
  poly f = 9x16-18x13y2-9x12y3+9x10y4-18x11y2+36x8y4
         +18x7y5-18x5y6+9x6y4-18x3y6-9x2y7+9y8;
  // = 9 * (x5-1y2)^2 * (x6-2x3y2-1x2y3+y4)
  factorize(f);
==> [1]:
==>    _[1]=9
==>    _[2]=x6-2x3y2-x2y3+y4
==>    _[3]=-x5+y2
==> [2]:
==>    1,1,2
  // returns factors and multiplicities,
  // first factor is a constant.
  poly g = (y4+x8)*(x2+y2);
  factorize(g);
==> [1]:
==>    _[1]=1
==>    _[2]=x8+y4
==>    _[3]=x2+y2
==> [2]:
==>    1,1,1
  // The same in characteristic 2:
  ring s =2,(x,y),dp;
  poly g = (y4+x8)*(x2+y2);
  factorize(g);
==> [1]:
==>    _[1]=1
==>    _[2]=x+y
==>    _[3]=x2+y
==> [2]:
==>    1,2,4

A.20 Puiseux pairs
==================

The Puiseux pairs of an irreducible and reduced curve singularity are
its most important invariants.  They can be computed from its
Hamburger-Noether expansion.  The library hnoether.lib written by
Martin Lamm uses the algorithm of Antonio Campillo "Algebroid curves in
positive characteristic" SLN 813, 1980.  This algorithm has the
advantage that it needs least possible field extensions and, moreover,
works in any characteristic. This fact can be used to compute the
invariants over a field of finite characteristic, say 32003, which will
then most probably be the same in characteristic 0.

We compute the Hamburger-Noether expansion of a plane curve
singularity given by a polynomial 
 in two variables. This is a
matrix which allows to compute the parametrization (up to a given order)
and all numerical invariants like the
*     characteristic exponents,
*     Puiseux pairs (of a complex model),
*     degree of the conductor,
*     delta invariant,
*     generators of the semigroup.
Besides this, the library contains procedures to compute the Newton
polygon of 
, the squarefree part of 
 and a procedure to
convert one set of invariants to another.


  LIB "hnoether.lib";
  // ======== The irreducible case ========
  ring s = 0,(x,y),ds;
  poly f = y4-2x3y2-4x5y+x6-x7;
  list hn = develop(f);
  show(hn[1]);     // Hamburger-Noether matrix
==> // matrix, 3x3
==> 0,x,  0,  
==> 0,1,  x,  
==> 0,1/4,-1/2
  displayHNE(hn);  // Hamburger-Noether development
==> HNE[1]=-y+z(0)*z(1)
==> HNE[2]=-x+z(1)^2+z(1)^2*z(2)
==> HNE[3]=1/4*z(2)^2-1/2*z(2)^3
  setring s;
  displayInvariants(hn);
==>  characteristic exponents  : 4,6,7
==>  generators of semigroup   : 4,6,13
==>  Puiseux pairs             : (3,2)(7,2)
==>  degree of the conductor   : 16
==>  delta invariant           : 8
==>  sequence of multiplicities: 4,2,2,1,1
  // invariants(hn);  returns the invariants as list
  // partial parametrization of f: param takes the first variable
  // as infinite except the ring has more than 2 variables. Then
  // the 3rd variable is chosen.
  param(hn);
==> // ** Warning: result is exact up to order 5 in x and 7 in y !
==> _[1]=1/16x4-3/16x5+1/4x7
==> _[2]=1/64x6-5/64x7+3/32x8+1/16x9-1/8x10
  ring extring=0,(x,y,t),ds;
  poly f=x3+2xy2+y2;
  list hn=develop(f,-1);
  param(hn);       // partial parametrization of f
==> // ** Warning: result is exact up to order 2 in x and 3 in y !
==> _[1]=-t2
==> _[2]=-t3
  list hn1=develop(f,6);
  param(hn1);     // a better parametrization
==> // ** Warning: result is exact up to order 6 in x and 7 in y !
==> _[1]=-t2+2t4-4t6
==> _[2]=-t3+2t5-4t7
  // instead of recomputing you may extend the development:
  list hn2=extdevelop(hn,12);
  param(hn2);     // a still better parametrization
==> // ** Warning: result is exact up to order 12 in x and 13 in y !
==> _[1]=-t2+2t4-4t6+8t8-16t10+32t12
==> _[2]=-t3+2t5-4t7+8t9-16t11+32t13
  //
  // ======== The reducible case ========
  ring r = 0,(x,y),dp;
  poly f=x11-2y2x8-y3x7-y2x6+y4x5+2y4x3+y5x2-y6;
  // = (x5-1y2) * (x6-2x3y2-1x2y3+y4)
  list hn=reddevelop(f);
  show(hn[1][1]);     // Hamburger-Noether matrix of 1st branch
==> // matrix, 3x3
==> 0,x,0,
==> 0,1,x,
==> 0,1,-1
  displayInvariants(hn);
==>  --- invariants of branch number 1 : ---
==>  characteristic exponents  : 4,6,7
==>  generators of semigroup   : 4,6,13
==>  Puiseux pairs             : (3,2)(7,2)
==>  degree of the conductor   : 16
==>  delta invariant           : 8
==>  sequence of multiplicities: 4,2,2,1,1
==> 
==>  --- invariants of branch number 2 : ---
==>  characteristic exponents  : 2,5
==>  generators of semigroup   : 2,5
==>  Puiseux pairs             : (5,2)
==>  degree of the conductor   : 4
==>  delta invariant           : 2
==>  sequence of multiplicities: 2,2,1,1
==> 
==>  -------------- contact numbers : -------------- 
==> 
==> branch |    2    
==> -------+-----
==>     1  |    2
==> 
==>  -------------- intersection multiplicities : -------------- 
==> 
==> branch |    2    
==> -------+-----
==>     1  |   12
==> 
==>  -------------- delta invariant of the curve :  22
  param(hn[2]);      // parametrization of 2nd branch
==> _[1]=x2
==> _[2]=x5
A.21 Primary decomposition
==========================

There are two algorithms implemented in SINGULAR which provide
primary decomposition: primdecGTZ, based on
Gianni/Trager/Zacharias (written by Gerhard Pfister) and
primdecSY, based on Shimoyama/Yokoyama (written by Wolfram Decker
and Hans Schoenemann).

The result of primdecGTZ and primdecSY is returned as
a list of pairs of ideals,
where the second ideal form the prime ideal and the first
ideal form the corresponding primary ideal.

  LIB "primdec.lib";
  ring r = 0,(a,b,c,d,e,f),dp;
  ideal i= f3, ef2, e2f, bcf-adf, de+cf, be+af, e3;
  primdecGTZ(i);
==> [1]:
==>    [1]:
==>       _[1]=f
==>       _[2]=e
==>    [2]:
==>       _[1]=f
==>       _[2]=e
==> [2]:
==>    [1]:
==>       _[1]=f3
==>       _[2]=ef2
==>       _[3]=e2f
==>       _[4]=e3
==>       _[5]=de+cf
==>       _[6]=be+af
==>       _[7]=-bc+ad
==>    [2]:
==>       _[1]=f
==>       _[2]=e
==>       _[3]=-bc+ad
  // We consider now the ideal J of the base space of the
  // miniversal deformation of the cone over the rational
  // normal curve computed in section *8* and compute
  // its primary decomposition.
  ring R = 0,(A,B,C,D),dp;
  ideal J = CD, BD+D2, AD;
  primdecGTZ(J);
==> [1]:
==>    [1]:
==>       _[1]=D
==>    [2]:
==>       _[1]=D
==> [2]:
==>    [1]:
==>       _[1]=C
==>       _[2]=B+D
==>       _[3]=A
==>    [2]:
==>       _[1]=C
==>       _[2]=B+D
==>       _[3]=A
  // We see that there are two components which are both
  // prime, even linear subspaces, one 3-dimensional,
  // the other 1-dimensional.
  // (This is Pinkhams example and was the first known
  // surface singularity with two components of
  // different dimensions)
  //
  // Let us now produce an embedded component in the last
  // example, compute the minimal associated primes and
  // the radical. We use the Characteristic set methods
  // from prim_dec.lib.
  J = intersect(J,maxideal(3));
  // The following shows that the maximal ideal defines an embedded
  // (prime) component.
  primdecSY(J);
==> [1]:
==>    [1]:
==>       _[1]=D
==>    [2]:
==>       _[1]=D
==> [2]:
==>    [1]:
==>       _[1]=C
==>       _[2]=B+D
==>       _[3]=A
==>    [2]:
==>       _[1]=C
==>       _[2]=B+D
==>       _[3]=A
==> [3]:
==>    [1]:
==>       _[1]=D2
==>       _[2]=C2
==>       _[3]=B2
==>       _[4]=AB
==>       _[5]=A2
==>       _[6]=BCD
==>       _[7]=ACD
==>    [2]:
==>       _[1]=D
==>       _[2]=C
==>       _[3]=B
==>       _[4]=A
  minAssChar(J);
==> [1]:
==>    _[1]=C
==>    _[2]=B+D
==>    _[3]=A
==> [2]:
==>    _[1]=D
  radical(J);
==> _[1]=CD
==> _[2]=BD+D2
==> _[3]=AD
A.22 Normalization
==================
The normalization will be computed for a reduced ring 
. The
result is a list of rings; ideals are always called norid in the
rings of this list. The normalization of 
 is the product of
the factor rings of the rings in the list divided out by the ideals
norid.

  LIB "normal.lib";
  // ----- first example: rational quadruple point -----
  ring R=32003,(x,y,z),wp(3,5,15);
  ideal I=z*(y3-x5)+x10;
  list pr=normal(I);
==> 
==> // 'normal' created a list of 1 ring(s).
==> // nor[1+1] is the delta-invariant in case of choose=wd.
==> // To see the rings, type (if the name of your list is nor):
==>      show( nor);
==> // To access the 1-st ring and map (similar for the others), type:
==>      def R = nor[1]; setring R;  norid; normap;
==> // R/norid is the 1-st ring of the normalization and
==> // normap the map from the original basering to R/norid
  def S=pr[1];
  setring S;
  norid;
==> norid[1]=T(2)*T(3)-T(1)*T(4)
==> norid[2]=T(1)^7-T(1)^2*T(3)+T(2)*T(5)
==> norid[3]=T(1)^2*T(5)-T(2)*T(4)
==> norid[4]=T(1)^5*T(4)-T(3)*T(4)+T(5)^2
==> norid[5]=T(1)^6*T(3)-T(1)*T(3)^2+T(4)*T(5)
==> norid[6]=T(1)*T(3)*T(5)-T(4)^2
  // ----- second example: union of straight lines -----
  ring R1=0,(x,y,z),dp;
  ideal I=(x-y)*(x-z)*(y-z);
  list qr=normal(I);
==> 
==> // 'normal' created a list of 3 ring(s).
==> // nor[3+1] is the delta-invariant in case of choose=wd.
==> // To see the rings, type (if the name of your list is nor):
==>      show( nor);
==> // To access the 1-st ring and map (similar for the others), type:
==>      def R = nor[1]; setring R;  norid; normap;
==> // R/norid is the 1-st ring of the normalization and
==> // normap the map from the original basering to R/norid
  def S1=qr[1]; def S2=qr[2];
  setring S1; norid;
==> norid[1]=0
  setring S2; norid;
==> norid[1]=0
A.23 Branches of an Isolated Space Curve Singularity
====================================================

In this example, the number of branches of a given quasihomogeneous isolated
space curve singularity will be computed as an example of the pitfalls
appearing in the use of primary decomposition. When dealing with singularities,
two situations are possible in which the primary decomposition algorithm
might not lead to a complete decomposition: first of all, one of the computed
components could be globally irreducible, but analytically reducible
(this is impossible for quasihomogeneous singularities) and,
as a second possibility, a component might be irreducible over the rational
numbers, but reducible over the complex numbers.
  ring r=0,(x,y,z),ds;
  ideal i=x^4-y*z^2,x*y-z^3,y^2-x^3*z;  // the space curve singularity
  qhweight(i);
==> 1,2,1
  // The given space curve singularity is quasihomogeneous. Hence we can pass
  // to the polynomial ring.
  ring rr=0,(x,y,z),dp;
  ideal i=imap(r,i);
  resolution ires=mres(i,0);
  ires;
==>   1       3       2       
==> rr <--  rr <--  rr
==> 
==> 0       1       2       
==> 
  // From the structure of the resolution, we see that the Cohen-Macaulay
  // type of the given singularity is 2
  //
  // Let us now look for the branches using the primdec library.
  LIB "primdec.lib";
  primdecSY(i);
==> [1]:
==>    [1]:
==>       _[1]=z3-xy
==>       _[2]=x3+x2z+xz2+xy+yz
==>       _[3]=x2z2+x2y+xyz+yz2+y2
==>    [2]:
==>       _[1]=z3-xy
==>       _[2]=x3+x2z+xz2+xy+yz
==>       _[3]=x2z2+x2y+xyz+yz2+y2
==> [2]:
==>    [1]:
==>       _[1]=x-z
==>       _[2]=z2-y
==>    [2]:
==>       _[1]=x-z
==>       _[2]=z2-y
  def li=_[2];
  ideal i2=li[2];       // call the second ideal i2
  // The curve seems to have 2 branches by what we computed using the
  // algorithm of Shimoyama-Yokoyama.
  // Now the same computation by the Gianni-Trager-Zacharias algorithm:
  primdecGTZ(i);
==> [1]:
==>    [1]:
==>       _[1]=z8+yz6+y2z4+y3z2+y4
==>       _[2]=xz5+z6+yz4+y2z2+y3
==>       _[3]=-z3+xy
==>       _[4]=x2z2+xz3+xyz+yz2+y2
==>       _[5]=x3+x2z+xz2+xy+yz
==>    [2]:
==>       _[1]=z8+yz6+y2z4+y3z2+y4
==>       _[2]=xz5+z6+yz4+y2z2+y3
==>       _[3]=-z3+xy
==>       _[4]=x2z2+xz3+xyz+yz2+y2
==>       _[5]=x3+x2z+xz2+xy+yz
==> [2]:
==>    [1]:
==>       _[1]=-z2+y
==>       _[2]=x-z
==>    [2]:
==>       _[1]=-z2+y
==>       _[2]=x-z
  // Having computed the primary decomposition in 2 different ways and
  // having obtained the same number of branches, we might expect that the
  // number of branches is really 2, but we can check this by formulae
  // for the invariants of space curve singularities:
  //
  // mu = tau - t + 1 (for quasihomogeneous curve singularities)
  // where mu denotes the Milnor number, tau the Tjurina number and
  // t the Cohen-Macaulay type
  //
  // mu = 2 delta - r + 1
  // where delta denotes the delta-Invariant and r the number of branches
  //
  // tau can be computed by using the corresponding procedure T1 from
  // sing.lib.
  setring r;
  LIB "sing.lib";
  T_1(i);
==> // dim T_1 = 13
==> _[1]=gen(6)+2z*gen(5)
==> _[2]=gen(4)+3x2*gen(2)
==> _[3]=gen(3)+gen(1)
==> _[4]=x*gen(5)-y*gen(2)-z*gen(1)
==> _[5]=x*gen(1)-z2*gen(2)
==> _[6]=y*gen(5)+3x2z*gen(2)
==> _[7]=y*gen(2)-z*gen(1)
==> _[8]=2y*gen(1)-z2*gen(5)
==> _[9]=z2*gen(5)
==> _[10]=z2*gen(1)
==> _[11]=x3*gen(2)
==> _[12]=x2z2*gen(2)
==> _[13]=xz3*gen(2)
==> _[14]=z4*gen(2)
  setring rr;
  // Hence tau is 13 and therefore mu is 12. But then it is impossible that
  // the singularity has two branches, since mu is even and delta is an
  // integer!
  // So obviously, we did not decompose completely. Because the first branch
  // is smooth, only the second ideal can be the one which can be decomposed
  // further.
  // Let us now consider the normalization of this second ideal i2.
  LIB "normal.lib";
  normal(i2);
==> 
==> // 'normal' created a list of 1 ring(s).
==> // nor[1+1] is the delta-invariant in case of choose=wd.
==> // To see the rings, type (if the name of your list is nor):
==>      show( nor);
==> // To access the 1-st ring and map (similar for the others), type:
==>      def R = nor[1]; setring R;  norid; normap;
==> // R/norid is the 1-st ring of the normalization and
==> // normap the map from the original basering to R/norid
==> [1]:
==>    //   characteristic : 0
==> //   number of vars : 1
==> //        block   1 : ordering dp
==> //                  : names    T(1) 
==> //        block   2 : ordering C
  def rno=_[1];
  setring rno;
  norid;
==> norid[1]=0
  // The ideal is generated by a polynomial in one variable of degree 4 which
  // factors completely into 4 polynomials of type T(2)+a.
  // From this, we know that the ring of the normalization is the direct sum of 
  // 4 polynomial rings in one variable.
  // Hence our original curve has these 4 branches plus a smooth one
  // which we already determined by primary decomposition.
  // Our final result is therefore: 5 branches.
A.24 Kernel of module homomorphisms
===================================
Let 
, 
 be two matrices of size
over the ring 
 and consider the corresponding maps
We want to compute the kernel of the map
This can be done using the modulo command:

  ring r=0,(x,y,z),(c,dp);
  matrix A[2][2]=x,y,z,1;
  matrix B[2][2]=x2,y2,z2,xz;
  print(modulo(A,B));
==> yz2-x2, xyz-y2,  x2z-xy, x3-y2z,
==> x2z-xz2,-x2z+y2z,xyz-yz2,0      

A.25 Algebraic dependence
=========================
Let
We want to check whether
1. are algebraically dependent.

Let
Then
are the algebraic relations between

2. 
if and only if the normal form of 
 with respect to 
 and a
block ordering with respect to
is in 
.

Both questions can be answered using the following procedure. If the
second argument is zero, it checks for algebraic dependence and returns
the ideal of relations between the generators of the given ideal.
Otherwise it checks for subring membership and returns the normal form
of the second argument with respect to the ideal I.

  proc algebraicDep(ideal J, poly g)
  {
    def R=basering;         // give a name to the basering
    int n=size(J);
    int k=nvars(R);
    int i;
    intvec v;

    // construction of the new ring:

    // construct a weight vector
    v[n+k]=0;         // gives a zero vector of length n+k
    for(i=1;i<=k;i++)
    {
      v[i]=1;
    }
    string orde="(a("+string(v)+"),dp);";
    string ri="ring Rhelp=("+charstr(R)+"),
                          ("+varstr(R)+",Y(1.."+string(n)+")),"+orde;
                            // ring definition as a string
    execute(ri);            // execution of the string

    // construction of the new ideal I=(J[1]-Y(1),...,J[n]-Y(n))
    ideal I=imap(R,J);
    for(i=1;i<=n;i++)
    {
      I[i]=I[i]-var(k+i);
    }
    poly g=imap(R,g);
    if(g==0)
    {
      // construction of the ideal of relations by elimination
      poly el=var(1);
      for(i=2;i<=k;i++)
      {
        el=el*var(i);
      }
      ideal KK=eliminate(I,el);
      keepring(Rhelp);
      return(KK);
    }
    // reduction of g with respect to I
    ideal KK=reduce(g,std(I));
    keepring(Rhelp);
    return(KK);
  }

  // applications of the procedure
  ring r=0,(x,y,z),dp;
  ideal i=xz,yz;
  algebraicDep(i,0);
==> _[1]=0
  // Note: after call of algebraicDep(), the basering is Rhelp.
  setring r; kill Rhelp;
  ideal j=xy+z2,z2+y2,x2y2-2xy3+y4;
  algebraicDep(j,0);
==> _[1]=Y(1)^2-2*Y(1)*Y(2)+Y(2)^2-Y(3)
  setring r; kill Rhelp;
  poly g=y2z2-xz;
  algebraicDep(i,g);
==> _[1]=Y(2)^2-Y(1)
  // this shows that g is contained in i.
  setring r; kill Rhelp;
  algebraicDep(j,g);
==> _[1]=-z^4+z^2*Y(2)-x*z
  // this shows that g is contained in j.

A.26 Classification
===================

Classification of isolated hypersurface singularities with respect to
right equivalence is provided by the command classify of the
library classify.lib. The classification is done using the
algorithm of Arnold. Before entering this algorithm, a first guess based
on the Hilbert polynomial of the Milnor algebra is made.

  LIB "classify.lib";
  ring r=0,(x,y,z),ds;
  poly p=singularity("E[6k+2]",2)[1];
  p=p+z^2;
  p;
==> z2+x3+xy6+y8
  // We received an E_14 singularity in normal form
  // from the database of normal forms. Since only the residual
  // part is saved in the database, we added z^2 to get an E_14
  // of embedding dimension 3.
  //
  // Now we apply a coordinate change in order to deal with a
  // singularity which is not in normal form:
  map phi=r,x+y,y+z,x;
  poly q=phi(p);
  // Yes, q really looks ugly, now:
  q;
==> x2+x3+3x2y+3xy2+y3+xy6+y7+6xy5z+6y6z+15xy4z2+15y5z2+20xy3z3+20y4z3+15xy2z\
   4+15y3z4+6xyz5+6y2z5+xz6+yz6+y8+8y7z+28y6z2+56y5z3+70y4z4+56y3z5+28y2z6+8\
   yz7+z8
  // Classification
  classify(q);
==> About the singularity :
==>           Milnor number(f)   = 14
==>           Corank(f)          = 2
==>           Determinacy       <= 12
==> Guessing type via Milnorcode:   E[6k+2]=E[14]
==> 
==> Computing normal form ...
==> I have to apply the splitting lemma. This will take some time....:-)
==>    Arnold step number 9
==> The singularity
==>    x3-9/4x4+27/4x5-189/8x6+737/8x7+6x6y+15x5y2+20x4y3+15x3y4+6x2y5+xy6-24\
   089/64x8-x7y+11/2x6y2+26x5y3+95/2x4y4+47x3y5+53/2x2y6+8xy7+y8+104535/64x9\
   +27x8y+135/2x7y2+90x6y3+135/2x5y4+27x4y5+9/2x3y6-940383/128x10-405/4x9y-2\
   025/8x8y2-675/2x7y3-2025/8x6y4-405/4x5y5-135/8x4y6+4359015/128x11+1701/4x\
   10y+8505/8x9y2+2835/2x8y3+8505/8x7y4+1701/4x6y5+567/8x5y6-82812341/512x12\
   -15333/8x11y-76809/16x10y2-25735/4x9y3-78525/16x8y4-16893/8x7y5-8799/16x6\
   y6-198x5y7-495/4x4y8-55x3y9-33/2x2y10-3xy11-1/4y12
==> is R-equivalent to E[14].
==>    Milnor number = 14
==>    modality      = 1
==> 2z2+x3+xy6+y8
  // The library also provides routines to determine the corank of q
  // and its residual part without going through the whole
  // classification algorithm.
  corank(q);
==> 2
  morsesplit(q);
==> y3-9/4y4+27/4y5-189/8y6+737/8y7+6y6z+15y5z2+20y4z3+15y3z4+6y2z5+yz6-24089\
   /64y8-y7z+11/2y6z2+26y5z3+95/2y4z4+47y3z5+53/2y2z6+8yz7+z8+104535/64y9+27\
   y8z+135/2y7z2+90y6z3+135/2y5z4+27y4z5+9/2y3z6-940383/128y10-405/4y9z-2025\
   /8y8z2-675/2y7z3-2025/8y6z4-405/4y5z5-135/8y4z6+4359015/128y11+1701/4y10z\
   +8505/8y9z2+2835/2y8z3+8505/8y7z4+1701/4y6z5+567/8y5z6-82812341/512y12-15\
   333/8y11z-76809/16y10z2-25735/4y9z3-78525/16y8z4-16893/8y7z5-8799/16y6z6-\
   198y5z7-495/4y4z8-55y3z9-33/2y2z10-3yz11-1/4z12
A.27 Fast lexicographical GB
============================

Compute Groebner basis in lexicographical ordering
by using the FGLM algorithm (stdfglm)
and Hilbert driven Groebner (stdhilb).

The command stdfglm applies only for zero-dimensional ideals and
returns a reduced Groebner basis.

For the ideal below, stdfglm is more than 100 times
and stdhilb about 10 times faster than std.

  ring r =32003,(a,b,c,d,e),lp;
  ideal i=a+b+c+d, ab+bc+cd+ae+de, abc+bcd+abe+ade+cde,
          abc+abce+abde+acde+bcde, abcde-1;
  int t=timer;
  ideal j1=stdfglm(i);
  timer-t;
==> 0
  size(j1);   // size (no. of polys) in computed GB
==> 5
  t=timer;
  ideal j2=stdhilb(i);
  timer-t;
==> 0
  size(j2);   // size (no. of polys) in computed GB
==> 158
  // usual Groebner basis computation for lex ordering
  t=timer;
  ideal j0 =std(i);
  timer-t;
==> 1
A.28 Parallelization with MPtcp links
=====================================
In this example, we demonstrate how MPtcp links can be used to
parallelize computations.

To compute a standard basis for a zero-dimensional ideal in the
lexicographical ordering, one of the two powerful routines
stdhilb
(see stdhilb)
and stdfglm
(see stdfglm)
should be used. However, a priory one can not predict
which one of the two commands is faster. This very much depends on the
(input) example. Therefore, we use MPtcp links to let both commands
work on the problem independently and in parallel, so that the one which
finishes first delivers the result.

The example we use is the so-called "omdi example". See Tim
Wichmann; Der FGLM-Algorithmus: verallgemeinert und implementiert in
Singular; Diplomarbeit Fachbereich Mathematik, Universitaet
Kaiserslautern; 1997 for more details.

ring r=0,(a,b,c,u,v,w,x,y,z),lp;
ideal i=a+c+v+2x-1, ab+cu+2vw+2xy+2xz-2/3,  ab2+cu2+2vw2+2xy2+2xz2-2/5,
ab3+cu3+2vw3+2xy3+2xz3-2/7, ab4+cu4+2vw4+2xy4+2xz4-2/9, vw2+2xyz-1/9,
vw4+2xy2z2-1/25, vw3+xyz2+xy2z-1/15, vw4+xyz3+xy3z-1/21;

link l_hilb,l_fglm = "MPtcp:fork","MPtcp:fork";         // 1.

open(l_fglm); open(l_hilb);

write(l_hilb, quote(system("pid")));                    // 2.
write(l_fglm, quote(system("pid")));
int pid_hilb,pid_fglm = read(l_hilb),read(l_fglm);

write(l_hilb, quote(stdhilb(i)));                       // 3.
write(l_fglm, quote(stdfglm(eval(i))));

while ((! status(l_hilb, "read", "ready", 1)) &&        // 4.
       (! status(l_fglm, "read", "ready", 1))) {}

if (status(l_hilb, "read", "ready"))
{
  "stdhilb won !!!!"; size(read(l_hilb));
  close(l_hilb); pid_fglm = system("sh","kill "+string(pid_fglm));
}
else                                                    // 5.
{
  "stdfglm won !!!!"; size(read(l_fglm));
  close(l_fglm); pid_hilb = system("sh","kill "+string(pid_hilb));
}
==> stdfglm won !!!!
==> 9
Some explanatory remarks are in order:
1. Instead of using links of the type MPtcp:fork, we alternatively
could use MPtcp:launch links such that the two "competing"
SINGULAR processes run on different machines. This has the
advantage of "true" parallel computing since no resource sharing is
involved (as it usually is with forked processes).

2. Unfortunately, MPtcp links do not offer means to (asynchronously)
interrupt or kill an attached (i.e., launched or forked)
process. Therefore, we explicitly need to get the process id numbers of
the competing SINGULAR processes, so that we can "kill" the
looser later.

3. Notice how quoting is used in order to prevent local evaluation
(i.e., local computation of results). Since we "forked" the two
competing processes, the identifier i is defined and has
identical values in both child processes. Therefore, the innermost
eval can be omitted (as is done for the l_hilb link),
and only the identifier i needs to be communicated to the
children. However, when MPtcp:launch links are used, the inner
evaluation must be applied so that actual values, and not the
identifiers are communicated (as is done for the l_fglm link).

4. We go into a "sleepy" loop and wait until one of the two children
finished the computation. That is, the current process checks approximately
once per second the status of one of the connecting links, and sleeps
(i.e., suspends its execution) in the intermediate time.

5. The child which has won delivers the result and is terminated with the usual
close command. The other child which is still computing needs to
be terminated by an explicit (i.e., system) kill command, since it can
not be terminated through the link while it is still computing.


