This is singular.hlp, produced by makeinfo version 4.13 from
singular.texi.


File: singular.hlp,  Node: char,  Next: char_series,  Prev: betti,  Up: Functions

5.1.4 char
----------

`*Syntax:*'
     `char (' ring_name `)'

`*Type:*'
     int

`*Purpose:*'
     returns the characteristic of the coefficient field of a ring.

`*Example:*'

            ring r=32003,(x,y),dp;
            char(r);
          ==> 32003
            ring s=0,(x,y),dp;
            char(s);
          ==> 0
            ring ra=(7,a),(x,y),dp;
            minpoly=a^3+a+1;
            char(ra);
          ==> 7
            ring rp=(49,a),(x,y),dp;
            char(rp);
          ==> 7
            ring rr=real,x,dp;
            char(rr);
          ==> 0

* Menu:

See
* charstr::
* ring::

See *note charstr::; *note ring::.


File: singular.hlp,  Node: char_series,  Next: charstr,  Prev: char,  Up: Functions

5.1.5 char_series
-----------------

`*Syntax:*'
     `char_series (' ideal_expression `)'

`*Type:*'
     matrix

`*Purpose:*'
     the rows of the matrix represent the irreducible characteristic
     series of the ideal with respect to the current ordering of
     variables.
     One application is the decomposition of the zero-set.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            print(char_series(ideal(xyz,xz,y)));
          ==> y,z,
          ==> x,y 

* Menu:

See
* Characteristic sets::

See *note Characteristic sets::.


File: singular.hlp,  Node: charstr,  Next: cleardenom,  Prev: char_series,  Up: Functions

5.1.6 charstr
-------------

`*Syntax:*'
     `charstr (' ring_name `)'

`*Type:*'
     string

`*Purpose:*'
     returns the description of the coefficient field of a ring.

`*Example:*'

            ring r=32003,(x,y),dp;
            charstr(r);
          ==> 32003
            ring s=0,(x,y),dp;
            charstr(s);
          ==> 0
            ring ra=(7,a),(x,y),dp;
            minpoly=a^3+a+1;
            charstr(ra);
          ==> 7,a
            ring rp=(49,a),(x,y),dp;
            charstr(rp);
          ==> 49,a
            ring rr=real,x,dp;
            charstr(rr);
          ==> real

* Menu:

See
* char::
* ordstr::
* ring::
* varstr::

See *note char::; *note ordstr::; *note ring::; *note varstr::.


File: singular.hlp,  Node: cleardenom,  Next: close,  Prev: charstr,  Up: Functions

5.1.7 cleardenom
----------------

`*Syntax:*'
     `cleardenom (' poly_expression `)'
     `cleardenom (' vector_expression `)'

`*Type:*'
     same as the input type

`*Purpose:*'
     multiplies a polynomial, resp. vector, by a suitable constant to
     cancel all denominators from its coefficients and then divide it by
     its content.

`*Example:*'

            ring r=0,(x,y,z),dp;
            poly f=(3x+6y)^5;
            f/5;
          ==> 243/5x5+486x4y+1944x3y2+3888x2y3+3888xy4+7776/5y5
            cleardenom(f/5);
          ==> x5+10x4y+40x3y2+80x2y3+80xy4+32y5


File: singular.hlp,  Node: close,  Next: coef,  Prev: cleardenom,  Up: Functions

5.1.8 close
-----------

`*Syntax:*'
     `close (' link_expression `)'

`*Type:*'
     none

`*Purpose:*'
     closes a link.

`*Example:*'

          link l="MPtcp:launch";
          open(l); // start SINGULAR "server" on localhost in batchmode
          close(l); // shut down SINGULAR server

* Menu:

See
* link::
* open::

See *note link::; *note open::.


File: singular.hlp,  Node: coef,  Next: coeffs,  Prev: close,  Up: Functions

5.1.9 coef
----------

`*Syntax:*'
     `coef (' poly_expression`,' product_of_ringvars `)'

`*Type:*'
     matrix

`*Syntax:*'
     `coef (' vector_expression`,' product_of_ringvars`,' matrix_name`,'
     matrix_name `)'

`*Type:*'
     none

`*Purpose:*'
     determines the monomials in f divisible by one of the ring
     variables of m (where f is the first argument and m the second
     argument) and the coefficients of these monomials as polynomials in
     the remaining variables.

     First case:  returns a 2 x n matrix M, n being the number of the
     determined monomials.  The first row consists of these monomials,
     the second row of the corresponding coefficients of the monomials
     in f.  Thus, f = M[1,1]*M[2,1]+...+M[1,n]*M[2,n].

     Second case: the second matrix (i.e., the 4th argument) contains
     the monomials, the first matrix (i.e., the 3rd argument) the
     corresponding coefficients of the monomials in the vector.

`*Note:*'
     coef considers only monomials which really occur in f (i.e., which
     are not 0), while coeffs (see *note coeffs::) returns the
     coefficient 0 at the appropriate place if a monomial is not
     present.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            poly f=x5+5x4y+10x2y3+y5;
            matrix m=coef(f,y);
            print(m);
          ==> y5,y3,  y,  1,
          ==> 1, 10x2,5x4,x5
            f=x20+xyz+xy+x2y+z3;
            print(coef(f,xy));
          ==> x20,x2y,xy, 1,
          ==> 1,  1,  z+1,z3
            vector v=[f,zy+77+xy];
            print(v);
          ==> [x20+x2y+xyz+z3+xy,xy+yz+77]
            matrix mc; matrix mm;
            coef(v,y,mc,mm);
            print(mc);
          ==> x2+xz+x,x20+z3,
          ==> x+z,    77     
            print(mm);
          ==> y,1,
          ==> y,1 

* Menu:

See
* coeffs::

See *note coeffs::.


File: singular.hlp,  Node: coeffs,  Next: contract,  Prev: coef,  Up: Functions

5.1.10 coeffs
-------------

`*Syntax:*'
     `coeffs (' poly_expression `,' ring_variable `)'
     `coeffs (' ideal_expression`,' ring_variable `)'
     `coeffs (' vector_expression`,' ring_variable `)'
     `coeffs (' module_expression`,' ring_variable `)'
     `coeffs (' poly_expression`,' ring_variable`,' matrix_name `)'
     `coeffs (' ideal_expression`,' ring_variable`,' matrix_name `)'
     `coeffs (' vector_expression`,' ring_variable`,' matrix_name `)'
     `coeffs (' module_expression`,' ring_variable`,' matrix_name `)'

`*Type:*'
     matrix

`*Purpose:*'
     develops each polynomial of the first argument, say J, as a
     univariate polynomial in the given ring_variable, say z, and
     returns the coefficients as a k x d matrix M, where:

         d-1 = maximum z-degree of all occurring polynomials
           k = 1 if J is a polynomial,
           k = number of generators  if J is an ideal.

     If J is a vector or a module this procedure is repeated for each
     component and the resulting matrices are appended.
     The third argument is used to return the matrix T of coefficients
     such that matrix(J) = T*M.  The third argument is used to return the matrix T of coefficients
     such that {\tt matrix}(J) = T*M.

`*Note:*'
     `coeffs' returns the coefficient 0 at the appropriate place if a
     monomial is not present, while `coef' considers only monomials
     which really occur in the given expression.
     If $M=(m_{ij})$
     M=(M[i,j]) then the j-th generator of an ideal J is equal to $$J_j = z^0 \cdot m_{1j} + z^1 \cdot m_{2j} + ... + z^{d-1} \cdot m_{dj},$$
     while for a module J the i-th component of the j-th generator is
     equal to the entry [i,j] of {\tt matrix}(J), and we get


        J[j] = z^0*M[1,j] + z^1*M[2,j] + ... + z^(d-1)*M[d,j],


     while for a module J the i-th component of the j-th generator is
     equal to the entry [i,j] of matrix(J), and we get $$ J_{i,j} = z^0 \cdot m_{(i-1)d+1,j} + z^1 \cdot m_{(i-1)d+2,j} + ... +
     z^{d-1} \cdot m_{id,j}.$$


      J[i,j] = z^0*M[(i-1)*d+1,j] + z^1*M[(i-1)*d+2,j] + ...
                                  + z^(d-1)*M[i*d,j].

`*Example:*'

            ring r;
            poly f=(x+y)^3;
            matrix M=coeffs(f,y);
            print(M);
          ==> x3, 
          ==> 3x2,
          ==> 3x, 
          ==> 1   
            ideal i=f,xyz+z10y4;
            print(coeffs(i,y));
          ==> x3, 0, 
          ==> 3x2,xz,
          ==> 3x, 0, 
          ==> 1,  0, 
          ==> 0,  z10

`*Syntax:*'
     `coeffs (' ideal_expression`,' ideal_expression `)'
     `coeffs (' module_expression`,' module_expression `)'
     `coeffs (' ideal_expression`,' ideal_expression`,'
     product_of_ringvars `)'
     `coeffs (' module_expression`,' module_expression`,'
     product_of_ringvars `)'

`*Type:*'
     matrix

`*Purpose:*'
     let the first argument be M, the second argument  be K (a set of
     monomials, resp. vectors with monomial entries, in the variables
     appearing in P), the third argument be the product P of variables
     to consider (if this argument is not given, then the product of all
     ring variables is taken as default argument).
     M is supposed to consist of elements of (resp. have entries in) a
     finitely generated module over a ring in the variables not
     appearing in P. K should contain the generators of M over this
     smaller ring.  Then `coeffs(M,K,P)' returns a matrix A of
     coefficients with K*A=M such that the entries of A do not contain
     any variable from P.
     If K does not contain all generators that are necessary to express
     M, then K*A=M' where M' is the part of M that can be expressed.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            ideal M=x2z+y3,xy;
            print(coeffs(M,ideal(x2,xy,y2),xy));
          ==> z,0,
          ==> 0,1,
          ==> 0,0 
            print(coeffs(M,ideal(x2,xy,y2)));
          ==> 0,0,
          ==> 0,1,
          ==> 0,0 

* Menu:

See
* coef::
* kbase::

See *note coef::; *note kbase::.


File: singular.hlp,  Node: contract,  Next: dbprint,  Prev: coeffs,  Up: Functions

5.1.11 contract
---------------

`*Syntax:*'
     `contract (' ideal_expression`,' ideal_expression `)'

`*Type:*'
     matrix

`*Purpose:*'
     contracts each of the n elements of the second ideal J by each of
     the m elements of the first ideal I, producing a m x n matrix.
     Contraction is defined on monomials by:

       contract(x^A,x^B) := x^(B-A) (if B>=A componentwise),
                         :=   0     (otherwise),

$${\rm contract}(x^A ,  x^B) := \cases{ x^{(B-A)}, &if $B\ge A$
     componentwise\cr 0,&otherwise.\cr}$$
     where A and B are the multiexponents of the ring variables
     represented by $x$.
     x.  `contract' is extended bilinearly to all polynomials.

`*Example:*'

            ring r=0,(a,b,c,d),dp;
            ideal I=a2,a2+bc,abc;
            ideal J=a2-bc,abcd;
            print(contract(I,J));
          ==> 1,0, 
          ==> 0,ad,
          ==> 0,d  

* Menu:

See
* diff::

See *note diff::.


File: singular.hlp,  Node: dbprint,  Next: defined,  Prev: contract,  Up: Functions

5.1.12 dbprint
--------------

`*Syntax:*'
     `dbprint (' int_expression`,' expression_list `)'

`*Type:*'
     none

`*Purpose:*'
     applies the print command to each expression in the expression_list
     if int_expression is positive.  `dbprint' may also be used in
     procedures in order to print results subject to certain conditions.

`*Syntax:*'
     `dbprint (' expression `)'

`*Type:*'
     none

`*Purpose:*'
     The print command is applied to the expression if
     `printlevel>=voice'.

`*Note:*'
     *Note Guidelines for writing a library::, for an example how this
     is used for displaying comments while procedures are executed.

`*Example:*'

            int debug=0;
            intvec i=1,2,3;
            dbprint(debug,i);
            debug=1;
            dbprint(debug,i);
          ==> 1,2,3
            voice;
          ==> 1
            printlevel;
          ==> 0
            dbprint(i);

* Menu:

See
* Debugging tools::
* print::
* printlevel::
* voice::

See *note Debugging tools::; *note print::; *note printlevel::; *note
voice::.


File: singular.hlp,  Node: defined,  Next: deg,  Prev: dbprint,  Up: Functions

5.1.13 defined
--------------

`*Syntax:*'
     `defined (' name `)'

`*Type:*'
     int

`*Purpose:*'
     returns a value <>0 (TRUE) if there is a user-defined object with
     this name, and 0 (FALSE) otherwise.
     A non-zero return value is the level where the object is defined
     (level 1 denotes the top level, level 2 the level of a first
     procedure, level 3 the level of a procedure called by a first
     procedure, etc.). For ring variables, -1 is returned.

`*Note:*'
     A local object `m' may be identified by `if (defined(m)==voice)'.

`*Example:*'

            ring r=(0,t),(x,y),dp;
            matrix m[5][6]=x,y,1,2,0,x+y;
            defined(mm);
          ==> 0
            defined(r) and defined(m);
          ==> 1
            defined(m)==voice;   // m is defined in the current level
          ==> 1
            defined(x);
          ==> -1
            defined(z);
          ==> 0
            defined(t);
          ==> -1
            defined(42);
          ==> -1

* Menu:

See
* rvar::
* voice::

See *note rvar::; *note voice::.


File: singular.hlp,  Node: deg,  Next: degree,  Prev: defined,  Up: Functions

5.1.14 deg
----------

`*Syntax:*'
     `deg (' poly_expression `)'
     `deg (' vector_expression `)'
     `deg (' poly_expression `,' intvec_expression `)'
     `deg (' vector_expression `,' intvec_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the maximal (weighted) degree of the terms of a polynomial
     or a vector;
     deg(0) is -1.
     The optional second argument gives the weight vector, the default
     weights of the base ring will be used otherwise.

`*Example:*'

            ring r=0,(x,y,z),lp;
            deg(0);
          ==> -1
            deg(x3+y4+xyz3);
          ==> 5
            ring rr=7,(x,y),wp(2,3);
            poly f=x2+y3;
            deg(f);
          ==> 9
            ring R=7,(x,y),ws(2,3);
            poly f=x2+y3;
            deg(f);
          ==> 9
            vector v=[x2,y];
            deg(v);
          ==> 4

* Menu:

See
* jet::
* ord::
* poly::
* vector::

See *note jet::; *note ord::; *note poly::; *note vector::.


File: singular.hlp,  Node: degree,  Next: delete,  Prev: deg,  Up: Functions

5.1.15 degree
-------------

`*Syntax:*'
     `degree (' ideal_expression `)'
     `degree (' module_expression `)'

`*Type:*'
     int

`*Purpose:*'
     computes the (weighted) degree of the projective variety,
     respectively sheaf over the projective variety, defined by the
     ideal, respectively module, generated by the leading monomials of
     the input.  This is equal to the (weighted) degree of the
     projective variety, respectively sheaf over the projective variety,
     defined by the ideal, respectively module, if the input is a
     standard basis with respect to a (weighted) degree ordering.

`*Example:*'

          ring r3=32003,(x,y,z,h),dp;
          int a,b,c,t=11,10,3,1;
          poly f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
            +x^(c-2)*y^c*(y2+t*x)^2;
          ideal i=jacob(f);
          i=homog(i,h);
          ideal i0=std(i);
          degree(i0);
          ==> 720 

* Menu:

See
* dim::
* ideal::
* mult::
* std::
* vdim::

See *note dim::; *note ideal::; *note mult::; *note std::; *note vdim::.


File: singular.hlp,  Node: delete,  Next: det,  Prev: degree,  Up: Functions

5.1.16 delete
-------------

`*Syntax:*'
     `delete (' list_expression`,' int_expression `)'

`*Type:*'
     list

`*Purpose:*'
     deletes the element with the given index from a list (the input is
     not changed).

`*Example:*'

            list l="a","b","c";
            list l1=delete(l,2);l1;
          ==> [1]:
          ==>    a
          ==> [2]:
          ==>    c
            l;
          ==> [1]:
          ==>    a
          ==> [2]:
          ==>    b
          ==> [3]:
          ==>    c

* Menu:

See
* insert::
* list::

See *note insert::; *note list::.


File: singular.hlp,  Node: det,  Next: diff,  Prev: delete,  Up: Functions

5.1.17 det
----------

`*Syntax:*'
     `det (' intmat_expression `)'
     `det (' matrix_expression `)'
     `det (' module_expression `)'

`*Type:*'
     int, resp. poly

`*Purpose:*'
     returns the determinant of a square matrix. A module is considered
     as a matrix. The applied algorithms depend on type of input.  If
     the input is a module or matrix with symbolic entries the Bareiss
     algorithm is used. In the other cases the chinese remainder
     algorithm is used. For large sparse problems the input as a module
     has advantages.

`*Example:*'

            ring r=7,(x,y),wp(2,3);
            matrix m[3][3]=1,2,3,4,5,6,7,8,x;
            det(m);
          ==> -3x-1

* Menu:

See
* intmat::
* matrix::
* minor::

See *note intmat::; *note matrix::; *note minor::.


File: singular.hlp,  Node: diff,  Next: dim,  Prev: det,  Up: Functions

5.1.18 diff
-----------

`*Syntax:*'
     `diff (' poly_expression`,' ring_variable `)'
     `diff (' vector_expression`,' ring_variable `)'
     `diff (' ideal_expression`,' ring_variable `)'
     `diff (' module_expression`,' ring_variable `)'
     `diff (' matrix_expression`,' ring_variable `)'

`*Type:*'
     the same as the type of the first argument

`*Syntax:*'
     `diff (' ideal_expression`,' ideal_expression `)'

`*Type:*'
     matrix

`*Purpose:*'
     computes the partial derivative of a polynomial object by a ring
     variable (first forms)
     respectively differentiates each polynomial (1..n) of the second
     ideal by the differential operator corresponding to each polynomial
     (1..m) in the first ideal, producing an m x n matrix.

`*Example:*'

            ring r=0,(x,y,z),dp;
            poly f=2x3y+3z5;
            diff(f,x);
          ==> 6x2y
            vector v=[f,y2+z];
            diff(v,z);
          ==> 15z4*gen(1)+gen(2)
            ideal j=x2-yz,xyz;
            ideal i=x2,x2+yz,xyz;
            // corresponds to differential operators
            // d2/dx2, d2/dx2+d2/dydz, d3/dxdydz:
            print(diff(i,j));
          ==> 2,0,
          ==> 1,x,
          ==> 0,1 

* Menu:

See
* contract::
* ideal::
* jacob::
* matrix::
* module::
* poly::
* var::
* vector::

See *note contract::; *note ideal::; *note jacob::; *note matrix::;
*note module::; *note poly::; *note var::; *note vector::.


File: singular.hlp,  Node: dim,  Next: division,  Prev: diff,  Up: Functions

5.1.19 dim
----------

`*Syntax:*'
     `dim (' ideal_expression `)'
     `dim (' module_expression `)'

`*Type:*'
     int

`*Purpose:*'
     computes the dimension of the ideal, resp. module, generated by the
     leading monomials of the given generators of the ideal, resp.
     module.  This is also the dimension of the ideal if it is
     represented by a standard basis.

`*Note:*'
     The dimension of an ideal I means the Krull dimension of the
     basering modulo I.
     The dimension of a module is the dimension of its annihilator
     ideal.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            ideal I=x2-y,x3;
            dim(std(I));
          ==> 1

* Menu:

See
* degree::
* ideal::
* mult::
* std::
* vdim::

See *note degree::; *note ideal::; *note mult::; *note std::; *note
vdim::.


File: singular.hlp,  Node: division,  Next: dump,  Prev: dim,  Up: Functions

5.1.20 division
---------------

`*Syntax:*'
     `division (' ideal_expression`,' ideal_expression `)'
     `division (' module_expression`,' module_expression `)'
     `division (' ideal_expression`,' ideal_expression`,' int_expression
     `)'
     `division (' module_expression`,' module_expression`,'
     int_expression `)'
     `division (' ideal_expression`,' ideal_expression`,'
     int_expression`,' intvec_expression `)'
     `division (' module_expression`,' module_expression`,'
     int_expression`,' intvec_expression `)'

`*Type:*'
     list

`*Purpose:*'
     `division' computes a division with remainder.  For two ideals
     resp. modules `M' (first argument) and `N' (second argument), it
     returns a list `T,R,U' where `T' is a matrix, `R' is an ideal resp.
     a module, and `U' is a diagonal matrix of units such that
     `matrix(M)*U=matrix(N)*T+matrix(R)' is a standard representation
     for the normal form `R' of `M' with respect to a standard basis of
     `N'.  `division' uses different algorithms depending on whether `N'
     is represented by a standard basis.  For a polynomial basering, the
     matrix `U' is the identity matrix.  A matrix `T' as above is also
     computed by `lift'.
     For additional arguments `n' (third argument) and `w' (fourth
     argument), `division' returns a list `T,R' as above such that
     `matrix(M)=matrix(N)*T+matrix(R)' is a standard representation for
     the normal form `R' of `M' with respect to `N' up to weighted
     degree `n' with respect to the weight vector `w'.  The weighted
     degree of `T' and `R' respect to `w' is at most `n'.  If the weight
     vector `w' is not given, `division' uses the standard weight vector
     `w=1,...,1'.

`*Example:*'

          ring R=0,(x,y),ds;
          poly f=x5+x2y2+y5;
          division(f,jacob(f));
          ==> [1]:
          ==>    _[1,1]=1/5x
          ==>    _[2,1]=3/10y
          ==> [2]:
          ==>    _[1]=-1/2y5
          ==> [3]:
          ==>    _[1,1]=1
          division(f^2,jacob(f));
          ==> [1]:
          ==>    _[1,1]=1/20x6-9/80xy5-5/16x7y+5/8x2y6
          ==>    _[2,1]=1/8x2y3+1/5x5y+1/20y6-3/4x3y4-5/4x6y2-5/16xy7
          ==> [2]:
          ==>    _[1]=0
          ==> [3]:
          ==>    _[1,1]=1/4-25/16xy
          division(ideal(f^2),jacob(f),10);
          ==> // ** _ is no standardbasis
          ==> [1]:
          ==>    _[1,1]=-75/8y9
          ==>    _[2,1]=1/2x2y3+x5y-1/4y6-3/2x3y4+15/4xy7+375/16x2y8
          ==> [2]:
          ==>    _[1]=x10+9/4y10

* Menu:

See
* ideal::
* lift::
* module::

See *note ideal::; *note lift::; *note module::.


File: singular.hlp,  Node: dump,  Next: eliminate,  Prev: division,  Up: Functions

5.1.21 dump
-----------

`*Syntax:*'
     `dump (' link_expression `)'

`*Type:*'
     none

`*Purpose:*'
     dumps (i.e., writes in one "message" or "block") the state of the
     SINGULAR session (i.e., all defined variables and their values) to
     the specified link (which must be either an ASCII or MP link) such
     that a `getdump' can retrieve it later on.

`*Example:*'

            ring r;
            // write the whole session to the file dump.ascii
            // in ASCII format
            dump(":w dump.ascii");
            kill r;                  // kill the basering
            // reread the session from the file
            // redefining everything which was not explicitly killed before
            getdump("dump.ascii");
          ==> // ** redefining stdfglm **
          ==> // ** redefining stdhilb **
          ==> // ** redefining groebner **
          ==> // ** redefining res **
          ==> // ** redefining quot **
          ==> // ** redefining quot1 **
          ==> // ** redefining quotient0 **
          ==> // ** redefining quotient1 **
          ==> // ** redefining quotient2 **
          ==> // ** redefining quotient3 **
          ==> // ** redefining quotient5 **
          ==> // ** redefining quotient4 **
          ==> // ** redefining intersect1 **
          ==> // ** redefining sprintf **
          ==> // ** redefining printf **
          ==> // ** redefining fprintf **
            r;
          ==> //   characteristic : 32003
          ==> //   number of vars : 3
          ==> //        block   1 : ordering dp
          ==> //                  : names    x y z 
          ==> //        block   2 : ordering C

`*Restrictions:*'
     For ASCII links, integer matrices contained in lists are  dumped as
     integer list elements (and not as integer matrices), and lists of
     lists are dumped as one flatted list. Furthermore, links themselves
     are not dumped.

* Menu:

See
* getdump::
* link::
* write::

See *note getdump::; *note link::; *note write::.


File: singular.hlp,  Node: eliminate,  Next: eval,  Prev: dump,  Up: Functions

5.1.22 eliminate
----------------

`*Syntax:*'
     `eliminate (' ideal_expression`,' product_of_ring_variables`)'
     `eliminate (' module_expression`,' product_of_ring_variables`)'
     `eliminate (' ideal_expression`,' product_of_ring_variables`,'
     intvec_hilb `)'
     `eliminate (' module_expression`,' product_of_ring_variables`,'
     intvec_hilb `)'

`*Type:*'
     the same as the type of the first argument

`*Purpose:*'
     eliminates variables occurring as factors of the second argument
     from an ideal, resp. module, by intersecting it with the subring
     not containing these variables.
     `eliminate' does not need a special ordering nor a standard basis
     as input.

`*Note:*'
     Since elimination is expensive, for homogeneous input it might be
     useful first to compute the Hilbert function of the ideal (first
     argument) with a fast ordering (e.g., `dp'). Then make use of it to
     speed up the computation: a Hilbert-driven elimination uses the
     intvec provided as the third argument.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            ideal i=x2,xy,y5;
            eliminate(i,x);
          ==> _[1]=y5
            ring R=0,(x,y,t,s,z),dp;
            ideal i=x-t,y-t2,z-t3,s-x+y3;
            eliminate(i,ts);
          ==> _[1]=y2-xz
          ==> _[2]=xy-z
          ==> _[3]=x2-y
            intvec v=hilb(std(i),1);
            eliminate(i,ts,v);
          ==> _[1]=y2-xz
          ==> _[2]=xy-z
          ==> _[3]=x2-y

* Menu:

See
* hilb::
* ideal::
* module::
* std::

See *note hilb::; *note ideal::; *note module::; *note std::.


File: singular.hlp,  Node: eval,  Next: ERROR,  Prev: eliminate,  Up: Functions

5.1.23 eval
-----------

`*Syntax:*'
     `eval (' expression `)'

`*Type:*'
     none

`*Purpose:*'
     evaluates (quoted) expressions. Within a quoted expression, the
     quote can be "undone" by an `eval' (i.e., each eval "undoes" the
     effect of exactly one quote). Used only when receiving a quoted
     expression from an MPfile link, with `quote' and `write' to prevent
     local evaluations  when writing to an MPtcp link.

`*Example:*'

            link l="MPfile:w example.mp";
            ring r=0,(x,y,z),ds;
            ideal i=maxideal(3);
            ideal j=x7,x2,z;
            // compute i+j before writing, but not std
            // this writes 'std(ideal(x3,...,z))'
            write (l, quote(std(eval(i+j))));
            option(prot);
            close(l);
            // now read it in again and evaluate
            // read(l) forces to compute 'std(ideal(x3,...,z))'
            read(l);
            close(l);

* Menu:

See
* MPfile links::
* quote::
* write::

See *note MPfile links::; *note quote::; *note write::.


File: singular.hlp,  Node: ERROR,  Next: example,  Prev: eval,  Up: Functions

5.1.24 ERROR
------------

`*Syntax:*'
     `ERROR (' string_expression `)'

`*Type:*'
     none

`*Purpose:*'
     Immediately interrupts the current computation, returns to the
     top-level, and displays the argument `string_expression' as error
     message.

`*Note:*'
     This should be used as an emergency, resp. failure, exit within
     procedures.

`*Example:*'

          int i=1;
          proc myError() {ERROR("Need to leave now");i=2;}
          myError();
          ==>    ? Need to leave now
          ==>    ? error occurred in line 2: `ERROR("Need to leave now");i=2;`
          ==>    ? leaving ::myError
          ==>    skipping text from `;` error at token `)`
          i;
          ==> 1


File: singular.hlp,  Node: example,  Next: execute,  Prev: ERROR,  Up: Functions

5.1.25 example
--------------

`*Syntax:*'
     `example' topic `;'

`*Purpose:*'
     computes an example for `topic'. Examples are available for all
     SINGULAR kernel and library functions. Where available (e.g.,
     within Emacs), use `<TAB>' completion for a list of all available
     example `topic's.

`*Example:*'

          example prime;
          example intvec_declarations;

* Menu:

See also:
* help::

*See also:* *note help::.


File: singular.hlp,  Node: execute,  Next: exit,  Prev: example,  Up: Functions

5.1.26 execute
--------------

`*Syntax:*'
     `execute (' string_expression `)'

`*Type:*'
     none

`*Purpose:*'
     executes a string containing a sequence of SINGULAR commands.

`*Note:*'
     The command `return' cannot appear in the string.
     `execute' should be avoided in procedures whenever possible, since
     it may give rise to name conflicts.  Moreover, such procedures
     cannot be precompiled (a feature which SINGULAR will provide in the
     future).

`*Example:*'

            ring r=32003,(x,y,z),dp;
            ideal i=x+y,z3+22y;
            write(":w save_i",i);
            ring r0=0,(x,y,z),Dp;
            string s="ideal k="+read("save_i")+";";
            s;
          ==> ideal k=x+y,z3+22y
          ==> ;
            execute(s); // define the ideal k
            k;
          ==> k[1]=x+y
          ==> k[2]=z3+22y


File: singular.hlp,  Node: exit,  Next: extgcd,  Prev: execute,  Up: Functions

5.1.27 exit
-----------

`*Syntax:*'
     `exit;'

`*Purpose:*'
     exits (quits) SINGULAR, works also from inside a procedure or from
     an interrupt.


File: singular.hlp,  Node: extgcd,  Next: facstd,  Prev: exit,  Up: Functions

5.1.28 extgcd
-------------

`*Syntax:*'
     `extgcd (' int_expression`,' int_expression `)'
     `extgcd (' poly_expression`,' poly_expression `)'

`*Type:*'
     list of 3 objects of the same type as the type of the arguments

`*Purpose:*'
     computes extended gcd: the first element is the greatest common
     divisor of the two arguments, the second and third are factors such
     that if `list L=extgcd(a,b);' then L[1]=a*L[2]+b*L[3].

`*Note:*'
     Polynomials must be univariate to apply `extgcd'.

`*Example:*'

            extgcd(24,10);
          ==> [1]:
          ==>    2
          ==> [2]:
          ==>    -2
          ==> [3]:
          ==>    5
            ring r=0,(x,y),lp;
            extgcd(x4-x6,(x2+x5)*(x2+x3));
          ==> [1]:
          ==>    2x5+2x4
          ==> [2]:
          ==>    x2+x+1
          ==> [3]:
          ==>    1

* Menu:

See
* gcd::
* int::
* poly::

See *note gcd::; *note int::; *note poly::.


File: singular.hlp,  Node: facstd,  Next: factorize,  Prev: extgcd,  Up: Functions

5.1.29 facstd
-------------

`*Syntax:*'
     `facstd (' ideal_expression `)'
     `facstd (' ideal_expression`,' ideal_expression `)'

`*Type:*'
     list of ideals

`*Purpose:*'
     returns a list of ideals computed by the factorizing Groebner basis
     algorithm.
     The intersection of these ideals has the same zero-set as the
     input, i.e., the radical of the intersection coincides with the
     radical of the input ideal.  In many (but not all!) cases this is
     already a decomposition of the radical of the ideal. (Note however,
     that, in general, no inclusion between the input and output ideals
     holds.)
     The second, optional argument gives a list of polynomials which
     define non-zero constraints. Hence, the intersection of the output
     ideals has a zero-set which is the (closure of the) complement of
     the zero-set of the second argument in the zero-set of the first
     argument.

`*Note:*'
     Not implemented for baserings over real ground fields, galois
     fields and over algebraic extensions over the rational numbers
     (that is, only implemented for ground fields for which *note
     factorize:: is implemented).

`*Example:*'

            ring r=32003,(x,y,z),(c,dp);
            ideal I=xyz,x2z;
            facstd(I);
          ==> [1]:
          ==>    _[1]=z
          ==> [2]:
          ==>    _[1]=x
            facstd(I,x);
          ==> [1]:
          ==>    _[1]=z

* Menu:

See
* ideal::
* ring::
* std::

See *note ideal::; *note ring::; *note std::.


File: singular.hlp,  Node: factorize,  Next: fetch,  Prev: facstd,  Up: Functions

5.1.30 factorize
----------------

`*Syntax:*'
     `factorize (' poly_expression `)'
     `factorize (' poly_expression`, 0 )'
     `factorize (' poly_expression`, 2 )'

`*Type:*'
     list of ideal and intvec

`*Syntax:*'
     `factorize (' poly_expression`, 1 )'

`*Type:*'
     ideal

`*Purpose:*'
     computes the irreducible factors (as an ideal) of the polynomial
     together with or without the multiplicities (as an intvec)
     depending on the second argument:

         0: returns factors and multiplicities, first factor is a constant.
            May also be written with only one argument.
         1: returns non-constant factors (no multiplicities).
         2: returns non-constant factors and multiplicities.

`*Note:*'
     Not implemented for the coefficient fields real and finite fields
     of type `(p^n,a)'.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            factorize(9*(x-1)^2*(y+z));
          ==> [1]:
          ==>    _[1]=9
          ==>    _[2]=y+z
          ==>    _[3]=x-1
          ==> [2]:
          ==>    1,1,2
            factorize(9*(x-1)^2*(y+z),1);
          ==> _[1]=y+z
          ==> _[2]=x-1
            factorize(9*(x-1)^2*(y+z),2);
          ==> [1]:
          ==>    _[1]=y+z
          ==>    _[2]=x-1
          ==> [2]:
          ==>    1,2

* Menu:

See
* poly::

See *note poly::.


File: singular.hlp,  Node: fetch,  Next: fglm,  Prev: factorize,  Up: Functions

5.1.31 fetch
------------

`*Syntax:*'
     `fetch (' ring_name`,' name `)'

`*Type:*'
     number, poly, vector, ideal, module, matrix or list (the same type
     as the second argument)

`*Purpose:*'
     maps objects between rings.  `fetch' is the identity map between
     rings and qrings, the i-th variable of the source ring is mapped to
     the i-th variable of the basering.  The coefficient fields must be
     compatible.  (See *note map:: for a description of possible mapping
     between different ground fields).
     `fetch' offers a convenient way to change variable names or
     orderings, or to map objects from a ring to a quotient ring of that
     ring or vice versa.

`*Note:*'
     Compared with `imap', `fetch' uses the position of the ring
     variables, not their names.

`*Example:*'

            ring r=0,(x,y,z),dp;
            ideal i=maxideal(2);
            ideal j=std(i);
            poly f=x+y2+z3;
            vector v=[f,1];
            qring q=j;
            poly f=fetch(r,f);
            f;
          ==> z3+y2+x
            vector v=fetch(r,v);
            v;
          ==> z3*gen(1)+y2*gen(1)+x*gen(1)+gen(2)
            ideal i=fetch(r,i);
            i;
          ==> i[1]=z2
          ==> i[2]=yz
          ==> i[3]=y2
          ==> i[4]=xz
          ==> i[5]=xy
          ==> i[6]=x2
            ring rr=0,(a,b,c),lp;
            poly f=fetch(q,f);
            f;
          ==> a+b2+c3
            vector v=fetch(r,v);
            v;
          ==> a*gen(1)+b2*gen(1)+c3*gen(1)+gen(2)
            ideal k=fetch(q,i);
            k;
          ==> k[1]=c2
          ==> k[2]=bc
          ==> k[3]=b2
          ==> k[4]=ac
          ==> k[5]=ab
          ==> k[6]=a2

* Menu:

See
* imap::
* map::
* qring::
* ring::

See *note imap::; *note map::; *note qring::; *note ring::.


File: singular.hlp,  Node: fglm,  Next: fglmquot,  Prev: fetch,  Up: Functions

5.1.32 fglm
-----------

`*Syntax:*'
     `fglm (' ring_name`,' ideal_name `)'

`*Type:*'
     ideal

`*Purpose:*'
     computes for the given ideal in the given ring a reduced Groebner
     basis in the current ring, by applying the so-called FGLM (Faugere,
     Gianni, Lazard, Mora)  algorithm.
     The main application is to compute a lexicographical Groebner basis
     from a reduced Groebner basis with respect to a degree ordering.
     This can be much faster than computing a lexicographical Groebner
     basis directly.

`*Note:*'
     The ideal must be zero-dimensional and given as a reduced Groebner
     basis in the given ring.
     The only permissible differences between the given ring and the
     current ring are the monomial ordering and a permutation of the
     variables, resp. parameters.

`*Example:*'

            ring r=0,(x,y,z),dp;
            ideal i=y3+x2, x2y+x2, x3-x2, z4-x2-y;
            option(redSB);   // force the computation of a reduced SB
            i=std(i);
            vdim(i);
          ==> 28
            ring s=0,(z,x,y),lp;
            ideal j=fglm(r,i);
            j;
          ==> j[1]=y4+y3
          ==> j[2]=xy3-y3
          ==> j[3]=x2+y3
          ==> j[4]=z4+y3-y

* Menu:

See
* fglmquot::
* option::
* qring::
* ring::
* std::
* stdfglm::
* vdim::

See *note fglmquot::; *note option::; *note qring::; *note ring::; *note
std::; *note stdfglm::; *note vdim::.


File: singular.hlp,  Node: fglmquot,  Next: filecmd,  Prev: fglm,  Up: Functions

5.1.33 fglmquot
---------------

`*Syntax:*'
     `fglmquot (' ideal_expression`,' poly_expression `)'

`*Type:*'
     ideal

`*Purpose:*'
     computes a reduced Groebner basis of the ideal quotient `I:p' of a
     zero-dimensional ideal `I' and a polynomial `p' using
     FGLM-techniques.

`*Note:*'
     The ideal must be zero-dimensional and given as a reduced Groebner
     basis in the given ring. The poly must be reduced with respect to
     the ideal.

`*Example:*'

            ring r=0,(x,y,z),lp;
            ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
            option(redSB);   // force the computation of a reduced SB
            i=std(i);
            poly p=reduce(x+yz2+z10,i);
            ideal j=fglmquot(i,p);
            j;
          ==> j[1]=z12
          ==> j[2]=yz4-z8
          ==> j[3]=y2+y-z8-z4
          ==> j[4]=x+y-z10-z6-z4

* Menu:

See
* fglm::
* option::
* quotient::
* ring::
* std::
* vdim::

See *note fglm::; *note option::; *note quotient::; *note ring::; *note
std::; *note vdim::.


File: singular.hlp,  Node: filecmd,  Next: find,  Prev: fglmquot,  Up: Functions

5.1.34 files, input from
------------------------

`*Syntax:*'
     `< "'filename`"'

`*Type:*'
     none

`*Purpose:*'
     input comes from the file filename. Shorthand for
     `execute(read(filename))'.

`*Example:*'

          < "example"; //read in the file example and execute it

* Menu:

See
* execute::
* read::

See *note execute::; *note read::.


File: singular.hlp,  Node: find,  Next: finduni,  Prev: filecmd,  Up: Functions

5.1.35 find
-----------

`*Syntax:*'
     `find (' string_expression`,' substring_expression `)'
     `find (' string_expression`,' substring_expression`,'
     int_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the first position of the substring in the string or 0 (if
     not found),
     starts the search at the position given in the 3rd argument.

`*Example:*'

            find("Aac","a");
          ==> 2
            find("abab","a"+"b");
          ==> 1
            find("abab","a"+"b",2);
          ==> 3
            find("abab","ab",3);
          ==> 3
            find("0123","abcd");
          ==> 0

* Menu:

See
* string::

See *note string::.


File: singular.hlp,  Node: finduni,  Next: fprintf,  Prev: find,  Up: Functions

5.1.36 finduni
--------------

`*Syntax:*'
     `finduni (' ideal_expression `)'

`*Type:*'
     ideal

`*Purpose:*'
     returns an ideal which is contained in the ideal_expression such
     that the i-th generator is a univariate polynomial in the i-th ring
     variable.
     The polynomials have minimal degree w.r.t. this property.

`*Note:*'
     The ideal must be zero-dimensional and given as a reduced Groebner
     basis in the current ring.

`*Example:*'

            ring  r=0,(x,y,z), dp;
            ideal i=y3+x2,x2y+x2,z4-x2-y;
            option(redSB);  // force computation of reduced basis
            i=std(i);
            ideal k=finduni(i);
            print(k);
          ==> x4-x2,
          ==> y4+y3,
          ==> z12

* Menu:

See
* option::
* ring::
* std::
* vdim::

See *note option::; *note ring::; *note std::; *note vdim::.


File: singular.hlp,  Node: fprintf,  Next: freemodule,  Prev: finduni,  Up: Functions

5.1.37 fprintf
--------------

Procedure from library `standard.lib' (*note standard_lib::).

*Syntax:*
     `fprintf (' link_expression`,' string_expression `[,'
     any_expressions`] )'

*Return:*
     none

*Purpose:*
     `fprintf(l,fmt,...);' performs output formatting.  The second
     argument is a format control string. Additional arguments may be
     required, depending on the content of the control string. A series
     of output characters is generated as directed by the control
     string; these characters are written to the link l.  The control
     string `fmt' is simply text to be copied, except that the string
     may contain conversion specifications.
     Do `help print;' for a listing of valid conversion specifications.
     As an addition to the conversions of `print', the `%n' and `%2'
     conversion specification does not consume an additional argument,
     but simply generates a newline character.

*Note:*
     If one of the additional arguments is a list, then it should be
     enclosed once more into a `list()' command, since passing a list as
     an argument flattens the list by one level.

*Example:*
       ring r=0,(x,y,z),dp;
     module m=[1,y],[0,x+z];
     intmat M=betti(mres(m,0));
     list l=r,m,M;
     link li="";   // link to stdout
     fprintf(li,"s:%s,l:%l",1,2);
     ==> s:1,l:int(2)
     fprintf(li,"s:%s",l);
     ==> s:(0),(x,y,z),(dp(3),C)
     fprintf(li,"s:%s",list(l));
     ==> s:(0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
     fprintf(li,"2l:%2l",list(l));
     ==> 2l:list("(0),(x,y,z),(dp(3),C)",
     ==> module(y*gen(2)+gen(1),
     ==> x*gen(2)+z*gen(2)),
     ==> intmat(intvec(1,1 ),1,2))
     ==> 
     fprintf(li,"%p",list(l));
     ==> [1]:
     ==>    //   characteristic : 0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y z 
     ==> //        block   2 : ordering C
     ==> [2]:
     ==>    _[1]=y*gen(2)+gen(1)
     ==>    _[2]=x*gen(2)+z*gen(2)
     ==> [3]:
     ==>    1,1 
     ==> 
     fprintf(li,"%;",list(l));
     ==> [1]:
     ==>    //   characteristic : 0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y z 
     ==> //        block   2 : ordering C
     ==> [2]:
     ==>    _[1]=y*gen(2)+gen(1)
     ==>    _[2]=x*gen(2)+z*gen(2)
     ==> [3]:
     ==>    1,1 
     ==> 
     fprintf(li,"%b",M);
     ==>            0     1
     ==> ------------------
     ==>     0:     1     1
     ==> ------------------
     ==> total:     1     1
     ==> 

* Menu:

See also:
* print::
* printf::
* sprintf::
* string::

*See also:* *note print::; *note printf::; *note sprintf::; *note
string::.


File: singular.hlp,  Node: freemodule,  Next: gcd,  Prev: fprintf,  Up: Functions

5.1.38 freemodule
-----------------

`*Syntax:*'
     `freemodule (' int_expression `)'

`*Type:*'
     module

`*Purpose:*'
     creates the free module of rank n generated by `gen(1)', ...,
     `gen(n)'.

`*Example:*'

            ring r=32003,(x,y),(c,dp);
            freemodule(3);
          ==> _[1]=[1]
          ==> _[2]=[0,1]
          ==> _[3]=[0,0,1]
            matrix m=freemodule(3); // generates the 3x3 unit matrix
            print(m);
          ==> 1,0,0,
          ==> 0,1,0,
          ==> 0,0,1 

* Menu:

See
* gen::
* module::

See *note gen::; *note module::.


File: singular.hlp,  Node: gcd,  Next: gen,  Prev: freemodule,  Up: Functions

5.1.39 gcd
----------

`*Syntax:*'
     `gcd (' int_expression`,' int_expression `)'
     `gcd (' number_expression`,' number_expression `)'
     `gcd (' poly_expression`,' poly_expression `)'

`*Type:*'
     the same as the type of the arguments

`*Purpose:*'
     computes the greatest common divisor.

`*Note:*'
     Not implemented for the coefficient fields real and finite fields
     of type `(p^n,a)'.
     The gcd of two numbers is their gcd as integer numbers or
     polynomials, otherwise it is not defined.

`*Example:*'

            gcd(2,3);
          ==> 1
            ring r=0,(x,y,z),lp;
            gcd(3x2*(x+y),9x*(y2-x2));
          ==> x2+xy
            gcd(number(6472674604870),number(878646537247372));
          ==> 2

* Menu:

See
* extgcd::
* int::
* number::
* poly::

See *note extgcd::; *note int::; *note number::; *note poly::.


File: singular.hlp,  Node: gen,  Next: getdump,  Prev: gcd,  Up: Functions

5.1.40 gen
----------

`*Syntax:*'
     `gen (' int_expression `)'

`*Type:*'
     vector

`*Purpose:*'
     returns the i-th free generator of a free module.

`*Example:*'

            ring r=32003,(x,y,z),(c,dp);
            gen(3);
          ==> [0,0,1]
            vector v=gen(5);
            poly f=xyz;
            v=v+f*gen(4); v;
          ==> [0,0,0,xyz,1]
            ring rr=32003,(x,y,z),dp;
            fetch(r,v);
          ==> xyz*gen(4)+gen(5)

* Menu:

See
* freemodule::
* int::
* vector::

See *note freemodule::; *note int::; *note vector::.


File: singular.hlp,  Node: getdump,  Next: groebner,  Prev: gen,  Up: Functions

5.1.41 getdump
--------------

`*Syntax:*'
     `getdump (' link_expression `)'

`*Type:*'
     none

`*Purpose:*'
     reads the content of the entire file, resp. link, and restores all
     variables from it. For ASCII links, `getdump' is equivalent to an
     `execute(read(' link `))' command. For MP links, `getdump' should
     only be used on data which were previously `dump''ed.

`*Example:*'

            int i=3;
            dump(":w example.txt");
            kill i;
            option(noredefine);
            getdump("example.txt");
            i;
          ==> 3

`*Restrictions:*'
     `getdump' is not supported for DBM links, or for a link connecting
     to `stdin' (standard input).

* Menu:

See
* dump::
* link::
* read::

See *note dump::; *note link::; *note read::.


File: singular.hlp,  Node: groebner,  Next: help,  Prev: getdump,  Up: Functions

5.1.42 groebner
---------------

Procedure from library `standard.lib' (*note standard_lib::).

*Syntax:*
     `groebner (' ideal_expression `)'
     `groebner (' module_expression `)'
     `groebner (' ideal_expression`,' int_expression `)'
     `groebner (' module_expression`,' int_expression `)'

*Type:*
     type of the first argument

*Purpose:*
     computes the standard basis of the first argument `I' (ideal or
     module), by a heuristically chosen method: if the ordering of the
     current ring is a local ordering, or if it is a non-block ordering
     and the current ring has no parameters, then `std(I)' is returned.
     Otherwise, `I' is mapped into a ring with no parameters and
     ordering dp, where its Hilbert series is computed. This is followed
     by a Hilbert-series based std computation in the original ring.

*Note:*
     If a 2nd argument `wait' is given, then the computation proceeds at
     most `wait' seconds. That is, if no result could be computed in
     `wait' seconds, then the computation is interrupted, 0 is returned,
     a warning message is displayed, and the global variable
     `groebner_error' is defined.

*Example:*
       ring r=0,(a,b,c,d),lp;
     option(prot);
     ideal i=a+b+c+d,ab+ad+bc+cd,abc+abd+acd+bcd,abcd-1; // cyclic 4
     groebner(i);
     ==> std in (0),(a,b,c,d,@t),(dp,C)
     ==> [63:1]1(3)s2(2)s3s4-s5ss6-s7--
     ==> product criterion:8 chain criterion:5
     ==> std with hilb in  (0),(a,b,c,d,@t),(lp(4),C)
     ==> [63:1]1(3)s2(2)s3s4-s5ss6shhhh8shh
     ==> product criterion:9 chain criterion:8
     ==> hilbert series criterion:6
     ==> dehomogenization
     ==> imap to original ring
     ==> simplification
     ==> _[1]=c2d6-c2d2-d4+1
     ==> _[2]=c3d2+c2d3-c-d
     ==> _[3]=bd4-b+d5-d
     ==> _[4]=bc-bd5+c2d4+cd-d6-d2
     ==> _[5]=b2+2bd+d2
     ==> _[6]=a+b+c+d
     ring rp=(0,a,b),(c,d), lp;
     ideal i=imap(r,i);
     ideal j=groebner(i);
     ==> std in 0,(c,d,a,b,@t),(dp,C)
     ==> [63:1]1(3)s2(2)s3s4-s5ss6-s7--
     ==> product criterion:8 chain criterion:5
     ==> std with hilb in  (0),(c,d,a,b,@t),(lp(2),C, dp(3))
     ==> [63:3]1(3)s2(2)s3s4-s5ss6shhhh8shh
     ==> product criterion:9 chain criterion:8
     ==> hilbert series criterion:6
     ==> dehomogenization
     ==> imap to original ring
     ==> simplification
     option(noprot);
     j; simplify(j,1); std(i);
     ==> j[1]=(a3b2+a2b3-a-b)
     ==> _[1]=1
     ==> _[1]=1
     if (system("with","MP")) {groebner(i,0);}
     ==> // ** groebner did not finish
     ==> _[1]=0
     defined(groebner_error);
     ==> 1

* Menu:

See also:
* std::
* stdfglm::
* stdhilb::

*See also:* *note std::; *note stdfglm::; *note stdhilb::.


File: singular.hlp,  Node: help,  Next: highcorner,  Prev: groebner,  Up: Functions

5.1.43 help
-----------

`*Syntax:*'
     `help;'
     `help' topic `;'

`*Type:*'
     none

`*Purpose:*'
     displays online help information for `topic' using the currently
     set help browser. If no `topic' is given, the title page of the
     manual is displayed.

`*Note:*'

        * `?' may be used instead of `help'.

        * `topic' can be an index entry of the SINGULAR manual or the
          name of a (loaded) procedure which has a help section.

        * `topic' may contain wildcard characters (i.e., `*'
          characters).

        * If a (possibly "wildcarded") `topic' cannot be found (or
          uniquely matched) a warning is displayed and no help
          information is provided.

        * If `topic' is the name of a (loaded) procedure whose help
          section has changed w.r.t. the help available in the manual
          then, instead of displaying the respective help section of the
          manual in the help browser, the "newer" help section of the
          procedure is simply printed to the terminal.

        * The browser in which the help information is displayed can be
          either set with the command-line option `--browser=<browser>'
          (*note Command line options::), or with the command
          `system("--browser", "<browser>")'. Use the command
          `system("browsers");' for a list of all available browsers.
          *Note The online help system::, for more details about help
          browsers.

`*Example:*'

          help;      // display title page of manual
          help ring; // display help for 'ring'
          ?ringe;    // equivalent to 'help ringe;'
          ==> // ** No help for topic 'ringe' (not even for '*ringe*')
          ==> // ** Try '?;'       for general help
          ==> // ** or  '?Index;'  for all available help topics
          ?ring*;
          ==> //  ** No unique help for 'ring*'
          ==> //  ** Try one of
          ==> ?Rings and orderings; ?Rings and standard bases; ?ring;
          ==> ?ring declarations; ?ring operations; ?ring related functions;
          ==> ?ring.lib; ?ring_lib; ?ringtensor; ?ringweights;
          help Rings and orderings;
          help standard.lib;  // displays help for library 'standard.lib'

* Menu:

See
* Command line options::
* Format of a library::
* Procedure definition::
* The online help system::
* system::

See *note Command line options::; *note Format of a library::; *note
Procedure definition::; *note The online help system::; *note system::.


File: singular.hlp,  Node: highcorner,  Next: hilb,  Prev: help,  Up: Functions

5.1.44 highcorner
-----------------

`*Syntax:*'
     `highcorner (' ideal_expression `)'
     `highcorner (' module_expression `)'

`*Type:*'
     poly, resp. vector

`*Purpose:*'
     returns the smallest monomial not contained in the ideal, resp.
     module, generated by the initial terms of the given generators. If
     the generators are a standard basis, this is also the smallest
     monomial not contained in the ideal, resp. module.
     If the ideal, resp. module, is not zero-dimensional, 0 is returned.

`*Note:*'
     Let the ideal I be given by a standard basis. Then `highcorner(I)'
     returns 0 iff `dim(I)>0' or `dim(I)=-1'.  Otherwise it returns the
     smallest monomial m not in I which has the following properties
     (with x(i) $x_i$
     the variables of the basering):

        * if x(i)>1 then x(i) $x_i>1$ then $x_i$
          does not divide m (e.g., m=1 if the ordering is global)

        * given any set of generators f_1,...f_k of I, let f_i' be
          obtained from f_i by deleting the terms divisible by x(i)*m
          for all i with x(i)<1.  Then f_1',...,f_k' generate I.  $f_1,\dots,f_k$ of I, let $f'_i$ be obtained from
          $f_i$ by deleting the terms divisible by $x_i\cdot m$ for all i with $x_i<1$.
          Then $f'_1,\dots,f'_k$ generate I.

`*Example:*'

          ring r=0,(x,y),ds;
          ideal i=x3,x2y,y3;
          highcorner(std(i));
          ==> xy2
          highcorner(std(ideal(1)));
          ==> 0

* Menu:

See
* dim::
* std::
* vdim::

See *note dim::; *note std::; *note vdim::.


File: singular.hlp,  Node: hilb,  Next: homog,  Prev: highcorner,  Up: Functions

5.1.45 hilb
-----------

`*Syntax:*'
     `hilb (' ideal_expression `)'
     `hilb (' module_expression `)'
     `hilb (' ideal_expression`,' int_expression `)'
     `hilb (' module_expression`,' int_expression `)'
     `hilb (' ideal_expression`,' int_expression `,' intvec_expression
     `)'
     `hilb (' module_expression`,' int_expression `,' intvec_expression
     `)'

`*Type:*'
     none (if called with one argument)
     intvec (if called with two or three arguments)

`*Purpose:*'
     computes the (weighted) Hilbert series of the ideal, resp. module,
     defined by the leading terms of the generators of the given ideal,
     resp. module.
     If `hilb' is called with one argument, then the 1st and 2nd Hilbert
     series together with some additional information are displayed.
     If `hilb' is called with two arguments, then the n-th Hilbert
     series is returned as an intvec, where n=1,2 is the second
argument.
     If a weight vector w is a given as 3rd argument, then the Hilbert
     series is computed w.r.t. these weights w (by default all weights
     are set to 1).

`*Caution:*'
     The last entry of the returned intvec is not part of the actual
     Hilbert series, but is used in the Hilbert driven standard basis
     computation (see *note stdhilb::).

`*Note:*'
     If the input is homogeneous w.r.t. the weights and a standard
     basis, the result is the (weighted) Hilbert series of the original
     ideal, resp. module.

`*Example:*'

            ring R=32003,(x,y,z),dp;
            ideal i=x2,y2,z2;
            ideal s=std(i);
            hilb(s);
          ==> //         1 t^0
          ==> //        -3 t^2
          ==> //         3 t^4
          ==> //        -1 t^6
          ==> 
          ==> //         1 t^0
          ==> //         3 t^1
          ==> //         3 t^2
          ==> //         1 t^3
          ==> // dimension (affine)  = 0
          ==> // degree      = 8
            hilb(s,1);
          ==> 1,0,-3,0,3,0,-1,0
            hilb(s,2);
          ==> 1,3,3,1,0
            intvec w=2,2,2;
            hilb(s,1,w);
          ==> 1,0,0,0,-3,0,0,0,3,0,0,0,-1,0

* Menu:

See
* Hilbert function::
* ideal::
* intvec::
* module::
* std::
* stdhilb::

See *note Hilbert function::; *note ideal::; *note intvec::; *note
module::; *note std::; *note stdhilb::.


File: singular.hlp,  Node: homog,  Next: hres,  Prev: hilb,  Up: Functions

5.1.46 homog
------------

`*Syntax:*'
     `homog (' ideal_expression `)'
     `homog (' module_expression `)'

`*Type:*'
     int

`*Purpose:*'
     tests for homogeneity: returns 1 for homogeneous input, 0
     otherwise.

`*Syntax:*'

     `homog (' polynomial_expression`,' ring_variable `)'
     `homog (' vector_expression`,' ring_variable `)'
     `homog (' ideal_expression`,' ring_variable `)'
     `homog (' module_expression`,' ring_variable `)'

`*Type:*'
     same as first argument

`*Purpose:*'
     homogenizes polynomials, vectors, ideals, or modules by multiplying
     each monomial with a suitable power of the given ring variable
     (which must have weight 1).

`*Example:*'

            ring r=32003,(x,y,z),ds;
            poly s1=x3y2+x5y+3y9;
            poly s2=x2y2z2+3z8;
            poly s3=5x4y2+4xy5+2x2y2z3+y7+11x10;
            ideal i=s1,s2,s3;
            homog(s2,z);
          ==> x2y2z4+3z8
            homog(i,z);
          ==> _[1]=3y9+x5yz3+x3y2z4
          ==> _[2]=x2y2z4+3z8
          ==> _[3]=11x10+y7z3+5x4y2z4+4xy5z4+2x2y2z6
            homog(i);
          ==> 0
            homog(homog(i,z));
          ==> 1

* Menu:

See
* ideal::
* module::
* poly::
* vector::

See *note ideal::; *note module::; *note poly::; *note vector::.


File: singular.hlp,  Node: hres,  Next: imap,  Prev: homog,  Up: Functions

5.1.47 hres
-----------

`*Syntax:*'
     `hres (' ideal_expression`,' int_expression `)'

`*Type:*'
     resolution

`*Purpose:*'
     computes a free resolution of an ideal using the Hilbert-driven
     algorithm.

     More precisely, let R be the basering and I be the given ideal.
     Then `hres' computes a minimal free resolution of R/I

                         A2       A1
           ... ---> F2 ---> F1 ---> R -> R/I -> 0.

$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
     \buildrel{A_1}\over{\longrightarrow} R\longrightarrow R/I
     \longrightarrow 0.$$
     If the int_expression k is not zero then the computation stops
     after k steps and returns a list of modules $M_i={\tt module} (A_i)$, i=1..k.
     Mi=module(Ai), i=1...k.

     `list L=hres(I,0);' returns a list L of n modules (where n is the
     number of variables of the basering) such that ${\tt L[i]}=M_i$
     L[i]=M_i in the above notation.

`*Note:*'
     The ideal_expression has to be homogeneous.
     Accessing single elements of a resolution may require that some
     partial computations have to be finished and may therefore take
     some time.

`*Example:*'

            ring r=0,(x,y,z),dp;
            ideal I=xz,yz,x3-y3;
            def L=hres(I,0);
            print(betti(L),"betti");
          ==>            0     1     2
          ==> ------------------------
          ==>     0:     1     -     -
          ==>     1:     -     2     1
          ==>     2:     -     1     1
          ==> ------------------------
          ==> total:     1     3     2
            L[2];     // the first syzygy module of r/I
          ==> _[1]=-x*gen(1)+y*gen(2)
          ==> _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)

* Menu:

See
* betti::
* ideal::
* int::
* lres::
* minres::
* module::
* mres::
* res::
* sres::

See *note betti::; *note ideal::; *note int::; *note lres::; *note
minres::; *note module::; *note mres::; *note res::; *note sres::.


File: singular.hlp,  Node: imap,  Next: impart,  Prev: hres,  Up: Functions

5.1.48 imap
-----------

`*Syntax:*'
     `imap (' ring_name`,' name `)'

`*Type:*'
     number, poly, vector, ideal, module, matrix or list (the same type
     as the second argument)

`*Purpose:*'
     identity map on common subrings.  `imap' is the map between rings
     and qrings with compatible ground fields which is the identity on
     variables and parameters of the same name and 0 otherwise.  (See
     *note map:: for a description of possible mapping between different
     ground fields).  Useful for mapping from a homogenized ring to the
     original ring or for mappings from/to rings with/without
     parameters. Compared with `fetch', `imap' uses the names of
     variables and parameters.  Unlike `map' and `fetch' `imap' can map
     parameters to variables.

`*Example:*'

            ring r=0,(x,y,z,a,b,c),dp;
            ideal i=xy2z3a4b5+1,homog(xy2z3a4b5+1,c); i;
          ==> i[1]=xy2z3a4b5+1
          ==> i[2]=xy2z3a4b5+c15
            ring r1=0,(a,b,x,y,z),lp;
            ideal j=imap(r,i); j;
          ==> j[1]=a4b5xy2z3+1
          ==> j[2]=a4b5xy2z3
            ring r2=(0,a,b),(x,y,z),ls;
            ideal j=imap(r,i); j;
          ==> j[1]=1+(a4b5)*xy2z3
          ==> j[2]=(a4b5)*xy2z3

* Menu:

See
* fetch::
* homog::
* map::
* qring::
* ring::

See *note fetch::; *note homog::; *note map::; *note qring::; *note
ring::.


File: singular.hlp,  Node: impart,  Next: indepSet,  Prev: imap,  Up: Functions

5.1.49 impart
-------------

`*Syntax:*'
     `impart (' number_expression `)'

`*Type:*'
     number

`*Purpose:*'
     returns the imaginary part of a number in a complex ground field,
     returns 0 otherwise.

`*Example:*'

            ring r=(complex,i),x,dp;
            impart(1+2*i);
          ==> 2

* Menu:

See
* repart::

See *note repart::.


File: singular.hlp,  Node: indepSet,  Next: insert,  Prev: impart,  Up: Functions

5.1.50 indepSet
---------------

`*Syntax:*'
     `indepSet (' ideal_expression `)'

`*Type:*'
     intvec

`*Purpose:*'
     computes a maximal set U of independent variables of the ideal
     given by a standard basis.  If `v' is the result then `v[i]' is 1
     if and only if the i-th variable of the ring, `x(i)', is an
     independent variable.  Hence, the set U consisting of all variables
     `x(i)' with `v[i]=1' is a maximal independent set.

`*Note:*'
     U is a set of independent variables for I if and only if $I \cap K[U]=(0)$,
     I intersect K[U]=(0), i.e., eliminating the remaining variables
     gives (0).  U is maximal if dim(I)=#U.

`*Syntax:*'
     `indepSet (' ideal_expression, int_expression `)'

`*Type:*'
     list

`*Purpose:*'
     computes a list of all maximal independent sets of the leading
     ideal (if the flag is 0), resp. of all those sets of independent
     variables of the leading ideal which cannot be enlarged.

`*Example:*'

            ring r=32003,(x,y,u,v,w),dp;
            ideal I=xyw,yvw,uyw,xv;
            attrib(I,"isSB",1);
            indepSet(I);
          ==> 1,1,1,0,0
            eliminate(I,vw);
          ==> _[1]=0
            indepSet(I,0);
          ==> [1]:
          ==>    1,1,1,0,0
          ==> [2]:
          ==>    0,1,1,1,0
          ==> [3]:
          ==>    1,0,1,0,1
          ==> [4]:
          ==>    0,0,1,1,1
            indepSet(I,1);
          ==> [1]:
          ==>    1,1,1,0,0
          ==> [2]:
          ==>    0,1,1,1,0
          ==> [3]:
          ==>    1,0,1,0,1
          ==> [4]:
          ==>    0,0,1,1,1
          ==> [5]:
          ==>    0,1,0,0,1
            eliminate(I,xuv);
          ==> _[1]=0

* Menu:

See
* ideal::
* std::

See *note ideal::; *note std::.


File: singular.hlp,  Node: insert,  Next: interred,  Prev: indepSet,  Up: Functions

5.1.51 insert
-------------

`*Syntax:*'
     `insert (' list_expression`,' expression `)'
     `insert (' list_expression`,' expression`,' int_expression `)'

`*Type:*'
     list

`*Purpose:*'
     inserts a new element (expression) into a list at the beginning, or
     (if called with 3 arguments) after the given position (the input is
     not changed).

`*Example:*'

            list L=1,2;
            insert(L,4,2);
          ==> [1]:
          ==>    1
          ==> [2]:
          ==>    2
          ==> [3]:
          ==>    4
            insert(L,4);
          ==> [1]:
          ==>    4
          ==> [2]:
          ==>    1
          ==> [3]:
          ==>    2

* Menu:

See
* delete::
* list::

See *note delete::; *note list::.


File: singular.hlp,  Node: interred,  Next: intersect,  Prev: insert,  Up: Functions

5.1.52 interred
---------------

`*Syntax:*'
     `interred (' ideal_expression `)'
     `interred (' module_expression `)'

`*Type:*'
     the same as the input type

`*Purpose:*'
     interreduces a set of polynomials/vectors.
     input: f_1,...,f_n input: $f_1,\dots,f_n$

     output: g_1,...,g_s with s<=n and the properties


output: $g_1,\dots,g_s$ with $s \leq n$ and the properties

        * (f_1,...,f_n) = (g_1,...,g_s) $(f_1,\dots,f_n) = (g_1,\dots,g_s)$

        * L(g_i)<>L(g_j) for all i<>j $L(g_i)\neq L(g_j)$ for all $i\neq j$

        * in the case of a global ordering (polynomial ring):
          L(g_i) $L(g_i)$
           does not divide m for all monomials m of
          {g_1,...,g_(i-1),g_(i+1),...,g_s} $\{g_1,\dots,g_{i-1},g_{i+1},\dots,g_s\}$

        * in the case of a local or mixed ordering (localization of
          polynomial ring):
          if L(g_i) | L(g_j) for any i<>j, $L(g_i) | L(g_j)$ for any $i \neq j$,
          then ecart(g_i) > ecart(g_j) $ecart(g_i) > ecart(g_j)$

Here, $L(g)$ denotes the leading term of $g$ and
     $ecart(g):=deg(g)-deg(L(g))$.


     Here, L(g) denotes the leading term of g and ecart(g) :=
     deg(g)-deg(L(g)).

`*Example:*'

            ring r=0,(x,y,z),dp;
            ideal i=x2+z,z,2z;
            interred(i);
          ==> _[1]=z
          ==> _[2]=x2
            ring R=0,(x,y,z),ds;
            ideal i=zx+y3,z+y3,z+xy;
            interred(i);
          ==> _[1]=z+xy
          ==> _[2]=xy-y3
          ==> _[3]=x2y-y3

* Menu:

See
* ideal::
* module::
* std::

See *note ideal::; *note module::; *note std::.


File: singular.hlp,  Node: intersect,  Next: jacob,  Prev: interred,  Up: Functions

5.1.53 intersect
----------------

`*Syntax:*'
     `intersect (' expression_list of ideal_expression `)'
     `intersect (' expression_list of module_expression `)'

`*Type:*'
     ideal, resp. module

`*Purpose:*'
     computes the intersection of ideals, resp. modules.

`*Note:*'
     If the option `returnSB' is enabled then the result is a standard
     basis.

`*Example:*'

            ring R=0,(x,y),dp;
            ideal i=x;
            ideal j=y;
            intersect(i,j);
          ==> _[1]=xy
            ring r=181,(x,y,z),(c,ls);
            ideal id1=maxideal(3);
            ideal id2=x2+xyz,y2-z3y,z3+y5xz;
            ideal id3=intersect(id1,id2,ideal(x,y));
            id3;
          ==> id3[1]=yz3+xy6z
          ==> id3[2]=yz4-y2z
          ==> id3[3]=y2z3-y3
          ==> id3[4]=xz3+x2y5z
          ==> id3[5]=xyz2+x2z
          ==> id3[6]=xyz3-xy2
          ==> id3[7]=xy2z+x2y
          ==> id3[8]=x2yz+x3

* Menu:

See
* ideal::
* module::
* option::

See *note ideal::; *note module::; *note option::.


File: singular.hlp,  Node: jacob,  Next: jet,  Prev: intersect,  Up: Functions

5.1.54 jacob
------------

`*Syntax:*'
     `jacob (' poly_expression `)'
     `jacob (' ideal_expression `)'

`*Type:*'
     ideal, if the input is a polynomial
     matrix, if the input is an ideal

`*Purpose:*'
     computes the Jacobi ideal, resp. Jacobi matrix, generated by all
     partial derivatives of the input.

`*Example:*'

            ring R;
            poly f=x2+y3+z5;
            jacob(f);
          ==> _[1]=2x
          ==> _[2]=3y2
          ==> _[3]=5z4
            ideal i=jacob(f);
            print(jacob(i));
          ==> 2,0, 0,  
          ==> 0,6y,0,  
          ==> 0,0, 20z3

* Menu:

See
* diff::
* ideal::
* module::
* nvars::

See *note diff::; *note ideal::; *note module::; *note nvars::.


File: singular.hlp,  Node: jet,  Next: kbase,  Prev: jacob,  Up: Functions

5.1.55 jet
----------

`*Syntax:*'
     `jet (' poly_expression`,' int_expression `)'
     `jet (' vector_expression`,' int_expression `)'
     `jet (' ideal_expression`,' int_expression `)'
     `jet (' module_expression`,' int_expression `)'
     `jet (' poly_expression`,' int_expression`,' intvec_expression `)'
     `jet (' vector_expression`,' int_expression`,' intvec_expression
     `)'
     `jet (' ideal_expression`,' int_expression`,' intvec_expression `)'

     `jet (' module_expression`,' int_expression`,' intvec_expression
     `)'
     `jet (' poly_expression`,' int_expression`,' poly_expression `)'
     `jet (' vector_expression`,' int_expression`,' poly_expression `)'
     `jet (' ideal_expression`,' int_expression`,' matrix_expression `)'

     `jet (' module_expression`,' int_expression`,' matrix_expression
     `)'

`*Type:*'
     the same as the type of the first argument

`*Purpose:*'
     deletes from the first argument all terms of degree bigger than the
     second argument.
     If a third argument `w' of type intvec is given, the degree is
     replaced by the weighted degree defined by `w'.
     If a third argument `u' of type poly or matrix is given, the first
     argument `p' is replaced by `p/u'.

`*Example:*'

            ring r=32003,(x,y,z),(c,dp);
            jet(1+x+x2+x3+x4,3);
          ==> x3+x2+x+1
            poly f=1+x+x2+xz+y2+x3+y3+x2y2+z4;
            jet(f,3);
          ==> x3+y3+x2+y2+xz+x+1
            intvec iv=2,1,1;
            jet(f,3,iv);
          ==> y3+y2+xz+x+1
            // the part of f with (total) degree >3:
            f-jet(f,3);
          ==> x2y2+z4
            // the homogeneous part of f of degree 2:
            jet(f,2)-jet(f,1);
          ==> x2+y2+xz
            // the part of maximal degree:
            jet(f,deg(f))-jet(f,deg(f)-1);
          ==> x2y2+z4
            // the absolute term of f:
            jet(f,0);
          ==> 1
            // now for other types:
            ideal i=f,x,f*f;
            jet(i,2);
          ==> _[1]=x2+y2+xz+x+1
          ==> _[2]=x
          ==> _[3]=3x2+2y2+2xz+2x+1
            vector v=[f,1,x];
            jet(v,1);
          ==> [x+1,1,x]
            jet(v,0);
          ==> [1,1]
            v=[f,1,0];
            module m=v,v,[1,x2,z3,0,1];
            jet(m,2);
          ==> _[1]=[x2+y2+xz+x+1,1]
          ==> _[2]=[x2+y2+xz+x+1,1]
          ==> _[3]=[1,x2,0,0,1]

* Menu:

See
* deg::
* ideal::
* int::
* intvec::
* module::
* poly::
* vector::

See *note deg::; *note ideal::; *note int::; *note intvec::; *note
module::; *note poly::; *note vector::.


File: singular.hlp,  Node: kbase,  Next: kill,  Prev: jet,  Up: Functions

5.1.56 kbase
------------

`*Syntax:*'
     `kbase (' ideal_expression `)'
     `kbase (' module_expression `)'
     `kbase (' ideal_expression`,' int_expression`)'
     `kbase (' module_expression`,' int_expression`)'

`*Type:*'
     the same as the input type of the first argument

`*Purpose:*'
     with one argument: computes a vector space basis (consisting of
     monomials) of the quotient ring by the ideal, resp. of a free
     module by the module, in case it is finite dimensional and if the
     input is a standard basis with respect to the ring ordering.  If
     the input is not a standard basis, the leading terms of the input
     are used and the result may have no meaning.
     With two arguments: computes the part of a vector space basis of
     the respective quotient with degree of the monomials equal to the
     second argument. Here, the quotient does not need to be finite
     dimensional.

`*Example:*'

            ring r=32003,(x,y,z),ds;
            ideal i=x2,y2,z;
            kbase(std(i));
          ==> _[1]=xy
          ==> _[2]=y
          ==> _[3]=x
          ==> _[4]=1
            i=x2,y3,xyz;  // quotient not finite dimensional
            kbase(std(i),2);
          ==> _[1]=z2
          ==> _[2]=yz
          ==> _[3]=xz
          ==> _[4]=y2
          ==> _[5]=xy

* Menu:

See
* ideal::
* module::
* vdim::

See *note ideal::; *note module::; *note vdim::.


File: singular.hlp,  Node: kill,  Next: killattrib,  Prev: kbase,  Up: Functions

5.1.57 kill
-----------

`*Syntax:*'
     `kill (' name `)'
     `kill (' list_of_names `)'

`*Type:*'
     none

`*Purpose:*'
     deletes objects.

`*Example:*'

            int i=3;
            ring r=0,x,dp;
            poly p;
            listvar();
          ==> // r                    [0]  *ring
          ==> //      p                    [0]  poly
          ==> // i                    [0]  int 3
          ==> // LIB                  [0]  string standard.lib
            kill(i,r);
            // the variable `i` does not exist any more
            i;
          ==>    ? `i` is undefined
          ==>    ? error occurred in line 7: `  i;`
            listvar();
          ==> // LIB                  [0]  string standard.lib

* Menu:

See
* defined::
* general_lib::
* names::

See *note defined::; *note general_lib::; *note names::.


File: singular.hlp,  Node: killattrib,  Next: koszul,  Prev: kill,  Up: Functions

5.1.58 killattrib
-----------------

`*Syntax:*'
     `killattrib (' name`,' string_expression `)'

`*Type:*'
     none

`*Purpose:*'
     deletes the attribute given as the second argument.

`*Example:*'

            ring r=32003,(x,y),lp;
            ideal i=maxideal(1);
            attrib(i,"isSB",1);
            attrib(i);
          ==> attr:isSB, type int
            killattrib(i,"isSB");
            attrib(i);
          ==> no attributes

* Menu:

See
* attrib::
* option::

See *note attrib::; *note option::.


File: singular.hlp,  Node: koszul,  Next: laguerre,  Prev: killattrib,  Up: Functions

5.1.59 koszul
-------------

`*Syntax:*'
     `koszul (' int_expression`,' int_expression `)'
     `koszul (' int_expression`,' ideal_expression `)'
     `koszul (' int_expression`,' int_expression`,' ideal_expression `)'

`*Type:*'
     matrix

`*Purpose:*'
     `koszul(d,n)' computes a matrix of the Koszul relations of degree d
     of the first n ring variables.

     `koszul(d,id)' computes a matrix of the Koszul relations of degree
     d of the generators of the ideal `id'.

     `koszul(d,n,id)' computes a matrix of the Koszul relations of
     degree d of the first n generators of the ideal `id'.

`*Note:*'
     `koszul(1,id),koszul(2,id),...' form a complex, that is, the
     product of the matrices `koszul(i,id)' and `koszul(i+1,id)' equals
     zero.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            print(koszul(2,3));
          ==> -y,-z,0, 
          ==> x, 0, -z,
          ==> 0, x, y  
            ideal I=xz2+yz2+z3,xyz+y2z+yz2,xy2+y3+y2z;
            print(koszul(1,I));
          ==> xz2+yz2+z3,xyz+y2z+yz2,xy2+y3+y2z
            print(koszul(2,I));
          ==> -xyz-y2z-yz2,-xy2-y3-y2z,0,          
          ==> xz2+yz2+z3,  0,          -xy2-y3-y2z,
          ==> 0,           xz2+yz2+z3, xyz+y2z+yz2 
            print(koszul(2,I)*koszul(3,I));
          ==> 0,
          ==> 0,
          ==> 0 

* Menu:

See
* int::
* matrix::

See *note int::; *note matrix::.


File: singular.hlp,  Node: laguerre,  Next: lead,  Prev: koszul,  Up: Functions

5.1.60 laguerre
---------------

`*Syntax:*'
     `laguerre (' poly_expression`,' int_expression`,' int_expression
     `)'

`*Type:*'
     list

`*Purpose:*'
     computes all complex roots of a univariate polynomial using
     Laguerre's algorithm. The second argument defines the precision of
     the fractional part if the ground field is the field of rational
     numbers, otherwise it will be ignored. The third argument (can be
     0, 1 or 2) gives the number of extra runs for Laguerre's algorithm
     (with corrupted roots), leading to better results.

`*Note:*'
     If the ground field is the field of complex numbers, the elements
     of the list are of type number, otherwise of type string.

`*Example:*'

          ring rs1=0,(x,y),lp;
          poly f=15x5+x3+x2-10;
          laguerre(f,10,2);
          ==> [1]:
          ==>    (0.2930464644-I*0.9003002396)
          ==> [2]:
          ==>    (0.2930464644+I*0.9003002396)
          ==> [3]:
          ==>    (-0.7392783383-I*0.5355190078)
          ==> [4]:
          ==>    (-0.7392783383+I*0.5355190078)
          ==> [5]:
          ==>    0.8924637479


File: singular.hlp,  Node: lead,  Next: leadcoef,  Prev: laguerre,  Up: Functions

5.1.61 lead
-----------

`*Syntax:*'
     `lead (' poly_expression `)'
     `lead (' vector_expression `)'
     `lead (' ideal_expression `)'
     `lead (' module_expression `)'

`*Type:*'
     the same as the input type

`*Purpose:*'
     returns the leading (or initial) term(s) of a polynomial, a vector,
     resp. of the generators of an ideal or module with respect to the
     monomial ordering.

`*Note:*'
     `IN' may be used instead of `lead'.

`*Example:*'

            ring r=32003,(x,y,z),(c,ds);
            poly f=2x2+3y+4z3;
            vector v=[2x10,f];
            ideal i=f,z;
            module m=v,[0,0,2+x];
            lead(f);
          ==> 3y
            lead(v);
          ==> [2x10]
            lead(i);
          ==> _[1]=3y
          ==> _[2]=z
            lead(m);
          ==> _[1]=[2x10]
          ==> _[2]=[0,0,2]
            lead(0);
          ==> 0

* Menu:

See
* ideal::
* leadcoef::
* leadexp::
* leadmonom::
* module::
* poly::
* vector::

See *note ideal::; *note leadcoef::; *note leadexp::; *note leadmonom::;
*note module::; *note poly::; *note vector::.


File: singular.hlp,  Node: leadcoef,  Next: leadexp,  Prev: lead,  Up: Functions

5.1.62 leadcoef
---------------

`*Syntax:*'
     `leadcoef (' poly_expression `)'
     `leadcoef (' vector_expression `)'

`*Type:*'
     number

`*Purpose:*'
     returns the leading (or initial) coefficient of a polynomial or a
     vector with respect to the monomial ordering.

`*Example:*'

            ring r=32003,(x,y,z),(c,ds);
            poly f=x2+y+z3;
            vector v=[2*x^10,f];
            leadcoef(f);
          ==> 1
            leadcoef(v);
          ==> 2
            leadcoef(0);
          ==> 0

* Menu:

See
* lead::
* leadexp::
* leadmonom::
* number::
* poly::
* vector::

See *note lead::; *note leadexp::; *note leadmonom::; *note number::;
*note poly::; *note vector::.


File: singular.hlp,  Node: leadexp,  Next: leadmonom,  Prev: leadcoef,  Up: Functions

5.1.63 leadexp
--------------

`*Syntax:*'
     `leadexp (' poly_expression `)'
     `leadexp (' vector_expression `)'

`*Type:*'
     intvec

`*Purpose:*'
     returns the exponent vector of the leading monomial of a polynomial
     or a vector.  In the case of a vector the last component is the
     index in the vector.

`*Example:*'

            ring r=32003,(x,y,z),(c,ds);
            poly f=x2+y+z3;
            vector v=[2*x^10,f];
            leadexp(f);
          ==> 0,1,0
            leadexp(v);
          ==> 10,0,0,1
            leadexp(0);
          ==> 0,0,0

* Menu:

See
* intvec::
* lead::
* leadcoef::
* leadmonom::
* poly::
* vector::

See *note intvec::; *note lead::; *note leadcoef::; *note leadmonom::;
*note poly::; *note vector::.


File: singular.hlp,  Node: leadmonom,  Next: LIB,  Prev: leadexp,  Up: Functions

5.1.64 leadmonom
----------------

`*Syntax:*'
     `leadmonom (' poly_expression `)'
     `leadmonom (' vector_expression `)'

`*Type:*'
     the same as the input type

`*Purpose:*'
     returns the leading monomial of a polynomial or a vector as a
     polynomial or vector whose coefficient is one.

`*Example:*'

            ring r=32003,(x,y,z),(c,ds);
            poly f=2x2+3y+4z3;
            vector v=[2x10,f];
            leadmonom(f);
          ==> y
            leadmonom(v);
          ==> [x10]
            leadmonom(0);
          ==> 0

* Menu:

See
* intvec::
* lead::
* leadcoef::
* leadexp::
* poly::
* vector::

See *note intvec::; *note lead::; *note leadcoef::; *note leadexp::;
*note poly::; *note vector::.


File: singular.hlp,  Node: LIB,  Next: lift,  Prev: leadmonom,  Up: Functions

5.1.65 LIB
----------

`*Syntax:*'
     `LIB' string_expression`;'

`*Type:*'
     none

`*Purpose:*'
     reads a library of procedures from a file. If the given filename
     does not start with `.' or `/' and cannot be located in the current
     directory, each directory contained in the library `SearchPath' is
     searched for file of this name.  *Note Loading of a library::, for
     more info on `SearchPath'.

`*Note on standard.lib:*'
     Unless  SINGULAR is started with the `--no-stdlib' option, the
     library `standard.lib' is automatically loaded at start-up time.

`*Syntax:*'
     `LIB;'

`*Type:*'
     string

`*Purpose:*'
     shows all loaded libraries written in Singular.

`*Example:*'

            option(loadLib); // show loading of libraries
            LIB;             // standard.lib is loaded
          ==> standard.lib

                             // the names of the procedures of inout.lib
            LIB "inout.lib"; // are now known to Singular
          ==> // ** loaded inout.lib (1.21.2.5,2002/06/12)
            LIB;
          ==> standard.lib,inout.lib

* Menu:

See
* Command line options::
* Loading of a library::
* Procedures and libraries::
* SINGULAR libraries::
* proc::
* standard_lib::
* string::
* system::

See *note Command line options::; *note Loading of a library::; *note
Procedures and libraries::; *note SINGULAR libraries::; *note proc::;
*note standard_lib::; *note string::; *note system::.


File: singular.hlp,  Node: lift,  Next: liftstd,  Prev: LIB,  Up: Functions

5.1.66 lift
-----------

`*Syntax:*'
     `lift (' ideal_expression`,' subideal_expression `)'
     `lift (' module_expression`,' submodule_expression `)'
     `lift (' ideal_expression`,' subideal_expression`,' matrix_name `)'

     `lift (' module_expression`,' submodule_expression`,' matrix_name
     `)'

`*Type:*'
     matrix

`*Purpose:*'
     computes the transformation matrix which expresses the generators
     of a submodule in terms of the generators of a module.  Uses
     different algorithms for modules which are, resp. are not,
     represented by a standard basis.
     More precisely, if  `m' is the module (or ideal), `sm' the
     submodule (or ideal), and `T' the transformation matrix returned by
     lift, then `matrix(sm)*U = matrix(m)*T' and `module(sm*U) =
     module(matrix(m)*T)' (resp. `ideal(sm*U) = ideal(matrix(m)*T)'),
     where `U' is a diagonal matrix of units.
     `U' is always the unity matrix if the basering is a polynomial ring
     (not power series ring). `U' is stored in the optional third
     argument.

`*Note:*'
     Gives a warning if `sm' is not a submodule.

`*Example:*'

            ring r=32003,(x,y,z),(dp,C);
            ideal m=3x2+yz,7y6+2x2y+5xz;
            poly f=y7+x3+xyz+z2;
            ideal i=jacob(f);
            matrix T=lift(i,m);
            matrix(m)-matrix(i)*T;
          ==> _[1,1]=0
          ==> _[1,2]=0

* Menu:

See
* division::
* ideal::
* module::

See *note division::; *note ideal::; *note module::.


File: singular.hlp,  Node: liftstd,  Next: listvar,  Prev: lift,  Up: Functions

5.1.67 liftstd
--------------

`*Syntax:*'
     `liftstd (' ideal_expression`,' matrix_name `)'
     `liftstd (' module_expression`,' matrix_name `)'

`*Type:*'
     ideal or module

`*Purpose:*'
     returns a standard basis of an ideal or module and the
     transformation matrix from the given ideal, resp. module, to the
     standard basis.
     That is, if `m' is the ideal or module, `sm' the standard basis
     returned by `liftstd', and `T' the transformation matrix then
     `matrix(sm)=matrix(m)*T' and `sm=ideal(matrix(m)*T)', resp.
     `sm=module(matrix(m)*T)'.

`*Example:*'

            ring R=0,(x,y,z),dp;
            poly f=x3+y7+z2+xyz;
            ideal i=jacob(f);
            matrix T;
            ideal sm=liftstd(i,T);
            sm;
          ==> sm[1]=xy+2z
          ==> sm[2]=3x2+yz
          ==> sm[3]=yz2+3048192z3
          ==> sm[4]=3024xz2-yz2
          ==> sm[5]=y2z-6xz
          ==> sm[6]=3097158156288z4+2016z3
          ==> sm[7]=7y6+xz
            print(T);
          ==> 0,1,T[1,3],   T[1,4],y,  T[1,6],0,
          ==> 0,0,-3x+3024z,3x,    0,  T[2,6],1,
          ==> 1,0,T[3,3],   T[3,4],-3x,T[3,6],0 
            matrix(sm)-matrix(i)*T;
          ==> _[1,1]=0
          ==> _[1,2]=0
          ==> _[1,3]=0
          ==> _[1,4]=0
          ==> _[1,5]=0
          ==> _[1,6]=0
          ==> _[1,7]=0

* Menu:

See
* ideal::
* matrix::
* option::
* ring::
* std::

See *note ideal::; *note matrix::; *note option::; *note ring::; *note
std::.


File: singular.hlp,  Node: listvar,  Next: lres,  Prev: liftstd,  Up: Functions

5.1.68 listvar
--------------

`*Syntax:*'
     `listvar (' [package] `)'
     `listvar (' [package`,'] type `)'
     `listvar (' [package`,'] ring_name `)'
     `listvar (' [package`,'] name `)'
     `listvar (' [package`,'] `all )'

`*Type:*'
     none

`*Purpose:*'
     lists all (user-)defined names in the current namespace:

        * `listvar()': all currently visible names except procedures,

        * `listvar('type`)': all currently visible names of the given
          type,

        * `listvar('ring_name`)': all names which belong to the given
          ring,

        * `listvar('name`)': the object with the given name,

        * `listvar(all)': all names except procedures.

     The current basering is marked with a `*'.  The nesting level of
     variables in procedures is shown in square brackets.

`*Example:*'

            proc t1 { }
            proc t2 { }
            ring s;
            poly ss;
            ring r;
            poly f=x+y+z;
            int i=7;
            ideal I=f,x,y;
            listvar(all);
          ==> // i                    [0]  int 7
          ==> // r                    [0]  *ring
          ==> //      I                    [0]  ideal, 3 generator(s)
          ==> //      f                    [0]  poly
          ==> // s                    [0]  ring
          ==> //      ss                   [0]  poly
          ==> // LIB                  [0]  string standard.lib
            listvar();
          ==> // i                    [0]  int 7
          ==> // r                    [0]  *ring
          ==> //      I                    [0]  ideal, 3 generator(s)
          ==> //      f                    [0]  poly
          ==> // s                    [0]  ring
          ==> // LIB                  [0]  string standard.lib
            listvar(r);
          ==> // r                    [0]  *ring
          ==> // I                    [0]  ideal, 3 generator(s)
          ==> // f                    [0]  poly
            listvar(t1);
          ==> // t1                   [0]  proc
            listvar(proc);
          ==> // t2                   [0]  proc
          ==> // t1                   [0]  proc
          ==> // fprintf              [0]  proc from standard.lib
          ==> // printf               [0]  proc from standard.lib
          ==> // sprintf              [0]  proc from standard.lib
          ==> // intersect1           [0]  proc from standard.lib (static)
          ==> // quotient4            [0]  proc from standard.lib
          ==> // quotient5            [0]  proc from standard.lib
          ==> // quotient3            [0]  proc from standard.lib
          ==> // quotient2            [0]  proc from standard.lib
          ==> // quotient1            [0]  proc from standard.lib
          ==> // quotient0            [0]  proc from standard.lib (static)
          ==> // quot1                [0]  proc from standard.lib (static)
          ==> // quot                 [0]  proc from standard.lib
          ==> // res                  [0]  proc from standard.lib
          ==> // groebner             [0]  proc from standard.lib
          ==> // stdhilb              [0]  proc from standard.lib
          ==> // stdfglm              [0]  proc from standard.lib

* Menu:

See
* Names::
* Names in procedures::
* defined::
* names::
* type::

See *note Names::; *note Names in procedures::; *note defined::; *note
names::; *note type::.


File: singular.hlp,  Node: lres,  Next: maxideal,  Prev: listvar,  Up: Functions

5.1.69 lres
-----------

`*Syntax:*'
     `lres (' ideal_expression`,' int_expression `)'

`*Type:*'
     resolution

`*Purpose:*'
     computes a free resolution of an ideal using La Scala's algorithm.

     More precisely, let R be the basering and I be the given ideal.
     Then `lres' computes a minimal free resolution of R/I

                         A2       A1
           ... ---> F2 ---> F1 ---> R -> R/I -> 0.

$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
     \buildrel{A_1}\over{\longrightarrow} R\longrightarrow R/I
     \longrightarrow 0.$$
     If the int_expression k is not zero then the computation stops
     after k steps and returns a list of modules $M_i={\tt module}(A_i)$, i=1..k.
     Mi=module(Ai), i=1..k.

     `list L=lres(I,0);' returns a list L of n modules (where n is the
     number of variables of the basering) such that ${\tt L[i]}=M_i$
     L[i]=M_i in the above notation.

`*Note:*'
     The ideal_expression has to be homogeneous.
     Accessing single elements of a resolution may require that some
     partial computations have to be finished and may therefore take
     some time.

`*Example:*'

            ring r=0,(x,y,z),dp;
            ideal I=xz,yz,x3-y3;
            def L=lres(I,0);
            print(betti(L),"betti");
          ==>            0     1     2
          ==> ------------------------
          ==>     0:     1     -     -
          ==>     1:     -     2     1
          ==>     2:     -     1     1
          ==> ------------------------
          ==> total:     1     3     2
            L[2];     // the first syzygy module of r/I
          ==> _[1]=-x*gen(1)+y*gen(2)
          ==> _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)

* Menu:

See
* betti::
* hres::
* ideal::
* int::
* minres::
* module::
* mres::
* res::
* sres::

See *note betti::; *note hres::; *note ideal::; *note int::; *note
minres::; *note module::; *note mres::; *note res::; *note sres::.


File: singular.hlp,  Node: maxideal,  Next: memory,  Prev: lres,  Up: Functions

5.1.70 maxideal
---------------

`*Syntax:*'
     `maxideal (' int_expression `)'

`*Type:*'
     ideal

`*Purpose:*'
     returns the power given by int_expression of the maximal ideal
     generated by all ring variables (`maxideal(i)=1' for `i<=0').

`*Example:*'

            ring r=32003,(x,y,z),dp;
            maxideal(2);
          ==> _[1]=z2
          ==> _[2]=yz
          ==> _[3]=y2
          ==> _[4]=xz
          ==> _[5]=xy
          ==> _[6]=x2

* Menu:

See
* ideal::
* ring::

See *note ideal::; *note ring::.


File: singular.hlp,  Node: memory,  Next: minbase,  Prev: maxideal,  Up: Functions

5.1.71 memory
-------------

`*Syntax:*'
     `memory (' int_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns statistics concerning the memory management:

        * `memory(0)' is the number of active (used) bytes,

        * `memory(1)' is the number of bytes allocated from the
          operating system,

        * `memory(2)' is the maximal number of bytes ever allocated from
          the operating system during the current SINGULAR session.

`*Note:*'
     To monitor the memory usage during ongoing computations the option
     `mem' should be set (using the command `option(mem);', see also
     *note option::).

`*Example:*'

            ring r=0,(x(1..500)),dp;
            poly p=(x(1)+x(500))^50;
            proc ReportMemoryUsage()
            {  "Memory currently used by SINGULAR     :",memory(0),"Byte (",
               memory(0)/1023, "KByte)" +newline+
               "Memory currently allocated from system:",memory(1), "Byte (",
               memory(1)/1023, "KByte)";
               "Maximal memory allocated from system  :",memory(2), "Byte (",
               memory(2)/1023, "KByte)";
            }
            ReportMemoryUsage();
          ==> Memory currently used by SINGULAR     : 206940 Byte ( 202 KByte)
          ==> Memory currently allocated from system: 669128 Byte ( 654 KByte)
          ==> Maximal memory allocated from system  : 669128 Byte ( 654 KByte)
            kill p;
            ReportMemoryUsage(); // less memory used: p killed
          ==> Memory currently used by SINGULAR     : 153704 Byte ( 150 KByte)
          ==> Memory currently allocated from system: 669128 Byte ( 654 KByte)
          ==> Maximal memory allocated from system  : 669128 Byte ( 654 KByte)
            kill r;
            ReportMemoryUsage(); // even less memory: r killed
          ==> Memory currently used by SINGULAR     : 143124 Byte ( 139 KByte)
          ==> Memory currently allocated from system: 669128 Byte ( 654 KByte)
          ==> Maximal memory allocated from system  : 669128 Byte ( 654 KByte)

* Menu:

See
* option::
* system::

See *note option::; *note system::.


File: singular.hlp,  Node: minbase,  Next: minor,  Prev: memory,  Up: Functions

5.1.72 minbase
--------------

`*Syntax:*'
     `minbase (' ideal_expression `)'
     `minbase (' module_expression `)'

`*Type:*'
     the same as the type of the argument

`*Purpose:*'
     returns a minimal set of generators of an ideal, resp. module, if
     the input is either homogeneous or if the ordering is local.

`*Example:*'

            ring r=181,(x,y,z),(c,ls);
            ideal id2=x2+xyz,y2-z3y,z3+y5xz;
            ideal id4=maxideal(3)+id2;
            size(id4);
          ==> 13
            minbase(id4);
          ==> _[1]=x2
          ==> _[2]=xyz+x2
          ==> _[3]=xz2
          ==> _[4]=y2
          ==> _[5]=yz2
          ==> _[6]=z3

* Menu:

See
* mstd::

See *note mstd::.


File: singular.hlp,  Node: minor,  Next: minres,  Prev: minbase,  Up: Functions

5.1.73 minor
------------

`*Syntax:*'
     `minor (' matrix_expression`,' int_expression `)'
     `minor (' matrix_expression`,' int_expression`,' ideal_expression
     `)'

`*Type:*'
     ideal

`*Purpose:*'
     returns the set of all minors (=subdeterminants) of the given size
     of a matrix.  The optional third argument must be a standard basis.
     If a third argument is given, the computations will be performed
     modulo that ideal.

`*Example:*'

            ring r=0,(x(1..5)),ds;
            matrix m[2][4]=x(1..4),x(2..5);
            print(m);
          ==> x(1),x(2),x(3),x(4),
          ==> x(2),x(3),x(4),x(5) 
            ideal j=minor(m,2);
            j;
          ==> j[1]=-x(4)^2+x(3)*x(5)
          ==> j[2]=-x(3)*x(4)+x(2)*x(5)
          ==> j[3]=-x(2)*x(4)+x(1)*x(5)
          ==> j[4]=x(3)^2-x(2)*x(4)
          ==> j[5]=x(2)*x(3)-x(1)*x(4)
          ==> j[6]=-x(2)^2+x(1)*x(3)
            minor(m,2,std(ideal(x(1))));
          ==> _[1]=-x(4)^2+x(3)*x(5)
          ==> _[2]=-x(3)*x(4)+x(2)*x(5)
          ==> _[3]=-x(2)*x(4)
          ==> _[4]=x(3)^2-x(2)*x(4)
          ==> _[5]=x(2)*x(3)
          ==> _[6]=-x(2)^2

* Menu:

See
* det::

See *note det::.


File: singular.hlp,  Node: minres,  Next: modulo,  Prev: minor,  Up: Functions

5.1.74 minres
-------------

`*Syntax:*'
     `minres (' list_expression `)'

`*Type:*'
     list

`*Syntax:*'
     `minres (' resolution_expression `)'

`*Type:*'
     resolution

`*Purpose:*'
     minimizes a free resolution of an ideal or module given by the
     list_expression, resp. resolution_expression.

`*Example:*'

            ring r1=32003,(x,y),dp;
            ideal i=x5+xy4,x3+x2y+xy2+y3;
            resolution rs=lres(i,0);
            rs;
          ==>   1       2       1       
          ==> r1 <--  r1 <--  r1
          ==> 
          ==> 0       1       2       
          ==> resolution not minimized yet
          ==> 
            list(rs);
          ==> [1]:
          ==>    _[1]=x3+x2y+xy2+y3
          ==>    _[2]=xy4
          ==>    _[3]=y7
          ==> [2]:
          ==>    _[1]=-y4*gen(1)+x2*gen(2)+xy*gen(2)+y2*gen(2)+gen(3)
          ==>    _[2]=-y3*gen(2)+x*gen(3)
            minres(rs);
          ==>   1       2       1       
          ==> r1 <--  r1 <--  r1
          ==> 
          ==> 0       1       2       
          ==> 
            list(rs);
          ==> [1]:
          ==>    _[1]=x3+x2y+xy2+y3
          ==>    _[2]=xy4
          ==> [2]:
          ==>    _[1]=xy4*gen(1)-x3*gen(2)-x2y*gen(2)-xy2*gen(2)-y3*gen(2)

* Menu:

See
* mres::
* res::
* sres::

See *note mres::; *note res::; *note sres::.


File: singular.hlp,  Node: modulo,  Next: monitor,  Prev: minres,  Up: Functions

5.1.75 modulo
-------------

`*Syntax:*'
     `modulo (' ideal_expression`,' ideal_expression `)'
     `modulo (' module_expression`,' module_expression `)'

`*Type:*'
     module

`*Purpose:*'
     `modulo(h1,h2)' represents h1/(h1 intersect h2) (isomorphic to
     (h1+h2)/h2) represents $h_1/(h_1 \cap h_2) \cong (h_1+h_2)/h_2$
     where $h_1$ and $h_2$
     h1 and h2 are considered as submodules of the same free module $R^l$
     R^l (l=1 for ideals). Let $H_1$, resp.\ $H_2$,
     H1 and H2 be the matrices of size l x k, resp. l x m, having the
     columns of be the matrices of size $l \times k$, resp.\ $l \times m$, having the
     generators of $h_1$, resp.\ $h_2$,
     h1, resp. h2, as columns.  Then $h_1/(h_1 \cap h_2) \cong R^k / ker(\overline{H_1})$

                                                         __
           h1/(h1 intersect h2) is isomorphic to R^k/ker(H1)



     where $\overline{H_1}: R^k \rightarrow R^l/Im(H_2)=R^l/h_2$
     is the induced map.

              __
              H1: R^k ---> R^l/Im(H2)=R^l/h2 is the induced map.




     `modulo(h1,h2)' returns generators of the kernel of this induced
     map.

`*Example:*'

            ring r;
            ideal h1=x,y,z;
            ideal h2=x;
            module m=modulo(h1,h2);
            print(m);
          ==> 1,0, 0,0,
          ==> 0,-z,x,0,
          ==> 0,y, 0,x 

* Menu:

See
* syz::

See *note syz::.


File: singular.hlp,  Node: monitor,  Next: mpresmat,  Prev: modulo,  Up: Functions

5.1.76 monitor
--------------

`*Syntax:*'
     `monitor (' string_expression `)'
     `monitor (' string_expression`,' string_expression `)'

`*Type:*'
     none

`*Purpose:*'
     controls the recording of all user input and/or program output into
     a file.  The second argument describes what to log: `"i"' means
     input, `"o"' means output, `"io"' for both.
     The default for the second argument is `"i"'.
     Each `monitor' command closes a previous monitor file and opens the
     file given by the first string expression.
     `monitor ("")' turns off recording.

`*Example:*'

            monitor("doe.tmp","io"); // log input and output to doe.tmp
            ring r;
            poly f=x+y+z;
            int i=7;
            ideal I=f,x,y;
            monitor("");             // stop logging


File: singular.hlp,  Node: mpresmat,  Next: mres,  Prev: monitor,  Up: Functions

5.1.77 mpresmat
---------------

`*Syntax:*'
     `mpresmat (' ideal_expression`,' int_expression `)'

`*Type:*'
     module

`*Purpose:*'
     computes the multipolynomial resultant matrix of the input system.
     Uses the sparse resultant matrix method of Gelfand, Kapranov and
     Zelevinsky (second parameter = 0) or the resultant matrix method of
     Macaulay (second parameter = 1).

`*Note:*'
     When using the resultant matrix method of Macaulay the input system
     must be homogeneous. The number of elements in the input system
     must be the number of variables in the basering plus one.

`*Example:*'

            ring rsq=(0,s,t,u),(x,y),lp;
            ideal i=s+tx+uy,x2+y2-10,x2+xy+2y2-16;
            module m=mpresmat(i,0);
            print(m);
          ==> -16,0,  -10,0,  (s),0,  0,  0,  0,  0,  
          ==> 0,  -16,0,  -10,(u),(s),0,  0,  0,  0,  
          ==> 2,  0,  1,  0,  0,  (u),0,  0,  0,  0,  
          ==> 0,  2,  0,  1,  0,  0,  0,  0,  0,  0,  
          ==> 0,  0,  0,  0,  (t),0,  -10,(s),0,  -16,
          ==> 1,  0,  0,  0,  0,  (t),0,  (u),(s),0,  
          ==> 0,  1,  0,  0,  0,  0,  1,  0,  (u),2,  
          ==> 1,  0,  1,  0,  0,  0,  0,  (t),0,  0,  
          ==> 0,  1,  0,  1,  0,  0,  0,  0,  (t),1,  
          ==> 0,  0,  0,  0,  0,  0,  1,  0,  0,  1   

* Menu:

See
* uressolve::

See *note uressolve::.


File: singular.hlp,  Node: mres,  Next: mstd,  Prev: mpresmat,  Up: Functions

5.1.78 mres
-----------

`*Syntax:*'
     `mres (' ideal_expression`,' int_expression `)'
     `mres (' module_expression`,' int_expression `)'

`*Type:*'
     resolution

`*Purpose:*'
     computes a minimal free resolution of an ideal or module M with the
     standard basis method. More precisely, let A=`matrix'(M), then
     `mres' computes a free resolution of coker(A)=F0/M

                         A2       A1
           ... ---> F2 ---> F1 ---> F0 -> F0/M -> 0.

$coker(A)=F_0/M$
     $$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
     \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M
     \longrightarrow 0,$$
     where the columns of the matrix $A_1$
     A1 are a minimal set of generators of M if the basering is local or
     if M is homogeneous.  If the int expression k is not zero then the
     computation stops after k steps and returns a list of modules $M_i={\tt module}(A_i)$, i=1...k.
     Mi=module(Ai), i=1...k.
     `mres(M,0)' returns a resolution consisting of at most n+2 modules,
     where n is the number of variables of the basering.  Let `list
     L=mres(M,0);'  then `L[1]' consists of a minimal set of generators
     of the input, `L[2]' consists of a minimal set of generators for
     the first syzygy module of `L[1]', etc., until `L[p+1]', such that
     L[i]<>0 for i<=p, ${\tt L[i]}\neq 0$ for $i \le p$,
      but `L[p+1]', the first syzygy module of `L[p]', is 0 (if the
     basering is not a qring).

`*Note:*'
     Accessing single elements of a resolution may require that some
     partial computations have to be finished and may therefore take
     some time.

`*Example:*'

            ring r=31991,(t,x,y,z,w),ls;
            ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
                    t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
            resolution L=mres(M,0);
            L;
          ==>  1      4      15      18      7      1      
          ==> r <--  r <--  r <--   r <--   r <--  r
          ==> 
          ==> 0      1      2       3       4      5      
          ==> 
            // projective dimension of M is 5

* Menu:

See
* hres::
* ideal::
* lres::
* module::
* res::
* sres::

See *note hres::; *note ideal::; *note lres::; *note module::; *note
res::; *note sres::.


File: singular.hlp,  Node: mstd,  Next: mult,  Prev: mres,  Up: Functions

5.1.79 mstd
-----------

`*Syntax:*'
     `mstd (' ideal_expression `)'
     `mstd (' module_expression `)'

`*Type:*'
     list

`*Purpose:*'
     returns a list whose first entry is a standard basis for the ideal,
     resp. module. If the monomial ordering is global, then the second
     entry is both a generating set for the ideal, resp. module, and a
     subset of the standard basis.  If, additionally, the input is
     homogeneous then the second entry is a minimal generating set for
     the ideal, resp. module.

`*Example:*'

            ring r=0,(x,y,z,t),dp;
            poly f=x3+y4+z6+xyz;
            ideal j=jacob(f),f;
            j=homog(j,t);j;
          ==> j[1]=3x2+yz
          ==> j[2]=4y3+xzt
          ==> j[3]=6z5+xyt3
          ==> j[4]=0
          ==> j[5]=z6+y4t2+x3t3+xyzt3
            mstd(j);
          ==> [1]:
          ==>    _[1]=3x2+yz
          ==>    _[2]=4y3+xzt
          ==>    _[3]=6z5+xyt3
          ==>    _[4]=xyzt3
          ==>    _[5]=y2z2t3
          ==>    _[6]=yz3t4
          ==>    _[7]=xz3t4
          ==>    _[8]=yz2t7
          ==>    _[9]=xz2t7
          ==>    _[10]=y2zt7
          ==>    _[11]=xy2t7
          ==> [2]:
          ==>    _[1]=3x2+yz
          ==>    _[2]=4y3+xzt
          ==>    _[3]=6z5+xyt3
          ==>    _[4]=xyzt3

* Menu:

See
* ideal::
* minbase::
* module::
* std::

See *note ideal::; *note minbase::; *note module::; *note std::.


File: singular.hlp,  Node: mult,  Next: nameof,  Prev: mstd,  Up: Functions

5.1.80 mult
-----------

`*Syntax:*'
     `mult (' ideal_expression `)'
     `mult (' module_expression `)'

`*Type:*'
     int

`*Purpose:*'
     computes the degree of the monomial ideal, resp. module, generated
     by the leading monomials of the input.
     If the input is a standard basis of a homogeneous ideal then it
     returns the degree of this ideal.
     If the input is a standard basis of an ideal in a (local) ring with
     respect to a local degree ordering then it returns the multiplicity
     of the ideal (in the sense of Samuel, with respect to the maximal
     ideal).

`*Example:*'

            ring r=32003,(x,y),ds;
            poly f=(x3+y5)^2+x2y7;
            ideal i=std(jacob(f));
            mult(i);
          ==> 46
            mult(std(f));
          ==> 6

* Menu:

See
* degree::
* dim::
* ideal::
* std::
* vdim::

See *note degree::; *note dim::; *note ideal::; *note std::; *note
vdim::.


File: singular.hlp,  Node: nameof,  Next: names,  Prev: mult,  Up: Functions

5.1.81 nameof
-------------

`*Syntax:*'
     `nameof (' expression `)'

`*Type:*'
     string

`*Purpose:*'
     returns the name of an expression as string.

`*Example:*'

            int i=9;
            string s=nameof(i);
            s;
          ==> i
            nameof(s);
          ==> s
            nameof(i+1); //returns the empty string:
          ==> 
            nameof(basering);
          ==> basering
            basering;
          ==>    ? `basering` is undefined
          ==>    ? error occurred in line 7: `  basering;`
            ring r;
            nameof(basering);
          ==> r

* Menu:

See
* names::
* reservedName::
* typeof::

See *note names::; *note reservedName::; *note typeof::.


File: singular.hlp,  Node: names,  Next: ncols,  Prev: nameof,  Up: Functions

5.1.82 names
------------

`*Syntax:*'
     `names ( )'
     `names (' ring_name `)'

`*Type:*'
     list of strings

`*Purpose:*'
     returns the names of all user-defined variables which are ring
     independent (this includes the names of  procedures) or, in the
     second case, which belong to the given ring.

`*Example:*'

            int i=9;
            ring r;
            poly f;
            poly g;
            setring r;
            names();
          ==> [1]:
          ==>    r
          ==> [2]:
          ==>    i
          ==> [3]:
          ==>    fprintf
          ==> [4]:
          ==>    printf
          ==> [5]:
          ==>    sprintf
          ==> [6]:
          ==>    intersect1
          ==> [7]:
          ==>    quotient4
          ==> [8]:
          ==>    quotient5
          ==> [9]:
          ==>    quotient3
          ==> [10]:
          ==>    quotient2
          ==> [11]:
          ==>    quotient1
          ==> [12]:
          ==>    quotient0
          ==> [13]:
          ==>    quot1
          ==> [14]:
          ==>    quot
          ==> [15]:
          ==>    res
          ==> [16]:
          ==>    groebner
          ==> [17]:
          ==>    stdhilb
          ==> [18]:
          ==>    stdfglm
          ==> [19]:
          ==>    LIB
            names(r);
          ==> [1]:
          ==>    g
          ==> [2]:
          ==>    f

* Menu:

See
* nameof::
* reservedName::

See *note nameof::; *note reservedName::.


File: singular.hlp,  Node: ncols,  Next: npars,  Prev: names,  Up: Functions

5.1.83 ncols
------------

`*Syntax:*'
     `ncols (' matrix_expression `)'
     `ncols (' intmat_expression `)'
     `ncols (' ideal_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the number of columns of a matrix or an intmat or the
     number of given generators of the ideal, including zeros.

`*Note:*'
     `size('ideal`)' counts the number of generators which are different
     from zero. (Use `nrows' to get the number of rows of a given matrix
     or intmat.)

`*Example:*'

            ring r;
            matrix m[5][6];
            ncols(m);
          ==> 6
            ideal i=x,0,y;
            ncols(i);
          ==> 3
            size(i);
          ==> 2

* Menu:

See
* matrix::
* nrows::
* size::

See *note matrix::; *note nrows::; *note size::.


File: singular.hlp,  Node: npars,  Next: nres,  Prev: ncols,  Up: Functions

5.1.84 npars
------------

`*Syntax:*'
     `npars (' ring_name `)'

`*Type:*'
     int

`*Purpose:*'
     returns the number of parameters of a ring.

`*Example:*'

            ring r=(23,t,v),(x,a(1..7)),lp;
            // the parameters are t,v
            npars(r);
          ==> 2

* Menu:

See
* par::
* parstr::
* ring::

See *note par::; *note parstr::; *note ring::.


File: singular.hlp,  Node: nres,  Next: nrows,  Prev: npars,  Up: Functions

5.1.85 nres
-----------

`*Syntax:*'
     `nres (' ideal_expression`,' int_expression `)'
     `nres (' module_expression`,' int_expression `)'

`*Type:*'
     resolution

`*Purpose:*'
     computes a free resolution of an ideal or module M which is
     minimized from the second module on (by the standard basis method).

     More precisely, let $A_1$=matrix(M),
     A1=matrix(M), then `nres' computes a free resolution of
     coker(A1)=F0/M

                         A2       A1
           ... ---> F2 ---> F1 ---> F0 -> F0/M -> 0.

$coker(A_1)=F_0/M$
     $$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M\longrightarrow 0,$$

     where the columns of the matrix $A_1$
     A1 are the given set of generators of M.  If the int expression k
     is not zero then the computation stops after k steps and returns a
     list of modules $M_i={\tt module}(A_i)$, i=1..k.
     Mi=module(Ai), i=1..k.
     `nres(M,0)' returns a list of n modules where n is the number of
     variables of the basering.  Let `list L=nres(M,0);' then `L[1]=M'
     is identical to the input, `L[2]' is a minimal set of generators
     for the first syzygy module of  `L[1]', etc.  (L[i]=M_i (${\tt L[i]}=M_i$
     in the notations from above).

`*Example:*'

            ring r=31991,(t,x,y,z,w),ls;
            ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
                    t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
            resolution L=nres(M,0);
            L;
          ==>  1      4      15      18      7      1      
          ==> r <--  r <--  r <--   r <--   r <--  r
          ==> 
          ==> 0      1      2       3       4      5      
          ==> resolution not minimized yet
          ==> 

* Menu:

See
* hres::
* ideal::
* lres::
* module::
* mres::
* res::
* resolution::
* sres::

See *note hres::; *note ideal::; *note lres::; *note module::; *note
mres::; *note res::; *note resolution::; *note sres::.


File: singular.hlp,  Node: nrows,  Next: nvars,  Prev: nres,  Up: Functions

5.1.86 nrows
------------

`*Syntax:*'
     `nrows (' matrix_expression `)'
     `nrows (' intmat_expression `)'
     `nrows (' intvec_expression `)'
     `nrows (' module_expression `)'
     `nrows (' vector_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the number of rows of a matrix, an intmat or an intvec,
     resp. the minimal rank of a free module in which the given module
     or vector lives (the index of the last non-zero component).

`*Note:*'
     Use `ncols' to get the number of columns of a given matrix or
     intmat.

`*Example:*'

            ring R;
            matrix M[2][3];
            nrows(M);
          ==> 2
            nrows(freemodule(4));
          ==> 4
            module m=[0,0,1];
            nrows(m);
          ==> 3
            nrows([0,x,0]);
          ==> 2

* Menu:

See
* gen::
* matrix::
* module::
* ncols::
* vector::

See *note gen::; *note matrix::; *note module::; *note ncols::; *note
vector::.


File: singular.hlp,  Node: nvars,  Next: open,  Prev: nrows,  Up: Functions

5.1.87 nvars
------------

`*Syntax:*'
     `nvars (' ring_name `)'

`*Type:*'
     int

`*Purpose:*'
     returns the number of variables of a ring.

`*Example:*'

            ring r=(23,t,v),(x,a(1..7)),ls;
            // the variables are x,a(1),...,a(7)
            nvars(r);
          ==> 8

* Menu:

See
* npars::
* ring::
* var::
* varstr::

See *note npars::; *note ring::; *note var::; *note varstr::.


File: singular.hlp,  Node: open,  Next: option,  Prev: nvars,  Up: Functions

5.1.88 open
-----------

`*Syntax:*'
     `open (' link_expression `)'

`*Type:*'
     none

`*Purpose:*'
     opens a link.

`*Example:*'

          link l="MPtcp:launch";
          open(l);  // start SINGULAR "server" on localhost in batchmode
          close(l); // shut down SINGULAR server

* Menu:

See
* close::
* link::

See *note close::; *note link::.


File: singular.hlp,  Node: option,  Next: ord,  Prev: open,  Up: Functions

5.1.89 option
-------------

`*Syntax:*'
     `option ()'

`*Type:*'
     string

`*Purpose:*'
     lists all defined options.

`*Syntax:*'
     `option (' option_name `)'

`*Type:*'
     none

`*Purpose:*'
     sets an option.

`*Note:*'
     To disable an option, use the prefix `no'.

`*Syntax:*'
     `option ( get )'

`*Type:*'
     intvec

`*Purpose:*'
     dumps the state of all options to an intvec.

`*Syntax:*'
     `option ( set,' intvec_expression `)'

`*Type:*'
     none

`*Purpose:*'
     restores the state of all options from an intvec (produced by
     `option(get)').

`*Values:*'
     The following options are used to manipulate the behavior of
     computations and act like boolean switches. Use the prefix `no' to
     disable an option. Notice that some options are ring dependent and
     reset to their default values on a change of the current basering.

     `none'
          turns off all options (including the `prompt' option).

     `returnSB'
          the functions `syz', `intersect', `quotient', `modulo' return
          a standard base instead of a generating set if `returnSB' is
          set. This option should not be used for `lift'.

     `fastHC'
          tries to the find the highest corner of the staircase (HC) as
          fast as possible during a standard basis computation (only
          used for local orderings).

     `intStrategy'
          avoids division of coefficients during standard basis
          computations. This option is ring dependent. By default, it is
          set for rings with characteristic 0 and not set for all other
          rings.

     `oldStd'
          uses a more lazy approach in std computations, which was used
          in Singular version before 2-0 (and which may lead to faster
          or slower computations, depending on the example)

     `minRes'
          special (additional) minimizing during computations (`res',
          `mres'),
          assumes homogeneous case and degree-compatible ordering.

     `notRegularity'
          disables the regularity bound for `res' and `mres' (see *note
          regularity::).

     `notSugar'
          disables the sugar strategy during standard basis computation.

     `notBuckets'
          disables the bucket representation of polynomials during
          standard basis computations. This option usually decreases the
          memory usage but increases the computation time. It should
          only be set for memory-critical standard basis computations.

     `prot'
          shows protocol information indicating the progress during the
          following computations: `facstd', `fglm', `groebner', `lres',
          `mres', `minres', `mstd', `res', `sres', `std', `stdfglm',
          `stdhilb', `syz'.  See below for more details.

     `redSB'
          computes a reduced standard basis in any standard basis
          computation.

     `redTail'
          reduction of the tails of polynomials during standard basis
          computations. This option is ring dependent. By default, it is
          set for rings with global degree orderings and not set for all
          other rings.

     `redThrough'
          for inhomogeneous input, polynomial reductions during standard
          basis computations are never postponed, but always finished
          through. This option is ring   dependent. By default, it is
          set for rings with global degree orderings and not set for all
          other rings.

     `sugarCrit'
          uses criteria similar to the homogeneous case to keep more
          useless pairs.

     `weightM'
          automatically computes suitable weights for the weighted ecart
          and the weighted sugar method.


     The following options, which also control computations, are
     special, since they are not manipulated by the `option' command but
     by a direct assignment of a value. Reset the option by assigning
     the value 0; the command `option(none)' will not reset them! If
     there is a non-zero value assigned, the command `option()' prints
     the option.

     `multBound'
          a multiplicity bound is set (see *note multBound::).

     `degBound'
          a degree bound is set (see *note degBound::).


     The last set of options controls the output of SINGULAR:

     `Imap'
          shows the mapping of variables with the fetch and imap
          commands.

     `loadLib'
          shows loading of libraries (set by default).

     `debugLib'
          warns about syntax errors during loading of libraries.

     `loadProc'
          shows loading of procedures from libraries.

     `mem'
          shows memory usage in square brackets (see *note memory::).

     `prompt'
          shows prompt (`>', resp. `.') if ready for input (default).

     `reading'
          shows the number of characters read from a file.

     `redefine'
          warns about variable redefinitions (set by default).

     `usage'
          shows correct usage in error messages (set by default).

`*Example:*'

            option(prot);
            option();
          ==> //options: prot redefine usage prompt
            option(notSugar);
            option();
          ==> //options: prot notSugar redefine usage prompt
            option(noprot);
            option();
          ==> //options: notSugar redefine usage prompt
            option(none);
            option();
          ==> //options: none
            ring r=0,x,dp;
            degBound=22;
            option();
          ==> //options: degBound redTail redThrough intStrategy
            intvec i=option(get);
            option(none);
            option(set,i);
            option();
          ==> //options: degBound redTail redThrough intStrategy


The output reported on `option(prot)' has the following meaning:

  `facstd'   `F'      found a new factor
                      all other characters: like the output of
                      `std' and `reduce'
  `fglm'     `.'      basis monomial found
             `+'      edge monomial found
             `-'      border monomial found
  `groebner'          all characters: like the output of `std'
  `lres'     `.'      minimal syzygy found
             `n'      slanted degree, i.e., row of Betti matrix
             `(mn)'   calculate in module n
             `g'      pair found giving reductum and syzygy
  `mres'     `[d]'    computations of the d-th syzygy module
                      all other characters: like the output of
                      `std'
  `minres'   `[d]'    minimizing of the d-th syzygy module
  `mstd'              all characters: like the output of `std'
  `reduce'   `r'      reduced a leading term
             `t'      reduced a non-leading term
  `res'      `[d]'    computations of the d-th syzygy module
                      all other characters: like the output of
                      `std'
  `sres'     `.'      syzygy found
             `(n)'    n elements remaining
             `[n]'    finished module n
  `std'      `[m:n]'  internal ring change to poly representation
                      with exponent bound m and n words in exponent
                      vector
             `s'      found a new element of the standard basis
             `-'      reduced a pair/S-polynomial to 0
             `.'      postponed a reduction of a pair/S-polynomial
             `h'      used Hilbert series criterion
             `H(d)'   found a 'highest corner' of degree d, no need
                      to consider higher degrees
             `(n)'    n critical pairs are still to be reduced
             `(S:n)'  doing complete reduction of n elements
             `d'      the degree of the leading terms is currently
                      d
  `stdfglm'           all characters in first part: like the output
                      of `std'
                      all characters in second part: like the
                      output of `fglm'
  `stdhilb'           all characters: like the output of `std'
  `syz'               all characters: like the output of `std'

* Menu:

See
* degBound::
* multBound::
* std::

See *note degBound::; *note multBound::; *note std::.


File: singular.hlp,  Node: ord,  Next: ordstr,  Prev: option,  Up: Functions

5.1.90 ord
----------

`*Syntax:*'
     `ord (' poly_expression `)'
     `ord (' vector_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the (weighted) degree of the initial term of a polynomial
     or a vector; the weights are the weights used for the first block
     of the ring ordering.

`*Note:*'
     `ord(0)' is `-1'.

`*Example:*'

            ring r=7,(x,y),wp(2,3);
            ord(0);
          ==> -1
            poly f=x2+y3;  // weight on y is 3
            ord(f);
          ==> 9
            ring R=7,(x,y),ws(2,3);
            poly f=x2+y3;
            ord(f);
          ==> 4
            vector v=[x2,y];
            ord(v);
          ==> 3

* Menu:

See
* deg::
* poly::
* vector::

See *note deg::; *note poly::; *note vector::.


File: singular.hlp,  Node: ordstr,  Next: par,  Prev: ord,  Up: Functions

5.1.91 ordstr
-------------

`*Syntax:*'
     `ordstr (' ring_name `)'

`*Type:*'
     string

`*Purpose:*'
     returns the description of the monomial ordering of the ring.

`*Example:*'

            ring r=7,(x,y),wp(2,3);
            ordstr(r);
          ==> wp(2,3),C

* Menu:

See
* charstr::
* parstr::
* ring::
* varstr::

See *note charstr::; *note parstr::; *note ring::; *note varstr::.


File: singular.hlp,  Node: par,  Next: pardeg,  Prev: ordstr,  Up: Functions

5.1.92 par
----------

`*Syntax:*'
     `par (' int_expression `)'

`*Type:*'
     number

`*Purpose:*'
     `par(n);' returns the n-th parameter of the basering.

`*Note:*'
     This command should only be used if the basering has at least one
     parameter.

`*Example:*'

            ring r=(0,a,b,c),(x,y,z),dp;
            char(r);  // char to get the characteristic
          ==> 0
            par(2);   // par to get the n-th parameter
          ==> (b)

* Menu:

See
* char::
* npars::
* parstr::
* ring::
* var::

See *note char::; *note npars::; *note parstr::; *note ring::; *note
var::.


File: singular.hlp,  Node: pardeg,  Next: parstr,  Prev: par,  Up: Functions

5.1.93 pardeg
-------------

`*Syntax:*'
     `pardeg (' number_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the degree of a number considered as a polynomial in the
     ring parameters.

`*Example:*'

            ring r=(0,a,b,c),(x,y,z),dp;
            pardeg(a^2*b);
          ==> 3

* Menu:

See
* deg::
* number::
* ring::
* var::

See *note deg::; *note number::; *note ring::; *note var::.


File: singular.hlp,  Node: parstr,  Next: preimage,  Prev: pardeg,  Up: Functions

5.1.94 parstr
-------------

`*Syntax:*'
     `parstr (' ring_name `)'
     `parstr (' int_expression `)'
     `parstr (' ring_name`,' int_expression `)'

`*Type:*'
     string

`*Purpose:*'
     returns the list of parameters of the ring as a string or the name
     of the n-th parameter where n is given by the int_expression.
     If the ring_name is omitted, the basering is used, thus `parstr(n)'
     is equivalent to `parstr(basering,n)'.

`*Example:*'

            ring r=(7,a,b,c),(x,y),wp(2,3);
            parstr(r);
          ==> a,b,c
            parstr(2);
          ==> b
            parstr(r,3);
          ==> c

* Menu:

See
* charstr::
* npars::
* ordstr::
* par::
* ring::
* varstr::

See *note charstr::; *note npars::; *note ordstr::; *note par::; *note
ring::; *note varstr::.


File: singular.hlp,  Node: preimage,  Next: prime,  Prev: parstr,  Up: Functions

5.1.95 preimage
---------------

`*Syntax:*'
     `preimage (' ring_name`,' map_name`,' ideal_name `)'
     `preimage (' ring_name`,' ideal_expression`,' ideal_name `)'

`*Type:*'
     ideal

`*Purpose:*'
     returns the preimage of an ideal under a given map.
     The second argument has to be a map from the basering to the given
     ring (or an ideal defining such a map), and the ideal has to be an
     ideal in the given ring.

`*Note:*'
     To compute the kernel of a map, the preimage of zero has to be
     determined.  Hence there is no special command for computing the
     kernel of a map in SINGULAR.

`*Example:*'

            ring r1=32003,(x,y,z,w),lp;
            ring r=32003,(x,y,z),dp;
            ideal i=x,y,z;
            ideal i1=x,y;
            ideal i0=0;
            map f=r1,i;
            setring r1;
            ideal i1=preimage(r,f,i1);
            i1;
          ==> i1[1]=w
          ==> i1[2]=y
          ==> i1[3]=x
            // the kernel of f
            preimage(r,f,i0);
          ==> _[1]=w

* Menu:

See
* ideal::
* map::
* ring::

See *note ideal::; *note map::; *note ring::.


File: singular.hlp,  Node: prime,  Next: print,  Prev: preimage,  Up: Functions

5.1.96 prime
------------

`*Syntax:*'
     `prime (' int_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the largest prime less then 32004 smaller or equal to the
     argument;
     returns 2 for all arguments smaller than 3.

`*Example:*'

            prime(32004);
          ==> 32003
            prime(0);
          ==> 2
            prime(-1);
          ==> 2

* Menu:

See
* general_lib::
* int::

See *note general_lib::; *note int::.


File: singular.hlp,  Node: print,  Next: printf,  Prev: prime,  Up: Functions

5.1.97 print
------------

`*Syntax:*'
     `print (' expression `)'
     `print (' expression`, "betti" )'
     `print (' expression`,' format_string `)'

`*Type:*'
     none (for the first two calling sequences), resp.
     string (for the last calling sequence)

`*Purpose:*'
     The first form prints the expression to the terminal and has no
     return value. Use the format string `%p' to print into a string
     (see below).
     The second form prints the graded Betti numbers from a matrix. See
     the description of the format string `"betti"' below for more
     details.
     The last form returns the printed output as a string. The format
     string determines which format to use to generate the string.

     The following format strings are supported:

     `"betti"'
          The Betti numbers are printed in a matrix-like format where
          the entry $d$ in row $i$ and column $j$
          d in row i and column j is the minimal number of generators in
          degree $i+j$ of the $j$-th
          i+j of the j-th  syzygy module of $R^n/M$ (the 0th and 1st syzygy module of $R^n/M$ is $R^n$ and $M$, resp.).
          R^n/M (the 0th and 1st syzygy module of R^n/M are R^n and M,
          resp.).

     `"%s"'
          returns `string(' expression `)'

     `"%2s"'
          similar to `"%s"', except that newlines are inserted after
          every comma and at the end

     `"%l"'
          similar to `"%s"', except that each object is embraced by its
          type such that it can be directly used for "cutting and
          pasting"

     `"%2l"'
          similar to `"%l"', except that newlines are inserted after
          every comma and at the end

     `"%;"'
          returns the string equivalent to typing `expression;'

     `"%t"'
          returns the string equivalent to typing `type expression;'

     `"%p"'
          returns the string equivalent to typing `print(expression);'

     `"%b"'
          returns the string equivalent to typing `print(expression,
          "betti");'

`*Example:*'

            ring r=0,(x,y,z),dp;
            module m=[1,y],[0,x+z];
            m;
          ==> m[1]=y*gen(2)+gen(1)
          ==> m[2]=x*gen(2)+z*gen(2)
            print(m);  // the columns generate m
          ==> 1,0, 
          ==> y,x+z
            string s=print(m,"%s"); s;
          ==> y*gen(2)+gen(1),x*gen(2)+z*gen(2)
            s=print(m,"%2s"); s;
          ==> y*gen(2)+gen(1),
          ==> x*gen(2)+z*gen(2)
          ==> 
            s=print(m,"%l"); s;
          ==> module(y*gen(2)+gen(1),x*gen(2)+z*gen(2))
            s=print(m,"%;"); s;
          ==> m[1]=y*gen(2)+gen(1)
          ==> m[2]=x*gen(2)+z*gen(2)
          ==> 
            s=print(m,"%t"); s;
          ==> // m                    [0]  module, rk 2, 2 generator(s)
          ==> m[1]=y*gen(2)+gen(1)
          ==> m[2]=x*gen(2)+z*gen(2)
            s=print(m,"%p"); s;
          ==> 1,0, 
          ==> y,x+z
          ==> 
            intmat M=betti(mres(m,0));
            print(M,"betti");
          ==>            0     1
          ==> ------------------
          ==>     0:     1     1
          ==> ------------------
          ==> total:     1     1
            list l=r,M;
            s=print(l,"%s"); s;
          ==> (0),(x,y,z),(dp(3),C),1,1 
            s=print(l,"%2s"); s;
          ==> (0),(x,y,z),(dp(3),C),
          ==> 1,1 
          ==> 
            s=print(l,"%l"); s;
          ==> list("(0),(x,y,z),(dp(3),C)",intmat(intvec(1,1 ),1,2))

* Menu:

See
* Type conversion and casting::
* betti::
* dbprint::
* fprintf::
* printf::
* short::
* sprintf::
* string type cast::
* type::

See *note Type conversion and casting::; *note betti::; *note dbprint::;
*note fprintf::; *note printf::; *note short::; *note sprintf::; *note
string type cast::; *note type::.


File: singular.hlp,  Node: printf,  Next: prune,  Prev: print,  Up: Functions

5.1.98 printf
-------------

Procedure from library `standard.lib' (*note standard_lib::).

*Syntax:*
     `printf (' string_expression `[,' any_expressions`] )'

*Return:*
     none

*Purpose:*
     `printf(fmt,...);' performs output formatting. The first argument
     is a format control string. Additional arguments may be required,
     depending on the content of the control string. A series of output
     characters is generated as directed by the control string; these
     characters are displayed (i.e., printed to standard out).
     The control string `fmt' is simply text to be copied, except that
     the string may contain conversion specifications.
     Do `help print;' for a listing of valid conversion specifications.
     As an addition to the conversions of `print', the `%n' and `%2'
     conversion specification does not consume an additional argument,
     but simply generates a newline character.

*Note:*
     If one of the additional arguments is a list, then it should be
     enclosed once more into a `list()' command, since passing a list as
     an argument flattens the list by one level.

*Example:*
       ring r=0,(x,y,z),dp;
     module m=[1,y],[0,x+z];
     intmat M=betti(mres(m,0));
     list l=r,m,M;
     printf("s:%s,l:%l",1,2);
     ==> s:1,l:int(2)
     printf("s:%s",l);
     ==> s:(0),(x,y,z),(dp(3),C)
     printf("s:%s",list(l));
     ==> s:(0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
     printf("2l:%2l",list(l));
     ==> 2l:list("(0),(x,y,z),(dp(3),C)",
     ==> module(y*gen(2)+gen(1),
     ==> x*gen(2)+z*gen(2)),
     ==> intmat(intvec(1,1 ),1,2))
     ==> 
     printf("%p",list(l));
     ==> [1]:
     ==>    //   characteristic : 0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y z 
     ==> //        block   2 : ordering C
     ==> [2]:
     ==>    _[1]=y*gen(2)+gen(1)
     ==>    _[2]=x*gen(2)+z*gen(2)
     ==> [3]:
     ==>    1,1 
     ==> 
     printf("%;",list(l));
     ==> [1]:
     ==>    //   characteristic : 0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y z 
     ==> //        block   2 : ordering C
     ==> [2]:
     ==>    _[1]=y*gen(2)+gen(1)
     ==>    _[2]=x*gen(2)+z*gen(2)
     ==> [3]:
     ==>    1,1 
     ==> 
     printf("%b",M);
     ==>            0     1
     ==> ------------------
     ==>     0:     1     1
     ==> ------------------
     ==> total:     1     1
     ==> 

* Menu:

See also:
* fprintf::
* print::
* sprintf::
* string::

*See also:* *note fprintf::; *note print::; *note sprintf::; *note
string::.


File: singular.hlp,  Node: prune,  Next: qhweight,  Prev: printf,  Up: Functions

5.1.99 prune
------------

`*Syntax:*'
     `prune (' module_expression `)'

`*Type:*'
     module

`*Purpose:*'
     returns the module minimally embedded in a free module such that
     the corresponding factor modules are isomorphic.

`*Example:*'

            ring r=0,(x,y,z),dp;
            module m=gen(1),gen(3),[x,y,0,z],[x+y,0,0,0,1];
            print(m);
          ==> 1,0,x,x+y,
          ==> 0,0,y,0,  
          ==> 0,1,0,0,  
          ==> 0,0,z,0,  
          ==> 0,0,0,1   
            print(prune(m));
          ==> y,
          ==> z 

* Menu:

See
* module::

See *note module::.


File: singular.hlp,  Node: qhweight,  Next: quot,  Prev: prune,  Up: Functions

5.1.100 qhweight
----------------

`*Syntax:*'
     `qhweight (' ideal_expression `)'

`*Type:*'
     intvec

`*Purpose:*'
     computes the weight vector of the variables for a quasihomogeneous
     ideal.  If the input is not weighted homogeneous, an intvec of
     zeros is returned.

`*Example:*'

            ring h1=32003,(t,x,y,z),dp;
            ideal i=x4+y3+z2;
            qhweight(i);
          ==> 0,3,4,6

* Menu:

See
* ideal::
* intvec::
* weight::

See *note ideal::; *note intvec::; *note weight::.


File: singular.hlp,  Node: quot,  Next: quote,  Prev: qhweight,  Up: Functions

5.1.101 quot
------------

Procedure from library `standard.lib' (*note standard_lib::).

*Syntax:*
     `quot (' module_expression`,' module_expression `)'
     `quot (' module_expression`,' module_expression`,' int_expression
     `)'
     `quot (' ideal_expression`,' ideal_expression `)'
     `quot (' ideal_expression`,' ideal_expression`,' int_expression `)'

*Type:*
     ideal

*Syntax:*
     `quot (' module_expression`,' ideal_expression `)'

*Type:*
     module

*Purpose:*
     computes the quotient of the 1st and the 2nd argument.  If a 3rd
     argument 'n' is given the n-th method is used (n=1...5).

*Example:*
       ring r=181,(x,y,z),(c,ls);
     ideal id1=maxideal(4);
     ideal id2=x2+xyz,y2-z3y,z3+y5xz;
     option(prot);
     ideal id3=quotient(id1,id2);
     ==> [1023:1]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
     ==> product criterion:12 chain criterion:0
     ==> {3}[1023:3]8(2)s(4)s(5)s9s.s.s.s.s.s
     ==> product criterion:0 chain criterion:39
     id3;
     ==> id3[1]=z2
     ==> id3[2]=yz
     ==> id3[3]=y2
     ==> id3[4]=xz
     ==> id3[5]=xy
     ==> id3[6]=x2
     ideal id4=quot(id1,id2,1);
     ==> [1023:2]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
     ==> product criterion:0 chain criterion:0
     ==> (S:3)rtrtrt
     ==> {1}[1023:3]4(2)s(4)s(5)s5s.s(3)s(2)sss
     ==> product criterion:0 chain criterion:39
     ==> {1}[1023:3]4(5)s(4)s(3)s(2)sss
     ==> product criterion:0 chain criterion:9
     ==> [255:3]3(11)s(10)sss(9)s(10)s(8)ss(7)s(8)s(6)s(7)s4(5)-----
     ==> product criterion:12 chain criterion:9
     ==> {1}[1023:3]4(2)sss
     ==> product criterion:0 chain criterion:12
     ==> [255:3]2(8)s(7)s(6)s3(5)ssssss4-----
     ==> product criterion:15 chain criterion:3
     id4;
     ==> id4[1]=z2
     ==> id4[2]=yz
     ==> id4[3]=xz
     ==> id4[4]=y2
     ==> id4[5]=xy
     ==> id4[6]=x2
     ideal id5=quot(id1,id2,2);
     ==> [1023:2]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
     ==> product criterion:0 chain criterion:0
     ==> (S:3)rtrtrt
     ==> {1}[1023:3]4(2)sss
     ==> product criterion:0 chain criterion:12
     ==> {1}[1023:3]4(5)s(4)s(3)s(2)sss
     ==> product criterion:0 chain criterion:9
     ==> [255:3]2(8)s(7)s(6)s3(5)s(4)s(3)s(2)sss
     ==> product criterion:15 chain criterion:0
     id5;
     ==> id5[1]=z2
     ==> id5[2]=yz
     ==> id5[3]=xz
     ==> id5[4]=y2
     ==> id5[5]=xy
     ==> id5[6]=x2

* Menu:

See also:
* quotient::

*See also:* *note quotient::.


File: singular.hlp,  Node: quote,  Next: quotient,  Prev: quot,  Up: Functions

5.1.102 quote
-------------

`*Syntax:*'
     `quote (' expression `)'

`*Type:*'
     none

`*Purpose:*'
     prevents expressions from evaluation. Used only in connections with
     write to MPfile links, prevents evaluation of an expression before
     sending it to an other SINGULAR process.  Within a quoted
     expression, the quote can be "undone" by an `eval' (i.e., each eval
     "undoes" the effect of exactly one quote).

`*Example:*'

            link l="MPfile:w example.mp";
            ring r=0,(x,y,z),ds;
            ideal i=maxideal(3);
            ideal j=x7,x2,z;
            option(prot);
            // compute i+j before writing, but not std
            write (l, quote(std(eval(i+j))));
            close(l);
            // now read it in again and evaluate:
            read(l);
          ==> [1023:1]1(12)s2(11)s3(10)--s(7)s(6)-----7-
          ==> product criterion:4 chain criterion:0
          ==> _[1]=z
          ==> _[2]=x2
          ==> _[3]=xy2
          ==> _[4]=y3
            close(l);

* Menu:

See
* MPfile links::
* eval::
* write::

See *note MPfile links::; *note eval::; *note write::.


File: singular.hlp,  Node: quotient,  Next: random,  Prev: quote,  Up: Functions

5.1.103 quotient
----------------

`*Syntax:*'
     `quotient (' ideal_expression`,' ideal_expression `)'
     `quotient (' module_expression`,' module_expression `)'

`*Type:*'
     ideal

`*Syntax:*'
     `quotient (' module_expression`,' ideal_expression `)'

`*Type:*'
     module

`*Purpose:*'
     computes the ideal quotient, resp. module quotient. Let `R' be the
     basering, `I,J' ideals and `M' a module in R^n.  ${\tt R}^n$.
     Then

        * `quotient(I,J)'= {a in R | aJ in I } $\{a \in R \mid aJ \subset I\}$,

        * `quotient(M,J)'= {b in R | bJ in M }.  $\{b \in R^n \mid bJ \subset M\}$.

`*Example:*'

          ring r=181,(x,y,z),(c,ls);
          ideal id1=maxideal(3);
          ideal id2=x2+xyz,y2-z3y,z3+y5xz;
          ideal id6=quotient(id1,id2);
          id6;
          ==> id6[1]=z
          ==> id6[2]=y
          ==> id6[3]=x
          quotient(id2,id1);
          ==> _[1]=z2
          ==> _[2]=yz
          ==> _[3]=y2
          ==> _[4]=xz
          ==> _[5]=xy
          ==> _[6]=x2
          module m=x*freemodule(3),y*freemodule(2);
          ideal id3=x,y;
          quotient(m,id3);
          ==> _[1]=[1]
          ==> _[2]=[0,1]
          ==> _[3]=[0,0,x]

* Menu:

See
* fglmquot::
* ideal::
* module::

See *note fglmquot::; *note ideal::; *note module::.


File: singular.hlp,  Node: random,  Next: read,  Prev: quotient,  Up: Functions

5.1.104 random
--------------

`*Syntax:*'
     `random (' int_expression`,' int_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns a random integer between the integer given by the first
     int_expression and the one given by the second int_expression.

`*Syntax:*'
     `random (' int_expression`,' int_expression`,' int_expression `)'

`*Type:*'
     intmat

`*Purpose:*'
     returns a random intmat where the size is given by the second
     (number of rows) and third argument (number of columns). The
     absolute value of the entries of the matrix is smaller than or
     equal to the integer given as the first argument.

`*Note:*'
     The random generator can be set to a start value with the function
     `system', resp. by a command line option.

`*Example:*'

            random(1,1000);
          ==> 35
            random(1,2,3);
          ==> 0,0,0,
          ==> 1,1,-1 
            system("random",210);  // start random generator with 210
            random(-1000,1000);
          ==> 707
            random(-1000,1000);
          ==> 284
            system("random",210);
            random(-1000,1000);    // the same random values again
          ==> 707

* Menu:

See
* Command line options::
* int::
* intmat::
* system::

See *note Command line options::; *note int::; *note intmat::; *note
system::.


File: singular.hlp,  Node: read,  Next: reduce,  Prev: random,  Up: Functions

5.1.105 read
------------

`*Syntax:*'
     `read (' link_expression `)'
     for DBM links:
     `read (' link_expression `)'
     `read (' link_expression`,' string_expression `)'

`*Type:*'
     any

`*Purpose:*'
     reads data from a link.
     For ASCII links, the content of the entire file is returned as one
     string. If the ASCII link is the empty string, `read' reads from
     standard input.
     For MP links, one expression is read from the link and returned
     after evaluation.
     For MPtcp links the `read' command blocks as long as there is no
     data to be read from the link. The `status' command can be used to
     check whether or not there is data to be read.
     For DBM links, a `read' with one argument returns the value of the
     next entry in the data base, and a `read' with two arguments
     returns the value to the key given as the second argument from the
     data base.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            ideal i=x+y,z3+22y;
            // write the ideal i to the file save_i
            write(":w save_i",i);
            ring r0=0,(x,y,z),Dp;
            // create an ideal k equal to the content
            // of the file save_i
            string s="ideal k="+read("save_i")+";";
            execute(s);
            k;
          ==> k[1]=x+y
          ==> k[2]=z3+22y

* Menu:

See
* execute::
* getdump::
* link::
* status::
* write::

See *note execute::; *note getdump::; *note link::; *note status::;
*note write::.


File: singular.hlp,  Node: reduce,  Next: regularity,  Prev: read,  Up: Functions

5.1.106 reduce
--------------

`*Syntax:*'
     `reduce (' poly_expression`,' ideal_expression `)'
     `reduce (' poly_expression`,' ideal_expression`,' int_expression
     `)'
     `reduce (' poly_expression`,' ideal_expression`,' poly_expression
     `)'
     `reduce (' vector_expression`,' ideal_expression `)'
     `reduce (' vector_expression`,' ideal_expression`,' int_expression
     `)'
     `reduce (' vector_expression`,' module_expression `)'
     `reduce (' vector_expression`,' module_expression`,' int_expression
     `)'
     `reduce (' vector_expression`,' module_expression`,'
     poly_expression `)'
     `reduce (' ideal_expression`,' ideal_expression `)'
     `reduce (' ideal_expression`,' ideal_expression`,' int_expression
     `)'
     `reduce (' ideal_expression`,' ideal_expression`,'
     matrix_expression `)'
     `reduce (' module_expression`,' ideal_expression `)'
     `reduce (' module_expression`,' ideal_expression`,' int_expression
     `)'
     `reduce (' module_expression`,' module_expression `)'
     `reduce (' module_expression`,' module_expression`,' int_expression
     `)'
     `reduce (' module_expression`,' module_expression`,'
     matrix_expression `)'

`*Type:*'
     the type of the first argument

`*Purpose:*'
     reduces a polynomial, vector, ideal  or module to its normal form
     with respect to an ideal or module represented by a standard basis.
     Returns 0 if and only if the polynomial (resp. vector, ideal,
     module) is an element (resp. subideal, submodule) of the ideal
     (resp. module).  The result may have no meaning if the second
     argument is not a standard basis.
     The third (optional) argument 1 of type int forces a reduction
     which considers only the leading term and does no tail reduction.
     If a third argument `u' of type poly or matrix is given, the first
     argument `p' is replaced by `p/u'.  This works only for zero
     dimensional ideals (resp. modules) in the second argument and
     gives, even in a local ring, a reduced normal form which is the
     projection to the quotient by the ideal (resp. module).

`*Note:*'
     The commands `reduce' and `NF' are synonymous.

`*Example:*'

            ring r1 = 0,(z,y,x),ds;
            poly s1=2x5y+7x2y4+3x2yz3;
            poly s2=1x2y2z2+3z8;
            poly s3=4xy5+2x2y2z3+11x10;
            ideal i=s1,s2,s3;
            ideal j=std(i);
            reduce(3z3yx2+7y4x2+yx5+z12y2x2,j);
          ==> -yx5+2401/81y14x2+2744/81y11x5+392/27y8x8+224/81y5x11+16/81y2x14
            reduce(3z3yx2+7y4x2+yx5+z12y2x2,j,1);
          ==> -yx5+z12y2x2

* Menu:

See
* ideal::
* module::
* std::
* vector::

See *note ideal::; *note module::; *note std::; *note vector::.


File: singular.hlp,  Node: regularity,  Next: repart,  Prev: reduce,  Up: Functions

5.1.107 regularity
------------------

`*Syntax:*'
     `regularity (' list_expression `)'
     `regularity (' resolution_expression `)'

`*Type:*'
     int

`*Purpose:*'
     computes the regularity of a homogeneous ideal, resp. module, from
     a minimal resolution given by the list expression.
     Let

            K[X]e(a,n) --> ... --> (+) K[X]e(a,0) --> I --> 0

     be a minimal resolution with homogeneous maps of degree 0.  The
     regularity is the smallest number s with the property
     deg(e(a,i)) <= s+i for all i.  \noindent
     Let $0 \rightarrow\ \bigoplus_a K[x]e_{a,n}\ \rightarrow\ \dots
       \rightarrow\ \bigoplus_a K[x]e_{a,0}\ \rightarrow\
       I\ \rightarrow\ 0$
     be a minimal resolution of I considered with homogeneous maps of degree 0.
     The regularity is the smallest number $s$ with the property deg($e_{a,i})
      \leq s+i$ for all $i$.

`*Note:*'
     If applied to a non minimal resolution only an upper bound is
     returned.
     If the input to the commands `res' and `mres' is homogeneous the
     regularity is computed and used as a degree bound during the
     computation unless `option(notRegularity);' is given.

`*Example:*'

            ring rh3=32003,(w,x,y,z),(dp,C);
            poly f=x11+y10+z9+x5y2+x2y2z3+xy3*(y2+x)^2;
            ideal j=homog(jacob(f),w);
            def jr=res(j,0);
            regularity(jr);
          ==> 25
            // example for upper bound behavior:
            list jj=jr;
            regularity(jj);
          ==> 25
            jj=nres(j,0);
            regularity(jj);
          ==> 27
            jj=minres(jj);
            regularity(jj);
          ==> 25

* Menu:

See
* list::
* minres::
* mres::
* option::
* res::
* resolution::
* sres::

See *note list::; *note minres::; *note mres::; *note option::; *note
res::; *note resolution::; *note sres::.


File: singular.hlp,  Node: repart,  Next: res,  Prev: regularity,  Up: Functions

5.1.108 repart
--------------

`*Syntax:*'
     `repart (' number_expression `)'

`*Type:*'
     number

`*Purpose:*'
     returns the real part of a number from a complex ground field,
     returns its argument otherwise.

`*Example:*'

            ring r=(complex,i),x,dp;
            repart(1+2*i);
          ==> 1

* Menu:

See
* impart::

See *note impart::.


File: singular.hlp,  Node: res,  Next: reservedName,  Prev: repart,  Up: Functions

5.1.109 res
-----------

Procedure from library `standard.lib' (*note standard_lib::).

`*Syntax:*'
     `res (' ideal_expression`,' int_expression `[,' any_expression `])'

     `res (' module_expression`,' int_expression `[,' any_expression
     `])'

`*Type:*'
     resolution

`*Purpose:*'
     computes a (possibly minimal) free resolution of an ideal or module
     using a heuristically chosen method.
     The second (int) argument (say, `k') specifies the length of the
     resolution. If it is not positive then `k' is assumed to be the
     number of variables of the basering.
     If a third argument is given, the returned resolution is minimized.

     Depending on the input, the returned resolution is computed using
     the following methods:

     *quotient rings:*
          `nres' (classical method using syzygies) , see *note nres::.

     *homogeneous ideals and k=0:*
          `lres' (La'Scala's method), see *note lres::.

     *not minimized resolution and (homogeneous input with k not 0, or local rings):*
          `sres' (Schreyer's method), see *note sres::.

     *all other inputs:*
          `mres' (classical method), see *note mres::.

`*Note:*'
     Accessing single elements of a resolution may require that some
     partial computations have to be finished and may therefore take
     some time.

* Menu:

See also
* betti::
* hres::
* ideal::
* lres::
* minres::
* module::
* mres::
* nres::
* resolution::
* sres::

See also *note betti::; *note hres::; *note ideal::; *note lres::; *note
minres::; *note module::; *note mres::; *note nres::; *note
resolution::; *note sres::.

*Example:*
       ring r=0,(x,y,z),dp;
     ideal i=xz,yz,x3-y3;
     def l=res(i,0); // homogeneous ideal: uses lres
     l;
     ==>  1      3      2      
     ==> r <--  r <--  r
     ==> 
     ==> 0      1      2      
     ==> resolution not minimized yet
     ==> 
     print(betti(l), "betti"); // input to betti may be of type resolution
     ==>            0     1     2
     ==> ------------------------
     ==>     0:     1     -     -
     ==>     1:     -     2     1
     ==>     2:     -     1     1
     ==> ------------------------
     ==> total:     1     3     2
     l[2];         // element access may take some time
     ==> _[1]=-x*gen(1)+y*gen(2)
     ==> _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)
     i=i,x+1;
     l=res(i,0);   // inhomogeneous ideal: uses mres
     l;
     ==>  1      3      3      1      
     ==> r <--  r <--  r <--  r
     ==> 
     ==> 0      1      2      3      
     ==> resolution not minimized yet
     ==> 
     ring rs=0,(x,y,z),ds;
     ideal i=imap(r,i);
     def l=res(i,0); // local ring not minimized: uses sres
     l;
     ==>   1       1       
     ==> rs <--  rs
     ==> 
     ==> 0       1       
     ==> resolution not minimized yet
     ==> 
     res(i,0,0);     // local ring and minimized: uses mres
     ==>   1       1       
     ==> rs <--  rs
     ==> 
     ==> 0       1       
     ==> 


File: singular.hlp,  Node: reservedName,  Next: resultant,  Prev: res,  Up: Functions

5.1.110 reservedName
--------------------

`*Syntax:*'
     `reservedName ()'

`*Type:*'
     none

`*Syntax:*'
     `reservedName (' string_expression `)'

`*Type:*'
     int

`*Purpose:*'
     prints a list of all reserved identifiers (first form) or tests
     whether the string is a reserved identifier (second form).

`*Example:*'

          reservedName();
          ==> ... // output skipped
            reservedName("ring");
          ==> 1
            reservedName("xyz");
          ==> 0

* Menu:

See
* names::
* string::

See *note names::; *note string::.


File: singular.hlp,  Node: resultant,  Next: rvar,  Prev: reservedName,  Up: Functions

5.1.111 resultant
-----------------

`*Syntax:*'
     `resultant (' poly_expression`,' poly_expression`,' ring_variable
     `)'

`*Type:*'
     poly

`*Purpose:*'
     computes the resultant of the first and second argument with
     respect to the variable given as the third argument.

`*Example:*'

            ring r=32003,(x,y,z),dp;
            poly f=3*(x+2)^3+y;
            poly g=x+y+z;
            resultant(f,g,x);
          ==> 3y3+9y2z+9yz2+3z3-18y2-36yz-18z2+35y+36z-24

* Menu:

See
* poly::
* ring::

See *note poly::; *note ring::.


File: singular.hlp,  Node: rvar,  Next: setring,  Prev: resultant,  Up: Functions

5.1.112 rvar
------------

`*Syntax:*'
     `rvar (' name `)'
     `rvar (' poly_expression `)'
     `rvar (' string_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the number of the variable if the name is a ring variable
     of the basering or if the string is the name of a ring variable of
     the basering; returns 0 if not. Hence the return value of `rvar'
     can also be used in a boolean context to check whether the variable
     exists.

`*Example:*'

            ring r=29,(x,y,z),lp;
            rvar(x);
          ==> 1
            rvar(r);
          ==> 0
            rvar(y);
          ==> 2
            rvar(var(3));
          ==> 3
            rvar("x");
          ==> 1

* Menu:

See
* defined::
* ring::
* var::
* varstr::

See *note defined::; *note ring::; *note var::; *note varstr::.


File: singular.hlp,  Node: setring,  Next: simplex,  Prev: rvar,  Up: Functions

5.1.113 setring
---------------

`*Syntax:*'
     `setring' ring_name

`*Type:*'
     none

`*Purpose:*'
     changes the basering to another (already defined) ring.

`*Example:*'

            ring r1=0,(x,y),lp;
            // the basering is r1
            ring r2=32003,(a(1..8)),ds;
            // the basering is r2
            setring r1;
            // the basering is again r1
            nameof(basering);
          ==> r1
            listvar();
          ==> // r2                   [0]  ring
          ==> // r1                   [0]  *ring
          ==> // LIB                  [0]  string standard.lib

`*Use in procedures:*'
     All changes of the basering by a definition of a new ring or a
     `setring' command in a procedure are local to this procedure.  Use
     `keepring' to move a ring, which is local to a procedure, up by one
     nesting level.

* Menu:

See
* keepring::
* qring::
* ring::

See *note keepring::; *note qring::; *note ring::.


File: singular.hlp,  Node: simplex,  Next: simplify,  Prev: setring,  Up: Functions

5.1.114 simplex
---------------

`*Syntax:*'
     `simplex (' matrix_expression`,' int_expression`,'
     int_expression`,' int_expression`,' int_expression`,'
     int_expression`)'

`*Type:*'
     list

`*Purpose:*'
     perform the simplex algorithm for the tableau given by the input,
     e.g.  M,m,n,m1,m2,m3:

     M matrix of numbers :
          first row describing the objective function (maximize
          problem),      the remaining rows describing constraints;

     m,n,m1,m2,m3 int :
          n = number of variables;      m = total number of constraints;
               m1 = number of <=constraints (rows 2 ... m1+1 of M);
          m2 = number of >=constraints (rows m1+2 ... m1+m2+1 of M);
          m3 = number of == constraints.

     The following assumptions are made:

     * ground field is of type `(real,N)', N>=4;

     * the matrix M is of size m x n;

     * m=m1+m2+m3;

     * the entries M[2,1] ,..., M[m+1,1] are non-negative;

     * the variables x(i) are non-negative;

     * a row  b, a(1) ,..., a(n)  corresponds to  b+a(1)x(1)+...+a(n)x(n);

     * for a <=, >=, or == constraint: add "in mind" >=0, <=0, or ==0.

     The output is a list L with

     * L[1] = matrix

     * L[2] = int:
          0 = finite solution found;  1 = unbounded;  -1 = no solution;
          -2 = error occured;

     * L[3] = intvec :
          L[3][k] = number of variable which corresponds to row k+1 of
          L[1];

     * L[4] = intvec :
          L[4][j] = number of variable which is represented by column
          j+1 of L[1]    ("non-basis variable");

     * L[5] = int :
          number of constraints (= m);

     * L[6] = int :
          number of variables (= n).

     The solution can be read from the first column of L[1] as is done
     by the procedure *note simplexOut:: in `solve.lib'.

`*Example:*'

              ring r = (real,10),(x),lp;

              // consider the max. problem:
              //
              //    maximize  x(1) + x(2) + 3*x(3) - 0.5*x(4)
              //
              //  with constraints:   x(1) +          2*x(3)          <= 740
              //                             2*x(2)          - 7*x(4) <=   0
              //                               x(2) -   x(3) + 2*x(4) >=   0.5
              //                      x(1) +   x(2) +   x(3) +   x(4)  =   9
              //
              matrix sm[5][5]=(  0, 1, 1, 3,-0.5,
                               740,-1, 0,-2, 0,
                                 0, 0,-2, 0, 7,
                               0.5, 0,-1, 1,-2,
                                 9,-1,-1,-1,-1);

              int n = 4;  // number of constraints
              int m = 4;  // number of variables
              int m1= 2;  // number of <= constraints
              int m2= 1;  // number of >= constraints
              int m3= 1;  // number of == constraints
              simplex(sm, n, m, m1, m2, m3);
          ==> [1]:
          ==>    _[1,1]=17.025
          ==>    _[1,2]=-0.95
          ==>    _[1,3]=-0.05
          ==>    _[1,4]=1.95
          ==>    _[1,5]=-1.05
          ==>    _[2,1]=730.55
          ==>    _[2,2]=0.1
          ==>    _[2,3]=-0.1
          ==>    _[2,4]=-1.1
          ==>    _[2,5]=0.9
          ==>    _[3,1]=3.325
          ==>    _[3,2]=-0.35
          ==>    _[3,3]=-0.15
          ==>    _[3,4]=0.35
          ==>    _[3,5]=0.35
          ==>    _[4,1]=0.95
          ==>    _[4,2]=-0.1
          ==>    _[4,3]=0.1
          ==>    _[4,4]=0.1
          ==>    _[4,5]=0.1
          ==>    _[5,1]=4.725
          ==>    _[5,2]=-0.55
          ==>    _[5,3]=0.05
          ==>    _[5,4]=0.55
          ==>    _[5,5]=-0.45
          ==> [2]:
          ==>    0
          ==> [3]:
          ==>    5,2,4,3
          ==> [4]:
          ==>    1,6,8,7
          ==> [5]:
          ==>    4
          ==> [6]:
          ==>    4

* Menu:

See
* simplexOut::

See *note simplexOut::.


File: singular.hlp,  Node: simplify,  Next: size,  Prev: simplex,  Up: Functions

5.1.115 simplify
----------------

`*Syntax:*'
     `simplify (' poly_expression`,' int_expression `)'
     `simplify (' vector_expression`,' int_expression `)'
     `simplify (' ideal_expression`,' int_expression `)'
     `simplify (' module_expression`,' int_expression `)'

`*Type:*'
     the type of the first argument

`*Purpose:*'
     returns the "simplified" first argument depending on the
     simplification rule given as the second argument.  The
     simplification rules are the sum of the following functions:

     `1'
          normalize (make leading coefficients 1).

     `2'
          erase zero generators/columns.

     `4'
          keep only the first one of identical generators/columns.

     `8'
          keep only the first one of generators/columns which differ
          only by a factor in the ground field.

     `16'
          keep only those generators/columns whose leading monomials
          differ.

     `32'
          keep only those generators/columns whose leading monomials are
          not divisible by other ones.

`*Example:*'

          ring r=0,(x,y,z),(c,dp);
          ideal i=0,2x,2x,4x,3x+y,5x2;
          simplify(i,1);
          ==> _[1]=0
          ==> _[2]=x
          ==> _[3]=x
          ==> _[4]=x
          ==> _[5]=x+1/3y
          ==> _[6]=x2
          simplify(i,2);
          ==> _[1]=2x
          ==> _[2]=2x
          ==> _[3]=4x
          ==> _[4]=3x+y
          ==> _[5]=5x2
          simplify(i,4);
          ==> _[1]=0
          ==> _[2]=2x
          ==> _[3]=4x
          ==> _[4]=3x+y
          ==> _[5]=5x2
          simplify(i,8);
          ==> _[1]=0
          ==> _[2]=2x
          ==> _[3]=3x+y
          ==> _[4]=5x2
          simplify(i,16);
          ==> _[1]=0
          ==> _[2]=2x
          ==> _[3]=5x2
          simplify(i,32);
          ==> _[1]=0
          ==> _[2]=2x
          simplify(i,32+2+1);
          ==> _[1]=x
          matrix A[2][3]=x,0,2x,y,0,2y;
          simplify(A,2+8); // by automatic conversion to module
          ==> _[1]=[x,y]

* Menu:

See
* ideal::
* module::
* poly::
* vector::

See *note ideal::; *note module::; *note poly::; *note vector::.


File: singular.hlp,  Node: size,  Next: sortvec,  Prev: simplify,  Up: Functions

5.1.116 size
------------

`*Syntax:*'
     `size (' string_expression `)'
     `size (' intvec_expression `)'
     `size (' intmat_expression `)'
     `size (' poly_expression `)'
     `size (' vector_expression `)'
     `size (' ideal_expression `)'
     `size (' module_expression `)'
     `size (' matrix_expression `)'
     `size (' list_expression `)'
     `size (' resolution_expression `)'
     `size (' ring_expression `)'

`*Type:*'
     int

`*Purpose:*'
     depends on the type of argument:

     ideal or module
          returns the number of (non-zero) generators.

     string, intvec, list or resolution
          returns the length, i.e., the number of characters, entries or
          elements.

     poly or vector
          returns the number of monomials.

     matrix or intmat
          returns the number of entries (rows*columns).

     ring
          returns the number of elements in the ground field (for Z/p
          and algebraic extensions) or -1

`*Example:*'

            string s="hello";
            size(s);
          ==> 5
            intvec iv=1,2;
            size(iv);
          ==> 2
            ring r=0,(x,y,z),lp;
            poly f=x+y+z;
            size(f);
          ==> 3
            vector v=[x+y,0,0,1];
            size(v);
          ==> 3
            ideal i=f,y;
            size(i);
          ==> 2
            module m=v,[0,1],[0,0,1],2*v;
            size(m);
          ==> 4
            matrix mm[2][2];
            size(mm);
          ==> 4
            ring r1=(2,a),x,dp;
            minpoly=a4+a+1;
            size(r1);
          ==> 8

* Menu:

See
* ideal::
* intmat::
* intvec::
* module::
* ncols::
* nrows::
* poly::
* string::
* vector::

See *note ideal::; *note intmat::; *note intvec::; *note module::; *note
ncols::; *note nrows::; *note poly::; *note string::; *note vector::.


File: singular.hlp,  Node: sortvec,  Next: sprintf,  Prev: size,  Up: Functions

5.1.117 sortvec
---------------

`*Syntax:*'
     `sortvec (' ideal_expression `)'
     `sortvec (' module_expression `)'

`*Type:*'
     intvec

`*Purpose:*'
computes the permutation {\tt v}
     which orders the ideal, resp.\ module, {\tt I} by its initial terms,
     starting with the smallest, that is, {\tt I(v[i]) < I(v[i+1])} for all
     {\tt i}.
     computes the permutation v which orders the ideal, resp. module, I
     by its initial terms, starting with the smallest, that is,
     I(v[i]) < I(v[i+1]) for all i.

`*Example:*'

            ring r=0,(x,y,z),dp;
            ideal I=y,z,x,x3,xz;
            sortvec(I);
          ==> 2,1,3,5,4

* Menu:

See
* general_lib::

See *note general_lib::.


File: singular.hlp,  Node: sprintf,  Next: sres,  Prev: sortvec,  Up: Functions

5.1.118 sprintf
---------------

Procedure from library `standard.lib' (*note standard_lib::).

*Syntax:*
     `sprintf (' string_expression `[,' any_expressions `] )'

*Return:*
     string

*Purpose:*
     `sprintf(fmt,...);' performs output formatting. The first argument
     is a format control string. Additional arguments may be required,
     depending on the content of the control string. A series of output
     characters is generated as directed by the control string; these
     characters are returned as a string.
     The control string `fmt' is simply text to be copied, except that
     the string may contain conversion specifications.
     Do `help print;' for a listing of valid conversion specifications.
     As an addition to the conversions of `print', the `%n' and `%2'
     conversion specification does not consume an additional argument,
     but simply generates a newline character.

*Note:*
     If one of the additional arguments is a list, then it should be
     enclosed once more into a `list()' command, since passing a list as
     an argument flattens the list by one level.

*Example:*
       ring r=0,(x,y,z),dp;
     module m=[1,y],[0,x+z];
     intmat M=betti(mres(m,0));
     list l = r, m, M;
     string s = sprintf("s:%s,%n l:%l", 1, 2); s;
     ==> s:1,
     ==>  l:int(2)
     s = sprintf("s:%n%s", l); s;
     ==> s:
     ==> (0),(x,y,z),(dp(3),C)
     s = sprintf("s:%2%s", list(l)); s;
     ==> s:
     ==> (0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
     s = sprintf("2l:%n%2l", list(l)); s;
     ==> 2l:
     ==> list("(0),(x,y,z),(dp(3),C)",
     ==> module(y*gen(2)+gen(1),
     ==> x*gen(2)+z*gen(2)),
     ==> intmat(intvec(1,1 ),1,2))
     ==> 
     s = sprintf("%p", list(l)); s;
     ==> [1]:
     ==>    //   characteristic : 0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y z 
     ==> //        block   2 : ordering C
     ==> [2]:
     ==>    _[1]=y*gen(2)+gen(1)
     ==>    _[2]=x*gen(2)+z*gen(2)
     ==> [3]:
     ==>    1,1 
     ==> 
     s = sprintf("%;", list(l)); s;
     ==> [1]:
     ==>    //   characteristic : 0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y z 
     ==> //        block   2 : ordering C
     ==> [2]:
     ==>    _[1]=y*gen(2)+gen(1)
     ==>    _[2]=x*gen(2)+z*gen(2)
     ==> [3]:
     ==>    1,1 
     ==> 
     s = sprintf("%b", M); s;
     ==>            0     1
     ==> ------------------
     ==>     0:     1     1
     ==> ------------------
     ==> total:     1     1
     ==> 

* Menu:

See also:
* fprintf::
* print::
* printf::
* string::

*See also:* *note fprintf::; *note print::; *note printf::; *note
string::.


File: singular.hlp,  Node: sres,  Next: status,  Prev: sprintf,  Up: Functions

5.1.119 sres
------------

`*Syntax:*'
     `sres (' ideal_expression`,' int_expression `)'
     `sres (' module_expression`,' int_expression `)'

`*Type:*'
     resolution

`*Purpose:*'
     computes a free resolution of an ideal or module with Schreyer's
     method. The ideal, resp. module, has to be a standard basis.  More
     precisely, let M be given by a standard basis and $A_1={\tt matrix}(M)$.
     A1=matrix(M).  Then `sres' computes a free resolution of
     coker(A1)=F0/M

                         A2       A1
           ... ---> F2 ---> F1 ---> F0 -> F0/M -> 0.

$coker(A_1)=F_0/M$
     $$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M\longrightarrow 0.$$
     If the int expression k is not zero then the computation stops
     after k steps and returns a list of modules (given by standard
     bases) $M_i={\tt module}(A_i)$, i=1..k.
     Mi=module(Ai), i=1..k.
     `sres(M,0)' returns a list of n modules where n is the number of
     variables of the basering.

     Even if `sres' does not compute a minimal resolution, the `betti'
     command gives the true betti numbers! In many cases of interest
     `sres' is much faster than any other known method.  Let `list
     L=sres(M,0);' then `L[1]=M' is identical to the input, `L[2]' is a
     standard basis with respect to the Schreyer ordering of the first
     syzygy module of `L[1]', etc.  (L[i]=M_i (${\tt L[i]}=M_i$
      in the notations from above.)

`*Note:*'
     Accessing single elements of a resolution may require that some
     partial computations have to be finished and may therefore take
     some time.

`*Example:*'

            ring r=31991,(t,x,y,z,w),ls;
            ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
                    t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
            M=std(M);
            resolution L=sres(M,0);
            L;
          ==>  1      35      141      209      141      43      4      
          ==> r <--  r <--   r <--    r <--    r <--    r <--   r
          ==> 
          ==> 0      1       2        3        4        5       6      
          ==> resolution not minimized yet
          ==> 
            print(betti(L),"betti");
          ==>            0     1     2     3     4     5
          ==> ------------------------------------------
          ==>     0:     1     -     -     -     -     -
          ==>     1:     -     -     -     -     -     -
          ==>     2:     -     -     -     -     -     -
          ==>     3:     -     4     -     -     -     -
          ==>     4:     -     -     -     -     -     -
          ==>     5:     -     -     -     -     -     -
          ==>     6:     -     -     6     -     -     -
          ==>     7:     -     -     9    16     2     -
          ==>     8:     -     -     -     2     5     1
          ==> ------------------------------------------
          ==> total:     1     4    15    18     7     1

* Menu:

See
* betti::
* hres::
* ideal::
* int::
* lres::
* minres::
* module::
* mres::
* res::
* syz::

See *note betti::; *note hres::; *note ideal::; *note int::; *note
lres::; *note minres::; *note module::; *note mres::; *note res::; *note
syz::.


File: singular.hlp,  Node: status,  Next: std,  Prev: sres,  Up: Functions

5.1.120 status
--------------

`*Syntax:*'
     `status (' link_expression`,' string_expression `)'

`*Type:*'
     string

`*Syntax:*'
     `status (' link_expression`,' string_expression`,'
     string_expression `)'
     `status (' link_expression`,' string_expression`,'
     string_expression`,' int_expression `)'

`*Type:*'
     int

`*Purpose:*'
     returns the status of the link as asked for by the second argument.
     If a third argument is given, the result of the comparison to the
     status string is returned: `(status(l,s1)==s2)' is equivalent to
     `status(l,s1,s2)'.  If a fourth integer argument (say, `i') is
     given and if `status(l,s1,s2)' yields `0', then the execution of
     the current process is suspended (the process is put to "sleep")
     for approximately `i' microseconds, and afterwards the result of
     another call to `status(l,s1,s2)' is returned. The latter is useful
     for "polling" the `read' status of MPtcp links such that busy loops
     are avoided (see *note Parallelization with MPtcp links:: for an
     example).  Note that on some systems, the minimum time for a
     process to be put to sleep is one second.
     The following string expressions are allowed:

     ``"name"''
          the name string given by the definition of the link (usually
          the filename)

     ``"type"''
          returns `"ASCII"', `"MPfile"', `"MPtcp"' or `"DBM"'

     ``"open"''
          returns `"yes"' or `"no"'

     ``"openread"''
          returns `"yes"' or `"no"'

     ``"openwrite"''
          returns `"yes"' or `"no"'

     ``"read"''
          returns `"ready"' or `"not ready"'

     ``"write"''
          returns `"ready"' or `"not ready"'

     ``"mode"''
          returns (depending on the type of the link and its status)
          `"","w","a","r"' or `"rw"'

`*Example:*'

            link l=":w example.txt";
            status(l,"write");
          ==> not ready
            open(l);
            status(l,"write","ready");
          ==> 1
            close(l);

* Menu:

See
* link::
* open::
* read::
* write::

See *note link::; *note open::; *note read::; *note write::.


File: singular.hlp,  Node: std,  Next: stdfglm,  Prev: status,  Up: Functions

5.1.121 std
-----------

`*Syntax:*'
     `std (' ideal_expression`)'
     `std (' module_expression`)'
     `std (' ideal_expression`,' intvec_expression `)'
     `std (' module_expression`,' intvec_expression `)'
     `std (' ideal_expression`,' intvec_expression`,' intvec_expression
     `)'
     `std (' module_expression`,' intvec_expression`,' intvec_expression
     `)'
     `std (' ideal_expression`,' poly_expression `)'
     `std (' module_expression`,' vector_expression `)'

`*Type:*'
     ideal or module

`*Purpose:*'
     returns a standard basis of an ideal or module with respect to the
     monomial ordering of the basering.  A standard basis is a set of
     generators such that the leading terms generate the leading ideal,
     resp. module.
     Use an optional second argument of type intvec as Hilbert series
     (result of `hilb(i,1)', see *note hilb::), if the ideal, resp.
     module, is homogeneous (Hilbert driven standard basis computation,
     *note stdhilb::).  If the ideal is quasihomogeneous with some
     weights w and if the Hilbert series is computed w.r.t. to these
     weights, then use w as third argument.
     Use an optional second argument of type poly, resp. vector, to
     construct the standard basis from an already computed one (given as
     the first argument) and one additional generator (the second
     argument).

`*Note:*'
     The standard basis is computed with a (more or less)
     straight-forward implementation of the classical Buchberger (resp.
     Mora) algorithm. For global orderings, use the `groebner' command
     instead (*note groebner::), which heuristically chooses the "best"
     algorithm to compute a Groebner basis.
     To view the progress of long running computations, use
     `option(prot)' (see *note option(prot)::).

`*Example:*'

            // local computation
            ring r=32003,(x,y,z),ds;
            poly s1=1x2y+151xyz10+169y21;
            poly s2=1xz14+6x2y4+3z24;
            poly s3=5y10z10x+2y20z10+y10z20+11x3;
            ideal i=s1,s2,s3;
            ideal j=std(i);
            degree(j);
          ==> 0
            // Hilbert driven elimination (standard)
            ring rhom=32003,(x,y,z,h),dp;
            ideal i=homog(imap(r,i),h);
            ideal j=std(i);
            intvec iv=hilb(j,1);
            ring rlex=32003,(x,y,z,h),lp;
            ideal i=fetch(rhom,i);
            ideal j=std(i,iv);
            j=subst(j,h,1);
            j[1];
          ==> z64
            // Hilbert driven elimination (ideal is quasihomogeneous)
            intvec w=10,1,1;
            ring whom=32003,(x,y,z),wp(w);
            ideal i=fetch(r,i);
            ideal j=std(i);
            intvec iw=hilb(j,1,w);
            ring wlex=32003,(x,y,z),lp;
            ideal i=fetch(whom,i);
            ideal j=std(i,iw,w);
            j[1];
          ==> z64

* Menu:

See
* facstd::
* fglm::
* groebner::
* ideal::
* mstd::
* option::
* ring::
* stdfglm::
* stdhilb::

See *note facstd::; *note fglm::; *note groebner::; *note ideal::; *note
mstd::; *note option::; *note ring::; *note stdfglm::; *note stdhilb::.


File: singular.hlp,  Node: stdfglm,  Next: stdhilb,  Prev: std,  Up: Functions

5.1.122 stdfglm
---------------

Procedure from library `standard.lib' (*note standard_lib::).

*Syntax:*
     `stdfglm (' ideal_expression `)'
     `stdfglm (' ideal_expression`,' string_expression `)'

*Type:*
     ideal

*Purpose:*
     computes the standard basis of the ideal in the basering via `fglm'
     (from the ordering given as the second argument to the ordering of
     the basering).
     If no second argument is given, "dp" is used.

*Example:*
        ring r=0,(x,y,z),lp;
     ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
     ideal i1=stdfglm(i);         //uses fglm from "dp" to "lp"
     i1;
     ==> i1[1]=z12
     ==> i1[2]=yz4-z8
     ==> i1[3]=y2+y-z8-z4
     ==> i1[4]=xy-xz4-y+z4
     ==> i1[5]=x2+y-z4
     ideal i2=stdfglm(i,"Dp");    //uses fglm from "Dp" to "lp"
     i2;
     ==> i2[1]=z12
     ==> i2[2]=yz4-z8
     ==> i2[3]=y2+y-z8-z4
     ==> i2[4]=xy-xz4-y+z4
     ==> i2[5]=x2+y-z4

* Menu:

See also:
* fglm::
* groebner::
* std::
* stdhilb::

*See also:* *note fglm::; *note groebner::; *note std::; *note
stdhilb::.


File: singular.hlp,  Node: stdhilb,  Next: subst,  Prev: stdfglm,  Up: Functions

5.1.123 stdhilb
---------------

Procedure from library `standard.lib' (*note standard_lib::).

*Syntax:*
     `stdhilb (' ideal_expression `)'
     `stdhilb (' ideal_expression`,' intvec_expression `)'

*Type:*
     ideal

*Purpose:*
     computes the standard basis of the homogeneous ideal in the
     basering, via a Hilbert driven standard basis computation.
     An optional second argument will be used as 1st Hilbert function.

*Assume:*
     The optional second argument is the first Hilbert series as
     computed by `hilb'.

*Example:*
        ring  r=0,(x,y,z),dp;
     ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
     ideal i1=stdhilb(i); i1;
     ==> i1[1]=y3+x2
     ==> i1[2]=x2y+x2
     ==> i1[3]=x3-x2
     ==> i1[4]=z4-x2-y
     // the latter computation is equivalent to:
     intvec v=hilb(i,1);
     ==> // ** i is no standardbasis
     ideal i2=stdhilb(i,v); i2;
     ==> i2[1]=y3+x2
     ==> i2[2]=x2y+x2
     ==> i2[3]=x3-x2
     ==> i2[4]=z4-x2-y

* Menu:

See also:
* groebner::
* std::
* stdfglm::

*See also:* *note groebner::; *note std::; *note stdfglm::.


File: singular.hlp,  Node: subst,  Next: system,  Prev: stdhilb,  Up: Functions

5.1.124 subst
-------------

`*Syntax:*'
     `subst (' poly_expression`,' ring_variable`,' poly_expression `)'
     `subst (' vector_expression`,' ring_variable`,' poly_expression `)'

     `subst (' ideal_expression`,' ring_variable`,' poly_expression `)'
     `subst (' module_expression`,' ring_variable`,' poly_expression `)'

`*Type:*'
     poly, vector, ideal or module (corresponding to the first argument)

`*Purpose:*'
     substitutes a ring variable by a polynomial.

`*Example:*'

            ring r=0,(x,y,z),dp;
            poly f=x2+y2+z2+x+y+z;
            subst(f,x,3/2);
          ==> y2+z2+y+z+15/4
            int a=1;
            subst(f,y,a);
          ==> x2+z2+x+z+2
            subst(f,y,z);
          ==> x2+2z2+x+2z
            subst(f,y,z+1);
          ==> x2+2z2+x+4z+2

* Menu:

See
* ideal::
* map::
* module::
* poly::
* vector::

See *note ideal::; *note map::; *note module::; *note poly::; *note
vector::.


File: singular.hlp,  Node: system,  Next: syz,  Prev: subst,  Up: Functions

5.1.125 system
--------------

`*Syntax:*'
     `system (' string_expression `)'
     `system (' string_expression`,' expression `)'

`*Type:*'
     depends on the desired function, may be none

`*Purpose:*'
     interface to internal data and the operating system. The
     string_expression determines the command to execute. Some commands
     require an additional argument (second form) where the type of the
     argument depends on the command. See below for a list of all
     possible commands.

`*Note:*'
     Not all functions work on every platform.

`*Functions:*'

     `system("sh"', string_expression `)'
          shell escape, returns the return code of the shell as int. The
          string is sent literally to the shell.

     `system("pid")'
          returns the process number as int (for creating unique names).

     `system("uname")'
          returns a string identifying the architecture for which
          SINGULAR was compiled.

     `system("getenv",' string_expression`)'
          returns the value of the shell environment variable given as
          the second argument. The return type is string.

     `system("setenv",'string_expression, string_expression`)'
          sets the shell environment variable given as the second
          argument to the value given as the third argument. Returns the
          third argument. Might not be available on all platforms.

     `system("tty")'
          resets the terminal.

     `system("version")'
          returns the version number of  SINGULAR as int.

     `system("contributors")'
          returns names of people who contributed to the SINGULAR kernel
          as string.

     `system("gen")'
          returns the generating element of the multiplicative group of
          (Z/p)\{0} (as int) where p is the characteristic of the
          basering.

     `system("nblocks")'

     `system("nblocks",' ring_name `)'
          returns the number of blocks of the given ring, or the number
          of parameters of the current basering, if no second argument
          is given. The return type is int.

     `system("Singular")'
          returns the absolute (path) name of the running SINGULAR as
          string.

     `system("'-`")'
          prints the values of all options.

     `system("'-long_option_name`")'
          returns the value of the (command-line) option
          long_option_name. The type of the returned value is either
          string or int.  *Note Command line options::, for more info.

     `system("'-long_option_name`",' expression`)'
          sets the value of the (command-line) option long_option_name
          to the value given by the expression. Type of the expression
          must be string, or int.  *Note Command line options::, for
          more info. Among others, this can be used for setting the seed
          of the random number generator, the used help browser, the
          minimal display time, or the timer resolution.

     `system("browsers");'
          returns a string about available help browsers.  *Note The
          online help system::.

`*Example:*'

          // a listing of the current directory:
          system("sh","ls");
          // execute a shell, return to SINGULAR with exit:
          system("sh","sh");
          string unique_name="/tmp/xx"+string(system("pid"));
          unique_name;
          ==> /tmp/xx4711
          system("uname")
          ==> ix86-Linux
          system("getenv","PATH");
          ==> /bin:/usr/bin:/usr/local/bin
          system("Singular");
          ==> /usr/local/bin/Singular
          // report value of all options
          system("--");
          ==> // --batch           0
          ==> // --execute
          ==> // --sdb             0
          ==> // --echo            0
          ==> // --help            0
          ==> // --quiet           0
          ==> // --random          937848971
          ==> // --no-tty          0
          ==> // --user-option
          ==> // --version         0
          ==> // --allow-net       0
          ==> // --browser
          ==> // --emacs           0
          ==> // --no-stdlib       0
          ==> // --no-rc           0
          ==> // --no-warn         0
          ==> // --no-out          0
          ==> // --min-time        "0.5"
          ==> // --mp-port
          ==> // --mp-host
          ==> // --ticks-per-sec   1
          ==> // --mp-transp
          ==> // --mp-mode
          // set minimal display time to 0.02 seconds
          system("--min-time", "0.02");
          // set timer resolution to 0.01 seconds
          system("--ticks-per-sec", 100);
          // re-seed random number generator
          system("--random", 12345678);
          // allow netscape to access HTML pages from the net
          system("--allow-net", 1);
          // and set help browser to netscape
          system("--browser", "netscape");


File: singular.hlp,  Node: syz,  Next: trace,  Prev: system,  Up: Functions

5.1.126 syz
-----------

`*Syntax:*'
     `syz (' ideal_expression `)'
     `syz (' module_expression `)'

`*Type:*'
     module

`*Purpose:*'
     computes the first syzygy (i.e., the module of relations of the
     given generators) of the ideal, resp. module.

`*Example:*'

            ring R=0,(x,y),(c,dp);
            ideal i=x,y;
            syz(i);
          ==> _[1]=[y,-x]

* Menu:

See
* hres::
* ideal::
* lres::
* module::
* mres::
* nres::
* res::
* sres::

See *note hres::; *note ideal::; *note lres::; *note module::; *note
mres::; *note nres::; *note res::; *note sres::.


File: singular.hlp,  Node: trace,  Next: transpose,  Prev: syz,  Up: Functions

5.1.127 trace
-------------

`*Syntax:*'
     `trace (' intmat_expression `)'
     `trace (' matrix_expression `)'

`*Type:*'
     int, if the argument is an intmat, resp.
     poly, if the argument is a matrix

`*Purpose:*'
     returns the trace of an intmat, resp. matrix.

`*Example:*'

            intmat m[2][2]=1,2,3,4;
            print(m);
          ==>      1     2
          ==>      3     4
            trace(m);
          ==> 5

* Menu:

See
* intmat::
* matrix::

See *note intmat::; *note matrix::.


File: singular.hlp,  Node: transpose,  Next: type,  Prev: trace,  Up: Functions

5.1.128 transpose
-----------------

`*Syntax:*'
     `transpose (' intmat_expression `)'
     `transpose (' matrix_expression `)'
     `transpose (' module_expression `)'

`*Type:*'
     intmat, matrix, or module, corresponding to the argument

`*Purpose:*'
     transposes a matrix.

`*Example:*'

            ring R=0,x,dp;
            matrix m[2][3]=1,2,3,4,5,6;
            print(m);
          ==> 1,2,3,
          ==> 4,5,6 
            print(transpose(m));
          ==> 1,4,
          ==> 2,5,
          ==> 3,6 

* Menu:

See
* intmat::
* matrix::
* module::

See *note intmat::; *note matrix::; *note module::.


File: singular.hlp,  Node: type,  Next: typeof,  Prev: transpose,  Up: Functions

5.1.129 type
------------

`*Syntax:*'
     `type ' name `;'
     `type (' name `);'

`*Type:*'
     none

`*Purpose:*'
     prints the name, level, type and value of a variable. To display
     the value of an expression, it is sufficient to type the expression
     followed by `;'.

`*Example:*'

            int i=3;
            i;
          ==> 3
            type(i);
          ==> // i                    [0]  int 3

* Menu:

See
* Data types::
* listvar::
* print::

See *note Data types::; *note listvar::; *note print::.


File: singular.hlp,  Node: typeof,  Next: uressolve,  Prev: type,  Up: Functions

5.1.130 typeof
--------------

`*Syntax:*'
     `typeof (' expression `)'

`*Type:*'
     string

`*Purpose:*'
     returns the type of an expression as string.

     Returns the type of the first list element if the expression is an
     expression list.

     Possible types are: `"ideal"', `"int"', `"intmat"', `"intvec"',
     `"list"', `"map"', `"matrix"', `"module"', `"number"', `"none"',
     `"poly"', `"proc"', `"qring"', `"resolution"', `"ring"',
     `"string"', `"vector"'.

     For internal use only is the type `"?unknown type?"'.

`*Example:*'

            int i=9; i;
          ==> 9
            typeof(_);
          ==> int
            print(i);
          ==> 9
            typeof(_);
          ==> none
            type i;
          ==> // i                    [0]  int 9
            typeof(_);
          ==> string
            string s=typeof(i);
            s;
          ==> int
            typeof(s);
          ==> string
            proc p() {  "hello"; return();}
            p();
          ==> hello
            typeof(_);
          ==> none

* Menu:

See
* Data types::
* type::

See *note Data types::; *note type::.


File: singular.hlp,  Node: uressolve,  Next: vandermonde,  Prev: typeof,  Up: Functions

5.1.131 uressolve
-----------------

`*Syntax:*'
     `uressolve (' ideal_expression`,' int_expression`,'
     int_expression`,' int_expression `)'

`*Type:*'
     list

`*Purpose:*'
     computes all complex roots of a zerodimensional ideal.
     Makes either use of the multipolynomial resultant of Macaulay
     (second argument = 1), which works only for homogeneous ideals, or
     uses the sparse resultant of Gelfand, Kapranov and Zelevinsky
     (second argument = 0).
     The sparse resultant algorithm uses a mixed polyhedral subdivision
     of the Minkowsky sum of the Newton polytopes in order to construct
     the sparse resultant matrix. Its determinant is a nonzero multiple
     of the sparse resultant. The u-resultant of B.L. van der Waerden
     and Laguerre's algorithm are used to determine the complex roots.
     The third argument defines the precision of the fractional part if
     the ground field is the field of rational numbers, otherwise it
     will be ignored.
     The fourth argument (can be 0, 1 or 2) gives the number of extra
     runs of Laguerre's algorithm (with corrupted roots), leading to
     better results.

`*Note:*'
     If the ground field is the field of complex numbers, the elements
     of the list are of type number, otherwise of type string.

`*Example:*'

          ring rsc=(real,20,I),(x,y),lp;
          ideal i=(2+3*I)*x2+(0.35+I*45.0e-2)*y2-8,x2+xy+(42.7)*y2;
          list l=uressolve(i,0,0,2);
          l[1];
          ==> [1]:
          ==>    (-1.315392899374542198+I*0.70468233142752928117)
          ==> [2]:
          ==>    (0.12292646536251281054+I*0.19245727404407015049)
          subst(subst(i[1],x,l[1][1]),y,l[1][2]);
          ==> 0

* Menu:

See
* laguerre::
* mpresmat::

See *note laguerre::; *note mpresmat::.


File: singular.hlp,  Node: vandermonde,  Next: var,  Prev: uressolve,  Up: Functions

5.1.132 vandermonde
-------------------

`*Syntax:*'
     `vandermonde (' ideal_expression`,' ideal_expression`,'
     int_expression `)'

`*Type:*'
     poly

`*Purpose:*'
     `vandermonde(p,v,d)' computes the (unique) polynomial of degree d
     with prescribed values v[1],...,v[N] at the points p^0,...,p^(N-1),
     N=(d+1)^n, n the number of ring variables.
     The returned polynomial is sum_a c[a]*x1^a1*...*xn^an, where the
     coefficients c[a] are the solution of the (transposed) Vandermonde
     system of linear equations

        sum_(|a|<=d) c_[a] * p[1]^(k*a1) *..* p[n]^(k*an) = v[k+1],
     k=1,...,N.

{\tt vandermonde(p,v,d)} computes the (unique) polynomial of degree
     @code{d} with prescribed values {\tt v[1],...,v[N]} at the points
     {\tt p}$^0,\dots,$ {\tt p}$^{N-1}$, {\tt N=(d+1)}$^n$, $n$ the
     number of ring variables.

     The returned polynomial is $\sum
     c_{\alpha_1\ldots\alpha_n}\cdot x_1^{\alpha_1} \cdot \dots \cdot
     x_n^{\alpha_n}$, where the coefficients
     $c_{\alpha_1\ldots\alpha_n}$ are the solution of the (transposed)
     Vandermonde system of linear equations
     $$ \sum_{\alpha_1+\ldots+\alpha_n\leq d} c_{\alpha_1\ldots\alpha_n} \cdot
     {\tt p}_1^{(k-1)\alpha_1}\cdot\dots\cdot {\tt p}_n^{(k-1)\alpha_n} =
     {\tt v}[k], \quad  k=1,\dots,{\tt N}.$$

`*Note:*'
     the ground field has to be the field of rational numbers. Moreover,
     ncols(p)==n, the number of variables in the basering, and all the
     given generators have to be numbers different from 0,1 or -1.
     Finally, ncols(v)==(d+1)^n, and all given generators have to be
     numbers.  the ground field has to be the field of rational
     numbers. Moreover, {\tt ncols(p)==}$n$, the number of variables in the
     basering, and all the given generators have to be numbers different from
     0,1 or -1. Finally, {\tt ncols(v)==(d+1)$^n$}, and all given generators have
     to be numbers.

`*Example:*'

          ring r=0,(x,y),dp;
          // determine f with deg(f)=2 and with given values v of f
          // at 9 points: (2,3)^0=(1,1),...,(2,3)^8=(2^8,3^8)
          // valuation point: (2,3)
          ideal p=2,3;
          ideal v=1,2,3,4,5,6,7,8,9;
          poly ip=vandermonde(p,v,2);
          ip[1..5];  //  the 5 first terms of ip:
          ==> -1/9797760x2y2-595/85536x2y+55/396576xy2+935/384x2-1309/3240xy
          // compute value of ip at the point 2^8,3^8, result must be 9
          subst(subst(ip,x,2^8),y,3^8);
          ==> 9

* Menu:

See also:


File: singular.hlp,  Node: var,  Next: varstr,  Prev: vandermonde,  Up: Functions

5.1.133 var
-----------

`*Syntax:*'
     `var (' int_expression `)'

`*Type:*'
     poly

`*Purpose:*'
     `var(n)' returns the n-th ring variable.

`*Example:*'

            ring r=0,(x,y,z),dp;
            var(2);
          ==> y

* Menu:

See
* int::
* nvars::
* ring::
* varstr::

See *note int::; *note nvars::; *note ring::; *note varstr::.


File: singular.hlp,  Node: varstr,  Next: vdim,  Prev: var,  Up: Functions

5.1.134 varstr
--------------

`*Syntax:*'
     `varstr (' ring_name `)'
     `varstr (' int_expression `)'
     `varstr (' ring_name`,' int_expression `)'

`*Type:*'
     string

`*Purpose:*'
     returns the list of the names of the ring variables as a string or
     the name of the n-th ring variable, where n is given by the
     int_expression.
     If the ring name is omitted, the basering is used, thus `varstr(n)'
     is equivalent to `varstr(basering,n)'.

`*Example:*'

            ring r=0,(x,y,z),dp;
            varstr(r);
          ==> x,y,z
            varstr(r,1);
          ==> x
            varstr(2);
          ==> y

* Menu:

See
* charstr::
* int::
* nvars::
* ordstr::
* parstr::
* ring::
* var::

See *note charstr::; *note int::; *note nvars::; *note ordstr::; *note
parstr::; *note ring::; *note var::.


File: singular.hlp,  Node: vdim,  Next: wedge,  Prev: varstr,  Up: Functions

5.1.135 vdim
------------

`*Syntax:*'
     `vdim (' ideal_expression `)'
     `vdim (' module_expression `)'

`*Type:*'
     int

`*Purpose:*'
     computes the vector space dimension of the ring, resp. free module,
     modulo the ideal, resp. module, generated by the initial terms of
     the given generators.  If the generators form a standard basis,
     this is the same as the vector space dimension of the ring, resp.
     free module, modulo the ideal, resp. module.
     If the ideal, resp. module, is not zero-dimensional, -1 is
     returned.

`*Example:*'

            ring r=0,(x,y),ds;
            ideal i=x2+y2,x2-y2;
            ideal j=std(i);
            vdim(j);
          ==> 4

* Menu:

See
* degree::
* dim::
* ideal::
* kbase::
* mult::
* std::

See *note degree::; *note dim::; *note ideal::; *note kbase::; *note
mult::; *note std::.


File: singular.hlp,  Node: wedge,  Next: weight,  Prev: vdim,  Up: Functions

5.1.136 wedge
-------------

`*Syntax:*'
     `wedge (' matrix_expression`,' int_expression `)'

`*Type:*'
     matrix

`*Purpose:*'
     `wedge(M,n)' computes the `n'-th exterior power of the matrix `M'.

`*Example:*'

            ring r;
            matrix m[2][3]=x,y,y,z,z,x;
            print(m);
          ==> x,y,y,
          ==> z,z,x 
            print(wedge(m,2));
          ==> xz-yz,-x2+yz,xy-yz

* Menu:

See
* int::
* matrix::
* minor::

See *note int::; *note matrix::; *note minor::.


File: singular.hlp,  Node: weight,  Next: write,  Prev: wedge,  Up: Functions

5.1.137 weight
--------------

`*Syntax:*'
     `weight (' ideal_expression `)'
     `weight (' module_expression `)'

`*Type:*'
     intvec

`*Purpose:*'
     computes an "optimal" weight vector for an ideal, resp. module,
     which may be used as weight vector for the variables in order to
     speed up the standard basis algorithm. If the input is weighted
     homogeneous, a weight vector for which the input is weighted
     homogeneous is found.

`*Example:*'

            ring h1=32003,(t,x,y,z),dp;
            ideal i=
            9x8+y7t3z4+5x4y2t2+2xy2z3t2,
            9y8+7xy6t+2x5y4t2+2x2yz3t2,
            9z8+3x2y3z2t4;
            intvec e=weight(i);
            e;
          ==> 5,7,5,7
            ring r=32003,(a,b,c,d),wp(e);
            map f=h1,a,b,c,d;
            ideal i0=std(f(i));

* Menu:

See
* ideal::
* intvec::
* qhweight::

See *note ideal::; *note intvec::; *note qhweight::.


File: singular.hlp,  Node: write,  Prev: weight,  Up: Functions

5.1.138 write
-------------

`*Syntax:*'
     `write (' link_expression`,' expression_list `)'
     for DBM links:
     `write (' link`,' string_expression`,' string_expression `)'
     `write (' link`,' string_expression `)'

`*Type:*'
     none

`*Purpose:*'
     writes data to a link.
     If the link is of type `ASCII', all expressions are converted to
     strings  (and separated by a newline character) before they are
     written. As a consequence, only such values which can be converted
     to a string can be written to an  `ASCII' link.
     For MP links, ring-dependent expressions are written together with
     a ring description. To prevent an evaluation of the expression
     before it is written, the `quote' command (possibly together with
     `eval') can be used. A `write' blocks (i.e., does not return to the
     prompt), as long as a MPtcp link is not ready for writing.
     For DBM links, `write' with three arguments inserts the first
     string as key and the second string as value into the dbm data
     base.
     Called with two arguments, it deletes the entry with the key
     specified by the string from the data base.

`*Example:*'

          // write the values of the variables f and i as strings into
          // the file "outfile" (overwrite it, if it exists)
          write(":w outfile",f,i);

          // now append the string "that was f,i" (without the quotes)
          // at the end of the file "outfile"
          write(":a outfile","that was f,i");
          // alternatively, links could be used:
          link l=":a outfile"; l;
          // type : ASCII
          // mode : a
          // name : outfile
          // open : no
          // read : not ready
          // write: not ready
          write(l," that was f,i");
          // saving and retrieving data (ASCII format):
          ring r=32003,(x,y,z),dp;
          ideal i=x+y,z3+22y;
          write(":w save_i",i);// this writes x+y,z3+22y to the file save_i
          ring r=32003,(x,y,z),dp;
          string s=read("save_i");   //creates the string x+y,z3+22y
          execute("ideal k="+s+";"); // this defines an ideal k which
                                     // is equal to i.
          // for large objects, the MP format and MPfile links are better:
          write("MPfile:w save_i.mp",i);
          def j=read("MPfile:r save_i.mp");

* Menu:

See
* Data types::
* dump::
* eval::
* link::
* print::
* printf::
* quote::
* read::
* short::

See *note Data types::; *note dump::; *note eval::; *note link::; *note
print::; *note printf::; *note quote::; *note read::; *note short::.


File: singular.hlp,  Node: Control structures,  Next: System variables,  Prev: Functions,  Up: Functions and system variables

5.2 Control structures
======================


List of all supported control structures.

* Menu:

* break::
* breakpoint::
* continue::
* else::
* export::
* for::
* if::
* keepring::
* quit::
* return::
* while::
* ~::

A sequence of commands surrounded by curly brackets (`{' and `}') is a
so called block. Blocks are used in SINGULAR in order to define
procedures and to collect commands belonging to `if', `else', `for' and
`while' statements and to the `example' part in libraries. Even if the
sequence of statements consists of only a single command it has to be
surrounded by curly brackets!  Variables which are defined inside a
block are not local to that block. Note that there is no ending
semicolon at the end of the block.
`*Example:*'

          if ( i>j )
          {
            // This is the block
            int temp;
            temp=i;
            i=j;
            j=temp;
            kill temp;
          }


File: singular.hlp,  Node: break,  Next: breakpoint,  Prev: Control structures,  Up: Control structures

5.2.1 break
-----------

`*Syntax:*'
     `break;'

`*Purpose:*'
     leaves the innermost `for' or `while' block.

`*Example:*'

          while (1)
          {
            ...
            if ( ... )
            {
              break; // leave the while block
            }
          }

* Menu:

See
* Control structures::
* for::
* while::

See *note Control structures::; *note for::; *note while::.


File: singular.hlp,  Node: breakpoint,  Next: continue,  Prev: break,  Up: Control structures

5.2.2 breakpoint
----------------

`*Syntax:*'
     `breakpoint(' proc_name `);'
     `breakpoint(' proc_name`,' line_no `);'

`*Purpose:*'
     sets a breakpoint at the beginning of the specified procedure or at
     the given line.  *Note:* Line number 1 is the first line of a
     library (for procedures from libraries), resp. the line with the
     `{'.
     A line number of -1 removes all breakpoint from that procedure.

`*Example:*'

          breakpoint(groebner);
          ==> breakpoint 1, at line 163 in groebner
          breakpoint(groebner, 176);
          ==> breakpoint 2, at line 176 in groebner
          breakpoint(groebner, -1);
          ==> breakpoints in groebner deleted(0x6)

* Menu:

See
* Source code debugger::
* ~::

See *note Source code debugger::; *note ~::.


File: singular.hlp,  Node: continue,  Next: else,  Prev: breakpoint,  Up: Control structures

5.2.3 continue
--------------

`*Syntax:*'
     `continue;'

`*Purpose:*'
     skips the rest of the innermost `for' or `while' loop und jumps to
     the beginning of the block. This command is only valid inside a
     `for' or a `while' construction.

`*Note:*'
     Unlike the C-construct it *does not execute the increment
     statement*.  The command `continue' is mainly for internal use.

`*Example:*'

          for (int i = 1 ; i<=10; i=i+1)
          {
             ...
             if (i==3) { i=8;continue; }
               // skip the rest if i is 3 and
               // continue with the next i: 8
             i;
          }
          ==> 1
          ==> 2
          ==> 8
          ==> 9
          ==> 10

* Menu:

See
* Control structures::
* for::
* while::

See *note Control structures::; *note for::; *note while::.


File: singular.hlp,  Node: else,  Next: export,  Prev: continue,  Up: Control structures

5.2.4 else
----------

`*Syntax:*'
     `if (' boolean_expression `)' true_block `else' false_block

`*Purpose:*'
     executes false_block if the boolean_expression of the `if'
     statement is false. This command is only valid in combination with
     an `if' command.

`*Example:*'

          int i=3;
          if (i > 5)
          {
            "i is bigger than 5";
          }
          else
          {
            "i is smaller than 6";
          }
          ==> i is smaller than 6

* Menu:

See
* Control structures::
* boolean expressions::
* if::

See *note Control structures::; *note boolean expressions::; *note if::.


File: singular.hlp,  Node: export,  Next: for,  Prev: else,  Up: Control structures

5.2.5 export
------------

`*Syntax:*'
     `export' name `;'
     `export' list_of_names `;'

`*Purpose:*'
     converts a local variable of a procedure to a global one.

`*Note:*'
     Objects defined in a ring are not automatically exported when
     exporting the ring (use `keepring' instead).

`*Example:*'

          proc p1
          {
            int i,j;
            export(i);
            intmat m;
            listvar();
            export(m);
          }
          p1();
          ==> // m                    [1]  intmat 1 x 1
          ==> // j                    [1]  int 0
          ==> // i                    [0]  int 0
          listvar();
          ==> // m                    [0]  intmat 1 x 1
          ==> // i                    [0]  int 0

* Menu:

See
* keepring::

See *note keepring::.


File: singular.hlp,  Node: for,  Next: if,  Prev: export,  Up: Control structures

5.2.6 for
---------

`*Syntax:*'
     `for (' init_command`;' boolean_expression`;' iterate_commands`)'
     block

`*Purpose:*'
     repetitive, conditional execution of a command block.
     The command init_command is executed first. Then boolean_expression
     is evaluated. If its value is TRUE the block is executed, otherwise
     the `for' statement is complete. After each execution of the block,
     the command iterate_command is executed and boolean_expression is
     evaluated. This is repeated until boolean_expression evaluates to
     FALSE.
     The command `break;' leaves the innermost `for' construct.

`*Example:*'

          // sum of 1 to 10:
          int s=0;
          for (int i=1; i<=10; i=i+1)
          {
             s=s+i;
          }
          s;
          ==> 55

* Menu:

See
* Control structures::
* boolean expressions::
* break::
* continue::
* if::
* while::

See *note Control structures::; *note boolean expressions::; *note
break::; *note continue::; *note if::; *note while::.


File: singular.hlp,  Node: if,  Next: keepring,  Prev: for,  Up: Control structures

5.2.7 if
--------

`*Syntax:*'
     `if (' boolean_expression `)' true_block
     `if (' boolean_expression `)' true_block `else' false_block

`*Purpose:*'
     executes true_block if the boolean condition is true. If the `if'
     statement is followed by an `else' statement and the boolean
     condition is false, then false_block is executed.

`*Example:*'

          int i = 9;
          matrix m[i][i];
          if (i > 5 and typeof(m) == "matrix")
          {
            m[i][i] = i;
          }

* Menu:

See
* Control structures::
* boolean expressions::
* break::
* else::

See *note Control structures::; *note boolean expressions::; *note
break::; *note else::.


File: singular.hlp,  Node: keepring,  Next: quit,  Prev: if,  Up: Control structures

5.2.8 keepring
--------------

`*Syntax:*'
     `keepring' name `;'

`*Purpose:*'
     moves the specified ring to the next (upper) level. This command
     can only be used inside of procedures and it should be the last
     command before the `return' statement. There it provides the
     possibility to keep a ring which is local to the procedure (and its
     objects) accessible after the procedure ended without making the
     ring global.

`*Example:*'

          proc P1
          {
            ring r=0,x,dp;
            keepring r;
          }
          proc P2
          {
            "inside P2: " + nameof(basering);
            P1();
            "inside P2, after call of P1: " + nameof(basering);
          }
          ring r1= 0,y,dp;
          P2();
          ==> inside P2: r1
          ==> inside P2, after call of P1: r
          "at top level: " + nameof(basering);
          ==> at top level: r1

* Menu:

See
* ring::

See *note ring::.


File: singular.hlp,  Node: quit,  Next: return,  Prev: keepring,  Up: Control structures

5.2.9 quit
----------

`*Syntax:*'
     `quit;'

`*Purpose:*'
     quits SINGULAR; works also from inside a procedure. The commands
     `quit' and `exit' are synonymous.

`*Example:*'

            quit;


File: singular.hlp,  Node: return,  Next: while,  Prev: quit,  Up: Control structures

5.2.10 return
-------------

`*Syntax:*'
     `return (' expression_list `);'
     `return ();'

`*Type:*'
     any

`*Purpose:*'
     returns the result(s) of a procedure and can only be used inside a
     procedure. Note that the brackets are required even if no return
     value is given.

`*Example:*'

          proc p2
          {
            int i,j;
            for(i=1;i<=10;i++)
            {
              j=j+i;
            }
            return(j);
          }
          // can also return an expression list, i.e., more than one value
          proc tworeturn ()
          { return (1,2); }
          int i,j = tworeturn();
          // return type may even depend on the input
          proc type_return (int i)
          {
            if (i > 0) {return (i);}
            else {return (list(i));}
          }
          // then we need def type (or list) to collect value
          def t1 = type_return(1);
          def t2 = type_return(-1);

* Menu:

See
* Data types::
* proc::

See *note Data types::; *note proc::.


File: singular.hlp,  Node: while,  Next: ~,  Prev: return,  Up: Control structures

5.2.11 while
------------

`*Syntax:*'
     `while ('boolean_expression`)' block

`*Purpose:*'
     repetitive, conditional execution of block.
     The boolean_expression is evaluated and if its value is TRUE, the
     block gets executed. This is repeated until boolean_expression
     evaluates to FALSE.  The command `break' leaves the innermost
     `while' construction.

`*Example:*'

          int i = 9;
          while (i>0)
          {
             // ... // do something for i=9, 8, ..., 1
             i = i - 1;
          }
          while (1)
          {
             // ...   // do something forever
             if (i == -5) // but leave the loop if i is -5
             {
               break;
             }
          }

* Menu:

See
* Control structures::
* boolean expressions::
* break::

See *note Control structures::; *note boolean expressions::; *note
break::.


File: singular.hlp,  Node: ~,  Prev: while,  Up: Control structures

5.2.12 ~ (break point)
----------------------

`*Syntax:*'
     `~;'

`*Purpose:*'
     sets a break point. Whenever SINGULAR reaches the command `~;' in a
     sequence of commands it prompts for input. The user may now input
     lines of SINGULAR commands. The line length cannot exceed 80
     characters.  SINGULAR proceeds with the execution of the command
     following `~;' as soon as it receives an empty line.

`*Example:*'

          proc t
          {
            int i=2;
            ~;
            return(i+1);
          }
          t();
          ==> -- break point in t --
          ==> -- 0: called    from STDIN --
          // here local variables of the procedure can be accessed
          i;
          ==> 2
          ==> -- break point in t --

          ==> 3

* Menu:

See
* Break points::

See *note Break points::.


File: singular.hlp,  Node: System variables,  Prev: Control structures,  Up: Functions and system variables

5.3 System variables
====================


List of all system variables.

* Menu:

* degBound::
* echo::
* minpoly::
* multBound::
* noether::
* printlevel::
* short::
* timer::
* TRACE var::
* rtimer::
* voice::


File: singular.hlp,  Node: degBound,  Next: echo,  Prev: System variables,  Up: System variables

5.3.1 degBound
--------------

`*Type:*'
     int

`*Purpose:*'
     The standard basis computation is stopped if the total (weighted)
     degree exceeds `degBound'.
     `degBound' should not be used for a global ordering with
     inhomogeneous input.
     Reset this bound by setting `degBound' to 0.

`*Example:*'

          degBound = 7;
          option();
          ==> //options for 'std'-command: degBound
          ideal j=std(i);
          degBound;
          ==> 7
          degBound = 0; //resets degree bound to infinity

* Menu:

See
* deg::
* int::
* option::
* std::

See *note deg::; *note int::; *note option::; *note std::.


File: singular.hlp,  Node: echo,  Next: minpoly,  Prev: degBound,  Up: System variables

5.3.2 echo
----------

`*Type:*'
     int

`*Purpose:*'
     input is echoed if `echo' >= `voice'.
     `echo' is a local setting for a procedure and defaulted to 0.
     `echo' does not affect the output of commands.

`*Example:*'

          echo = 1;
          int i = echo;
          ==> int i = echo;

* Menu:

See
* int::
* voice::

See *note int::; *note voice::.


File: singular.hlp,  Node: minpoly,  Next: multBound,  Prev: echo,  Up: System variables

5.3.3 minpoly
-------------

`*Type:*'
     number

`*Purpose:*'
     describes the coefficient field of the current basering as an
     algebraic extension with the minimal polynomial equal to `minpoly'.
     Setting the `minpoly' should be the first command after defining
     the ring.

`*Note:*'
     The minimal polynomial has to be specified in the syntax of a
     polynomial.  Its variable is not one of the ring variables, but the
     algebraic element which is being adjoined to the field.  Algebraic
     extensions in SINGULAR are only possible over the rational numbers
     or over Z/p, p a prime number.
     SINGULAR does not check whether the given polynomial is
     irreducible! It can be checked in advance with the function
     `factorize' (*note factorize::).

`*Example:*'

            //(Q[i]/(i^2+1))[x,y,z]:
            ring Cxyz=(0,i),(x,y,z),dp;
            minpoly=i^2+1;
            i2;  //this is a number, not a poly
          ==> -1

* Menu:

See
* factorize::
* ring::

See *note factorize::; *note ring::.


File: singular.hlp,  Node: multBound,  Next: noether,  Prev: minpoly,  Up: System variables

5.3.4 multBound
---------------

`*Type:*'
     int

`*Purpose:*'
     The standard basis computation is stopped if the ideal is
     zero-dimensional in a ring with local ordering and its multiplicity
     (`mult') is lower than `multBound'.
     Reset this bound by setting `multBound' to 0.

`*Example:*'

          multBound = 20;
          option();
          ==>    //options for 'std'-command: multBound
          ideal j=std(i);
          multBound;
          ==> 20
          multBound = 0;  //disables multBound

* Menu:

See
* int::
* mult::
* option::
* std::

See *note int::; *note mult::; *note option::; *note std::.


File: singular.hlp,  Node: noether,  Next: printlevel,  Prev: multBound,  Up: System variables

5.3.5 noether
-------------

`*Type:*'
     poly

`*Purpose:*'
     The standard basis computation in local rings cuts off  all
     monomials above (in the sense of the monomial ordering) the
     monomial `noether' during the computation.
     Reset `noether' by setting `noether' to 0.

`*Example:*'

            ring R=32003,(x,y,z),ds;
            ideal i=x2+y12,y13;
            std(i);
          ==> _[1]=x2+y12
          ==> _[2]=y13
            noether=x11;
            std(i);
          ==> _[1]=x2
            noether=0; //disables noether

* Menu:

See
* poly::
* std::

See *note poly::; *note std::.


File: singular.hlp,  Node: printlevel,  Next: short,  Prev: noether,  Up: System variables

5.3.6 printlevel
----------------

`*Type:*'
     int

`*Purpose:*'
     sets the debug level for `dbprint'.  If `printlevel' >= `voice'
     then `dbprint' is equivalent to `print', otherwise nothing is
     printed.

`*Note:*'
     *Note Procedures in a library::, for a small example about how this
     is used for the display of comments while procedures are executed.

`*Example:*'

            voice;
          ==> 1
            printlevel=0;
            dbprint(1);
            printlevel=voice;
            dbprint(1);
          ==> 1

* Menu:

See
* dbprint::
* int::
* voice::

See *note dbprint::; *note int::; *note voice::.


File: singular.hlp,  Node: short,  Next: timer,  Prev: printlevel,  Up: System variables

5.3.7 short
-----------

`*Type:*'
     int

`*Purpose:*'
     the output of monomials is done in the short manner, if `short' is
     non-zero. A C-like notion is used, if short is zero.  Both
     notations may be used as input.
     The default depends on the names of the ring variables (0 if there
     are names of variables longer than 1 character, 1 otherwise). Every
     change of the basering sets `short' to the previous value for that
     ring. In other words, the value of the variable `short' is
     "ring-local".

`*Example:*'

            ring r=23,x,dp;
            int save=short;
            short=1;
            2x2,x2;
          ==> 2x2 x2
            short=0;
            2x2,x2;
          ==> 2*x^2 x^2
            short=save;  //resets short to the previous value

* Menu:

See
* int::

See *note int::.


File: singular.hlp,  Node: timer,  Next: TRACE var,  Prev: short,  Up: System variables

5.3.8 timer
-----------

`*Type:*'
     int

`*Purpose:*'

       1. the CPU time (i.e, user and system time) used for each command
          is printed if timer >0 , if this time is bigger than a
          (customizable) minimal time and if `printlevel+1 >= voice'
          (which is by default true on the SINGULAR top level, but not
          true while procedures are executed).

       2. yields the used CPU time since the start-up of SINGULAR in a
          (customizable) resolution.

     The default setting of `timer' is 0, the default minimal time is
     0.5 seconds, and the default timer resolution is 1 (i.e., the
     default unit of time is one second). The minimal time and timer
     resolution can be set using the command line options `--min-time'
     and `--ticks-per-sec' and can be checked using
     `system("--min-time")' and `system("--ticks-per-sec")'.

     How to use `timer' in order to measure the time for a sequence of
     commands, see example below.

`*Note for Windows95/98:*'
     The value of the `timer' cannot be used (resp. trusted) when
     SINGULAR is run under Windows95/98 (this is due to the shortcomings
     of the Windows95/98 operating system). Use *note rtimer::, instead.

`*Example:*'

            timer=1; // The time of each command is printed
            int t=timer; // initialize t by timer
            ring r=0,(x,y,z),dp;
            poly p=(x+2y+3z+4xy+5xz+6yz)^20;
            // timer as int_expression:
            t=timer-t;
            t;  // yields the time in ticks-per-sec (default 1)
          ==> 0
                // since t was initialized by timer
            int tps=system("--ticks-per-sec");
            t/tps; // yields the time in seconds truncated to int
          ==> 0

* Menu:

See
* Command line options::
* printlevel::
* rtimer::
* system::
* voice::

See *note Command line options::; *note printlevel::; *note rtimer::;
*note system::; *note voice::.


File: singular.hlp,  Node: TRACE var,  Next: rtimer,  Prev: timer,  Up: System variables

5.3.9 TRACE
-----------

`*Type:*'
     int

`*Purpose:*'
     sets level of debugging.

     `TRACE=0'
          no debugging messages are printed.

     `TRACE=1'
          messages about entering and leaving of procedures are
          displayed.

     `TRACE=3'
          messages about entering and leaving of procedures together
          with line numbers are displayed.

     `TRACE=4'
          each line is echoed and the interpretation of commands in this
          line is suspended until the user presses `RETURN'.


     `TRACE' is defaulted to 0.
     `TRACE' does not affect the output of commands.

`*Example:*'

            TRACE=1;
            LIB "general.lib";
            sum(1..100);
          ==> entering sum (level 0)
          ==> leaving  sum (level 0)
          ==> 5050

* Menu:

See
* int::

See *note int::.


File: singular.hlp,  Node: rtimer,  Next: voice,  Prev: TRACE var,  Up: System variables

5.3.10 rtimer
-------------

`*Type:*'
     int

`*Purpose:*'
     identical to `timer' (*note timer::), except that real times (i.e.,
     wall-clock) times are reported, instead of CPU times. This can be
     trusted on all operating systems (including Windows95/98).


File: singular.hlp,  Node: voice,  Prev: rtimer,  Up: System variables

5.3.11 voice
------------

`*Type:*'
     int

`*Purpose:*'
     shows the nesting level of procedures.

`*Note:*'
     *Note Guidelines for writing a library::, for an small example how
     this is used for the display of comments while procedures are
     executed.

`*Example:*'

            voice;
          ==> 1
          proc p
          {
            voice;
          };
          p();
          ==> 2

* Menu:

See
* dbprint::
* listvar::
* printlevel::

See *note dbprint::; *note listvar::; *note printlevel::.


File: singular.hlp,  Node: Tricks and pitfalls,  Next: Examples,  Prev: Functions and system variables,  Up: Top

6 Tricks and pitfalls
*********************

* Menu:

* Limitations::
* Major differences to the C programming language::
* Miscellaneous oddities::
* Identifier resolution::


File: singular.hlp,  Node: Limitations,  Next: Major differences to the C programming language,  Up: Tricks and pitfalls

6.1 Limitations
===============

SINGULAR has the following limitations:
   * the characteristic of a prime field must be less than 2147483629

   * the (weighted) degree of a monomial must be smaller than the
     largest `long', usually 2147483648

   * the exponent of a ring variable must be smaller than 32768 unless
     the ring ordering start with the pseudo ordering `L(' max_exponent
     `)'

   * the rank of any free module must be smaller than the largest
     `long', usually 2147483648

   * the number of parameters must be smaller than 32768

   * the number of ring variables must be smaller than 32768

   * the precision of long floating point numbers (for ground field
     `real') must be smaller than 32768

   * integers (of type `int') have the limited range from -2147483647 to
     2147483647

   * floating point numbers (type `number' from field `real') have a
     limited range which is machine dependent. A typical range is
     -1.0e-38 to 1.0e+38.  The string representation of overflow and
     underflow is machine dependent, as well. For example "`Inf'" on
     Linux, or "`+.+00e+00'" on HPUX.

   * the length of an identifier is unlimited but `listvar' displays
     only the first 20 characters

   * statements may not contain more than 10000 tokens

   * All input to Singular must be 7-bit clean, i.e. special characters
     like the the German Umlaute (a", o", etc.), or the French accent
     characters may neither appear as input to SINGULAR, nor in
     libraries or procedure definitions.


File: singular.hlp,  Node: Major differences to the C programming language,  Next: Miscellaneous oddities,  Prev: Limitations,  Up: Tricks and pitfalls

6.2 Major differences to the C programming language
===================================================

Although many constructs from SINGULAR's programming language are
similar to those from the C programming language, there are some subtle
differences. Most notably:

* Menu:

* No rvalue of increments and assignments::
* Evaluation of logical expressions::
* No case or switch statement::
* Usage of commas::
* Usage of brackets::
* Behavior of continue::
* Return type of procedures::


File: singular.hlp,  Node: No rvalue of increments and assignments,  Next: Evaluation of logical expressions,  Up: Major differences to the C programming language

6.2.1 No rvalue of increments and assignments
---------------------------------------------

The increment operator `++' (resp. decrement operator `--') has no
rvalue, i.e., cannot be used on the right-hand sides of assignments.
So, instead of

     j = i++;  // WRONG!!!

(which results in an error), it must be written

     i++; j = i;

Likewise, an assignment expression does not have a result.  Therefore,
compound assignments like `i = j = k;' are not allowed and result in an
error.


File: singular.hlp,  Node: Evaluation of logical expressions,  Next: No case or switch statement,  Prev: No rvalue of increments and assignments,  Up: Major differences to the C programming language

6.2.2 Evaluation of logical expressions
---------------------------------------

*All* arguments of a logical expression are first evaluated and then the
value of the logical expression is determined. For example, the logical
expressions `(a || b)' is evaluated by first evaluating `a' _and_ `b',
even though the value of `b' has no influence on the value of `(a ||
b)', if `a' evaluates to true.

Note, that this evaluation is different from the left-to-right,
conditional evaluation of logical expressions (as found in most
programming languages). For example, in these other languages, the value
of `(1 || b)' is determined without ever evaluating `b'.  This causes
some problems with boolean tests on variables, which might not be
defined at evaluation time. For example, the following results in an
error, if the variable `i' is undefined:

     if (defined(i) && i > 0) {} // WRONG!!!

This must be written instead as:

     if (defined(i))
     {
       if (i > 0) {}
     }

However, there are several short work-arounds for this problem:
  1. If a variable (say, `i') is only to be used as a boolean flag, then
     define (value is TRUE) and undefine (value is FALSE) `i' instead of
     assigning a value. Using this scheme, it is sufficient to simply
     write

          if (defined(i))

     in order to check whether `i' is TRUE. Use the command `kill' to
     undefine a variable, i.e. to assign it a FALSE value (*note
     kill::).

  2. If a variable  can have more than two values, then define it, if
     necessary, before it is used for the first time.  For example, if
     the following is used within a procedure

          if (! defined(DEBUG)) { int DEBUG = 1;}
          ...
          if (DEBUG == 3)  {...}
          if (DEBUG == 2)  {...}
          ...

     then a user of this procedure does not need to care about the
     existence of the `DEBUG' variable - this remains hidden from the
     user. However, if `DEBUG' exists globally, then its local default
     value is overwritten by its global one.


File: singular.hlp,  Node: No case or switch statement,  Next: Usage of commas,  Prev: Evaluation of logical expressions,  Up: Major differences to the C programming language

6.2.3 No case or switch statement
---------------------------------

SINGULAR does not offer a `case' (or `switch') statement. However, it
can be imitated in the following way:

     while (1)
     {
        if (choice == choice_1) { ...; break;}
        ...
        if (choice == choice_n) { ...; break;}
        // default case
        ...; break;
     }


File: singular.hlp,  Node: Usage of commas,  Next: Usage of brackets,  Prev: No case or switch statement,  Up: Major differences to the C programming language

6.2.4 Usage of commas
---------------------

In SINGULAR, a comma separates list elements and the value of a comma
expression is a list.  Hence, commas can not be used to combine several
expressions into a single expression. For example, instead of writing

     for (i=1, j=5; i<5 || j<10; i++, j++) {...} // WRONG!!!!!!

one has to write

     for (i,j = 1,5; i<5 || j<10; i++, j++) {...}


File: singular.hlp,  Node: Usage of brackets,  Next: Behavior of continue,  Prev: Usage of commas,  Up: Major differences to the C programming language

6.2.5 Usage of brackets
-----------------------

In SINGULAR, curly brackets (`{' `}') *must always* be used to enclose
the statement body following such constructs like `if', `else', `for',
or `while', even if this block consists of only a single statement.
Similarly, in the return statement of a procedure, parentheses (`(' `)')
*must always* be used to enclose the return value.  Even if there is no
value to return, parentheses have to be used after a return statement
(i.e., `return();').  For example,

     if (i == 1) return i;    // WRONG!!!!!

results in an error. Instead, it must be written as

     if (i == 1) { return (i); }


File: singular.hlp,  Node: Behavior of continue,  Next: Return type of procedures,  Prev: Usage of brackets,  Up: Major differences to the C programming language

6.2.6 Behavior of continue
--------------------------

SINGULAR's `continue' construct is only valid inside the body of a `for'
or `while' construct. It skips the rest of the loop-body and jumps to
the beginning of the block. Unlike the C-construct SINGULAR's `continue'
*does not execute the increment statement*. For example,

     for (int i = 1 ; i<=10; i=i+1)
     {
        ...
        if (i==3) { i=8;continue; }
          // skip the rest if i is 3 and
          // continue with the next i: 8
        i;
     }
     ==> 1
     ==> 2
     ==> 8
     ==> 9
     ==> 10


File: singular.hlp,  Node: Return type of procedures,  Prev: Behavior of continue,  Up: Major differences to the C programming language

6.2.7 Return type of procedures
-------------------------------

Although the SINGULAR language is a strongly typed programming language,
the type of the return value of a procedure does not need to be
specified. As a consequence, the return type of a procedure may vary,
i.e., may, for example, depend on the input. However, the return value
of such a procedure may then only be assigned to a variable of type
`def'.

     proc type_return (int i)
     {
       if (i > 0) {return (i);}
       else {return (list(i));}
     }
     def t1 = type_return(1);
     def t2 = type_return(-1);
     typeof(t1); typeof(t2);
     ==> int
     ==> list

Furthermore, it is mandatory to assign the return value of a procedure
to a variable of type `def', if a procedure changes the current ring
using the `keepring' command (*note keepring::) and returns a
ring-dependent value (like a polynomial or module).

     proc def_return
     {
       ring r=0,(x,y),dp;
       poly p = x;
       keepring r;
       return (x);
     }
     def p = def_return();
     // poly p = def_return(); would be WRONG!!!
     typeof(p);
     ==> poly

On the other hand, more than one value can be returned by a single
`return' statement. For example,

     proc tworeturn () { return (1,2); }
     int i,j = tworeturn();


File: singular.hlp,  Node: Miscellaneous oddities,  Next: Identifier resolution,  Prev: Major differences to the C programming language,  Up: Tricks and pitfalls

6.3 Miscellaneous oddities
==========================

  1. integer division

     If two numerical constants (i.e., two sequences of digits) are
     divided using the `/' operator, the surrounding whitespace
     determines which division to use: if there is no space between the
     constants and the `/' operator (e.g., "3/2"), both numerical
     constants are treated as of type `number' and the current ring
     division is used. If there is at least one space surrounding the
     `/' operator (e.g., "3 / 2"), both numerical constants are treated
     as of type `int' and an integer division is performed. To avoid
     confusion, use the `div' operator instead of `/' for integer
     division and an explicit type cast to `number' for ring division.
     Note, that this problem does only occur for divisions of numerical
     constants.

            ring r=32002,x,dp;
            3/2;    // ring division
          ==> -15994
            3 / 2;  // integer division
          ==> 1
            3 div 2;
          ==> 1
            number(3) / number(2);
          ==> -15994
            number a=3;
            number b=2;
            a/b;
          ==> -15994
            int c=3;
            int d=2;
            c / d;
          ==> 1

  2. monomials and precedence

     The computation of a monomial has precedence over all operators:

            ring r=0,(x,y),dp;
            2xy^2 == (2*x*y)^2;
          ==> 1
            2xy^2 == 2x*y^2;
          ==> 0
            2x*y^2 == 2*x * (y^2);
          ==> 1

  3. meaning of `mult'

     For an arbitrary ideal or module `i', `mult(i)' returns the
     multiplicity of the ideal generated by the leading monomials of the
     given generators of `i', hence depends on the monomial ordering!

     A standard mistake is to interpret `degree(i)' or `mult(i)' for an
     inhomogeneous ideal `i' as the degree of the homogenization or as
     something like the 'degree of the affine part'. For the ordering
     `dp' (degree reverse lexicographical) the converse is true: if `i'
     is given by a standard basis, `mult(i)' is the degree of the
     homogeneous ideal obtained by homogenization of `i' and then
     putting the homogenizing variable to 0, hence it is the degree of
     the part at infinity (this can also be checked by looking at the
     initial ideal).

  4. size of ideals

     `size' counts the non-zero entries of an ideal or module. Use
     `ncols' to determine the actual number of entries in the ideal or
     module.

  5. computations in `qring'

     In order to speed up computations in quotient rings, SINGULAR
     usually does not reduce polynomials w.r.t. the quotient ideal;
     rather the given representative is used as long as possible during
     computations. If it is necessary, reduction is done during standard
     base computations. To reduce a polynomial `f' by hand w.r.t. the
     current quotient ideal use the command `reduce(f,std(0))' (*note
     reduce::).

  6. substring selection

     To extract substrings from a `string', square brackets are used,
     enclosing either two comma-separated `int's or an `intvec'.
     Although two comma-separated `int's represent an `intvec', they
     mean different things in substring access. Square brackets
     enclosing two `int's (e.g. `s[2,6]') return a substring where the
     first integer denotes the starting position and the second integer
     denotes the length of the substring. The result is returned as a
     `string'. Square brackets enclosing an `intvec' (e.g.
     `s[intvec(2,6)]') return the characters of the string at the
     position given by the values of the `intvec'. The result is
     returned as an expression list of strings.

            string s = "one-word";
            s[2,6];     // a substring starting at the second char
          ==> ne-wor
            size(_);
          ==> 6
            intvec v = 2,6;
            s[v];      // the second and the sixth char
          ==> n o
            string st = s[v];  // stick together by an assignment
            st;
          ==> no
            size(_);
          ==> 2
            v = 2,6,8;
            s[v];
          ==> n o d


File: singular.hlp,  Node: Identifier resolution,  Prev: Miscellaneous oddities,  Up: Tricks and pitfalls

6.4 Identifier resolution
=========================

In SINGULAR, an identifier (i.e., a "word") is resolved in the following
way and order: It is checked for
  1. a reserved name (like `ring', `std', ...),

  2. a local  variable (w.r.t. a procedure),

  3. a local ring variable (w.r.t. the current basering locally set in a
     procedure),

  4. a global variable,

  5. a global ring variable (w.r.t. the current basering)

  6. a monomial consisting of local ring variables written without
     operators,

  7. a monomial consisting of global ring variables written without
     operators.

Consequently, it is allowed to have general variables with the same name
as ring  variables. However, the above identifier resolution order must
be kept in mind. Otherwise, surprising results may come up.

     ring r=0,(x,y),dp;
     int x;
     x*y; // resolved product int*poly, i.e., 0*y
     ==> 0
     xy; // "xy" is one identifier and resolved to monomial xy
     ==> xy

For these reasons, we strongly recommend not to use variables which have
the same name(s) as ring variables.

Moreover, we strongly recommend not to use ring variables whose name is
fully contained in (i.e., is a substring of) another name of a ring
variable. Otherwise, effects like the following might occur:

     ring r=0,(x, x1),dp; // name x is substring of name x1 !!!!!!!!!
     x;x1;   // resolved poly x
     ==> x
     ==> x1
     short=0; 2x1; // resolved to monomial 2*x^1 !!!!!!
     ==> 2*x
     2*x1; // resolved to product 2 times x1
     ==> 2*x1


File: singular.hlp,  Node: Examples,  Next: Polynomial data,  Prev: Tricks and pitfalls,  Up: Top

Appendix A Examples
*******************

The following topics are treated:

* Menu:

* Milnor and Tjurina::
* Procedures and LIB::
* Critical points::
* Saturation::
* Long coefficients::
* Parameters::
* T1 and T2::
* Deformations::
* Finite fields::
* Elimination::
* Free resolution::
* Computation of Ext::
* Polar curves::
* Depth::
* Formatting output::
* Cyclic roots::
* G_a -Invariants::
* Invariants of a finite group::
* Factorization::
* Puiseux pairs::
* Primary decomposition::
* Normalization::
* Branches of an Isolated Space Curve Singularity::
* Kernel of module homomorphisms::
* Algebraic dependence::
* Classification::
* Fast lexicographical GB::
* Parallelization with MPtcp links::


File: singular.hlp,  Node: Milnor and Tjurina,  Next: Procedures and LIB,  Prev: Examples,  Up: Examples

A.1 Milnor and Tjurina
======================

The Milnor number, resp. the Tjurina number, of a power series f in $K[[x_1,\ldots,x_n]]$
K[[x1,...,xn]] is
milnor(f) = dim_K(K[[x1,...,xn]]/jacob(f))
resp.
tjurina(f) = dim_K(K[[x1,...,xn]]/((f)+jacob(f)))
where $$
\hbox{milnor}(f) = \hbox{dim}_K(K[[x_1,\ldots,x_n]]/\hbox{jacob}(f)),
$$
respectively
$$
\hbox{tjurina}(f) = \hbox{dim}_K(K[[x_1,\ldots,x_n]]/((f)+\hbox{jacob}(f)))
$$
where
`jacob(f)' is the ideal generated by the partials of `f'. `tjurina(f)'
is finite, if and only if `f' has an isolated singularity. The same
holds for `milnor(f)' if K has characteristic 0.  SINGULAR displays -1
if the dimension is infinite.

SINGULAR cannot compute with infinite power series. But it can work in $\hbox{Loc}_{(x)}K[x_1,\ldots,x_n]$,
Loc_(x)K[x1,...,xn], the localization of $K[x_1,\ldots,x_n]$
K[x1,...,xn] at the maximal ideal $(x_1,\ldots,x_n)$.
(x1,...,xn).  To do this one has to define an s-ordering like ds, Ds,
ls, ws, Ws or an appropriate matrix ordering (look at the manual to get
information about the possible monomial orderings in SINGULAR, or type
`help Monomial orderings;' to get a menu of possible orderings. For
further help type, e.g., `help local orderings;').  See *note Monomial
orderings::.

We shall show in the example below how to realize the following:
   * set option `prot' to have a short protocol during standard basis
     computation

   * define the ring `r1' with char 32003, variables `x,y,z', monomial
     ordering `ds', series ring (i.e., K[x,y,z] localized at (x,y,z))

   * list the information about `r1' by typing its name

   * define the integers `a,b,c,t'

   * define a polynomial `f' (depending on `a,b,c,t') and display it

   * define the jacobian ideal `i' of `f'

   * compute a standard basis of `i'

   * compute the Milnor number (=250) with `vdim' and create and display
       a string in order to comment the result   (text between quotes "
     "; is a 'string')

   * compute a standard basis of `i+(f)'

   * compute the Tjurina number (=195) with `vdim'

   * then compute the Milnor number (=248) and the Tjurina number (=195)
     for `t'=1

   * reset the option to `noprot'

       option(prot);
       ring r1 = 32003,(x,y,z),ds;
       r1;
     ==> //   characteristic : 32003
     ==> //   number of vars : 3
     ==> //        block   1 : ordering ds
     ==> //                  : names    x y z 
     ==> //        block   2 : ordering C
       int a,b,c,t=11,5,3,0;
       poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
                x^(c-2)*y^c*(y^2+t*x)^2;
       f;
     ==> y5+x5y2+x2y2z3+xy7+z9+x11
       ideal i=jacob(f);
       i;
     ==> i[1]=5x4y2+2xy2z3+y7+11x10
     ==> i[2]=5y4+2x5y+2x2yz3+7xy6
     ==> i[3]=3x2y2z2+9z8
       ideal j=std(i);
     ==> [1023:2]7(2)s8s10s11s12s(3)s13(4)s(5)s14(6)s(7)15--.s(6)-16.-.s(5)17.s(7)\
        s--s18(6).--19-..sH(24)20(3)...21....22....23.--24-
     ==> product criterion:10 chain criterion:69
       "The Milnor number of f(11,5,3) for t=0 is", vdim(j);
     ==> The Milnor number of f(11,5,3) for t=0 is 250
       j=i+f;    // overwrite j
       j=std(j);
     ==> [1023:2]7(3)s8(2)s10s11(3)ss12(4)s(5)s13(6)s(8)s14(9).s(10).15--sH(23)(8)\
        ...16......17.......sH(21)(9)sH(20)16(10).17...........18.......19..----.\
        .sH(19)
     ==> product criterion:10 chain criterion:53
       vdim(j);  // compute the Tjurina number for t=0
     ==> 195
       t=1;
       f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
         +x^(c-2)*y^c*(y^2+t*x)^2;
       ideal i1=jacob(f);
       ideal j1=std(i1);
     ==> [1023:2]7(2)s8s10s11s12s13(3)ss(4)s14(5)s(6)s15(7).....s(8)16.s...s(9)..1\
        7............s18(10).....s(11)..-.19.......sH(24)(10).....20...........21\
        ..........22.............................23..............................\
        .24.----------.25.26
     ==> product criterion:11 chain criterion:83
       "The Milnor number of f(11,5,3) for t=1:",vdim(j1);
     ==> The Milnor number of f(11,5,3) for t=1: 248
       vdim(std(j1+f));   // compute the Tjurina number for t=1
     ==> [1023:2]7(16)s8(15)s10s11ss(16)-12.s-s13s(17)s(18)s(19)-s(18).-14-s(17)-s\
        (16)ss(17)s15(18)..-s...--.16....-.......s(16).sH(23)s(18)...17..........\
        18.........sH(20)17(17)....................18..........19..---....-.-....\
        .....20.-----...s17(9).........18..............19..-.......20.-......21..\
        .......sH(19)16(5).....18......19.-----
     ==> product criterion:15 chain criterion:174
     ==> 195
       option(noprot);


File: singular.hlp,  Node: Procedures and LIB,  Next: Critical points,  Prev: Milnor and Tjurina,  Up: Examples

A.2 Procedures and LIB
======================

The computation of the Milnor number (for an arbitrary isolated complete
intersection singularity ICIS) and the Tjurina number (for an arbitrary
isolated singularity) can be done by using procedures from the library
`sing.lib'. For a hypersurface singularity it is very easy to write a
procedure which computes the Milnor number and the Tjurina number.

We shall demonstrate:
   * load the library `sing.lib'

   * define a local ring in 2 variables and characteristic 0

   * define a plane curve singularity

   * compute Milnor number and Tjurina number by using the procedures
     `milnor' and `tjurina'

   * write your own procedures: (A procedure has a list of input
     parameters and of return values, both lists may be empty.)

            - the procedure `mil' which must be called with one
          parameter, a   polynomial.    The name g is local to the
          procedure and is killed automatically.    `mil' returns the
          Milnor number (and displays a comment).

        - the procedure `tjur' where the parameters are not specified.
          They   are referred   to by `#[1]' for the 1st, `#[2]' for the
          2nd parameter, etc.    `tjur' returns the Tjurina number (and
          displays a comment).

        - the procedure `milrina' which returns a list consisting of two
            integers,   the Milnor and the Tjurina number.

     LIB "sing.lib";
     // you should get the information that sing.lib has been loaded
     // together with some other libraries which are needed by sing.lib
     ring r = 0,(x,y),ds;
     poly f = x7+y7+(x-y)^2*x2y2;
     milnor(f);
     ==> 28
     tjurina(f);
     ==> 24

     proc mil (poly g)
     {
        "Milnor number:";
        return(vdim(std(jacob(g))));
     }
     mil(f);
     ==> Milnor number:
     ==> 28

     proc tjur
     {
        "Tjurina number:";
        return(vdim(std(jacob(#[1])+#[1])));
     }
     tjur(f);
     ==> Tjurina number:
     ==> 24

     proc milrina (poly f)
     {
        ideal j=jacob(f);
        list L=vdim(std(j)),vdim(std(j+f));
        return(L);
     }
     milrina(f);     // a list containing Milnor and Tjurina number
     ==> [1]:
     ==>    28
     ==> [2]:
     ==>    24
     milrina(f)[2];  // the second element of the list
     ==> 24


File: singular.hlp,  Node: Critical points,  Next: Saturation,  Prev: Procedures and LIB,  Up: Examples

A.3 Critical points
===================

The same computation which computes the Milnor, resp. the Tjurina,
number, but with ordering `dp' instead of `ds' (i.e., in $K[x_1,\ldots,x_n]$
K[x1,...,xn] instead of $\hbox{Loc}_{(x)}K[x_1,\ldots,x_n])$
Loc_(x)K[x1,...,xn]) gives:
   * the number of critical points of `f' in the affine plane (counted
     with multiplicities)

   * the number of singular points of `f' on the affine plane curve
     `f'=0 (counted with multiplicities).

We start with the ring `r1' from section *note Milnor and Tjurina:: and
its elements.

The following will be realized below:
   * reset the protocol option and activate the timer

   * define the ring `r2' with char 32003, variables `x,y,z' and
     monomial   ordering `dp' (= degrevlex) (i.e., the polynomial ring =
     K[x,y,z]).

   * Note that polynomials, ideals, matrices (of polys), vectors,
     modules belong to a ring, hence we have to define `f' and
     `jacob(f)'   again in `r2'. Since these objects are local to a
     ring, we may use   the same names.    Instead of defining `f' again
     we map it from ring `r1' to `r2'   by using the `imap' command
     (`imap' is a convenient way to map variables   from some ring
     identically to variables with the same name in the   basering, even
     if the ground field is different. Compare with `fetch'   which
     works for almost identical rings,   e.g., if the rings differ only
     by the ordering or by the names of the   variables and which may be
     used to rename variables).    Integers and strings, however, do not
     belong to any ring. Once   defined they are globally known.

   * The result of the computation here (together with the previous one
     in  *note Milnor and Tjurina::) shows that (for `t'=0) $\hbox{dim}_K(\hbox{Loc}_{(x,y,z)}K[x,y,z]/\hbox{jacob}(f))$
       dim_K(Loc_(x,y,z)K[x,y,z]/jacob(f)) = 250 (previously computed)
     while $\hbox{dim}_K(K[x,y,z]/\hbox{jacob}(f))$
       dim_K(K[x,y,z]/jacob(f)) = 536. Hence `f' has 286 critical
     points,   counted with multiplicity, outside the origin.
     Moreover, since $\hbox{dim}_K(\hbox{Loc}_{(x,y,z)}K[x,y,z]/(\hbox{jacob}(f)+(f)))$
     dim_K(Loc_(x,y,z)K[x,y,z]/(jacob(f)+(f))) = 195 = $\hbox{dim}_K(K[x,y,z]/(\hbox{jacob}(f)+(f)))$,
     dim_K(K[x,y,z]/(jacob(f)+(f))), the affine surface `f'=0 is smooth
     outside the origin.

       ring r1 = 32003,(x,y,z),ds;
       int a,b,c,t=11,5,3,0;
       poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
                x^(c-2)*y^c*(y^2+t*x)^2;
       option(noprot);
       timer=1;
       ring r2 = 32003,(x,y,z),dp;
       poly f=imap(r1,f);
       ideal j=jacob(f);
       vdim(std(j));
     ==> 536
       vdim(std(j+f));
     ==> 195
       timer=0;  // reset timer


File: singular.hlp,  Node: Saturation,  Next: Long coefficients,  Prev: Critical points,  Up: Examples

A.4 Saturation
==============

Since in the example above, the ideal j+(f) $j+(f)$
 has the same `vdim' in the polynomial ring and in the localization at 0
(each 195),

f=0 $f=0$
 is smooth outside 0.  Hence j+(f) $j+(f)$
 contains some power of the maximal ideal m $m$
. We shall check this in a different manner: For any two ideals i, j $i, j$
 in the basering R $R$
 let $$
\hbox{sat}(i,j)=\{x\in R\;|\; \exists\;n\hbox{ s.t. }
x\cdot(j^n)\subseteq i\}
= \bigcup_{n=1}^\infty i:j^n$$

sat(i,j) = {x in R | there is an n s.t. x*(j^n) contained in i}
= union_(n=1...) of i:j^n,
denote the saturation of i $i$
 with respect to j $j$
. This defines, geometrically, the closure of the complement of V( j $j$
) in V( i $i$
) (V( i $i$
) denotes the variety defined by i $i$
).  In our case, sat(j+(f),m) $sat(j+(f),m)$
 must be the whole ring, hence generated by 1.

The saturation is computed by the procedure `sat' in `elim.lib' by
computing iterated ideal quotients with the maximal ideal.  `sat'
returns a list of two elements: the saturated ideal and the number of
iterations.  (Note that `maxideal(n)' denotes the n-th power of the
maximal ideal).

       LIB "elim.lib";         // loading library elim.lib
       // you should get the information that elim.lib has been loaded
       // together with some other libraries which are needed by it
       option(noprot);         // no protocol
       ring r2 = 32003,(x,y,z),dp;
       poly f = x^11+y^5+z^(3*3)+x^(3+2)*y^(3-1)+x^(3-1)*y^(3-1)*z3+
         x^(3-2)*y^3*(y^2)^2;
       ideal j=jacob(f);
       sat(j+f,maxideal(1));
     ==> [1]:
     ==>    _[1]=1
     ==> [2]:
     ==>    17
       // list the variables defined so far:
       listvar();
     ==> // r2                   [0]  *ring
     ==> //      j                    [0]  ideal, 3 generator(s)
     ==> //      f                    [0]  poly
     ==> // LIB                  [0]  string standard.lib,elim.li..., 83 char(s)


File: singular.hlp,  Node: Long coefficients,  Next: Parameters,  Prev: Saturation,  Up: Examples

A.5 Long coefficients
=====================

The following innocent example produces in its standard basis extremely
long coefficients in char 0 for the lexicographical ordering.  But a
very small deformation does not (the undeformed example is degenerate
with respect to the Newton boundary).  This example demonstrates that it
might be wise, for complicated examples, to do the calculation first in
positive char (e.g., 32003).  It has been shown, that in complicated
examples, more than 95 percent of the time needed for a standard basis
computation is used in the computation of the coefficients (in char 0).
The representation of long integers with real is demonstrated.

     timer = 1;                              // activate the timer
     option(prot);
     ring R0 = 0,(x,y),lp;
     poly f = x5+y11+xy9+x3y9;
     ideal i = jacob(f);
     ideal i1 = i,i[1]*i[2];                 // undeformed ideal
     ideal i2 = i,i[1]*i[2]+1/1000000*x5y8;  // deformation of i1
     i1; i2;
     ==> i1[1]=5x4+3x2y9+y9
     ==> i1[2]=9x3y8+9xy8+11y10
     ==> i1[3]=45x7y8+27x5y17+45x5y8+55x4y10+36x3y17+33x2y19+9xy17+11y19
     ==> i2[1]=5x4+3x2y9+y9
     ==> i2[2]=9x3y8+9xy8+11y10
     ==> i2[3]=45x7y8+27x5y17+45000001/1000000x5y8+55x4y10+36x3y17+33x2y19+9xy17+1\
        1y19
     ideal j = std(i1);
     ==> [65535:1]11(2)ss19s20s21s22(3)-23-s27s28s29s30s31s32s33s34s35s36s37s38s39\
        s40s70-
     ==> product criterion:1 chain criterion:30
     j;
     ==> j[1]=264627y39+26244y35-1323135y30-131220y26+1715175y21+164025y17+1830125\
        y16
     ==> j[2]=12103947791971846719838321886393392913750065060875xy8-28639152114168\
        3198701331939250003266767738632875y38-31954402206909026926764622877573565\
        78554430672591y37+57436621420822663849721381265738895282846320y36+1657764\
        214948799497573918210031067353932439400y35+213018481589308191195677223898\
        98682697001205500y34+1822194158663066565585991976961565719648069806148y33\
        -4701709279892816135156972313196394005220175y32-1351872269688192267600786\
        97600850686824231975y31-3873063305929810816961516976025038053001141375y30\
        +1325886675843874047990382005421144061861290080000y29+1597720195476063141\
        9467945895542406089526966887310y28-26270181336309092660633348002625330426\
        7126525y27-7586082690893335269027136248944859544727953125y26-867853074106\
        49464602285843351672148965395945625y25-5545808143273594102173252331151835\
        700278863924745y24+19075563013460437364679153779038394895638325y23+548562\
        322715501761058348996776922561074021125y22+157465452677648386073957464715\
        68100780933983125y21-1414279129721176222978654235817359505555191156250y20\
        -20711190069445893615213399650035715378169943423125y19+272942733337472665\
        573418092977905322984009750y18+789065115845334505801847294677413365720955\
        3750y17+63554897038491686787729656061044724651089803125y16-22099251729923\
        906699732244761028266074350255961625y14+147937139679655904353579489722585\
        91339027857296625y10
     ==> j[3]=5x4+3x2y9+y9
     // Compute average coefficient length (=51) by
     //   - converting j[2] to a string in order to compute the number
     //   of characters
     //   - divide this by the number of monomials:
     size(string(j[2]))/size(j[2]);
     ==> 51
     vdim(j);
     ==> 63
     // For a better representation normalize the long coefficients
     // of the polynomial j[2] and map it  to real:
     poly p=(1/12103947791971846719838321886393392913750065060875)*j[2];
     ring R1=real,(x,y),lp;
     short=0; // force the long output format
     poly p=imap(R0,p);
     p;
     ==> x*y^8-2.366e-02*y^38-2.640e-01*y^37+4.745e-06*y^36+1.370e-04*y^35+1.760e-\
        03*y^34+1.505e-01*y^33+3.884e-07*y^32-1.117e-05*y^31-3.200e-04*y^30+1.095\
        e-01*y^29+1.320e+00*y^28-2.170e-05*y^27-6.267e-04*y^26-7.170e-03*y^25-4.5\
        82e-01*y^24+1.576e-06*y^23+4.532e-05*y^22+1.301e-03*y^21-1.168e-01*y^20-1\
        .711e+00*y^19+2.255e-05*y^18+6.519e-04*y^17+5.251e-03*y^16-1.826e+00*y^14\
        +1.222e+00*y^10
     // Compute a standard basis for the deformed ideal:
     setring R0;
     j = std(i2);
     ==> [65535:1]11(2)ss19s20s21s22(3)-s23(2)s27.28.s29(3)s30.s31ss32sss33sss34ss\
        35--38-
     ==> product criterion:11 chain criterion:21
     j;
     ==> j[1]=y16
     ==> j[2]=65610xy8+17393508y27+7223337y23+545292y19+6442040y18-119790y14+80190\
        y10
     ==> j[3]=5x4+3x2y9+y9
     vdim(j);
     ==> 40


File: singular.hlp,  Node: Parameters,  Next: T1 and T2,  Prev: Long coefficients,  Up: Examples

A.6 Parameters
==============

Let us deform the above ideal now by introducing a parameter t and
compute over the ground field Q(t).  We compute the dimension at the
generic point, i.e., $dim_{Q(t)}Q(t)[x,y]/j$.
dim_Q(t) Q(t)[x,y]/j.  (This gives the same result as for the deformed
ideal above. Hence, the above small deformation was "generic".)

For almost all $a \in Q$
a in Q this is the same as $dim_Q Q[x,y]/j_0$,
dim_Q Q[x,y]/j0, where $j_0=j|_{t=a}$.
j_0=j_t=a

       ring Rt = (0,t),(x,y),lp;
       Rt;
     ==> //   characteristic : 0
     ==> //   1 parameter    : t 
     ==> //   minpoly        : 0
     ==> //   number of vars : 2
     ==> //        block   1 : ordering lp
     ==> //                  : names    x y 
     ==> //        block   2 : ordering C
       poly f = x5+y11+xy9+x3y9;
       ideal i = jacob(f);
       ideal j = i,i[1]*i[2]+t*x5y8;  // deformed ideal, parameter t
       vdim(std(j));
     ==> 40
       ring R=0,(x,y),lp;
       ideal i=imap(Rt,i);
       int a=random(1,30000);
       ideal j=i,i[1]*i[2]+a*x5y8;  // deformed ideal, fixed integer a
       vdim(std(j));
     ==> 40


File: singular.hlp,  Node: T1 and T2,  Next: Deformations,  Prev: Parameters,  Up: Examples

A.7 T1 and T2
=============

T^1 $T^1$
, resp. T^2 $T^2$
, of an ideal j $j$
 usually denote the modules of infinitesimal deformations, resp. of
obstructions.  In SINGULAR there are procedures `T_1' and `T_2' in
`sing.lib' such that `T_1(j)' and `T_2(j)' compute a standard basis of a
presentation of these modules.  If T_1 and T_2 are finite dimensional
K-vector spaces (e.g., for isolated singularities), a basis can be
computed by applying `kbase(T_1(j));', resp. `kbase(T_2(j));', the
dimensions by applying `vdim'.  For a complete intersection j the
procedure `Tjurina' also computes T_1, but faster (T_2=0 in this case).
For a non complete intersection, it is faster to use the procedure
`T_12' instead of `T_1' and `T_2'.  Type `help T_1;' (or `help T_2;' or
`help T_12;') to obtain more detailed information about these
procedures.

We give three examples, the first being a hypersurface, the second a
complete intersection, the third no complete intersection:
   * load `sing.lib'

   * check whether the ideal j is a complete intersection. It is, if
     number of variables = dimension + minimal number of generators

   * compute the Tjurina number

   * compute a vector space basis (kbase) of T_1

   * compute the Hilbert function of T_1

   * create a polynomial encoding the Hilbert series

   * compute the dimension of T_2

       LIB "sing.lib";
       ring R=32003,(x,y,z),ds;
       // ---------------------------------------
       // hypersurface case (from series T[p,q,r]):
       int p,q,r = 3,3,4;
       poly f = x^p+y^q+z^r+xyz;
       tjurina(f);
     ==> 8
       // Tjurina number = 8
       kbase(Tjurina(f));
     ==> // Tjurina number = 8
     ==> _[1]=z3
     ==> _[2]=z2
     ==> _[3]=yz
     ==> _[4]=xz
     ==> _[5]=z
     ==> _[6]=y
     ==> _[7]=x
     ==> _[8]=1
       // ---------------------------------------
       // complete intersection case (from series P[k,l]):
       int k,l =3,2;
       ideal j=xy,x^k+y^l+z2;
       dim(std(j));          // Krull dimension
     ==> 1
       size(minbase(j));     // minimal number of generators
     ==> 2
       tjurina(j);           // Tjurina number
     ==> 6
       module T=Tjurina(j);
     ==> // Tjurina number = 6
       kbase(T);             // a sparse output of the k-basis of T_1
     ==> _[1]=z*gen(1)
     ==> _[2]=gen(1)
     ==> _[3]=y*gen(2)
     ==> _[4]=x2*gen(2)
     ==> _[5]=x*gen(2)
     ==> _[6]=gen(2)
       print(kbase(T));      // columns of matrix are a k-basis of T_1
     ==> z,1,0,0, 0,0,
     ==> 0,0,y,x2,x,1 
       // ---------------------------------------
       // general case (cone over rational normal curve of degree 4):
       ring r1=0,(x,y,z,u,v),ds;
       matrix m[2][4]=x,y,z,u,y,z,u,v;
       ideal i=minor(m,2);   // 2x2 minors of matrix m
       module M=T_1(i);       // a presentation matrix of T_1
     ==> // dim T_1 = 4
       vdim(M);              // Tjurina number
     ==> 4
       hilb(M);              // display of both Hilbert series
     ==> //         4 t^0
     ==> //       -20 t^1
     ==> //        40 t^2
     ==> //       -40 t^3
     ==> //        20 t^4
     ==> //        -4 t^5
     ==> 
     ==> //         4 t^0
     ==> // dimension (local)   = 0
     ==> // multiplicity = 4
       intvec v1=hilb(M,1);  // first Hilbert series as intvec
       intvec v2=hilb(M,2);  // second Hilbert series as intvec
       v1;
     ==> 4,-20,40,-40,20,-4,0
       v2;
     ==> 4,0
       v1[3];                // 3rd coefficient of the 1st Hilbert series
     ==> 40
       module N=T_2(i);
     ==> // dim T_2 = 3
     // In some cases it might be useful to have a polynomial in some ring
     // encoding the Hilbert series. This polynomial can then be
     // differentiated, evaluated etc. It can be done as follows:
     ring H = 0,t,ls;
     poly h1;
     int ii;
     for (ii=1; ii<=size(v1); ii=ii+1)
     {
        h1=h1+v1[ii]*t^(ii-1);
     }
     h1;                   // 1st Hilbert series
     ==> 4-20t+40t2-40t3+20t4-4t5
     diff(h1,t);           // differentiate  h1
     ==> -20+80t-120t2+80t3-20t4
     subst(h1,t,1);        // substitute t by 1
     ==> 0

     // The procedures T_1, T_2, T_12 may be called with two arguments and then
     // they return a list with more information (type help T_1; etc.)
     // e.g., T_12(i,<any>); returns a list with 9 nonempty objects where
     // _[1] = std basis of T_1-module, _[2] = std basis of T_2-module,
     // _[3]= vdim of T_1, _[4]= vdim of T_2
     setring r1;           // make r1 again the basering
     list L = T_12(i,1);
     ==> // dim T_1  =  4
     ==> // dim T_2  =  3
     kbase(L[1]);          // kbase of T_1
     ==> _[1]=1*gen(2)
     ==> _[2]=1*gen(3)
     ==> _[3]=1*gen(6)
     ==> _[4]=1*gen(7)
     kbase(L[2]);          // kbase of T_2
     ==> _[1]=1*gen(6)
     ==> _[2]=1*gen(8)
     ==> _[3]=1*gen(9)
     L[3];                 // vdim of T_1
     ==> 4
     L[4];                 // vdim of T_2
     ==> 3


File: singular.hlp,  Node: Deformations,  Next: Finite fields,  Prev: T1 and T2,  Up: Examples

A.8 Deformations
================

   * The libraries `sing.lib', resp. `deform.lib', contain procedures to
     compute total and base space of the miniversal (= semiuniversal)
     deformation of an isolated complete intersection singularity, resp.
     arbitrary isolated singularity.

   * The procedure `deform' in `sing.lib' returns a matrix whose columns
     `h_1,..., h_r' $h_1,\ldots,h_r$
     represent all 1st order deformations. More precisely, if I in R is
     the ideal generated by `f_1,...,f_s', then any infinitesimal
     deformation of R/I over K[e]/(e^2) is given by `f+eg', where
     f=(f_1,...,f_s), g a K-linear combination of the h_i.  $I \subset R$ is the ideal generated by $f_1,...,f_s$, then any infinitesimal
     deformation of $R/I$ over $K[\varepsilon]/(\varepsilon^2)$ is given
     by $f+\varepsilon g$,
     where $f=(f_1,...,f_s)$, $g$ a $K$-linear combination of the $h_i$.

   * The procedure `versal' in `deform.lib' computes a formal miniversal
     deformation up to a certain order which can be prescribed by the
     user. For a complete intersection the 1st order part is already
     miniversal.

   * The procedure `versal' extends the basering to a new ring with
     additional deformation parameters which contains the equations for
     the miniversal base space and the miniversal total space.

   * There are default names for the objects created, but the user may
     also choose his own names.

   * If the user sets `printlevel=2;' before running `versal', some
     intermediate results are shown. This is useful since `versal' is
     already complicated and might run for some time on more complicated
     examples. (type `help versal;')

We compute for the same examples as in the preceding section the
miniversal deformations:

       LIB "deform.lib";
       ring R=32003,(x,y,z),ds;
       //----------------------------------------------------
       // hypersurface case (from series T[p,q,r]):
       int p,q,r = 3,3,4;
       poly f = x^p+y^q+z^r+xyz;
       print(deform(f));
     ==> z3,z2,yz,xz,z,y,x,1
       // the miniversal deformation of f=0 is the projection from the
       // miniversal total space to the miniversal base space:
       // { (A,B,C,D,E,F,G,H,x,y,z) | x3+y3+xyz+z4+A+Bx+Cxz+Dy+Eyz+Fz+Gz2+Hz3 =0 }
       //  --> { (A,B,C,D,E,F,G,H) }
       //----------------------------------------------------
       // complete intersection case (from series P[k,l]):
       int k,l =3,2;
       ideal j=xy,x^k+y^l+z2;
       print(deform(j));
     ==> 0,0, 0,0,z,1,
     ==> y,x2,x,1,0,0 
       versal(j);                  // using default names
     ==> // smooth base space
     ==> // ready: T_1 and T_2
     ==> 
     ==> // Result belongs to ring Px.
     ==> // Equations of total space of miniversal deformation are 
     ==> // given by Fs, equations of miniversal base space by Js.
     ==> // Make Px the basering and list objects defined in Px by typing:
     ==>    setring Px; show(Px);
     ==>    listvar(matrix);
     ==> // NOTE: rings Qx, Px, So are alive!
     ==> // (use 'kill_rings("");' to remove)
       setring Px;
       show(Px);                   // show is a procedure from inout.lib
     ==> // ring: (32003),(A,B,C,D,E,F,x,y,z),(ds(6),ds(3),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> // Rs                   [0]  matrix 2 x 1
     ==> // Fs                   [0]  matrix 1 x 2
     ==> // Js                   [0]  matrix 1 x 0
       listvar(matrix);
     ==> // Rs                   [0]  matrix 2 x 1
     ==> // Fs                   [0]  matrix 1 x 2
     ==> // Js                   [0]  matrix 1 x 0
       // ___ Equations of miniversal base space ___:
       Js;
     ==> 
       // ___ Equations of miniversal total space ___:
       Fs;
     ==> Fs[1,1]=xy+Ez+F
     ==> Fs[1,2]=y2+z2+x3+Ay+Bx2+Cx+D
       // the miniversal deformation of V(j) is the projection from the
       // miniversal total space to the miniversal base space:
       // { (A,B,C,D,E,F,x,y,z) | xy+F+Ez=0, y2+z2+x3+D+Cx+Bx2+Ay=0 }
       //  --> { (A,B,C,D,E,F) }
       //----------------------------------------------------
       // general case (cone over rational normal curve of degree 4):
       ring r1=0,(x,y,z,u,v),ds;
       matrix m[2][4]=x,y,z,u,y,z,u,v;
       ideal i=minor(m,2);                 // 2x2 minors of matrix m
       int time=timer;
       // Def_r is the name of the miniversal base space with
       // parameters A(1),...,A(4)
       versal(i,0,"Def_r","A(");
     ==> // ready: T_1 and T_2
     ==> 
     ==> // Result belongs to ring Def_rPx.
     ==> // Equations of total space of miniversal deformation are 
     ==> // given by Fs, equations of miniversal base space by Js.
     ==> // Make Def_rPx the basering and list objects defined in Def_rPx by typin\
        g:
     ==>    setring Def_rPx; show(Def_rPx);
     ==>    listvar(matrix);
     ==> // NOTE: rings Def_rQx, Def_rPx, Def_rSo are alive!
     ==> // (use 'kill_rings("Def_r");' to remove)
       "// used time:",timer-time,"sec";   // time of last command
     ==> // used time: 1 sec
       // the miniversal deformation of V(i) is the projection from the
       // miniversal total space to the miniversal base space:
       // { (A(1..4),x,y,z,u,v) |
       //         -y^2+x*z+A(2)*x-A(3)*y=0, -y*z+x*u-A(1)*x-A(3)*z=0,
       //         -y*u+x*v-A(3)*u-A(4)*z=0, -z^2+y*u-A(1)*y-A(2)*z=0,
       //         -z*u+y*v-A(2)*u-A(4)*u=0, -u^2+z*v+A(1)*u-A(4)*v=0 }
       //  --> { A(1..4) |
       //         -A(1)*A(4) = A(3)*A(4) = -A(2)*A(4)-A(4)^2 = 0 }
       //----------------------------------------------------


File: singular.hlp,  Node: Finite fields,  Next: Elimination,  Prev: Deformations,  Up: Examples

A.9 Finite fields
=================

We define a variety in n $n$
-space of codimension 2 defined by polynomials of degree d $d$
 with generic coefficients over the prime field Z/p $Z/p$
 and look for zeros on the torus. First over the prime field and then in
the finite extension field with $p^k$
p^k elements.  In general there will be many more solutions in the
second case.  (Since the SINGULAR language is interpreted, the
evaluation of many `for'-loops is not very fast):

       int p=3;  int n=3;  int d=5; int k=2;
       ring rp = p,(x(1..n)),dp;
       int s = size(maxideal(d));
       s;
     ==> 21
       // create a dense homogeneous ideal m, all generators of degree d, with
       // generic (random) coefficients:
       ideal m = maxideal(d)*random(p,s,n-2);
       m;
     ==> m[1]=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^3*x\
        (3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5
       // look for zeros on the torus by checking all points (with no component 0)
       // of the affine n-space over the field with p elements :
       ideal mt;
       int i(1..n);                    // initialize integers i(1),...,i(n)
       int l;
       s=0;
       for (i(1)=1;i(1)<p;i(1)=i(1)+1)
       {
         for (i(2)=1;i(2)<p;i(2)=i(2)+1)
         {
           for (i(3)=1;i(3)<p;i(3)=i(3)+1)
           {
             mt=m;
             for (l=1;l<=n;l=l+1)
             {
               mt=subst(mt,x(l),i(l));
             }
             if (size(mt)==0)
             {
               "solution:",i(1..n);
               s=s+1;
             }
           }
         }
       }
     ==> solution: 1 1 2
     ==> solution: 1 2 1
     ==> solution: 1 2 2
     ==> solution: 2 1 1
     ==> solution: 2 1 2
     ==> solution: 2 2 1
       "//",s,"solutions over GF("+string(p)+")";
     ==> // 6 solutions over GF(3)
       // Now go to the field with p^3 elements:
       // As long as there is no map from Z/p to the field with p^3 elements
       // implemented, use the following trick: convert the ideal to be mapped
       // to the new ring to a string and then execute this string in the
       // new ring
       string ms="ideal m="+string(m)+";";
       ms;
     ==> ideal m=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^\
        3*x(3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5;
       // define a ring rpk with p^k elements, call the primitive element z. Hence
       // 'solution exponent: 0 1 5' means that (z^0,z^1,z^5) is a solution
       ring rpk=(p^k,z),(x(1..n)),dp;
       rpk;
     ==> //   # ground field : 9
     ==> //   primitive element : z
     ==> //   minpoly        : 1*z^2+1*z^1+2*z^0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering dp
     ==> //                  : names    x(1) x(2) x(3) 
     ==> //        block   2 : ordering C
       execute(ms);
       s=0;
       ideal mt;
       for (i(1)=0;i(1)<p^k-1;i(1)=i(1)+1)
       {
         for (i(2)=0;i(2)<p^k-1;i(2)=i(2)+1)
         {
           for (i(3)=0;i(3)<p^k-1;i(3)=i(3)+1)
           {
             mt=m;
             for (l=1;l<=n;l=l+1)
             {
               mt=subst(mt,x(l),z^i(l));
             }
             if (size(mt)==0)
             {
               "solution exponent:",i(1..n);
               s=s+1;
             }
           }
         }
       }
     ==> solution exponent: 0 0 2
     ==> solution exponent: 0 0 4
     ==> solution exponent: 0 0 6
     ==> solution exponent: 0 1 0
     ==> solution exponent: 0 3 0
     ==> solution exponent: 0 4 0
     ==> solution exponent: 0 4 4
     ==> solution exponent: 0 4 5
     ==> solution exponent: 0 4 7
     ==> solution exponent: 1 1 3
     ==> solution exponent: 1 1 5
     ==> solution exponent: 1 1 7
     ==> solution exponent: 1 2 1
     ==> solution exponent: 1 4 1
     ==> solution exponent: 1 5 0
     ==> solution exponent: 1 5 1
     ==> solution exponent: 1 5 5
     ==> solution exponent: 1 5 6
     ==> solution exponent: 2 2 0
     ==> solution exponent: 2 2 4
     ==> solution exponent: 2 2 6
     ==> solution exponent: 2 3 2
     ==> solution exponent: 2 5 2
     ==> solution exponent: 2 6 1
     ==> solution exponent: 2 6 2
     ==> solution exponent: 2 6 6
     ==> solution exponent: 2 6 7
     ==> solution exponent: 3 3 1
     ==> solution exponent: 3 3 5
     ==> solution exponent: 3 3 7
     ==> solution exponent: 3 4 3
     ==> solution exponent: 3 6 3
     ==> solution exponent: 3 7 0
     ==> solution exponent: 3 7 2
     ==> solution exponent: 3 7 3
     ==> solution exponent: 3 7 7
     ==> solution exponent: 4 0 0
     ==> solution exponent: 4 0 1
     ==> solution exponent: 4 0 3
     ==> solution exponent: 4 0 4
     ==> solution exponent: 4 4 0
     ==> solution exponent: 4 4 2
     ==> solution exponent: 4 4 6
     ==> solution exponent: 4 5 4
     ==> solution exponent: 4 7 4
     ==> solution exponent: 5 0 5
     ==> solution exponent: 5 1 1
     ==> solution exponent: 5 1 2
     ==> solution exponent: 5 1 4
     ==> solution exponent: 5 1 5
     ==> solution exponent: 5 5 1
     ==> solution exponent: 5 5 3
     ==> solution exponent: 5 5 7
     ==> solution exponent: 5 6 5
     ==> solution exponent: 6 1 6
     ==> solution exponent: 6 2 2
     ==> solution exponent: 6 2 3
     ==> solution exponent: 6 2 5
     ==> solution exponent: 6 2 6
     ==> solution exponent: 6 6 0
     ==> solution exponent: 6 6 2
     ==> solution exponent: 6 6 4
     ==> solution exponent: 6 7 6
     ==> solution exponent: 7 0 7
     ==> solution exponent: 7 2 7
     ==> solution exponent: 7 3 3
     ==> solution exponent: 7 3 4
     ==> solution exponent: 7 3 6
     ==> solution exponent: 7 3 7
     ==> solution exponent: 7 7 1
     ==> solution exponent: 7 7 3
     ==> solution exponent: 7 7 5
       "//",s,"solutions over GF("+string(p^k)+")";
     ==> // 72 solutions over GF(9)


File: singular.hlp,  Node: Elimination,  Next: Free resolution,  Prev: Finite fields,  Up: Examples

A.10 Elimination
================

Elimination is the algebraic counterpart of the geometric concept of
projection. If $f=(f_1,\ldots,f_n):k^r\rightarrow k^n$
f=(f1,...,fn) : k^r -> k^n is a polynomial map, the Zariski-closure of
the image is the zero-set of the ideal $$
\displaylines{
j=J \cap k[x_1,\ldots,x_n], \;\quad\hbox{\rm where}\cr
J=(x_1-f_1(t_1,\ldots,t_r),\ldots,x_n-f_n(t_1,\ldots,t_r))\subseteq
k[t_1,\ldots,t_r,x_1,\ldots,x_n]
}
$$

             j = J intersected with K[x1,...,xn]
     J=(x1-f1(t1,...,tr),...,xn-fn(t1,...,tr)) in k[t1,...tr,x1,...,xn]

i.e, of the ideal j obtained from J by eliminating the variables $t_1,\ldots,t_r$.
t1,...,tr.  This can be done by computing a standard basis of J with
respect to a product ordering where the block of t-variables precedes
the block of x-variables and then selecting those polynomials which do
not contain any t. In SINGULAR the most convenient way is to use the
`eliminate' command.  In contrast to the first method, with `eliminate'
the result needs not be a standard basis in the given ordering.  Hence,
there may be cases where the first method is the preferred one.

*WARNING:* In the case of a local or a mixed ordering, elimination needs
special care. f may be considered as a map of germs $f:(k^r,0)\rightarrow(k^n,0)$,
f : (k^r,0) -> (k^n,0), but even if this map germ is finite, we are in
general not able to compute the image germ because for this we would
need an implementation of the Weierstrass preparation theorem. What we
can compute, and what `eliminate' actually does, is the following: let
V(J) be the zero-set of J in $k^r\times(k^n,0)$,
k^r x (k^n,0), then the closure of the image of V(J) under the
projection $$\hbox{pr}:k^r\times(k^n,0)\rightarrow(k^n,0)$$
can be computed.

pr:  k^r x (k^n,0) -> (k^n,0)
can be computed.  Note that this germ contains also those components of
V(J) which meet the fiber of pr outside the origin.  This is achieved by
an ordering with the block of t-variables having a global ordering (and
preceding the x-variables) and the x-variables having a local ordering.
In a local situation we propose `eliminate' with ordering ls.

In any case, if the input is weighted homogeneous (=quasihomogeneous),
the weights given to the variables should be chosen accordingly.
SINGULAR offers a function `weight' which proposes, given an ideal or
module, integer weights for the variables, such that the ideal, resp.
module, is as homogeneous as possible with respect to these weights.
The function finds correct weights, if the input is weighted homogeneous
(but is rather slow for many variables). In order to check, whether the
input is quasihomogeneous, use the function `qhweight', which returns an
intvec of correct weights if the input is quasihomogeneous and an intvec
of zeros otherwise.

Let us give two examples:
  1. First we compute the equations of the simple space curve $\hbox{T}[7]^\prime$
     T[7]'    consisting of two tangential cusps given in parametric
     form.

  2. We compute weights for the equations such that the    equations are
     quasihomogeneous w.r.t. these weights.

  3. Then we compute the tangent developable of the rational    normal
     curve in $P^4$.
     P^4.

       // 1. Compute equations of curve given in parametric form:
       // Two transversal cusps in (k^3,0):
       ring r1 = 0,(t,x,y,z),ls;
       ideal i1 = x-t2,y-t3,z;        // parametrization of the first branch
       ideal i2 = y-t2,z-t3,x;        // parametrization of the second branch
       ideal j1 = eliminate(i1,t);
       j1;                            // equations of the first branch
     ==> j1[1]=z
     ==> j1[2]=y2-x3
       ideal j2 = eliminate(i2,t);
       j2;                            // equations of the second branch
     ==> j2[1]=x
     ==> j2[2]=z2-y3
       // Now map to a ring with only x,y,z as variables and compute the
       // intersection of j1 and j2 there:
       ring r2 = 0,(x,y,z),ds;
       ideal j1= imap(r1,j1);         // imap is a convenient ringmap for
       ideal j2= imap(r1,j2);         // inclusions and projections of rings
       ideal i = intersect(j1,j2);
       i;                             // equations of both branches
     ==> i[1]=z2-y3+x3y
     ==> i[2]=xz
     ==> i[3]=xy2-x4
     ==> i[4]=x3z
       //
       // 2. Compute the weights:
       intvec v= qhweight(i);         // compute weights
       v;
     ==> 4,6,9
       //
       // 3. Compute the tangent developable
       // The tangent developable of a projective variety given parametrically
       // by F=(f1,...,fn) : P^r --> P^n is the union of all tangent spaces
       // of the image. The tangent space at a smooth point F(t1,...,tr)
       // is given as the image of the tangent space at (t1,...,tr) under
       // the tangent map (affine coordinates)
       //   T(t1,...,tr): (y1,...,yr) --> jacob(f)*transpose((y1,...,yr))
       // where jacob(f) denotes the jacobian matrix of f with respect to the
       // t's evaluated at the point (t1,...,tr).
       // Hence we have to create the graph of this map and then to eliminate
       // the t's and y's.
       // The rational normal curve in P^4 is given as the image of
       //        F(s,t) = (s4,s3t,s2t2,st3,t4)
       // each component being homogeneous of degree 4.
       ring P = 0,(s,t,x,y,a,b,c,d,e),dp;
       ideal M = maxideal(1);
       ideal F = M[1..2];     // take the 1st two generators of M
       F=F^4;
       // simplify(...,2); deletes 0-columns
       matrix jac = simplify(jacob(F),2);
       ideal T = x,y;
       ideal J = jac*transpose(T);
       ideal H = M[5..9];
       ideal i = H-J;         // this is tricky: difference between two
                              // ideals is not defined, but between two
                              // matrices. By automatic type conversion
                              // the ideals are converted to matrices,
                              // subtracted and afterwards converted
                              // to an ideal. Note that '+' is defined
                              // and adds (concatenates) two ideals
       i;
     ==> i[1]=-4s3x+a
     ==> i[2]=-3s2tx-s3y+b
     ==> i[3]=-2st2x-2s2ty+c
     ==> i[4]=-t3x-3st2y+d
     ==> i[5]=-4t3y+e
       // Now we define a ring with product ordering and weights 4
       // for the variables a,...,e.
       // Then we map i from P to P1 and eliminate s,t,x,y from i.
       ring P1 = 0,(s,t,x,y,a,b,c,d,e),(dp(4),wp(4,4,4,4,4));
       ideal i = fetch(P,i);
       ideal j= eliminate(i,stxy);    // equations of tangent developable
       j;
     ==> j[1]=3c2-4bd+ae
     ==> j[2]=2bcd-3ad2-3b2e+4ace
     ==> j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde
       // We can use the product ordering to eliminate s,t,x,y from i
       // by a std-basis computation.
       // We need proc 'nselect' from elim.lib.
       LIB "elim.lib";
       j = std(i);                    // compute a std basis j
       j = nselect(j,1,4);            // select generators from j not
       j;                             // containing variable 1,...,4
     ==> j[1]=3c2-4bd+ae
     ==> j[2]=2bcd-3ad2-3b2e+4ace
     ==> j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde


File: singular.hlp,  Node: Free resolution,  Next: Computation of Ext,  Prev: Elimination,  Up: Examples

A.11 Free resolution
====================

In SINGULAR a free resolution of a module or ideal has its own type:
`resolution'. It is a structure that stores all information related to
free resolutions. This allows partial computations of resolutions via
the command `res'. After applying `res', only a pre-format of the
resolution is computed which allows to determine invariants like
Betti-numbers or homological dimension. To see the differentials of the
complex, a resolution must be converted into the type list which yields
a list of modules: the k-th module in this list is the first
syzygy-module (module of relations) of the (k-1)st module.  There are
the following commands to compute a resolution:
`res'
     *note res::
     computes a free resolution of an ideal or module using a
     heuristically chosen method.  This is the preferred method to
     compute free resolutions of ideals or modules.

`lres'
     *note lres::
     computes a free resolution of an ideal or module with La Scala's
     method. The input needs to be homogeneous.

`mres'
     *note mres::
     computes a minimal free resolution of an ideal or module with the
     syzygy method.

`sres'
     *note sres::
     computes a free resolution of an ideal or module with Schreyer's
     method. The input has to be a standard basis.

`nres'
     *note nres::
     computes a free resolution of an ideal or module with the standard
     basis method.

`minres'
     *note minres::
     minimizes a free resolution of an ideal or module.

`syz'
     *note syz::
     computes the first syzygy module.
`res(i,r)', `lres(i,r)', `sres(i,r)', `mres(i,r)', `nres(i,r)' compute
the first r modules of the resolution of i, resp. the full resolution if
r=0 and the basering is not a qring.  See the manual for a precise
description of these commands.
Note: The command `betti' does not require a minimal resolution for the
minimal betti numbers.

Now let's look at an example which uses resolutions: The Hilbert-Burch
theorem says that the ideal i of a reduced curve in $K^3$
K^3 has a free resolution of length 2 and that i is given by the 2x2
minors of the 2nd matrix in the resolution.  We test this for two
transversal cusps in $K^3$.
K^3.  Afterwards we compute the resolution of the ideal j of the tangent
developable of the rational normal curve in $P^4$
P^4 from above.  Finally we demonstrate the use of the type `resolution'
in connection with the `lres' command.

       // Two transversal cusps in (k^3,0):
       ring r2 =0,(x,y,z),ds;
       ideal i =z2-1y3+x3y,xz,-1xy2+x4,x3z;
       resolution rs=mres(i,0);   // computes a minimal resolution
       rs;                        // the standard representation of complexes
     ==>   1       3       2       
     ==> r2 <--  r2 <--  r2
     ==> 
     ==> 0       1       2       
     ==> 
         list resi=rs;            // convertion to a list
       print(resi[1]);            // the 1st module is i minimized
     ==> xz,
     ==> z2-y3+x3y,
     ==> xy2-x4
       print(resi[2]);            // the 1st syzygy module of i
     ==> -z,-y2+x3,
     ==> x, 0,     
     ==> y, z      
       resi[3];                   // the 2nd syzygy module of i
     ==> _[1]=0
       ideal j=minor(resi[2],2);
       reduce(j,std(i));          // check whether j is contained in i
     ==> _[1]=0
     ==> _[2]=0
     ==> _[3]=0
       size(reduce(i,std(j)));    // check whether i is contained in j
     ==> 0
       // size(<ideal>) counts the non-zero generators
       // ---------------------------------------------
       // The tangent developable of the rational normal curve in P^4:
       ring P = 0,(a,b,c,d,e),dp;
       ideal j= 3c2-4bd+ae, -2bcd+3ad2+3b2e-4ace,
                8b2d2-9acd2-9b2ce+9ac2e+2abde-1a2e2;
       resolution rs=mres(j,0);
       rs;
     ==>  1      2      1      
     ==> P <--  P <--  P
     ==> 
     ==> 0      1      2      
     ==> 
       list L=rs;
       print(L[2]);
     ==> 2bcd-3ad2-3b2e+4ace,
     ==> -3c2+4bd-ae         
       // create an intmat with graded betti numbers
       intmat B=betti(rs);
       // this gives a nice output of betti numbers
       print(B,"betti");
     ==>            0     1     2
     ==> ------------------------
     ==>     0:     1     -     -
     ==>     1:     -     1     -
     ==>     2:     -     1     -
     ==>     3:     -     -     1
     ==> ------------------------
     ==> total:     1     2     1
       // the user has access to all betti numbers
       // the 2-nd column of B:
       B[1..4,2];
     ==> 0 1 1 0
       ring cyc5=32003,(a,b,c,d,e,h),dp;
       ideal i=
       a+b+c+d+e,
       ab+bc+cd+de+ea,
       abc+bcd+cde+dea+eab,
       abcd+bcde+cdea+deab+eabc,
       h5-abcde;
       resolution rs=lres(i,0);   //computes the resolution according La Scala
       rs;                        //the shape of the minimal resolution
     ==>     1         5         10         10         5         1         
     ==> cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
     ==> 
     ==> 0         1         2          3          4         5         
     ==> resolution not minimized yet
     ==> 
       print(betti(rs),"betti");  //shows the Betti-numbers of cyclic 5
     ==>            0     1     2     3     4     5
     ==> ------------------------------------------
     ==>     0:     1     1     -     -     -     -
     ==>     1:     -     1     1     -     -     -
     ==>     2:     -     1     1     -     -     -
     ==>     3:     -     1     2     1     -     -
     ==>     4:     -     1     2     1     -     -
     ==>     5:     -     -     2     2     -     -
     ==>     6:     -     -     1     2     1     -
     ==>     7:     -     -     1     2     1     -
     ==>     8:     -     -     -     1     1     -
     ==>     9:     -     -     -     1     1     -
     ==>    10:     -     -     -     -     1     1
     ==> ------------------------------------------
     ==> total:     1     5    10    10     5     1
       dim(rs);                   //the homological dimension
     ==> 4
       size(list(rs));            //gets the full (non-reduced) resolution
     ==> 6
       minres(rs);                //minimizes the resolution
     ==>     1         5         10         10         5         1         
     ==> cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
     ==> 
     ==> 0         1         2          3          4         5         
     ==> 
       size(list(rs));            //gets the minimized resolution
     ==> 6


File: singular.hlp,  Node: Computation of Ext,  Next: Polar curves,  Prev: Free resolution,  Up: Examples

A.12 Computation of Ext
=======================

We start by showing how to calculate the n $n$
-th Ext group of an ideal. The ingredients to do this are by the
definition of Ext the following: calculate a (minimal) resolution at
least up to length

n $n$
, apply the Hom-functor, and calculate the n $n$
-th homology group, that is form the quotient $\hbox{\rm ker} / \hbox{\rm Im}$
ker/Im in the resolution sequence.

The Hom functor is given simply by transposing (hence dualizing) the
module or the corresponding matrix with the command `transpose'.  The
image of the (n-1) $(n-1)$
-st map is generated by the columns of the corresponding matrix. To
calculate the kernel apply the command `syz' at the (n-1) $(n-1)$
-st transposed entry of the resolution.  Finally, the quotient is
obtained by the command `modulo', which gives for two modules A = ker, B
= Im the module of relations of $A/(A \cap B)$
A/(A intersect B) in the usual way. As we have a chain complex this is
obviously the same as ker/Im.

We collect these statements in the following short procedure:

     proc ext(int n, ideal I)
     {
       resolution rs = mres(I,n+1);
       module tAn    = transpose(rs[n+1]);
       module tAn_1  = transpose(rs[n]);
       module ext_n  = modulo(syz(tAn),tAn_1);
       return(ext_n);
     }

Now consider the following example:

     ring r5 = 32003,(a,b,c,d,e),dp;
     ideal I = a2b2+ab2c+b2cd, a2c2+ac2d+c2de,a2d2+ad2e+bd2e,a2e2+abe2+bce2;
     print(ext(2,I));
     ==> 1,0,0,0,0,0,0,
     ==> 0,1,0,0,0,0,0,
     ==> 0,0,1,0,0,0,0,
     ==> 0,0,0,1,0,0,0,
     ==> 0,0,0,0,1,0,0,
     ==> 0,0,0,0,0,1,0,
     ==> 0,0,0,0,0,0,1
     ext(3,I);   // too big to be displayed here

The library `homolog.lib' contains several procedures for computing
Ext-modules and related modules, which are much more general and
sophisticated then the above one. They are used in the following
example.

If M $M$
 is a module, then $\hbox{Ext}^1(M,M)$, resp.\ $\hbox{Ext}^2(M,M)$,
Ext^1(M,M), resp. Ext^2(M,M), are the modules of infinitesimal
deformations, resp. of obstructions, of

M $M$
 (like T1 and T2 for a singularity).  Similar to the treatment for
singularities, the semiuniversal deformation of M $M$
 can be computed (if $\hbox{Ext}^1$
Ext^1 is finite dimensional) with the help of $\hbox{Ext}^1$, $\hbox{Ext}^2$
Ext^1, Ext^2 and the cup product. There is an extra procedure for $\hbox{Ext}^k(R/J,R)$
Ext^k(R/J,R) if J $J$
 is an ideal in R $R$
 since this is faster than the general Ext.

We compute
   * the infinitesimal deformations ($=\hbox{Ext}^1(K,K)$)
     (=Ext^1(K,K)) and obstructions ($=\hbox{Ext}^2(K,K)$)
     (=Ext^2(K,K)) of the residue field K=R/m $K=R/m$
      of an ordinary cusp, $R=Loc_m K[x,y]/(x^2-y^3)$, $m=(x,y)$.
     R=Loc_m K[x,y]/(x^2-y^3), m=(x,y).  To compute $\hbox{Ext}^1(m,m)$
     Ext^1(m,m), we have to apply `Ext(1,syz(m),syz(m))' with `syz(m)'
     the first syzygy module of m $m$
     , which is isomorphic to $\hbox{Ext}^2(K,K)$.
     Ext^2(K,K).

   * $\hbox{Ext}^k(R/i,R)$
     Ext^k(R/i,R) for some ideal i $i$
      and with an extra option.

       LIB "homolog.lib";
       ring R=0,(x,y),ds;
       ideal i=x2-y3;
       qring q = std(i);      // defines the quotient ring Loc_m k[x,y]/(x2-y3)
       ideal m = maxideal(1);
       module T1K = Ext(1,m,m);  // computes Ext^1(R/m,R/m)
     ==> // dimension of Ext^1:  0
     ==> // vdim of Ext^1:       2
     ==> 
       print(T1K);
     ==> 0,  0,y,x,0,y,0,    x2-y3,
     ==> -y2,x,x,0,y,0,x2-y3,0,    
     ==> 1,  0,0,0,0,0,0,    0     
       printlevel=2;             // gives more explanation
       module T2K=Ext(2,m,m);    // computes Ext^2(R/m,R/m)
     ==> // Computing Ext^2 (help Ext; gives an explanation):
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
     ==> // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
     ==> // then Hom(F2,G0)-->Hom(F3,G0) is given by:
     ==> y2,x,
     ==> x, y 
     ==> // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
     ==> -y,x,  x,0,y,0,
     ==> x, -y2,0,x,0,y 
     ==> 
     ==> // dimension of Ext^2:  0
     ==> // vdim of Ext^2:       2
     ==> 
       print(std(T2K));
     ==> -y2,0,x,0,y,
     ==> 0,  x,0,y,0,
     ==> 1,  0,0,0,0 
       printlevel=0;
       module E = Ext(1,syz(m),syz(m));
     ==> // dimension of Ext^1:  0
     ==> // vdim of Ext^1:       2
     ==> 
       print(std(E));
     ==> -y,x, 0, 0,0,x,0,y,
     ==> 0, -y,-y,0,x,0,y,0,
     ==> 0, 0, 0, 1,0,0,0,0,
     ==> 0, 0, 1, 0,0,0,0,0,
     ==> 0, 1, 0, 0,0,0,0,0,
     ==> 1, 0, 0, 0,0,0,0,0 
       //The matrices which we have just computed are presentation matrices
       //of the modules T2K and E. Hence we may ignore those columns
       //containing 1 as an entry and see that T2K and E are isomorphic
       //as expected, but differently presented.
       //-------------------------------------------
       ring S=0,(x,y,z),dp;
       ideal  i = x2y,y2z,z3x;
       module E = Ext_R(2,i);
     ==> // dimension of Ext^2:  1
     ==> 
       print(E);
     ==> 0,y,0,z2,
     ==> z,0,0,-x,
     ==> 0,0,x,-y 
       // if a 3-rd argument is given (of any type)
       // a list of Ext^k(R/i,R), a SB of Ext^k(R/i,R) and a vector space basis
       // is returned:
       list LE = Ext_R(3,i,"");
     ==> // dimension of Ext^3:  0
     ==> // vdim of Ext^3:       2
     ==> 
       LE;
     ==> [1]:
     ==>    _[1]=y*gen(1)
     ==>    _[2]=x*gen(1)
     ==>    _[3]=z2*gen(1)
     ==> [2]:
     ==>    _[1]=y*gen(1)
     ==>    _[2]=x*gen(1)
     ==>    _[3]=z2*gen(1)
     ==> [3]:
     ==>    _[1,1]=z
     ==>    _[1,2]=1
       print(LE[2]);
     ==> y,x,z2
       print(kbase(LE[2]));
     ==> z,1


File: singular.hlp,  Node: Polar curves,  Next: Depth,  Prev: Computation of Ext,  Up: Examples

A.13 Polar curves
=================

The polar curve of a hypersurface given by a polynomial $f\in k[x_1,\ldots,x_n,t]$
f in k[x1,...,xn,t] with respect to t $t$
 (we may consider f=0 $f=0$
 as a family of hypersurfaces parametrized by t $t$
) is defined as the Zariski closure of $V(\partial f/\partial x_1,\ldots,\partial f/\partial x_n) \setminus V(f)$
V(diff(f,x1),...,diff(f,xn)) \ V(f) if this happens to be a curve.  Some
authors consider $V(\partial f/\partial x_1,\ldots,\partial f/\partial x_n)$
V(diff(f,x1),...,diff(f,xn)) itself as polar curve.

We may consider projective hypersurfaces (in $P^n$),
(in P^n), affine hypersurfaces (in $k^n$)
(in k^n) or germs of hypersurfaces (in $(k^n,0)$),
(in (k^n,0)), getting in this way projective, affine or local polar
curves.

Now let us compute this for a family of curves.  We need the library
`elim.lib' for saturation and `sing.lib' for the singular locus.

       LIB "elim.lib";
       LIB "sing.lib";
       // Affine polar curve:
       ring R = 0,(x,z,t),dp;              // global ordering dp
       poly f = z5+xz3+x2-tz6;
       dim_slocus(f);                      // dimension of singular locus
     ==> 1
       ideal j = diff(f,x),diff(f,z);
       dim(std(j));                        // dim V(j)
     ==> 1
       dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
     ==> 1
       // j defines a curve, but to get the polar curve we must remove the
       // branches contained in f=0 (they exist since dim V(j,f) = 1). This
       // gives the polar curve set theoretically. But for the structure we
       // may take either j:f or j:f^k for k sufficiently large. The first is
       // just the ideal quotient, the second the iterated ideal quotient
       // or saturation. In our case both coincide.
       ideal q = quotient(j,ideal(f));     // ideal quotient
       ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
       ideal sq = std(q);
       dim(sq);
     ==> 1
       // 1-dimensional, hence q defines the affine polar curve
       //
       // to check that q and qsat are the same, we show both inclusions, i.e.,
       // both reductions must give the 0-ideal
       size(reduce(qsat,sq));
     ==> 0
       size(reduce(q,std(qsat)));
     ==> 0
       qsat;
     ==> qsat[1]=12zt+3z-10
     ==> qsat[2]=5z2+12xt+3x
     ==> qsat[3]=144xt2+72xt+9x+50z
       // We see that the affine polar curve does not pass through the origin,
       // hence we expect the local polar "curve" to be empty
       // ------------------------------------------------
       // Local polar curve:
       ring r = 0,(x,z,t),ds;              // local ordering ds
       poly f = z5+xz3+x2-tz6;
       ideal j = diff(f,x),diff(f,z);
       dim(std(j));                        // V(j) 1-dimensional
     ==> 1
       dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
     ==> 1
       ideal q = quotient(j,ideal(f));     // ideal quotient
       q;
     ==> q[1]=1
       // The local polar "curve" is empty, i.e., V(j) is contained in V(f)
       // ------------------------------------------------
       // Projective polar curve: (we need "sing.lib" and "elim.lib")
       ring P = 0,(x,z,t,y),dp;            // global ordering dp
       poly f = z5y+xz3y2+x2y4-tz6;
                                           // but consider t as parameter
       dim_slocus(f);              // projective 1-dimensional singular locus
     ==> 2
       ideal j = diff(f,x),diff(f,z);
       dim(std(j));                        // V(j), projective 1-dimensional
     ==> 2
       dim(std(j+ideal(f)));               // V(j,f) also projective 1-dimensional
     ==> 2
       ideal q = quotient(j,ideal(f));
       ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
       dim(std(qsat));
     ==> 2
       // projective 1-dimensional, hence q and/or qsat define the projective
       // polar curve. In this case, q and qsat are not the same, we needed
       // 2 quotients.
       // Let us check both reductions:
       size(reduce(qsat,std(q)));
     ==> 4
       size(reduce(q,std(qsat)));
     ==> 0
       // Hence q is contained in qsat but not conversely
       q;
     ==> q[1]=12zty+3zy-10y2
     ==> q[2]=60z2t-36xty-9xy-50zy
       qsat;
     ==> qsat[1]=12zt+3z-10y
     ==> qsat[2]=12xty+5z2+3xy
     ==> qsat[3]=144xt2+72xt+9x+50z
     ==> qsat[4]=z3+2xy2
       //
       // Now consider again the affine polar curve,
       // homogenize it with respect to y (deg t=0) and compare:
       // affine polar curve:
       ideal qa = 12zt+3z-10,5z2+12xt+3x,-144xt2-72xt-9x-50z;
       // homogenized:
       ideal qh = 12zt+3z-10y,5z2+12xyt+3xy,-144xt2-72xt-9x-50z;
       size(reduce(qh,std(qsat)));
     ==> 0
       size(reduce(qsat,std(qh)));
     ==> 0
       // both ideals coincide


File: singular.hlp,  Node: Depth,  Next: Formatting output,  Prev: Polar curves,  Up: Examples

A.14 Depth
==========

We compute the depth of the module of Kaehler differentials D$_k$(R)
D_k(R) of the variety defined by the (m+1) $(m+1)$
-minors of a generic symmetric $(n \times n)$-matrix.
(n x n)-matrix.  We do this by computing the resolution over the
polynomial ring.  Then, by the Auslander-Buchsbaum formula, the depth is
equal to the number of variables minus the length of a minimal
resolution.  This example was suggested by U. Vetter in order to check
whether his bound $\hbox{depth}(\hbox{D}_k(R))\geq m(m+1)/2 + m-1$
depth(D_k(R)) >= m(m+1)/2 + m-1 could be improved.

       LIB "matrix.lib"; LIB "sing.lib";
       int n = 4;
       int m = 3;
       int N = n*(n+1)/2;           // will become number of variables
       ring R = 32003,x(1..N),dp;
       matrix X = symmat(n);        // proc from matrix.lib
                                    // creates the symmetric generic nxn matrix
       print(X);
     ==> x(1),x(2),x(3),x(4),
     ==> x(2),x(5),x(6),x(7),
     ==> x(3),x(6),x(8),x(9),
     ==> x(4),x(7),x(9),x(10)
       ideal J = minor(X,m);
       J=std(J);
       // Kaehler differentials D_k(R)
       // of R=k[x1..xn]/J:
       module D = J*freemodule(N)+transpose(jacob(J));
       ncols(D);
     ==> 110
       nrows(D);
     ==> 10
       //
       // Note: D is a submodule with 110 generators of a free module
       // of rank 10 over a polynomial ring in 10 variables.
       // Compute a full resolution of D with sres.
       // This takes about 17 sec on a Mac PB 520c and 2 sec an a HP 735
       int time = timer;
       module sD = std(D);
       list Dres = sres(sD,0);                // the full resolution
       timer-time;                            // time used for std + sres
     ==> 0
       intmat B = betti(Dres);
       print(B,"betti");
     ==>            0     1     2     3     4     5     6
     ==> ------------------------------------------------
     ==>     0:    10     -     -     -     -     -     -
     ==>     1:     -    10     -     -     -     -     -
     ==>     2:     -    84   144    60     -     -     -
     ==>     3:     -     -    35    80    60    16     1
     ==> ------------------------------------------------
     ==> total:    10    94   179   140    60    16     1
       N-ncols(B)+1;                          // the desired depth
     ==> 4


File: singular.hlp,  Node: Formatting output,  Next: Cyclic roots,  Prev: Depth,  Up: Examples

A.15 Formatting output
======================

We show how to insert the result of a computation inside a text by using
strings.  First we compute the powers of 2 and comment the result with
some text.  Then we do the same and give the output a nice format by
computing and adding appropriate space.

       // The powers of 2:
       int  n;
       for (n = 2; n <= 128; n = n * 2)
       {"n = " + string (n);}
     ==> n = 2
     ==> n = 4
     ==> n = 8
     ==> n = 16
     ==> n = 32
     ==> n = 64
     ==> n = 128
       // The powers of 2 in a nice format
       int j;
       string space = "";
       for (n = 2; n <= 128; n = n * 2)
       {
         space = "";
         for (j = 1; j <= 5 - size (string (n)); j = j+1)
         { space = space + " "; }
         "n =" + space + string (n);
       }
     ==> n =    2
     ==> n =    4
     ==> n =    8
     ==> n =   16
     ==> n =   32
     ==> n =   64
     ==> n =  128


File: singular.hlp,  Node: Cyclic roots,  Next: G_a -Invariants,  Prev: Formatting output,  Up: Examples

A.16 Cyclic roots
=================

We write a procedure returning a string that enables us to create
automatically the ideal of cyclic roots over the basering with n
variables. The procedure assumes that the variables consist of a single
letter each (hence no indexed variables are allowed; the procedure
`cyclic' in `poly.lib' does not have this restriction). Then we compute
a standard basis of this ideal and some numerical information.  (This
ideal is used as a classical benchmark for standard basis computations).

     // We call the procedure 'cyclic':
     proc cyclic (int n)
     {
        string vs = varstr(basering)+varstr(basering);
        int c=find(vs,",");
        while ( c!=0 )
        {
           vs=vs[1,c-1]+vs[c+1,size(vs)];
           c=find(vs,",");
        }
        string t,s;
        int i,j;
        for ( j=1; j<=n-1; j=j+1 )
        {
           t="";
           for ( i=1; i <=n; i=i+1 )
           {
              t = t + vs[i,j] + "+";
           }
           t = t[1,size(t)-1] + ","+newline;
           s=s+t;
        }
        s=s+vs[1,n]+"-1";
        return (s);
     }

     ring r=0,(a,b,c,d,e),lp;         // basering, char 0, lex ordering
     string sc=cyclic(nvars(basering));
     sc;                              // the string of the ideal
     ==> a+b+c+d+e,
     ==> ab+bc+cd+de+ea,
     ==> abc+bcd+cde+dea+eab,
     ==> abcd+bcde+cdea+deab+eabc,
     ==> abcde-1
     execute("ideal i="+sc+";");      // this defines the ideal of cyclic roots
     i;
     ==> i[1]=a+b+c+d+e
     ==> i[2]=ab+bc+cd+ae+de
     ==> i[3]=abc+bcd+abe+ade+cde
     ==> i[4]=abcd+abce+abde+acde+bcde
     ==> i[5]=abcde-1
     timer=1;
     ideal j=std(i);
     ==> //used time: 7.5 sec
     size(j);                         // number of elements in the std basis
     ==> 11
     degree(j);
     ==> // codimension = 5
     ==> // dimension   = 0
     ==> // degree      = 70


File: singular.hlp,  Node: G_a -Invariants,  Next: Invariants of a finite group,  Prev: Cyclic roots,  Up: Examples

A.17 G_a -Invariants
====================

We work in characteristic 0 and use the Lie algebra generated by one
vector field of the form $\sum x_i \partial /\partial x_{i+1}$.
sum x(i)*d/dx(i+1).
       LIB "ainvar.lib";
       int n=5;
       int i;
       ring s=32003,(x(1..n)),wp(1,2,3,4,5);
       // definition of the vector field m=sum m[i,1]*d/dx(i)
       matrix m[n][1];
       for (i=1;i<=n-1;i=i+1)
       {
          m[i+1,1]=x(i);
       }
       // computation of the ring of invariants
       ideal in=invariantRing(m,x(2),x(1),0);
       in;   //invariant ring is generated by 5 invariants
     ==> in[1]=x(1)
     ==> in[2]=x(2)^2-2*x(1)*x(3)
     ==> in[3]=x(3)^2-2*x(2)*x(4)+2*x(1)*x(5)
     ==> in[4]=x(2)^3-3*x(1)*x(2)*x(3)+3*x(1)^2*x(4)
     ==> in[5]=x(3)^3-3*x(2)*x(3)*x(4)-15997*x(1)*x(4)^2+3*x(2)^2*x(5)-6*x(1)*x(3)\
        *x(5)
       ring q=32003,(x,y,z,u,v,w),dp;
       matrix m[6][1];
       m[2,1]=x;
       m[3,1]=y;
       m[5,1]=u;
       m[6,1]=v;
       // the vector field is: xd/dy+yd/dz+ud/dv+vd/dw
       ideal in=invariantRing(m,y,x,0);
       in; //invariant ring is generated by 6 invariants
     ==> in[1]=x
     ==> in[2]=u
     ==> in[3]=v2-2uw
     ==> in[4]=zu-yv+xw
     ==> in[5]=yu-xv
     ==> in[6]=y2-2xz

