This is index.htm, produced by makeinfo version 4.13 from singular.texi.



File: index.htm,  Node: Factorization,  Next: Puiseux pairs,  Prev: Invariants of a finite group,  Up: Examples

A.19 Factorization
==================

The factorization of polynomials is implemented in the C++ libraries
Factory (written mainly by Ruediger Stobbe) and libfac (written by
Michael Messollen) which are part of the SINGULAR system.

       ring r = 0,(x,y),dp;
       poly f = 9x16-18x13y2-9x12y3+9x10y4-18x11y2+36x8y4
              +18x7y5-18x5y6+9x6y4-18x3y6-9x2y7+9y8;
       // = 9 * (x5-1y2)^2 * (x6-2x3y2-1x2y3+y4)
       factorize(f);
     ==> [1]:
     ==>    _[1]=9
     ==>    _[2]=x6-2x3y2-x2y3+y4
     ==>    _[3]=-x5+y2
     ==> [2]:
     ==>    1,1,2
       // returns factors and multiplicities,
       // first factor is a constant.
       poly g = (y4+x8)*(x2+y2);
       factorize(g);
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=x8+y4
     ==>    _[3]=x2+y2
     ==> [2]:
     ==>    1,1,1
       // The same in characteristic 2:
       ring s =2,(x,y),dp;
       poly g = (y4+x8)*(x2+y2);
       factorize(g);
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=x+y
     ==>    _[3]=x2+y
     ==> [2]:
     ==>    1,2,4


File: index.htm,  Node: Puiseux pairs,  Next: Primary decomposition,  Prev: Factorization,  Up: Examples

A.20 Puiseux pairs
==================

The Puiseux pairs of an irreducible and reduced curve singularity are
its most important invariants.  They can be computed from its
Hamburger-Noether expansion.  The library `hnoether.lib' written by
Martin Lamm uses the algorithm of Antonio Campillo "Algebroid curves in
positive characteristic" SLN 813, 1980.  This algorithm has the
advantage that it needs least possible field extensions and, moreover,
works in any characteristic. This fact can be used to compute the
invariants over a field of finite characteristic, say 32003, which will
then most probably be the same in characteristic 0.

We compute the Hamburger-Noether expansion of a plane curve singularity
given by a polynomial f $f$
 in two variables. This is a matrix which allows to compute the
parametrization (up to a given order) and all numerical invariants like
the
   * characteristic exponents,

   * Puiseux pairs (of a complex model),

   * degree of the conductor,

   * delta invariant,

   * generators of the semigroup.
Besides this, the library contains procedures to compute the Newton
polygon of f $f$
, the squarefree part of f $f$
 and a procedure to convert one set of invariants to another.

       LIB "hnoether.lib";
       // ======== The irreducible case ========
       ring s = 0,(x,y),ds;
       poly f = y4-2x3y2-4x5y+x6-x7;
       list hn = develop(f);
       show(hn[1]);     // Hamburger-Noether matrix
     ==> // matrix, 3x3
     ==> 0,x,  0,  
     ==> 0,1,  x,  
     ==> 0,1/4,-1/2
       displayHNE(hn);  // Hamburger-Noether development
     ==> HNE[1]=-y+z(0)*z(1)
     ==> HNE[2]=-x+z(1)^2+z(1)^2*z(2)
     ==> HNE[3]=1/4*z(2)^2-1/2*z(2)^3
       setring s;
       displayInvariants(hn);
     ==>  characteristic exponents  : 4,6,7
     ==>  generators of semigroup   : 4,6,13
     ==>  Puiseux pairs             : (3,2)(7,2)
     ==>  degree of the conductor   : 16
     ==>  delta invariant           : 8
     ==>  sequence of multiplicities: 4,2,2,1,1
       // invariants(hn);  returns the invariants as list
       // partial parametrization of f: param takes the first variable
       // as infinite except the ring has more than 2 variables. Then
       // the 3rd variable is chosen.
       param(hn);
     ==> // ** Warning: result is exact up to order 5 in x and 7 in y !
     ==> _[1]=1/16x4-3/16x5+1/4x7
     ==> _[2]=1/64x6-5/64x7+3/32x8+1/16x9-1/8x10
       ring extring=0,(x,y,t),ds;
       poly f=x3+2xy2+y2;
       list hn=develop(f,-1);
       param(hn);       // partial parametrization of f
     ==> // ** Warning: result is exact up to order 2 in x and 3 in y !
     ==> _[1]=-t2
     ==> _[2]=-t3
       list hn1=develop(f,6);
       param(hn1);     // a better parametrization
     ==> // ** Warning: result is exact up to order 6 in x and 7 in y !
     ==> _[1]=-t2+2t4-4t6
     ==> _[2]=-t3+2t5-4t7
       // instead of recomputing you may extend the development:
       list hn2=extdevelop(hn,12);
       param(hn2);     // a still better parametrization
     ==> // ** Warning: result is exact up to order 12 in x and 13 in y !
     ==> _[1]=-t2+2t4-4t6+8t8-16t10+32t12
     ==> _[2]=-t3+2t5-4t7+8t9-16t11+32t13
       //
       // ======== The reducible case ========
       ring r = 0,(x,y),dp;
       poly f=x11-2y2x8-y3x7-y2x6+y4x5+2y4x3+y5x2-y6;
       // = (x5-1y2) * (x6-2x3y2-1x2y3+y4)
       list hn=reddevelop(f);
       show(hn[1][1]);     // Hamburger-Noether matrix of 1st branch
     ==> // matrix, 3x3
     ==> 0,x,0,
     ==> 0,1,x,
     ==> 0,1,-1
       displayInvariants(hn);
     ==>  --- invariants of branch number 1 : ---
     ==>  characteristic exponents  : 4,6,7
     ==>  generators of semigroup   : 4,6,13
     ==>  Puiseux pairs             : (3,2)(7,2)
     ==>  degree of the conductor   : 16
     ==>  delta invariant           : 8
     ==>  sequence of multiplicities: 4,2,2,1,1
     ==> 
     ==>  --- invariants of branch number 2 : ---
     ==>  characteristic exponents  : 2,5
     ==>  generators of semigroup   : 2,5
     ==>  Puiseux pairs             : (5,2)
     ==>  degree of the conductor   : 4
     ==>  delta invariant           : 2
     ==>  sequence of multiplicities: 2,2,1,1
     ==> 
     ==>  -------------- contact numbers : -------------- 
     ==> 
     ==> branch |    2    
     ==> -------+-----
     ==>     1  |    2
     ==> 
     ==>  -------------- intersection multiplicities : -------------- 
     ==> 
     ==> branch |    2    
     ==> -------+-----
     ==>     1  |   12
     ==> 
     ==>  -------------- delta invariant of the curve :  22
       param(hn[2]);      // parametrization of 2nd branch
     ==> _[1]=x2
     ==> _[2]=x5


File: index.htm,  Node: Primary decomposition,  Next: Normalization,  Prev: Puiseux pairs,  Up: Examples

A.21 Primary decomposition
==========================

There are two algorithms implemented in SINGULAR which provide primary
decomposition: `primdecGTZ', based on Gianni/Trager/Zacharias (written
by Gerhard Pfister) and `primdecSY', based on Shimoyama/Yokoyama
(written by Wolfram Decker and Hans Schoenemann).

The result of `primdecGTZ' and `primdecSY' is returned as a list of
pairs of ideals, where the second ideal form the prime ideal and the
first ideal form the corresponding primary ideal.

       LIB "primdec.lib";
       ring r = 0,(a,b,c,d,e,f),dp;
       ideal i= f3, ef2, e2f, bcf-adf, de+cf, be+af, e3;
       primdecGTZ(i);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=f
     ==>       _[2]=e
     ==>    [2]:
     ==>       _[1]=f
     ==>       _[2]=e
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=f3
     ==>       _[2]=ef2
     ==>       _[3]=e2f
     ==>       _[4]=e3
     ==>       _[5]=de+cf
     ==>       _[6]=be+af
     ==>       _[7]=-bc+ad
     ==>    [2]:
     ==>       _[1]=f
     ==>       _[2]=e
     ==>       _[3]=-bc+ad
       // We consider now the ideal J of the base space of the
       // miniversal deformation of the cone over the rational
       // normal curve computed in section *8* and compute
       // its primary decomposition.
       ring R = 0,(A,B,C,D),dp;
       ideal J = CD, BD+D2, AD;
       primdecGTZ(J);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=D
     ==>    [2]:
     ==>       _[1]=D
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=C
     ==>       _[2]=B+D
     ==>       _[3]=A
     ==>    [2]:
     ==>       _[1]=C
     ==>       _[2]=B+D
     ==>       _[3]=A
       // We see that there are two components which are both
       // prime, even linear subspaces, one 3-dimensional,
       // the other 1-dimensional.
       // (This is Pinkhams example and was the first known
       // surface singularity with two components of
       // different dimensions)
       //
       // Let us now produce an embedded component in the last
       // example, compute the minimal associated primes and
       // the radical. We use the Characteristic set methods
       // from prim_dec.lib.
       J = intersect(J,maxideal(3));
       // The following shows that the maximal ideal defines an embedded
       // (prime) component.
       primdecSY(J);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=D
     ==>    [2]:
     ==>       _[1]=D
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=C
     ==>       _[2]=B+D
     ==>       _[3]=A
     ==>    [2]:
     ==>       _[1]=C
     ==>       _[2]=B+D
     ==>       _[3]=A
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=D2
     ==>       _[2]=C2
     ==>       _[3]=B2
     ==>       _[4]=AB
     ==>       _[5]=A2
     ==>       _[6]=BCD
     ==>       _[7]=ACD
     ==>    [2]:
     ==>       _[1]=D
     ==>       _[2]=C
     ==>       _[3]=B
     ==>       _[4]=A
       minAssChar(J);
     ==> [1]:
     ==>    _[1]=C
     ==>    _[2]=B+D
     ==>    _[3]=A
     ==> [2]:
     ==>    _[1]=D
       radical(J);
     ==> _[1]=CD
     ==> _[2]=BD+D2
     ==> _[3]=AD


File: index.htm,  Node: Normalization,  Next: Branches of an Isolated Space Curve Singularity,  Prev: Primary decomposition,  Up: Examples

A.22 Normalization
==================

The normalization will be computed for a reduced ring R/I $R/I$
. The result is a list of rings; ideals are always called `norid' in the
rings of this list. The normalization of R/I $R/I$
 is the product of the factor rings of the rings in the list divided out
by the ideals `norid'.

       LIB "normal.lib";
       // ----- first example: rational quadruple point -----
       ring R=32003,(x,y,z),wp(3,5,15);
       ideal I=z*(y3-x5)+x10;
       list pr=normal(I);
     ==> 
     ==> // 'normal' created a list of 1 ring(s).
     ==> // nor[1+1] is the delta-invariant in case of choose=wd.
     ==> // To see the rings, type (if the name of your list is nor):
     ==>      show( nor);
     ==> // To access the 1-st ring and map (similar for the others), type:
     ==>      def R = nor[1]; setring R;  norid; normap;
     ==> // R/norid is the 1-st ring of the normalization and
     ==> // normap the map from the original basering to R/norid
       def S=pr[1];
       setring S;
       norid;
     ==> norid[1]=T(2)*T(3)-T(1)*T(4)
     ==> norid[2]=T(1)^7-T(1)^2*T(3)+T(2)*T(5)
     ==> norid[3]=T(1)^2*T(5)-T(2)*T(4)
     ==> norid[4]=T(1)^5*T(4)-T(3)*T(4)+T(5)^2
     ==> norid[5]=T(1)^6*T(3)-T(1)*T(3)^2+T(4)*T(5)
     ==> norid[6]=T(1)*T(3)*T(5)-T(4)^2
       // ----- second example: union of straight lines -----
       ring R1=0,(x,y,z),dp;
       ideal I=(x-y)*(x-z)*(y-z);
       list qr=normal(I);
     ==> 
     ==> // 'normal' created a list of 3 ring(s).
     ==> // nor[3+1] is the delta-invariant in case of choose=wd.
     ==> // To see the rings, type (if the name of your list is nor):
     ==>      show( nor);
     ==> // To access the 1-st ring and map (similar for the others), type:
     ==>      def R = nor[1]; setring R;  norid; normap;
     ==> // R/norid is the 1-st ring of the normalization and
     ==> // normap the map from the original basering to R/norid
       def S1=qr[1]; def S2=qr[2];
       setring S1; norid;
     ==> norid[1]=0
       setring S2; norid;
     ==> norid[1]=0


File: index.htm,  Node: Branches of an Isolated Space Curve Singularity,  Next: Kernel of module homomorphisms,  Prev: Normalization,  Up: Examples

A.23 Branches of an Isolated Space Curve Singularity
====================================================

In this example, the number of branches of a given quasihomogeneous
isolated space curve singularity will be computed as an example of the
pitfalls appearing in the use of primary decomposition. When dealing
with singularities, two situations are possible in which the primary
decomposition algorithm might not lead to a complete decomposition:
first of all, one of the computed components could be globally
irreducible, but analytically reducible (this is impossible for
quasihomogeneous singularities) and, as a second possibility, a
component might be irreducible over the rational numbers, but reducible
over the complex numbers.
       ring r=0,(x,y,z),ds;
       ideal i=x^4-y*z^2,x*y-z^3,y^2-x^3*z;  // the space curve singularity
       qhweight(i);
     ==> 1,2,1
       // The given space curve singularity is quasihomogeneous. Hence we can pass
       // to the polynomial ring.
       ring rr=0,(x,y,z),dp;
       ideal i=imap(r,i);
       resolution ires=mres(i,0);
       ires;
     ==>   1       3       2       
     ==> rr <--  rr <--  rr
     ==> 
     ==> 0       1       2       
     ==> 
       // From the structure of the resolution, we see that the Cohen-Macaulay
       // type of the given singularity is 2
       //
       // Let us now look for the branches using the primdec library.
       LIB "primdec.lib";
       primdecSY(i);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=z3-xy
     ==>       _[2]=x3+x2z+xz2+xy+yz
     ==>       _[3]=x2z2+x2y+xyz+yz2+y2
     ==>    [2]:
     ==>       _[1]=z3-xy
     ==>       _[2]=x3+x2z+xz2+xy+yz
     ==>       _[3]=x2z2+x2y+xyz+yz2+y2
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=x-z
     ==>       _[2]=z2-y
     ==>    [2]:
     ==>       _[1]=x-z
     ==>       _[2]=z2-y
       def li=_[2];
       ideal i2=li[2];       // call the second ideal i2
       // The curve seems to have 2 branches by what we computed using the
       // algorithm of Shimoyama-Yokoyama.
       // Now the same computation by the Gianni-Trager-Zacharias algorithm:
       primdecGTZ(i);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=z8+yz6+y2z4+y3z2+y4
     ==>       _[2]=xz5+z6+yz4+y2z2+y3
     ==>       _[3]=-z3+xy
     ==>       _[4]=x2z2+xz3+xyz+yz2+y2
     ==>       _[5]=x3+x2z+xz2+xy+yz
     ==>    [2]:
     ==>       _[1]=z8+yz6+y2z4+y3z2+y4
     ==>       _[2]=xz5+z6+yz4+y2z2+y3
     ==>       _[3]=-z3+xy
     ==>       _[4]=x2z2+xz3+xyz+yz2+y2
     ==>       _[5]=x3+x2z+xz2+xy+yz
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=-z2+y
     ==>       _[2]=x-z
     ==>    [2]:
     ==>       _[1]=-z2+y
     ==>       _[2]=x-z
       // Having computed the primary decomposition in 2 different ways and
       // having obtained the same number of branches, we might expect that the
       // number of branches is really 2, but we can check this by formulae
       // for the invariants of space curve singularities:
       //
       // mu = tau - t + 1 (for quasihomogeneous curve singularities)
       // where mu denotes the Milnor number, tau the Tjurina number and
       // t the Cohen-Macaulay type
       //
       // mu = 2 delta - r + 1
       // where delta denotes the delta-Invariant and r the number of branches
       //
       // tau can be computed by using the corresponding procedure T1 from
       // sing.lib.
       setring r;
       LIB "sing.lib";
       T_1(i);
     ==> // dim T_1 = 13
     ==> _[1]=gen(6)+2z*gen(5)
     ==> _[2]=gen(4)+3x2*gen(2)
     ==> _[3]=gen(3)+gen(1)
     ==> _[4]=x*gen(5)-y*gen(2)-z*gen(1)
     ==> _[5]=x*gen(1)-z2*gen(2)
     ==> _[6]=y*gen(5)+3x2z*gen(2)
     ==> _[7]=y*gen(2)-z*gen(1)
     ==> _[8]=2y*gen(1)-z2*gen(5)
     ==> _[9]=z2*gen(5)
     ==> _[10]=z2*gen(1)
     ==> _[11]=x3*gen(2)
     ==> _[12]=x2z2*gen(2)
     ==> _[13]=xz3*gen(2)
     ==> _[14]=z4*gen(2)
       setring rr;
       // Hence tau is 13 and therefore mu is 12. But then it is impossible that
       // the singularity has two branches, since mu is even and delta is an
       // integer!
       // So obviously, we did not decompose completely. Because the first branch
       // is smooth, only the second ideal can be the one which can be decomposed
       // further.
       // Let us now consider the normalization of this second ideal i2.
       LIB "normal.lib";
       normal(i2);
     ==> 
     ==> // 'normal' created a list of 1 ring(s).
     ==> // nor[1+1] is the delta-invariant in case of choose=wd.
     ==> // To see the rings, type (if the name of your list is nor):
     ==>      show( nor);
     ==> // To access the 1-st ring and map (similar for the others), type:
     ==>      def R = nor[1]; setring R;  norid; normap;
     ==> // R/norid is the 1-st ring of the normalization and
     ==> // normap the map from the original basering to R/norid
     ==> [1]:
     ==>    //   characteristic : 0
     ==> //   number of vars : 1
     ==> //        block   1 : ordering dp
     ==> //                  : names    T(1) 
     ==> //        block   2 : ordering C
       def rno=_[1];
       setring rno;
       norid;
     ==> norid[1]=0
       // The ideal is generated by a polynomial in one variable of degree 4 which
       // factors completely into 4 polynomials of type T(2)+a.
       // From this, we know that the ring of the normalization is the direct sum of 
       // 4 polynomial rings in one variable.
       // Hence our original curve has these 4 branches plus a smooth one
       // which we already determined by primary decomposition.
       // Our final result is therefore: 5 branches.


File: index.htm,  Node: Kernel of module homomorphisms,  Next: Algebraic dependence,  Prev: Branches of an Isolated Space Curve Singularity,  Up: Examples

A.24 Kernel of module homomorphisms
===================================

Let A $A$
, B $B$
 be two matrices of size $m\times r$ and $m\times s$
m x r and m x s over the ring R $R$
 and consider the corresponding maps $$
R^r \buildrel{A}\over{\longrightarrow}
R^m \buildrel{B}\over{\longleftarrow} R^s\;.
$$

        r   A     m
       R  -----> R
                 ^
                 |
                 |
                  s
                 R  .

We want to compute the kernel of the map $R^r \buildrel{A}\over{\longrightarrow}
R^m\longrightarrow
R^m/\hbox{Im}(B) \;.$

        r   A     m         m
       R  -----> R  -----> R /Im(B) .

This can be done using the `modulo' command: $$
\hbox{\tt modulo}(A,B)=\hbox{ker}(R^r
\buildrel{A}\over{\longrightarrow}R^m/\hbox{Im}(B)) \; .
$$

                        r   A     m
       modulo(A,B)=ker(R  -----> R /Im(B))  .

       ring r=0,(x,y,z),(c,dp);
       matrix A[2][2]=x,y,z,1;
       matrix B[2][2]=x2,y2,z2,xz;
       print(modulo(A,B));
     ==> yz2-x2, xyz-y2,  x2z-xy, x3-y2z,
     ==> x2z-xz2,-x2z+y2z,xyz-yz2,0      


File: index.htm,  Node: Algebraic dependence,  Next: Classification,  Prev: Kernel of module homomorphisms,  Up: Examples

A.25 Algebraic dependence
=========================

Let $g$, $f_1$, \dots, $f_r\in K[x_1,\ldots,x_n]$.
g, f_1, ..., f_r in K[x1,...,xn].  We want to check whether
  1. $f_1$, \dots, $f_r$
     f_1, ..., f_r are algebraically dependent.

     Let $I=\langle Y_1-f_1,\ldots,Y_r-f_r \rangle \subseteq
     K[x_1,\ldots,x_n,Y_1,\ldots,Y_r]$.

          I=<Y_1-f_1,...,Y_r-f_r> subset K[x1,...,xn,Y_1,...,Y_r].

     Then $I \cap K[Y_1,\ldots,Y_r]$
     I intersected with K[Y_1,...,Y_r] are the algebraic relations
     between $f_1$, \dots, $f_r$.
     f_1, ..., f_r.

  2. $g \in K [f_1,\ldots,f_r]$.
     g in K[f_1,...,f_r].

$g \in K[f_1,\ldots,f_r]$
     g in K[f_1,...,f_r] if and only if the normal form of g $g$
      with respect to I $I$
      and a block ordering with respect to $X=(x_1,\ldots,x_n)$ and $Y=(Y_1,\ldots,Y_r)$ with $X>Y$
     X=(x1,...,xn) and Y=(Y_1,...,Y_r) with X>Y is in K[Y] $K[Y]$
     .

Both questions can be answered using the following procedure. If the
second argument is zero, it checks for algebraic dependence and returns
the ideal of relations between the generators of the given ideal.
Otherwise it checks for subring membership and returns the normal form
of the second argument with respect to the ideal I.

       proc algebraicDep(ideal J, poly g)
       {
         def R=basering;         // give a name to the basering
         int n=size(J);
         int k=nvars(R);
         int i;
         intvec v;

         // construction of the new ring:

         // construct a weight vector
         v[n+k]=0;         // gives a zero vector of length n+k
         for(i=1;i<=k;i++)
         {
           v[i]=1;
         }
         string orde="(a("+string(v)+"),dp);";
         string ri="ring Rhelp=("+charstr(R)+"),
                               ("+varstr(R)+",Y(1.."+string(n)+")),"+orde;
                                 // ring definition as a string
         execute(ri);            // execution of the string

         // construction of the new ideal I=(J[1]-Y(1),...,J[n]-Y(n))
         ideal I=imap(R,J);
         for(i=1;i<=n;i++)
         {
           I[i]=I[i]-var(k+i);
         }
         poly g=imap(R,g);
         if(g==0)
         {
           // construction of the ideal of relations by elimination
           poly el=var(1);
           for(i=2;i<=k;i++)
           {
             el=el*var(i);
           }
           ideal KK=eliminate(I,el);
           keepring(Rhelp);
           return(KK);
         }
         // reduction of g with respect to I
         ideal KK=reduce(g,std(I));
         keepring(Rhelp);
         return(KK);
       }

       // applications of the procedure
       ring r=0,(x,y,z),dp;
       ideal i=xz,yz;
       algebraicDep(i,0);
     ==> _[1]=0
       // Note: after call of algebraicDep(), the basering is Rhelp.
       setring r; kill Rhelp;
       ideal j=xy+z2,z2+y2,x2y2-2xy3+y4;
       algebraicDep(j,0);
     ==> _[1]=Y(1)^2-2*Y(1)*Y(2)+Y(2)^2-Y(3)
       setring r; kill Rhelp;
       poly g=y2z2-xz;
       algebraicDep(i,g);
     ==> _[1]=Y(2)^2-Y(1)
       // this shows that g is contained in i.
       setring r; kill Rhelp;
       algebraicDep(j,g);
     ==> _[1]=-z^4+z^2*Y(2)-x*z
       // this shows that g is contained in j.


File: index.htm,  Node: Classification,  Next: Fast lexicographical GB,  Prev: Algebraic dependence,  Up: Examples

A.26 Classification
===================

Classification of isolated hypersurface singularities with respect to
right equivalence is provided by the command `classify' of the library
`classify.lib'. The classification is done using the algorithm of
Arnold. Before entering this algorithm, a first guess based on the
Hilbert polynomial of the Milnor algebra is made.

       LIB "classify.lib";
       ring r=0,(x,y,z),ds;
       poly p=singularity("E[6k+2]",2)[1];
       p=p+z^2;
       p;
     ==> z2+x3+xy6+y8
       // We received an E_14 singularity in normal form
       // from the database of normal forms. Since only the residual
       // part is saved in the database, we added z^2 to get an E_14
       // of embedding dimension 3.
       //
       // Now we apply a coordinate change in order to deal with a
       // singularity which is not in normal form:
       map phi=r,x+y,y+z,x;
       poly q=phi(p);
       // Yes, q really looks ugly, now:
       q;
     ==> x2+x3+3x2y+3xy2+y3+xy6+y7+6xy5z+6y6z+15xy4z2+15y5z2+20xy3z3+20y4z3+15xy2z\
        4+15y3z4+6xyz5+6y2z5+xz6+yz6+y8+8y7z+28y6z2+56y5z3+70y4z4+56y3z5+28y2z6+8\
        yz7+z8
       // Classification
       classify(q);
     ==> About the singularity :
     ==>           Milnor number(f)   = 14
     ==>           Corank(f)          = 2
     ==>           Determinacy       <= 12
     ==> Guessing type via Milnorcode:   E[6k+2]=E[14]
     ==> 
     ==> Computing normal form ...
     ==> I have to apply the splitting lemma. This will take some time....:-)
     ==>    Arnold step number 9
     ==> The singularity
     ==>    x3-9/4x4+27/4x5-189/8x6+737/8x7+6x6y+15x5y2+20x4y3+15x3y4+6x2y5+xy6-24\
        089/64x8-x7y+11/2x6y2+26x5y3+95/2x4y4+47x3y5+53/2x2y6+8xy7+y8+104535/64x9\
        +27x8y+135/2x7y2+90x6y3+135/2x5y4+27x4y5+9/2x3y6-940383/128x10-405/4x9y-2\
        025/8x8y2-675/2x7y3-2025/8x6y4-405/4x5y5-135/8x4y6+4359015/128x11+1701/4x\
        10y+8505/8x9y2+2835/2x8y3+8505/8x7y4+1701/4x6y5+567/8x5y6-82812341/512x12\
        -15333/8x11y-76809/16x10y2-25735/4x9y3-78525/16x8y4-16893/8x7y5-8799/16x6\
        y6-198x5y7-495/4x4y8-55x3y9-33/2x2y10-3xy11-1/4y12
     ==> is R-equivalent to E[14].
     ==>    Milnor number = 14
     ==>    modality      = 1
     ==> 2z2+x3+xy6+y8
       // The library also provides routines to determine the corank of q
       // and its residual part without going through the whole
       // classification algorithm.
       corank(q);
     ==> 2
       morsesplit(q);
     ==> y3-9/4y4+27/4y5-189/8y6+737/8y7+6y6z+15y5z2+20y4z3+15y3z4+6y2z5+yz6-24089\
        /64y8-y7z+11/2y6z2+26y5z3+95/2y4z4+47y3z5+53/2y2z6+8yz7+z8+104535/64y9+27\
        y8z+135/2y7z2+90y6z3+135/2y5z4+27y4z5+9/2y3z6-940383/128y10-405/4y9z-2025\
        /8y8z2-675/2y7z3-2025/8y6z4-405/4y5z5-135/8y4z6+4359015/128y11+1701/4y10z\
        +8505/8y9z2+2835/2y8z3+8505/8y7z4+1701/4y6z5+567/8y5z6-82812341/512y12-15\
        333/8y11z-76809/16y10z2-25735/4y9z3-78525/16y8z4-16893/8y7z5-8799/16y6z6-\
        198y5z7-495/4y4z8-55y3z9-33/2y2z10-3yz11-1/4z12


File: index.htm,  Node: Fast lexicographical GB,  Next: Parallelization with MPtcp links,  Prev: Classification,  Up: Examples

A.27 Fast lexicographical GB
============================

Compute Groebner basis in lexicographical ordering by using the FGLM
algorithm (`stdfglm') and Hilbert driven Groebner (`stdhilb').

The command `stdfglm' applies only for zero-dimensional ideals and
returns a reduced Groebner basis.

For the ideal below, `stdfglm' is more than 100 times and `stdhilb'
about 10 times faster than `std'.

       ring r =32003,(a,b,c,d,e),lp;
       ideal i=a+b+c+d, ab+bc+cd+ae+de, abc+bcd+abe+ade+cde,
               abc+abce+abde+acde+bcde, abcde-1;
       int t=timer;
       ideal j1=stdfglm(i);
       timer-t;
     ==> 0
       size(j1);   // size (no. of polys) in computed GB
     ==> 5
       t=timer;
       ideal j2=stdhilb(i);
       timer-t;
     ==> 0
       size(j2);   // size (no. of polys) in computed GB
     ==> 158
       // usual Groebner basis computation for lex ordering
       t=timer;
       ideal j0 =std(i);
       timer-t;
     ==> 1


File: index.htm,  Node: Parallelization with MPtcp links,  Prev: Fast lexicographical GB,  Up: Examples

A.28 Parallelization with MPtcp links
=====================================

In this example, we demonstrate how MPtcp links can be used to
parallelize computations.

To compute a standard basis for a zero-dimensional ideal in the
lexicographical ordering, one of the two powerful routines `stdhilb'
(see *note stdhilb::) and `stdfglm' (see *note stdfglm::) should be
used. However, a priory one can not predict which one of the two
commands is faster. This very much depends on the (input) example.
Therefore, we use MPtcp links to let both commands work on the problem
independently and in parallel, so that the one which finishes first
delivers the result.

The example we use is the so-called "omdi example". See Tim Wichmann;
Der FGLM-Algorithmus: verallgemeinert und implementiert in Singular;
Diplomarbeit Fachbereich Mathematik, Universitaet Kaiserslautern; 1997
for more details.

     ring r=0,(a,b,c,u,v,w,x,y,z),lp;
     ideal i=a+c+v+2x-1, ab+cu+2vw+2xy+2xz-2/3,  ab2+cu2+2vw2+2xy2+2xz2-2/5,
     ab3+cu3+2vw3+2xy3+2xz3-2/7, ab4+cu4+2vw4+2xy4+2xz4-2/9, vw2+2xyz-1/9,
     vw4+2xy2z2-1/25, vw3+xyz2+xy2z-1/15, vw4+xyz3+xy3z-1/21;

     link l_hilb,l_fglm = "MPtcp:fork","MPtcp:fork";         // 1.

     open(l_fglm); open(l_hilb);

     write(l_hilb, quote(system("pid")));                    // 2.
     write(l_fglm, quote(system("pid")));
     int pid_hilb,pid_fglm = read(l_hilb),read(l_fglm);

     write(l_hilb, quote(stdhilb(i)));                       // 3.
     write(l_fglm, quote(stdfglm(eval(i))));

     while ((! status(l_hilb, "read", "ready", 1)) &&        // 4.
            (! status(l_fglm, "read", "ready", 1))) {}

     if (status(l_hilb, "read", "ready"))
     {
       "stdhilb won !!!!"; size(read(l_hilb));
       close(l_hilb); pid_fglm = system("sh","kill "+string(pid_fglm));
     }
     else                                                    // 5.
     {
       "stdfglm won !!!!"; size(read(l_fglm));
       close(l_fglm); pid_hilb = system("sh","kill "+string(pid_hilb));
     }
     ==> stdfglm won !!!!
     ==> 9
Some explanatory remarks are in order:
  1. Instead of using links of the type `MPtcp:fork', we alternatively
     could use `MPtcp:launch' links such that the two "competing"
     SINGULAR processes run on different machines. This has the
     advantage of "true" parallel computing since no resource sharing is
     involved (as it usually is with forked processes).

  2. Unfortunately, MPtcp links do not offer means to (asynchronously)
     interrupt or kill an attached (i.e., launched or forked) process.
     Therefore, we explicitly need to get the process id numbers of the
     competing SINGULAR processes, so that we can "kill" the looser
     later.

  3. Notice how quoting is used in order to prevent local evaluation
     (i.e., local computation of results). Since we "forked" the two
     competing processes, the identifier `i' is defined and has
     identical values in both child processes. Therefore, the innermost
     `eval' can be omitted (as is done for the `l_hilb' link), and only
     the identifier `i' needs to be communicated to the children.
     However, when `MPtcp:launch' links are used, the inner evaluation
     must be applied so that actual values, and not the identifiers are
     communicated (as is done for the `l_fglm' link).

  4. We go into a "sleepy" loop and wait until one of the two children
     finished the computation. That is, the current process checks
     approximately once per second the status of one of the connecting
     links, and sleeps (i.e., suspends its execution) in the
     intermediate time.

  5. The child which has won delivers the result and is terminated with
     the usual `close' command. The other child which is still computing
     needs to be terminated by an explicit (i.e., system) kill command,
     since it can not be terminated through the link while it is still
     computing.


File: index.htm,  Node: Polynomial data,  Next: Mathematical background,  Prev: Examples,  Up: Top

Appendix B Polynomial data
**************************

* Menu:

* Representation of mathematical objects::
* Monomial orderings::


File: index.htm,  Node: Representation of mathematical objects,  Next: Monomial orderings,  Up: Polynomial data

B.1 Representation of mathematical objects
==========================================

SINGULAR distinguishes between objects which do not belong to a ring and
those which belong to a specific ring (see *note Rings and orderings::).
We comment only on the latter ones.

Internally all ring-dependent objects are polynomials or structures
built from polynomials (and some additional information).  Note that
SINGULAR stores (and hence prints) a polynomial automatically w.r.t. the
monomial ordering.

Hence, in order to define such an object in SINGULAR, one has to give a
list of polynomials in a specific format.

For ideals, resp. matrices, this is straight forward: The user gives a
list of polynomials which generate the ideal, resp. which are the
entries of the matrix.  (The number of rows and columns has to be given
when creating the matrix.)

A vector  in SINGULAR is always an element of a free module over the
basering. It is given as a list of polynomials in one of the following
formats $[f_1,...,f_n]$ or $f_1*gen(1)+...+f_n*gen(n)$, where $gen(i)$
[f_1,...,f_n] or f_1*gen(1)+...+f_n*gen(n), where gen(i) denotes the
i-th canonical generator of a free module (with 1 at place i and 0
everywhere else).  Both forms are equivalent. A vector is internally
represented in the second form with the $gen(i)$
gen(i) being "special" ring variables, ordered accordingly to the
monomial ordering.  Therefore, the form $[f_1,...,f_n]$
[f_1,...,f_n] is given as output only if the monomial ordering gives
priority to the component, i.e., is of the form `(c,...)' (see *note
Module orderings::).  However, in any case the procedure `show' from the
library `inout.lib' displays the bracket format.

A vector $v=[f_1,...,f_n]$
v=[f_1,...,f_n] should always be considered as a column vector in a free
module of rank equal to nrows($v$)
nrows(v) where nrows($v$)
nrows(v) is equal to the maximal index $r$
r such that $f_r \not= 0$.
f_r<>0.  This is due to the fact, that internally $v$
v is a polynomial in a sparse representation, i.e., $f_i*gen(i)$
f_i*gen(i) is not stored if $f_i=0$
f_i=0 (for reasons of efficiency), hence the last 0-entries of $v$
v are lost.  Only more complex structures are able to keep the rank.

A module $M$
M in SINGULAR is given by a list of vectors $v_1,...,v_k$
v_1,....v_k which generate the module as a submodule of the free module
of rank equal to nrows($M$)
nrows(M) which is the maximum of nrows($v_i$).
nrows(v_i).

If one wants to create a module with a larger rank than given by its
generators, one has to use the command `attrib(M,"rank",r)' (see *note
attrib::, *note nrows::) or to define a matrix first, then converting it
into a module.  Modules in SINGULAR are almost the same as matrices,
they may be considered as sparse representations of matrices.  A module
of a matrix is generated by the columns of the matrix and a matrix of a
module has as columns the generators of the module.  These conversions
preserve the rank and the number of generators, resp. the number of rows
and columns.

By the above remarks it might appear that SINGULAR is only able to
handle submodules of a free module. However, this is not true. SINGULAR
can compute with any finitely generated module over the basering $R$.
R.  Such a module, say $N$,
N, is not represented by its generators but by its (generators and)
relations. This means that $N = R^n/M$ where $n$ 
N = R^n/M where n is the number of generators of $N$ and $M \subseteq R^n$
N and M in R^n is the module of relations.  In other words, defining  a
module $M$
M as a submodule of a free module $R^n$
R^n can also be considered as the definition of $N = R^n/M$.
N=R^n/M.

Note that most functions, when applied to a module $M$,
M, really deal with $M$.
M.  However, there are some functions which deal with $N = R^n/M$ instead of $M$.
N=R^n/M instead of M.

For example, `std(M)' computes a standard basis of $M$
M (and thus gives another representation of $N$ as $N = R^n/$std($M$)).
N as N=R^n/std(M)).  However, `dim(M)', resp. `vdim(M)', returns dim$(R^n/M)$, resp.@: dim$_k(R^n/M)$
dim(R^n/M), resp. dim_k(R^n/M) (if M is given by a standard basis).

The function `syz(M)'  returns the first syzygy module of $M$,
M, i.e., the module of relations of the given generators of $M$
M which is equal to the second syzygy module of $N$.
N.  Refer to the description of each function in *note Functions:: to
get information which module the function deals with.

The numbering in `res' and other commands for computing resolutions
refers to a resolution of $N = R^n/M$
N=R^n/M (see *note res::; *note Syzygies and resolutions::).

It is possible to compute in any field which is a valid ground field in
SINGULAR.  For doing so, one has to define a ring with the desired
ground field and at least one variable. The elements of the field are of
type number, but may also be considered as polynomials (of degree 0).
Large computations should be faster if the elements of the field are
defined as numbers.

The above remarks do also apply to quotient rings. Polynomial data are
stored internally in the same manner, the only difference is that this
polynomial representation is in general not unique. `reduce(f,std(0))'
computes a normal form of a polynomial f in a quotient ring (cf. *note
reduce::).


File: index.htm,  Node: Monomial orderings,  Prev: Representation of mathematical objects,  Up: Polynomial data

B.2 Monomial orderings
======================

* Menu:

* Introduction to orderings::
* General definitions for orderings::
* Global orderings::
* Local orderings::
* Module orderings::
* Matrix orderings::
* Product orderings::
* Extra weight vector::


File: index.htm,  Node: Introduction to orderings,  Next: General definitions for orderings,  Up: Monomial orderings

B.2.1 Introduction to orderings
-------------------------------

SINGULAR offers a great variety of monomial orderings which provide an
enormous functionality, if used diligently. However, this flexibility
might also be confusing for the novice user.  Therefore, we recommend to
those not familiar with monomial orderings to generally use the ordering
`dp' for computations in the polynomial ring $K[x_1,\ldots,x_n]$, 
K[x1,...,xn], resp.  `ds' for computations in the localization $\hbox{Loc}_{(x)}K[x_1,\ldots,x_n]$.
Loc_(x)K[x1,...,xn].

For inhomogeneous input ideals,  standard (resp. groebner) bases
computations are generally faster with the orderings $\hbox{Wp}(w_1, \ldots, w_n)$
Wp(w_1, ..., w_n) (resp. $\hbox{Ws}(w_1, \ldots, w_n)$)
Ws(w_1, ..., w_n)) if the input is quasihomogeneous w.r.t. the weights $w_1$, $\ldots$, $w_n$ of $x_1$, $\ldots$, $x_n$. 
w_1, ..., w_n of x_1, ..., x_n.

If the output needs to be "triangular" (resp. "block-triangular"), the
lexicographical ordering `lp' (resp. lexicographical block-orderings)
need to be used. However, these orderings usually result in much less
efficient computations.


File: index.htm,  Node: General definitions for orderings,  Next: Global orderings,  Prev: Introduction to orderings,  Up: Monomial orderings

B.2.2 General definitions for orderings
---------------------------------------

A monomial ordering (term ordering) on $K[x_1, \ldots, x_n]$ is
a total ordering $<$ on the
set of monomials (power products) $\{x^\alpha \mid \alpha \in \bf{N}^n\}$
which is compatible with the
natural semigroup structure, i.e., $x^\alpha < x^\beta$ implies $x^\gamma
x^\alpha < x^\gamma x^\beta$ for any $\gamma \in \bf{N}^n$.
We do not require
$<$ to be  a well ordering.
A monomial ordering (term ordering) on K[x_1, ..., x_n] is a total
ordering < on the set of monomials (power products) {x^a | a in N^n}
which is compatible with the natural semigroup structure, i.e., x^a <
x^b implies x^c*x^a < x^c*x^b for any c in N^n.  We do not require < to
be  a well ordering.   See the literature cited in *note References::.

It is known that any monomial ordering can be represented by a matrix $M$ in $GL(n,R)$,
M in GL(n,R), but, of course, only integer coefficients are of relevance
in practice.

Global orderings are well orderings (i.e.,  \hbox{$1 < x_i$} for each variable
$x_i$), local orderings satisfy $1 > x_i$ for each variable.   If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not well orderings.

Let $K$ be the ground field, \hbox{$x = (x_1, \ldots, x_n)$} the
variables and $<$ a monomial ordering, then Loc $K[x]$ denotes the
localization of $K[x]$ with respect to the multiplicatively closed set $$\{1 +
g \mid g = 0 \hbox{ or } g \in K[x]\backslash \{0\} \hbox{ and }L(g) <
1\}.$$   Here, $L(g)$ 
denotes the leading monomial of $g$, i.e., the biggest monomial of $g$ with
respect to $<$.   The result of any computation which uses standard basis
computations has to be interpreted in Loc $K[x]$.
Global orderings are well orderings (i.e., 1 < x_i for each variable
x_i), local orderings satisfy 1 > x_i for each variable.  If some
variables are ordered globally and others locally we call it a mixed
ordering.   Local or mixed orderings are not well orderings.

If K is the ground field, x = (x_1, ..., x_n) the variables and < a
monomial ordering, then Loc K[x] denotes the localization of K[x] with
respect to the multiplicatively closed set {1 + g | g = 0 or g in
K[x]\{0} and L(g) < 1}.   L(g) denotes the leading monomial of g, i.e.,
the biggest monomial of g with respect to <.   The result of any
computation which uses standard basis computations has to be interpreted
in Loc K[x].

Note that the definition of a ring includes the definition of its
monomial ordering (see *note Rings and orderings::). SINGULAR offers the
monomial orderings described in the following sections.


File: index.htm,  Node: Global orderings,  Next: Local orderings,  Prev: General definitions for orderings,  Up: Monomial orderings

B.2.3 Global orderings
----------------------

For all these orderings: Loc $K[x]$ = $K[x]$
For all these orderings: Loc K[x] = K[x]

lp:
     lexicographical ordering:
     x^a < x^b  <==> there is an i,  1 <= i <= n :
     a_1 = b_1, ..., a_(i-1) = b_(i-1), a_i < b_i.  $x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
     \alpha_1 = \beta_1, \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i <
     \beta_i$.

rp:
     reverse lexicographical ordering:
     x^a < x^b  <==> there is an i,  1 <= i <= n :
     a_n = b_n, ..., a_(i+1) = b_(i+1), a_i > b_i.  $x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
     \alpha_n = \beta_n,
         \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i.$

dp:
     degree reverse lexicographical ordering:
     let deg(x^a) = a_1 + ... + a_n, then let $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ then

     x^a < x^b <==>
     deg(x^a) < deg(x^b),
     or
     deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
     a_n = b_n, ..., a_(i+1) = b_(i+1), a_i > b_i.      $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) < \deg(x^\beta)$ or

\phantom{$x^\alpha < x^\beta \Leftrightarrow $}$ \deg(x^\alpha) =
         \deg(x^\beta)$ and $\exists\ 1 \le i \le n: \alpha_n = \beta_n,
         \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i.$

Dp:
     degree lexicographical ordering:
     let deg(x^a) = a_1 + ... + a_n, then let $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ then

     x^a < x^b <==>
     deg(x^a) < deg(x^b)
     or
     deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
     a_1 = b_1, ..., a_(i-1) = b_(i-1), a_i < b_i.      $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) < \deg(x^\beta)$ or

\phantom{ $x^\alpha < x^\beta \Leftrightarrow $} $\deg(x^\alpha) =
         \deg(x^\beta)$ and $\exists\ 1 \le i \le n:\alpha_1 = \beta_1,
         \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i < \beta_i.$

wp:
     weighted reverse lexicographical ordering:
     wp(w_1, ..., w_n), w_i  positive integers, let $w_1, \ldots, w_n$ be positive integers. Then ${\tt wp}(w_1, \ldots,
     w_n)$ 
      is defined as `dp'  but with   deg(x^a) = w_1 a_1 + ... + w_n a_n.
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$

Wp:
     weighted lexicographical ordering:
     Wp(w_1, ..., w_n), w_i  positive integers, let $w_1, \ldots, w_n$ be positive integers. Then ${\tt Wp}(w_1, \ldots,
     w_n)$ 
      is defined as `Dp'  but with   deg(x^a) = w_1 a_1 + ... + w_n a_n.
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$


File: index.htm,  Node: Local orderings,  Next: Module orderings,  Prev: Global orderings,  Up: Monomial orderings

B.2.4 Local orderings
---------------------

For ls, ds, Ds and, if the weights are positive integers, also for ws
and Ws,  we have Loc K[x] = K[x]_(x), Loc $K[x]$ = $K[x]_{(x)}$,
 the localization of $K[x]$
K[x] at the maximal ideal  (x_1, ..., x_n).  \ $(x_1, ..., x_n)$.

ls:
     negative lexicographical ordering:
     x^a < x^b  <==> there is an i,  1 <= i <= n :
     a_1 = b_1, ..., a_(i-1) = b_(i-1), a_i > b_i.  $x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
     \alpha_1 = \beta_1, \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i >
     \beta_i$.

ds:
     negative degree reverse lexicographical ordering:
     let deg(x^a) = a_1 + ... + a_n, then let $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ then

     x^a < x^b <==>
     deg(x^a) > deg(x^b)
     or
     deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
     a_n = b_n, ..., a_(i+1) = b_(i+1), a_i > b_i.      $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) > \deg(x^\beta)$ or

\phantom{ $x^\alpha < x^\beta \Leftrightarrow$}$ \deg(x^\alpha) =
         \deg(x^\beta)$ and $\exists\ 1 \le i \le n: \alpha_n = \beta_n,
         \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i.$

Ds:
     negative degree lexicographical ordering:
     let deg(x^a) = a_1 + ... + a_n, then let $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ then
     x^a < x^b <==>
     deg(x^a) > deg(x^b)
     or
     deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
     a_1 = b_1, ..., a_(i-1) = b_(i-1), a_i < b_i.      $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) > \deg(x^\beta)$ or 

\phantom{ $ x^\alpha < x^\beta \Leftrightarrow$}$ \deg(x^\alpha) =
         \deg(x^\beta)$ and $\exists\ 1 \le i \le n:\alpha_1 = \beta_1,
         \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i < \beta_i.$

ws:
     (general) weighted reverse lexicographical ordering:
     ws(w_1, ..., w_n), w_1 ${\tt ws}(w_1, \ldots, w_n),\; w_1$
      a nonzero integer, w_2,...,w_n $w_2,\ldots,w_n$
      any integer (including 0),  is defined as `ds'  but with
     deg(x^a) = w_1 a_1 + ... + w_n a_n.  $\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$

Ws:
     (general) weighted lexicographical ordering:
     Ws(w_1, ..., w_n), w_1 ${\tt Ws}(w_1, \ldots, w_n),\; w_1$
      a nonzero integer, w_2,...,w_n $w_2,\ldots,w_n$
      any integer (including 0),  is defined as `Ds'  but with
     deg(x^a) = w_1 a_1 + ... + w_n a_n.  $\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$


File: index.htm,  Node: Module orderings,  Next: Matrix orderings,  Prev: Local orderings,  Up: Monomial orderings

B.2.5 Module orderings
----------------------

SINGULAR offers also orderings on the set of "monomials" { x^a*gen(i) |
a in N^n, 1 <= i <= r } in Loc K[x]^r = Loc K[x]gen(1) + ... + Loc
K[x]gen(r), where gen(1), ..., gen(r) denote the canonical generators of
Loc K[x]^r, the r-fold direct sum of Loc K[x].  $\{ x^a e_i  \mid  a \in N^n, 1 \leq i \leq r \}$ in Loc $K[x]^r$ = Loc
$K[x]e_1 
+ \ldots +$Loc $K[x]e_r$, where $e_1, \ldots, e_r$ denote the canonical
generators of Loc $K[x]^r$, the r-fold direct sum of Loc $K[x]$.
(The function {\tt gen(i)} yields $e_i$).

We have two possibilities: either to give priority to the component of a
vector in Loc K[x]^r  Loc $K[x]^r$
or (which is the default in SINGULAR) to give priority to the
coefficients.  The orderings `(<,c)' and `(<,C)' give priority to the
coefficients; whereas `(c,<)' and `(C,<)' give priority to the
components.
Let < be any of the monomial orderings of Loc $K[x]$
Loc K[x] as above.

(<,C):
     <_m = (<,C) denotes the module ordering (giving priority to the
     coefficients):
     x^a*gen(i) <_m x^b*gen(j) <==>
     x^a < x^b
     or
     x^a = x^b  and  i < j.  $<_m = (<,C)$ denotes the module ordering (giving priority to the coefficients):

\quad  \quad  $x^\alpha e_i <_m x^\beta e_j \Leftrightarrow x^\alpha <
     x^\beta$ or ($x^\alpha = x^\beta $ and $ i < j$).

     *Example:*

            ring r = 0, (x,y,z), ds;
            // the same as ring r = 0, (x,y,z), (ds, C);
            [x+y2,z3+xy];
          ==> x*gen(1)+xy*gen(2)+y2*gen(1)+z3*gen(2)
            [x,x,x];
          ==> x*gen(3)+x*gen(2)+x*gen(1)

(C,<):
     <_m = (C, <) denotes the module ordering (giving priority to the
     component):
     x^a*gen(i) <_m x^b*gen(j) <==>
     i<j
     or
     i = j and x^a < x^b.  $<_m = (C, <)$ denotes the module ordering (giving priority to the component):

\quad \quad   $x^\alpha e_i <_m x^\beta e_j \Leftrightarrow i < j$ or ($
     i = j $ and $ x^\alpha < x^\beta $). 

     *Example:*

            ring r = 0, (x,y,z), (C,lp);
            [x+y2,z3+xy];
          ==> xy*gen(2)+z3*gen(2)+x*gen(1)+y2*gen(1)
            [x,x,x];
          ==> x*gen(3)+x*gen(2)+x*gen(1)

(<,c):
     <_m = (<,c) denotes the module ordering (giving priority to the
     coefficients):
     x^a*gen(i) <_m x^b*gen(j) <==>
     x^a < x^b
     or
     x^a = x^b  and  i > j.  $<_m = (<,c)$ denotes the module ordering (giving priority to the coefficients):

\quad \quad $x^\alpha e_i <_m x^\beta e_j \Leftrightarrow x^\alpha <
     x^\beta$ or ($x^\alpha = x^\beta $ and $ i > j$).

     *Example:*

            ring r = 0, (x,y,z), (lp,c);
            [x+y2,z3+xy];
          ==> xy*gen(2)+x*gen(1)+y2*gen(1)+z3*gen(2)
            [x,x,x];
          ==> x*gen(1)+x*gen(2)+x*gen(3)

(c,<):
     <_m = (c, <) denotes the module ordering (giving priority to the
     component):
     x^a*gen(i) <_m x^b*gen(j) <==>
     i>j
     or
     i = j and x^a < x^b.  $<_m = (c, <)$ denotes the module ordering (giving priority to the component):

\quad \quad   $x^\alpha e_i <_m x^\beta e_j \Leftrightarrow i > j$ or ($
     i = j $ and $ x^\alpha < x^\beta $). 

     *Example:*

            ring r = 0, (x,y,z), (c,lp);
            [x+y2,z3+xy];
          ==> [x+y2,xy+z3]
            [x,x,x];
          ==> [x,x,x]

The output of a vector v in K[x]^r with components v_1, ..., v_r has the
format v_1 * gen(1) + ... + v_r * gen(r) The output of a vector $v$ in $K[x]^r$ with components $v_1,
\ldots, v_r$ has the format $v_1 * gen(1) + \ldots + v_r * gen(r)$
(up to permutation) unless the ordering starts with `c'.  In this case a
vector is written as [v_1, ..., v_r].  In this case a vector is written as $[v_1, \ldots, v_r]$.
In all cases SINGULAR can read input in both formats.


File: index.htm,  Node: Matrix orderings,  Next: Product orderings,  Prev: Module orderings,  Up: Monomial orderings

B.2.6 Matrix orderings
----------------------

Let $M$
M be an invertible $(n \times n)$-matrix
(n x n)-matrix  with integer coefficients and M_1, ..., M_n the rows of
M.  $M_1, \ldots, M_n$ the rows of $M$.

The M-ordering < is defined as follows:
x^a < x^b <==> there exists an i: 1 <= i <= n : M_1*a = M_1*b, ...,
M_(i-1)*a = M_(i-1)*b, M_i*a < M_i*b.  \quad \quad $x^a < x^b \Leftrightarrow \exists\  1 \leq i \leq n :
M_1 a = \; M_1 b, \ldots, M_{i-1} a = \; M_{i-1} b$ and $M_i a < \; M_i b$.

Thus, x^a < x^b if and only if M*a is smaller than M*b $x^a < x^b$
if and only if $M a$ is smaller than $M b$
with respect to the lexicographical ordering.

The following matrices represent (for 3 variables) the global and local
orderings defined above (note that the matrix is not uniquely determined
by the ordering):

lp:
     1   0   0
     0   1   0
     0   0   1

dp:
     1   1   1
     0   0  -1
     0  -1   0

Dp:
     1   1   1
     1   0   0
     0   1   0

wp(1,2,3):
     1   2   3
     0   0  -1
     0  -1   0

Wp(1,2,3):
     1   2   3
     1   0   0
     0   1   0

ls:
     -1   0   0
     0  -1   0
     0   0  -1

ds:
     -1  -1  -1
     0   0  -1
     0  -1   0

Ds:
     -1  -1  -1
     1   0   0
     0   1   0

ws(1,2,3):
     -1  -2  -3
     0   0  -1
     0  -1   0

Ws(1,2,3):
     -1  -2  -3
     1   0   0
     0   1   0

$\quad$ lp:
$\left(\matrix{
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 0 & 0 & 1 \cr
 }\right)$
\quad dp:
$\left(\matrix{
 1 & 1 & 1 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Dp:
$\left(\matrix{
 1 & 1 & 1 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

$\quad$ wp(1,2,3):
$\left(\matrix{
 1 & 2 & 3 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Wp(1,2,3):
$\left(\matrix{
 1 & 2 & 3 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

$\quad$ ls:
$\left(\matrix{
-1 & 0 & 0 \cr
 0 &-1 & 0 \cr
 0 & 0 &-1 \cr
 }\right)$
\quad ds:
$\left(\matrix{
-1 &-1 &-1 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Ds:
$\left(\matrix{
-1 &-1 &-1 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

$\quad$ ws(1,2,3):
$\left(\matrix{
-1 &-2 &-3 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Ws(1,2,3):
$\left(\matrix{
-1 &-2 &-3 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

Product orderings (see next section) represented by  a matrix:

(dp(3), wp(1,2,3)):
     1  1  1  0  0  0
     0  0  -1  0  0  0
     0  -1  0  0  0  0
     0  0  0  1  2  3
     0  0  0  0  0  -1
     0  0  0  0  -1  0

(Dp(3), ds(3)):
     1  1  1  0  0  0
     1  0  0  0  0  0
     0  1  0  0  0  0
     0  0  0  -1  -1  -1
     0  0  0  0  0  -1
     0  0  0  0  -1  0
$\quad$ (dp(3), wp(1,2,3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
0&  0&  -1&  0&  0&  0 \cr
0&  -1&  0&  0&  0&  0 \cr
0&  0&  0&  1&  2&  3 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$

$\quad$ (Dp(3), ds(3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
1&  0&  0&  0&  0&  0 \cr
0&  1&  0&  0&  0&  0 \cr
0&  0&  0&  -1&  -1&  -1 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$

Orderings with extra weight vector (see below) represented by  a matrix:

(dp(3), a(1,2,3),dp(3)):
     1  1  1  0  0  0
     0  0  -1  0  0  0
     0  -1  0  0  0  0
     0  0  0  1  2  3
     0  0  0  1  1  1
     0  0  0  0  0  -1
     0  0  0  0  -1  0

(a(1,2,3,4,5),Dp(3), ds(3)):
     1  2  3  4  5  0
     1  1  1  0  0  0
     1  0  0  0  0  0
     0  1  0  0  0  0
     0  0  0  -1  -1  -1
     0  0  0  0  0  -1
     0  0  0  0  -1  0
$\quad$ (dp(3), a(1,2,3),dp(3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
0&  0&  -1&  0&  0&  0 \cr
0&  -1&  0&  0&  0&  0 \cr
0&  0&  0&  1&  2&  3 \cr
0&  0&  0&  1&  1&  1 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$

$\quad$ (a(1,2,3,4,5),Dp(3), ds(3)):
$\left(\matrix{
1&  2&  3&  4&  5&  0 \cr
1&  1&  1&  0&  0&  0 \cr
1&  0&  0&  0&  0&  0 \cr
0&  1&  0&  0&  0&  0 \cr
0&  0&  0&  -1&  -1&  -1 \cr
0&  0&  0&  0&  0 & -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$


*Example*:
       ring r = 0, (x,y,z), M(1, 0, 0,   0, 1, 0,   0, 0, 1);

which may also be written as:
       intmat m[3][3]=1, 0, 0, 0, 1, 0, 0, 0, 1;
       m;
     ==> 1,0,0,
     ==> 0,1,0,
     ==> 0,0,1 
       ring r = 0, (x,y,z), M(m);
       r;
     ==> //   characteristic : 0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering M
     ==> //                  : names    x y z 
     ==> //                  : weights  1 0 0 
     ==> //                  : weights  0 1 0 
     ==> //                  : weights  0 0 1 
     ==> //        block   2 : ordering C

If the ring has $n$
n variables and the matrix contains less than $n \times n$
n x n entries an error message is given, if there are more entries, the
last ones are ignored.

*WARNING:* SINGULAR does not check whether the matrix has full rank.
In such a case some computations might not terminate, others might give
a nonsense result.

Having these matrix orderings SINGULAR can compute standard bases for
any monomial ordering which is compatible with the natural semigroup
structure.  In practice the global and local orderings together with
block orderings should be sufficient in most cases. These orderings are
faster than the corresponding matrix orderings, since evaluating a
matrix product is time consuming.


File: index.htm,  Node: Product orderings,  Next: Extra weight vector,  Prev: Matrix orderings,  Up: Monomial orderings

B.2.7 Product orderings
-----------------------

Let x = (x_1, ..., x_n) = x(1..n) and y = (y_1, ..., y_m) = y(1..m) $x = (x_1, \ldots, x_n)$ and $y = (y_1, \ldots, y_m)$
be two ordered sets of variables, <_1 a monomial ordering on K[x] and
<_2 a monomial ordering on K[y].   The product ordering (or block
ordering) < = (<_1,<_2) on K[x,y] is the following:
x^a y^b < x^A y^B <==>
x^a <_1 x^A
or
x^a = x^A  and  y^b <_2 y^B.  $<_1$ a monomial
ordering on $K[x]$ and $<_2$ a monomial ordering on $K[y]$.   The product
ordering (or block ordering) $<\ := (<_1,<_2)$ on $K[x,y]$ is the following:

\quad \quad $x^a y^b < x^A y^B \Leftrightarrow x^a <_1 x^A $ or ($x^a =
x^A$ and $y^b <_2 y^B$). 

Inductively one defines the product ordering of more than two monomial
orderings.

In SINGULAR, any of the above global orderings, local orderings or
matrix orderings may be combined (in an arbitrary manner and length) to
a product ordering.   E.g., `(lp(3), M(1, 2, 3, 1, 1, 1, 1, 0, 0),
ds(4), ws(1,2,3))' defines: `lp' on the first 3 variables, the matrix
ordering `M(1, 2, 3, 1, 1, 1, 1, 0, 0)' on the next 3 variables, `ds' on
the next 4 variables and `ws(1,2,3)' on the last 3 variables.


File: index.htm,  Node: Extra weight vector,  Prev: Product orderings,  Up: Monomial orderings

B.2.8 Extra weight vector
-------------------------

a(w_1, ..., w_n), ${\tt a}(w_1, \ldots, w_n),\; $
w_1,...,w_n $w_1,\ldots,w_n$
any integers (including 0), defines   deg(x^a) = w_1 a_1 + ... + w_n a_n
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n$
and
deg(x^a) < deg(x^b) ==> x^a < x^b     $$\deg(x^\alpha) < \deg(x^\beta) \Rightarrow x^\alpha < x^\beta,$$

deg(x^a) > deg(x^b) ==> x^a > x^b.      $$\deg(x^\alpha) > \deg(x^\beta) \Rightarrow x^\alpha > x^\beta. $$

An extra weight vector does not define a monomial ordering by itself: it
can only be used in combination with other orderings to insert an extra
line of weights into the ordering matrix.


*Example*:
     ring r = 0, (x,y,z),  (a(1,2,3),wp(4,5,2));
     ring s = 0, (x,y,z),  (a(1,2,3),dp);
     ring q = 0, (a,b,c,d),(lp(1),a(1,2,3),ds);


File: index.htm,  Node: Mathematical background,  Next: SINGULAR libraries,  Prev: Polynomial data,  Up: Top

Appendix C Mathematical background
**********************************

This chapter introduces some of the mathematical notions and definitions
used throughout the manual. It is mostly a collection of the most
prominent definitions and properties. For details, please, refer to some
articles or text books (see *note References::).

* Menu:

* Standard bases::
* Hilbert function::
* Syzygies and resolutions::
* Characteristic sets::
* Gauss-Manin connection::
* Toric ideals and integer programming::
* References::


File: index.htm,  Node: Standard bases,  Next: Hilbert function,  Up: Mathematical background

C.1 Standard bases
==================

Definition
----------

Let $R = \hbox{Loc}_< K[\underline{x}]$ and let $I$ be a submodule of $R^r$.
Note that for r=1 this means that $I$ is an ideal in $R$.
Denote by $L(I)$ the submodule of $R^r$ generated by the leading terms 
of elements of $I$, i.e. by $\left\{L(f) \mid f \in I\right\}$.
Then $f_1, \ldots, f_s \in I$ is called a {\bf standard basis} of $I$ 
if $L(f_1), \ldots, L(f_s)$ generate $L(I)$.
Let R = Loc K[x] and let I be a submodule of $R^r$.  Denote by L(I) the
submodule of R^r generated by the leading terms of elements in $I$, i.e.
by { L(f) | f in I}.  Then f_1, ..., f_s in I is called a *standard
basis* of I if L(f_1), ..., L(f_s) generate L(I).

Properties
----------

normal form:
A function $\hbox{NF} : R^r \times \{G \mid G\ \hbox{ a standard
     basis}\} \to R^r, (p,G) \mapsto \hbox{NF}(p|G)$, is called a {\bf normal
     form} if for any $p \in R^r$ and any standard basis $G$ the following
     holds: if $\hbox{NF}(p|G) \not= 0$ then $L(g)$ does not divide
     $L(\hbox{NF}(p|G))$ for all $g \in G$.

     \noindent
     $\hbox{NF}(p|G)$ is called a {\bf normal form of} $p$ {\bf with
     respect to} $G$ (note that such a function is not unique).
     A function NF : R^r x {G | G a standard basis} -> R^r, (p,G) ->
     NF(p|G), is called a *normal form* if for any p in R^r and any
     standard basis G the following holds: if NF(p|G) <> 0 then L(g)
     does not divide L(NF(p|G)) for all g in G.
     NF(p|G) is called a *normal form* of p with respect to G (note that
     such a function is not unique).

ideal membership:
For a standard basis $G$ of $I$ the following holds: 
     $f \in I$ if and only if $\hbox{NF}(f,G) = 0$.
     For a standart basis G of I the following holds: f in I if and only
     if NF(f,G) = 0.

Hilbert function:
Let \hbox{$I \subseteq K[\underline{x}]^r$} be a homogeneous module, then the Hilbert function
     $H_I$ of $I$ (see below)
     and the Hilbert function $H_{L(I)}$ of the leading module $L(I)$
     coincide, i.e.,
     $H_I=H_{L(I)}$.
     Let I in K[x]^r be a homogeneous ideal, then the Hilbert function
     H_I of I and the Hilbert function H_L(I) of the leading ideal L(I)
     coincide.


File: index.htm,  Node: Hilbert function,  Next: Syzygies and resolutions,  Prev: Standard bases,  Up: Mathematical background

C.2 Hilbert function
====================

Let M $=\bigoplus_i M_i$ be a graded module over $K[x_1,..,x_n]$ with 
respect to weights $(w_1,..w_n)$.
The {\bf Hilbert function} of $M$, $H_M$, is defined (on the integers) by
$$H_M(k) :=dim_K M_k.$$
The {\bf Hilbert-Poincare series}  of $M$ is the power series
$$\hbox{HP}_M(t) :=\sum_{i=-\infty}^\infty
H_M(i)t^i=\sum_{i=-\infty}^\infty dim_K M_i \cdot t^i.$$
It turns out that $\hbox{HP}_M(t)$ can be written in two useful ways
for weights $(1,..,1)$:
$$\hbox{HP}_M(t)={Q(t)\over (1-t)^n}={P(t)\over (1-t)^{dim(M)}}$$
where $Q(t)$ and $P(t)$ are polynomials in ${\bf Z}[t]$.
$Q(t)$ is called the {\bf first Hilbert series},
and $P(t)$ the {\bf second Hilbert series}.
If \hbox{$P(t)=\sum_{k=0}^N a_k t^k$}, and \hbox{$d = dim(M)$},
then \hbox{$H_M(s)=\sum_{k=0}^N a_k$ ${d+s-k-1}\choose{d-1}$}
(the {\bf Hilbert polynomial}) for $s \ge N$.
Let M =(+) M_i be a graded module over K[x_1,...,x_n] with respect to
weights (w_1,..w_n).  The Hilbert function of M H_M is defined by
     H_M(k)=dim_K M_k.
The Hilbert-Poincare series  of M is the power series
     HP_M(t)=sum_i dim_K (M_i)*t^i.
It turns out that HP_M(t) can be written in two useful ways for weights
$(1,..,1)$:
     H_M(t)=Q(t)/(1-t)^n=P(t)/(1-t)^dim(M).
where Q(t) and P(t) are polynomials in Z[t].  Q(t) is called the first
Hilbert series, and P(t) the second Hilbert series.  If P(t)=sum_(k=0)^N
a_k t^k, and d=dim(M), then
     H_M(s)=sum_(k=0)^N a_k binomial(d+s-k-1,d-1) (the Hilbert polynomial)
for s >= N.
Generalizing these to quasihomogeneous modules we get
$$\hbox{HP}_M(t)={Q(t)\over {\Pi_{i=1}^n(1-t^{w_i})}}$$
where $Q(t)$ is a polynomial in ${\bf Z}[t]$.
$Q(t)$ is called the {\bf first (weighted) Hilbert series} of M.
Generalizing these to quasihomogeneous modules we get
     H_M(t)=Q(t)/Prod((1-t)^(w_i)).
where Q(t) is a polynomial in Z[t].  Q(t) is called the first (weighted)
Hilbert series of M.


File: index.htm,  Node: Syzygies and resolutions,  Next: Characteristic sets,  Prev: Hilbert function,  Up: Mathematical background

C.3 Syzygies and resolutions
============================

Syzygies
--------

Let $R$ be a quotient of $\hbox{Loc}_< K[\underline{x}]$ and let \hbox{$I=(g_1, ..., g_s)$} be a submodule of $R^r$.
Then the {\bf module of syzygies} (or {\bf 1st syzygy module}, {\bf module of relations}) of $I$, syz($I$), is defined to be the kernel of the map \hbox{$R^s \rightarrow R^r,\; \sum_{i=1}^s w_ie_i \mapsto \sum_{i=1}^s w_ig_i$.}
Let R be a quotient of Loc K[x] and let I=(g_1, ..., g_s) be a submodule
of R^r.  Then the *module of syzygies* (or *1st syzygy module*, *module
of relations*) of I, syz(I), is defined to be the kernel of the map
     R^s -> R^r,
     w_1*e_1 + ... + w_s*e_s -> w_1*g_1 + ... + w_s*g_s.

The *k-th syzygy module* is defined inductively to be the module of
syzygies of the $(k-1)$-st 
(k-1)-st  syzygy module.

Note, that the syzygy modules of $I$ depend on a choice of generators $g_1, ..., g_s$.
But one can show that they depend on $I$ uniquely up to direct summands.
Note, that the syzygy modules of I depend on a choice of generators g_1,
..., g_s.  But one can show that they depend on I uniquely up to direct
summands.

`*Example:*'

            ring R= 0,(u,v,x,y,z),dp;
            ideal i=ux, vx, uy, vy;
            print(syz(i));
          ==> -y,0, -v,0, 
          ==> 0, -y,u, 0, 
          ==> x, 0, 0, -v,
          ==> 0, x, 0, u  

Free resolutions
----------------

Let $I=(g_1,...,g_s)\subseteq R^r$ and $M= R^r/I$.
A {\bf free resolution of $M$} is a long exact sequence
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M\longrightarrow
0,$$
Let I=(g_1,...,g_s) in R^r and M=R^r/I.  A free resolution of M is a
long exact sequence
     ...-> F2 -A2-> F1 -A1-> F0->M->0,

where the columns of the matrix $A_1$
A_1 generate I $I$
. Note, that resolutions need not to be finite (i.e., of finite length).
The Hilbert Syzygy Theorem states, that for $R=\hbox{Loc}_< K[\underline{x}]$
R=Loc K[x] there exists a ("minimal") resolution of length not exceeding
the number of variables.

`*Example:*'

            ring R= 0,(u,v,x,y,z),dp;
            ideal I = ux, vx, uy, vy;
            resolution resI = mres(I,0); resI;
          ==>  1      4      4      1      
          ==> R <--  R <--  R <--  R
          ==> 
          ==> 0      1      2      3      
          ==> 
            // The matrix A_1 is given by
            print(matrix(resI[1]));
          ==> vy,uy,vx,ux
            // We see that the columns of A_1 generate I.
            // The matrix A_2 is given by
            print(matrix(resI[3]));
          ==> u, 
          ==> -v,
          ==> -x,
          ==> y  

Betti numbers and regularity
----------------------------

Let $R$ be a graded ring (e.g., $R = \hbox{Loc}_< K[\underline{x}]$) and
let $I \subset R^r$ be a graded submodule. Let
$$
  R^r = \bigoplus_a R\cdot e_{a,0} \buildrel A_1 \over \longleftarrow
        \bigoplus_a R\cdot e_{a,1} \longleftarrow \ldots \longleftarrow
        \bigoplus_a R\cdot e_{a,n} \longleftarrow 0
$$
be a minimal free resolution of $R^n/I$ considered with homogeneous maps
of degree 0. Then the {\bf graded Betti number} $b_{i,j}$ of $R^r/I$ is
the minimal number of generators $e_{a,j}$ in degree $i+j$ of the $j$-th
syzygy module of $R^r/I$ (i.e., the $(j-1)$-st syzygy module of
$I$). Note, that by definition the $0$-th syzygy module of $R^r/I$ is $R^r$
and the 1st syzygy module of $R^r/I$ is $I$.
Let R be a graded ring (e.g., R = K[x]) and let I in R^r be a graded
submodule. Let
     R^r = (+) K[x]e(a,0) <-- (+) K[x]e(a,1)
                 <-- ... <-- (+) K[x]e(a,n) <-- 0
be a minimal free resolution of R^n/I considered with homogeneous maps
of degree 0. Then the *graded Betti number* b_i,j of R^r/I is the
minimal number of generators e_a,j in degree i+j of the j-th syzygy
module of R^r/I (i.e., the (j-1)-st syzygy module of I). Note, that by
definition the 0th syzygy module of R^r/I is R^r and the 1st syzygy
module of R^r/I is I.

The *regularity* of I $I$
 is the smallest integer s $s$

such that $$
    \hbox{deg}(e_{a,j}) \le s+j-1 \quad \hbox{for all $j$.}
$$
     deg(e(a,j)) <= s+j-1    for all j.

`*Example:*'

            ring R= 0,(u,v,x,y,z),dp;
            ideal I = ux, vx, uy, vy;
            resolution resI = mres(I,0); resI;
          ==>  1      4      4      1      
          ==> R <--  R <--  R <--  R
          ==> 
          ==> 0      1      2      3      
          ==> 
            // the betti number:
            print(betti(resI), "betti");
          ==>            0     1     2     3
          ==> ------------------------------
          ==>     0:     1     -     -     -
          ==>     1:     -     4     4     1
          ==> ------------------------------
          ==> total:     1     4     4     1
            // the regularity:
            regularity(resI);
          ==> 2


File: index.htm,  Node: Characteristic sets,  Next: Gauss-Manin connection,  Prev: Syzygies and resolutions,  Up: Mathematical background

C.4 Characteristic sets
=======================

Let $<$ be the lexicographical ordering on $R=K[x_1,...,x_n]$ with $x_1
< ... < x_n$.
For $f \in R$ let lvar($f$) (the leading variable of $f$) be the largest
variable in $f$,
i.e., if $f=a_s(x_1,...,x_{k-1})x_k^s+...+a_0(x_1,...,x_{k-1})$ for some
$k \leq n$ then lvar$(f)=x_k$.

Moreover, let
\hbox{ini}$(f):=a_s(x_1,...,x_{k-1})$. The pseudo remainder
$r=\hbox{prem}(g,f)$ of $g$ with respect to $f$ is
defined by the equality $\hbox{ini}(f)^a\cdot g = qf+r$ with
$\hbox{deg}_{lvar(f)}(r)<\hbox{deg}_{lvar(f)}(f)$ and $a$
minimal.

A set $T=\{f_1,...,f_r\} \subset R$ is called triangular if
$\hbox{lvar}(f_1)<...<\hbox{lvar}(f_r)$. Moreover, let $ U \subset T $,
then $(T,U)$ is called a triangular system, if $T$ is a triangular set
such that $\hbox{ini}(T)$ does not vanish on $V(T) \setminus V(U)
(=:V(T\setminus U))$.

$T$ is called irreducible if for every $i$ there are no
$d_i$,$f_i'$,$f_i''$ such that
$$   \hbox{lvar}(d_i)<\hbox{lvar}(f_i) =
\hbox{lvar}(f_i')=\hbox{lvar}(f_i''),$$
$$   0 \not\in \hbox{prem}(\{ d_i, \hbox{ini}(f_i'),
\hbox{ini}(f_i'')\},\{ f_1,...,f_{i-1}\}),$$
$$\hbox{prem}(d_if_i-f_i'f_i'',\{f_1,...,f_{i-1}\})=0.$$
Furthermore, $(T,U)$ is called irreducible if $T$ is irreducible.

The main result on triangular sets is the following:
let $G=\{g_1,...,g_s\} \subset R$ then there are irreducible triangular sets $T_1,...,T_l$
such that $V(G)=\bigcup_{i=1}^{l}(V(T_i\setminus I_i))$
where $I_i=\{\hbox{ini}(f) \mid f \in T_i \}$. Such a set
$\{T_1,...,T_l\}$ is called an {\bf irreducible characteristic series} of
the ideal $(G)$.
Let > be the lexicographical ordering on R=K[x_1,...,x_n] with
x_1<...<x_n .  For f in R let lvar(f) (the leading variable of f) be the
largest variable in lead(f) (the leading term of f with respect to >),
i.e., if f=a_s(x_1,...,x_(k-1))x_k^s+...+a_0(x_1,...,x_(k-1)) for some
k<=n then lvar(f)=x_k.

Moreover, let ini(f):=a_s(x_1,...,x_(k-1)). The pseudo remainder
r=prem(g,f) of g with respect to f is defined by ini(f)^a*g=q*f+r with
the property deg_(lvar(f))(r)<deg_(lvar(f))(f), `a' minimal.

A set T={f_1,...,f_r} in R is called triangular if
lvar(f_1)<...<lvar(f_r).

(T,U) is called a triangular system, if U is a subset of T and if T is a
triangular set such that ini(T) does not vanish on the zero-set of T \
zero-set of U ( =:Zero(T\U)).

T is called irreducible if for every i there are no d_i,f_i',f_i" with
the property:
     lvar(d_i)<lvar(f_i)
     lvar(f_i')=lvar(f_i")=lvar(f_i)
     0 not in prem({ d_i, ini(f_i'), ini(f_i")},{ f_1,...,f_(i-1)})
such that prem(d_i*f_i-f_i'*f_i",{f_1,...,f_(i-1)})=0.

(T,U) is called irreducible if T is irreducible.

The main result on triangular sets is the following: let G={g_1,...,g_s}
then there are irreducible triangular sets T_1,...,T_l such that
Zero(G)=Union(i=1,...,l: Zero(T_i\I_i)) where I_i={ini(f), f in T_i }.
Such a set {T_1,...,T_l} is called an *irreducibel characteristic
series* of the ideal (G).

`*Example:*'

            ring R= 0,(x,y,z,u),dp;
            ideal i=-3zu+y2-2x+2,
                    -3x2u-4yz-6xz+2y2+3xy,
                    -3z2u-xu+y2z+y;
            print(char_series(i));
          ==> _[1,1],3x2z-y2+2yz,3x2u-3xy-2y2+2yu,
          ==> x,     -y+2z,      -2y2+3yu-4       


File: index.htm,  Node: Gauss-Manin connection,  Next: Toric ideals and integer programming,  Prev: Characteristic sets,  Up: Mathematical background

C.5 Gauss-Manin connection
==========================

Let $f\colon(C^{n+1},0)\rightarrow(C,0)$ be a complex isolated hypersurface singularity given by a polynomial with algebraic coefficients which we also denote by $f$.
Let $O=C[x_0,\ldots,x_n]_{(x_0,\ldots,x_n)}$ be the local ring at the origin and $J_f$ the Jacobian ideal of $f$.

A {\bf Milnor representative} of $f$ defines a differentiable fibre bundle over the punctured disc with fibres of homotopy type of $\mu$ $n$-spheres.
The $n$-th cohomology bundle is a flat vector bundle of dimension $n$ and carries a natural flat connection with covariant derivative $\partial_t$.
The {\bf monodromy operator} is the action of a positively oriented generator of the fundamental group of the puctured disc on the Milnor fibre.
Sections in the cohomology bundle of {\bf moderate growth} at $0$ form a regular $D=C\{t\}[\partial_t]$-module $G$, the {\bf Gauss-Manin connection}.

By integrating along flat multivalued families of cycles, one can consider fibrewise global holomorphic differential forms as elements of $G$.
This factors through an inclusion of the {\bf Brieskorn lattice} $H'':=\Omega^{n+1}_{C^{n+1},0}/df\wedge d\Omega^{n-1}_{C^{n+1},0}$ in $G$.

The $D$-module structure defines the {\bf V-filtration} $V$ on $G$ by $V^\alpha:=\sum_{\beta\ge\alpha}C\{t\}ker(t\partial_t-\beta)^{n+1}$.
The Brieskorn lattice defines the {\bf Hodge filtration} $F$ on $G$ by $F_k=\partial_t^kH''$ which comes from the {\bf mixed Hodge structure} on the Milnor fibre.
Note that $F_{-1}=H'$.

The induced V-filtration on the Brieskorn lattice determines the {\bf singularity spectrum} $Sp$ by $Sp(\alpha):=\dim_CGr_V^\alpha Gr^F_0G$.
The spectrum consists of $\mu$ rational numbers $\alpha_1,\dots,\alpha_\mu$ such that $e^{2\pi i\alpha_1},\dots,e^{2\pi i\alpha_\mu}$ are the eigenvalues of the monodromy.
These {\bf spectral numbers} lie in the open interval $(-1,n)$, symmetric about the midpoint $(n-1)/2$.

The spectrum is constant under $\mu$-constant deformations and has the following semicontinuity property:
The number of spectral numbers in an interval $(a,a+1]$ of all singularities of a small deformation of $f$ is greater or equal to that of f in this interval.
For semiquasihomogeneous singularities, this also holds for intervals of the form $(a,a+1)$.

Two given isolated singularities $f$ and $g$ determine two spectra and from these spectra we get an integer.
This integer is the maximal positive integer $k$ such that the semicontinuity holds for the spectrum of $f$ and $k$ times the spectrum of $g$.
These numbers give bounds for the maximal number of isolated singularities of a specific type on a hypersurface $X\subset{P}^n$ of degree $d$: 
such a hypersurface has a smooth hyperplane section, and the complement is a small deformation of a cone over this hyperplane section.
The cone itself being a $\mu$-constant deformation of $x_0^d+\dots+x_n^d=0$, the singularities are bounded by the spectrum of $x_0^d+\dots+x_n^d$.

Using the library {\tt gaussman.lib} one can compute the {\bf monodromy}, the V-filtration on $H''/H'$, and the spectrum.

Let f:(C^(n+1),0)-->(C,0) be a complex isolated hypersurface singularity
given by a polynomial with algebraic coefficients which we also denote
by f.  Let O=C[x_0,...,x_n]_(x_0,...,x_n) be the local ring at the
origin and J_f the Jacobian ideal of f.

A *Milnor representative* of f defines a differentiable fibre bundle
over the punctured disc with fibres of homotopy type of mu n-spheres.
The n-th cohomology bundle is a flat vector bundle of dimension n and
carries a natural flat connection with covariant derivative d_t.  The
*monodromy operator* is the action of a positively oriented generator of
the fundamental group of the puctured disc on the Milnor fibre.
Sections in the cohomology bundle of *moderate growth* at 0 form a
regular D=C{t}[d_t]-module G, the *Gauss-Manin connection*.

By integrating along flat multivalued families of cycles, one can
consider fibrewise global holomorphic differential forms as elements of
G.  This factors through an inclusion of the *Brieskorn lattice*
H":=Omega^(n+1)_(C^(n+1),0)/df*dOmega^(n-1)_(C^(n+1),0) in G.

The D-module structure defines the *V-filtration* V on G by
V^a:=sum_(b>=a)C{t}ker(t*d_t-b)^(n+1).  The Brieskorn lattice defines
the *Hodge filtration* F on G by F_k=d_t^kH" which comes from the *mixed
Hodge structure* on the Milnor fibre.  Note that F_(-1)=H'.

The induced V-filtration on the Brieskorn lattice determines the
*singularity spectrum* Sp by Sp(a):=dim_CGr_V^a Gr^F_0G.  The spectrum
consists of mu rational numbers a_1,...,a_mu such that
exp(2*pi*i*a_1),...,exp(2*pi*i*a_mu) are the eigenvalues of the
monodromy.  These *spectral numbers* lie in the open interval (-1,n),
symmetric about the midpoint (n-1)/2.

The spectrum is constant under mu-constant deformations and has the
following semicontinuity property: The number of spectral numbers in an
interval (a,a+1] of all singularities of a small deformation of f is
greater or equal to that of f in this interval.  For
semiquasihomogeneous singularities, this also holds for intervals of the
form (a,a+1).

Two given isolated singularities f and g determine two spectra and from
these spectra we get an integer.  This integer is the maximal positive
integer k such that the semicontinuity holds for the spectrum of f and k
times the spectrum of g.  These numbers give bounds for the maximal
number of isolated singularties of a specific type on a hypersurface X
in P^n of degree d: such a hypersurface has a smooth hyperplane section,
and the complement is a small deformation of a cone over this hyperplane
section.  The cone itself being a mu-constant deformation of
x_0^d+...+x_n^d=0, the singularities are bounded by the spectrum of
x_0^d+...+x_n^d.

Using the library `gaussman.lib' one can compute the *monodromy*, the
V-filtration on H"/H', and the spectrum.

Let us consider as an example f=x^5+x^2y^2+y^5 $f=x^5+x^2y^2+y^5$
.  First, we compute a matrix M $M$
 such that $\exp(2\pi iM)$
exp(-2*pi*i*M) is a monodromy matrix of f $f$
 and the Jordan normal form of M $M$
:
       LIB "gaussman.lib";
       ring R=0,(x,y),ds;
       poly f=x5+x2y2+y5;
       list l=monodromy(f);
       matrix M=jordanmatrix(l[1],l[2],l[3]);
       print(M);
     ==> 1/2,0,  0,   0,   0,   0,   0,0,    0,    0,    0,   
     ==> 1,  1/2,0,   0,   0,   0,   0,0,    0,    0,    0,   
     ==> 0,  0,  7/10,0,   0,   0,   0,0,    0,    0,    0,   
     ==> 0,  0,  0,   7/10,0,   0,   0,0,    0,    0,    0,   
     ==> 0,  0,  0,   0,   9/10,0,   0,0,    0,    0,    0,   
     ==> 0,  0,  0,   0,   0,   9/10,0,0,    0,    0,    0,   
     ==> 0,  0,  0,   0,   0,   0,   1,0,    0,    0,    0,   
     ==> 0,  0,  0,   0,   0,   0,   0,11/10,0,    0,    0,   
     ==> 0,  0,  0,   0,   0,   0,   0,0,    11/10,0,    0,   
     ==> 0,  0,  0,   0,   0,   0,   0,0,    0,    13/10,0,   
     ==> 0,  0,  0,   0,   0,   0,   0,0,    0,    0,    13/10

Now, we compute the V-filtration on H"/H' $H''/H'$
 and the spectrum:
       LIB "gaussman.lib";
       ring R=0,(x,y),ds;
       poly f=x5+x2y2+y5;
       list l=vfilt(f);
       print(l[1]);
     ==> -1/2,
     ==> -3/10,
     ==> -1/10,
     ==> 0,
     ==> 1/10,
     ==> 3/10,
     ==> 1/2
       print(l[2]);
     ==> 1,2,2,1,2,2,1
       print(l[3]);
     ==> [1]:
     ==>    _[1]=gen(11)
     ==> [2]:
     ==>    _[1]=gen(10)
     ==>    _[2]=gen(6)
     ==> [3]:
     ==>    _[1]=gen(9)
     ==>    _[2]=gen(4)
     ==> [4]:
     ==>    _[1]=gen(5)
     ==> [5]:
     ==>    _[1]=gen(3)
     ==>    _[2]=gen(8)
     ==> [6]:
     ==>    _[1]=gen(2)
     ==>    _[2]=gen(7)
     ==> [7]:
     ==>    _[1]=gen(1)
       print(l[4]);
     ==> y5,
     ==> y4,
     ==> y3,
     ==> y2,
     ==> xy,
     ==> y,
     ==> x4,
     ==> x3,
     ==> x2,
     ==> x,
     ==> 1
Here `l[1]' contains the spectral numbers, `l[2]' the corresponding
multiplicities, `l[3]' a C $C$
-basis of the V-filtration on H"/H' $H''/H'$
 in terms of the monomial basis of $O/J_f\cong H''/H'$
O/J_f~=H"/H' in `l[4]'.

If the principal part of $f$ is $C$-nondegenerate, one can compute the spectrum using the library {\tt spectrum.lib}.
In this case, the V-filtration on $H''$ coincides with the Newton-filtration on $H''$ which allows to compute the spectrum more efficiently.

If the principal part of f is C-nondegenerate, one can compute the
spectrum using the library `spectrum.lib'.  In this case, the
V-filtration on H" coincides with the Newton-filtration on H" which
allows to compute the spectrum more efficiently.

Let us calculate one specific example, the maximal number of triple
points of type $\tilde{E}_6$ on a surface $X\subset{P}^3$
E~_6 on a surface X in P^3 of degree seven.  This calculation can be
done over the rationals.  So choose a local ordering on Q[x,y,z] $Q[x,y,z]$
. Here we take the negative degree lexicographical ordering which is
denoted `ds' in SINGULAR:

     ring r=0,(x,y,z),ds;
     LIB "spectrum.lib";
     poly f=x^7+y^7+z^7;
     list s1=spectrumnd( f );
     s1;
     ==> [1]:
     ==>    _[1]=-4/7
     ==>    _[2]=-3/7
     ==>    _[3]=-2/7
     ==>    _[4]=-1/7
     ==>    _[5]=0
     ==>    _[6]=1/7
     ==>    _[7]=2/7
     ==>    _[8]=3/7
     ==>    _[9]=4/7
     ==>    _[10]=5/7
     ==>    _[11]=6/7
     ==>    _[12]=1
     ==>    _[13]=8/7
     ==>    _[14]=9/7
     ==>    _[15]=10/7
     ==>    _[16]=11/7
     ==> [2]:
     ==>    1,3,6,10,15,21,25,27,27,25,21,15,10,6,3,1

The command `spectrumnd(f)' computes the spectrum of f $f$
 and returns a list with six entries: The Milnor number $\mu(f)$, the geometric genus $p_g(f)$
mu(f), the geometric genus p_g(f) and the number of different spectrum
numbers.  The other three entries are of type `intvec'.  They contain
the numerators, denominators and multiplicities of the spectrum numbers.
So $x^7+y^7+z^7=0$
x^7+y^7+z^7=0 has Milnor number 216 and geometrical genus 35. Its
spectrum consists of the 16 different rationals
${3 \over 7}, {4 \over 7}, {5 \over 7}, {6 \over 7}, {1 \over 1},
{8 \over 7}, {9 \over 7}, {10 \over 7}, {11 \over 7}, {12 \over 7},
{13 \over 7}, {2 \over 1}, {15 \over 7}, {16 \over 7}, {17 \over 7},
{18 \over 7}$
3/7, 4/7, 5/7, 6/7, 1, 8/7, 9/7, 10/7, 11/7, 12/7, 13/7, 2, 15/7, 16/7,
17/7, 18/7
appearing with multiplicities
1,3,6,10,15,21,25,27,27,25,21,15,10,6,3,1.

The singularities of type $\tilde{E}_6$ form a
$\mu$-constant one parameter family given by
$x^3+y^3+z^3+\lambda xyz=0,\quad \lambda^3\neq-27$.
The singularities of type E~_6 form a mu-constant one parameter family
given by x^3+y^3+z^3+lambda xyz=0, lambda^3 <> -27.  Therefore they have
all the same spectrum, which we compute for $x^3+y^3+z^3$.
x^3+y^3+z^3.

     poly g=x^3+y^3+z^3;
     list s2=spectrumnd(g);
     s2;
     ==> [1]:
     ==>    8
     ==> [2]:
     ==>    1
     ==> [3]:
     ==>    4
     ==> [4]:
     ==>    1,4,5,2
     ==> [5]:
     ==>    1,3,3,1
     ==> [6]:
     ==>    1,3,3,1
Evaluating semicontinuity is very easy:
     semicont(s1,s2);
     ==> 18

This tells us that there are at most 18 singularities of type $\tilde{E}_6$ on a septic in $P^3$. But $x^7+y^7+z^7$
E~_6 on a septic in P^3. But x^7+y^7+z^7 is semiquasihomogeneous (sqh),
so we can also apply the stronger form of semicontinuity:

     semicontsqh(s1,s2);
     ==> 17

So in fact a septic has at most 17 triple points of type $\tilde{E}_6$.
E~_6.

Note that `spectrumnd(f)' works only if f $f$
 has nondegenerate principal part. In fact `spectrumnd' will detect a
degenerate principal part in many cases and print out an error message.
However if it is known in advance that f $f$
 has nondegenerate principal part, then the spectrum may be computed
much faster using `spectrumnd(f,1)'.


File: index.htm,  Node: Toric ideals and integer programming,  Next: References,  Prev: Gauss-Manin connection,  Up: Mathematical background

C.6 Toric ideals and integer programming
========================================

* Menu:

* Toric ideals::                Definition and computation.
* Integer programming::         An algorithm using toric ideals.
* Relevant References::


File: index.htm,  Node: Toric ideals,  Next: Integer programming,  Up: Toric ideals and integer programming

C.6.1 Toric ideals
------------------

Let $A$ denote an $m\times n$ matrix with integral coefficients. For $u
\in Z\!\!\! Z^n$, we define $u^+,u^-$ to be the uniquely determined
vectors with nonnegative coefficients and disjoint support (i.e.,
$u_i^+=0$ or $u_i^-=0$ for each component $i$) such that
$u=u^+-u^-$. For $u\geq 0$ component-wise, let $x^u$ denote the monomial
$x_1^{u_1}\cdot\ldots\cdot x_n^{u_n}\in K[x_1,\ldots,x_n]$.

The ideal
$$ I_A:=<x^{u^+}-x^{u^-} | u\in\ker(A)\cap Z\!\!\! Z^n>\ \subset
K[x_1,\ldots,x_n] $$
is called a \bf toric ideal. \rm

The first problem in computing toric ideals is to find a finite
generating set: Let $v_1,\ldots,v_r$ be a lattice basis of $\ker(A)\cap
Z\!\!\! Z^n$ (i.e, a basis of the $Z\!\!\! Z$-module). Then
$$ I_A:=I:(x_1\cdot\ldots\cdot x_n)^\infty $$
where
$$ I=<x^{v_i^+}-x^{v_i^-}|i=1,\ldots,r> $$

Let A denote an mxn matrix with integral coefficients. For u in Z^n, we
define u+,u- to be the uniquely determined vectors with nonnegative
coefficients and disjoint support (i.e., u+[i]=0 or u-[i]=0 for each
component i) such that u = u+ - u-.  For u>=0 component-wise, let x^u
denote the monomial x(1)^u[1] *...* x(n)^u[n] in K[x(1),...,x(n)].

The ideal in K[x(1),...,x(n)]
     I(A):= < x^u+ - x^u- | u in ker(A), u in Z^n >
is called a *toric ideal*.

The first problem in computing toric ideals is to find a finite
generating set: Let v(1),...,v(r) be a lattice basis of ker(A) as a
subset of Z^n (i.e., a basis of the Z-module). Then
     I(A):= sat( I, x[1] *...* x[n])
where
     I= < x^v(i)+ - x^v(i)- | i=1,...,r >.

The required lattice basis can be computed using the LLL-algorithm
(*note [Coh93]::). For the computation of the saturation, there are
various possibilities described in the section Algorithms.
menu entry Algorithms.

* Menu:

* Algorithms::             Various algorithms for computing toric ideals.
* Buchberger algorithm::   Specializing it for toric ideals.


File: index.htm,  Node: Algorithms,  Next: Buchberger algorithm,  Up: Toric ideals

C.6.2 Algorithms
----------------

The following algorithms are implemented in *note toric_lib::.

* Menu:

* Conti and Traverso::
* Pottier::
* Hosten and Sturmfels::
* Di Biase and Urbanke::
* Bigatti and La Scala and Robbiano::


File: index.htm,  Node: Conti and Traverso,  Next: Pottier,  Up: Algorithms

C.6.2.1 The algorithm of Conti and Traverso
...........................................

The algorithm of Conti and Traverso (*note [CoTr91]::) computes $I_A$ via the
extended matrix $B=(I_m|A)$,
where $I_m$ is the $m\times m$ unity matrix. A lattice basis of $B$ is
given by the set of vectors $(a^j,-e_j)\in Z\!\!\! Z^{m+n}$, where $a^j$
is the $j$-th row of $A$ and $e_j$ the $j$-th coordinate vector. We
look at the ideal in $K[y_1,\ldots,y_m,x_1,\ldots,x_n]$ corresponding to
these vectors, namely
$$ I_1=<y^{a_j^+}- x_j y^{a_j^-} | j=1,\ldots, n>.$$
We introduce a further variable $t$ and adjoin the binomial $t\cdot
y_1\cdot\ldots\cdot y_m -1$ to the generating set of $I_1$, obtaining
an ideal $I_2$ in the polynomial ring $K[t,
y_1,\ldots,y_m,x_1,\ldots,x_n]$. $I_2$ is saturated w.r.t. all
variables because all variables are invertible modulo $I_2$. Now $I_A$
can be computed from $I_2$ by eliminating the variables
$t,y_1,\ldots,y_m$.
computes I(A) via the extended matrix B= ( I | A ), where I is the mxm
unity matrix. A lattice basis of B is given by the set of vectors
(a^j,-e_j) in Z^(m+n), where a^j is the j-th row of A and e_j the j-th
coordinate vector. We look at the ideal in
K[y(1),...,y(m),x(1),...,x(n)] corresponding to these vectors, namely
     I1= < y^(a_j)+ - x(j) * y^(a_j)- | j=1,...,n >.
We introduce a further variable t and adjoin the binomial t * y(1) *...*
y(m) -1 to the generating set of I1, obtaining an ideal I2 in the
polynomial ring K[t,y(1),...,y(m),x(1),...,x(n)]. I2 is saturated w.r.t.
all variables because all variables are invertible modulo I2. Now I(A)
can be computed from I2 by eliminating the variables t,y(1),...,y(m).

Because of the big number of auxiliary variables needed to compute a
toric ideal, this algorithm is rather slow in practice. However, it has
a special importance in the application to integer programming (*note
Integer programming::).


File: index.htm,  Node: Pottier,  Next: Hosten and Sturmfels,  Prev: Conti and Traverso,  Up: Algorithms

C.6.2.2 The algorithm of Pottier
................................

The algorithm of Pottier (*note [Pot94]::) starts by computing a lattice
basis $v_1,\ldots,v_r$ for the integer kernel of $A$ using the
LLL-algorithm. The ideal corresponding to the lattice basis vectors
$$ I_1=<x^{v_i^+}-x^{v_i^-}|i=1,\ldots,r> $$
is saturated -- as in the algorithm of Conti and Traverso -- by
inversion of all variables: One adds an auxiliary variable $t$ and the
generator $t\cdot x_1\cdot\ldots\cdot x_n -1$ to obtain an ideal $I_2$
in $K[t,x_1,\ldots,x_n]$ from which one computes $I_A$ by elimination of
$t$.
basis v(1),...,v(r) for the integer kernel of A using the LLL-algorithm.
The ideal corresponding to the lattice basis vectors
     I1= < x^v(i)+ - x^v(i)- | i=1,...,r >
is saturated - as in the algorithm of Conti and Traverso - by inversion
of all variables: One adds an auxiliary variable t and the generator t *
x(1) *...* x(n) -1 to obtain an ideal I2 in K[t,x(1),...,x(n)] from
which one computes I(A) by elimination of t.


File: index.htm,  Node: Hosten and Sturmfels,  Next: Di Biase and Urbanke,  Prev: Pottier,  Up: Algorithms

C.6.2.3 The algorithm of Hosten and Sturmfels
.............................................

The algorithm of Hosten and Sturmfels (*note [HoSt95]::) allows to compute $I_A$ without any auxiliary variables, provided that $A$ contains a vector $w$
with positive coefficients in its row space. This is a real restriction,
i.e., the algorithm will not necessarily work in the general case.

A lattice basis $v_1,\ldots,v_r$ is again computed via the
LLL-algorithm. The saturation step is performed in the following way:
First note that $w$ induces a positive grading w.r.t. which the ideal
$$ I=<x^{v_i^+}-x^{v_i^-}|i=1,\ldots,r> $$
corresponding to our lattice basis is homogeneous. We use the following
lemma:

Let $I$ be a homogeneous ideal w.r.t. the weighted reverse
lexicographical ordering with weight vector $w$ and variable order $x_1
> x_2 > \ldots > x_n$. Let $G$ denote a Groebner basis of $I$ w.r.t. to
this ordering.  Then a Groebner basis of $(I:x_n^\infty)$ is obtained by
dividing each element of $G$ by the highest possible power of $x_n$.

From this fact, we can successively compute
$$ I_A= I:(x_1\cdot\ldots\cdot x_n)^\infty
=(((I:x_1^\infty):x_2^\infty):\ldots :x_n^\infty); $$
in the $i$-th step we take $x_i$ as the cheapest variable and apply the
lemma with $x_i$ instead of $x_n$.

This procedure involves $n$ Groebner basis computations. Actually, this
number can be reduced to at most $n/2$
compute I(A) without any auxiliary variables, provided that A contains a
vector w with positive coefficients in its row space. This is a real
restriction, i.e., the algorithm will not necessarily work in the
general case.

A lattice basis v(1),...,v(r) is again computed via the LLL-algorithm.
The saturation step is performed in the following way: First note that w
induces a positive grading w.r.t. which the ideal
     I= < x^v(i)+ - x^v(i)- | i=1,...,r >
corresponding to our lattice basis is homogeneous. We use the following
lemma:

Let I be a homogeneous ideal w.r.t. the weighted reverse lexicographical
ordering with weight vector w and variable order x(1) > x(2) > ... >
x(n). Let G denote a Groebner basis of I w.r.t. to this ordering.  Then
a Groebner basis of sat(I,x(n)) is obtained by dividing each element of
G by the highest possible power of x(n).

From this fact, we can successively compute
     I(A)= sat(I, x(1) *...* x(n))
         = sat(...(sat(sat(I,x(1)), x(2)), ..., x(n)));
in the i-th step we take x(i) as the cheapest variable and apply the
lemma with x(i) instead of x(n).

This procedure involves n Groebner basis computations. Actually, this
number can be reduced to at most n/2 (*note [HoSh98]::), and the single
computations - except from the first one - show to be easy and fast in
practice.


File: index.htm,  Node: Di Biase and Urbanke,  Next: Bigatti and La Scala and Robbiano,  Prev: Hosten and Sturmfels,  Up: Algorithms

C.6.2.4 The algorithm of Di Biase and Urbanke
.............................................

Like the algorithm of Hosten and Sturmfels, the algorithm of Di Biase
and Urbanke (*note [DBUr95]::) performs up to $n/2$ Groebner basis
computations. It needs no auxiliary variables, but a supplementary
precondition; namely, the existence of a vector without zero components
in the kernel of $A$.

The main idea comes from the following observation:

Let $B$ be an integer matrix, $u_1,\ldots,u_r$ a lattice basis of the
integer kernel of $B$. Assume that all components of $u_1$ are
positive. Then
$$ I_B=<x^{u_i^+}-x^{u_i^-}|i=1,\ldots,r>, $$
i.e., the ideal on the right is already saturated w.r.t. all variables.

The algorithm starts by finding a lattice basis $v_1,\ldots,v_r$ of the
kernel of $A$ such that $v_1$ has no zero component. Let
$\{i_1,\ldots,i_l\}$ be the set of indices $i$ with
$v_{1,i}<0$. Multiplying the components $i_1,\ldots,i_l$ of
$v_1,\ldots,v_r$ and the columns $i_1,\ldots,i_l$ of $A$ by $-1$ yields
a matrix $B$ and a lattice basis $u_1,\ldots,u_r$ of the kernel of $B$
that fulfill the assumption of the observation above. We are then able
to compute a generating set of $I_A$ by applying the following
``variable flip'' successively to $i=i_1,\ldots,i_l$:

Let $>$ be an elimination ordering for $x_i$. Let $A_i$ be the matrix
obtained by multiplying the $i$-th column of $A$ with $-1$. Let
$$\{x_i^{r_j} x^{a_j} - x^{b_j} | j\in J \}$$
be a Groebner basis of $I_{A_i}$ w.r.t. $>$ (where $x_i$ is neither
involved in $x^{a_j}$ nor in $x^{b_j}$). Then
$$\{x^{a_j} - x_i^{r_j} x^{b_j} | j\in J \}$$
is a generating set for $I_A$.
to n/2 Groebner basis computations. It needs no auxiliary variables, but
a supplementary precondition; namely, the existence of a vector without
zero components in the kernel of A.

The main idea comes from the following observation:

Let B be an integer matrix, u(1),...,u(r) a lattice basis of the integer
kernel of B. Assume that all components of u(1) are positive. Then
     I(B)= < x^u(i)+ - x^u(i)- | i=1,...,r >,
i.e., the ideal on the right is already saturated w.r.t. all variables.

The algorithm starts by finding a lattice basis v(1),...,v(r) of the
kernel of A such that v(1) has no zero component. Let { i1,...,il } be
the set of indices i with v(1)_i <0. Multiplying the components
i1,...,il of v(1),...,v(r) and the columns i1,...,il of A by -1 yields a
matrix B and a lattice basis u(1),...,u(r) of the kernel of B that
fulfill the assumption of the observation above. We are then able to
compute a generating set of I(A) by applying the following "variable
flip" successively to i=i1,...,il:

Let > be an elimination ordering for x(i). Let A(i) be the matrix
obtained by multiplying the i-th column of A with -1. Let
     { x(i)^r(j) * x^a(j) - x^b(j) | j in J }
be a Groebner basis of I(A(i)) w.r.t. > (where x(i) is neither involved
in x^a(j) nor in x^b(j)). Then
     { x^a(j) - x(i)^r(j) * x^b(j) | j in J }
is a generating set for I(A).


File: index.htm,  Node: Bigatti and La Scala and Robbiano,  Prev: Di Biase and Urbanke,  Up: Algorithms

C.6.2.5 The algorithm of Bigatti, La Scala and Robbiano
.......................................................

The algorithm of Bigatti, La Scala and Robbiano (*note [BLR98]::)
combines the ideas of the algorithms of Pottier and of Hosten and
Sturmfels. The computations are performed on a graded ideal with one
auxiliary variable $u$ and one supplementary generator $x_1\cdot\ldots\cdot x_n -
u$ (instead of the generator $t\cdot x_1\cdot\ldots\cdot x_n -1$ in
the algorithm of Pottier). The algorithm uses a quite unusual technique to
get rid of the variable $u$ again.
variable u and one supplementary generator x(1) *...* x(n) -u (instead
of the generator t * x(1) *...* x(n) -1 in the algorithm of Pottier).
The algorithm uses a quite unusual technique to get rid of the variable
u again.

There is another algorithm of the authors which tries to parallelize the
computations (but which is not implemented in this library).


File: index.htm,  Node: Buchberger algorithm,  Prev: Algorithms,  Up: Toric ideals

C.6.3 The Buchberger algorithm for toric ideals
-----------------------------------------------

Toric ideals have a very special structure that allows us to improve the
Buchberger algorithm in many respects: They are prime ideals and
generated by binomials. Pottier used this fact to describe all
operations of the Buchberger algorithm on the ideal generators in terms
of vector additions and subtractions. Some other strategies like
multiple reduction (*note [CoTr91]::) or the use of bit vectors to
represent the support of a monomial (*note [Big97]::) may be applied to
more general ideals, but show to be especially useful in the toric case.


File: index.htm,  Node: Integer programming,  Next: Relevant References,  Prev: Toric ideals,  Up: Toric ideals and integer programming

C.6.4 Integer programming
-------------------------

Let $A$ be an $m\times n$ matrix with integral coefficients, $b\in
Z\!\!\! Z^m$ and $c\in Z\!\!\! Z^n$. The problem
$$ \min\{c^T x | x\in Z\!\!\! Z^n, Ax=b, x\geq 0\hbox{
component-wise}\} $$
is called an instance of the \bf integer programming problem \rm or
\bf IP problem. \rm

The IP problem is very hard; namely, it is NP-complete.

For the following discussion let $c\geq 0$ (component-wise). We
consider $c$ as a weight vector; because of its non-negativity, $c$ can
be refined into a monomial ordering $>_c$. It turns out that we can
solve such an IP instance with the help of toric ideals:

First we assume that an initial solution $v$ (i.e., $v\in Z\!\!\!
Z^n, v\geq 0, Av=b$) is already known. We obtain the optimal solution
$v_0$ (i.e., with $c^T v_0$ minimal) by the following procedure:

Let A be an mxn matrix with integral coefficients, b in Z^m and c in
Z^n. The problem
     min { c*x | x in Z^n, A*x=b, x>=0 component-wise }
is called an instance of the *integer programming problem* or *IP
problem*.

The IP problem is very hard; namely, it is NP-complete.

For the following discussion let c>=0 (component-wise). We consider c as
a weight vector; because of its non-negativity, c can be refined into a
monomial ordering >_c. It turns out that we can solve such an IP
instance with the help of toric ideals:

First we assume that an initial solution v (i.e., v in Z^n, v>=0, A*v=b)
is already known. We obtain the optimal solution v(opt) (i.e., with
c*v(opt) minimal) by the following procedure:

   * (1) Compute the toric ideal I(A) using one of the algorithms in the
     previous section.

   * (2) Compute the reduced Groebner basis G(c) of I(A) w.r.t. >_c $>_c$
     .

   * (3) Reduce x^v $x^v$
      modulo G(c) using the Hironaka division algorithm.  If the result
     of this reduction is x^(v_0) $x^(v_0)$
     , then v_0 $v_0$
      is an optimal solution of the given instance.

If no initial solution is known, we are nevertheless able to solve the
problem with similar techniques. For this purpose we replace our
instance by an extended instance with the matrix used in the
Conti-Traverso algorithm. Indeed, the Conti-Traverso algorithm offers
the possibility to verify solvability of a given instance and to find an
initial solution in the case of existence (but none of the other
algorithms does!). Details can be found in [CoTr91] and [The99].

An implementation of the above algorithm and some examples can be found
in *note intprog_lib::.

Classical methods for solving IP instances like Branch-and-Bound methods
seem to be faster in general than the methods using toric ideals. But
the latter have one great advantage: If one wants to solve various
instances that differ only by the vector b $b$
, one has to perform steps (1) and (2) above only once. As the running
time of step (3) is very short, solving all the instances is not much
harder than solving one single instance.

For a detailed discussion see [The99].


File: index.htm,  Node: Relevant References,  Prev: Integer programming,  Up: Toric ideals and integer programming

C.6.5 Relevant References
-------------------------

   * [Big97]  Bigatti, A.M.:     Computation of Hilbert-Poincare
     series.     Journal of Pure and Applied Algebra (1997) 199, 237-253

   * [BLR98]  Bigatti, A.M.; La Scala, R.; Robbiano, L.:     Computing
     toric ideals.     Journal of Symbolic Computation (to appear)

   * [Coh93]  Cohen, H.:     A Course in Computational Algebraic Number
     Theory.     Springer (1997)

   * [CoTr91]  Conti, P.; Traverso, C.:     Buchberger algorithm and
     integer programming.     Proceedings AAECC-9 (new Orleans),
     Springer LNCS (1991) 539,    130-139

   * [DBUr95]  Di Biase, F.; Urbanke, R.:     An algorithm to calculate
     the kernel of certain polynomial ring    homomorphisms.
     Experimental Mathematics (1995) 4, 227-234

   * [HoSh98]  Hosten, S.; Shapiro, J.:     Primary decomposition of
     lattice basis ideals.     (to appear)

   * [HoSt95]  Hosten, S.; Sturmfels, B.:     GRIN: An implementation
     of Groebner bases for integer programming.     in Balas, E.;
     Clausen, J. (editors): Integer Programming and    Combinatorial
     Optimization.     Springer LNCS (1995) 920, 267-276

   * [Pot94]  Pottier, L.:     Groebner bases of toric ideals.
     Rapport de recherche 2224 (1997), INRIA Sophia Antipolis

   * [Stu96]  Sturmfels, B.:     Groebner Bases and Convex Polytopes.
     University Lecture Series, Volume 8 (1996), American Mathematical
     Society

   * [The99]  Theis, C.:     Der Buchberger-Algorithmus fuer torische
     Ideale und seine Anwendung    in der ganzzahligen Optimierung.
     Diplomarbeit, Universitaet des Saarlandes (1999), Saarbruecken
     (Germany)


File: index.htm,  Node: References,  Prev: Toric ideals and integer programming,  Up: Mathematical background

C.7 References
==============

The Centre for Computer Algebra Kaiserslautern publishes a series of
preprints which are electronically available at
`http://www.mathematik.uni-kl.de/~zca/Reports_on_ca'.  Other sources to
check are `http://symbolicnet.mcs.kent.edu/', `http://www.can.nl/',...
and the following list of books:

Text books on computational algebraic geometry
----------------------------------------------

   * Adams, W.; Loustaunau, P.: An Introduction to Gro"bner Bases.
     Providence, RI, AMS, 1996

   * Becker, T.; Weisspfenning, V.: Gro"bner Bases - A Computational
     Approach to Commutative Algebra. Springer, 1993

   * Cohen, H.: A Course in Computational Algebraic Number Theory,
     Springer, 1995

   * Cox, D.; Little, J.; O'Shea, D.: Ideals, Varieties and Algorithms.
     Springer, 1996

   * Eisenbud, D.: Commutative Algebra with a View Toward Algebraic
     Geometry.  Springer, 1995

   * Greuel, G.-M.; Pfister, G.: A SINGULAR Introduction to Commuative
     Algebra, Springer, 2002

   * Mishra, B.: Algorithmic Algebra, Texts and Monographs in Computer
     Science.  Springer, 1993

   * Sturmfels, B.: Algorithms in Invariant Theory. Springer 1993

   * Vasconcelos, W.: Computational Methods in Commutative Algebra and
     Algebraic Geometry. Springer, 1998

Descriptions of algorithms
--------------------------

   * Bareiss, E.: Sylvester's identity and multistep integer-preserving
     Gaussian elimination.  Math. Comp. 22 (1968), 565-578

   * Campillo, A.: Algebroid curves in positive characteristic. SLN 813,
     1980

   * Chou, S.: Mechanical Geometry Theorem Proving.  D.Reidel Publishing
     Company, 1988

   * Decker, W.; Greuel, G.-M.; Pfister, G.: Primary decomposition:
     algorithms and comparisons.  Preprint, Univ. Kaiserslautern, 1998.
     To appear in: Greuel, G.-M.; Matzat, B. H.; Hiss, G. (Eds.),
     Algorithmic Algebra and Number Theory. Springer Verlag, Heidelberg,
     1998

   * Decker, W.; Greuel, G.-M.; de Jong, T.; Pfister, G.: The
     normalization: a new algorithm, implementation and comparisons.
     Preprint, Univ. Kaiserslautern, 1998

   * Decker, W.; Heydtmann, A.; Schreyer, F. O.: Generating a Noetherian
     Normalization of the Invariant Ring of a Finite Group, 1997, to
     appear in Journal of Symbolic Computation

   * Faug\`ere,
     Faugere, J. C.; Gianni, P.; Lazard, D.; Mora, T.: Efficient
     computation of zero-dimensional Gro"bner bases by change of
     ordering. Journal of Symbolic Computation, 1989

   * Gra"be, H.-G.: On factorized Gro"bner bases, Univ. Leipzig, Inst.
     fu"r Informatik, 1994

   * Grassmann, H.; Greuel, G.-M.; Martin, B.; Neumann, W.; Pfister, G.;
     Pohl, W.; Scho"nemann, H.; Siebert, T.:  On an implementation of
     standard bases and syzygies in  SINGULAR.  Proceedings of the
     Workshop  Computational Methods in Lie theory in AAECC (1995)

   * Greuel, G.-M.; Pfister, G.: Advances and improvements in the theory
     of standard bases and syzygies. Arch. d. Math. 63(1995)

   * Kemper; Generating Invariant Rings of Finite Groups over Arbitrary
     Fields. 1996, to appear in Journal of Symbolic Computation

   * Kemper and Steel: Some Algorithms in Invariant Theory of Finite
     Groups. 1997

   * Lee, H.R.; Saunders, B.D.: Fraction Free Gaussian Elimination for
     Sparse Matrices. Journal of Symbolic Computation (1995) 19, 393-402

   * Scho"nemann, H.: Algorithms in SINGULAR, Reports on Computer
     Algebra 2(1996), Kaiserslautern

   * Siebert, T.: On strategies and implementations for computations of
     free resolutions.  Reports on Computer Algebra 8(1996),
     Kaiserslautern

   * Wang, D.: Characteristic Sets and Zero Structure of Polynomial
     Sets.  Lecture Notes, RISC Linz, 1989


File: index.htm,  Node: SINGULAR libraries,  Next: Release Notes,  Prev: Mathematical background,  Up: Top

Appendix D SINGULAR libraries
*****************************

SINGULAR comes with a set of standard libraries. Their content is
described in the following subsections.

Use the *note LIB:: command for loading of single libraries, and the
command `LIB "all.lib";' for loading all libraries.

* Menu:

* standard_lib:: extensions of Singular kernel
* General purpose::
* Linear algebra::
* Commutative algebra::
* Singularities::
* Invariant theory::
* Symbolic-numerical solving::
* Visualization::
* Coding theory::


File: index.htm,  Node: standard_lib,  Next: General purpose,  Prev: SINGULAR libraries,  Up: SINGULAR libraries

D.1 standard_lib
================

The library `standard.lib' provides extensions to the set of built-in
commands and is automatically loaded during the start of SINGULAR,
unless SINGULAR is started up with the `--no-stdlib' command line option
(see *note Command line options::).

*Library:*
     standard.lib

*Purpose:*
     Procedures which are always loaded at Start-up

*Procedures:*

* Menu:

* stdfglm:: standard basis of ideal via fglm [and ordering ord]
* stdhilb:: standard basis of ideal using the Hilbert function
* groebner:: standard basis using a heuristically chosen method
* quot:: quotient using heuristically chosen method
* res:: free resolution of ideal or module
* sprintf:: returns formatted string
* fprintf:: writes formatted string to link
* printf:: displays formatted string


File: index.htm,  Node: General purpose,  Next: Linear algebra,  Prev: standard_lib,  Up: SINGULAR libraries

D.2 General purpose
===================

* Menu:

* all_lib:: load all other libraries
* general_lib:: procedures of general type
* inout_lib:: procedures for manipulating in- and output
* poly_lib:: procedures for manipulating polynomials and ideals
* random_lib:: procedures of random/sparse  matrix and poly operations
* ring_lib:: procedures for manipulating rings and maps


File: index.htm,  Node: all_lib,  Next: general_lib,  Prev: General purpose,  Up: General purpose

D.2.1 all_lib
-------------

The library `all.lib' provides a convenient way to load all libraries of
the SINGULAR distribution.

*Example:*
     option(loadLib);
     LIB "all.lib";
     ==> // ** loaded all.lib (1.35.2.4,2003/02/25)
     ==> // ** loaded makedbm.lib (1.11,2000/12/22)
     ==> // ** loaded brnoeth.lib (1.11.2.5,2002/10/18)
     ==> // ** loaded paramet.lib (1.11.2.1,2002/10/21)
     ==> // ** loaded surf.lib (1.19.2.6,2002/07/17)
     ==> // ** loaded latex.lib (1.19.2.1,2002/02/20)
     ==> // ** loaded graphics.lib (1.10,2001/02/19)
     ==> // ** loaded zeroset.lib (1.7.2.2,2002/02/20)
     ==> // ** loaded ntsolve.lib (1.12.2.1,2002/04/12)
     ==> // ** loaded triang.lib (1.7,2001/02/19)
     ==> // ** loaded solve.lib (1.21.2.13,2002/10/21)
     ==> // ** loaded presolve.lib (1.17.2.6,2003/03/26)
     ==> // ** loaded stratify.lib (1.7.2.4,2002/04/11)
     ==> // ** loaded rinvar.lib (1.7.2.3,2002/02/20)
     ==> // ** loaded finvar.lib (1.32.2.2,2002/08/13)
     ==> // ** loaded ainvar.lib (1.6.2.2,2002/04/12)
     ==> // ** loaded spectrum.lib (1.12.2.3,2002/03/06)
     ==> // ** loaded spcurve.lib (1.15.2.1,2002/02/20)
     ==> // ** loaded sing.lib (1.24.2.5,2003/04/15)
     ==> // ** loaded qhmoduli.lib (1.0,2000/12/12)
     ==> // ** loaded mondromy.lib (1.22.2.2,2002/02/20)
     ==> // ** loaded hnoether.lib (1.29.2.14,2002/10/21)
     ==> // ** loaded gaussman.lib (1.33.2.26,2003/02/10)
     ==> // ** loaded equising.lib (1.7.2.5,2003/02/25)
     ==> // ** loaded deform.lib (1.25.2.2,2003/02/24)
     ==> // ** loaded classify.lib (1.48.2.4,2002/04/11)
     ==> // ** loaded toric.lib (1.11,2001/02/06)
     ==> // ** loaded intprog.lib (1.5,2001/02/06)
     ==> // ** loaded reesclos.lib (1.50,2001/08/06)
     ==> // ** loaded primitiv.lib (1.15,2001/02/05)
     ==> // ** loaded primdec.lib (1.98.2.14,2003/04/07)
     ==> // ** loaded normal.lib (1.34.2.17,2002/10/21)
     ==> // ** loaded mregular.lib (1.6.2.1,2002/02/20)
     ==> // ** loaded mprimdec.lib (1.1.2.3,2002/03/19)
     ==> // ** loaded homolog.lib (1.15.2.2,2002/10/07)
     ==> // ** loaded elim.lib (1.14.2.4,2003/04/16)
     ==> // ** loaded algebra.lib (1.9.2.3,2002/04/11)
     ==> // ** loaded linalg.lib (1.10.2.15,2003/04/04)
     ==> // ** loaded matrix.lib (1.26.2.2,2002/10/07)
     ==> // ** loaded ring.lib (1.17.2.1,2002/02/20)
     ==> // ** loaded random.lib (1.16.2.1,2002/02/20)
     ==> // ** loaded poly.lib (1.33.2.6,2003/02/10)
     ==> // ** loaded inout.lib (1.21.2.5,2002/06/12)
     ==> // ** loaded general.lib (1.38.2.9,2003/04/04)


File: index.htm,  Node: general_lib,  Next: inout_lib,  Prev: all_lib,  Up: General purpose

D.2.2 general_lib
-----------------

*Library:*
     general.lib

*Purpose:*
     Elementary Computations of General Type

*Procedures:*

* Menu:

* A_Z:: string a,b,... of n comma separated letters
* ASCII:: string of printable ASCII characters (number n to m)
* absValue:: absolute value of c
* binomial:: n choose m (type int), [type string/type number]
* deleteSublist:: delete entries given by iv from list l
* factorial:: n factorial (=n!) (type int), [type string/number]
* fibonacci:: nth Fibonacci number [char p]
* kmemory:: active [allocated] memory in kilobyte
* killall:: kill all user-defined variables
* number_e:: compute exp(1) up to n decimal digits
* number_pi:: compute pi (area of unit circle) up to n digits
* primes:: intvec of primes p, n<=p<=m
* product:: multiply components of vector/ideal/...[indices v]
* sort:: sort generators according to monomial ordering
* sum:: add components of vector/ideal/...[with indices v]
* watchdog:: only wait for result of command cmd for i seconds
* which:: search for command and return absolute path, if found
* primecoeffs:: primefactors <= min(p,32003) of coeffs of J
* primefactors:: primefactors <= min(p,32003) of n
* timeStd:: std(i) if computation finished after d seconds else i
* timeFactorize:: works as timeStd with factorization
* factorH:: factorizes with good choice of principal variable


File: index.htm,  Node: A_Z,  Next: ASCII,  Up: general_lib

D.2.2.1 A_Z
...........

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     A_Z("a",n); a any letter, n integer (-26<= n <=26, !=0)

*Return:*
     string of n small (if a is small) or capital (if a is capital)
     letters, comma separated, beginning with a, in alphabetical order
     (or revers alphabetical order if n<0)

*Example:*
     LIB "general.lib";
     A_Z("c",5);
     ==> c,d,e,f,g
     A_Z("Z",-5);
     ==> Z,Y,X,W,V
     string sR = "ring R = (0,"+A_Z("A",6)+"),("+A_Z("a",10)+"),dp;";
     sR;
     ==> ring R = (0,A,B,C,D,E,F),(a,b,c,d,e,f,g,h,i,j),dp;
     execute(sR);
     R;
     ==> //   characteristic : 0
     ==> //   6 parameter    : A B C D E F 
     ==> //   minpoly        : 0
     ==> //   number of vars : 10
     ==> //        block   1 : ordering dp
     ==> //                  : names    a b c d e f g h i j 
     ==> //        block   2 : ordering C


File: index.htm,  Node: ASCII,  Next: absValue,  Prev: A_Z,  Up: general_lib

D.2.2.2 ASCII
.............

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     ASCII([n,m]); n,m= integers (32 <= n <= m <= 126)

*Return:*
     string of printable ASCII characters (no native language support)
     ASCII(): string of all ASCII characters with its numbers, ASCII(n):
     n-th ASCII character
     ASCII(n,m): n-th up to m-th ASCII character (inclusive)

*Example:*
     LIB "general.lib";
     ASCII();"";
     ==>      !    "    #    $    %    &    '    (    )    *    +    ,    -    .
     ==> 32   33   34   35   36   37   38   39   40   41   42   43   44   45   46
     ==> /    0    1    2    3    4    5    6    7    8    9    :    ;    <    =
     ==> 47   48   49   50   51   52   53   54   55   56   57   58   59   60   61
     ==> >    ?    @    A    B    C    D    E    F    G    H    I    J    K    L
     ==> 62   63   64   65   66   67   68   69   70   71   72   73   74   75   76
     ==> M    N    O    P    Q    R    S    T    U    V    W    X    Y    Z    [
     ==> 77   78   79   80   81   82   83   84   85   86   87   88   89   90   91
     ==> \    ]    ^    _    `    a    b    c    d    e    f    g    h    i    j
     ==> 92   93   94   95   96   97   98   99  100  101  102  103  104  105  10
     ==> k    l    m    n    o    p    q    r    s    t    u    v    w    x    y
     ==> 107  108  109  110  111  112  113  114  115  116  117  118  119  120  121
     ==> z    {    |    }    ~
     ==> 122  123  124  125  126 
     ==> 
     ASCII(42);
     ==> *
     ASCII(32,126);
     ==>  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh\
        ijklmnopqrstuvwxyz{|}~


File: index.htm,  Node: absValue,  Next: binomial,  Prev: ASCII,  Up: general_lib

D.2.2.3 absValue
................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     absValue(c); c int, number or poly

*Return:*
     absValue(c); the absolute value of c

*Note:*
     absValue(c)=c if c>=0; absValue=-c if c<=0.
     So the function can be applied to any type, for which comparison
     operators are defined.

*Example:*
     LIB "general.lib";
     ring r1 = 0,x,dp;
     absValue(-2002);
     ==> 2002
     poly f=-4;
     absValue(f);
     ==> 4

* Menu:

See also:
* boolean expressions::

*See also:* *note boolean expressions::.


File: index.htm,  Node: binomial,  Next: deleteSublist,  Prev: absValue,  Up: general_lib

D.2.2.4 binomial
................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     binomial(n,k[,p]); n,k,p integers

*Return:*
     binomial(n,k); binomial coefficient n choose k
     - of type string (computed in characteristic 0)
     binomial(n,k,p); n choose k, computed in characteristic 0 or
     prime(p)
     - of type number if a basering, say R, is present and p=0=char(R)
     or if prime(p)=char(R)
     - of type string else

*Note:*
     In any characteristic, binomial(n,k) = coefficient of x^k in
     (1+x)^n

*Example:*
     LIB "general.lib";
     binomial(200,100);"";                   //type string, computed in char 0
     ==> 90548514656103281165404177077484163874504589675413336841320
     ==> 
     binomial(200,100,3);"";                 //type string, computed in char 3
     ==> 0
     ==> 
     int n,k = 200,100;
     ring r = 0,x,dp;
     number b1 = binomial(n,k,0);            //type number, computed in ring r
     poly b2 = coeffs((x+1)^n,x)[k+1,1];     //coefficient of x^k in (x+1)^n
     b1-b2;                                  //b1 and b2 should coincide
     ==> 0

* Menu:

See also:
* prime::

*See also:* *note prime::.


File: index.htm,  Node: deleteSublist,  Next: factorial,  Prev: binomial,  Up: general_lib

D.2.2.5 deleteSublist
.....................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     deleteSublist(v,l); intvec v; list l
     where the entries of the integer vector v correspond to the
     positions of the elements to be deleted

*Return:*
     list without the deleted elements

*Example:*
     LIB "general.lib";
     list l=1,2,3,4,5;
     intvec v=1,3,4;
     l=deleteSublist(v,l);
     l;
     ==> [1]:
     ==>    2
     ==> [2]:
     ==>    5


File: index.htm,  Node: factorial,  Next: fibonacci,  Prev: deleteSublist,  Up: general_lib

D.2.2.6 factorial
.................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     factorial(n[,p]); n,p integers

*Return:*
     factorial(n): n! (computed in characteristic 0), of type string.
     factorial(n,p): n! computed in characteristic 0 or prime(p)
     - of type number if a basering is present and 0=p=char(basering) or
     if prime(p)=char(basering)
     - of type string else

*Example:*
     LIB "general.lib";
     factorial(37);"";                 //37! of type string (as long integer)
     ==> 13763753091226345046315979581580902400000000
     ==> 
     ring r1 = 0,x,dp;
     number p = factorial(37,0);       //37! of type number, computed in r
     p;
     ==> 13763753091226345046315979581580902400000000

* Menu:

See also:
* prime::

*See also:* *note prime::.


File: index.htm,  Node: fibonacci,  Next: kmemory,  Prev: factorial,  Up: general_lib

D.2.2.7 fibonacci
.................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     fibonacci(n); n,p integers

*Return:*
     fibonacci(n): nth Fibonacci number, f(0)=f(1)=1, f(i+1)=f(i-1)+f(i)

     - computed in characteristic 0, of type string
     fibonacci(n,p): f(n) computed in characteristic 0 or prime(p)
     - of type number if a basering is present and p=0=char(basering) or
     if prime(p)=char(basering)
     - of type string else

*Example:*
     LIB "general.lib";
     fibonacci(42); "";             //f(42) of type string (as long integer)
     ==> 267914296
     ==> 
     ring r = 2,x,dp;
     number b = fibonacci(42,2);    //f(42) of type number, computed in r
     b;
     ==> 0

* Menu:

See also:
* prime::

*See also:* *note prime::.


File: index.htm,  Node: kmemory,  Next: killall,  Prev: fibonacci,  Up: general_lib

D.2.2.8 kmemory
...............

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     kmemory([n,[v]]); n,v integers

*Return:*
     memory in kilobyte of type int
     n=0: memory used by active variables (same as no parameters)
     n=1: total memory allocated by Singular
     n=2: difference between top and init memory address (sbrk memory)
     n!=0,1,2: 0

*Display:*
     detailed information about allocated and used memory if v!=0

*Note:*
     kmemory uses internal function 'memory' to compute kilobyte, and is
     the same as 'memory' for n!=0,1,2

*Example:*
     LIB "general.lib";
     kmemory();
     ==> 152
     kmemory(1,1);
     ==> // total memory allocated, at the moment, by SINGULAR (kilobyte):
     ==> 650


File: index.htm,  Node: killall,  Next: number_e,  Prev: kmemory,  Up: general_lib

D.2.2.9 killall
...............

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     killall(); (no parameter)
     killall("type_name");
     killall("not", "type_name");

*Return:*
     killall(); kills all user-defined variables except loaded
     procedures, no return value.
     - killall("type_name"); kills all user-defined variables, of type
     "type_name"
     - killall("not", "type_name"); kills all user-defined variables,
     except those of type "type_name" and except loaded procedures
     - killall("not", "name_1", "name_2", ...); kills all user-defined
     variables, except those of name "name_i" and except loaded
     procedures

*Note:*
     killall should never be used inside a procedure

*Example:*
     LIB "general.lib";
     ring rtest; ideal i=x,y,z; string str="hi"; int j = 3;
     export rtest,i,str,j;       //this makes the local variables global
     ==> // ** `rtest` is already global
     ==> // ** `i` is already global
     ==> // ** `str` is already global
     ==> // ** `j` is already global
     listvar();
     ==> // j                    [0]  int 3
     ==> // str                  [0]  string hi
     ==> // rtest                [0]  *ring
     ==> //      i                    [0]  ideal, 3 generator(s)
     ==> // LIB                  [0]  string standard.lib,general..., 74 char(s)
     killall("ring");            // kills all rings
     ==> // ** killing the basering for level 0
     listvar();
     ==> // j                    [0]  int 3
     ==> // str                  [0]  string hi
     ==> // LIB                  [0]  string standard.lib,general..., 74 char(s)
     killall("not", "int");      // kills all variables except int's (and procs)
     listvar();
     ==> // j                    [0]  int 3
     ==> // LIB                  [0]  string standard.lib,general..., 74 char(s)
     killall();                  // kills all vars except loaded procs
     listvar();
     ==> // j                    [0]  int 3
     ==> // LIB                  [0]  string standard.lib,general..., 74 char(s)


File: index.htm,  Node: number_e,  Next: number_pi,  Prev: killall,  Up: general_lib

D.2.2.10 number_e
.................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     number_e(n); n integer

*Return:*
     Euler number e=exp(1) up to n decimal digits (no rounding)
     - of type string if no basering of char 0 is defined
     - of type number if a basering of char 0 is defined

*Display:*
     decimal format of e if printlevel > 0 (default:printlevel=0 )

*Note:*
     procedure uses algorithm of A.H.J. Sale

*Example:*
     LIB "general.lib";
     number_e(30);"";
     ==> 2.71828182845904523536028747135
     ==> 
     ring R = 0,t,lp;
     number e = number_e(30);
     e;
     ==> 13591409142295226176801437356763/5000000000000000000000000000000


File: index.htm,  Node: number_pi,  Next: primes,  Prev: number_e,  Up: general_lib

D.2.2.11 number_pi
..................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     number_pi(n); n positive integer

*Return:*
     pi (area of unit circle) up to n decimal digits (no rounding)
     - of type string if no basering of char 0 is defined,
     - of type number, if a basering of char 0 is defined

*Display:*
     decimal format of pi if printlevel > 0 (default:printlevel=0 )

*Note:*
     procedure uses algorithm of S. Rabinowitz

*Example:*
     LIB "general.lib";
     number_pi(11);"";
     ==> 3.1415926535
     ==> 
     ring r = (real,10),t,dp;
     number pi = number_pi(11); pi;
     ==> 3.1415926536


File: index.htm,  Node: primes,  Next: product,  Prev: number_pi,  Up: general_lib

D.2.2.12 primes
...............

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     primes(n,m); n,m integers

*Return:*
     intvec, consisting of all primes p, prime(n)<=p<=m, in increasing
     order if n<=m, resp. prime(m)<=p<=n, in decreasing order if m<n.

*Note:*
     prime(n); returns the biggest prime number <= min(n,32003) if n>=2,
     else 2

*Example:*
     LIB "general.lib";
     primes(50,100);"";
     ==> 47,53,59,61,67,71,73,79,83,89,97
     ==> 
     intvec v = primes(37,1); v;
     ==> 37,31,29,23,19,17,13,11,7,5,3,2


File: index.htm,  Node: product,  Next: sort,  Prev: primes,  Up: general_lib

D.2.2.13 product
................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     product(id[,v]); id ideal/vector/module/matrix/intvec/intmat/list,
     v intvec (default: v=1..number of entries of id)

*Assume:*
     list members can be multiplied.

*Return:*
     The product of all entries of id [with index given by v] of type
     depending on the entries of id.

*Note:*
     If id is not a list, id is treated as a list of polys resp.
     integers.  A module m is identified with the corresponding matrix M
     (columns of M generate m).
     If v is outside the range of id, we have the empty product and the
     result will be 1 (of type int).

*Example:*
     LIB "general.lib";
     ring r= 0,(x,y,z),dp;
     ideal m = maxideal(1);
     product(m);
     ==> xyz
     product(m[2..3]);
     ==> yz
     matrix M[2][3] = 1,x,2,y,3,z;
     product(M);
     ==> 6xyz
     intvec v=2,4,6;
     product(M,v);
     ==> xyz
     intvec iv = 1,2,3,4,5,6,7,8,9;
     v=1..5,7,9;
     product(iv,v);
     ==> 7560
     intmat A[2][3] = 1,1,1,2,2,2;
     product(A,3..5);
     ==> 4


File: index.htm,  Node: sort,  Next: sum,  Prev: product,  Up: general_lib

D.2.2.14 sort
.............

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     sort(id[v,o,n]); id = ideal/module/intvec/list(of intvec's or
     int's)
     sort may be called with 1, 2 or 3 arguments in the following way:
     sort(id[v,n]); v=intvec of positive integers, n=integer,
     sort(id[o,n]); o=string (any allowed ordstr of a ring), n=integer

*Return:*
     a list l of two elements:

             l[1]: object of same type as input but sorted in the following way:
                - if id=ideal/module: generators of id are sorted w.r.t. intvec v
                  (id[v[1]] becomes 1-st, id[v[2]]  2-nd element, etc.). If no v is
                  present, id is sorted w.r.t. ordering o (if o is given) or w.r.t.
                  actual monomial ordering (if no o is given):
                  NOTE: generators with SMALLER(!) leading term come FIRST
                  (e.g. sort(id); sorts backwards to actual monomial ordering)
                - if id=list of intvec's or int's: consider a list element, say
                  id[1]=3,2,5, as exponent vector of the monomial x^3*y^2*z^5;
                  the corresponding monomials are ordered w.r.t. intvec v (s.a.).
                  If no v is present, the monomials are sorted w.r.t. ordering o
                  (if o is given) or w.r.t. lexicographical ordering (if no o is
                  given). The corresponding ordered list of exponent vectors is
                  returned.
                  (e.g. sort(id); sorts lexicographically, smaller int's come first)
                  WARNING: Since negative exponents create the 0 polynomial in
                  Singular, id should not contain negative integers: the result
                  might not be as expected
                - if id=intvec: id is treated as list of integers
                - if n!=0 the ordering is inverse, i.e. w.r.t. v(size(v)..1)
                  default: n=0
              l[2]: intvec, describing the permutation of the input (hence l[2]=v
                  if v is given (with positive integers))

*Note:*
     If v is given id may be any simply indexed object (e.g. any list or
     string); if v[i]<0 and i<=size(id) v[i] is set internally to i;
     entries of v must be pairwise distinct to get a permutation if id.
     Zero generators of ideal/module are deleted

*Example:*
     LIB "general.lib";
     ring r0 = 0,(x,y,z,t),lp;
     ideal i = x3,z3,xyz;
     sort(i);            //sorts using lex ordering, smaller polys come first
     ==> [1]:
     ==>    _[1]=z3
     ==>    _[2]=xyz
     ==>    _[3]=x3
     ==> [2]:
     ==>    2,3,1
     sort(i,3..1);
     ==> [1]:
     ==>    _[1]=xyz
     ==>    _[2]=z3
     ==>    _[3]=x3
     ==> [2]:
     ==>    3,2,1
     sort(i,"ls")[1];     //sort w.r.t. negative lex ordering
     ==> _[1]=x3
     ==> _[2]=xyz
     ==> _[3]=z3
     intvec v =1,10..5,2..4;v;
     ==> 1,10,9,8,7,6,5,2,3,4
     sort(v)[1];          // sort v lexicographically
     ==> 1,2,3,4,5,6,7,8,9,10
     sort(v,"Dp",1)[1];   // sort v w.r.t (total sum, reverse lex)
     ==> 10,9,8,7,6,5,4,3,2,1


File: index.htm,  Node: sum,  Next: watchdog,  Prev: sort,  Up: general_lib

D.2.2.15 sum
............

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     sum(id[,v]); id ideal/vector/module/matrix/intvec/intmat/list, v
     intvec (default: v=1..number of entries of id)

*Assume:*
     list members can be added.

*Return:*
     The sum of all entries of id [with index given by v] of type
     depending on the entries of id.

*Note:*
     If id is not a list, id is treated as a list of polys resp.
     integers.  A module m is identified with the corresponding matrix M
     (columns of M generate m).
     If v is outside the range of id, we have the empty sum and the
     result will be 0 (of type int).

*Example:*
     LIB "general.lib";
     ring r= 0,(x,y,z),dp;
     vector pv = [xy,xz,yz,x2,y2,z2];
     sum(pv);
     ==> x2+xy+y2+xz+yz+z2
     sum(pv,2..5);
     ==> x2+y2+xz+yz
     matrix M[2][3] = 1,x,2,y,3,z;
     intvec w=2,4,6;
     sum(M,w);
     ==> x+y+z
     intvec iv = 1,2,3,4,5,6,7,8,9;
     sum(iv,2..4);
     ==> 9


File: index.htm,  Node: watchdog,  Next: which,  Prev: sum,  Up: general_lib

D.2.2.16 watchdog
.................

Procedure from library `general.lib' (*note general_lib::).

*Return:*
     Result of cmd, if the result can be computed in i seconds.
     Otherwise the computation is interrupted after i seconds, the
     string "Killed" is returned and the global variable
     'watchdog_interrupt' is defined.

*Note:*
     * the MP package must be enabled
     * the current basering should not be watchdog_rneu, since
     watchdog_rneu will be killed
     * if there are variable names of the structure x(i) all polynomials
     have to be put into eval(...) in order to be interpreted correctly
     * a second Singular process is started by this procedure

*Example:*
     LIB "general.lib";
     ring r=0,(x,y,z),dp;
     poly f=x^30+y^30;
     watchdog(1,"factorize(eval("+string(f)+"))");
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=x16+x14y2-x10y6-x8y8-x6y10+x2y14+y16
     ==>    _[3]=x8-x6y2+x4y4-x2y6+y8
     ==>    _[4]=x4-x2y2+y4
     ==>    _[5]=x2+y2
     ==> [2]:
     ==>    1,1,1,1,1
     watchdog(100,"factorize(eval("+string(f)+"))");
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=x16+x14y2-x10y6-x8y8-x6y10+x2y14+y16
     ==>    _[3]=x8-x6y2+x4y4-x2y6+y8
     ==>    _[4]=x4-x2y2+y4
     ==>    _[5]=x2+y2
     ==> [2]:
     ==>    1,1,1,1,1


File: index.htm,  Node: which,  Next: primecoeffs,  Prev: watchdog,  Up: general_lib

D.2.2.17 which
..............

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     which(command); command = string expression

*Return:*
     Absolute pathname of command, if found in search path.  Empty
     string, otherwise.

*Note:*
     Based on the Unix command 'which'.

*Example:*
     LIB "general.lib";
     which("sh");
     ==> /bin/sh


File: index.htm,  Node: primecoeffs,  Next: primefactors,  Prev: which,  Up: general_lib

D.2.2.18 primecoeffs
....................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     primecoeffs(J[,q]); J any type which can be converted to a matrix
     e.g. ideal, matrix, vector, module, int, intvec
     q = intger

*Compute:*
     primefactors <= min(p,32003) of coeffs of J (default p = 32003)

*Return:*
     a list, say l, of two intvectors:
     l[1] : the different primefactors of all coefficients of J l[2] :
     the different remaining factors

*Note:*
     the procedure works for small integers only, just by testing all
     primes (not to be considerd as serious prime factorization!)

*Example:*
     LIB "general.lib";
     primecoeffs(intvec(7*8*121,7*8));"";
     ==> [1]:
     ==>    2,7,11
     ==> [2]:
     ==>    1
     ==> 
     ring r = 0,(b,c,t),dp;
     ideal I = -13b6c3t+4b5c4t,-10b4c2t-5b4ct2;
     primecoeffs(I);
     ==> [1]:
     ==>    2,5,13
     ==> [2]:
     ==>    _[1]=1


File: index.htm,  Node: primefactors,  Next: timeStd,  Prev: primecoeffs,  Up: general_lib

D.2.2.19 primefactors
.....................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     primefactors(n [,p]); n = int or number, p = integer

*Compute:*
     primefactors <= min(p,32003) of n (default p = 32003)

*Return:*
     a list, say l,
     l[1] : primefactors <= min(p,32003) of n
     l[2] : l[2][i] = multiplicity of l[1][i]
     l[3] : remaining factor ( n=product{ (l[1][i]^l[2][i])*l[3]} )
     type(l[3])=typeof(n)

*Note:*
     If n is a long integer (of type number) then the procedure finds
     primefactors <= min(p,32003) but n may be larger as 2147483647
     (max. integer representation)

*Warning:*
     the procedure works for small integers only, just by testing all
     primes (not to be considerd as serious prime factorization!)

*Example:*
     LIB "general.lib";
     primefactors(7*8*121);
     ==> [1]:
     ==>    2,7,11
     ==> [2]:
     ==>    3,1,2
     ==> [3]:
     ==>    1
     ring r = 0,x,dp;
     primefactors(123456789100);
     ==> [1]:
     ==>    2,5
     ==> [2]:
     ==>    2,2
     ==> [3]:
     ==>    1234567891


File: index.htm,  Node: timeStd,  Next: timeFactorize,  Prev: primefactors,  Up: general_lib

D.2.2.20 timeStd
................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     timeStd(i,d), i ideal, d integer

*Return:*
     std(i) if the standard basis computation finished after d-1 seconds
     and i otherwise

*Example:*
     LIB "general.lib";
     ring r=32003,(a,b,c,d,e),dp;
     int n=6;
     ideal i=
     a^n-b^n,
     b^n-c^n,
     c^n-d^n,
     d^n-e^n,
     a^(n-1)*b+b^(n-1)*c+c^(n-1)*d+d^(n-1)*e+e^(n-1)*a;
     ideal j=timeStd(i,2);
     j;
     ==> j[1]=a6-b6
     ==> j[2]=b6-c6
     ==> j[3]=c6-d6
     ==> j[4]=d6-e6
     ==> j[5]=a5b+b5c+c5d+d5e+ae5


File: index.htm,  Node: timeFactorize,  Next: factorH,  Prev: timeStd,  Up: general_lib

D.2.2.21 timeFactorize
......................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     timeFactorize(p,d) poly p , integer d

*Return:*
     factorize(p) if the factorization finished after d-1
     seconds otherwise f is considered to be irreducible

*Example:*
     LIB "general.lib";
     ring r=0,(x,y),dp;
     poly p=((x2+y3)^2+xy6)*((x3+y2)^2+x10y);
     p=p^2;
     list l=timeFactorize(p,2);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       x22y14+2x21y14+4x23y11+x20y14+2x25y8+4x22y11+6x24y8+4x26y5+2x18y13+\
        x28y2+4x17y13+4x15y15+8x19y10+2x16y13+8x14y15+2x12y17+4x21y7+8x18y10+16x1\
        6y12+4x13y15+4x11y17+12x20y7+8x18y9+16x15y12+8x13y14+2x10y17+8x22y4+24x17\
        y9+4x15y11+x14y12+8x12y14+2x24y+16x19y6+12x14y11+2x13y12+4x11y14+4x21y3+8\
        x16y8+4x15y9+x12y12+8x10y14+6x8y16+2x18y5+2x17y6+4x14y9+16x12y11+4x9y14+1\
        2x7y16+4x5y18+6x16y6+8x14y8+16x11y11+24x9y13+6x6y16+8x4y18+x2y20+4x18y3+2\
        4x13y8+12x11y10+24x8y13+16x6y15+4x3y18+2xy20+x20+16x15y5+36x10y10+8x8y12+\
        16x5y15+4x3y17+y20+4x17y2+24x12y7+24x7y12+2x5y14+4x2y17+6x14y4+16x9y9+6x4\
        y14+4x11y6+4x6y11+x8y8
     ==> [2]:
     ==>    1,1


File: index.htm,  Node: factorH,  Prev: timeFactorize,  Up: general_lib

D.2.2.22 factorH
................

Procedure from library `general.lib' (*note general_lib::).

*Usage:*
     factorH(p) p poly

*Return:*
     factorize(p)

*Note:*
     changes variables to become the last variable the principal one in
     the multivariate factorization and factorizes then the polynomial

*Example:*
     LIB "general.lib";
     system("random",992851144);
     ring r=32003,(x,y,z,w,t),lp;
     poly p=y2w9+yz7t-yz5w4-z2w4t4-w8t3;
     //factorize(p);  //fast
     //system("random",992851262);
     //factorize(p);  //slow
     //system("random",992851262);
     factorH(p);
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=y2w9+yz7t-yz5w4-z2w4t4-w8t3
     ==> [2]:
     ==>    1,1


File: index.htm,  Node: inout_lib,  Next: poly_lib,  Prev: general_lib,  Up: General purpose

D.2.3 inout_lib
---------------

*Library:*
     inout.lib

*Purpose:*
     Printing and Manipulating In- and Output

*Procedures:*

* Menu:

* allprint:: print list if ALLprint is defined, with pause if >0
* lprint:: display poly/... fitting to pagewidth [size n]
* pmat:: print form-matrix [first n chars of each column]
* rMacaulay:: read Macaulay_1 output and return its Singular format
* show:: display any object in a compact format
* showrecursive:: display id recursively with respect to variables in p
* split:: split given string into lines of length n
* tab:: string of n space tabs
* writelist:: write a list into a file and keep the list structure
* pause:: stop the computation until user input


File: index.htm,  Node: allprint,  Next: lprint,  Up: inout_lib

D.2.3.1 allprint
................

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     allprint(L); L list

*Display:*
     prints L[1], L[2], ... if an integer with name ALLprint is defined.

     makes "pause", if ALLprint > 0
     listvar(matrix), if ALLprint = 2

*Return:*
     no return value

*Example:*
     LIB "inout.lib";
     ring S;
     matrix M=matrix(freemodule(2),3,3);
     int ALLprint; export ALLprint;
     ==> // ** `ALLprint` is already global
     allprint("M =",M);
     ==> M =
     ==> 1,0,0,
     ==> 0,1,0,
     ==> 0,0,0 
     kill ALLprint;


File: index.htm,  Node: lprint,  Next: pmat,  Prev: allprint,  Up: inout_lib

D.2.3.2 lprint
..............

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     lprint(id[,n]); id poly/ideal/vector/module/matrix, n integer

*Return:*
     string of id in a format fitting into lines of size n, such that no
     monomial is destroyed, i.e. the new line starts with + or -;
     (default: n = pagewidth).

*Note:*
     id is printed columnwise, each column separated by a blank line;
     hence lprint(transpose(id)); displays a matrix id in a format which
     can be used as input.

*Example:*
     LIB "inout.lib";
     ring r= 0,(x,y,z),ds;
     poly f=((x+y)*(x-y)*(x+z)*(y+z)^2);
     lprint(f,40);
     ==>   x3y2-xy4+2x3yz+x2y2z-2xy3z-y4z+x3z2
     ==> +2x2yz2-xy2z2-2y3z2+x2z3-y2z3
     module m = [f*(x-y)],[0,f*(x-y)];
     string s=lprint(m); s;"";
     ==>   x4y2-x3y3-x2y4+xy5+2x4yz-x3y2z-3x2y3z+xy4z+y5z+x4z2+x3yz2-3x2y2z2-xy3z2
     ==> +2y4z2+x3z3-x2yz3-xy2z3+y3z3,
     ==>   0,
     ==> 
     ==>   0,
     ==>   x4y2-x3y3-x2y4+xy5+2x4yz-x3y2z-3x2y3z+xy4z+y5z+x4z2+x3yz2-3x2y2z2-xy3z2
     ==> +2y4z2+x3z3-x2yz3-xy2z3+y3z3
     ==> 
     execute("matrix M[2][2]="+s+";");      //use the string s as input
     module m1 = transpose(M);	          //should be the same as m
     print(m-m1);
     ==> 0,0,
     ==> 0,0 


File: index.htm,  Node: pmat,  Next: rMacaulay,  Prev: lprint,  Up: inout_lib

D.2.3.3 pmat
............

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     pmat(M,[n]); M matrix, n integer

*Display:*
     display M in array format if it fits into pagewidth; if n is given,
     only the first n characters of each column are shown

*Return:*
     no return value

*Example:*
     LIB "inout.lib";
     ring r=0,(x,y,z),ls;
     ideal i= x,z+3y,x+y,z;
     matrix m[3][3]=i^2;
     pmat(m);
     ==> x2,     xz+3xy,     xy+x2,         
     ==> xz,     z2+6yz+9y2, yz+3y2+xz+3xy, 
     ==> z2+3yz, y2+2xy+x2,  yz+xz
     pmat(m,3);
     ==> x2  xz+ xy+ 
     ==> xz  z2+ yz+ 
     ==> z2+ y2+ yz+ 


File: index.htm,  Node: rMacaulay,  Next: show,  Prev: pmat,  Up: inout_lib

D.2.3.4 rMacaulay
.................

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     rMacaulay(s[,n]); s string, n integer

*Return:*
     A string which should be readable by Singular if s is a string
     which was produced by Macaulay. If a second argument is present the
     first n lines of the file are deleted (which is useful if the file
     was produced e.g. by the putstd command of Macaulay).

*Note:*
     This does not always work with 'cut and paste' since the character
     \ is treated differently

*Example:*
     LIB "inout.lib";
     // Assume there exists a file 'Macid' with the following ideal in
     // Macaulay format:"
     // x[0]3-101/74x[0]2x[1]+7371x[0]x[1]2-13/83x[1]3-x[0]2x[2] \
     //     -4/71x[0]x[1]x[2]
     // Read this file into Singular and assign it to the string s1 by:
     // string s1 = read("Macid");
     // This is equivalent to";
     string s1 =
     "x[0]3-101/74x[0]2x[1]+7371x[0]x[1]2-13/83x[1]3-x[0]2x[2]-4/71x[0]x[1]x[2]";
     rMacaulay(s1);
     ==> x(0)^3-101/74*x(0)^2*x(1)+7371*x(0)*x(1)^2-13/83*x(1)^3-x(0)^2*x(2)-4/71*\
        x(0)*x(1)*x(2)
     // You may wish to assign s1 to a Singular ideal id:
     string sid = "ideal id =",rMacaulay(s1),";";
     ring r = 0,x(0..3),dp;
     execute(sid);
     id; "";
     ==> id[1]=x(0)^3-101/74*x(0)^2*x(1)+7371*x(0)*x(1)^2-13/83*x(1)^3-x(0)^2*x(2)\
        -4/71*x(0)*x(1)*x(2)
     ==> 
     // Now treat a matrix in Macaulay format. Using the execute
     // command, this could be assinged to a Singular matrix as above.
     string s2 = "
     0  0  0  0  0
     a3 0  0  0  0
     0  b3 0  0  0
     0  0  c3 0  0
     0  0  0  d3 0
     0  0  0  0  e3 ";
     rMacaulay(s2);
     ==> 0, 0, 0, 0, 0,
     ==> a3,0, 0, 0, 0,
     ==> 0, b3,0, 0, 0,
     ==> 0, 0, c3,0, 0,
     ==> 0, 0, 0, d3,0,
     ==> 0, 0, 0, 0, e3


File: index.htm,  Node: show,  Next: showrecursive,  Prev: rMacaulay,  Up: inout_lib

D.2.3.5 show
............

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     show(id); id any object of basering or of type ring/qring
     show(R,s); R=ring, s=string (s = name of an object belonging to R)

*Display:*
     display id/s in a compact format together with some information

*Return:*
     no return value

*Note:*
     objects of type string, int, intvec, intmat belong to any ring.  id
     may be a ring or a qring. In this case the minimal polynomial is
     displayed, and, for a qring, also the defining ideal.
     id may be of type list but the list must not contain a ring.
     show(R,s) does not work inside a procedure!

*Example:*
     LIB "inout.lib";
     ring r;
     show(r);
     ==> // ring: (32003),(x,y,z),(dp(3),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ideal i=x^3+y^5-6*z^3,xy,x3-y2;
     show(i,3);            // introduce 3 space tabs before information
     ==>    // ideal, 3 generator(s)
     ==> y5+x3-6z3,
     ==> xy,
     ==> x3-y2
     vector v=x*gen(1)+y*gen(3);
     module m=v,2*v+gen(4);
     list L = i,v,m;
     show(L);
     ==> // list, 3 element(s):
     ==> [1]:
     ==>    // ideal, 3 generator(s)
     ==> y5+x3-6z3,
     ==> xy,
     ==> x3-y2
     ==> [2]:
     ==>    // vector
     ==> [x,0,y]
     ==> [3]:
     ==>    // module, 2 generator(s)
     ==> [x,0,y]
     ==> [2x,0,2y,1]
     ring S=(0,T),(a,b,c,d),ws(1,2,3,4);
     minpoly = T^2+1;
     ideal i=a2+b,c2+T^2*d2; i=std(i);
     qring Q=i;
     show(Q);
     ==> // qring: (0,T),(a,b,c,d),(ws(1,2,3,4),C);
     ==> // minpoly = (T2+1)
     ==> // quotient ring from ideal:
     ==> _[1]=a2+b
     ==> _[2]=c2-d2
     map F=r,a2,b^2,3*c3;
     show(F);
     ==> // i-th variable of preimage ring is mapped to @map[i]
     ==> // @map                 [1]  map from r
     ==> @map[1]=a2
     ==> @map[2]=b2
     ==> @map[3]=3*c3
     // Apply 'show' to i (which does not belong to the basering) by typing
     // ring r; ideal i=xy,x3-y2; ring Q; show(r,"i");


File: index.htm,  Node: showrecursive,  Next: split,  Prev: show,  Up: inout_lib

D.2.3.6 showrecursive
.....................

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     showrecursive(id,p[ord]); id= any object of basering, p= product of
     variables and ord=string (any allowed ordstr)

*Display:*
     display 'id' in a recursive format as a polynomial in the variables
     occurring in p with coefficients in the remaining variables. This
     is done by mapping to a ring with parameters [and ordering 'ord',
     if a 3rd argument is present (default: ord="dp")] and applying
     procedure 'show'

*Return:*
     no return value

*Example:*
     LIB "inout.lib";
     ring r=2,(a,b,c,d,x,y),ds;
     poly f=y+ax2+bx3+cx2y2+dxy3;
     showrecursive(f,x);
     ==> // poly, 4 monomial(s)
     ==> (b)*x3+(a+cy2)*x2+(dy3)*x+(y)
     showrecursive(f,xy,"lp");
     ==> // poly, 5 monomial(s)
     ==> (b)*x3+(c)*x2y2+(a)*x2+(d)*xy3+y


File: index.htm,  Node: split,  Next: tab,  Prev: showrecursive,  Up: inout_lib

D.2.3.7 split
.............

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     split(s[,n]); s string, n integer

*Return:*
     same string, split into lines of length n separated by \ (default:
     n=pagewidth)

*Note:*
     may be used in connection with lprint

*Example:*
     LIB "inout.lib";
     ring r= 0,(x,y,z),ds;
     poly f = (x+y+z)^4;
     split(string(f),50);
     ==> x4+4x3y+6x2y2+4xy3+y4+4x3z+12x2yz+12xy2z+4y3z+6x\
     ==> 2z2+12xyz2+6y2z2+4xz3+4yz3+z4
     split(lprint(f));
     ==>   x4+4x3y+6x2y2+4xy3+y4+4x3z+12x2yz+12xy2z+4y3z+6x2z2+12xyz2+6y2z2+4xz3+4\
        yz3\
     ==> +z4


File: index.htm,  Node: tab,  Next: writelist,  Prev: split,  Up: inout_lib

D.2.3.8 tab
...........

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     tab(n); n integer

*Return:*
     string of n space tabs

*Example:*
     LIB "inout.lib";
     for(int n=0; n<=5; n=n+1)
     { tab(5-n)+"*"+tab(n)+"+"+tab(n)+"*"; }
     ==>      *+*
     ==>     * + *
     ==>    *  +  *
     ==>   *   +   *
     ==>  *    +    *
     ==> *     +     *


File: index.htm,  Node: writelist,  Next: pause,  Prev: tab,  Up: inout_lib

D.2.3.9 writelist
.................

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     writelist(file,name,L); file,name strings (file-name, list-name), L
     a list.

*Create:*
     a file with name `file`, write the content of the list L into it
     and call the list `name`, keeping the list structure

*Return:*
     no return value

*Note:*
     The syntax of writelist uses and is similar to the syntax of the
     write command of Singular which does not manage lists properly.  If
     (file,name) = ("listfile","L1"), writelist creates (resp.  appends
     if listfile exists) a file with name listfile and stores there the
     list L under the name L1. The Singular command
     execute(read("listfile")); assigns the content of L (stored in
     listfile) to a list L1.
     On a UNIX system, write(">file",...) overwrites an existing file
     `file` while write("file",...) and write(">>file",...) append.

*Example:*
     LIB "inout.lib";
     ring r;
     ideal i=x,y,z;
     list k="Hi",nameof(basering),i,37;
     writelist("zumSpass","lustig",k);
     read("zumSpass");
     ==> list lustig;
     ==>    lustig[1]=
     ==> Hi;
     ==>    lustig[2]=
     ==> r;
     ==>    lustig[3]=
     ==> x,y,z;
     ==>    lustig[4]=
     ==> 37;
     ==> 
     list L=res(i,0);                    //resolution of the ideal i
     writelist("res_list","res-name",L); "";
     ==> 
     read("res_list");
     ==> list res-name;
     ==>    res-name[1]=
     ==> z,y,x;
     ==>    res-name[2]=
     ==> -y*gen(1)+z*gen(2),-x*gen(1)+z*gen(3),-x*gen(2)+y*gen(3);
     ==>    res-name[3]=
     ==> x*gen(1)-y*gen(2)+z*gen(3);
     ==> 
     // execute(read("res_list")); would create a list with name res-name,
     // which is the resolution of i (the same content as L)
     system("sh","/bin/rm res_list zumSpass");
     ==> 0
     // Under UNIX, this removes the files 'res_list' and 'zumSpass'
     // Type help system; to get more information about the shell escape
     // If your operating system does not accept the shell escape, you
     // must remove the just created files 'zumSpass' and 'res_list' directly


File: index.htm,  Node: pause,  Prev: writelist,  Up: inout_lib

D.2.3.10 pause
..............

Procedure from library `inout.lib' (*note inout_lib::).

*Usage:*
     pause([ prompt ]) prompt string

*Return:*
     none

*Purpose:*
     interrupt the execution of commands until user input

*Note:*
     pause is useful in procedures in connection with printlevel to
     interrupt the computation and to display intermediate results.

*Example:*
     LIB "inout.lib";
     // can only be shown interactively, try the following commands:
     // pause("press <return> to continue");
     // pause();
     // In the following pocedure TTT, xxx is printed and the execution of
     // TTT is stopped until the return-key is pressed, if printlevel>0.
     // xxx may be any result of a previous computation or a comment, etc:
     //
     // proc TTT
     // { int pp = printlevel-voice+2;  //pp=0 if printlevel=0 and if TTT is
     //    ....                         //not called from another procedure
     //    if( pp>0 )
     //    {
     //       print( xxx );
     //       pause("press <return> to continue");
     //    }
     //     ....
     // }

* Menu:

See also:
* printlevel::
* read::

*See also:* *note printlevel::; *note read::.


File: index.htm,  Node: poly_lib,  Next: random_lib,  Prev: inout_lib,  Up: General purpose

D.2.4 poly_lib
--------------

*Library:*
     poly.lib

*Purpose:*
     Procedures for Manipulating Polys, Ideals, Modules

*Authors:*
     O. Bachmann, G.-M: Greuel, A. Fruehbis

*Procedures:*

* Menu:

* cyclic:: ideal of cyclic n-roots
* katsura:: katsura [i] ideal
* freerank:: rank of coker(input) if coker is free else -1
* is_homog:: int, =1 resp. =0 if input is homogeneous resp. not
* is_zero:: int, =1 resp. =0 if coker(input) is 0 resp. not
* lcm:: lcm of given generators of ideal
* maxcoef:: maximal length of coefficient occurring in poly/...
* maxdeg:: int/intmat = degree/s of terms of maximal order
* maxdeg1:: int = [weighted] maximal degree of input
* mindeg:: int/intmat = degree/s of terms of minimal order
* mindeg1:: int = [weighted] minimal degree of input
* normalize:: normalize poly/... such that leading coefficient is 1
* rad_con:: check radical containment of poly p in ideal I
* content:: content of polynomial/vector f
* numerator:: numerator of number n
* denominator:: denominator of number n
* mod2id:: conversion of a module M to an ideal
* id2mod:: conversion inverse to mod2id
* substitute:: substitute in I variables by polynomials
* subrInterred:: interred w.r.t. a subset of variables
* hilbPoly:: Hilbert polynomial of basering/I


File: index.htm,  Node: cyclic,  Next: katsura,  Up: poly_lib

D.2.4.1 cyclic
..............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     cyclic(n); n integer

*Return:*
     ideal of cyclic n-roots from 1-st n variables of basering

*Example:*
     LIB "poly.lib";
     ring r=0,(u,v,w,x,y,z),lp;
     cyclic(nvars(basering));
     ==> _[1]=u+v+w+x+y+z
     ==> _[2]=uv+uz+vw+wx+xy+yz
     ==> _[3]=uvw+uvz+uyz+vwx+wxy+xyz
     ==> _[4]=uvwx+uvwz+uvyz+uxyz+vwxy+wxyz
     ==> _[5]=uvwxy+uvwxz+uvwyz+uvxyz+uwxyz+vwxyz
     ==> _[6]=uvwxyz-1
     homog(cyclic(5),z);
     ==> _[1]=u+v+w+x+y
     ==> _[2]=uv+uy+vw+wx+xy
     ==> _[3]=uvw+uvy+uxy+vwx+wxy
     ==> _[4]=uvwx+uvwy+uvxy+uwxy+vwxy
     ==> _[5]=uvwxy-z5


File: index.htm,  Node: katsura,  Next: freerank,  Prev: cyclic,  Up: poly_lib

D.2.4.2 katsura
...............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     katsura([n]): n integer

*Return:*
     katsura(n) : n-th katsura ideal of
     (1) newly created and set ring (32003, x(0..n), dp), if
     nvars(basering) < n
     (2) basering, if nvars(basering) >= n
     katsura() : katsura ideal of basering

*Example:*
     LIB "poly.lib";
     ring r; basering;
     ==> //   characteristic : 32003
     ==> //   number of vars : 3
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y z 
     ==> //        block   2 : ordering C
     katsura();
     ==> _[1]=x+2y+2z-1
     ==> _[2]=x2+2y2+2z2-x
     ==> _[3]=2xy+2yz-y
     katsura(4); basering;
     ==> _[1]=x(0)+2*x(1)+2*x(2)+2*x(3)-1
     ==> _[2]=x(0)^2+2*x(1)^2+2*x(2)^2+2*x(3)^2-x(0)
     ==> _[3]=2*x(0)*x(1)+2*x(1)*x(2)+2*x(2)*x(3)-x(1)
     ==> _[4]=x(1)^2+2*x(0)*x(2)+2*x(1)*x(3)-x(2)
     ==> //   characteristic : 32003
     ==> //   number of vars : 5
     ==> //        block   1 : ordering dp
     ==> //                  : names    x(0) x(1) x(2) x(3) x(4) 
     ==> //        block   2 : ordering C


File: index.htm,  Node: freerank,  Next: is_homog,  Prev: katsura,  Up: poly_lib

D.2.4.3 freerank
................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     freerank(M[,any]); M=poly/ideal/vector/module/matrix

*Compute:*
     rank of module presented by M in case it is free.
     By definition this is vdim(coker(M)/m*coker(M)) if coker(M) is
     free, where m = maximal ideal of the variables of the basering and
     M is considered as matrix.
     (the 0-module is free of rank 0)

*Return:*
     rank of coker(M) if coker(M) is free and -1 else;
     in case of a second argument return a list:
     L[1] = rank of coker(M) or -1
     L[2] = minbase(M)

*Note:*
     freerank(syz(M)); computes the rank of M if M is free (and -1 else)

*Example:*
     LIB "poly.lib";
     ring r;
     ideal i=x;
     module M=[x,0,1],[-x,0,-1];
     freerank(M);          // should be 2, coker(M) is not free
     ==> 2
     freerank(syz (M),"");
     ==> [1]:
     ==>    1
     ==> [2]:
     ==>    _[1]=gen(2)+gen(1)
     // [1] should be 1, coker(syz(M))=M is free of rank 1
     // [2] should be gen(2)+gen(1) (minimal relation of M)
     freerank(i);
     ==> -1
     freerank(syz(i));     // should be 1, coker(syz(i))=i is free of rank 1
     ==> 1


File: index.htm,  Node: is_homog,  Next: is_zero,  Prev: freerank,  Up: poly_lib

D.2.4.4 is_homog
................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     is_homog(id); id poly/ideal/vector/module/matrix

*Return:*
     integer which is 1 if input is homogeneous (resp. weighted
     homogeneous if the monomial ordering consists of one block of type
     ws,Ws,wp or Wp, assuming that all weights are positive) and 0
     otherwise

*Note:*
     A vector is homogeneous, if the components are homogeneous of same
     degree, a module/matrix is homogeneous if all column vectors are
     homogeneous
     //*** ergaenzen, wenn Matrizen-Spalten Gewichte haben

*Example:*
     LIB "poly.lib";
     ring r = 0,(x,y,z),wp(1,2,3);
     is_homog(x5-yz+y3);
     ==> 0
     ideal i = x6+y3+z2, x9-z3;
     is_homog(i);
     ==> 1
     ring s = 0,(a,b,c),ds;
     vector v = [a2,0,ac+bc];
     vector w = [a3,b3,c4];
     is_homog(v);
     ==> 1
     is_homog(w);
     ==> 0


File: index.htm,  Node: is_zero,  Next: lcm,  Prev: is_homog,  Up: poly_lib

D.2.4.5 is_zero
...............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     is_zero(M[,any]); M=poly/ideal/vector/module/matrix

*Return:*
     integer, 1 if coker(M)=0 resp. 0 if coker(M)!=0, where M is
     considered as matrix.
     If a second argument is given, return a list:
     L[1] = 1 if coker(M)=0 resp. 0 if coker(M)!=0
     L[2] = dim(M)

*Example:*
     LIB "poly.lib";
     ring r;
     module m = [x],[y],[1,z];
     is_zero(m,1);
     ==> [1]:
     ==>    0
     ==> [2]:
     ==>    2
     qring q = std(ideal(x2+y3+z2));
     ideal j = x2+y3+z2-37;
     is_zero(j);
     ==> 1


File: index.htm,  Node: lcm,  Next: maxcoef,  Prev: is_zero,  Up: poly_lib

D.2.4.6 lcm
...........

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     lcm(p[,q]); p int/intvec q a list of integers or
     p poly/ideal q a list of polynomials

*Return:*
     the least common multiple of the common entries of p and q:
     - of type int if p is an int/intvec
     - of type poly if p is a poly/ideal

*Example:*
     LIB "poly.lib";
     ring  r = 0,(x,y,z),lp;
     poly  p = (x+y)*(y+z);
     poly  q = (z4+2)*(y+z);
     lcm(p,q);
     ==> xyz4+2xy+xz5+2xz+y2z4+2y2+yz5+2yz
     ideal i=p,q,y+z;
     lcm(i,p);
     ==> xyz4+2xy+xz5+2xz+y2z4+2y2+yz5+2yz
     lcm(2,3,6);
     ==> 6
     lcm(2..6);
     ==> 60


File: index.htm,  Node: maxcoef,  Next: maxdeg,  Prev: lcm,  Up: poly_lib

D.2.4.7 maxcoef
...............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     maxcoef(f); f poly/ideal/vector/module/matrix

*Return:*
     maximal length of coefficient of f of type int (by counting the
     length of the string of each coefficient)

*Example:*
     LIB "poly.lib";
     ring r= 0,(x,y,z),ds;
     poly g = 345x2-1234567890y+7/4z;
     maxcoef(g);
     ==> 10
     ideal i = g,10/1234567890;
     maxcoef(i);
     ==> 11
     // since i[2]=1/123456789


File: index.htm,  Node: maxdeg,  Next: maxdeg1,  Prev: maxcoef,  Up: poly_lib

D.2.4.8 maxdeg
..............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     maxdeg(id); id poly/ideal/vector/module/matrix

*Return:*
     int/intmat, each component equals maximal degree of monomials in
     the corresponding component of id, independent of ring ordering
     (maxdeg of each var is 1).
     Of type int if id is of type poly, of type intmat else

*Note:*
     proc maxdeg1 returns 1 integer, the absolute maximum; moreover, it
     has an option for computing weighted degrees

*Example:*
     LIB "poly.lib";
     ring r = 0,(x,y,z),wp(1,2,3);
     poly f = x+y2+z3;
     deg(f);             //deg; returns weighted degree (in case of 1 block)!
     ==> 9
     maxdeg(f);
     ==> 3
     matrix m[2][2]=f+x10,1,0,f^2;
     maxdeg(m);
     ==> 10,0,
     ==> -1,6 


File: index.htm,  Node: maxdeg1,  Next: mindeg,  Prev: maxdeg,  Up: poly_lib

D.2.4.9 maxdeg1
...............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     maxdeg1(id[,v]); id=poly/ideal/vector/module/matrix, v=intvec

*Return:*
     integer, maximal [weighted] degree of monomials of id independent
     of ring ordering, maxdeg1 of i-th variable is v[i] (default:
     v=1..1).

*Note:*
     This proc returns one integer while maxdeg returns, in general, a
     matrix of integers. For one polynomial and if no intvec v is given
     maxdeg is faster

*Example:*
     LIB "poly.lib";
     ring r = 0,(x,y,z),wp(1,2,3);
     poly f = x+y2+z3;
     deg(f);            //deg returns weighted degree (in case of 1 block)!
     ==> 9
     maxdeg1(f);
     ==> 3
     intvec v = ringweights(r);
     maxdeg1(f,v);                        //weighted maximal degree
     ==> 9
     matrix m[2][2]=f+x10,1,0,f^2;
     maxdeg1(m,v);                        //absolute weighted maximal degree
     ==> 18


File: index.htm,  Node: mindeg,  Next: mindeg1,  Prev: maxdeg1,  Up: poly_lib

D.2.4.10 mindeg
...............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     mindeg(id); id poly/ideal/vector/module/matrix

*Return:*
     minimal degree/s of monomials of id, independent of ring ordering
     (mindeg of each variable is 1) of type int if id of type poly, else
     of type intmat.

*Note:*
     proc mindeg1 returns one integer, the absolute minimum; moreover it
     has an option for computing weighted degrees.

*Example:*
     LIB "poly.lib";
     ring r = 0,(x,y,z),ls;
     poly f = x5+y2+z3;
     ord(f);                  // ord returns weighted order of leading term!
     ==> 3
     mindeg(f);               // computes minimal degree
     ==> 2
     matrix m[2][2]=x10,1,0,f^2;
     mindeg(m);               // computes matrix of minimum degrees
     ==> 10,0,
     ==> -1,4 


File: index.htm,  Node: mindeg1,  Next: normalize,  Prev: mindeg,  Up: poly_lib

D.2.4.11 mindeg1
................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     mindeg1(id[,v]); id=poly/ideal/vector/module/matrix, v=intvec

*Return:*
     integer, minimal [weighted] degree of monomials of id independent
     of ring ordering, mindeg1 of i-th variable is v[i] (default
     v=1..1).

*Note:*
     This proc returns one integer while mindeg returns, in general, a
     matrix of integers. For one polynomial and if no intvec v is given
     mindeg is faster.

*Example:*
     LIB "poly.lib";
     ring r = 0,(x,y,z),ls;
     poly f = x5+y2+z3;
     ord(f);                  // ord returns weighted order of leading term!
     ==> 3
     intvec v = 1,-3,2;
     mindeg1(f,v);            // computes minimal weighted degree
     ==> -6
     matrix m[2][2]=x10,1,0,f^2;
     mindeg1(m,1..3);         // computes absolute minimum of weighted degrees
     ==> -1


File: index.htm,  Node: normalize,  Next: rad_con,  Prev: mindeg1,  Up: poly_lib

D.2.4.12 normalize
..................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     normalize(id); id=poly/vector/ideal/module

*Return:*
     object of same type with leading coefficient equal to 1

*Example:*
     LIB "poly.lib";
     ring r = 0,(x,y,z),ls;
     poly f = 2x5+3y2+4z3;
     normalize(f);
     ==> z3+3/4y2+1/2x5
     module m=[9xy,0,3z3],[4z,6y,2x];
     normalize(m);
     ==> _[1]=z3*gen(3)+3xy*gen(1)
     ==> _[2]=z*gen(1)+3/2y*gen(2)+1/2x*gen(3)
     ring s = 0,(x,y,z),(c,ls);
     module m=[9xy,0,3z3],[4z,6y,2x];
     normalize(m);
     ==> _[1]=[xy,0,1/3z3]
     ==> _[2]=[z,3/2y,1/2x]


File: index.htm,  Node: rad_con,  Next: content,  Prev: normalize,  Up: poly_lib

D.2.4.13 rad_con
................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     rad_con(g,I); g polynomial, I ideal

*Return:*
     1 (TRUE) (type int) if g is contained in the radical of I
     0 (FALSE) (type int) otherwise

*Example:*
     LIB "poly.lib";
     ring R=0,(x,y,z),dp;
     ideal I=x2+y2,z2;
     poly f=x4+y4;
     rad_con(f,I);
     ==> 0
     ideal J=x2+y2,z2,x4+y4;
     poly g=z;
     rad_con(g,I);
     ==> 1


File: index.htm,  Node: content,  Next: numerator,  Prev: rad_con,  Up: poly_lib

D.2.4.14 content
................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     content(f); f polynomial/vector

*Return:*
     number, the content (greatest common factor of coefficients) of the
     polynomial/vector f

*Example:*
     LIB "poly.lib";
     ring r=0,(x,y,z),(c,lp);
     content(3x2+18xy-27xyz);
     ==> 3
     vector v=[3x2+18xy-27xyz,15x2+12y4,3];
     content(v);
     ==> 3


File: index.htm,  Node: numerator,  Next: denominator,  Prev: content,  Up: poly_lib

D.2.4.15 numerator
..................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     numerator(n); n number

*Return:*
     number, the numerator of n

*Example:*
     LIB "poly.lib";
     ring r = 0,x, dp;
     number n = 3/2;
     numerator(n);
     ==> 3

* Menu:

See also:
* cleardenom::
* content::
* denominator::

*See also:* *note cleardenom::; *note content::; *note denominator::.


File: index.htm,  Node: denominator,  Next: mod2id,  Prev: numerator,  Up: poly_lib

D.2.4.16 denominator
....................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     denominator(n); n number

*Return:*
     number, the denominator of n

*Example:*
     LIB "poly.lib";
     ring r = 0,x, dp;
     number n = 3/2;
     denominator(n);
     ==> 2

* Menu:

See also:
* cleardenom::
* content::
* denominator::

*See also:* *note cleardenom::; *note content::; *note denominator::.


File: index.htm,  Node: mod2id,  Next: id2mod,  Prev: denominator,  Up: poly_lib

D.2.4.17 mod2id
...............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     mod2id(M,vpos); M matrix, vpos intvec

*Assume:*
     vpos is an integer vector such that gen(i) corresponds to
     var(vpos[i]).
     The basering contains variables var(vpos[i]) which do not occur in
     M.

*Return:*
     ideal I in which each gen(i) from the module is replaced by
     var(vpos[i]) and all monomials var(vpos[i])*var(vpos[j]) have been
     added to the generating set of I.

*Note:*
     This procedure should be used in the following situation: one wants
     to pass to a ring with new variables, say e(1),..,e(s), which
     correspond to the components gen(1),..,gen(s) of the module M such
     that e(i)*e(j)=0 for all i,j.
     The new ring should already exist and be the current ring

*Example:*
     LIB "poly.lib";
     ring r=0,(e(1),e(2),x,y,z),(dp(2),ds(3));
     module mo=x*gen(1)+y*gen(2);
     intvec iv=2,1;
     mod2id(mo,iv);
     ==> _[1]=e(2)^2
     ==> _[2]=e(1)*e(2)
     ==> _[3]=e(1)^2
     ==> _[4]=e(1)*y+e(2)*x


File: index.htm,  Node: id2mod,  Next: substitute,  Prev: mod2id,  Up: poly_lib

D.2.4.18 id2mod
...............

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     id2mod(I,vpos); I ideal, vpos intvec

*Return:*
     module corresponding to the ideal by replacing var(vpos[i]) by
     gen(i) and omitting all generators var(vpos[i])*var(vpos[j])

*Note:*
     * This procedure only makes sense if the ideal contains all
     var(vpos[i])*var(vpos[j]) as monomial generators and all other
     generators of I are linear combinations of the var(vpos[i]) over
     the ring in the other variables.
     * This is the inverse procedure to mod2id and should be applied
     only to ideals created by mod2id using the same intvec vpos
     (possibly after a standard basis computation)

*Example:*
     LIB "poly.lib";
     ring r=0,(e(1),e(2),x,y,z),(dp(2),ds(3));
     ideal i=e(2)^2,e(1)*e(2),e(1)^2,e(1)*y+e(2)*x;
     intvec iv=2,1;
     id2mod(i,iv);
     ==> _[1]=x*gen(1)+y*gen(2)


File: index.htm,  Node: substitute,  Next: subrInterred,  Prev: id2mod,  Up: poly_lib

D.2.4.19 substitute
...................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     - case 1: typeof(#[1])==poly:
     substitute (I,v,f[,v1,f1,v2,f2,...]); I object of basering which
     can be mapped, v,v1,v2,.. ring variables, f,f1,f2,... poly
     - case 2: typeof(#[1])==ideal: substitute1 (I,v,f); I object of
     basering which can be mapped, v ideal of ring variables, f ideal

*Return:*
     object of same type as I,
     - case 1: ring variable v,v1,v2,... substituted by polynomials
     f,f1,f2,..., in this order
     - case 2: ring variables in v substituted by polynomials in f: v[i]
     is substituted by f[i], i=1,...,i=min(size(v),ncols(f))

*Note:*
     this procedure extends the built-in command subst which substitutes
     ring variables only by monomials

*Example:*
     LIB "poly.lib";
     ring r = 0,(b,c,t),dp;
     ideal I = -bc+4b2c2t,bc2t-5b2c;
     substitute(I,c,b+c,t,0,b,b-1);
     ==> _[1]=-b2-bc+2b+c-1
     ==> _[2]=-5b3-5b2c+15b2+10bc-15b-5c+5
     ideal v = c,t,b;
     ideal f = b+c,0,b-1;
     substitute(I,v,f);
     ==> _[1]=-b2-bc+2b+c-1
     ==> _[2]=-5b3-5b2c+15b2+10bc-15b-5c+5


File: index.htm,  Node: subrInterred,  Next: hilbPoly,  Prev: substitute,  Up: poly_lib

D.2.4.20 subrInterred
.....................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     subrInterred(mon,sm,iv);
     sm: ideal in a ring r with n + s variables,
     e.g. x_1,..,x_n and t_1,..,t_s
     mon: ideal with monomial generators (not divisible by any of the
     t_i) such that sm is contained in the module
     k[t_1,..,t_s]*mon[1]+..+k[t_1,..,t_s]*mon[size(mon)]
     iv: intvec listing the variables which are supposed to be used as
     x_i

*Return:*
     list l:
     l[1]=the monomials from mon in the order used
     l[2]=their coefficients after interreduction
     l[3]=l[1]*l[2]

*Purpose:*
     Do interred only w.r.t. a subset of variables.
     The procedure returns an interreduced system of generators of sm
     considered as a k[t_1,..,t_s]-submodule of the free module
     k[t_1,..,t_s]*mon[1]+..+k[t_1,..,t_s]*mon[size(mon)]).

*Example:*
     LIB "poly.lib";
     ring r=0,(x,y,z),dp;
     ideal i=x^2+x*y^2,x*y+x^2*y,z;
     ideal j=x^2+x*y^2,x*y,z;
     ideal mon=x^2,z,x*y;
     intvec iv=1,3;
     subrInterred(mon,i,iv);
     ==> [1]:
     ==>    _[1,1]=z
     ==>    _[1,2]=xy
     ==>    _[1,3]=x2
     ==> [2]:
     ==>    _[1]=gen(1)
     ==>    _[2]=y2*gen(2)-gen(2)
     ==>    _[3]=y*gen(2)+gen(3)
     ==> [3]:
     ==>    _[1,1]=z
     ==>    _[1,2]=xy3-xy
     ==>    _[1,3]=xy2+x2
     subrInterred(mon,j,iv);
     ==> [1]:
     ==>    _[1,1]=z
     ==>    _[1,2]=xy
     ==>    _[1,3]=x2
     ==> [2]:
     ==>    _[1]=gen(1)
     ==>    _[2]=gen(2)
     ==>    _[3]=gen(3)
     ==> [3]:
     ==>    _[1,1]=z
     ==>    _[1,2]=xy
     ==>    _[1,3]=x2


File: index.htm,  Node: hilbPoly,  Prev: subrInterred,  Up: poly_lib

D.2.4.21 hilbPoly
.................

Procedure from library `poly.lib' (*note poly_lib::).

*Usage:*
     hilbPoly(I) I a homogeneous ideal

*Return:*
     the Hilbert polynomial of basering/I as an intvec v=v_0,...,v_r
     such that the Hilbert polynomial is (v_0+v_1*t+...v_r*t^r)/r!

*Example:*
     LIB "poly.lib";
     ring r = 0,(b,c,t,h),dp;
     ideal I=
     bct-t2h+2th2+h3,
     bt3-ct3-t4+b2th+c2th-2bt2h+2ct2h+2t3h-bch2-2bth2+2cth2+2th3,
     b2c2+bt2h-ct2h-t3h+b2h2+2bch2+c2h2-2bth2+2cth2+t2h2-2bh3+2ch3+2th3+3h4,
     c2t3+ct4-c3th-2c2t2h-2ct3h-t4h+bc2h2-2c2th2-bt2h2+4t3h2+2bth3-2cth3-t2h3
     +bh4-6th4-2h5;
     hilbPoly(I);
     ==> -11,10


File: index.htm,  Node: random_lib,  Next: ring_lib,  Prev: poly_lib,  Up: General purpose

D.2.5 random_lib
----------------

*Library:*
     random.lib

*Purpose:*
     Creating Random and Sparse Matrices, Ideals, Polys

*Procedures:*

* Menu:

* genericid:: generic sparse linear combinations of generators of i
* randomid:: random linear combinations of generators of id
* randommat:: nxm matrix of random linear combinations of id
* sparseid:: ideal of k random sparse poly's of degree d [u<=d<=o]
* sparsematrix:: nxm sparse matrix of polynomials of degree<=o
* sparsemat:: nxm sparse integer matrix with random coefficients
* sparsepoly:: random sparse polynomial with terms of degree in [u,o]
* sparsetriag:: nxm sparse lower-triag intmat with random coefficients
* triagmatrix:: nxm sparse lower-triag matrix of poly's of degree<=o
* randomLast:: random transformation of the last variable
* randomBinomial:: binomial ideal, k random generators of degree >=u


File: index.htm,  Node: genericid,  Next: randomid,  Up: random_lib

D.2.5.1 genericid
.................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     genericid(id,[,p,b]); id ideal/module, k,p,b integers

*Return:*
     system of generators of id which are generic, sparse, triagonal
     linear combinations of given generators with coefficients in [1,b]
     and sparseness p percent, bigger p being sparser (default: p=75,
     b=30000)

*Note:*
     For performance reasons try small bound b in characteristic 0

*Example:*
     LIB "random.lib";
     ring r=0,(t,x,y,z),ds;
     ideal i= x3+y4,z4+yx,t+x+y+z;
     genericid(i,0,10);
     ==> _[1]=3t+3x+3y+3z+2xy+x3+y4+2z4
     ==> _[2]=4t+4x+4y+4z+xy+z4
     ==> _[3]=t+x+y+z
     module m=[x,0,0,0],[0,y2,0,0],[0,0,z3,0],[0,0,0,t4];
     print(genericid(m));
     ==> x,      0,      0, 0,
     ==> 17904y2,y2,     0, 0,
     ==> 0,      24170z3,z3,0,
     ==> 0,      0,      0, t4


File: index.htm,  Node: randomid,  Next: randommat,  Prev: genericid,  Up: random_lib

D.2.5.2 randomid
................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     randomid(id,[k,b]); id ideal/module, b,k integers

*Return:*
     ideal/module having k generators which are random linear
     combinations of generators of id with coefficients in the interval
     [-b,b] (default: b=30000, k=size(id))

*Note:*
     For performance reasons try small bound b in characteristic 0

*Example:*
     LIB "random.lib";
     ring r=0,(x,y,z),dp;
     randomid(maxideal(2),2,9);
     ==> _[1]=-5x2-9xy+6y2-8xz-8yz+4z2
     ==> _[2]=-9xy+2y2+xz+yz-z2
     module m=[x,0,1],[0,y2,0],[y,0,z3];
     show(randomid(m));
     ==> // module, 3 generator(s)
     ==> [1369x-11685y,-4481y2,-11685z3+1369]
     ==> [-642x-13756y,25342y2,-13756z3-642]
     ==> [2536x-6355y,8285y2,-6355z3+2536]


File: index.htm,  Node: randommat,  Next: sparseid,  Prev: randomid,  Up: random_lib

D.2.5.3 randommat
.................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     randommat(n,m[,id,b]); n,m,b integers, id ideal

*Return:*
     nxm matrix, entries are random linear combinations of elements of
     id and coefficients in [-b,b]
     [default: (id,b) = (maxideal(1),30000)]

*Note:*
     For performance reasons try small bound b in char 0

*Example:*
     LIB "random.lib";
     ring r=0,(x,y,z),dp;
     matrix A=randommat(3,3,maxideal(2),9);
     print(A);
     ==> 9x2-2xy-8y2-9xz+yz+4z2, 9x2-4xy+y2-5xz+6yz-z2,   8x2+xy-9y2+2yz-8z2,    
     ==> -x2+5xy-8y2-7xz+4yz-3z2,x2+xy-4y2-xz+5z2,        5x2-8xy+8y2+6xz+yz+7z2,
     ==> 4x2-5xy-6y2-4yz-5z2,    -4x2-6xy-4y2-8xz+3yz+5z2,2x2+3xy+y2+4xz-3yz+2z2 
     A=randommat(2,3);
     print(A);
     ==> 15276x+9897y+7526z,  6495x-24178y+11295z,-5745x-14754y+15979z,
     ==> 20788x-28366y-20283z,24911x-10978y+3341z,12412x+11216y+15344z 


File: index.htm,  Node: sparseid,  Next: sparsematrix,  Prev: randommat,  Up: random_lib

D.2.5.4 sparseid
................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     sparseid(k,u[,o,p,b]); k,u,o,p,b integers

*Return:*
     ideal having k generators, each of degree d, u<=d<=o, p percent of
     terms in degree d are 0, the remaining have random coefficients in
     the interval [1,b], (default: o=u=d, p=75, b=30000)

*Example:*
     LIB "random.lib";
     ring r = 0,(a,b,c,d),ds;
     sparseid(2,3);"";
     ==> _[1]=12773a3+24263a2c+20030abc+17904b2c+26359c3
     ==> _[2]=24004a3+6204b2c+24170bc2+19505c2d+21962bd2
     ==> 
     sparseid(3,0,4,90,9);
     ==> _[1]=1+4a2+8b2c+3c3+4a3b+4a2b2+5abc2+3ac3
     ==> _[2]=a+a2+7ab2+6a2c+3c3+5a3b+9ab3+2c4+3c3d+8ad3
     ==> _[3]=5a+ab+2ac2+2b3c+8abcd


File: index.htm,  Node: sparsematrix,  Next: sparsemat,  Prev: sparseid,  Up: random_lib

D.2.5.5 sparsematrix
....................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     sparsematrix(n,m,o[,u,pe,pp,b]); n,m,o,u,pe,pp,b integers

*Return:*
     nxm matrix, about pe percent of the entries are 0, the remaining
     are random polynomials of degree d, u<=d<=o, with pp percent of the
     terms being 0, the remaining have random coefficients in the
     interval [1,b] [default: (pe,u,pp,b) = (0,50,75,100)]

*Example:*
     LIB "random.lib";
     ring r = 0,(a,b,c,d),dp;
     // sparse matrix of sparse polys of degree <=2:
     print(sparsematrix(3,4,2));"";
     ==> 14ab+20bc+79cd+30b,    32a2+97bc+5b,      0,             0,
     ==> 0,                     0,                 6c2+16b+64c+76,0,
     ==> 17a2+30ab+94bc+19b+45d,88a2+44bc+13d2+31a,59ac,          0 
     ==> 
     // dense matrix of sparse linear forms:
     print(sparsematrix(3,3,1,1,0,55,9));
     ==> 9b+7c+8d,9b+9d,5a,   
     ==> 7c+d,    a+6b, 2b+2d,
     ==> 9a+5b+9c,2a+9d,2d    


File: index.htm,  Node: sparsemat,  Next: sparsepoly,  Prev: sparsematrix,  Up: random_lib

D.2.5.6 sparsemat
.................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     sparsemat(n,m[,p,b]); n,m,p,b integers

*Return:*
     nxm integer matrix, p percent of the entries are 0, the remaining
     are random coefficients >=1 and <= b; [defaults: (p,b) = (75,1)]

*Example:*
     LIB "random.lib";
     sparsemat(5,5);"";
     ==> 0,0,0,0,0,
     ==> 0,1,0,0,1,
     ==> 0,0,0,1,0,
     ==> 0,1,0,0,0,
     ==> 0,1,0,1,1 
     ==> 
     sparsemat(5,5,95);"";
     ==> 1,0,0,0,0,
     ==> 0,0,0,0,0,
     ==> 0,0,0,0,0,
     ==> 0,0,0,0,0,
     ==> 0,0,0,1,0 
     ==> 
     sparsemat(5,5,5);"";
     ==> 1,1,1,1,1,
     ==> 1,1,1,1,1,
     ==> 1,1,1,1,1,
     ==> 1,0,1,1,1,
     ==> 1,1,1,1,0 
     ==> 
     sparsemat(5,5,50,100);
     ==> 0,17,24,80,0,
     ==> 0,13,30,45,0,
     ==> 19,0,0,0,0,
     ==> 93,0,23,0,69,
     ==> 0,88,44,31,0 


File: index.htm,  Node: sparsepoly,  Next: sparsetriag,  Prev: sparsemat,  Up: random_lib

D.2.5.7 sparsepoly
..................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     sparsepoly(u[,o,p,b]); u,o,p,b integers

*Return:*
     poly having only terms in degree d, u<=d<=o, p percent of the terms
     in degree d are 0, the remaining have random coefficients in [1,b),
     (defaults: o=u=d, p=75, b=30000)

*Example:*
     LIB "random.lib";
     ring r=0,(x,y,z),dp;
     sparsepoly(5);"";
     ==> 24263xy4+24170x4z+21962x3yz+26642xy3z+5664xy2z2+17904xz4
     ==> 
     sparsepoly(3,5,90,9);
     ==> 8x3z2+2y3z2+3xyz3+2xy3+yz3+xy2


File: index.htm,  Node: sparsetriag,  Next: triagmatrix,  Prev: sparsepoly,  Up: random_lib

D.2.5.8 sparsetriag
...................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     sparsetriag(n,m[,p,b]); n,m,p,b integers

*Return:*
     nxm lower triagonal integer matrix, diagonal entries equal to 1,
     about p percent of lower diagonal entries are 0, the remaining are
     random integers >=1 and <= b; [defaults: (p,b) = (75,1)]

*Example:*
     LIB "random.lib";
     sparsetriag(5,7);"";
     ==> 1,0,0,0,0,0,0,
     ==> 0,1,0,0,0,0,0,
     ==> 0,1,1,0,0,0,0,
     ==> 0,0,0,1,0,0,0,
     ==> 1,1,0,0,1,0,0 
     ==> 
     sparsetriag(7,5,90);"";
     ==> 1,0,0,0,0,
     ==> 0,1,0,0,0,
     ==> 0,1,1,0,0,
     ==> 0,0,0,1,0,
     ==> 0,0,0,0,1,
     ==> 0,0,0,1,0,
     ==> 0,1,0,0,0 
     ==> 
     sparsetriag(5,5,0);"";
     ==> 1,0,0,0,0,
     ==> 1,1,0,0,0,
     ==> 1,1,1,0,0,
     ==> 1,1,1,1,0,
     ==> 1,1,1,1,1 
     ==> 
     sparsetriag(5,5,50,100);
     ==> 1,0,0,0,0,
     ==> 73,1,0,0,0,
     ==> 0,79,1,0,0,
     ==> 14,0,0,1,0,
     ==> 0,48,23,0,1 


File: index.htm,  Node: triagmatrix,  Next: randomLast,  Prev: sparsetriag,  Up: random_lib

D.2.5.9 triagmatrix
...................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     triagmatrix(n,m,o[,u,pe,pp,b]); n,m,o,u,pe,pp,b integers

*Return:*
     nxm lower triagonal matrix, diagonal entries equal to 1, about p
     percent of lower diagonal entries are 0, the remaining are random
     polynomials of degree d, u<=d<=o, with pp percent of the terms
     being 0, the remaining have random coefficients in the interval
     [1,b] [default: (pe,u,pp,b) = (0,50,75,100)]

*Example:*
     LIB "random.lib";
     ring r = 0,(a,b,c,d),dp;
     // sparse triagonal matrix of sparse polys of degree <=2:
     print(triagmatrix(3,4,2));"";
     ==> 1,                                 0,0,0,
     ==> 52ac+54cd+14c,                     1,0,0,
     ==> 17a2+19b2+45ac+94bc+50b+87c+54d+21,0,1,0 
     ==> 
     // dense triagonal matrix of sparse linear forms:
     print(triagmatrix(3,3,1,1,0,55,9));
     ==> 1,       0,    0,
     ==> 7a+8d,   1,    0,
     ==> 9b+7c+4d,7b+9d,1 


File: index.htm,  Node: randomLast,  Next: randomBinomial,  Prev: triagmatrix,  Up: random_lib

D.2.5.10 randomLast
...................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     randomLast(b); b int

*Return:*
     ideal = maxideal(1), but the last variable is exchanged by a random
     linear combination of all variables, with coefficients in the
     interval [-b,b].

*Example:*
     LIB "random.lib";
     ring  r = 0,(x,y,z),lp;
     ideal i = randomLast(10);
     i;
     ==> i[1]=x
     ==> i[2]=y
     ==> i[3]=-x+z


File: index.htm,  Node: randomBinomial,  Prev: randomLast,  Up: random_lib

D.2.5.11 randomBinomial
.......................

Procedure from library `random.lib' (*note random_lib::).

*Usage:*
     randomBinomial(k,u[,o,b]); k,u,o,b integers

*Return:*
     binomial ideal, k homogeneous generators of degree d, u<=d<=o, with
     randomly chosen monomials and coefficients in the interval [-b,b]
     (default: u=o, b=10).

*Example:*
     LIB "random.lib";
     ring  r = 0,(x,y,z),lp;
     ideal i = randomBinomial(4,5,6);
     i;
     ==> i[1]=-x4z-xz4
     ==> i[2]=8x2y3+8xy3z
     ==> i[3]=-4x2y2z2-4xy5
     ==> i[4]=5x3yz2+5xz5


File: index.htm,  Node: ring_lib,  Prev: random_lib,  Up: General purpose

D.2.6 ring_lib
--------------

*Library:*
     ring.lib

*Purpose:*
     Manipulating Rings and Maps

*Procedures:*

* Menu:

* changechar:: make a copy R of basering [ring r] with new char c
* changeord:: make a copy R of basering [ring r] with new ord o
* changevar:: make a copy R of basering [ring r] with new vars v
* defring:: define a ring R in specified char c, n vars v, ord o
* defrings:: define ring Sn in n vars, char 32003 [p], ord ds
* defringp:: define ring Pn in n vars, char 32003 [p], ord dp
* extendring:: extend given ring by n vars v, ord o and name it R
* fetchall:: fetch all objects of ring R to basering
* imapall:: imap all objects of ring R to basering
* mapall:: map all objects of ring R via ideal i to basering
* ord_test:: test whether ordering of R is global, local or mixed
* ringtensor:: create ring R, tensor product of rings s,t,...
* ringweights:: intvec of weights of ring variables of ring r


File: index.htm,  Node: changechar,  Next: changeord,  Up: ring_lib

D.2.6.1 changechar
..................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     changechar(newr,c[,r]); newr,c=strings, r=ring

*Create:*
     create a new ring with name `newr` and make it the basering if r is
     an existing ring [default: r=basering].
     The new ring differs from the old ring only in the characteristic.
     If, say, (newr,c) = ("R","0,A") and the ring r exists, the new
     basering will have name R, characteristic 0 and one parameter A.

*Return:*
     No return value

*Note:*
     Works for qrings if map from old_char to new_char is implemented
     This proc uses 'execute' or calls a procedure using 'execute'.  If
     you use it in your own proc, let the local names of your proc start
     with @.

*Example:*
     LIB "ring.lib";
     ring r=0,(x,y,u,v),(dp(2),ds);
     changechar("R","2,A"); R;"";
     ==> // basering is now R
     ==> //   characteristic : 2
     ==> //   1 parameter    : A 
     ==> //   minpoly        : 0
     ==> //   number of vars : 4
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y 
     ==> //        block   2 : ordering ds
     ==> //                  : names    u v 
     ==> //        block   3 : ordering C
     ==> 
     changechar("R1","32003",R); R1;
     ==> // basering is now R1
     ==> //   characteristic : 32003
     ==> //   number of vars : 4
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y 
     ==> //        block   2 : ordering ds
     ==> //                  : names    u v 
     ==> //        block   3 : ordering C
     kill R,R1;
     if(system("with","Namespaces")) {
     if( nameof(Current) == "Ring" ) {
     kill Top::R,Top::R1;
     } else {
     kill Ring::R,Ring::R1;
     }
     }


File: index.htm,  Node: changeord,  Next: changevar,  Prev: changechar,  Up: ring_lib

D.2.6.2 changeord
.................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     changeord(newr,o[,r]); newr,o=strings, r=ring/qring

*Create:*
     create a new ring with name `newr` and make it the basering if r is
     an existing ring/qring [default: r=basering].
     The new ring differs from the old ring only in the ordering. If,
     say, (newr,o) = ("R","wp(2,3),dp") and the ring r exists and has
     >=3 variables, the new basering will have name R and ordering
     wp(2,3),dp.

*Return:*
     No return value

*Note:*
     This proc uses 'execute' or calls a procedure using 'execute'.  If
     you use it in your own proc, let the local names of your proc start
     with @.

*Example:*
     LIB "ring.lib";
     ring r=0,(x,y,u,v),(dp(2),ds);
     changeord("R","wp(2,3),dp"); R; "";
     ==> // basering is now R
     ==> //   characteristic : 0
     ==> //   number of vars : 4
     ==> //        block   1 : ordering wp
     ==> //                  : names    x y 
     ==> //                  : weights  2 3 
     ==> //        block   2 : ordering dp
     ==> //                  : names    u v 
     ==> //        block   3 : ordering C
     ==> 
     ideal i = x^2,y^2-u^3,v;
     qring Q = std(i);
     changeord("Q'","lp",Q); Q';
     ==> // basering is now Q'
     ==> //   characteristic : 0
     ==> //   number of vars : 4
     ==> //        block   1 : ordering lp
     ==> //                  : names    x y u v 
     ==> //        block   2 : ordering C
     ==> // quotient ring from ideal
     ==> _[1]=v
     ==> _[2]=x2
     ==> _[3]=y2-u3
     kill R,Q,Q';
     if(system("with","Namespaces")) {
     if( nameof(Current) == "Ring" ) {
     kill Top::R,Top::Q';
     } else {
     kill Ring::R,Ring::Q';
     }
     }


File: index.htm,  Node: changevar,  Next: defring,  Prev: changeord,  Up: ring_lib

D.2.6.3 changevar
.................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     changevar(newr,vars[,r]); newr,vars=strings, r=ring/qring

*Create:*
     creates a new ring with name `newr` and makes it the basering if r
     is an existing ring/qring [default: r=basering].
     The new ring differs from the old ring only in the variables. If,
     say, (newr,vars) = ("R","t()") and the ring r exists and has n
     variables, the new basering will have name R and variables
     t(1),...,t(n).
     If vars = "a,b,c,d", the new ring will have the variables a,b,c,d.

*Return:*
     No return value

*Note:*
     This procedure is useful in connection with the procedure
     ringtensor, when a conflict between variable names must be avoided.
     This proc uses 'execute' or calls a procedure using 'execute'.  If
     you use it in your own proc, let the local names of your proc start
     with @.

*Example:*
     LIB "ring.lib";
     ring r=0,(x,y,u,v),(dp(2),ds);
     ideal i = x^2,y^2-u^3,v;
     qring Q = std(i);
     setring(r);
     changevar("R","A()"); R; "";
     ==> // basering is now R
     ==> //   characteristic : 0
     ==> //   number of vars : 4
     ==> //        block   1 : ordering dp
     ==> //                  : names    A(1) A(2) 
     ==> //        block   2 : ordering ds
     ==> //                  : names    A(3) A(4) 
     ==> //        block   3 : ordering C
     ==> 
     changevar("Q'","a,b,c,d",Q); Q';
     ==> // basering is now Q'
     ==> //   characteristic : 0
     ==> //   number of vars : 4
     ==> //        block   1 : ordering dp
     ==> //                  : names    a b 
     ==> //        block   2 : ordering ds
     ==> //                  : names    c d 
     ==> //        block   3 : ordering C
     ==> // quotient ring from ideal
     ==> _[1]=d
     ==> _[2]=a2
     ==> _[3]=b2-c3
     kill R,Q,Q';
     if(system("with","Namespaces")) {
     if( nameof(Current) == "Ring" ) {
     kill Top::R,Top::Q';
     } else {
     kill Ring::R,Ring::Q';
     }
     }


File: index.htm,  Node: defring,  Next: defrings,  Prev: changevar,  Up: ring_lib

D.2.6.4 defring
...............

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     defring(s1,s2,n,s3,s4); s1..s4=strings, n=integer

*Create:*
     Define a ring with name 's1', characteristic 's2', ordering 's4'
     and n variables with names derived from s3 and make it the
     basering.  If s3 is a single letter, say s3="a", and if n<=26 then
     a and the following n-1 letters from the alphabet (cyclic order)
     are taken as variables. If n>26 or if s3 is a single letter
     followed by (, say s3="T(", the variables are T(1),...,T(n).

*Return:*
     No return value

*Note:*
     This proc is useful for defining a ring in a procedure.  This proc
     uses 'execute' or calls a procedure using 'execute'.  If you use it
     in your own proc, let the local names of your proc start with @.

*Example:*
     LIB "ring.lib";
     defring("r","0",5,"u","ls"); r; "";
     ==> // basering is now: r
     ==> //   characteristic : 0
     ==> //   number of vars : 5
     ==> //        block   1 : ordering ls
     ==> //                  : names    u v w x y 
     ==> //        block   2 : ordering C
     ==> 
     defring("R","2,A",10,"x(","dp(3),ws(1,2,3),ds"); R;
     ==> // basering is now: R
     ==> //   characteristic : 2
     ==> //   1 parameter    : A 
     ==> //   minpoly        : 0
     ==> //   number of vars : 10
     ==> //        block   1 : ordering dp
     ==> //                  : names    x(1) x(2) x(3) 
     ==> //        block   2 : ordering ws
     ==> //                  : names    x(4) x(5) x(6) 
     ==> //                  : weights     1    2    3 
     ==> //        block   3 : ordering ds
     ==> //                  : names    x(7) x(8) x(9) x(10) 
     ==> //        block   4 : ordering C
     kill r,R;
     if(system("with","Namespaces")) {
     if( nameof(Current) == "Ring" ) {
     kill Top::r,Top::R;
     } else {
     kill Ring::r,Ring::R;
     }
     }


File: index.htm,  Node: defrings,  Next: defringp,  Prev: defring,  Up: ring_lib

D.2.6.5 defrings
................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     defrings(n,[p]); n,p integers

*Create:*
     Defines a ring with name Sn, characteristic p, ordering ds and n
     variables x,y,z,a,b,...if n<=26 (resp. x(1..n) if n>26) and makes
     it the basering (default: p=32003)

*Return:*
     No return value

*Example:*
     LIB "ring.lib";
     defrings(5,0); S5; "";
     ==> // basering is now: ring S5=0,(x,y,z,a,b),ds;
     ==> //   characteristic : 0
     ==> //   number of vars : 5
     ==> //        block   1 : ordering ds
     ==> //                  : names    x y z a b 
     ==> //        block   2 : ordering C
     ==> 
     defrings(30); S30;
     ==> // basering is now: ring S30=32003,x(1..30),ds;
     ==> //   characteristic : 32003
     ==> //   number of vars : 30
     ==> //        block   1 : ordering ds
     ==> //                  : names    x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(\
        9) x(10) x(11) x(12) x(13) x(14) x(15) x(16) x(17) x(18) x(19) x(20) x(21\
        ) x(22) x(23) x(24) x(25) x(26) x(27) x(28) x(29) x(30) 
     ==> //        block   2 : ordering C
     kill S5, S30;
     if(system("with","Namespaces")) {
     if( nameof(Current) == "Ring" ) {
     kill Top::S5,Top::S30;
     } else {
     kill Ring::S5,Ring::S30;
     }
     }


File: index.htm,  Node: defringp,  Next: extendring,  Prev: defrings,  Up: ring_lib

D.2.6.6 defringp
................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     defringp(n,[p]); n,p=integers

*Create:*
     defines a ring with name Pn, characteristic p, ordering dp and n
     variables x,y,z,a,b,...if n<=26 (resp. x(1..n) if n>26) and makes
     it the basering (default: p=32003)

*Return:*
     No return value

*Example:*
     LIB "ring.lib";
     defringp(5,0); P5; "";
     ==> // basering is now: ring P5=0,(x,y,z,a,b),dp;
     ==> //   characteristic : 0
     ==> //   number of vars : 5
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y z a b 
     ==> //        block   2 : ordering C
     ==> 
     defringp(30); P30;
     ==> // basering is now: ring P30=32003,x(1..30),dp;
     ==> //   characteristic : 32003
     ==> //   number of vars : 30
     ==> //        block   1 : ordering dp
     ==> //                  : names    x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(\
        9) x(10) x(11) x(12) x(13) x(14) x(15) x(16) x(17) x(18) x(19) x(20) x(21\
        ) x(22) x(23) x(24) x(25) x(26) x(27) x(28) x(29) x(30) 
     ==> //        block   2 : ordering C
     kill P5, P30;
     if(system("with","Namespaces")) {
     if( nameof(Current) == "Ring" ) {
     kill Top::P5,Top::P30;
     } else {
     kill Ring::P5,Ring::P30;
     }
     }


File: index.htm,  Node: extendring,  Next: fetchall,  Prev: defringp,  Up: ring_lib

D.2.6.7 extendring
..................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     extendring(na,n,va,o[iv,i,r]); na,va,o=strings,
     n,i=integers, r=ring, iv=intvec of positive integers or iv=0

*Create:*
     Define a ring with name `na` which extends the ring r by adding n
     new variables in front of [after, if i!=0] the old variables and
     make it the basering [default: (i,r)=(0,basering)].
     - The characteristic is the characteristic of r.
     - The new vars are derived from va. If va is a single letter, say
     va="T", and if n<=26 then T and the following n-1 letters from
     T..Z..T (resp. T(1..n) if n>26) are taken as additional variables.
     If va is a single letter followed by (, say va="x(", the new
     variables are x(1),...,x(n).
     - The ordering is the product ordering between the ordering of r
     and an ordering derived from `o` [and iv].
     - If o contains a 'c' or a 'C' in front resp. at the end this is
     taken for the whole ordering in front resp. at the end. If o does
     not contain a 'c' or a 'C' the same rule applies to ordstr(r).
     - If no intvec iv is given, or if iv=0, o may be any allowed
     ordstr, like "ds" or "dp(2),wp(1,2,3),Ds(2)" or "ds(a),dp(b),ls" if
     a and b are globally (!) defined integers and if a+b+1<=n.  If,
     however, a and b are local to a proc calling extendring, the intvec
     iv must be used to let extendring know the values of a and b
     - If an intvec iv !=0 is given, iv[1],iv[2],... is taken for the
     1st, 2nd,... block of o, if o contains no substring "w" or "W" i.e.
     no weighted ordering (in the above case o="ds,dp,ls" and iv=a,b).
     If o contains a weighted ordering (only one (!) weighted block is
     allowed) iv[1] is taken as size for the weight-vector, the next
     iv[1] values of iv are taken as weights and the remaining values of
     iv as block-size for the remaining non-weighted blocks.  e.g.
     o="dp,ws,Dp,ds", iv=3,2,3,4,2,5 creates the ordering
     dp(2),ws(2,3,4),Dp(5),ds

*Return:*
     No return value

*Note:*
     This proc is useful for adding deformation parameters.
     This proc uses 'execute' or calls a procedure using 'execute'.  If
     you use it in your own proc, let the local names of your proc start
     with @ (see the file HelpForProc)

*Example:*
     LIB "ring.lib";
     ring r=0,(x,y,z),ds;
     show(r);"";
     ==> // ring: (0),(x,y,z),(ds(3),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> 
     //blocksize is derived from no of vars:
     int t=5;
     extendring("R1",t,"a","dp");         //t global: "dp" -> "dp(5)"
     ==> // basering is now R1
     show(R1); "";
     ==> // ring: (0),(a,b,c,d,e,x,y,z),(dp(5),ds(3),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> 
     extendring("R2",4,"T(","c,dp",1,r);    //"dp" -> "c,..,dp(4)"
     ==> // basering is now R2
     show(R2);"";
     ==> // ring: (0),(x,y,z,T(1),T(2),T(3),T(4)),(c,ds(3),dp(4));
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> 
     //no intvec given, blocksize given: given blocksize is used:
     extendring("R3",4,"T(","dp(2)",0,r);   // "dp(2)" -> "dp(2)"
     ==> // basering is now R3
     show(R3);"";
     ==> // ring: (0),(T(1),T(2),T(3),T(4),x,y,z),(dp(2),ds(5),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> 
     //intvec given: weights and blocksize is derived from given intvec
     //(no specification of a blocksize in the given ordstr is allowed!)
     //if intvec does not cover all given blocks, the last block is used
     //for the remaining variables, if intvec has too many components,
     //the last ones are ignored
     intvec v=3,2,3,4,1,3;
     extendring("R4",10,"A","ds,ws,Dp,dp",v,0,r);
     ==> // basering is now R4
     //v covers 3 blocks: v[1] (=3) : no of components of ws
     //next v[1] values (=v[2..4]) give weights
     //remaining components of v are used for the remaining blocks
     show(R4);
     ==> // ring: (0),(A,B,C,D,E,F,G,H,I,J,x,y,z),(ds(1),ws(2,3,4),Dp(3),dp(3),ds(\
        3),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     kill r,R1,R2,R3,R4;
     if(system("with","Namespaces")) {
     if( nameof(Current) == "Ring" ) {
     kill Top::R1,Top::R2,Top::R3,Top::R4;
     } else {
     kill Ring::R1,Ring::R2,Ring::R3,Ring::R4;
     }
     }


File: index.htm,  Node: fetchall,  Next: imapall,  Prev: extendring,  Up: ring_lib

D.2.6.8 fetchall
................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     fetchall(R[,s]); R=ring/qring, s=string

*Create:*
     fetch all objects of ring R (of type
     poly/ideal/vector/module/number/ matrix) into the basering.
     If no 3rd argument is present, the names are the same as in R. If,
     say, f is a poly in R and the 3rd argument is the string "R", then
     f is mapped to f_R etc.

*Return:*
     no return value

*Note:*
     As fetch, this procedure maps the 1st, 2nd, ... variable of R to
     the 1st, 2nd, ... variable of the basering.
     The 3rd argument is useful in order to avoid conflicts of names,
     the empty string is allowed

*Caution:*
     fetchall does not work inside a procedure.
     It does not work if R contains a map.

*Example:*
     LIB "ring.lib";
     // The example is not shown since fetchall does not work in a procedure;
     // (and hence not in the example procedure). Try the following commands:
     //   ring R=0,(x,y,z),dp;
     //   ideal j=x,y2,z2;
     //   matrix M[2][3]=1,2,3,x,y,z;
     //   j; print(M);
     //   ring S=0,(a,b,c),ds;
     //   fetchall(R);       //map from R to S: x->a, y->b, z->c;
     //   names(S);
     //   j; print(M);
     //   fetchall(S,"1");   //identity map of S: copy objects, change names
     //   names(S);
     //   kill R,S;


File: index.htm,  Node: imapall,  Next: mapall,  Prev: fetchall,  Up: ring_lib

D.2.6.9 imapall
...............

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     imapall(R[,s]); R=ring/qring, s=string

*Create:*
     map all objects of ring R (of type poly/ideal/vector/module/number/
     matrix) into the basering, by applying imap to all objects of R.
     If no 3rd argument is present, the names are the same as in R. If,
     say, f is a poly in R and the 3rd argument is the string "R", then
     f is mapped to f_R etc.

*Return:*
     no return value

*Note:*
     As imap, this procedure maps the variables of R to the variables
     with the same name in the basering, the other variables are mapped
     to 0.  The 3rd argument is useful in order to avoid conflicts of
     names, the empty string is allowed

*Caution:*
     imapall does not work inside a procedure
     It does not work if R contains a map

*Example:*
     LIB "ring.lib";
     // The example is not shown since imapall does not work in a procedure
     // (and hence not in the example procedure). Try the following commands:
     //   ring R=0,(x,y,z,u),dp;
     //   ideal j=x,y,z,u2+ux+z;
     //   matrix M[2][3]=1,2,3,x,y,uz;
     //   j; print(M);
     //   ring S=0,(a,b,c,x,z,y),ds;
     //   imapall(R);         //map from R to S: x->x, y->y, z->z, u->0
     //   names(S);
     //   j; print(M);
     //   imapall(S,"1");     //identity map of S: copy objects, change names
     //   names(S);
     //   kill R,S;


File: index.htm,  Node: mapall,  Next: ord_test,  Prev: imapall,  Up: ring_lib

D.2.6.10 mapall
...............

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     mapall(R,i[,s]); R=ring/qring, i=ideal of basering, s=string

*Create:*
     map all objects of ring R (of type poly/ideal/vector/module/number/
     matrix, map) into the basering, by mapping the j-th variable of R
     to the j-th generator of the ideal i. If no 3rd argument is
     present, the names are the same as in R. If, say, f is a poly in R
     and the 3rd argument is the string "R", then f is mapped to f_R
     etc.

*Return:*
     no return value.

*Note:*
     This procedure has the same effect as defining a map, say psi, by
     map psi=R,i; and then applying psi to all objects of R. In
     particular, maps from R to some ring S are composed with psi,
     creating thus a map from the basering to S.
     mapall may be combined with copyring to change vars for all
     objects.  The 3rd argument is useful in order to avoid conflicts of
     names, the empty string is allowed.

*Caution:*
     mapall does not work inside a procedure.

*Example:*
     LIB "ring.lib";
     // The example is not shown since mapall does not work in a procedure
     // (and hence not in the example procedure). Try the following commands:
     //   ring R=0,(x,y,z),dp;
     //   ideal j=x,y,z;
     //   matrix M[2][3]=1,2,3,x,y,z;
     //   map phi=R,x2,y2,z2;
     //   ring S=0,(a,b,c),ds;
     //   ideal i=c,a,b;
     //   mapall(R,i);         //map from R to S: x->c, y->a, z->b
     //   names(S);
     //   j; print(M); phi;    //phi maps R to S: x->c2, y->a2, z->b2
     //   ideal i1=a2,a+b,1;
     //   mapall(R,i1,"");   //map from R to S: x->a2, y->a+b, z->1
     //   names(S);
     //   j_; print(M_); phi_;
     //   changevar("T","x()",R);  //change vars in R and call result T
     //   mapall(R,maxideal(1));       //identity map from R to T
     //   names(T);
     //   j; print(M); phi;
     //   kill R,S,T;


File: index.htm,  Node: ord_test,  Next: ringtensor,  Prev: mapall,  Up: ring_lib

D.2.6.11 ord_test
.................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     ord_test(r); r ring

*Return:*
     int 1 (resp. -1, resp. 0) if ordering of r is global (resp. local,
     resp. mixed)

*Example:*
     LIB "ring.lib";
     ring R = 0,(x,y),dp;
     ring S = 0,(u,v),ls;
     ord_test(R);
     ==> 1
     ord_test(S);
     ==> -1
     ord_test(R+S);
     ==> 0


File: index.htm,  Node: ringtensor,  Next: ringweights,  Prev: ord_test,  Up: ring_lib

D.2.6.12 ringtensor
...................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     ringtensor(s,r1,r2,...); s=string, r1,r2,...=rings

*Create:*
     A new base ring with name `s` if r1,r2,... are existing rings.  If,
     say, s = "R" and the rings r1,r2,... exist, the new ring will have
     name R, variables from all rings r1,r2,... and as monomial ordering
     the block (product) ordering of r1,r2,... . Hence, R is the tensor
     product of the rings r1,r2,... with ordering matrix equal to the
     direct sum of the ordering matrices of r1,r2,...

*Return:*
     no return value

*Note:*
     The characteristic of the new ring will be that of r1. The names of
     variables in the rings r1,r2,... should differ (if a name, say x,
     occurs in r1 and r2, then, in the new ring r, x always refers to
     the variable with name x in r1, there is no access to x in r2).
     The procedure works also for quotient rings ri, if the
     characteristic of ri is compatible with the characteristic of r1
     (i.e. if imap from ri to r1 is implemented)
     This proc uses 'execute' or calls a procedure using 'execute'.  If
     you use it in your own proc, let the local names of your proc start
     with @ (see the file HelpForProc)

*Example:*
     LIB "ring.lib";
     ring r=32003,(x,y,u,v),dp;
     ring s=0,(a,b,c),wp(1,2,3);
     ring t=0,x(1..5),(c,ls);
     ringtensor("R",r,s,t);
     ==> // basering is now R
     type R;
     ==> // R                    [0]  *ring
     ==> //   characteristic : 32003
     ==> //   number of vars : 12
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y u v 
     ==> //        block   2 : ordering wp
     ==> //                  : names    a b c 
     ==> //                  : weights  1 2 3 
     ==> //        block   3 : ordering ls
     ==> //                  : names    x(1) x(2) x(3) x(4) x(5) 
     ==> //        block   4 : ordering C
     setring s;
     ideal i = a2+b3+c5;
     changevar("S","x,y,z");       //change vars of sand make S the basering
     ==> // basering is now S
     qring qS =std(fetch(s,i));    //create qring of S mod i (mapped to S)
     changevar("T","d,e,f,g,h",t); //change vars of t and make T the basering
     ==> // basering is now T
     qring qT=std(d2+e2-f3);       //create qring of T mod d2+e2-f3
     ringtensor("Q",s,qS,t,qT);
     ==> // basering is now Q
     type Q;
     ==> // Q                    [0]  *qring
     ==> //   characteristic : 0
     ==> //   number of vars : 16
     ==> //        block   1 : ordering wp
     ==> //                  : names    a b c 
     ==> //                  : weights  1 2 3 
     ==> //        block   2 : ordering wp
     ==> //                  : names    x y z 
     ==> //                  : weights  1 2 3 
     ==> //        block   3 : ordering ls
     ==> //                  : names    x(1) x(2) x(3) x(4) x(5) 
     ==> //        block   4 : ordering ls
     ==> //                  : names    d e f g h 
     ==> //        block   5 : ordering C
     ==> // quotient ring from ideal
     ==> _[1]=f3-e2-d2
     ==> _[2]=z5+y3+x2
     kill R,Q,S,T;
     if(system("with","Namespaces")) {
     if( nameof(Current) == "Ring" ) {
     kill Top::R,Top::Q,Top::S,Top::T;
     } else {
     kill Ring::R,Ring::Q,Ring::S,Ring::T;
     }
     }


File: index.htm,  Node: ringweights,  Prev: ringtensor,  Up: ring_lib

D.2.6.13 ringweights
....................

Procedure from library `ring.lib' (*note ring_lib::).

*Usage:*
     ringweights(P); P=name of an existing ring (true name, not a
     string)

*Return:*
     intvec consisting of the weights of the variables of P, as they
     appear when typing P;.

*Note:*
     This is useful when enlarging P but keeping the weights of the old
     variables.

*Example:*
     LIB "ring.lib";
     ring r0 = 0,(x,y,z),dp;
     ringweights(r0);
     ==> 1,1,1
     ring r1 = 0,x(1..5),(ds(3),wp(2,3));
     ringweights(r1);"";
     ==> 1,1,1,2,3
     ==> 
     // an example for enlarging the ring, keeping the first weights:
     intvec v = ringweights(r1),6,2,3,4,5;
     ring R = 0,x(1..10),(a(v),dp);
     ordstr(R);
     ==> a(1,1,1,2,3,6,2,3,4,5),dp(10),C


File: index.htm,  Node: Linear algebra,  Next: Commutative algebra,  Prev: General purpose,  Up: SINGULAR libraries

D.3 Linear algebra
==================

* Menu:

* matrix_lib:: procedures for matrix operations
* linalg_lib:: procedures for algorithmic linear algebra


File: index.htm,  Node: matrix_lib,  Next: linalg_lib,  Prev: Linear algebra,  Up: Linear algebra

D.3.1 matrix_lib
----------------

*Library:*
     matrix.lib

*Purpose:*
     Elementary Matrix Operations

*Procedures:*

* Menu:

* compress:: matrix, zero columns from A deleted
* concat:: matrix, concatenation of matrices A1,A2,...
* diag:: matrix, nxn diagonal matrix with entries poly p
* dsum:: matrix, direct sum of matrices A1,A2,...
* flatten:: ideal, generated by entries of matrix A
* genericmat:: generic nxm matrix [entries from id]
* is_complex:: 1 if list c is a complex, 0 if not
* outer:: matrix, outer product of matrices A and B
* power:: matrix/intmat, n-th power of matrix/intmat A
* skewmat:: generic skew-symmetric nxn matrix [entries from id]
* submat:: submatrix of A with rows/cols specified by intvec r/c
* symmat:: generic symmetric nxn matrix [entries from id]
* tensor:: matrix, tensor product of matrices A nd B
* unitmat:: unit square matrix of size n
* gauss_col:: transform a matrix into col-reduced Gauss normal form
* gauss_row:: transform a matrix into row-reduced Gauss normal form
* addcol:: add p*(c1-th col) to c2-th column of matrix A, p poly
* addrow:: add p*(r1-th row) to r2-th row of matrix A, p poly
* multcol:: multiply c-th column of A with poly p
* multrow:: multiply r-th row of A with poly p
* permcol:: permute i-th and j-th columns
* permrow:: permute i-th and j-th rows
* rowred:: reduction of matrix A with elementary row-operations
* colred:: reduction of matrix A with elementary col-operations
* rm_unitrow:: remove unit rows and associated columns of A
* rm_unitcol:: remove unit columns and associated rows of A
* headStand:: A[n-i+1,m-j+1]=headStand(A[i,j])


File: index.htm,  Node: compress,  Next: concat,  Up: matrix_lib

D.3.1.1 compress
................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     compress(A); A matrix/ideal/module/intmat/intvec

*Return:*
     same type, zero columns/generators from A deleted
     (if A=intvec, zero elements are deleted)

*Example:*
     LIB "matrix.lib";
     ring r=0,(x,y,z),ds;
     matrix A[3][4]=1,0,3,0,x,0,z,0,x2,0,z2,0;
     print(A);
     ==> 1, 0,3, 0,
     ==> x, 0,z, 0,
     ==> x2,0,z2,0 
     print(compress(A));
     ==> 1, 3,
     ==> x, z,
     ==> x2,z2
     module m=module(A); show(m);
     ==> // module, 4 generator(s)
     ==> [1,x,x2]
     ==> [0]
     ==> [3,z,z2]
     ==> [0]
     show(compress(m));
     ==> // module, 2 generator(s)
     ==> [1,x,x2]
     ==> [3,z,z2]
     intmat B[3][4]=1,0,3,0,4,0,5,0,6,0,7,0;
     compress(B);
     ==> 1,3,
     ==> 4,5,
     ==> 6,7 
     intvec C=0,0,1,2,0,3;
     compress(C);
     ==> 1,2,3


File: index.htm,  Node: concat,  Next: diag,  Prev: compress,  Up: matrix_lib

D.3.1.2 concat
..............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     concat(A1,A2,..); A1,A2,... matrices

*Return:*
     matrix, concatenation of A1,A2,.... Number of rows of result matrix
     is max(nrows(A1),nrows(A2),...)

*Example:*
     LIB "matrix.lib";
     ring r=0,(x,y,z),ds;
     matrix A[3][3]=1,2,3,x,y,z,x2,y2,z2;
     matrix B[2][2]=1,0,2,0; matrix C[1][4]=4,5,x,y;
     print(A);
     ==> 1, 2, 3,
     ==> x, y, z,
     ==> x2,y2,z2
     print(B);
     ==> 1,0,
     ==> 2,0 
     print(C);
     ==> 4,5,x,y
     print(concat(A,B,C));
     ==> 1, 2, 3, 1,0,4,5,x,y,
     ==> x, y, z, 2,0,0,0,0,0,
     ==> x2,y2,z2,0,0,0,0,0,0 


File: index.htm,  Node: diag,  Next: dsum,  Prev: concat,  Up: matrix_lib

D.3.1.3 diag
............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     diag(p,n); p poly, n integer
     diag(A); A matrix

*Return:*
     diag(p,n): diagonal matrix, p times unit matrix of size n.
     diag(A) : n*m x n*m diagonal matrix with entries all the entries of
     the nxm matrix A, taken from the 1st row, 2nd row etc of A

*Example:*
     LIB "matrix.lib";
     ring r = 0,(x,y,z),ds;
     print(diag(xy,4));
     ==> xy,0, 0, 0,
     ==> 0, xy,0, 0,
     ==> 0, 0, xy,0,
     ==> 0, 0, 0, xy
     matrix A[3][2] = 1,2,3,4,5,6;
     print(A);
     ==> 1,2,
     ==> 3,4,
     ==> 5,6 
     print(diag(A));
     ==> 1,0,0,0,0,0,
     ==> 0,2,0,0,0,0,
     ==> 0,0,3,0,0,0,
     ==> 0,0,0,4,0,0,
     ==> 0,0,0,0,5,0,
     ==> 0,0,0,0,0,6 


File: index.htm,  Node: dsum,  Next: flatten,  Prev: diag,  Up: matrix_lib

D.3.1.4 dsum
............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     dsum(A1,A2,..); A1,A2,... matrices

*Return:*
     matrix, direct sum of A1,A2,...

*Example:*
     LIB "matrix.lib";
     ring r = 0,(x,y,z),ds;
     matrix A[3][3] = 1,2,3,4,5,6,7,8,9;
     matrix B[2][2] = 1,x,y,z;
     print(A);
     ==> 1,2,3,
     ==> 4,5,6,
     ==> 7,8,9 
     print(B);
     ==> 1,x,
     ==> y,z 
     print(dsum(A,B));
     ==> 1,2,3,0,0,
     ==> 4,5,6,0,0,
     ==> 7,8,9,0,0,
     ==> 0,0,0,1,x,
     ==> 0,0,0,y,z 


File: index.htm,  Node: flatten,  Next: genericmat,  Prev: dsum,  Up: matrix_lib

D.3.1.5 flatten
...............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     flatten(A); A matrix

*Return:*
     ideal, generated by all entries from A

*Example:*
     LIB "matrix.lib";
     ring r = 0,(x,y,z),ds;
     matrix A[2][3] = 1,2,x,y,z,7;
     print(A);
     ==> 1,2,x,
     ==> y,z,7 
     flatten(A);
     ==> _[1]=1
     ==> _[2]=2
     ==> _[3]=x
     ==> _[4]=y
     ==> _[5]=z
     ==> _[6]=7


File: index.htm,  Node: genericmat,  Next: is_complex,  Prev: flatten,  Up: matrix_lib

D.3.1.6 genericmat
..................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     genericmat(n,m[,id]); n,m=integers, id=ideal

*Return:*
     nxm matrix, with entries from id.

*Note:*
     if id has less than nxm elements, the matrix is filled with 0's,
     (default: id=maxideal(1)).
     genericmat(n,m); creates the generic nxm matrix

*Example:*
     LIB "matrix.lib";
     ring R = 0,x(1..16),lp;
     print(genericmat(3,3));      // the generic 3x3 matrix
     ==> x(1),x(2),x(3),
     ==> x(4),x(5),x(6),
     ==> x(7),x(8),x(9) 
     ring R1 = 0,(a,b,c,d),dp;
     matrix A = genericmat(3,4,maxideal(1)^3);
     print(A);
     ==> a3, a2b,a2c,a2d,
     ==> ab2,abc,abd,ac2,
     ==> acd,ad2,b3, b2c 
     int n,m = 3,2;
     ideal i = ideal(randommat(1,n*m,maxideal(1),9));
     print(genericmat(n,m,i));    // matrix of generic linear forms
     ==> 4a-8b-2c-3d,-a+b-4c+5d,
     ==> -8a-9b+c+7d,a-9b+9c+4d,
     ==> 6a-5b+9c,   2a+8c+d    


File: index.htm,  Node: is_complex,  Next: outer,  Prev: genericmat,  Up: matrix_lib

D.3.1.7 is_complex
..................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     is_complex(c); c = list of size-compatible modules or matrices

*Return:*
     1 if c[i]*c[i+1]=0 for all i, 0 if not, hence checking whether the
     list of matrices forms a complex.

*Note:*
     Ideals are treated internally as 1-line matrices.
     If printlevel > 0, the position where c is not a complex is shown.

*Example:*
     LIB "matrix.lib";
     ring r  = 32003,(x,y,z),ds;
     ideal i = x4+y5+z6,xyz,yx2+xz2+zy7;
     list L  = nres(i,0);
     is_complex(L);
     ==> 1
     L[4]    = matrix(i);
     is_complex(L);
     ==> 0


File: index.htm,  Node: outer,  Next: power,  Prev: is_complex,  Up: matrix_lib

D.3.1.8 outer
.............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     outer(A,B); A,B matrices

*Return:*
     matrix, outer (tensor) product of A and B

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),ds;
     matrix A[3][3]=1,2,3,4,5,6,7,8,9;
     matrix B[2][2]=x,y,0,z;
     print(A);
     ==> 1,2,3,
     ==> 4,5,6,
     ==> 7,8,9 
     print(B);
     ==> x,y,
     ==> 0,z 
     print(outer(A,B));
     ==> x, y, 2x,2y,3x,3y,
     ==> 0, z, 0, 2z,0, 3z,
     ==> 4x,4y,5x,5y,6x,6y,
     ==> 0, 4z,0, 5z,0, 6z,
     ==> 7x,7y,8x,8y,9x,9y,
     ==> 0, 7z,0, 8z,0, 9z 


File: index.htm,  Node: power,  Next: skewmat,  Prev: outer,  Up: matrix_lib

D.3.1.9 power
.............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     power(A,n); A a square-matrix of type intmat or matrix, n=integer

*Return:*
     intmat resp. matrix, the n-th power of A

*Note:*
     for A=intmat and big n the result may be wrong because of int
     overflow

*Example:*
     LIB "matrix.lib";
     intmat A[3][3]=1,2,3,4,5,6,7,8,9;
     print(power(A,3));"";
     ==>    468   576   684
     ==>   1062  1305  1548
     ==>   1656  2034  2412
     ==> 
     ring r=0,(x,y,z),dp;
     matrix B[3][3]=0,x,y,z,0,0,y,z,0;
     print(power(B,3));"";
     ==> yz2,    xy2+x2z,y3+xyz,
     ==> y2z+xz2,yz2,    0,     
     ==> y3+xyz, y2z+xz2,yz2    
     ==> 


File: index.htm,  Node: skewmat,  Next: submat,  Prev: power,  Up: matrix_lib

D.3.1.10 skewmat
................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     skewmat(n[,id]); n integer, id ideal

*Return:*
     skew-symmetric nxn matrix, with entries from id
     (default: id=maxideal(1))
     skewmat(n); creates the generic skew-symmetric matrix

*Note:*
     if id has less than n*(n-1)/2 elements, the matrix is
     filled with 0's,

*Example:*
     LIB "matrix.lib";
     ring R=0,x(1..5),lp;
     print(skewmat(4));    // the generic skew-symmetric matrix
     ==> 0,    x(1), x(2),x(3),
     ==> -x(1),0,    x(4),x(5),
     ==> -x(2),-x(4),0,   0,   
     ==> -x(3),-x(5),0,   0    
     ring R1 = 0,(a,b,c),dp;
     matrix A=skewmat(4,maxideal(1)^2);
     print(A);
     ==> 0,  a2, ab, ac,
     ==> -a2,0,  b2, bc,
     ==> -ab,-b2,0,  c2,
     ==> -ac,-bc,-c2,0  
     int n=3;
     ideal i = ideal(randommat(1,n*(n-1) div 2,maxideal(1),9));
     print(skewmat(n,i));  // skew matrix of generic linear forms
     ==> 0,       4a+b-8c, -a+6b+c,  
     ==> -4a-b+8c,0,       -8a+2b-9c,
     ==> a-6b-c,  8a-2b+9c,0         
     kill R1;


File: index.htm,  Node: submat,  Next: symmat,  Prev: skewmat,  Up: matrix_lib

D.3.1.11 submat
...............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     submat(A,r,c); A=matrix, r,c=intvec

*Return:*
     matrix, submatrix of A with rows specified by intvec r and columns
     specified by intvec c.

*Example:*
     LIB "matrix.lib";
     ring R=32003,(x,y,z),lp;
     matrix A[4][4]=x,y,z,0,1,2,3,4,5,6,7,8,9,x2,y2,z2;
     print(A);
     ==> x,y, z, 0,
     ==> 1,2, 3, 4,
     ==> 5,6, 7, 8,
     ==> 9,x2,y2,z2
     intvec v=1,3,4;
     matrix B=submat(A,v,1..3);
     print(B);
     ==> x,y, z,
     ==> 5,6, 7,
     ==> 9,x2,y2


File: index.htm,  Node: symmat,  Next: tensor,  Prev: submat,  Up: matrix_lib

D.3.1.12 symmat
...............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     symmat(n[,id]); n integer, id ideal

*Return:*
     symmetric nxn matrix, with entries from id (default:
     id=maxideal(1))

*Note:*
     if id has less than n*(n+1)/2 elements, the matrix is filled with
     0's, symmat(n); creates the generic symmetric matrix

*Example:*
     LIB "matrix.lib";
     ring R=0,x(1..10),lp;
     print(symmat(4));    // the generic symmetric matrix
     ==> x(1),x(2),x(3),x(4),
     ==> x(2),x(5),x(6),x(7),
     ==> x(3),x(6),x(8),x(9),
     ==> x(4),x(7),x(9),x(10)
     ring R1 = 0,(a,b,c),dp;
     matrix A=symmat(4,maxideal(1)^3);
     print(A);
     ==> a3, a2b,a2c,ab2,
     ==> a2b,abc,ac2,b3, 
     ==> a2c,ac2,b2c,bc2,
     ==> ab2,b3, bc2,c3  
     int n=3;
     ideal i = ideal(randommat(1,n*(n+1) div 2,maxideal(1),9));
     print(symmat(n,i));  // symmetric matrix of generic linear forms
     ==> 4a-8b-2c,-a+b-4c, -8a-9b+c,
     ==> -a+b-4c, a-9b+9c, 6a-5b+9c,
     ==> -8a-9b+c,6a-5b+9c,2a+8c    
     kill R1;


File: index.htm,  Node: tensor,  Next: unitmat,  Prev: symmat,  Up: matrix_lib

D.3.1.13 tensor
...............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     tensor(A,B); A,B matrices

*Return:*
     matrix, tensor product of A and B

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),(c,ds);
     matrix A[3][3]=1,2,3,4,5,6,7,8,9;
     matrix B[2][2]=x,y,0,z;
     print(A);
     ==> 1,2,3,
     ==> 4,5,6,
     ==> 7,8,9 
     print(B);
     ==> x,y,
     ==> 0,z 
     print(tensor(A,B));
     ==> x, y, 2x,2y,3x,3y,
     ==> 0, z, 0, 2z,0, 3z,
     ==> 4x,4y,5x,5y,6x,6y,
     ==> 0, 4z,0, 5z,0, 6z,
     ==> 7x,7y,8x,8y,9x,9y,
     ==> 0, 7z,0, 8z,0, 9z 


File: index.htm,  Node: unitmat,  Next: gauss_col,  Prev: tensor,  Up: matrix_lib

D.3.1.14 unitmat
................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     unitmat(n); n integer >= 0

*Return:*
     nxn unit matrix

*Note:*
     needs a basering, diagonal entries are numbers (=1) in the basering

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),lp;
     print(xyz*unitmat(4));
     ==> xyz,0,  0,  0, 
     ==> 0,  xyz,0,  0, 
     ==> 0,  0,  xyz,0, 
     ==> 0,  0,  0,  xyz
     print(unitmat(5));
     ==> 1,0,0,0,0,
     ==> 0,1,0,0,0,
     ==> 0,0,1,0,0,
     ==> 0,0,0,1,0,
     ==> 0,0,0,0,1 


File: index.htm,  Node: gauss_col,  Next: gauss_row,  Prev: unitmat,  Up: matrix_lib

D.3.1.15 gauss_col
..................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     gauss_col(A[,e]); A a matrix, e any type

*Return:*
     - a matrix B, if called with one argument; B is the complete
     column- reduced upper-triangular normal form of A if A is constant,
     (resp. as far as this is possible if A is a polynomial matrix; no
     division by polynomials).
     - a list L of two matrices, if called with two arguments; L
     satisfies L[1] = A * L[2] with L[1] the column-reduced form of A
     and L[2] the transformation matrix.

*Note:*
     * The procedure just applies interred to A with ordering (C,dp).
     The transformation matrix is obtained by applying 'lift'.  This
     should be faster than the procedure colred.
     * It should only be used with exact coefficient field (there is no
     pivoting and rounding error treatment).
     * Parameters are allowed. Hence, if the entries of A are
     parameters, B is the column-reduced form of A over the rational
     function field.

*Example:*
     LIB "matrix.lib";
     ring r=(0,a,b),(A,B,C),dp;
     matrix m[8][6]=
     0,    2*C, 0,    0,  0,   0,
     0,    -4*C,a*A,  0,  0,   0,
     b*B,  -A,  0,    0,  0,   0,
     -A,   B,   0,    0,  0,   0,
     -4*C, 0,   B,    2,  0,   0,
     2*A,  B,   0,    0,  0,   0,
     0,    3*B, 0,    0,  2b,  0,
     0,    AB,  0,    2*A,A,   2a;"";
     ==> 
     list L=gauss_col(m,1);
     print(L[1]);
     ==> 0,0,2*C, 0,       0,0,
     ==> A,0,-4*C,0,       0,0,
     ==> 0,0,-A,  (1/2b)*B,0,0,
     ==> 0,0,B,   -1/2*A,  0,0,
     ==> 0,1,0,   0,       0,0,
     ==> 0,0,B,   A,       0,0,
     ==> 0,0,0,   0,       1,0,
     ==> 0,0,0,   0,       0,1 
     print(L[2]);
     ==> 0,         0,        0,               1/2,      0,         0,    
     ==> 0,         0,        1,               0,        0,         0,    
     ==> 1/(a),     0,        0,               0,        0,         0,    
     ==> -1/(2a)*B, 1/2,      0,               C,        0,         0,    
     ==> 0,         0,        -3/(2b)*B,       0,        1/(2b),    0,    
     ==> 1/(2a2)*AB,-1/(2a)*A,(-2b+3)/(4ab)*AB,-1/(a)*AC,-1/(4ab)*A,1/(2a)
     ring S=0,x,(c,dp);
     matrix A[5][4] =
     3, 1, 1, 1,
     13, 8, 6,-7,
     14,10, 6,-7,
     7, 4, 3,-3,
     2, 1, 0, 3;
     print(gauss_col(A));
     ==> 8/9,-5/9,-1/3,7/9,
     ==> 1,  0,   0,   0,  
     ==> 0,  1,   0,   0,  
     ==> 0,  0,   1,   0,  
     ==> 0,  0,   0,   1   

* Menu:

See also:
* colred::

*See also:* *note colred::.


File: index.htm,  Node: gauss_row,  Next: addcol,  Prev: gauss_col,  Up: matrix_lib

D.3.1.16 gauss_row
..................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     gauss_row(A [,e]); A matrix, e any type

*Return:*
     - a matrix B, if called with one argument; B is the complete row-
     reduced lower-triangular normal form of A if A is constant, (resp.
     as far as this is possible if A is a polynomial matrix; no division
     by polynomials).
     - a list L of two matrices, if called with two arguments; L
     satisfies L[1] = L[2] * A with L[1] the row-reduced form of A and
     L[2] the transformation matrix.

*Note:*
     * This procedure just applies gauss_col to the transposed matrix.
     The transformation matrix is obtained by applying lift.  This
     should be faster than the procedure rowred.
     * It should only be used with exact coefficient field (there is no
     pivoting and rounding error treatment).
     * Parameters are allowed. Hence, if the entries of A are
     parameters, B is the row-reduced form of A over the rational
     function field.

*Example:*
     LIB "matrix.lib";
     ring r=(0,a,b),(A,B,C),dp;
     matrix m[6][8]=
     0, 0,  b*B, -A,-4C,2A,0, 0,
     2C,-4C,-A,B, 0,  B, 3B,AB,
     0,a*A,  0, 0, B,  0, 0, 0,
     0, 0,  0, 0, 2,  0, 0, 2A,
     0, 0,  0, 0, 0,  0, 2b, A,
     0, 0,  0, 0, 0,  0, 0, 2a;"";
     ==> 
     print(gauss_row(m));"";
     ==> 0,  A,   0,       0,     0,0,0,0,
     ==> 0,  0,   0,       0,     1,0,0,0,
     ==> 2*C,-4*C,-A,      B,     0,B,0,0,
     ==> 0,  0,   (1/2b)*B,-1/2*A,0,A,0,0,
     ==> 0,  0,   0,       0,     0,0,1,0,
     ==> 0,  0,   0,       0,     0,0,0,1 
     ==> 
     ring S=0,x,dp;
     matrix A[4][5] =  3, 1,1,-1,2,
     13, 8,6,-7,1,
     14,10,6,-7,1,
     7, 4,3,-3,3;
     list L=gauss_row(A,1);
     print(L[1]);
     ==> 1/2,-7/3,-19/6,5/6,
     ==> 1,  0,   0,    0,  
     ==> 0,  1,   0,    0,  
     ==> 0,  0,   1,    0,  
     ==> 0,  0,   0,    1   
     print(L[2]);
     ==> 0,   -6,  -5,  1,   
     ==> -1/2,2/3, -1/6,-1/6,
     ==> 1/2, -5/3,-5/6,1/6, 
     ==> 0,   13/3,11/3,-1/3 

* Menu:

See also:
* rowred::

*See also:* *note rowred::.


File: index.htm,  Node: addcol,  Next: addrow,  Prev: gauss_row,  Up: matrix_lib

D.3.1.17 addcol
...............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     addcol(A,c1,p,c2); A matrix, p poly, c1, c2 positive integers

*Return:*
     matrix, A being modified by adding p times column c1 to column c2

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),lp;
     matrix A[3][3]=1,2,3,4,5,6,7,8,9;
     print(A);
     ==> 1,2,3,
     ==> 4,5,6,
     ==> 7,8,9 
     print(addcol(A,1,xy,2));
     ==> 1,xy+2, 3,
     ==> 4,4xy+5,6,
     ==> 7,7xy+8,9 


File: index.htm,  Node: addrow,  Next: multcol,  Prev: addcol,  Up: matrix_lib

D.3.1.18 addrow
...............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     addcol(A,r1,p,r2); A matrix, p poly, r1, r2 positive integers

*Return:*
     matrix, A being modified by adding p times row r1 to row r2

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),lp;
     matrix A[3][3]=1,2,3,4,5,6,7,8,9;
     print(A);
     ==> 1,2,3,
     ==> 4,5,6,
     ==> 7,8,9 
     print(addrow(A,1,xy,3));
     ==> 1,   2,    3,   
     ==> 4,   5,    6,   
     ==> xy+7,2xy+8,3xy+9


File: index.htm,  Node: multcol,  Next: multrow,  Prev: addrow,  Up: matrix_lib

D.3.1.19 multcol
................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     addcol(A,c,p); A matrix, p poly, c positive integer

*Return:*
     matrix, A being modified by multiplying column c with p

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),lp;
     matrix A[3][3]=1,2,3,4,5,6,7,8,9;
     print(A);
     ==> 1,2,3,
     ==> 4,5,6,
     ==> 7,8,9 
     print(multcol(A,2,xy));
     ==> 1,2xy,3,
     ==> 4,5xy,6,
     ==> 7,8xy,9 


File: index.htm,  Node: multrow,  Next: permcol,  Prev: multcol,  Up: matrix_lib

D.3.1.20 multrow
................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     multrow(A,r,p); A matrix, p poly, r positive integer

*Return:*
     matrix, A being modified by multiplying row r with p

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),lp;
     matrix A[3][3]=1,2,3,4,5,6,7,8,9;
     print(A);
     ==> 1,2,3,
     ==> 4,5,6,
     ==> 7,8,9 
     print(multrow(A,2,xy));
     ==> 1,  2,  3,  
     ==> 4xy,5xy,6xy,
     ==> 7,  8,  9   


File: index.htm,  Node: permcol,  Next: permrow,  Prev: multrow,  Up: matrix_lib

D.3.1.21 permcol
................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     permcol(A,c1,c2); A matrix, c1,c2 positive integers

*Return:*
     matrix, A being modified by permuting column c1 and c2

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),lp;
     matrix A[3][3]=1,x,3,4,y,6,7,z,9;
     print(A);
     ==> 1,x,3,
     ==> 4,y,6,
     ==> 7,z,9 
     print(permcol(A,2,3));
     ==> 1,3,x,
     ==> 4,6,y,
     ==> 7,9,z 


File: index.htm,  Node: permrow,  Next: rowred,  Prev: permcol,  Up: matrix_lib

D.3.1.22 permrow
................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     permrow(A,r1,r2); A matrix, r1,r2 positive integers

*Return:*
     matrix, A being modified by permuting row r1 and r2

*Example:*
     LIB "matrix.lib";
     ring r=32003,(x,y,z),lp;
     matrix A[3][3]=1,2,3,x,y,z,7,8,9;
     print(A);
     ==> 1,2,3,
     ==> x,y,z,
     ==> 7,8,9 
     print(permrow(A,2,1));
     ==> x,y,z,
     ==> 1,2,3,
     ==> 7,8,9 


File: index.htm,  Node: rowred,  Next: colred,  Prev: permrow,  Up: matrix_lib

D.3.1.23 rowred
...............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     rowred(A[,e]); A matrix, e any type

*Return:*
     - a matrix B, being the row reduced form of A, if rowred is called
     with one argument.
     (as far as this is possible over the polynomial ring; no division
     by polynomials)
     - a list L of two matrices, such that L[1] = L[2] * A with L[1] the
     row-reduced form of A and L[2] the transformation matrix (if rowred
     is called with two arguments).

*Note:*
     * This procedure is designed for teaching purposes mainly.
     * The straight forward Gaussian algorithm is implemented in the
     library (no standard basis computation).
     The transformation matrix is obtained by concatenating a unit
     matrix to A. proc gauss_row should be faster.
     * It should only be used with exact coefficient field (there is no
     pivoting) over the polynomial ring (ordering lp or dp).
     * Parameters are allowed. Hence, if the entries of A are parameters
     the computation takes place over the field of rational functions.

*Example:*
     LIB "matrix.lib";
     ring r=(0,a,b),(A,B,C),dp;
     matrix m[6][8]=
     0, 0,  b*B, -A,-4C,2A,0, 0,
     2C,-4C,-A,B, 0,  B, 3B,AB,
     0,a*A,  0, 0, B,  0, 0, 0,
     0, 0,  0, 0, 2,  0, 0, 2A,
     0, 0,  0, 0, 0,  0, 2b, A,
     0, 0,  0, 0, 0,  0, 0, 2a;"";
     ==> 
     print(rowred(m));"";
     ==> 0,  0,    0,    0, 1,0,  0,0,
     ==> 0,  0,    0,    0, 0,0,  1,0,
     ==> 0,  0,    0,    0, 0,0,  0,1,
     ==> 0,  0,    (b)*B,-A,0,2*A,0,0,
     ==> 2*C,-4*C, -A,   B, 0,B,  0,0,
     ==> 0,  (a)*A,0,    0, 0,0,  0,0 
     ==> 
     list L=rowred(m,1);
     print(L[1]);
     ==> 0,  0,    0,    0, 1,0,  0,0,
     ==> 0,  0,    0,    0, 0,0,  1,0,
     ==> 0,  0,    0,    0, 0,0,  0,1,
     ==> 0,  0,    (b)*B,-A,0,2*A,0,0,
     ==> 2*C,-4*C, -A,   B, 0,B,  0,0,
     ==> 0,  (a)*A,0,    0, 0,0,  0,0 
     print(L[2]);
     ==> 0,0,0,1/2,   0,        -1/(2a)*A,       
     ==> 0,0,0,0,     1/(2b),   -1/(4ab)*A,      
     ==> 0,0,0,0,     0,        1/(2a),          
     ==> 1,0,0,2*C,   0,        -2/(a)*AC,       
     ==> 0,1,0,0,     -3/(2b)*B,(-2b+3)/(4ab)*AB,
     ==> 0,0,1,-1/2*B,0,        1/(2a)*AB        

* Menu:

See also:
* gauss_row::

*See also:* *note gauss_row::.


File: index.htm,  Node: colred,  Next: rm_unitrow,  Prev: rowred,  Up: matrix_lib

D.3.1.24 colred
...............

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     colred(A[,e]); A matrix, e any type

*Return:*
     - a matrix B, being the column reduced form of A, if colred is
     called with one argument.
     (as far as this is possible over the polynomial ring; no division
     by polynomials)
     - a list L of two matrices, such that L[1] = A * L[2] with L[1] the
     column-reduced form of A and L[2] the transformation matrix (if
     colred is called with two arguments).

*Note:*
     * This procedure is designed for teaching purposes mainly.
     * It applies rowred to the transposed matrix.  proc gauss_col
     should be faster.
     * It should only be used with exact coefficient field (there is no
     pivoting) over the polynomial ring (ordering lp or dp).
     * Parameters are allowed. Hence, if the entries of A are parameters
     the computation takes place over the field of rational functions.

*Example:*
     LIB "matrix.lib";
     ring r=(0,a,b),(A,B,C),dp;
     matrix m[8][6]=
     0,    2*C, 0,    0,  0,   0,
     0,    -4*C,a*A,  0,  0,   0,
     b*B,  -A,  0,    0,  0,   0,
     -A,   B,   0,    0,  0,   0,
     -4*C, 0,   B,    2,  0,   0,
     2*A,  B,   0,    0,  0,   0,
     0,    3*B, 0,    0,  2b,  0,
     0,    AB,  0,    2*A,A,   2a;"";
     ==> 
     print(colred(m));"";
     ==> 0,0,0,0,    2*C, 0,    
     ==> 0,0,0,0,    -4*C,(a)*A,
     ==> 0,0,0,(b)*B,-A,  0,    
     ==> 0,0,0,-A,   B,   0,    
     ==> 1,0,0,0,    0,   0,    
     ==> 0,0,0,2*A,  B,   0,    
     ==> 0,1,0,0,    0,   0,    
     ==> 0,0,1,0,    0,   0     
     ==> 
     list L=colred(m,1);
     print(L[1]);
     ==> 0,0,0,0,    2*C, 0,    
     ==> 0,0,0,0,    -4*C,(a)*A,
     ==> 0,0,0,(b)*B,-A,  0,    
     ==> 0,0,0,-A,   B,   0,    
     ==> 1,0,0,0,    0,   0,    
     ==> 0,0,0,2*A,  B,   0,    
     ==> 0,1,0,0,    0,   0,    
     ==> 0,0,1,0,    0,   0     
     print(L[2]);
     ==> 0,        0,         0,     1,        0,               0,       
     ==> 0,        0,         0,     0,        1,               0,       
     ==> 0,        0,         0,     0,        0,               1,       
     ==> 1/2,      0,         0,     2*C,      0,               -1/2*B,  
     ==> 0,        1/(2b),    0,     0,        -3/(2b)*B,       0,       
     ==> -1/(2a)*A,-1/(4ab)*A,1/(2a),-2/(a)*AC,(-2b+3)/(4ab)*AB,1/(2a)*AB

* Menu:

See also:
* gauss_col::

*See also:* *note gauss_col::.


File: index.htm,  Node: rm_unitrow,  Next: rm_unitcol,  Prev: colred,  Up: matrix_lib

D.3.1.25 rm_unitrow
...................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     rm_unitrow(A); A matrix (being col-reduced)

*Return:*
     matrix, obtained from A by deleting unit rows (having just one 1
     and else 0 as entries) and associated columns

*Example:*
     LIB "matrix.lib";
     ring r=0,(A,B,C),dp;
     matrix m[8][6]=
     0,0,  0,   0, 2C, 0,
     0,0,  0,   0, -4C,A,
     A,-C2,0,   B, -A, 0,
     0,0,  1/2B,-A,B,  0,
     1,0,  0,   0, 0,  0,
     0,0,  0,   2A,B,  0,
     0,1,  0,   0, 0,  0,
     0,0,  1,   0, 0,  0;
     print(rm_unitrow(m));
     ==> 0, 2C, 0,
     ==> 0, -4C,A,
     ==> B, -A, 0,
     ==> -A,B,  0,
     ==> 2A,B,  0 


File: index.htm,  Node: rm_unitcol,  Next: headStand,  Prev: rm_unitrow,  Up: matrix_lib

D.3.1.26 rm_unitcol
...................

Procedure from library `matrix.lib' (*note matrix_lib::).

*Usage:*
     rm_unitcol(A); A matrix (being row-reduced)

*Return:*
     matrix, obtained from A by deleting unit columns (having just one 1
     and else 0 as entries) and associated rows

*Example:*
     LIB "matrix.lib";
     ring r=0,(A,B,C),dp;
     matrix m[6][8]=
     0,  0,    A,   0, 1,0,  0,0,
     0,  0,  -C2,   0, 0,0,  1,0,
     0,  0,    0,1/2B, 0,0,  0,1,
     0,  0,    B,  -A, 0,2A, 0,0,
     2C,-4C,  -A,   B, 0,B,  0,0,
     0,  A,    0,   0, 0,0,  0,0;
     print(rm_unitcol(m));
     ==> 0, 0,  B, -A,2A,
     ==> 2C,-4C,-A,B, B, 
     ==> 0, A,  0, 0, 0  


File: index.htm,  Node: headStand,  Prev: rm_unitcol,  Up: matrix_lib

D.3.1.27 headStand
..................

Procedure from library `matrix.lib' (*note matrix_lib::).


File: index.htm,  Node: linalg_lib,  Prev: matrix_lib,  Up: Linear algebra

D.3.2 linalg_lib
----------------

*Library:*
     linalg.lib

*Purpose:*
     Algorithmic Linear Algebra

*Authors:*
     Ivor Saynisch (ivs@math.tu-cottbus.de)
     Mathias Schulze (mschulze@mathematik.uni-kl.de)

*Procedures:*

* Menu:

* inverse:: matrix, the inverse of A
* inverse_B:: list(matrix Inv,poly p),Inv*A=p*En ( using busadj(A) )
* inverse_L:: list(matrix Inv,poly p),Inv*A=p*En ( using lift )
* sym_gauss:: symmetric gaussian algorithm
* orthogonalize:: Gram-Schmidt orthogonalization
* diag_test:: test whether A can be diagonalized
* busadj:: coefficients of Adj(E*t-A) and coefficients of det(E*t-A)
* charpoly:: characteristic polynomial of A ( using busadj(A) )
* adjoint:: adjoint of A ( using busadj(A) )
* det_B:: determinant of A ( using busadj(A) )
* gaussred:: gaussian reduction: P*A=U*S, S a row reduced form of A
* gaussred_pivot:: gaussian reduction: P*A=U*S, uses row pivoting
* gauss_nf:: gaussian normal form of A
* mat_rk:: rank of constant matrix A
* U_D_O:: P*A=U*D*O, P,D,U,O=permutation,diag,lower-,upper-triang
* pos_def:: test symmetric matrix for positive definiteness
* hessenberg:: Hessenberg form of M
* evnf:: eigenvalues normal form of (e[,m])
* eigenvals:: eigenvalues with multiplicities of M
* minipoly:: minimal polynomial of M
* jordan:: Jordan data of M
* jordanbasis:: Jordan basis and weight filtration of M
* jordanmatrix:: Jordan matrix with Jordan data (e,s,m)
* jordannf:: Jordan normal form of M


File: index.htm,  Node: inverse,  Next: inverse_B,  Up: linalg_lib

D.3.2.1 inverse
...............

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     inverse(A [,opt]); A a square matrix, opt integer

*Return:*

               a matrix:
               - the inverse matrix of A, if A is invertible;
               - the 1x1 0-matrix if A is not invertible (in the polynomial ring!).
               There are the following options:
               - opt=0 or not given: heuristically best option from below
               - opt=1 : apply std to (transpose(E,A)), ordering (C,dp).
               - opt=2 : apply interred (transpose(E,A)), ordering (C,dp).
               - opt=3 : apply lift(A,E), ordering (C,dp).

*Note:*
     parameters and minpoly are allowed; opt=2 is only correct for
     matrices with entries in a field

*Example:*
     LIB "linalg.lib";
     ring r=0,(x,y,z),lp;
     matrix A[3][3]=
     1,4,3,
     1,5,7,
     0,4,17;
     print(inverse(A));"";
     matrix B[3][3]=
     y+1,  x+y,    y,
     z,    z+1,    z,
     y+z+2,x+y+z+2,y+z+1;
     print(inverse(B));
     print(B*inverse(B));

* Menu:

See also:
* inverse_B::
* inverse_L::

*See also:* *note inverse_B::; *note inverse_L::.


File: index.htm,  Node: inverse_B,  Next: inverse_L,  Prev: inverse,  Up: linalg_lib

D.3.2.2 inverse_B
.................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     inverse_B(A); A = square matrix

*Return:*
     list Inv with
     - Inv[1] = matrix I and
     - Inv[2] = poly p
     such that I*A = unitmat(n)*p;

*Note:*
     p=1 if 1/det(A) is computable and p=det(A) if not;
     the computation uses busadj.

*Example:*
     LIB "linalg.lib";
     ring r=0,(x,y),lp;
     matrix A[3][3]=x,y,1,1,x2,y,x,6,0;
     print(A);
     list Inv=inverse_B(A);
     print(Inv[1]);
     print(Inv[2]);
     print(Inv[1]*A);

* Menu:

See also:
* inverse::
* inverse_L::

*See also:* *note inverse::; *note inverse_L::.


File: index.htm,  Node: inverse_L,  Next: sym_gauss,  Prev: inverse_B,  Up: linalg_lib

D.3.2.3 inverse_L
.................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     inverse_L(A); A = square matrix

*Return:*
     list Inv representing a left inverse of A, i.e
     - Inv[1] = matrix I and
     - Inv[2] = poly p
     such that I*A = unitmat(n)*p;

*Note:*
     p=1 if 1/det(A) is computable and p=det(A) if not;
     the computation computes first det(A) and then uses lift

*Example:*
     LIB "linalg.lib";
     ring r=0,(x,y),lp;
     matrix A[3][3]=x,y,1,1,x2,y,x,6,0;
     print(A);
     list Inv=inverse_L(A);
     print(Inv[1]);
     print(Inv[2]);
     print(Inv[1]*A);

* Menu:

See also:
* inverse::
* inverse_B::

*See also:* *note inverse::; *note inverse_B::.


File: index.htm,  Node: sym_gauss,  Next: orthogonalize,  Prev: inverse_L,  Up: linalg_lib

D.3.2.4 sym_gauss
.................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     sym_gauss(A); A = symmetric matrix

*Return:*
     matrix, diagonalisation with symmetric gauss algorithm

*Example:*
     LIB "linalg.lib";
     ring r=0,(x),lp;
     matrix A[2][2]=1,4,4,15;
     print(A);
     print(sym_gauss(A));


File: index.htm,  Node: orthogonalize,  Next: diag_test,  Prev: sym_gauss,  Up: linalg_lib

D.3.2.5 orthogonalize
.....................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     orthogonalize(A); A = constant matrix

*Return:*
     matrix, orthogonal basis of the column space of A

*Example:*
     LIB "linalg.lib";
     ring r=0,(x),lp;
     matrix A[4][4]=5,6,12,4,7,3,2,6,12,1,1,2,6,4,2,10;
     print(A);
     print(orthogonalize(A));


File: index.htm,  Node: diag_test,  Next: busadj,  Prev: orthogonalize,  Up: linalg_lib

D.3.2.6 diag_test
.................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     diag_test(A); A = const square matrix

*Return:*
     int, 1 if A is diagonalisable, 0 if not
     -1 no statement is possible, since A does not split.

*Note:*
     The test works only for split matrices, i.e if eigenvalues of A are
     in the ground field.
     Does not work with parameters (uses factorize,gcd).

*Example:*
     LIB "linalg.lib";
     ring r=0,(x),dp;
     matrix A[4][4]=6,0,0,0,0,0,6,0,0,6,0,0,0,0,0,6;
     print(A);
     diag_test(A);


File: index.htm,  Node: busadj,  Next: charpoly,  Prev: diag_test,  Up: linalg_lib

D.3.2.7 busadj
..............

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     busadj(A); A = square matrix (of size nxn)

*Return:*
     list L:

              L[1] contains the (n+1) coefficients of the characteristic
                   polynomial X of A, i.e.
                   X = L[1][1]+..+L[1][k]*t^(k-1)+..+(L[1][n+1])*t^n
              L[2] contains the n (nxn)-matrices Hk which are the coefficients of
                   the busadjoint bA = adjoint(E*t-A) of A, i.e.
                   bA = (Hn-1)*t^(n-1)+...+Hk*t^k+...+H0,  ( Hk=L[2][k+1] )

*Example:*
     LIB "linalg.lib";
     ring r = 0,(t,x),lp;
     matrix A[2][2] = 1,x2,x,x2+3x;
     print(A);
     list L = busadj(A);
     poly X = L[1][1]+L[1][2]*t+L[1][3]*t2; X;
     matrix bA[2][2] = L[2][1]+L[2][2]*t;
     print(bA);               //the busadjoint of A;
     print(bA*(t*unitmat(2)-A));


File: index.htm,  Node: charpoly,  Next: adjoint,  Prev: busadj,  Up: linalg_lib

D.3.2.8 charpoly
................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     charpoly(A[,v]); A square matrix, v string, name of a variable

*Return:*
     poly, the characteristic polynomial det(E*v-A)
     (default: v=name of last variable)

*Note:*
     A must be independent of the variable v. The computation uses det.
     If printlevel>0, det(E*v-A) is diplayed recursively.

*Example:*
     LIB "linalg.lib";
     ring r=0,(x,t),dp;
     matrix A[3][3]=1,x2,x,x2,6,4,x,4,1;
     print(A);
     charpoly(A,"t");


File: index.htm,  Node: adjoint,  Next: det_B,  Prev: charpoly,  Up: linalg_lib

D.3.2.9 adjoint
...............

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     adjoint(A); A = square matrix

*Return:*
     adjoint matrix of A, i.e. Adj*A=det(A)*E

*Note:*
     computation uses busadj(A)

*Example:*
     LIB "linalg.lib";
     ring r=0,(t,x),lp;
     matrix A[2][2]=1,x2,x,x2+3x;
     print(A);
     matrix Adj[2][2]=adjoint(A);
     print(Adj);                    //Adj*A=det(A)*E
     print(Adj*A);


File: index.htm,  Node: det_B,  Next: gaussred,  Prev: adjoint,  Up: linalg_lib

D.3.2.10 det_B
..............

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     det_B(A); A any matrix

*Return:*
     returns the determinant of A

*Note:*
     the computation uses the busadj algorithm

*Example:*
     LIB "linalg.lib";
     ring r=0,(x),dp;
     matrix A[10][10]=random(2,10,10)+unitmat(10)*x;
     print(A);
     det_B(A);


File: index.htm,  Node: gaussred,  Next: gaussred_pivot,  Prev: det_B,  Up: linalg_lib

D.3.2.11 gaussred
.................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     gaussred(A); A any constant matrix

*Return:*
     list Z: Z[1]=P , Z[2]=U , Z[3]=S , Z[4]=rank(A)
     gives a row reduced matrix S, a permutation matrix P and a
     normalized lower triangular matrix U, with P*A=U*S

*Note:*
     This procedure is designed for teaching purposes mainly.  The
     straight forward implementation in the interpreted library is not
     very efficient (no standard basis computation).

*Example:*
     LIB "linalg.lib";
     ring r=0,(x),dp;
     matrix A[5][4]=1,3,-1,4,2,5,-1,3,1,3,-1,4,0,4,-3,1,-3,1,-5,-2;
     print(A);
     list Z=gaussred(A);   //construct P,U,S s.t. P*A=U*S
     print(Z[1]);          //P
     print(Z[2]);          //U
     print(Z[3]);          //S
     print(Z[4]);          //rank
     print(Z[1]*A);        //P*A
     print(Z[2]*Z[3]);     //U*S


File: index.htm,  Node: gaussred_pivot,  Next: gauss_nf,  Prev: gaussred,  Up: linalg_lib

D.3.2.12 gaussred_pivot
.......................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     gaussred_pivot(A); A any constant matrix

*Return:*
     list Z: Z[1]=P , Z[2]=U , Z[3]=S , Z[4]=rank(A)
     gives n row reduced matrix S, a permutation matrix P and a
     normalized lower triangular matrix U, with P*A=U*S

*Note:*
     with row pivoting

*Example:*
     LIB "linalg.lib";
     ring r=0,(x),dp;
     matrix A[5][4] = 1, 3,-1,4,
     2, 5,-1,3,
     1, 3,-1,4,
     0, 4,-3,1,
     -3,1,-5,-2;
     list Z=gaussred_pivot(A);  //construct P,U,S s.t. P*A=U*S
     print(Z[1]);               //P
     print(Z[2]);               //U
     print(Z[3]);               //S
     print(Z[4]);               //rank
     print(Z[1]*A);             //P*A
     print(Z[2]*Z[3]);          //U*S


File: index.htm,  Node: gauss_nf,  Next: mat_rk,  Prev: gaussred_pivot,  Up: linalg_lib

D.3.2.13 gauss_nf
.................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     gauss_nf(A); A any constant matrix

*Return:*
     matrix; gauss normal form of A (uses gaussred)

*Example:*
     LIB "linalg.lib";
     ring r = 0,(x),dp;
     matrix A[4][4] = 1,4,4,7,2,5,5,4,4,1,1,3,0,2,2,7;
     print(gauss_nf(A));


File: index.htm,  Node: mat_rk,  Next: U_D_O,  Prev: gauss_nf,  Up: linalg_lib

D.3.2.14 mat_rk
...............

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     mat_rk(A); A any constant matrix

*Return:*
     int, rank of A

*Example:*
     LIB "linalg.lib";
     ring r = 0,(x),dp;
     matrix A[4][4] = 1,4,4,7,2,5,5,4,4,1,1,3,0,2,2,7;
     mat_rk(A);


File: index.htm,  Node: U_D_O,  Next: pos_def,  Prev: mat_rk,  Up: linalg_lib

D.3.2.15 U_D_O
..............

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     U_D_O(A); constant invertible matrix A

*Return:*
     list Z: Z[1]=P , Z[2]=U , Z[3]=D , Z[4]=O
     gives a permutation matrix P,
     a normalized lower triangular matrix U ,
     a diagonal matrix D, and
     a normalized upper triangular matrix O
     with P*A=U*D*O

*Note:*
     Z[1]=-1 means that A is not regular (proc uses gaussred)

*Example:*
     LIB "linalg.lib";
     ring r = 0,(x),dp;
     matrix A[5][5] = 10, 4,  0, -9,  8,
     -3, 6, -6, -4,  9,
     0, 3, -1, -9, -8,
     -4,-2, -6, -10,10,
     -9, 5, -1, -6,  5;
     list Z = U_D_O(A);              //construct P,U,D,O s.t. P*A=U*D*O
     print(Z[1]);                    //P
     print(Z[2]);                    //U
     print(Z[3]);                    //D
     print(Z[4]);                    //O
     print(Z[1]*A);                  //P*A
     print(Z[2]*Z[3]*Z[4]);          //U*D*O


File: index.htm,  Node: pos_def,  Next: hessenberg,  Prev: U_D_O,  Up: linalg_lib

D.3.2.16 pos_def
................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     pos_def(A); A = constant, symmetric square matrix

*Return:*
     int:
     1 if A is positive definit ,
     0 if not,
     -1 if unknown

*Example:*
     LIB "linalg.lib";
     ring r = 0,(x),dp;
     matrix A[5][5] = 20,  4,  0, -9,   8,
     4, 12, -6, -4,   9,
     0, -6, -2, -9,  -8,
     -9, -4, -9, -20, 10,
     8,  9, -8,  10, 10;
     pos_def(A);
     matrix B[3][3] =  3,  2,  0,
     2, 12,  4,
     0,  4,  2;
     pos_def(B);


File: index.htm,  Node: hessenberg,  Next: evnf,  Prev: pos_def,  Up: linalg_lib

D.3.2.17 hessenberg
...................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     hessenberg(M); matrix M

*Assume:*
     M constant square matrix

*Return:*
     matrix H; Hessenberg form of M

*Example:*
     LIB "linalg.lib";
     ring R=0,x,dp;
     matrix M[3][3]=3,2,1,0,2,1,0,0,3;
     print(M);
     print(hessenberg(M));


File: index.htm,  Node: evnf,  Next: eigenvals,  Prev: hessenberg,  Up: linalg_lib

D.3.2.18 evnf
.............

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     evnf(e[,m]); ideal e, intvec m

*Assume:*
     ncols(e)==size(m)

*Return:*
     order eigenvalues e with multiplicities m


File: index.htm,  Node: eigenvals,  Next: minipoly,  Prev: evnf,  Up: linalg_lib

D.3.2.19 eigenvals
..................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     eigenvals(M); matrix M

*Assume:*
     eigenvalues of M in basefield

*Return:*

     list l; 
       ideal l[1];
         number l[1][i];  i-th eigenvalue of M
       intvec l[2]; 
         int l[2][i];  multiplicity of i-th eigenvalue of M

*Example:*
     LIB "linalg.lib";
     ring R=0,x,dp;
     matrix M[3][3]=3,2,1,0,2,1,0,0,3;
     print(M);
     eigenvals(M);


File: index.htm,  Node: minipoly,  Next: jordan,  Prev: eigenvals,  Up: linalg_lib

D.3.2.20 minipoly
.................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     minpoly(M); matrix M

*Assume:*
     eigenvalues of M in basefield

*Return:*

     list l;  minimal polynomial of M
       ideal l[1]; 
         number l[1][i];  i-th root of minimal polynomial of M
       intvec l[2]; 
         int l[2][i];  multiplicity of i-th root of minimal polynomial of M

*Example:*
     LIB "linalg.lib";
     ring R=0,x,dp;
     matrix M[3][3]=3,2,1,0,2,1,0,0,3;
     print(M);
     minipoly(M);


File: index.htm,  Node: jordan,  Next: jordanbasis,  Prev: minipoly,  Up: linalg_lib

D.3.2.21 jordan
...............

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     jordan(M); matrix M

*Assume:*
     eigenvalues of M in basefield

*Return:*

     list l;  Jordan data of M
       ideal l[1]; 
         number l[1][i];  eigenvalue of i-th Jordan block of M
       intvec l[2]; 
         int l[2][i];  size of i-th Jordan block of M
       intvec l[3]; 
         int l[3][i];  multiplicity of i-th Jordan block of M

*Example:*
     LIB "linalg.lib";
     ring R=0,x,dp;
     matrix M[3][3]=3,2,1,0,2,1,0,0,3;
     print(M);
     jordan(M);


File: index.htm,  Node: jordanbasis,  Next: jordanmatrix,  Prev: jordan,  Up: linalg_lib

D.3.2.22 jordanbasis
....................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     jordanbasis(M); matrix M

*Assume:*
     eigenvalues of M in basefield

*Return:*

     list l:
       module l[1];  inverse(l[1])*M*l[1] in Jordan normal form
       intvec l[2]; 
         int l[2][i];  weight filtration index of l[1][i]

*Example:*
     LIB "linalg.lib";
     ring R=0,x,dp;
     matrix M[3][3]=3,2,1,0,2,1,0,0,3;
     print(M);
     list l=jordanbasis(M);
     print(l[1]);
     print(l[2]);
     print(inverse(l[1])*M*l[1]);


File: index.htm,  Node: jordanmatrix,  Next: jordannf,  Prev: jordanbasis,  Up: linalg_lib

D.3.2.23 jordanmatrix
.....................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     jordanmatrix(e,s,m); ideal e, intvec s, intvec m

*Assume:*
     ncols(e)==size(s)==size(m)

*Return:*

     matrix J;  Jordan matrix with list(e,s,m)==jordan(J)

*Example:*
     LIB "linalg.lib";
     ring R=0,x,dp;
     ideal e=ideal(2,3);
     intvec s=1,2;
     intvec m=1,1;
     print(jordanmatrix(e,s,m));


File: index.htm,  Node: jordannf,  Prev: jordanmatrix,  Up: linalg_lib

D.3.2.24 jordannf
.................

Procedure from library `linalg.lib' (*note linalg_lib::).

*Usage:*
     jordannf(M); matrix M

*Assume:*
     eigenvalues of M in basefield

*Return:*
     matrix J; Jordan normal form of M

*Example:*
     LIB "linalg.lib";
     ring R=0,x,dp;
     matrix M[3][3]=3,2,1,0,2,1,0,0,3;
     print(M);
     print(jordannf(M));


File: index.htm,  Node: Commutative algebra,  Next: Singularities,  Prev: Linear algebra,  Up: SINGULAR libraries

D.4 Commutative algebra
=======================

* Menu:

* algebra_lib:: procedures for computing with algebras and maps
* elim_lib:: procedures for elimination, saturation and blowing up
* homolog_lib:: procedures for homological algebra
* mprimdec_lib:: procedures for primary decomposition of modules
* mregular_lib:: procedures for Castelnuovo-Mumford regularity
* normal_lib:: procedure for normalization
* primdec_lib:: procedures for primary decomposition
* primitiv_lib:: procedures for finding a primitive element
* reesclos_lib:: Rees Algebra and integral closure of an ideal
* intprog_lib:: Integer Programming
* toric_lib:: toric ideals


File: index.htm,  Node: algebra_lib,  Next: elim_lib,  Prev: Commutative algebra,  Up: Commutative algebra

D.4.1 algebra_lib
-----------------

*Library:*
     algebra.lib

*Purpose:*
     Compute with Algebras and Algebra Maps

*Authors:*
     Gert-Martin Greuel, greuel@mathematik.uni-kl.de,
     Agnes Eileen Heydtmann, agnes@math.uni-sb.de,
     Gerhard Pfister, pfister@mathematik.uni-kl.de

*Procedures:*

* Menu:

* algebra_containment:: query of algebra containment
* module_containment:: query of module containment over a subalgebra
* inSubring:: test whether poly p is in subring generated by I
* algDependent:: computes algebraic relations between generators of I
* alg_kernel:: computes the kernel of the ring map phi
* is_injective:: test for injectivity of ring map phi
* is_surjective:: test for surjectivity of ring map phi
* is_bijective:: test for bijectivity of ring map phi
* noetherNormal:: noether normalization of ideal id
* mapIsFinite:: query for finiteness of map phi:R -> basering/I
* finitenessTest:: find variables which occur as pure power in lead(i)


File: index.htm,  Node: algebra_containment,  Next: module_containment,  Up: algebra_lib

D.4.1.1 algebra_containment
...........................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     algebra_containment(p,A[,k]); p poly, A ideal, k integer.
     A = A[1],...,A[m] generators of subalgebra of the basering

*Return:*

              - k=0 (or if k is not given) an integer:
                1  : if p is contained in the subalgebra K[A[1],...,A[m]]
                0  : if p is not contained in K[A[1],...,A[m]]
              - k=1 : a list, say l, of size 2, l[1] integer, l[2] ring, satisfying
                l[1]=1 if p is in the subalgebra K[A[1],...,A[m]] and then the ring
                l[2] contains poly check = h(y(1),...,y(m)) if p=h(A[1],...,A[m])
                l[1]=0 if p is in not the subalgebra K[A[1],...,A[m]] and then
                l[2] contains the poly check = h(x,y(1),...,y(m)) if p satisfies
                the nonlinear relation p = h(x,A[1],...,A[m]) where
                x = x(1),...,x(n) denote the variables of the basering

*Display:*
     if k=0 and printlevel >= voice+1 (default) display the poly check

*Note:*
     The proc inSubring uses a different algorithm which is sometimes
     faster.

*Theory:*
     The ideal of algebraic relations of the algebra generators
     A[1],..., A[m] is computed introducing new variables y(i) and the
     product order with x(i) >> y(i).
     p reduces to a polynomial only in the y(i) <=> p is contained in
     the subring generated by the polynomials A[1],...,A[m].

*Example:*
     LIB "algebra.lib";
     int p = printlevel; printlevel = 1;
     ring R = 0,(x,y,z),dp;
     ideal A=x2+y2,z2,x4+y4,1,x2z-1y2z,xyz,x3y-1xy3;
     poly p1=z;
     poly p2=
     x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
     algebra_containment(p1,A);
     ==> // x(3)
     ==> 0
     algebra_containment(p2,A);
     ==> // y(1)*y(2)*y(5)^2+y(3)*y(5)^3+4*y(1)*y(2)*y(6)^2+4*y(6)^3*y(7)+2*y(2)*y\
        (5)*y(7)^2
     ==> 1
     list L = algebra_containment(p2,A,1);
     ==> 
     ==> // 'algebra_containment' created a ring as 2nd element of the list.
     ==> // The ring contains the poly check which defines the algebraic relation.
     ==> // To access to the ring and see check you must give the ring a name,
     ==> // e.g.:
     ==>                def S = l[2]; setring S; check;
     ==> 	
     L[1];
     ==> 1
     def S = L[2]; setring S;
     check;
     ==> y(1)*y(2)*y(5)^2+y(3)*y(5)^3+4*y(1)*y(2)*y(6)^2+4*y(6)^3*y(7)+2*y(2)*y(5)\
        *y(7)^2
     printlevel = p;


File: index.htm,  Node: module_containment,  Next: inSubring,  Prev: algebra_containment,  Up: algebra_lib

D.4.1.2 module_containment
..........................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     module_containment(p,P,M[,k]); p poly, P ideal, M ideal, k int
     P = P[1],...,P[n] generators of a subalgebra of the basering,
     M = M[1],...,M[m] generators of a module over the subalgebra K[P]

*Assume:*
     ncols(P) = nvars(basering), the P[i] are algebraically independent

*Return:*

              - k=0 (or if k is not given), an integer:
                1    : if p is contained in the module <M[1],...,M[m]> over K[P]
                0    : if p is not contained in <M[1],...,M[m]>
              - k=1, a list, say l, of size 2, l[1] integer, l[2] ring:
                l[1]=1 : if p is in <M[1],...,M[m]> and then the ring l[2] contains
                  the polynomial check = h(y(1),...,y(m),z(1),...,z(n)) if
                  p = h(M[1],...,M[m],P[1],...,P[n])
                l[1]=0 : if p is in not in <M[1],...,M[m]>, then l[2] contains the
                  poly check = h(x,y(1),...,y(m),z(1),...,z(n)) if p satisfies
                  the nonlinear relation p = h(x,M[1],...,M[m],P[1],...,P[n]) where
                  x = x(1),...,x(n) denote the variables of the basering

*Display:*
     the polynomial h(y(1),...,y(m),z(1),...,z(n)) if k=0, resp.  a
     comment how to access the relation check if k=1, provided
     printlevel >= voice+1 (default).

*Theory:*
     The ideal of algebraic relations of all the generators p1,...,pn,
     s1,...,st given by P and S is computed introducing new variables
     y(j), z(i) and the product order: x^a*y^b*z^c > x^d*y^e*z^f if x^a
     > x^d with respect to the lp ordering or else if z^c > z^f with
     respect to the dp ordering or else if y^b > y^e with respect to the
     lp ordering again. p reduces to a polynomial only in the y(j) and
     z(i), linear in the z(i) <=> p is contained in the module.

*Example:*
     LIB "algebra.lib";
     int p = printlevel; printlevel = 1;
     ring R=0,(x,y,z),dp;
     ideal P = x2+y2,z2,x4+y4;           //algebra generators
     ideal M = 1,x2z-1y2z,xyz,x3y-1xy3;  //module generators
     poly p1=
     x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
     module_containment(p1,P,M);
     ==> // y(2)*z(2)*z(3)^2+z(1)^3*z(2)^2
     ==> 1
     poly p2=z;
     list l = module_containment(p2,P,M,1);
     ==> 
     ==> // 'module_containment' created a ring as 2nd element of the list. The
     ==> // ring contains the poly check which defines the algebraic relation
     ==> // for p. To access to the ring and see check you must give the ring
     ==> // a name, e.g.:
     ==>      def S = l[2]; setring S; check;
     ==>       
     l[1];
     ==> 0
     def S = l[2]; setring S; check;
     ==> x(3)
     printlevel=p;


File: index.htm,  Node: inSubring,  Next: algDependent,  Prev: module_containment,  Up: algebra_lib

D.4.1.3 inSubring
.................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     inSubring(p,i); p poly, i ideal

*Return:*

              a list l of size 2, l[1] integer, l[2] string
              l[1]=1 iff p is in the subring generated by i=i[1],...,i[k],
                     and then l[2] = y(0)-h(y(1),...,y(k)) if p = h(i[1],...,i[k])
              l[1]=0 iff p is in not the subring generated by i,
                     and then l[2] = h(y(0),y(1),...,y(k) where p satisfies the
                     nonlinear relation h(p,i[1],...,i[k])=0.

*Note:*
     the proc algebra_containment tests the same with a different
     algorithm, which is often faster

*Example:*
     LIB "algebra.lib";
     ring q=0,(x,y,z,u,v,w),dp;
     poly p=xyzu2w-1yzu2w2+u4w2-1xu2vw+u2vw2+xyz-1yzw+2u2w-1xv+vw+2;
     ideal I =x-w,u2w+1,yz-v;
     inSubring(p,I);
     ==> [1]:
     ==>    1
     ==> [2]:
     ==>    y(1)*y(2)*y(3)+y(2)^2-y(0)+1


File: index.htm,  Node: algDependent,  Next: alg_kernel,  Prev: inSubring,  Up: algebra_lib

D.4.1.4 algDependent
....................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     algDependent(f[,c]); f ideal (say, f = f1,...,fm), c integer

*Return:*

              a list l  of size 2, l[1] integer, l[2] ring:
              - l[1] = 1 if f1,...,fm are algebraic dependent, 0 if not
              - l[2] is a ring with variables x(1),...,x(n),y(1),...,y(m) if the
                basering has n variables. It contains the ideal 'ker', depending
                only on the y(i) and generating the algebraic relations between the
                f[i], i.e. substituting y(i) by fi yields 0. Of course, ker is
                nothing but the kernel of the ring map
                   K[y(1),...,y(m)] --> basering,  y(i) -> fi.

*Note:*
     Three different algorithms are used depending on c = 1,2,3.  If c
     is not given or c=0, a heuristically best method is chosen.  The
     basering may be a quotient ring.
     To access to the ring l[2] and see ker you must give the ring a
     name, e.g. def S=l[2]; setring S; ker;

*Display:*
     The above comment is displayed if printlevel >= 0 (default).

*Example:*
     LIB "algebra.lib";
     int p = printlevel; printlevel = 1;
     ring R = 0,(x,y,z,u,v,w),dp;
     ideal I = xyzu2w-1yzu2w2+u4w2-1xu2vw+u2vw2+xyz-1yzw+2u2w-1xv+vw+2,
     x-w, u2w+1, yz-v;
     list l = algDependent(I);
     ==> 
     ==> // The 2nd element of the list l is a ring with variables x(1),...,x(n),
     ==> // and y(1),...,y(m) if the basering has n variables and if the ideal
     ==> // is f[1],...,f[m]. The ring contains the ideal ker which depends only
     ==> // on the y(i) and generates the relations between the f[i].
     ==> // I.e. substituting y(i) by f[i] yields 0.
     ==> // To access to the ring and see ker you must give the ring a name,
     ==> // e.g.:
     ==>              def S = l[2]; setring S; ker;
     ==> 	
     l[1];
     ==> 1
     def S = l[2]; setring S;
     ker;
     ==> ker[1]=y(2)*y(3)*y(4)+y(3)^2-y(1)+1
     printlevel = p;


File: index.htm,  Node: alg_kernel,  Next: is_injective,  Prev: algDependent,  Up: algebra_lib

D.4.1.5 alg_kernel
..................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     alg_kernel(phi,pr[,s,c]); phi map to basering, pr preimage ring, s
     string (name of kernel in pr), c integer.

*Return:*
     a string, the kernel of phi as string.
     If, moreover, a string s is given, the algorithm creates, in the
     preimage ring pr the kernel of phi with name s.
     Three different algorithms are used depending on c = 1,2,3.  If c
     is not given or c=0, a heuristically best method is chosen.
     (algorithm 1 uses the preimage command)

*Note:*
     Since the kernel of phi lives in pr, it cannot be returned to the
     basering. If s is given, the user has access to it in pr via s.
     The basering may be a quotient ring.

*Example:*
     LIB "algebra.lib";
     ring r = 0,(a,b,c),ds;
     ring s = 0,(x,y,z,u,v,w),dp;
     ideal I = x-w,u2w+1,yz-v;
     map phi = r,I;                // a map from r to s:
     alg_kernel(phi,r);            // a,b,c ---> x-w,u2w+1,yz-v
     ==> 0
     ring S = 0,(a,b,c),ds;
     ring R = 0,(x,y,z),dp;
     qring Q = std(x-y);
     ideal i = x, y, x2-y3;
     map phi = S,i;                 // a map to a quotient ring
     alg_kernel(phi,S,"ker",3);     // uses algorithm 3
     ==> a-b,b^3-b^2+c
     setring S;                     // you have access to kernel in preimage
     ker;
     ==> ker[1]=a-b
     ==> ker[2]=c-b2+b3


File: index.htm,  Node: is_injective,  Next: is_surjective,  Prev: alg_kernel,  Up: algebra_lib

D.4.1.6 is_injective
....................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     is_injective(phi,pr[,c,s]); phi map, pr preimage ring, c int, s
     string

*Return:*

              - 1 (type int) if phi is injective, 0 if not (if s is not given).
              - If s is given, return a list l of size 2, l[1] int, l[2] ring:
                l[1] is 1 if phi is injective, 0 if not
                l[2] is a ring with variables x(1),...,x(n),y(1),...,y(m) if the
                basering has n variables and the map m components, it contains the
                ideal 'ker', depending only on the y(i), the kernel of the given map

*Note:*
     Three different algorithms are used depending on c = 1,2,3.  If c
     is not given or c=0, a heuristically best method is chosen.  The
     basering may be a quotient ring. However, if the preimage ring is a
     quotient ring, say pr = P/I, consider phi as a map from P and then
     the algorithm returns 1 if the kernel of phi is 0 mod I.  To access
     to the ring l[2] and see ker you must give the ring a name, e.g.
     def S=l[2]; setring S; ker;

*Display:*
     The above comment is displayed if printlevel >= 0 (default).

*Example:*
     LIB "algebra.lib";
     int p = printlevel;
     ring r = 0,(a,b,c),ds;
     ring s = 0,(x,y,z,u,v,w),dp;
     ideal I = x-w,u2w+1,yz-v;
     map phi = r,I;                    // a map from r to s:
     is_injective(phi,r);              // a,b,c ---> x-w,u2w+1,yz-v
     ==> 1
     ring R = 0,(x,y,z),dp;
     ideal i = x, y, x2-y3;
     map phi = R,i;                    // a map from R to itself, z --> x2-y3
     list l = is_injective(phi,R,"");
     ==> 
     ==> // The 2nd element of the list is a ring with variables x(1),...,x(n),
     ==> // y(1),...,y(m) if the basering has n variables and the map is
     ==> // F[1],...,F[m].
     ==> // It contains the ideal ker, the kernel of the given map y(i) --> F[i].
     ==> // To access to the ring and see ker you must give the ring a name,
     ==> // e.g.:
     ==>      def S = l[2]; setring S; ker;
     ==> 	
     l[1];
     ==> 0
     def S = l[2]; setring S;
     ker;
     ==> ker[1]=y(2)^3-y(1)^2+y(3)


File: index.htm,  Node: is_surjective,  Next: is_bijective,  Prev: is_injective,  Up: algebra_lib

D.4.1.7 is_surjective
.....................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     is_surjective(phi); phi map to basering, or ideal defining it

*Return:*
     an integer, 1 if phi is surjective, 0 if not

*Note:*
     The algorithm returns 1 iff all the variables of the basering are
     contained in the polynomial subalgebra generated by the polynomials
     defining phi. Hence, if the basering has local or mixed ordering or
     if the preimage ring is a quotient ring (in which case the map may
     not be well defined) then the return value 1 means
     "surjectivity" in this sense.

*Example:*
     LIB "algebra.lib";
     ring R = 0,(x,y,z),dp;
     ideal i = x, y, x2-y3;
     map phi = R,i;                    // a map from R to itself, z->x2-y3
     is_surjective(phi);
     ==> 0
     qring Q = std(ideal(z-x37));
     map psi = R, x,y,x2-y3;           // the same map to the quotient ring
     is_surjective(psi);
     ==> 1
     ring S = 0,(a,b,c),dp;
     map psi = R,ideal(a,a+b,c-a2+b3); // a map from R to S,
     is_surjective(psi);               // x->a, y->a+b, z->c-a2+b3
     ==> 1


File: index.htm,  Node: is_bijective,  Next: noetherNormal,  Prev: is_surjective,  Up: algebra_lib

D.4.1.8 is_bijective
....................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     is_bijective(phi,pr); phi map to basering, pr preimage ring

*Return:*
     an integer, 1 if phi is bijective, 0 if not

*Note:*
     The algorithm checks first injectivity and then surjectivity To
     interpret this for local/mixed orderings, or for quotient rings
     type help is_surjective; and help is_injective;

*Display:*
     A comment if printlevel >= voice-1 (default)

*Example:*
     LIB "algebra.lib";
     int p = printlevel;  printlevel = 1;
     ring R = 0,(x,y,z),dp;
     ideal i = x, y, x2-y3;
     map phi = R,i;                      // a map from R to itself, z->x2-y3
     is_bijective(phi,R);
     ==> // map not injective
     ==> 0
     qring Q = std(z-x2+y3);
     is_bijective(ideal(x,y,x2-y3),Q);
     ==> 1
     ring S = 0,(a,b,c,d),dp;
     map psi = R,ideal(a,a+b,c-a2+b3,0); // a map from R to S,
     is_bijective(psi,R);                // x->a, y->a+b, z->c-a2+b3
     ==> // map injective, but not surjective
     ==> 0
     qring T = std(d,c-a2+b3);
     ==> // ** _ is no standardbasis
     map chi = Q,a,b,a2-b3;              // amap between two quotient rings
     is_bijective(chi,Q);
     ==> 1
     printlevel = p;


File: index.htm,  Node: noetherNormal,  Next: mapIsFinite,  Prev: is_bijective,  Up: algebra_lib

D.4.1.9 noetherNormal
.....................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     noetherNormal(id[,p]); id ideal, p integer

*Return:*

              a list l two ideals, say I,J:
              - I is generated by a subset of the variables with size(I) = dim(id)
              - J defines a map (coordinate change in the basering), such that:
                if we define  map phi=basering,J;
                then k[var(1),...,var(n)]/phi(id) is finite over k[I].
              If p is given, 0<=p<=100, a sparse coordinate change with p percent
              of the matrix entries being 0 (default: p=0 i.e. dense)

*Note:*
     Designed for characteristic 0.It works also in char k > 0 if it
     terminates,but may result in an infinite loop in small
     characteristic

*Example:*
     LIB "algebra.lib";
     ring r=0,(x,y,z),dp;
     ideal i= xy,xz;
     noetherNormal(i);
     ==> [1]:
     ==>    _[1]=x
     ==>    _[2]=2x+y
     ==>    _[3]=3x+4y+z
     ==> [2]:
     ==>    _[1]=y
     ==>    _[2]=z


File: index.htm,  Node: mapIsFinite,  Next: finitenessTest,  Prev: noetherNormal,  Up: algebra_lib

D.4.1.10 mapIsFinite
....................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     mapIsFinite(phi,R[,J]); R a ring, phi: R --> basering a map J an
     ideal in the basering, J = 0 if not given

*Return:*
     1 if R --> basering/J is finite and 0 else

*Example:*
     LIB "algebra.lib";
     ring r = 0,(a,b,c),dp;
     ring s = 0,(x,y,z),dp;
     ideal i= xy;
     map phi= r,(xy)^3+x2+z,y2-1,z3;
     mapIsFinite(phi,r,i);
     ==> 1


File: index.htm,  Node: finitenessTest,  Prev: mapIsFinite,  Up: algebra_lib

D.4.1.11 finitenessTest
.......................

Procedure from library `algebra.lib' (*note algebra_lib::).

*Usage:*
     finitenessTest(J[,v]); J ideal, v intvec (say v1,...,vr with vi>0)

*Return:*

              a list l with l[1] integer, l[2], l[3], l[4] ideals
              - l[1] = 1 if var(v1),...,var(vr) are in l[2] and 0 else
              - l[2] (resp. l[3]) contains those variables which occur,
                (resp. occur not) as pure power in the leading term of one of the
                generators of J,
              - l[4] contains those J[i] for which the leading term is a pure power
                of a variable (which is then in l[2])
              (default: v = [1,2,..,nvars(basering)])

*Theory:*
     If J is a standard basis of an ideal generated by x_1 - f_1(y),...,
     x_n - f_n with y_j ordered lexicographically and y_j >> x_i, then,
     if y_i appears as pure power in the leading term of J[k]. J[k]
     defines an integral relation for y_i over the y_(i+1),... and the
     f's.  Moreover, in this situation, if l[2] = y_1,...,y_r, then
     K[y_1,...y_r] is finite over K[f_1..f_n]. If J contains furthermore
     polynomials h_j(y), then K[y_1,...y_z]/<h_j> is finite over
     K[f_1..f_n].

*Example:*
     LIB "algebra.lib";
     ring s = 0,(x,y,z,a,b,c),(lp(3),dp);
     ideal i= a -(xy)^3+x2-z, b -y2-1, c -z3;
     ideal j = a -(xy)^3+x2-z, b -y2-1, c -z3, xy;
     finitenessTest(std(i),1..3);
     ==> [1]:
     ==>    0
     ==> [2]:
     ==>    _[1]=y
     ==>    _[2]=z
     ==> [3]:
     ==>    _[1]=x
     ==>    _[2]=a
     ==>    _[3]=b
     ==>    _[4]=c
     ==> [4]:
     ==>    _[1]=z3-c
     ==>    _[2]=y2-b+1
     finitenessTest(std(j),1..3);
     ==> [1]:
     ==>    1
     ==> [2]:
     ==>    _[1]=x
     ==>    _[2]=y
     ==>    _[3]=z
     ==> [3]:
     ==>    _[1]=a
     ==>    _[2]=b
     ==>    _[3]=c
     ==> [4]:
     ==>    _[1]=z3-c
     ==>    _[2]=y2-b+1
     ==>    _[3]=x2-z+a


File: index.htm,  Node: elim_lib,  Next: homolog_lib,  Prev: algebra_lib,  Up: Commutative algebra

D.4.2 elim_lib
--------------

*Library:*
     elim.lib

*Purpose:*
     Elimination, Saturation and Blowing up

*Procedures:*

* Menu:

* blowup0:: create presentation of blownup ring of ideal j
* elim:: variable n..m eliminated from id (ideal/module)
* elim1:: p=product of vars to be eliminated from id
* nselect:: select generators not containing n-th [..m-th] variable
* sat:: saturated quotient of ideal/module id by ideal j
* select:: select generators containing all variables n...m
* select1:: select generators containing one variable n...m


File: index.htm,  Node: blowup0,  Next: elim,  Up: elim_lib

D.4.2.1 blowup0
...............

Procedure from library `elim.lib' (*note elim_lib::).

*Usage:*
     blowup0(j[,s1,s2]); j ideal, s1,s2 nonempty strings

*Create:*
     Create a presentation of the blowup ring of j

*Return:*
     no return value

*Note:*
     s1 and s2 are used to give names to the blownup ring and the
     blownup ideal (default: s1="j", s2="A")
     Assume R = char,x(1..n),ord is the basering of j, and s1="j",
     s2="A" then the procedure creates a new ring with name Bl_jR
     (equal to R[A,B,...])
     Bl_jR = char,(A,B,...,x(1..n)),(dp(k),ord)
     with k=ncols(j) new variables A,B,... and ordering wp(d1..dk) if j
     is homogeneous with deg(j[i])=di resp. dp otherwise for these vars.
     If k>26 or size(s2)>1, say s2="A()", the new vars are
     A(1),...,A(k).  Let j_ be the kernel of the ring map Bl_jR -> R
     defined by A(i)->j[i], x(i)->x(i), then the quotient ring Bl_jR/j_
     is the blowup ring of j in R (being isomorphic to R+j+j^2+...).
     Moreover the procedure creates a std basis of j_ with name j_ in
     Bl_jR.
     This proc uses 'execute' or calls a procedure using 'execute'.

*Display:*
     printlevel >=0: explain created objects (default)

*Example:*
     LIB "elim.lib";
     ring R=0,(x,y),dp;
     poly f=y2+x3; ideal j=jacob(f);
     blowup0(j);
     ==> 
     ==> // The proc created the ring Bl_jR (equal to R[A,B])
     ==> // it contains the ideal j_ , such that
     ==> //             Bl_jR/j_ is the blowup ring
     ==> // show(Bl_jR); shows this ring.
     ==> // Make Bl_jR the basering and see j_ by typing:
     ==>    setring Bl_jR;
     ==>    j_;
     show(Bl_jR);
     ==> // ring: (0),(A,B,x,y),(wp(2,1),dp(2),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> // j_                   [0]  ideal, 1 generator(s)
     setring Bl_jR;
     j_;"";
     ==> j_[1]=2Ay-3Bx2
     ==> 
     ring r=32003,(x,y,z),ds;
     blowup0(maxideal(1),"m","T()");
     ==> 
     ==> // The proc created the ring Bl_mr (equal to r[T(1..3)])
     ==> // it contains the ideal m_ , such that
     ==> //             Bl_mr/m_ is the blowup ring
     ==> // show(Bl_mr); shows this ring.
     ==> // Make Bl_mr the basering and see m_ by typing:
     ==>    setring Bl_mr;
     ==>    m_;
     show(Bl_mr);
     ==> // ring: (32003),(T(1),T(2),T(3),x,y,z),(wp(1,1,1),ds(3),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> // m_                   [0]  ideal, 3 generator(s)
     setring Bl_mr;
     m_;
     ==> m_[1]=T(1)y-T(2)x
     ==> m_[2]=T(1)z-T(3)x
     ==> m_[3]=T(2)z-T(3)y
     kill Bl_jR, Bl_mr;


File: index.htm,  Node: elim,  Next: elim1,  Prev: blowup0,  Up: elim_lib

D.4.2.2 elim
............

Procedure from library `elim.lib' (*note elim_lib::).

*Usage:*
     elim(id,n,m); id ideal/module, n,m integers

*Returns:*
     ideal/module obtained from id by eliminating variables n..m

*Note:*
     no special monomial ordering is required, result is a SB with
     respect to ordering dp (resp. ls) if the first var not to be
     eliminated belongs to a -p (resp. -s) block ordering
     This proc uses 'execute' or calls a procedure using 'execute'.

*Example:*
     LIB "elim.lib";
     ring r=0,(x,y,u,v,w),dp;
     ideal i=x-u,y-u2,w-u3,v-x+y3;
     elim(i,3,4);
     ==> _[1]=y2-xw
     ==> _[2]=xy-w
     ==> _[3]=x2-y
     module m=i*gen(1)+i*gen(2);
     m=elim(m,3,4);show(m);
     ==> // module, 6 generator(s)
     ==> [y2-xw]
     ==> [0,y2-xw]
     ==> [xy-w]
     ==> [0,xy-w]
     ==> [x2-y]
     ==> [0,x2-y]

* Menu:

See also:
* elim1::
* eliminate::

*See also:* *note elim1::; *note eliminate::.


File: index.htm,  Node: elim1,  Next: nselect,  Prev: elim,  Up: elim_lib

D.4.2.3 elim1
.............

Procedure from library `elim.lib' (*note elim_lib::).

*Usage:*
     elim1(id,p); id ideal/module, p product of vars to be eliminated

*Return:*
     ideal/module obtained from id by eliminating vars occurring in poly

*Note:*
     no special monomial ordering is required, result is a SB with
     respect to ordering dp (resp. ls) if the first var not to be
     eliminated belongs to a -p (resp. -s) block ordering
     This proc uses 'execute' or calls a procedure using 'execute'.

*Example:*
     LIB "elim.lib";
     ring r=0,(x,y,t,s,z),dp;
     ideal i=x-t,y-t2,z-t3,s-x+y3;
     elim1(i,ts);
     ==> _[1]=y2-xz
     ==> _[2]=xy-z
     ==> _[3]=x2-y
     module m=i*gen(1)+i*gen(2);
     m=elim1(m,st); show(m);
     ==> // module, 6 generator(s)
     ==> [y2-xz]
     ==> [0,y2-xz]
     ==> [xy-z]
     ==> [0,xy-z]
     ==> [x2-y]
     ==> [0,x2-y]

* Menu:

See also:
* elim::
* eliminate::

*See also:* *note elim::; *note eliminate::.


File: index.htm,  Node: nselect,  Next: sat,  Prev: elim1,  Up: elim_lib

D.4.2.4 nselect
...............

Procedure from library `elim.lib' (*note elim_lib::).

*Usage:*
     nselect(id,n[,m]); id a module or ideal, n, m integers

*Return:*
     generators of id not containing the variable n [up to m]

*Example:*
     LIB "elim.lib";
     ring r=0,(x,y,t,s,z),(c,dp);
     ideal i=x-y,y-z2,z-t3,s-x+y3;
     nselect(i,3);
     ==> _[1]=x-y
     ==> _[2]=-z2+y
     ==> _[3]=y3-x+s
     module m=i*(gen(1)+gen(2));
     show(m);
     ==> // module, 4 generator(s)
     ==> [x-y,x-y]
     ==> [-z2+y,-z2+y]
     ==> [-t3+z,-t3+z]
     ==> [y3-x+s,y3-x+s]
     show(nselect(m,3,4));
     ==> // module, 2 generator(s)
     ==> [x-y,x-y]
     ==> [-z2+y,-z2+y]

* Menu:

See also:
* select::
* select1::

*See also:* *note select::; *note select1::.


File: index.htm,  Node: sat,  Next: select,  Prev: nselect,  Up: elim_lib

D.4.2.5 sat
...........

Procedure from library `elim.lib' (*note elim_lib::).

*Usage:*
     sat(id,j); id=ideal/module, j=ideal

*Return:*
     list of an ideal/module [1] and an integer [2]:
     [1] = saturation of id with respect to j (= union_(k=1...) of
     id:j^k) [2] = saturation exponent (= min( k | id:j^k = id:j^(k+1)
     ))

*Note:*
     [1] is a standard basis in the basering

*Display:*
     saturation exponent during computation if printlevel >=1

*Example:*
     LIB "elim.lib";
     int p      = printlevel;
     ring r     = 2,(x,y,z),dp;
     poly F     = x5+y5+(x-y)^2*xyz;
     ideal j    = jacob(F);
     sat(j,maxideal(1));
     ==> [1]:
     ==>    _[1]=x3+x2y+xy2+y3
     ==>    _[2]=y4+x2yz+y3z
     ==>    _[3]=x2y2+x2yz+y3z
     ==> [2]:
     ==>    4
     printlevel = 2;
     sat(j,maxideal(2));
     ==> // compute quotient 1
     ==> // compute quotient 2
     ==> // compute quotient 3
     ==> // saturation becomes stable after 2 iteration(s)
     ==> 
     ==> [1]:
     ==>    _[1]=x3+x2y+xy2+y3
     ==>    _[2]=y4+x2yz+y3z
     ==>    _[3]=x2y2+x2yz+y3z
     ==> [2]:
     ==>    2
     printlevel = p;


File: index.htm,  Node: select,  Next: select1,  Prev: sat,  Up: elim_lib

D.4.2.6 select
..............

Procedure from library `elim.lib' (*note elim_lib::).

*Usage:*
     select(id,n[,m]); id ideal/module, n, m integers

*Return:*
     generators of id containing the variable n [all variables up to m]

*Note:*
     use 'select1' for selecting generators containing at least one of
     the variables between n and m

*Example:*
     LIB "elim.lib";
     ring r=0,(x,y,t,s,z),(c,dp);
     ideal i=x-y,y-z2,z-t3,s-x+y3;
     ideal j=select(i,1);
     j;
     ==> j[1]=x-y
     ==> j[2]=y3-x+s
     module m=i*(gen(1)+gen(2));
     m;
     ==> m[1]=[x-y,x-y]
     ==> m[2]=[-z2+y,-z2+y]
     ==> m[3]=[-t3+z,-t3+z]
     ==> m[4]=[y3-x+s,y3-x+s]
     select(m,1,2);
     ==> _[1]=[x-y,x-y]
     ==> _[2]=[y3-x+s,y3-x+s]

* Menu:

See also:
* nselect::
* select1::

*See also:* *note nselect::; *note select1::.


File: index.htm,  Node: select1,  Prev: select,  Up: elim_lib

D.4.2.7 select1
...............

Procedure from library `elim.lib' (*note elim_lib::).

*Usage:*
     select1(id,n[,m]); id ideal/module, n, m integers

*Return:*
     generators of id containing the variable n
     [at least one of the variables up to m]

*Note:*
     use 'select' for selecting generators containing all the variables
     between n and m

*Example:*
     LIB "elim.lib";
     ring r=0,(x,y,t,s,z),(c,dp);
     ideal i=x-y,y-z2,z-t3,s-x+y3;
     ideal j=select1(i,1);
     j;
     ==> j[1]=x-y
     ==> j[2]=y3-x+s
     module m=i*(gen(1)+gen(2));
     m;
     ==> m[1]=[x-y,x-y]
     ==> m[2]=[-z2+y,-z2+y]
     ==> m[3]=[-t3+z,-t3+z]
     ==> m[4]=[y3-x+s,y3-x+s]
     select1(m,1,2);
     ==> _[1]=[x-y,x-y]
     ==> _[2]=[-z2+y,-z2+y]
     ==> _[3]=[y3-x+s,y3-x+s]

* Menu:

See also:
* nselect::
* select::

*See also:* *note nselect::; *note select::.


File: index.htm,  Node: homolog_lib,  Next: mprimdec_lib,  Prev: elim_lib,  Up: Commutative algebra

D.4.3 homolog_lib
-----------------

*Library:*
     homolog.lib

*Purpose:*
     Procedures for Homological Algebra

*Authors:*
     Gert-Martin Greuel, greuel@mathematik.uni-kl.de,
     Bernd Martin, martin@math.tu-cottbus.de
     Christoph Lossen, lossen@mathematik.uni-kl.de

*Procedures:*

* Menu:

* cup:: cup: Ext^1(M',M') x Ext^1() -> Ext^2()
* cupproduct:: cup: Ext^p(M',N') x Ext^q(N',P') -> Ext^p+q(M',P')
* depth:: depth(I,M'), I ideal, M module, M'=coker(M)
* Ext_R:: Ext^k(M',R), M module, R basering, M'=coker(M)
* Ext:: Ext^k(M',N'), M,N modules, M'=coker(M), N'=coker(N)
* fitting:: n-th Fitting ideal of M'=coker(M), M module, n int
* flatteningStrat:: Flattening stratification of M'=coker(M), M module
* Hom:: Hom(M',N'), M,N modules, M'=coker(M), N'=coker(N)
* homology:: ker(B)/im(A), homology of complex R^k-A->M'-B->N'
* isCM:: test if coker(M) is Cohen-Macaulay, M module
* isFlat:: test if coker(M) is flat, M module
* isLocallyFree:: test if coker(M) is locally free of constant rank r
* isReg:: test if I is coker(M)-sequence, I ideal, M module
* kernel:: ker(M'-A->N') M,N modules, A matrix
* kohom:: Hom(R^k,A), A matrix over basering R
* kontrahom:: Hom(A,R^k), A matrix over basering R
* KoszulHomology:: n-th Koszul homology H_n(I,coker(M)), I=ideal
* tensorMod:: Tensor product of modules M'=coker(M), N'=coker(N)
* Tor:: Tor_k(M',N'), M,N modules, M'=coker(M), N'=coker(N)


File: index.htm,  Node: cup,  Next: cupproduct,  Up: homolog_lib

D.4.3.1 cup
...........

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     cup(M,[,any,any]); M=module

*Compute:*
     cup-product Ext^1(M',M') x Ext^1(M',M') --> Ext^2(M',M'), where
     M':=R^m/M, if M in R^m, R basering (i.e. M':=coker(matrix(M))).
     If called with >= 2 arguments: compute symmetrized cup-product

*Assume:*
     all Ext's are finite dimensional

*Return:*
     - if called with 1 argument: matrix, the columns of the output
     present the coordinates of b_i&b_j with respect to a kbase of
     Ext^2, where b_1,b_2,... is a kbase of Ext^1 and & denotes cup
product;
     - if called with 2 arguments: matrix, the columns of the output
     present the coordinates of (1/2)(b_i&b_j + b_j&b_i) with respect to
     a kbase of Ext^2;
     - if called with 3 arguments: list,

           L[1] = matrix see above (symmetric case, for >=2 arguments)
           L[2] = matrix of kbase of Ext^1
           L[3] = matrix of kbase of Ext^2

*Note:*
     printlevel >=1; shows what is going on.
     printlevel >=2; shows result in another representation.
     For computing cupproduct of M itself, apply proc to syz(M)!

*Example:*
     LIB "homolog.lib";
     int p      = printlevel;
     ring  rr   = 32003,(x,y,z),(dp,C);
     ideal  I   = x4+y3+z2;
     qring  o   = std(I);
     module M   = [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
     print(cup(M));
     ==> 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
     ==> 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
     ==> 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
     ==> 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
     print(cup(M,1));
     ==> 0,1,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,1,0,0,0,0,0,0 
     // 2nd EXAMPLE  (shows what is going on)
     printlevel = 3;
     ring   r   = 0,(x,y),(dp,C);
     ideal  i   = x2-y3;
     qring  q   = std(i);
     module M   = [-x,y],[-y2,x];
     print(cup(M));
     ==> // vdim (Ext^1) = 2
     ==> // kbase of Ext^1(M,M)
     ==> //  - the columns present the kbase elements in Hom(F(1),F(0))
     ==> //  - F(*) a free resolution of M
     ==> -1,0,
     ==> 0, y,
     ==> 0, 1,
     ==> -1,0 
     ==> // lift kbase of Ext^1:
     ==> //  - the columns present liftings of kbase elements into Hom(F(2),F(1))
     ==> //  - F(*) a free resolution of M 
     ==> 1,0,
     ==> 0,y,
     ==> 0,1,
     ==> 1,0 
     ==> // vdim (Ext^2) = 2
     ==> // kbase of Ext^2(M,M)
     ==> //  - the columns present the kbase elements in Hom(F(2),F(0))
     ==> //  - F(*) is a a free resolution of M 
     ==> -1,0,
     ==> 0, y,
     ==> 0, 1,
     ==> -1,0 
     ==> // matrix of cup-products (in Ext^2)
     ==> 0,-1,0, 0,y,
     ==> 0,0, -y,y,0,
     ==> 0,0, -1,1,0,
     ==> 0,-1,0, 0,y 
     ==> ////// end level 2 //////
     ==> // the associated matrices of the bilinear mapping 'cup' 
     ==> // corresponding to the kbase elements of Ext^2(M,M) are shown,
     ==> //  i.e. the rows of the final matrix are written as matrix of
     ==> //  a bilinear form on Ext^1 x Ext^1
     ==> //-----component 1:
     ==> 0,1,
     ==> 0,0 
     ==> //-----component 2:
     ==> 0, 0,
     ==> -1,1 
     ==> ////// end level 3 //////
     ==> 0,1,0, 0,0,
     ==> 0,0,-1,1,0 
     printlevel = p;


File: index.htm,  Node: cupproduct,  Next: depth,  Prev: cup,  Up: homolog_lib

D.4.3.2 cupproduct
..................

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     cupproduct(M,N,P,p,q[,any]); M,N,P modules, p,q integers

*Compute:*
     cup-product Ext^p(M',N') x Ext^q(N',P') --> Ext^p+q(M',P'), where
     M':=R^m/M, if M in R^m, R basering (i.e. M':=coker(matrix(M)))

*Assume:*
     all Ext's are of finite dimension

*Return:*
     - if called with 5 arguments: matrix of the associated linear map
     Ext^p (tensor) Ext^q -> Ext^p+q, i.e. the columns of <matrix>
     present the coordinates of the cup products (b_i & c_j) with
     respect to a kbase of Ext^p+q (b_i resp. c_j are the choosen bases
     of Ext^p, resp. Ext^q).
     - if called with 6 arguments: list L,

           L[1] = matrix (see above)
           L[2] = matrix of kbase of Ext^p(M',N')
           L[3] = matrix of kbase of Ext^q(N',P')
           L[4] = matrix of kbase of Ext^p+q(N',P')

*Note:*
     printlevel >=1; shows what is going on.
     printlevel >=2; shows the result in another representation.
     For computing the cupproduct of M,N itself, apply proc to syz(M),
     syz(N)!

*Example:*
     LIB "homolog.lib";
     int p      = printlevel;
     ring  rr   = 32003,(x,y,z),(dp,C);
     ideal  I   = x4+y3+z2;
     qring  o   = std(I);
     module M   = [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
     print(cupproduct(M,M,M,1,3));
     ==> 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
     ==> 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
     ==> 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
     ==> 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
     printlevel = 3;
     list l     = (cupproduct(M,M,M,1,3,"any"));
     ==> // vdim Ext(M,N) = 4
     ==> // kbase of Ext^p(M,N)
     ==> //  - the columns present the kbase elements in Hom(F(p),G(0))
     ==> //  - F(*),G(*) are free resolutions of M and N
     ==> 0, 0, 1, 0,  
     ==> 0, y, 0, 0,  
     ==> 1, 0, 0, 0,  
     ==> 0, 0, 0, y,  
     ==> 0, -1,0, 0,  
     ==> 0, 0, x2,0,  
     ==> 0, 0, 0, -x2,
     ==> 1, 0, 0, 0,  
     ==> 0, 0, 0, -1, 
     ==> -1,0, 0, 0,  
     ==> 0, 1, 0, 0,  
     ==> 0, 0, 1, 0,  
     ==> -1,0, 0, 0,  
     ==> 0, 0, 0, x2y,
     ==> 0, 0, x2,0,  
     ==> 0, -y,0, 0   
     ==> // vdim Ext(N,P) = 4
     ==> // kbase of Ext(N,P):
     ==> 0, 0, 1,  0,  
     ==> 0, 0, 0,  y,  
     ==> 1, 0, 0,  0,  
     ==> 0, -y,0,  0,  
     ==> 0, -1,0,  0,  
     ==> 1, 0, 0,  0,  
     ==> 0, 0, 0,  -x2,
     ==> 0, 0, -x2,0,  
     ==> 0, 0, 0,  -1, 
     ==> 0, 0, 1,  0,  
     ==> 0, 1, 0,  0,  
     ==> 1, 0, 0,  0,  
     ==> -1,0, 0,  0,  
     ==> 0, -y,0,  0,  
     ==> 0, 0, x2, 0,  
     ==> 0, 0, 0,  -x2y
     ==> // kbase of Ext^q(N,P)
     ==> //  - the columns present the kbase elements in Hom(G(q),H(0))
     ==> //  - G(*),H(*) are free resolutions of N and P
     ==> 0, 0, 1,  0,  
     ==> 0, 0, 0,  y,  
     ==> 1, 0, 0,  0,  
     ==> 0, -y,0,  0,  
     ==> 0, -1,0,  0,  
     ==> 1, 0, 0,  0,  
     ==> 0, 0, 0,  -x2,
     ==> 0, 0, -x2,0,  
     ==> 0, 0, 0,  -1, 
     ==> 0, 0, 1,  0,  
     ==> 0, 1, 0,  0,  
     ==> 1, 0, 0,  0,  
     ==> -1,0, 0,  0,  
     ==> 0, -y,0,  0,  
     ==> 0, 0, x2, 0,  
     ==> 0, 0, 0,  -x2y
     ==> // vdim Ext(M,P) = 4
     ==> // kbase of Ext^p+q(M,P)
     ==> //  - the columns present the kbase elements in Hom(F(p+q),H(0))
     ==> //  - F(*),H(*) are free resolutions of M and P
     ==> 0, 0, 1,  0,  
     ==> 0, 0, 0,  y,  
     ==> 1, 0, 0,  0,  
     ==> 0, -y,0,  0,  
     ==> 0, -1,0,  0,  
     ==> 1, 0, 0,  0,  
     ==> 0, 0, 0,  -x2,
     ==> 0, 0, -x2,0,  
     ==> 0, 0, 0,  -1, 
     ==> 0, 0, 1,  0,  
     ==> 0, 1, 0,  0,  
     ==> 1, 0, 0,  0,  
     ==> -1,0, 0,  0,  
     ==> 0, -y,0,  0,  
     ==> 0, 0, x2, 0,  
     ==> 0, 0, 0,  -x2y
     ==> // lifting of kbase of Ext^p(M,N)
     ==> //  - the columns present liftings of kbase elements in Hom(F(p+q),G(q))
     ==> 1,0, 0, 0,  
     ==> 0,-y,0, 0,  
     ==> 0,0, x2,0,  
     ==> 0,0, 0, x2y,
     ==> 0,1, 0, 0,  
     ==> 1,0, 0, 0,  
     ==> 0,0, 0, -x2,
     ==> 0,0, x2,0,  
     ==> 0,0, -1,0,  
     ==> 0,0, 0, y,  
     ==> 1,0, 0, 0,  
     ==> 0,y, 0, 0,  
     ==> 0,0, 0, -1, 
     ==> 0,0, -1,0,  
     ==> 0,-1,0, 0,  
     ==> 1,0, 0, 0   
     ==> // matrix of cup-products (in Ext^p+q)
     ==> 0,0, 0, -1, 0,   0, 0, 0,   y,   1,  0,  0,  0,  0,   y,   0,  0,   
     ==> 0,0, 0, 0,  y,   0, 0, y,   0,   0,  -y, 0,  0,  y,   0,   0,  0,   
     ==> 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
     ==> 0,0, y, 0,  0,   -y,0, 0,   0,   0,  0,  0,  x2y,0,   0,   x2y,0,   
     ==> 0,0, 1, 0,  0,   -1,0, 0,   0,   0,  0,  0,  x2, 0,   0,   x2, 0,   
     ==> 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
     ==> 0,0, 0, 0,  -x2, 0, 0, -x2, 0,   0,  x2, 0,  0,  -x2, 0,   0,  0,   
     ==> 0,0, 0, x2, 0,   0, 0, 0,   -x2y,-x2,0,  0,  0,  0,   -x2y,0,  0,   
     ==> 0,0, 0, 0,  -1,  0, 0, -1,  0,   0,  1,  0,  0,  -1,  0,   0,  0,   
     ==> 0,0, 0, -1, 0,   0, 0, 0,   y,   1,  0,  0,  0,  0,   y,   0,  0,   
     ==> 0,0, -1,0,  0,   1, 0, 0,   0,   0,  0,  0,  -x2,0,   0,   -x2,0,   
     ==> 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
     ==> 0,-1,0, 0,  0,   0, -y,0,   0,   0,  0,  -x2,0,  0,   0,   0,  x2y, 
     ==> 0,0, y, 0,  0,   -y,0, 0,   0,   0,  0,  0,  x2y,0,   0,   x2y,0,   
     ==> 0,0, 0, -x2,0,   0, 0, 0,   x2y, x2, 0,  0,  0,  0,   x2y, 0,  0,   
     ==> 0,0, 0, 0,  -x2y,0, 0, -x2y,0,   0,  x2y,0,  0,  -x2y,0,   0,  0    
     ==> ////// end level 2 //////
     ==> // the associated matrices of the bilinear mapping 'cup' 
     ==> // corresponding to the kbase elements of Ext^p+q(M,P) are shown,
     ==> //  i.e. the rows of the final matrix are written as matrix of
     ==> //  a bilinear form on Ext^p x Ext^q
     ==> //----component 1:
     ==> 0,1,0,0,
     ==> 0,0,0,0,
     ==> 0,0,0,0,
     ==> 0,0,0,0 
     ==> //----component 2:
     ==> 0,0,-1,0,
     ==> 0,1,0, 0,
     ==> 0,0,0, 0,
     ==> 0,0,0, 0 
     ==> //----component 3:
     ==> 0,0,0,-1,
     ==> 0,0,0,0, 
     ==> 0,1,0,0, 
     ==> 0,0,0,0  
     ==> //----component 4:
     ==> 0,0,0, 0,
     ==> 1,0,0, 1,
     ==> 0,0,-1,0,
     ==> 0,1,0, 0 
     ==> ////// end level 3 //////
     show(l[1]);show(l[2]);
     ==> // matrix, 4x17
     ==> 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
     ==> 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
     ==> 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
     ==> 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
     ==> // matrix, 16x4
     ==> 0, 0, 1, 0,  
     ==> 0, y, 0, 0,  
     ==> 1, 0, 0, 0,  
     ==> 0, 0, 0, y,  
     ==> 0, -1,0, 0,  
     ==> 0, 0, x2,0,  
     ==> 0, 0, 0, -x2,
     ==> 1, 0, 0, 0,  
     ==> 0, 0, 0, -1, 
     ==> -1,0, 0, 0,  
     ==> 0, 1, 0, 0,  
     ==> 0, 0, 1, 0,  
     ==> -1,0, 0, 0,  
     ==> 0, 0, 0, x2y,
     ==> 0, 0, x2,0,  
     ==> 0, -y,0, 0   
     printlevel = p;


File: index.htm,  Node: depth,  Next: Ext_R,  Prev: cupproduct,  Up: homolog_lib

D.4.3.3 depth
.............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     depth(M,[I]); M module, I ideal

*Return:*
     int,
     - if called with 1 argument: the depth of M'=coker(M) w.r.t. the
     maxideal in the basering (which is then assumed to be local)
     - if called with 2 arguments: the depth of M'=coker(M) w.r.t. the
     ideal I.

*Note:*
     procedure makes use of KoszulHomology.

*Example:*
     LIB "homolog.lib";
     ring R=0,(x,y,z),dp;
     ideal I=x2,xy,yz;
     module M=0;
     depth(M,I);   // depth(<x2,xy,yz>,Q[x,y,z])
     ==> 2
     ring r=0,(x,y,z),ds;  // local ring
     matrix M[2][2]=x,xy,1+yz,0;
     print(M);
     ==> x,   xy,
     ==> 1+yz,0  
     depth(M);     // depth(maxideal,coker(M))
     ==> 2
     ideal I=x;
     depth(M,I);   // depth(<x>,coker(M))
     ==> 0
     I=x+z;
     depth(M,I);   // depth(<x+z>,coker(M))
     ==> 1


File: index.htm,  Node: Ext_R,  Next: Ext,  Prev: depth,  Up: homolog_lib

D.4.3.4 Ext_R
.............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     Ext_R(v,M[,p]); v int resp. intvec , M module, p int

*Compute:*
     A presentation of Ext^k(M',R); for k=v[1],v[2],..., M'=coker(M).
     Let

            0 <-- M' <-- F0 <-M-- F1 <-- F2 <-- ...

     be a free resolution of M'. If

                  0 --> F0* -A1-> F1* -A2-> F2* -A3-> ...

     is the dual sequence, Fi*=Hom(Fi,R), then Ext^k = ker(Ak+1)/im(Ak)
     is presented as in the following exact sequences:

              R^p --syz(Ak+1)-> Fk* ---Ak+1---->  Fk+1* ,
              R^q ----Ext^k---> R^p --syz(Ak+1)-> Fk*/im(Ak).

     Hence, Ext^k=modulo(syz(Ak+1),Ak) presents Ext^k(M',R).

*Return:*
     - module Ext, a presentation of Ext^k(M',R) if v is of type int
     - a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.
     - In case of a third argument of type int return a list l:

          l[1] = module Ext^k resp. list of Ext^k
          l[2] = SB of Ext^k resp. list of SB of Ext^k
          l[3] = matrix resp. list of matrices, each representing a kbase of Ext^k 
                   (if finite dimensional)

*Display:*
     printlevel >=0: (affine) dimension of Ext^k for each k (default)
     printlevel >=1: Ak, Ak+1 and kbase of Ext^k in Fk*

*Note:*
     In order to compute Ext^k(M,R) use the command Ext_R(k,syz(M)); or
     the 2 commands: list L=mres(M,2); Ext_R(k,L[2]);

*Example:*
     LIB "homolog.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 0,(x,y,z),dp;
     ideal i    = x2y,y2z,z3x;
     module E   = Ext_R(1,i);    //computes Ext^1(r/i,r)
     ==> // Computing Ext^1:
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
     ==> // then F1*-->F2* is given by:
     ==> x2, -yz,0,  
     ==> 0,  z3, -xy,
     ==> xz2,0,  -y2 
     ==> // and F0*-->F1* is given by:
     ==> y2z,
     ==> x2y,
     ==> xz3 
     ==> 
     ==> // dimension of Ext^1:  -1
     ==> 
     is_zero(E);
     ==> 1
     qring R    = std(x2+yz);
     intvec v   = 0,2;
     printlevel = 2;             //shows what is going on
     ideal i    = x,y,z;         //computes Ext^i(r/(x,y,z),r/(x2+yz)), i=0,2
     list L     = Ext_R(v,i,1);  //over the qring R=r/(x2+yz), std and kbase
     ==> // Computing Ext^0:
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
     ==> // then F0*-->F1* is given by:
     ==> z,
     ==> y,
     ==> x 
     ==> // and F-1*-->F0* is given by:
     ==> 0
     ==> 
     ==> // dimension of Ext^0:  -1
     ==> 
     ==> // columns of matrix are kbase of Ext^0 in F0*:
     ==> 0
     ==> 
     ==> // Computing Ext^2:
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
     ==> // then F2*-->F3* is given by:
     ==> x,-y,z, 0,
     ==> z,x, 0, z,
     ==> 0,0, x, y,
     ==> 0,0, -z,x 
     ==> // and F1*-->F2* is given by:
     ==> y,-z,0, 
     ==> x,0, -z,
     ==> 0,x, -y,
     ==> 0,z, x  
     ==> 
     ==> // dimension of Ext^2:  0
     ==> // vdim of Ext^2:       1
     ==> 
     ==> // columns of matrix are kbase of Ext^2 in F2*:
     ==> x, 
     ==> -z,
     ==> 0, 
     ==> 0  
     ==> 
     printlevel = p;

