This is singular.hlp, produced by makeinfo version 4.13 from
singular.texi.


File: singular.hlp,  Node: primary_charp_without_random,  Next: power_products,  Prev: primary_charp_no_molien_random,  Up: finvar_lib

D.6.1.22 primary_charp_without_random
.....................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_charp_without_random(G1,G2,...,r[,v]);
     G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
     where -|r| to |r| is the range of coefficients of the random
     combinations of bases elements, v: an optional <int>

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring

*Theory:*
     Bases of homogeneous invariants are generated successively and
     random linear combinations are chosen as primary invariants that
     lower the dimension of the ideal generated by the previously found
     invariants (see "Generating a Noetherian Normalization of the
     Invariant Ring of a Finite Group" by Decker, Heydtmann, Schreyer
     (1998)). No Reynolds operator or Molien series is used.

*Example:*
     LIB "finvar.lib";
     ring R=2,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix P=primary_charp_without_random(A,1);
     print(P);
     ==> x+y,z,xy


File: singular.hlp,  Node: power_products,  Next: secondary_char0,  Prev: primary_charp_without_random,  Up: finvar_lib

D.6.1.23 power_products
.......................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     power_products(dv,d);
     dv: an <intvec> giving the degrees of homogeneous polynomials, d:
     the degree of the desired power products

*Return:*
     a size(dv)*m <intmat> where each column ought to be interpreted as
     containing the exponents of the corresponding polynomials. The
     product of the powers is then homogeneous of degree d.

*Example:*
     LIB "finvar.lib";
     intvec dv=5,5,5,10,10;
     print(power_products(dv,10));
     ==>      2     1     1     0     0     0     0     0
     ==>      0     1     0     2     1     0     0     0
     ==>      0     0     1     0     1     2     0     0
     ==>      0     0     0     0     0     0     1     0
     ==>      0     0     0     0     0     0     0     1
     print(power_products(dv,7));
     ==>      0
     ==>      0
     ==>      0
     ==>      0
     ==>      0


File: singular.hlp,  Node: secondary_char0,  Next: secondary_charp,  Prev: power_products,  Up: finvar_lib

D.6.1.24 secondary_char0
........................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     secondary_char0(P,REY,M[,v]);
     P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
     representing the Reynolds operator, M: a 1x2 <matrix> giving
     numerator and denominator of the Molien series, v: an optional
     <int>

*Assume:*
     n is the number of variables of the basering, g the size of the
     group, REY is the 1st return value of group_reynolds(),
     reynolds_molien() or the second one of primary_invariants(), M the
     return value of molien() or the second one of reynolds_molien() or
     the third one of primary_invariants()

*Return:*
     secondary invariants of the invariant ring (type <matrix>) and
     irreducible secondary invariants (type <matrix>)

*Display:*
     information if v does not equal 0

*Theory:*
     The secondary invariants are calculated by finding a basis (in
     terms of monomials) of the basering modulo the primary invariants,
     mapping those to invariants with the Reynolds operator and using
     these images or their power products such that they are linearly
     independent modulo the primary invariants (see paper "Some
     Algorithms in Invariant Theory of Finite Groups" by Kemper and
     Steel (1997)).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=primary_invariants(A);
     matrix S,IS=secondary_char0(L[1..3]);
     print(S);
     ==> 1,xyz,x2z-y2z,x3y-xy3
     print(IS);
     ==> xyz,x2z-y2z,x3y-xy3


File: singular.hlp,  Node: secondary_charp,  Next: secondary_no_molien,  Prev: secondary_char0,  Up: finvar_lib

D.6.1.25 secondary_charp
........................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     secondary_charp(P,REY,ringname[,v]);
     P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
     representing the Reynolds operator, ringname: a <string> giving the
     name of a ring of characteristic 0 where the Molien series is
     stored, v: an optional <int>

*Assume:*
     n is the number of variables of the basering, g the size of the
     group, REY is the 1st return value of group_reynolds(),
     reynolds_molien() or the second one of primary_invariants(),
     `ringname` is a ring of char 0 that has been created by molien() or
     reynolds_molien() or primary_invariants()

*Return:*
     secondary invariants of the invariant ring (type <matrix>) and
     irreducible secondary invariants (type <matrix>)

*Display:*
     information if v does not equal 0

*Theory:*
     Secondary invariants are calculated by finding a basis (in terms of
     monomials) of the basering modulo primary invariants, mapping those
     to invariants with the Reynolds operator and using these images or
     their power products such that they are linearly independent modulo
     the primary invariants (see paper "Some Algorithms in Invariant
     Theory of Finite Groups" by Kemper and Steel (1997)).

*Example:*
     LIB "finvar.lib";
     ring R=3,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=primary_invariants(A);
     matrix S,IS=secondary_charp(L[1..size(L)]);
     print(S);
     ==> 1,xyz,x2z-y2z,x3y-xy3
     print(IS);
     ==> xyz,x2z-y2z,x3y-xy3


File: singular.hlp,  Node: secondary_no_molien,  Next: secondary_and_irreducibles_no_molien,  Prev: secondary_charp,  Up: finvar_lib

D.6.1.26 secondary_no_molien
............................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     secondary_no_molien(P,REY[,deg_vec,v]);
     P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
     representing the Reynolds operator, deg_vec: an optional <intvec>
     listing some degrees where no non-trivial homogeneous invariants
     can be found, v: an optional <int>

*Assume:*
     n is the number of variables of the basering, g the size of the
     group, REY is the 1st return value of group_reynolds(),
     reynolds_molien() or the second one of primary_invariants(),
     deg_vec is the second return value of primary_char0_no_molien(),
     primary_charp_no_molien(), primary_char0_no_molien_random() or
     primary_charp_no_molien_random()

*Return:*
     secondary invariants of the invariant ring (type <matrix>)

*Display:*
     information if v does not equal 0

*Theory:*
     Secondary invariants are calculated by finding a basis (in terms of
     monomials) of the basering modulo primary invariants, mapping those
     to invariants with the Reynolds operator and using these images as
     candidates for secondary invariants.

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=primary_invariants(A,intvec(1,1,0));
     matrix S=secondary_no_molien(L[1..3]);
     print(S);
     ==> 1,xyz,x2z-y2z,x3y-xy3


File: singular.hlp,  Node: secondary_and_irreducibles_no_molien,  Next: secondary_not_cohen_macaulay,  Prev: secondary_no_molien,  Up: finvar_lib

D.6.1.27 secondary_and_irreducibles_no_molien
.............................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     secondary_and_irreducibles_no_molien(P,REY[,v]);
     P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
     representing the Reynolds operator, v: an optional <int>

*Assume:*
     n is the number of variables of the basering, g the size of the
     group, REY is the 1st return value of group_reynolds(),
     reynolds_molien() or the second one of primary_invariants()

*Return:*
     secondary invariants of the invariant ring (type <matrix>) and
     irreducible secondary invariants (type <matrix>)

*Display:*
     information if v does not equal 0

*Theory:*
     Secondary invariants are calculated by finding a basis (in terms of
     monomials) of the basering modulo primary invariants, mapping those
     to invariants with the Reynolds operator and using these images or
     their power products such that they are linearly independent modulo
     the primary invariants (see paper "Some Algorithms in Invariant
     Theory of Finite Groups" by Kemper and Steel (1997)).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=primary_invariants(A,intvec(1,1,0));
     matrix S,IS=secondary_and_irreducibles_no_molien(L[1..2]);
     print(S);
     ==> 1,xyz,x2z-y2z,x3y-xy3
     print(IS);
     ==> xyz,x2z-y2z,x3y-xy3


File: singular.hlp,  Node: secondary_not_cohen_macaulay,  Next: orbit_variety,  Prev: secondary_and_irreducibles_no_molien,  Up: finvar_lib

D.6.1.28 secondary_not_cohen_macaulay
.....................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     secondary_not_cohen_macaulay(P,G1,G2,...[,v]);
     P: a 1xn <matrix> with primary invariants, G1,G2,...: nxn
     <matrices> generating a finite matrix group, v: an optional <int>

*Assume:*
     n is the number of variables of the basering

*Return:*
     secondary invariants of the invariant ring (type <matrix>)

*Display:*
     information if v does not equal 0

*Theory:*
     Secondary invariants are generated following "Generating Invariant
     Rings of Finite Groups over Arbitrary Fields" by Kemper (1996).

*Example:*
     LIB "finvar.lib";
     ring R=2,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=primary_invariants(A);
     matrix S=secondary_not_cohen_macaulay(L[1],A);
     print(S);
     ==> 1


File: singular.hlp,  Node: orbit_variety,  Next: relative_orbit_variety,  Prev: secondary_not_cohen_macaulay,  Up: finvar_lib

D.6.1.29 orbit_variety
......................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     orbit_variety(F,s);
     F: a 1xm <matrix> defining an invariant ring, s: a <string> giving
     the name for a new ring

*Return:*
     a Groebner basis (type <ideal>, named G) for the ideal defining the
     orbit variety (i.e. the syzygy ideal) in the new ring (named `s`)

*Theory:*
     The ideal of algebraic relations of the invariant ring generators
     is calculated, then the variables of the original ring are
     eliminated and the polynomials that are left over define the orbit
     variety

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix F[1][7]=x2+y2,z2,x4+y4,1,x2z-1y2z,xyz,x3y-1xy3;
     string newring="E";
     orbit_variety(F,newring);
     print(G);
     ==> y(4)-1,
     ==> y(5)*y(6)-y(2)*y(7),
     ==> y(2)*y(3)-y(5)^2-2*y(6)^2,
     ==> y(1)^2*y(6)-2*y(3)*y(6)+y(5)*y(7),
     ==> y(1)^2*y(5)-y(3)*y(5)-2*y(6)*y(7),
     ==> y(1)^2*y(2)-y(2)*y(3)-2*y(6)^2,
     ==> y(1)^4-3*y(1)^2*y(3)+2*y(3)^2+2*y(7)^2
     basering;
     ==> //   characteristic : 0
     ==> //   number of vars : 7
     ==> //        block   1 : ordering dp
     ==> //                  : names    y(1) y(2) y(3) y(4) y(5) y(6) y(7) 
     ==> //        block   2 : ordering C


File: singular.hlp,  Node: relative_orbit_variety,  Next: image_of_variety,  Prev: orbit_variety,  Up: finvar_lib

D.6.1.30 relative_orbit_variety
...............................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     relative_orbit_variety(I,F,s);
     I: an <ideal> invariant under the action of a group, F: a 1xm
     <matrix> defining the invariant ring of this group, s: a <string>
     giving a name for a new ring

*Return:*
     a Groebner basis (type <ideal>, named G) for the ideal defining the
     relative orbit variety with respect to I in the new ring (named s)

*Theory:*
     A Groebner basis of the ideal of algebraic relations of the
     invariant ring generators is calculated, then one of the basis
     elements plus the ideal generators. The variables of the original
     ring are eliminated and the polynomials that are left define the
     relative orbit variety with respect to I.

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix F[1][3]=x+y+z,xy+xz+yz,xyz;
     ideal I=x2+y2+z2-1,x2y+y2z+z2x-2x-2y-2z,xy2+yz2+zx2-2x-2y-2z;
     string newring="E";
     relative_orbit_variety(I,F,newring);
     print(G);
     ==> 27*y(3)^6-513*y(3)^4+33849*y(3)^2-784,
     ==> 1475*y(2)+9*y(3)^4-264*y(3)^2+736,
     ==> 8260*y(1)+9*y(3)^5-87*y(3)^3+5515*y(3)
     basering;
     ==> //   characteristic : 0
     ==> //   number of vars : 3
     ==> //        block   1 : ordering lp
     ==> //                  : names    y(1) y(2) y(3) 
     ==> //        block   2 : ordering C


File: singular.hlp,  Node: image_of_variety,  Prev: relative_orbit_variety,  Up: finvar_lib

D.6.1.31 image_of_variety
.........................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     image_of_variety(I,F);
     I: an arbitrary <ideal>, F: a 1xm <matrix> defining an invariant
     ring of a some matrix group

*Return:*
     the <ideal> defining the image under that group of the variety
     defined by I

*Theory:*
     relative_orbit_variety(I,F,s) is called and the newly introduced
     variables in the output are replaced by the generators of the
     invariant ring. This ideal in the original variables defines the
     image of the variety defined by I

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix F[1][3]=x+y+z,xy+xz+yz,xyz;
     ideal I=xy;
     print(image_of_variety(I,F));
     ==> xyz


File: singular.hlp,  Node: ainvar_lib,  Next: rinvar_lib,  Prev: finvar_lib,  Up: Invariant theory

D.6.2 ainvar_lib
----------------

*Library:*
     ainvar.lib

*Purpose:*
     Invariant Rings of the Additive Group

*Authors:*
     Gerhard Pfister (email: pfister@mathematik.uni-kl.de), Gert-Martin
     Greuel (email: greuel@mathematik.uni-kl.de)

*Procedures:*

* Menu:

* invariantRing:: compute ring of invariants of (K,+)-action given by m
* derivate:: derivation of f with respect to the vector field m
* actionIsProper:: tests whether action defined by m is proper
* reduction:: SAGBI reduction of p in the subring generated by I
* completeReduction:: complete SAGBI reduction
* localInvar:: invariant polynomial under m computed from p,...
* furtherInvar:: compute further invariants of m from the given ones
* sortier:: sorts generators of id by increasing leading terms


File: singular.hlp,  Node: invariantRing,  Next: derivate,  Up: ainvar_lib

D.6.2.1 invariantRing
.....................

Procedure from library `ainvar.lib' (*note ainvar_lib::).

*Usage:*
     invariantRing(m,p,q,b[,r,pa]); m matrix, p,q poly, b,r int, pa
     string

*Assume:*
     p,q variables with m(p)=q and q invariant under m
     i.e. if p=x(i) and q=x(j) then m[j,1]=0 and m[i,1]=x(j)

*Return:*
     ideal, containing generators of the ring of invariants of the
     additive group (K,+) given by the vector field

              m = m[1,1]*d/dx(1) +...+ m[n,1]*d/dx(n).

     If b>0 the computation stops after all invariants of degree <= b
     (and at least one of higher degree) are found or when all
     invariants are computed.
     If b<=0, the computation continues until all generators of the ring
     of invariants are computed (should be used only if the ring of
     invariants is known to be finitely generated otherwise the
     algorithm might not stop).
     If r=1 a different reduction is used which is sometimes faster
     (default r=0).

*Display:*
     if pa is given (any string as 5th or 6th argument), the computation
     pauses whenever new invariants are found and displays them

*Theory:*
     The algorithm to compute the ring of invariants works in char 0 or
     big enough characteristic. (K,+) acts as the exponential of the
     vector field defined by the matrix m. For background see G.-M.
     Greuel, G. Pfister, Geometric quotients of unipotent group actions,
     Proc.  London Math. Soc. (3) 67, 75-105 (1993).

*Example:*
     LIB "ainvar.lib";
     //Winkelmann: free action but Spec(k[x(1),...,x(5)]) --> Spec(invariant ring)
     //is not surjective
     ring rw=0,(x(1..5)),dp;
     matrix m[5][1];
     m[3,1]=x(1);
     m[4,1]=x(2);
     m[5,1]=1+x(1)*x(4)+x(2)*x(3);
     ideal in=invariantRing(m,x(3),x(1),0);      //compute full invarint ring
     in;
     ==> in[1]=x(1)
     ==> in[2]=x(2)
     ==> in[3]=x(2)*x(3)*x(4)-x(2)*x(5)+x(4)
     ==> in[4]=x(1)*x(3)*x(4)-x(1)*x(5)+x(3)
     //Deveney/Finston: The ring of invariants is not finitely generated
     ring rf=0,(x(1..7)),dp;
     matrix m[7][1];
     m[4,1]=x(1)^3;
     m[5,1]=x(2)^3;
     m[6,1]=x(3)^3;
     m[7,1]=(x(1)*x(2)*x(3))^2;
     ideal in=invariantRing(m,x(4),x(1),6);      //all invariants up to degree 6
     in;
     ==> in[1]=x(1)
     ==> in[2]=x(3)
     ==> in[3]=x(2)
     ==> in[4]=x(3)^3*x(4)-x(1)^3*x(6)
     ==> in[5]=x(2)^3*x(4)-x(1)^3*x(5)
     ==> in[6]=x(2)^2*x(3)^2*x(4)-x(1)*x(7)
     ==> in[7]=x(1)^2*x(2)^2*x(6)-x(3)*x(7)
     ==> in[8]=x(1)^2*x(3)^2*x(5)-x(2)*x(7)
     ==> in[9]=x(1)^2*x(2)*x(3)^4*x(4)*x(5)+x(1)^2*x(2)^4*x(3)*x(4)*x(6)-x(1)^5*x(\
        2)*x(3)*x(5)*x(6)-2*x(2)^2*x(3)^2*x(4)*x(7)+x(1)*x(7)^2


File: singular.hlp,  Node: derivate,  Next: actionIsProper,  Prev: invariantRing,  Up: ainvar_lib

D.6.2.2 derivate
................

Procedure from library `ainvar.lib' (*note ainvar_lib::).

*Usage:*
     derivate(m,id); m matrix, id poly/vector/ideal

*Assume:*
     m is a nx1 matrix, where n = number of variables of the basering

*Return:*
     poly/vector/ideal (same type as input), result of applying the
     vector field by the matrix m componentwise to id;

*Note:*
     the vector field is m[1,1]*d/dx(1) +...+ m[1,n]*d/dx(n)

*Example:*
     LIB "ainvar.lib";
     ring q=0,(x,y,z,u,v,w),dp;
     poly f=2xz-y2;
     matrix m[6][1] =x,y,0,u,v;
     derivate(m,f);
     ==> -2y2+2xz
     vector v = [2xz-y2,u6-3];
     derivate(m,v);
     ==> 6u6*gen(2)-2y2*gen(1)+2xz*gen(1)
     derivate(m,ideal(2xz-y2,u6-3));
     ==> _[1]=-2y2+2xz
     ==> _[2]=6u6


File: singular.hlp,  Node: actionIsProper,  Next: reduction,  Prev: derivate,  Up: ainvar_lib

D.6.2.3 actionIsProper
......................

Procedure from library `ainvar.lib' (*note ainvar_lib::).

*Usage:*
     actionIsProper(m); m matrix

*Assume:*
     m is a nx1 matrix, where n = number of variables of the basering

*Return:*
     int = 1, if the action defined by m is proper, 0 if not

*Note:*
     m defines a group action which is the exponential of the vector
     field m[1,1]*d/dx(1) +...+ m[1,n]*d/dx(n)

*Example:*
     LIB "ainvar.lib";
     ring rf=0,x(1..7),dp;
     matrix m[7][1];
     m[4,1]=x(1)^3;
     m[5,1]=x(2)^3;
     m[6,1]=x(3)^3;
     m[7,1]=(x(1)*x(2)*x(3))^2;
     actionIsProper(m);
     ==> 0
     ring rd=0,x(1..5),dp;
     matrix m[5][1];
     m[3,1]=x(1);
     m[4,1]=x(2);
     m[5,1]=1+x(1)*x(4)^2;
     actionIsProper(m);
     ==> 1


File: singular.hlp,  Node: reduction,  Next: completeReduction,  Prev: actionIsProper,  Up: ainvar_lib

D.6.2.4 reduction
.................

Procedure from library `ainvar.lib' (*note ainvar_lib::).

*Usage:*
     reduction(p,I[,q,n]); p poly, I ideal, [q monomial, n int
     (optional)]

*Return:*
     a polynomial equal to p-H(f1,...,fr), in case the leading term
     LT(p) of p is of the form H(LT(f1),...,LT(fr)) for some polynomial
     H in r variables over the base field, I=f1,...,fr; if q is given, a
     maximal power a is computed such that q^a divides p-H(f1,...,fr),
     and then (p-H(f1,...,fr))/q^a is returned; return p if no H is
     found
     if n=1, a different algorithm is chosen which is sometimes faster
     (default: n=0; q and n can be given (or not) in any order)

*Note:*
     this is a kind of SAGBI reduction in the subalgebra K[f1,...,fr] of
     the basering

*Example:*
     LIB "ainvar.lib";
     ring q=0,(x,y,z,u,v,w),dp;
     poly p=x2yz-x2v;
     ideal dom =x-w,u2w+1,yz-v;
     reduction(p,dom);
     ==> 2xyzw-yzw2-2xvw+vw2
     reduction(p,dom,w);
     ==> 2xyz-yzw-2xv+vw


File: singular.hlp,  Node: completeReduction,  Next: localInvar,  Prev: reduction,  Up: ainvar_lib

D.6.2.5 completeReduction
.........................

Procedure from library `ainvar.lib' (*note ainvar_lib::).

*Usage:*
     completeReduction(p,I[,q,n]); p poly, I ideal, [q monomial, n int]

*Return:*
     a polynomial, the SAGBI reduction of the polynomial p with I via
     the procedure 'reduction' as long as possible
     if n=1, a different algorithm is chosen which is sometimes faster
     (default: n=0; q and n can be given (or not) in any order)

*Note:*
     help reduction; shows an explanation of SAGBI reduction

*Example:*
     LIB "ainvar.lib";
     ring q=0,(x,y,z,u,v,w),dp;
     poly p=x2yz-x2v;
     ideal dom =x-w,u2w+1,yz-v;
     completeReduction(p,dom);
     ==> 2xyzw-yzw2-2xvw+vw2
     completeReduction(p,dom,w);
     ==> 0


File: singular.hlp,  Node: localInvar,  Next: furtherInvar,  Prev: completeReduction,  Up: ainvar_lib

D.6.2.6 localInvar
..................

Procedure from library `ainvar.lib' (*note ainvar_lib::).

*Usage:*
     localInvar(m,p,q,h); m matrix, p,q,h polynomials

*Assume:*
     m(q) and h are invariant under the vector field m, i.e.
     m(m(q))=m(h)=0 h must be a ring variable

*Return:*
     a polynomial, the invariant polynomial of the vector field

              m = m[1,1]*d/dx(1) +...+ m[n,1]*d/dx(n)

     with respect to p,q,h. It is defined as follows: set inv = p if p
     is invariant, and else as
     inv = m(q)^N * sum_i=1..N-1{ (-1)^i*(1/i!)*m^i(p)*(q/m(q))^i }
     where m^N(p) = 0, m^(N-1)(p) != 0;
     the result is inv divided by h as much as possible

*Example:*
     LIB "ainvar.lib";
     ring q=0,(x,y,z),dp;
     matrix m[3][1];
     m[2,1]=x;
     m[3,1]=y;
     poly in=localInvar(m,z,y,x);
     in;
     ==> -1/2y2+xz


File: singular.hlp,  Node: furtherInvar,  Next: sortier,  Prev: localInvar,  Up: ainvar_lib

D.6.2.7 furtherInvar
....................

Procedure from library `ainvar.lib' (*note ainvar_lib::).

*Usage:*
     furtherInvar(m,id,karl,q); m matrix, id,karl ideals, q poly, n int

*Assume:*
     karl,id,q are invariant under the vector field m,
     moreover, q must be a variable

*Return:*
     list of two ideals, the first ideal contains further invariants of
     the vector field

              m = sum m[i,1]*d/dx(i) with respect to id,p,q,

     i.e. we compute elements in the (invariant) subring generated by id
     which are divisible by q and divide them by q as much as possible
     the second ideal contains all invariants given before if n=1, a
     different algorithm is chosen which is sometimes faster (default:
     n=0)

*Example:*
     LIB "ainvar.lib";
     ring r=0,(x,y,z,u),dp;
     matrix m[4][1];
     m[2,1]=x;
     m[3,1]=y;
     m[4,1]=z;
     ideal id=localInvar(m,z,y,x),localInvar(m,u,y,x);
     ideal karl=id,x;
     list in=furtherInvar(m,id,karl,x);
     in;
     ==> [1]:
     ==>    _[1]=y2z2-8/3xz3-2y3u+6xyzu-3x2u2
     ==> [2]:
     ==>    _[1]=-1/2y2+xz
     ==>    _[2]=1/3y3-xyz+x2u
     ==>    _[3]=x


File: singular.hlp,  Node: sortier,  Prev: furtherInvar,  Up: ainvar_lib

D.6.2.8 sortier
...............

Procedure from library `ainvar.lib' (*note ainvar_lib::).

*Usage:*
     sortier(id); id ideal/module

*Return:*
     the same ideal/module but with generators ordered by there leading
     term, starting with the smallest

*Example:*
     LIB "ainvar.lib";
     ring q=0,(x,y,z,u,v,w),dp;
     ideal i=w,x,z,y,v;
     sortier(i);
     ==> _[1]=w
     ==> _[2]=v
     ==> _[3]=z
     ==> _[4]=y
     ==> _[5]=x


File: singular.hlp,  Node: rinvar_lib,  Next: stratify_lib,  Prev: ainvar_lib,  Up: Invariant theory

D.6.3 rinvar_lib
----------------

*Library:*
     rinvar.lib

*Purpose:*
     Invariant Rings of Reductive Groups

*Author:*
     Thomas Bayer, tbayer@in.tum.de
     http://wwwmayr.informatik.tu-muenchen.de/personen/bayert/ Current
     Adress: Institut fuer Informatik, TU Muenchen

*Overview:*
     Implementation based on Derksen's algorithm. Written in the frame
     of the diploma thesis (advisor: Prof. Gert-Martin Greuel)
     'Computations of moduli spaces of semiquasihomogeneous
     singularities and an implementation in Singular'

*Procedures:*

* Menu:

* HilbertSeries:: Hilbert series of the ideal I w.r.t. weight w
* HilbertWeights:: weighted degrees of the generators of I
* ImageVariety:: ideal of the image variety F(variety(I))
* ImageGroup:: ideal of G w.r.t. the induced representation
* InvariantRing:: generators of the invariant ring of G
* InvariantQ:: decide if f is invariant w.r.t. G
* LinearizeAction:: linearization of the action 'Gaction' of G
* LinearActionQ:: decide if action is linear in var(s..nvars)
* LinearCombinationQ:: decide if f is in the linear hull of 'base'
* MinimalDecomposition:: minimal decomposition of f (like coef)
* NullCone:: ideal of the null cone of the action 'act' of G
* ReynoldsImage:: image of f under the Reynolds operator 'RO'
* ReynoldsOperator:: Reynolds operator of the group G
* SimplifyIdeal:: simplify the ideal I (try to reduce variables)
* TransferIdeal:: transfer the ideal 'name' from R to basering

* Menu:

See also:
* qhmoduli_lib::
* zeroset_lib::

*See also:* *note qhmoduli_lib::; *note zeroset_lib::.


File: singular.hlp,  Node: HilbertSeries,  Next: HilbertWeights,  Up: rinvar_lib

D.6.3.1 HilbertSeries
.....................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     HilbertSeries(I, w); ideal I, intvec wt

*Purpose:*
     compute the polynomial p of the Hilbert Series,represented by p/q,
     of the ring K[t_1,...,t_m,y_1,...,y_r]/I1 where 'w' are the weights
     of the variables, computed, e.g., by 'HilbertWeights', 'I1' is of
     the form I[1] - y_1,...,I[r] - y_r and is quasihomogeneous w.r.t.
     'w'

*Return:*
     intvec

*Note:*
     the leading 0 of the result does not belong to p, but is needed in
     the hilbert-driven 'std'.


File: singular.hlp,  Node: HilbertWeights,  Next: ImageVariety,  Prev: HilbertSeries,  Up: rinvar_lib

D.6.3.2 HilbertWeights
......................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Purpose:*
     compute the weights of the "slack" variables needed for the
     computation of the algebraic relations of the generators of 'I'
     s.t.  the Hilbert driven 'std' can be used.

*Return:*
     intvec

*Assume:*
     basering = K[t_1,...,t_m,...], 'I' is quasihomogeneous w.r.t. 'w'
     and contains only polynomials in t_1,...,t_m


File: singular.hlp,  Node: ImageVariety,  Next: ImageGroup,  Prev: HilbertWeights,  Up: rinvar_lib

D.6.3.3 ImageVariety
....................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     ImageVariety(ideal I, F [, w]);ideal I; F is a list/ideal, intvec
     w.

*Purpose:*
     compute the Zariski closure of the image of the variety of I under
     the morphism F.

*Note:*
     if 'I' and 'F' are quasihomogeneous w.r.t. 'w' then the
     Hilbert-driven 'std' is used.

*Return:*
     polynomial ring over the same ground field, containing the ideal
     'imageid'. The variables are Y(1),...,Y(k) where k = size(F) -
     'imageid' is the ideal of the Zariski closure of F(X) where X is
     the variety of I.

*Example:*
     LIB "rinvar.lib";
     ring B   = 0,(x,y),dp;
     ideal I  = x4 - y4;
     ideal F  = x2, y2, x*y;
     def R = ImageVariety(I, F);
     setring R;
     imageid;
     ==> imageid[1]=Y(1)*Y(2)-Y(3)^2
     ==> imageid[2]=Y(1)^2-Y(2)^2
     ==> imageid[3]=Y(2)^3-Y(1)*Y(3)^2


File: singular.hlp,  Node: ImageGroup,  Next: InvariantRing,  Prev: ImageVariety,  Up: rinvar_lib

D.6.3.4 ImageGroup
..................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     ImageGroup(G, action); ideal G, action;

*Purpose:*
     compute the ideal of the image of G in GL(m,K) induced by the
     linear action 'action', where G is an algebraic group and 'action'
     defines an action of G on K^m (size(action) = m).

*Return:*
     ring, a polynomial ring over the same ground field as the basering,
     containing the ideals 'groupid' and 'actionid'.
     - 'groupid' is the ideal of the image of G (order <= order of G) -
     'actionid' defines the linear action of 'groupid' on K^m.

*Note:*
     'action' and 'actionid' have the same orbits
     all variables which give only rise to 0's in the m x m matrices of
     G have been omitted.

*Assume:*
     basering K[s(1..r),t(1..m)] has r + m variables, G is the ideal of
     an algebraic group and F is an action of G on K^m. G contains only
     the variables s(1)...s(r). The action 'action' is given by
     polynomials f_1,...,f_m in basering, s.t. on the ring level we have
     K[t_1,...,t_m] -> K[s_1,...,s_r,t_1,...,t_m]/G
     t_i -> f_i(s_1,...,s_r,t_1,...,t_m)

*Example:*
     LIB "rinvar.lib";
     ring B   = 0,(s(1..2), t(1..2)),dp;
     ideal G = s(1)^3-1, s(2)^10-1;
     ideal action = s(1)*s(2)^8*t(1), s(1)*s(2)^7*t(2);
     def R = ImageGroup(G, action);
     setring R;
     groupid;
     ==> groupid[1]=-s(1)+s(2)^4
     ==> groupid[2]=s(1)^8-s(2)^2
     ==> groupid[3]=s(1)^7*s(2)^2-1
     actionid;
     ==> actionid[1]=s(1)*t(1)
     ==> actionid[2]=s(2)*t(2)


File: singular.hlp,  Node: InvariantRing,  Next: InvariantQ,  Prev: ImageGroup,  Up: rinvar_lib

D.6.3.5 InvariantRing
.....................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     InvariantRing(G, Gact [, opt]); ideal G, Gact; int opt

*Purpose:*
     compute generators of the invariant ring of G w.r.t. the action
     'Gact'

*Assume:*
     G is a finite group and 'Gact' is a linear action.

*Return:*
     polynomial ring over a simple extension of the ground field of the
     basering (the extension might be trivial), containing the ideals
     'invars' and 'groupid' and the poly 'newA'
     - 'invars' contains the algebra-generators of the invariant ring -
     'groupid' is the ideal of G in the new ring
     - 'newA' if the minpoly changes this is the new representation of
     the algebraic number, otherwise it is set to 'a'.

*Note:*
     the delivered ring might have a different minimal polynomial

*Example:*
     LIB "rinvar.lib";
     ring B = 0, (s(1..2), t(1..2)), dp;
     ideal G = -s(1)+s(2)^3, s(1)^4-1;
     ideal action = s(1)*t(1), s(2)*t(2);
     def R = InvariantRing(std(G), action);
     setring R;
     invars;
     ==> invars[1]=t(1)^4
     ==> invars[2]=t(1)^3*t(2)^3
     ==> invars[3]=t(1)^2*t(2)^6
     ==> invars[4]=t(1)*t(2)^9
     ==> invars[5]=t(2)^12


File: singular.hlp,  Node: InvariantQ,  Next: LinearizeAction,  Prev: InvariantRing,  Up: rinvar_lib

D.6.3.6 InvariantQ
..................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     InvariantQ(f, G, action); poly f; ideal G, action

*Purpose:*
     check if the polynomial f is invariant w.r.t. G where G acts via
     'action' on K^m.

*Assume:*
     basering = K[s_1,...,s_m,t_1,...,t_m] where K = Q of K = Q(a) and
     minpoly != 0, f contains only t_1,...,t_m, G is the ideal of an
     algebraic group and a standard basis.

*Return:*
     int;
     0 if f is not invariant,
     1 if f is invariant

*Note:*
     G need not be finite


File: singular.hlp,  Node: LinearizeAction,  Next: LinearActionQ,  Prev: InvariantQ,  Up: rinvar_lib

D.6.3.7 LinearizeAction
.......................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     LinearizeAction(G,action,r); ideal G, action; int r

*Purpose:*
     linearize the group action 'action' and find an equivariant
     embedding of K^m where m = size(action).

*Assume:*
     G contains only variables var(1..r) (r = nrs)
     basering = K[s(1..r),t(1..m)], K = Q or K = Q(a) and minpoly != 0.

*Return:*
     polynomial ring containing the ideals 'actionid', 'embedid',
     'groupid' - 'actionid' is the ideal defining the linearized action
     of G - 'embedid' is a parameterization of an equivariant embedding
     (closed) - 'groupid' is the ideal of G in the new ring

*Note:*
     set printlevel > 0 to see a trace

*Example:*
     LIB "rinvar.lib";
     ring B   = 0,(s(1..5), t(1..3)),dp;
     ideal G =  s(3)-s(4), s(2)-s(5), s(4)*s(5), s(1)^2*s(4)+s(1)^2*s(5)-1, s(1)^2*s(5)^2-s(5), s(4)^4-s(5)^4+s(1)^2, s(1)^4+s(4)^3-s(5)^3, s(5)^5-s(1)^2*s(5);
     ideal action = -s(4)*t(1)+s(5)*t(1), -s(4)^2*t(2)+2*s(4)^2*t(3)^2+s(5)^2*t(2), s(4)*t(3)+s(5)*t(3);
     LinearActionQ(action, 5);
     ==> 0
     def R = LinearizeAction(G, action, 5);
     setring R;
     R;
     ==> //   characteristic : 0
     ==> //   number of vars : 9
     ==> //        block   1 : ordering dp
     ==> //                  : names    s(1) s(2) s(3) s(4) s(5) t(1) t(2) t(3) t(\
        4) 
     ==> //        block   2 : ordering C
     actionid;
     ==> actionid[1]=-s(4)*t(1)+s(5)*t(1)
     ==> actionid[2]=-s(4)^2*t(2)+s(5)^2*t(2)+2*s(4)^2*t(4)
     ==> actionid[3]=s(4)*t(3)+s(5)*t(3)
     ==> actionid[4]=s(4)^2*t(4)+s(5)^2*t(4)
     embedid;
     ==> embedid[1]=t(1)
     ==> embedid[2]=t(2)
     ==> embedid[3]=t(3)
     ==> embedid[4]=t(3)^2
     groupid;
     ==> groupid[1]=s(3)-s(4)
     ==> groupid[2]=s(2)-s(5)
     ==> groupid[3]=s(4)*s(5)
     ==> groupid[4]=s(1)^2*s(4)+s(1)^2*s(5)-1
     ==> groupid[5]=s(1)^2*s(5)^2-s(5)
     ==> groupid[6]=s(4)^4-s(5)^4+s(1)^2
     ==> groupid[7]=s(1)^4+s(4)^3-s(5)^3
     ==> groupid[8]=s(5)^5-s(1)^2*s(5)
     LinearActionQ(actionid, 5);
     ==> 1


File: singular.hlp,  Node: LinearActionQ,  Next: LinearCombinationQ,  Prev: LinearizeAction,  Up: rinvar_lib

D.6.3.8 LinearActionQ
.....................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     LinearActionQ(action,nrs,nrt); ideal action, int nrs

*Purpose:*
     check if the action defined by 'action' is linear w.r.t. the
     variables var(nrs + 1...nvars(basering)).

*Return:*
     0 action not linear
     1 action is linear

*Example:*
     LIB "rinvar.lib";
     ring R   = 0,(s(1..5), t(1..3)),dp;
     ideal G =  s(3)-s(4), s(2)-s(5), s(4)*s(5), s(1)^2*s(4)+s(1)^2*s(5)-1, s(1)^2*s(5)^2-s(5), s(4)^4-s(5)^4+s(1)^2, s(1)^4+s(4)^3-s(5)^3, s(5)^5-s(1)^2*s(5);
     ideal Gaction = -s(4)*t(1)+s(5)*t(1), -s(4)^2*t(2)+2*s(4)^2*t(3)^2+s(5)^2*t(2), s(4)*t(3)+s(5)*t(3);
     LinearActionQ(Gaction, 5, 3);
     ==> // ** too many arguments for LinearActionQ
     ==> 0


File: singular.hlp,  Node: LinearCombinationQ,  Next: MinimalDecomposition,  Prev: LinearActionQ,  Up: rinvar_lib

D.6.3.9 LinearCombinationQ
..........................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     LinearCombination(I, f); ideal I, poly f

*Purpose:*
     test if f can be written as a linear combination of the generators
     of I.

*Return:*
     0 f is not a linear combination
     1 f is a linear combination


File: singular.hlp,  Node: MinimalDecomposition,  Next: NullCone,  Prev: LinearCombinationQ,  Up: rinvar_lib

D.6.3.10 MinimalDecomposition
.............................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     MinimalDecomposition(f,a,b); poly f; int a, b.

*Purpose:*
     decompose f as a sum M[1,1]*M[2,1] + ... + M[1,r]*M[2,r] where
     M[1,i] contains only s(1..a), M[2,i] contains only t(1...b) s.t. r
     is minimal

*Assume:*
     f polynomial in K[s(1..a),t(1..b)], K = Q or K = Q(a) and minpoly
     != 0

*Return:*
     2 x r matrix M s.t. f = M[1,1]*M[2,1] + ... + M[1,r]*M[2,r]

*Example:*
     LIB "rinvar.lib";
     ring R = 0, (s(1..2), t(1..2)), dp;
     poly h = s(1)*(t(1) + t(1)^2) +  (t(2) + t(2)^2)*(s(1)^2 + s(2));
     matrix M = MinimalDecomposition(h, 2, 2);
     M;
     ==> M[1,1]=s(1)^2+s(2)
     ==> M[1,2]=s(1)
     ==> M[2,1]=t(2)^2+t(2)
     ==> M[2,2]=t(1)^2+t(1)
     M[1,1]*M[2,1] + M[1,2]*M[2,2] - h;
     ==> 0


File: singular.hlp,  Node: NullCone,  Next: ReynoldsImage,  Prev: MinimalDecomposition,  Up: rinvar_lib

D.6.3.11 NullCone
.................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     NullCone(G, action); ideal G, action

*Purpose:*
     compute the ideal of the null cone of the linear action of G on
     K^n, given by 'action', by means of Derksen's algorithm

*Assume:*
     basering = K[s(1..r),t(1..n)], K = Q or K = Q(a) and minpoly != 0,
     G is an ideal of a reductive algebraic group in K[s(1..r)],
     'action' is a linear group action of G on K^n (n = ncols(action))

*Return:*
     ideal of the null cone of G.

*Note:*
     the generators of the null cone are homogeneous, but i.g. not
     invariant

*Example:*
     LIB "rinvar.lib";
     ring R = 0, (s(1..2), x, y), dp;
     ideal G = -s(1)+s(2)^3, s(1)^4-1;
     ideal action = s(1)*x, s(2)*y;
     ideal inv = NullCone(G, action);
     inv;
     ==> inv[1]=x^4
     ==> inv[2]=x^3*y^3
     ==> inv[3]=x^2*y^6
     ==> inv[4]=x*y^9
     ==> inv[5]=y^12


File: singular.hlp,  Node: ReynoldsImage,  Next: ReynoldsOperator,  Prev: NullCone,  Up: rinvar_lib

D.6.3.12 ReynoldsImage
......................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     ReynoldsImage(RO, f); list RO, poly f

*Purpose:*
     compute the Reynolds image of the polynomial f where RO represents
     the Reynolds operator

*Return:*
     poly


File: singular.hlp,  Node: ReynoldsOperator,  Next: SimplifyIdeal,  Prev: ReynoldsImage,  Up: rinvar_lib

D.6.3.13 ReynoldsOperator
.........................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Usage:*
     ReynoldsOperator(G, action [, opt); ideal G, action; int opt

*Purpose:*
     compute the Reynolds operator of the group G which act via 'action'

*Return:*
     polynomial ring R over a simple extension of the ground field of
     the basering (the extension might be trivial), containing a list
     'ROelements', the ideals 'id', 'actionid' and the polynomial
     'newA'.  R = K(a)[s(1..r),t(1..n)].
     - 'ROelements' is a list of ideal, each ideal represents a
     substitution map F : R -> R according to the zero-set of G - 'id'
     is the ideal of G in the new ring
     - 'newA' is the new representation of a' in terms of a. If the
     basering does not contain a parameter then 'newA' = 'a'.

*Assume:*
     basering = K[s(1..r),t(1..n)], K = Q or K = Q(a') and minpoly != 0,
     G is the ideal of a finite group in K[s(1..r)], 'action' is a
     linear group action of G


File: singular.hlp,  Node: SimplifyIdeal,  Next: TransferIdeal,  Prev: ReynoldsOperator,  Up: rinvar_lib

D.6.3.14 SimplifyIdeal
......................

Procedure from library `rinvar.lib' (*note rinvar_lib::).

*Purpose:*
     simplify ideal I to the ideal I', do not change the names of the
     first m variables, new ideal I' might contain less variables.  I'
     contains variables var(1..m)

*Return:*
     list
     _[1] ideal I'
     _[2] ideal representing a map phi to a ring with probably less
     vars. s.t.  phi(I) = I'
     _[3] list of variables
     _[4] list from 'elimpart'


File: singular.hlp,  Node: TransferIdeal,  Prev: SimplifyIdeal,  Up: rinvar_lib

D.6.3.15 TransferIdeal
......................

Procedure from library `rinvar.lib' (*note rinvar_lib::).


File: singular.hlp,  Node: stratify_lib,  Prev: rinvar_lib,  Up: Invariant theory

D.6.4 stratify_lib
------------------

*Library:*
     stratify.lib

*Purpose:*
     Algorithmic Stratification for Unipotent Group-Actions

*Author:*
     Anne Fruehbis-Krueger, anne@mathematik.uni-kl.de

*Overview:*
     This library provides an implementation of the algorithm of Greuel
     and Pfister introduced in the article <Geometric quotients of
     unipotent group actions>.

*Procedures:*

* Menu:

* prepMat:: list of submatrices corresp. to given filtration
* stratify:: algorithmic stratification (main procedure)


File: singular.hlp,  Node: prepMat,  Next: stratify,  Up: stratify_lib

D.6.4.1 prepMat
...............

Procedure from library `stratify.lib' (*note stratify_lib::).

*Usage:*
     prepMat(M,wr,ws,step);
     where M is a matrix, wr is an intvec of size ncols(M), ws an intvec
     of size nrows(M) and step is an integer

*Return:*
     2 lists of submatrices corresponding to the filtrations specified
     by wr and ws
     the first list corresponds to the list for the filtration of AdA,
     i.e. the ranks of these matrices will be the r_i, the second one to
     the list for the filtration of L, i.e.  the ranks of these matrices
     will be the s_i

*Note:*
     * the entries of the matrix M are M_ij=delta_i(x_j),
     * wr is used to determine what subset of the set of all dx_i is
     generating AdF^l(A):
     if (k-1)*step <= wr[i] < k*step, then dx_i is in the set of
     generators of AdF^l(A) for all l>=k and the i-th column of M
     appears in each submatrix starting from the k-th
     * ws is used to determine what subset of the set of all delta_i is
     generating Z_l(L):
     if (k-1)*step <= ws[i] < k*step, then delta_i is in the set of
     generators of Z_l(A) for l < k and the i-th row of M appears in
     each submatrix up to the (k-1)th
     * the entries of wr and ws as well as step should be positive
     integers

*Example:*
     LIB "stratify.lib";
     ring r=0,(t(1..3)),dp;
     matrix M[2][3]=0,t(1),3*t(2),0,0,t(1);
     print(M);
     ==> 0,t(1),3*t(2),
     ==> 0,0,   t(1)   
     intvec wr=1,3,5;
     intvec ws=2,4;
     int step=2;
     prepMat(M,wr,ws,step);
     ==> [1]:
     ==>    [1]:
     ==>       _[1,1]=0
     ==>       _[2,1]=0
     ==>    [2]:
     ==>       _[1,1]=0
     ==>       _[1,2]=t(1)
     ==>       _[2,1]=0
     ==>       _[2,2]=0
     ==>    [3]:
     ==>       _[1,1]=0
     ==>       _[1,2]=t(1)
     ==>       _[1,3]=3*t(2)
     ==>       _[2,1]=0
     ==>       _[2,2]=0
     ==>       _[2,3]=t(1)
     ==> [2]:
     ==>    [1]:
     ==>       _[1,1]=0
     ==>       _[1,2]=t(1)
     ==>       _[1,3]=3*t(2)
     ==>       _[2,1]=0
     ==>       _[2,2]=0
     ==>       _[2,3]=t(1)
     ==>    [2]:
     ==>       _[1,1]=0
     ==>       _[1,2]=0
     ==>       _[1,3]=t(1)


File: singular.hlp,  Node: stratify,  Prev: prepMat,  Up: stratify_lib

D.6.4.2 stratify
................

Procedure from library `stratify.lib' (*note stratify_lib::).

*Usage:*
     stratify(M,wr,ws,step);
     where M is a matrix, wr is an intvec of size ncols(M), ws an intvec
     of size nrows(M) and step is an integer

*Return:*
     list of lists, each entry of the big list corresponds to one
     locally closed set and has the following entries:
     1) intvec giving the corresponding rs-vector
     2) ideal determining the closed set
     3) list d of polynomials determining the open set D(d[1]) empty
     list if there is more than one open set
     4-n) lists of polynomials determining open sets which all lead to
     the same rs-vector

*Note:*
     * ring ordering should be global, i.e. the ring should be a
     polynomial ring
     * the entries of the matrix M are M_ij=delta_i(x_j),
     * wr is used to determine what subset of the set of all dx_i is
     generating AdF^l(A):
     if (k-1)*step < wr[i] <= k*step, then dx_i is in the set of
     generators of AdF^l(A) for all l>=k
     * ws is used to determine what subset of the set of all delta_i is
     generating Z_l(L):
     if (k-1)*step <= ws[i] < k*step, then delta_i is in the set of
     generators of Z_l(A) for l < k
     * the entries of wr and ws as well as step should be positive
     integers
     * the filtrations have to be known, no sanity checks concerning the
     filtrations are performed !!!

*Example:*
     LIB "stratify.lib";
     ring r=0,(t(1..3)),dp;
     matrix M[2][3]=0,t(1),3*t(2),0,0,t(1);
     intvec wr=1,3,5;
     intvec ws=2,4;
     int step=2;
     stratify(M,wr,ws,step);
     ==> [1]:
     ==>    [1]:
     ==>       0,0,0,0
     ==>    [2]:
     ==>       _[1]=t(2)
     ==>       _[2]=t(1)
     ==>    [3]:
     ==>       [1]:
     ==>          1
     ==> [2]:
     ==>    [1]:
     ==>       0,1,0,1
     ==>    [2]:
     ==>       _[1]=t(1)
     ==>    [3]:
     ==>       [1]:
     ==>          t(2)
     ==>       [2]:
     ==>          t(2)
     ==> [3]:
     ==>    [1]:
     ==>       1,2,1,2
     ==>    [2]:
     ==>       _[1]=0
     ==>    [3]:
     ==>       [1]:
     ==>          t(1)
     ==>       [2]:
     ==>          t(1)


File: singular.hlp,  Node: Symbolic-numerical solving,  Next: Visualization,  Prev: Invariant theory,  Up: SINGULAR libraries

D.7 Symbolic-numerical solving
==============================

* Menu:

* presolve_lib:: procedures for pre-solving polynomial equations
* solve_lib:: procedures to solve polynomial systems
* triang_lib:: procedures for decomposing zero-dimensional ideals
* ntsolve_lib:: one real solution of polynomial systems (Newton iteration)
* zeroset_lib:: procedures for roots and factorization


File: singular.hlp,  Node: presolve_lib,  Next: solve_lib,  Prev: Symbolic-numerical solving,  Up: Symbolic-numerical solving

D.7.1 presolve_lib
------------------

*Library:*
     presolve.lib

*Purpose:*
     Pre-Solving of Polynomial Equations

*Author:*
     Gert-Martin Greuel, email: greuel@mathematik.uni-kl.de,

*Procedures:*

* Menu:

* degreepart:: elements of id of total degree >= d1 and <= d2
* elimlinearpart:: linear part eliminated from id
* elimpart:: partial elimination of vars [among first n vars]
* elimpartanyr:: factors of p partially eliminated from i in any ring
* fastelim:: fast elimination of factors of p from i [options]
* findvars:: ideal of variables occurring in id [more information]
* hilbvec:: intvec of Hilbert-series of id [in char c and ord o]
* linearpart:: elements of id of total degree <=1
* tolessvars:: maps id to new basering having only vars occurring in id
* solvelinearpart:: reduced std-basis of linear part of id
* sortandmap:: map to new basering with vars sorted w.r.t. complexity
* sortvars:: sort vars w.r.t. complexity in id [different blocks]
* shortid:: generators of id having <= n terms
* valvars:: valuation of vars w.r.t. to their complexity in id
* idealSimplify:: eliminates variables which are linear in id
* idealSplit:: intersection of the ideals has the same radical as id


File: singular.hlp,  Node: degreepart,  Next: elimlinearpart,  Up: presolve_lib

D.7.1.1 degreepart
..................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     degreepart(id,d1,d2[,v]); id=ideal/module, d1,d1=integers, v=intvec

*Return:*
     generators of id of [v-weighted] total degree >= d1 and <= d2
     (default: v = 1,...,1)

*Example:*
     LIB "presolve.lib";
     ring r=0,(x,y,z),dp;
     ideal i=1+x+x2+x3+x4,3,xz+y3+z8;
     degreepart(i,0,4);
     ==> _[1]=x4+x3+x2+x+1
     ==> _[2]=3
     module m=[x,y,z],x*[x3,y2,z],[1,x2,z3,0,1];
     intvec v=2,3,6;
     show(degreepart(m,8,8,v));
     ==> // module, 1 generator(s)
     ==> [x4,xy2,xz]


File: singular.hlp,  Node: elimlinearpart,  Next: elimpart,  Prev: degreepart,  Up: presolve_lib

D.7.1.2 elimlinearpart
......................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     elimlinearpart(i[,n]); i=ideal, n=integer,
     default: n=nvars(basering)

*Return:*
     list L with 5 entries:

       L[1]: (interreduced) ideal obtained from i by substituing
             from the first n variables those, which appear in a linear part
             of i, by putting this part into triangular form
       L[2]: ideal of variables which have been substituted
       L[3]: ideal, j-th element defines substitution of j-th var in [2]
       L[4]: ideal of variables of basering, eliminated ones are set to 0
       L[5]: ideal, describing the map from the basering to itself such that
             L[1] is the image of i
       
*Note:*
     the procedure does always interreduce the ideal i internally w.r.t.
     ordering dp.

*Example:*
     LIB "presolve.lib";
     ring s=0,(x,y,z),dp;
     ideal i = x3+y2+z,x2y2+z3,y+z+1;
     elimlinearpart(i);
     ==> [1]:
     ==>    _[1]=x3+z2+3z+1
     ==>    _[2]=x2z2+2x2z+z3+x2
     ==> [2]:
     ==>    _[1]=y
     ==> [3]:
     ==>    _[1]=y+z+1
     ==> [4]:
     ==>    _[1]=x
     ==>    _[2]=0
     ==>    _[3]=z
     ==> [5]:
     ==>    _[1]=x
     ==>    _[2]=-z-1
     ==>    _[3]=z


File: singular.hlp,  Node: elimpart,  Next: elimpartanyr,  Prev: elimlinearpart,  Up: presolve_lib

D.7.1.3 elimpart
................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     elimpart(i [,n,e] ); i=ideal, n,e=integers
     n : only the first n vars are considered for substitution,
     e =0: substitute from linear part of i (same as elimlinearpart)
     e!=0: eliminate also by direct substitution
     (default: n = nvars(basering), e = 1)

*Return:*
     list of 5 objects:

       [1]: ideal obtained by substituting from the first n variables those
            from i, which appear in the linear part of i (or, if e!=0, which
            can be expressed directly in the remaining vars)
       [2]: ideal, variables which have been substituted
       [3]: ideal, i-th element defines substitution of i-th var in [2]
       [4]: ideal of variables of basering, substituted ones are set to 0
       [5]: ideal, describing the map from the basering, say k[x(1..m)], to
            itself onto k[..variables fom [4]..] and [1] is the image of i
       
     The ideal i is generated by [1] and [3] in k[x(1..m)], the map [5]
     maps [3] to 0, hence induces an isomorphism

                 k[x(1..m)]/i -> k[..variables fom [4]..]/[1]
       
*Note:*
     If the basering has ordering (c,dp), this is faster for big ideals,
     since it avoids internal ring change and mapping.

*Example:*
     LIB "presolve.lib";
     ring s=0,(x,y,z),dp;
     ideal i =x2+y2,x2+y+1;
     elimpart(i,3,0);
     ==> [1]:
     ==>    _[1]=y2-y-1
     ==>    _[2]=x2+y+1
     ==> [2]:
     ==>    _[1]=0
     ==> [3]:
     ==>    _[1]=0
     ==> [4]:
     ==>    _[1]=x
     ==>    _[2]=y
     ==>    _[3]=z
     ==> [5]:
     ==>    _[1]=x
     ==>    _[2]=y
     ==>    _[3]=z
     elimpart(i,3,1);
     ==> [1]:
     ==>    _[1]=x4+3x2+1
     ==> [2]:
     ==>    _[1]=y
     ==> [3]:
     ==>    _[1]=x2+y+1
     ==> [4]:
     ==>    _[1]=x
     ==>    _[2]=0
     ==>    _[3]=z
     ==> [5]:
     ==>    _[1]=x
     ==>    _[2]=-x2-1
     ==>    _[3]=z


File: singular.hlp,  Node: elimpartanyr,  Next: fastelim,  Prev: elimpart,  Up: presolve_lib

D.7.1.4 elimpartanyr
....................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     elimpartanyr(i [,p,e] ); i=ideal, p=polynomial, e=integer
     p: product of vars to be eliminated,
     e =0: substitute from linear part of i (same as elimlinearpart)
     e!=0: eliminate also by direct substitution
     (default: p=product of all vars, e=1)

*Return:*
     list of 6 objects:

       [1]: (interreduced) ideal obtained by substituting from i those vars
            appearing in p, which occur in the linear part of i (or which can
            be expressed directly in the remaining variables, if e!=0)
       [2]: ideal, variables which have been substituted
       [3]: ideal, i-th element defines substitution of i-th var in [2]
       [4]: ideal of variables of basering, substituted ones are set to 0
       [5]: ideal, describing the map from the basering, say k[x(1..m)], to
            itself onto k[..variables fom [4]..] and [1] is the image of i
       [6]: int, # of vars considered for substitution (= # of factors of p)
       
     The ideal i is generated by [1] and [3] in k[x(1..m)], the map [5]
     maps [3] to 0, hence induces an isomorphism

                 k[x(1..m)]/i -> k[..variables fom [4]..]/[1]
       
*Note:*
     the proc uses `execute' to create a ring with ordering dp and vars
     placed correctly and then applies `elimpart'.

*Example:*
     LIB "presolve.lib";
     ring s=0,(x,y,z),dp;
     ideal i = x3+y2+z,x2y2+z3,y+z+1;
     elimpartanyr(i,z);
     ==> [1]:
     ==>    _[1]=x3+y2-y-1
     ==>    _[2]=x2y2-y3-3y2-3y-1
     ==> [2]:
     ==>    _[1]=z
     ==> [3]:
     ==>    _[1]=y+z+1
     ==> [4]:
     ==>    _[1]=0
     ==>    _[2]=x
     ==>    _[3]=y
     ==> [5]:
     ==>    _[1]=-y-1
     ==>    _[2]=x
     ==>    _[3]=y
     ==> [6]:
     ==>    1


File: singular.hlp,  Node: fastelim,  Next: findvars,  Prev: elimpartanyr,  Up: presolve_lib

D.7.1.5 fastelim
................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     fastelim(i,p[h,o,a,b,e,m]); i=ideal, p=polynomial;
     h,o,a,b,e=integers p: product of variables to be eliminated;
     Optional parameters:

       - h !=0: use Hilbert-series driven std-basis computation
       - o !=0: use proc `valvars' for a - hopefully - optimal ordering of vars
       - a !=0: order vars to be eliminated w.r.t. increasing complexity
       - b !=0: order vars not to be eliminated w.r.t. increasing complexity
       - e !=0: use `elimpart' first to eliminate easy part
       - m !=0: compute a minimal system of generators
       
     (default: h,o,a,b,e,m = 0,1,0,0,0,0)

*Return:*
     ideal obtained from i by eliminating those variables, which occur
     in p

*Example:*
     LIB "presolve.lib";
     ring s=31991,(e,f,x,y,z,t,u,v,w,a,b,c,d),dp;
     ideal i = w2+f2-1, x2+t2+a2-1,  y2+u2+b2-1, z2+v2+c2-1,
     d2+e2-1, f4+2u, wa+tf, xy+tu+ab;
     fastelim(i,xytua,1,1);       //with hilb,valvars
     ==> _[1]=f2+w2-1
     ==> _[2]=z2+v2+c2-1
     ==> _[3]=e2+d2-1
     fastelim(i,xytua,1,0,1);     //with hilb,minbase
     ==> _[1]=z2+v2+c2-1
     ==> _[2]=f2+w2-1
     ==> _[3]=e2+d2-1


File: singular.hlp,  Node: findvars,  Next: hilbvec,  Prev: fastelim,  Up: presolve_lib

D.7.1.6 findvars
................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     findvars(id [,any] ); id=poly/ideal/vector/module/matrix, any=any
     type

*Return:*
     if no second argument is present: ideal of variables occurring in
id,
     if a second argument is given (of any type): list L with 4 entries:

       L[1]: ideal of variables occurring in id
       L[2]: intvec of variables occurring in id
       L[3]: ideal of variables not occurring in id
       L[4]: intvec of variables not occurring in id
       
*Example:*
     LIB "presolve.lib";
     ring s  = 0,(e,f,x,y,t,u,v,w,a,d),dp;
     ideal i = w2+f2-1, x2+t2+a2-1;
     findvars(i);
     ==> _[1]=f
     ==> _[2]=x
     ==> _[3]=t
     ==> _[4]=w
     ==> _[5]=a
     findvars(i,1);
     ==> [1]:
     ==>    _[1]=f
     ==>    _[2]=x
     ==>    _[3]=t
     ==>    _[4]=w
     ==>    _[5]=a
     ==> [2]:
     ==>    2,3,5,8,9
     ==> [3]:
     ==>    _[1]=e
     ==>    _[2]=y
     ==>    _[3]=u
     ==>    _[4]=v
     ==>    _[5]=d
     ==> [4]:
     ==>    1,4,6,7,10


File: singular.hlp,  Node: hilbvec,  Next: linearpart,  Prev: findvars,  Up: presolve_lib

D.7.1.7 hilbvec
...............

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     hilbvec(id[,c,o]); id=poly/ideal/vector/module/matrix, c,o=strings,
     c=char, o=ordering used by `hilb'
     (default: c="32003", o="dp")

*Return:*
     intvec of 1-st Hilbert-series of id, computed in char c and
     ordering o

*Note:*
     id must be homogeneous (i.e. all vars have weight 1)

*Example:*
     LIB "presolve.lib";
     ring s   = 0,(e,f,x,y,z,t,u,v,w,a,b,c,d,H),dp;
     ideal id = w2+f2-1, x2+t2+a2-1,  y2+u2+b2-1, z2+v2+c2-1,
     d2+e2-1, f4+2u, wa+tf, xy+tu+ab;
     id = homog(id,H);
     hilbvec(id);
     ==> 1,0,-7,0,20,0,-28,0,14,0,14,0,-28,0,20,0,-7,0,1,0


File: singular.hlp,  Node: linearpart,  Next: tolessvars,  Prev: hilbvec,  Up: presolve_lib

D.7.1.8 linearpart
..................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     linearpart(id); id=ideal/module

*Return:*
     generators of id of total degree <= 1

*Example:*
     LIB "presolve.lib";
     ring r=0,(x,y,z),dp;
     ideal i=1+x+x2+x3,3,x+3y+5z;
     linearpart(i);
     ==> _[1]=3
     ==> _[2]=x+3y+5z
     module m=[x,y,z],x*[x3,y2,z],[1,x2,z3,0,1];
     show(linearpart(m));
     ==> // module, 1 generator(s)
     ==> [x,y,z]


File: singular.hlp,  Node: tolessvars,  Next: solvelinearpart,  Prev: linearpart,  Up: presolve_lib

D.7.1.9 tolessvars
..................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     tolessvars(id [,s1,s2] ); id poly/ideal/vector/module/matrix,
s1,s2=strings
     s1: name of new ring,
     s2: new ordering
     (default: s1="R(n)" where n is the # of vars in the new ring,
     s2="dp" or "ds" depending whether the first block of the old
     ordering is a p- resp. an s-ordering)

*Create:*
     nothing, if id contains all vars of the basering.
     Else, create a ring with same char as the basering, but possibly
     less variables (only those variables which actually occur in id)
     and map id to the new ring, which will be the basering after the
     proc has finished.

*Display:*
     If printlevel >=0, display ideal of vars, which have been omitted
     from the old ring

*Return:*
     the original ideal id (see NOTE)

*Note:*
     You must not type, say, 'ideal id=tolessvars(id);' since the ring
     to which 'id' would belong will only be defined by the r.h.s.. But
     you may type 'def id=tolessvars(id);' or 'list id=tolessvars(id);'
     since then 'id' does not a priory belong to a ring, its type will
     be defined by the right hand side. Moreover, do not use a name
     which occurs in the old ring, for the same reason.

*Example:*
     LIB "presolve.lib";
     ring r  = 0,(x,y,z),dp;
     ideal i = y2-x3,x-3,y-2x;
     def j   = tolessvars(i,"R_r","lp");
     ==> 
     ==> // variables which did not occur:
     ==> z
     ==> // basering is now R_r
     show(basering);
     ==> // ring: (0),(x,y),(lp(2),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> // j                    [0]  ideal, 3 generator(s)
     j;
     ==> j[1]=-x3+y2
     ==> j[2]=x-3
     ==> j[3]=-2x+y
     kill R_r;


File: singular.hlp,  Node: solvelinearpart,  Next: sortandmap,  Prev: tolessvars,  Up: presolve_lib

D.7.1.10 solvelinearpart
........................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     solvelinearpart(id [,n] ); id=ideal/module, n=integer,
     (default: n=0)

*Return:*
     (interreduced) generators of id of degree <=1 in reduced triangular
     form if n=0 [non-reduced triangular form if n!=0]

*Assume:*
     monomial ordering is a global ordering (p-ordering)

*Note:*
     may be used to solve a system of linear equations see proc
     `gauss_row' from 'matrix.lib' for a different method

*Warning:*
     the result is very likely to be false for 'real' coefficients, use
     char 0 instead!

*Example:*
     LIB "presolve.lib";
     // Solve the system of linear equations:
     //         3x +   y +  z -  u = 2
     //         3x +  8y + 6z - 7u = 1
     //        14x + 10y + 6z - 7u = 0
     //         7x +  4y + 3z - 3u = 3
     ring r = 0,(x,y,z,u),lp;
     ideal i= 3x +   y +  z -  u,
     13x +  8y + 6z - 7u,
     14x + 10y + 6z - 7u,
     7x +  4y + 3z - 3u;
     ideal j= 2,1,0,3;
     j = i-j;                        // difference of 1x4 matrices
     // compute reduced triangular form, setting
     solvelinearpart(j);             // the RHS equal 0 gives the solutions!
     ==> _[1]=u-4
     ==> _[2]=z-4
     ==> _[3]=y+1
     ==> _[4]=x-1
     solvelinearpart(j,1); "";       // triangular form, not reduced
     ==> _[1]=u-4
     ==> _[2]=3z-8u+20
     ==> _[3]=18y-6z+7u+14
     ==> _[4]=13x+8y+6z-7u-1
     ==> 


File: singular.hlp,  Node: sortandmap,  Next: sortvars,  Prev: solvelinearpart,  Up: presolve_lib

D.7.1.11 sortandmap
...................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
sortandmap(id,s1,s2[,n1,p1,n2,p2...,o1,m1,o2,m2...]);
id=poly/ideal/vector/module,
     s1,s2 = strings (names for new ring and mapped id),
     p1,p2,...= polynomials (product of variables),
     n1,n2,...= integers,
     o1,o2,...= strings,
     m1,m2,...= integers
     (default: p1=product of all vars, n1=0, o1="dp",m1=0)
     the last pi (containing the remaining vars) may be omitted

*Create:*
     a new ring and map id into it, the new ring has same char as
     basering but with new ordering and vars sorted in the following
     manner:

       - each block of vars occurring in pi is sorted w.r.t. its complexity in id,
       - ni controls the sorting in i-th block (= vars occurring in pi):
         ni=0 (resp.!=0) means that less (resp. more) complex vars come first
       - oi and mi define the monomial ordering of the i-th block:
         if mi =0, oi=ordstr(i-th block)
         if mi!=0, the ordering of the i-th block itself is a blockordering,
           each subblock having ordstr=oi, such that vars of same complexity are
           in one block
       
     Note that only simple ordstrings oi are allowed:
     "lp","dp","Dp","ls","ds","Ds".

*Return:*
     nothing

*Note:*
     We define a variable x to be more complex than y (with respect to
     id) if val(x) > val(y) lexicographically, where val(x) denotes the
     valuation vector of x:
     consider id as list of polynomials in x with coefficients in the
     remaining variables. Then:
     val(x) = (maximal occurring power of x, # of all monomials in
     leading coefficient, # of all monomials in coefficient of next
     smaller power of x,...).

*Example:*
     LIB "presolve.lib";
     ring s = 32003,(x,y,z),dp;
     ideal i=x3+y2,xz+z2;
     sortandmap(i,"R_r","i");
     // i is now an ideal in the new basering R_r
     show(R_r);
     ==> // ring: (32003),(y,z,x),(dp(3),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> // i                    [0]  ideal, 2 generator(s)
     kill R_r; setring s;
     sortandmap(i,"R_r","i",1,xy,0,z,0,"ds",0,"lp",0);
     show(R_r);
     ==> // ring: (32003),(x,y,z),(ds(2),lp(1),C);
     ==> // minpoly = 0
     ==> // objects belonging to this ring:
     ==> // i                    [0]  ideal, 2 generator(s)
     kill R_r;


File: singular.hlp,  Node: sortvars,  Next: shortid,  Prev: sortandmap,  Up: presolve_lib

D.7.1.12 sortvars
.................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
sortvars(id[,n1,p1,n2,p2,...]);
id=poly/ideal/vector/module,
     p1,p2,...= polynomials (product of vars),
n1,n2,...=integers
     (default: p1=product of all vars, n1=0)
     the last pi (containing the remaining vars) may be omitted

*Compute:*
     sort variables with respect to their complexity in id

*Return:*
     list of two elements, an ideal and a list:

       [1]: ideal, variables of basering sorted w.r.t their complexity in id
            ni controls the ordering in i-th block (= vars occurring in pi):
            ni=0 (resp.!=0) means that less (resp. more) complex vars come first
       [2]: a list with 4 entries for each pi:
            ideal ai : vars of pi in correct order,
            intvec vi: permutation vector describing the ordering in ai,
            intmat Mi: valuation matrix of ai, the columns of Mi being the
                       valuation vectors of the vars in ai
            intvec wi: size of 1-st, 2-nd,... block of identical columns of Mi
                       (vars with same valuation)
       
*Note:*
     We define a variable x to be more complex than y (with respect to
     id) if val(x) > val(y) lexicographically, where val(x) denotes the
     valuation vector of x:
     consider id as list of polynomials in x with coefficients in the
     remaining variables. Then:
     val(x) = (maximal occurring power of x, # of all monomials in
     leading coefficient, # of all monomials in coefficient of next
     smaller power of x,...).

*Example:*
     LIB "presolve.lib";
     ring s=0,(x,y,z,w),dp;
     ideal i = x3+y2+yw2,xz+z2,xyz-w2;
     sortvars(i,0,xy,1,zw);
     ==> [1]:
     ==>    _[1]=y
     ==>    _[2]=x
     ==>    _[3]=w
     ==>    _[4]=z
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=y
     ==>       _[2]=x
     ==>    [2]:
     ==>       2,1
     ==>    [3]:
     ==>       2,3,
     ==>       1,1,
     ==>       2,0,
     ==>       0,2 
     ==>    [4]:
     ==>       1,1
     ==>    [5]:
     ==>       _[1]=w
     ==>       _[2]=z
     ==>    [6]:
     ==>       2,1
     ==>    [7]:
     ==>       2,2,
     ==>       2,1,
     ==>       0,2 
     ==>    [8]:
     ==>       1,1


File: singular.hlp,  Node: shortid,  Next: valvars,  Prev: sortvars,  Up: presolve_lib

D.7.1.13 shortid
................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     shortid(id,n[,e]); id= ideal/module, n,e=integers

*Return:*
     - if called with two arguments or e=0:
     same type as id, containing generators of id having <= n terms.
     - if called with three arguments and e!=0:
     a list L:
     L[1]: same type as id, containing generators of id having <= n
     terms.
     L[2]: number of corresponding generator of id

*Note:*
     May be used to compute partial standard basis in case id is to hard

*Example:*
     LIB "presolve.lib";
     ring s=0,(x,y,z,w),dp;
     ideal i = (x3+y2+yw2)^2,(xz+z2)^2,xyz-w2-xzw; 
     shortid(i,3);
     ==> _[1]=x2z2+2xz3+z4
     ==> _[2]=xyz-xzw-w2


File: singular.hlp,  Node: valvars,  Next: idealSimplify,  Prev: shortid,  Up: presolve_lib

D.7.1.14 valvars
................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
valvars(id[,n1,p1,n2,p2,...]);
id=poly/ideal/vector/module,
     p1,p2,...= polynomials (product of vars),
     n1,n2,...= integers,

     ni controls the ordering of vars occurring in pi: ni=0 (resp.!=0)
     means that less (resp. more) complex vars come first
     (default: p1=product of all vars, n1=0)
     the last pi (containing the remaining vars) may be omitted

*Compute:*
     valuation (complexity) of variables with respect to id.
     ni controls the ordering of vars occurring in pi:
     ni=0 (resp.!=0) means that less (resp. more) complex vars come
     first.

*Return:*
     list with 3 entries:

       [1]: intvec, say v, describing the permutation such that the permuted
            ringvariables are ordered with respect to their complexity in id
       [2]: list of intvecs, i-th intvec, say v(i) describing permutation
            of vars in a(i) such that v=v(1),v(2),...
       [3]: list of ideals and intmat's, say a(i) and M(i), where
            a(i): factors of pi,
            M(i): valuation matrix of a(i), such that the j-th column of M(i)
                  is the valuation vector of j-th generator of a(i)
              
*Note:*
     Use `sortvars' in order to actually sort the variables!  We define
     a variable x to be more complex than y (with respect to id) if
     val(x) > val(y) lexicographically, where val(x) denotes the
     valuation vector of x:
     consider id as list of polynomials in x with coefficients in the
     remaining variables. Then:
     val(x) = (maximal occurring power of x, # of all monomials in
     leading coefficient, # of all monomials in coefficient of next
     smaller power of x,...).

*Example:*
     LIB "presolve.lib";
     ring s=0,(x,y,z,a,b),dp;
     ideal i=ax2+ay3-b2x,abz+by2;
     valvars (i,0,xyz);
     ==> [1]:
     ==>    3,1,2,4,5
     ==> [2]:
     ==>    [1]:
     ==>       3,1,2
     ==>    [2]:
     ==>       1,2
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=x
     ==>       _[2]=y
     ==>       _[3]=z
     ==>    [2]:
     ==>       2,3,1,
     ==>       1,1,1,
     ==>       1,1,0 
     ==>    [3]:
     ==>       _[1]=a
     ==>       _[2]=b
     ==>    [4]:
     ==>       1,2,
     ==>       3,1,
     ==>       0,2 


File: singular.hlp,  Node: idealSimplify,  Next: idealSplit,  Prev: valvars,  Up: presolve_lib

D.7.1.15 idealSimplify
......................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     idealSimplify(id); id ideal

*Return:*
     ideal I = eliminate(Id,m) m is a product of variables which are
     only linearly involved in the generators of id

*Example:*
     LIB "presolve.lib";
     ring r=0,(x,y,z,w,t),dp;
     ideal i=
     t,
     x3+y2+2z,
     x2+3y,
     x2+y2+z2,
     w2+z;
     ideal j=idealSimplify(i);
     ideal k=eliminate(i,zyt);
     reduce(k,std(j));
     ==> _[1]=0
     ==> _[2]=0
     reduce(j,std(k));
     ==> _[1]=0
     ==> _[2]=0


File: singular.hlp,  Node: idealSplit,  Prev: idealSimplify,  Up: presolve_lib

D.7.1.16 idealSplit
...................

Procedure from library `presolve.lib' (*note presolve_lib::).

*Usage:*
     idealSplit(id,timeF,timeS); id ideal and optional
     timeF ,timeS integers to bound the time which can be used for
     factorization resp. standard basis computation

*Return:*
     a list of ideals such that their intersection
     has the same radical as id

*Example:*
     LIB "presolve.lib";
     ring r=32003,(b,s,t,u,v,w,x,y,z),dp;
     ideal i=
     bv+su,
     bw+tu,
     sw+tv,
     by+sx,
     bz+tx,
     sz+ty,
     uy+vx,
     uz+wx,
     vz+wy,
     bvz;
     idealSplit(i);
     ==> [1]:
     ==>    _[1]=x
     ==>    _[2]=u
     ==>    _[3]=t
     ==>    _[4]=s
     ==>    _[5]=b
     ==>    _[6]=wy+vz
     ==> [2]:
     ==>    _[1]=z
     ==>    _[2]=w
     ==>    _[3]=t
     ==>    _[4]=s
     ==>    _[5]=b
     ==>    _[6]=vx+uy
     ==> [3]:
     ==>    _[1]=z
     ==>    _[2]=x
     ==>    _[3]=w
     ==>    _[4]=u
     ==>    _[5]=t
     ==>    _[6]=b
     ==> [4]:
     ==>    _[1]=z
     ==>    _[2]=y
     ==>    _[3]=x
     ==>    _[4]=t
     ==>    _[5]=s
     ==>    _[6]=b
     ==> [5]:
     ==>    _[1]=z
     ==>    _[2]=y
     ==>    _[3]=x
     ==>    _[4]=u
     ==>    _[5]=b
     ==>    _[6]=tv+sw
     ==> [6]:
     ==>    _[1]=z
     ==>    _[2]=y
     ==>    _[3]=x
     ==>    _[4]=w
     ==>    _[5]=t
     ==>    _[6]=su+bv
     ==> [7]:
     ==>    _[1]=w
     ==>    _[2]=v
     ==>    _[3]=u
     ==>    _[4]=t
     ==>    _[5]=s
     ==>    _[6]=b
     ==> [8]:
     ==>    _[1]=x
     ==>    _[2]=w
     ==>    _[3]=v
     ==>    _[4]=u
     ==>    _[5]=b
     ==>    _[6]=ty+sz
     ==> [9]:
     ==>    _[1]=z
     ==>    _[2]=w
     ==>    _[3]=v
     ==>    _[4]=u
     ==>    _[5]=t
     ==>    _[6]=sx+by
     ==> [10]:
     ==>    _[1]=z
     ==>    _[2]=y
     ==>    _[3]=x
     ==>    _[4]=w
     ==>    _[5]=v
     ==>    _[6]=u
     ==> [11]:
     ==>    _[1]=y
     ==>    _[2]=v
     ==>    _[3]=t
     ==>    _[4]=s
     ==>    _[5]=b
     ==>    _[6]=wx+uz
     ==> [12]:
     ==>    _[1]=y
     ==>    _[2]=x
     ==>    _[3]=v
     ==>    _[4]=u
     ==>    _[5]=s
     ==>    _[6]=b
     ==> [13]:
     ==>    _[1]=z
     ==>    _[2]=y
     ==>    _[3]=x
     ==>    _[4]=v
     ==>    _[5]=s
     ==>    _[6]=tu+bw
     ==> [14]:
     ==>    _[1]=z
     ==>    _[2]=y
     ==>    _[3]=w
     ==>    _[4]=v
     ==>    _[5]=t
     ==>    _[6]=s
     ==> [15]:
     ==>    _[1]=y
     ==>    _[2]=w
     ==>    _[3]=v
     ==>    _[4]=u
     ==>    _[5]=s
     ==>    _[6]=tx+bz


File: singular.hlp,  Node: solve_lib,  Next: triang_lib,  Prev: presolve_lib,  Up: Symbolic-numerical solving

D.7.2 solve_lib
---------------

*Library:*
     solve.lib

*Purpose:*
     Complex Solving of Polynomial Systems

*Author:*
     Moritz Wenk, email: wenk@mathematik.uni-kl.de
     Wilfred Pohl, email: pohl@mathematik.uni-kl.de

*Procedures:*

* Menu:

* laguerre_solve:: find all roots of univariate polynomial p
* solve:: all roots of 0-dim. ideal i using triangular sets
* ures_solve:: find all roots of 0-dimensional ideal i with resultants
* mp_res_mat:: multipolynomial resultant matrix of ideal i
* interpolate:: interpolate poly from evaluation points i and results j
* fglm_solve:: find roots of 0-dim. ideal using FGLM and lex_solve
* lex_solve:: find roots of reduced lexicographic standard basis
* simplexOut:: prints solution of simplex in nice format
* triangLf_solve:: find roots using triangular sys. (factorizing Lazard)
* triangM_solve:: find roots of given triangular system (Moeller)
* triangL_solve:: find roots using triangular system (Lazard)
* triang_solve:: find roots of given triangular system


File: singular.hlp,  Node: laguerre_solve,  Next: solve,  Up: solve_lib

D.7.2.1 laguerre_solve
......................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     laguerre_solve(f [, m, l, n, s] ); f = polynomial,
     m, l, n, s = integers (control parameters of the method)

      m: precision of output in digits ( 4 <= m), if basering is not ring of 
           complex numbers;
      l: precision of internal computation in decimal digits ( l >=8 )
           only if the basering is not complex or complex with smaller precision;
      n: control of multiplicity of roots or of splitting of f into
           squarefree factors
           n < 0, no split of f (good, if all roots are simple)
           n >= 0, try to split
           n = 0, return only different roots
           n > 0, find all roots (with multiplicity)
      s: s != 0, returns ERROR if  | f(root) | > 0.1^m (when computing in the 
           current ring)
      ( default: m, l, n, s = 8, 30, 1, 0 )

*Assume:*
     f is a univariate polynomial;
     basering has characteristic 0 and is either complex or without
     parameters.

*Return:*
     list of (complex) roots of the polynomial f, depending on n. The
     result is of type

      string: if the basering is not complex,
      number: otherwise.

*Note:*
     If printlevel >0: displays comments ( default = 0 ).
     If s != 0 and if the procedure stops with ERROR, try a higher
     internal precision m.

*Example:*
     LIB "solve.lib";
     // Find all roots of an univariate polynomial using Laguerre's method:
     ring rs1= 0,(x,y),lp;
     poly f = 15x5 + x3 + x2 - 10;
     // 10 digits precision
     laguerre_solve(f,10);
     ==> [1]:
     ==>    (0.2930464644-i*0.9003002396)
     ==> [2]:
     ==>    (0.2930464644+i*0.9003002396)
     ==> [3]:
     ==>    (-0.7392783383-i*0.5355190078)
     ==> [4]:
     ==>    (-0.7392783383+i*0.5355190078)
     ==> [5]:
     ==>    0.8924637479
     // Now with complex coefficients,
     // internal precision is 30 digits (default)
     printlevel=2;
     ring rsc= (real,10,i),x,lp;
     poly f = (15.4+i*5)*x^5 + (25.0e-2+i*2)*x^3 + x2 - 10*i;
     list l = laguerre_solve(f);
     ==> //BEGIN laguerre_solve
     ==> //control: complex ring with precision 30
     ==> //working in:  ring lagc=(complex,30,30),x,lp;
     ==> //         polynomial has complex coefficients
     ==> //split in working ring:
     ==> // split without result
     ==> //END laguerre_solve
     l;
     ==> [1]:
     ==>    (0.04588498039+i*0.9133296179)
     ==> [2]:
     ==>    (0.5037408279-i*0.8058051828)
     ==> [3]:
     ==>    (-0.5462895588-i*0.6796668873)
     ==> [4]:
     ==>    (0.8524014357+i*0.2163760334)
     ==> [5]:
     ==>    (-0.8557376852+i*0.3557664188)
     // check result, value of substituted poly should be near to zero
     // remember that l contains a list of strings
     // in the case of a different ring
     subst(f,x,l[1]);
     ==> 0
     subst(f,x,l[2]);
     ==> 0


File: singular.hlp,  Node: solve,  Next: ures_solve,  Prev: laguerre_solve,  Up: solve_lib

D.7.2.2 solve
.............

Procedure from library `solve.lib' (*note solve_lib::).

*Assume:*
     the ideal is 0-dimensional;
     basering has characteristic 0 and is either complex or without
     parameters;

*Return:*
     list of solutions of the ideal G, depending on n; one solution is a
     list of complex numbers in the generated output ring (the new
     basering).

      The result is a list L
         n  = 0: a list of all different solutions (L[i]),
         n != 0: a list of two elements,
                 L[i][1] contains all different solutions with the same multiplicity
                 L[i][2] the multiplicity
      L is ordered w.r.t. multiplicity (the smallest first).

*Note:*
     If the problem is not 0-dim. the procedure stops with ERROR, if the
     ideal G is not a lex. standard basis, it is generated with internal
     computation (Hilbert driven), if the input-ring (with char 0) has
     the name "<A>", the lexicographical and complex output-ring has the
     name "<A>C".

*Example:*
     LIB "solve.lib";
     // Find all roots of a multivariate ideal using triangular sets:
     int d=4;// with these 3 parameters you may construct
     int t=3;// very hard problems for 'solve'
     int s=2;
     int i;
     ring A=0,(x(1..d)),dp;
     poly p=-1;
     for(i=d;i>0;i--){p=p+x(i)^s;}
     ideal I=x(d)^t-x(d)^s+p;
     for(i=d-1;i>0;i--){I=x(i)^t-x(i)^s+p,I;}
     I;
     ==> I[1]=x(1)^3+x(2)^2+x(3)^2+x(4)^2-1
     ==> I[2]=x(2)^3+x(1)^2+x(3)^2+x(4)^2-1
     ==> I[3]=x(3)^3+x(1)^2+x(2)^2+x(4)^2-1
     ==> I[4]=x(4)^3+x(1)^2+x(2)^2+x(3)^2-1
     // the mutiplicity is
     vdim(std(I));
     ==> 81
     list l1=solve(I,6,0);
     ==> // name of new current ring: AC
     // the current ring is
     AC;
     ==> //   characteristic : 0 (complex:6 digits, additional 6 digits)
     ==> //   1 parameter    : i 
     ==> //   minpoly        : (i^2+1)
     ==> //   number of vars : 4
     ==> //        block   1 : ordering lp
     ==> //                  : names    x(1) x(2) x(3) x(4) 
     ==> //        block   2 : ordering C
     // you must start with char. 0
     setring A;
     list l2=solve(I,6,1);
     ==> // name of current ring: AC
     // the number of different solutions is
     size(l1);
     ==> 37
     // this is equal to
     size(l2[1][1])+size(l2[2][1]);
     ==> 37
     // the number of solutions with multiplicity is
     size(l2[1][1])*l2[1][2]+size(l2[2][1])*l2[2][2];
     ==> 81
     // the solutions with multiplicity
     l2[2][2];
     ==> 12
     // are
     l2[2][1];
     ==> [1]:
     ==>    [1]:
     ==>       0
     ==>    [2]:
     ==>       0
     ==>    [3]:
     ==>       1
     ==>    [4]:
     ==>       0
     ==> [2]:
     ==>    [1]:
     ==>       0
     ==>    [2]:
     ==>       1
     ==>    [3]:
     ==>       0
     ==>    [4]:
     ==>       0
     ==> [3]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       0
     ==>    [3]:
     ==>       0
     ==>    [4]:
     ==>       0
     ==> [4]:
     ==>    [1]:
     ==>       0
     ==>    [2]:
     ==>       0
     ==>    [3]:
     ==>       0
     ==>    [4]:
     ==>       1


File: singular.hlp,  Node: ures_solve,  Next: mp_res_mat,  Prev: solve,  Up: solve_lib

D.7.2.3 ures_solve
..................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     ures_solve(i [, k, p] ); i = ideal, k, p = integers

        k=0: use sparse resultant matrix of Gelfand, Kapranov and Zelevinsky,
        k=1: use resultant matrix of Macaulay which works only for
               homogeneous ideals,
        p>0: defines precision of the long floats for internal computation
               if the basering is not complex (in decimal digits),
        (default: k=0, p=30)

*Assume:*
     i is a zerodimensional ideal with
     nvars(basering) = ncols(i) = number of vars
     actually occurring in i,

*Return:*
     list of all (complex) roots of the polynomial system i = 0; the
     result is of type

        string: if the basering is not complex,
        number: otherwise.

*Example:*
     LIB "solve.lib";
     // compute the intersection points of two curves
     ring rsq = 0,(x,y),lp;
     ideal gls=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
     ures_solve(gls,0,16);
     ==> [1]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       -3
     ==> [2]:
     ==>    [1]:
     ==>       -1
     ==>    [2]:
     ==>       3
     ==> [3]:
     ==>    [1]:
     ==>       2.82842712474619
     ==>    [2]:
     ==>       1.414213562373095
     ==> [4]:
     ==>    [1]:
     ==>       -2.82842712474619
     ==>    [2]:
     ==>       -1.414213562373095
     // result is a list (x,y)-coordinates as strings
     // now with complex coefficient field, precision is 20 digits
     ring rsc= (real,20,I),(x,y),lp;
     ideal i = (2+3*I)*x2 + (0.35+I*45.0e-2)*y2 - 8, x2 + xy + (42.7)*y2;
     list l= ures_solve(i,0,10);
     // result is a list of (x,y)-coordinates of complex numbers
     l;
     ==> [1]:
     ==>    [1]:
     ==>       (-1.315392899374542198+I*0.70468233142752928117)
     ==>    [2]:
     ==>       (0.12292646536251281054+I*0.19245727404407015049)
     ==> [2]:
     ==>    [1]:
     ==>       (1.315392899374542198-I*0.70468233142752928117)
     ==>    [2]:
     ==>       (-0.12292646536251281054-I*0.19245727404407015049)
     ==> [3]:
     ==>    [1]:
     ==>       (1.31584587549391830705-I*0.70396753310002259573)
     ==>    [2]:
     ==>       (0.092006639590217681983+I*0.20902112035965287775)
     ==> [4]:
     ==>    [1]:
     ==>       (-1.31584587549391830705+I*0.70396753310002259573)
     ==>    [2]:
     ==>       (-0.092006639590217681983-I*0.20902112035965287775)
     // check the result
     subst(subst(i[1],x,l[1][1]),y,l[1][2]);
     ==> 0


File: singular.hlp,  Node: mp_res_mat,  Next: interpolate,  Prev: ures_solve,  Up: solve_lib

D.7.2.4 mp_res_mat
..................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     mp_res_mat(i [, k] ); i ideal, k integer,

         k=0: sparse resultant matrix of Gelfand, Kapranov and Zelevinsky,
         k=1: resultant matrix of Macaulay (k=0 is default)

*Assume:*
     The number of elements in the input system must be the number of
     variables in the basering plus one;
     if k=1 then i must be homogeneous.

*Return:*
     module representing the multipolynomial resultant matrix

*Example:*
     LIB "solve.lib";
     // compute resultant matrix in ring with parameters (sparse resultant matrix)
     ring rsq= (0,u0,u1,u2),(x1,x2),lp;
     ideal i= u0+u1*x1+u2*x2,x1^2 + x2^2 - 10,x1^2 + x1*x2 + 2*x2^2 - 16;
     module m = mp_res_mat(i);
     print(m);
     ==> -16,0,  -10,0,  (u0),0,   0,  0,   0,   0,  
     ==> 0,  -16,0,  -10,(u2),(u0),0,  0,   0,   0,  
     ==> 2,  0,  1,  0,  0,   (u2),0,  0,   0,   0,  
     ==> 0,  2,  0,  1,  0,   0,   0,  0,   0,   0,  
     ==> 0,  0,  0,  0,  (u1),0,   -10,(u0),0,   -16,
     ==> 1,  0,  0,  0,  0,   (u1),0,  (u2),(u0),0,  
     ==> 0,  1,  0,  0,  0,   0,   1,  0,   (u2),2,  
     ==> 1,  0,  1,  0,  0,   0,   0,  (u1),0,   0,  
     ==> 0,  1,  0,  1,  0,   0,   0,  0,   (u1),1,  
     ==> 0,  0,  0,  0,  0,   0,   1,  0,   0,   1   
     // computing sparse resultant
     det(m);
     ==> (-2*u0^4+18*u0^2*u1^2+4*u0^2*u1*u2+22*u0^2*u2^2-16*u1^4+80*u1^3*u2-52*u1^\
        2*u2^2-120*u1*u2^3-36*u2^4)
     // compute resultant matrix (Macaulay resultant matrix)
     ring rdq= (0,u0,u1,u2),(x0,x1,x2),lp;
     ideal h=  homog(imap(rsq,i),x0);
     h;
     ==> h[1]=(u0)*x0+(u1)*x1+(u2)*x2
     ==> h[2]=-10*x0^2+x1^2+x2^2
     ==> h[3]=-16*x0^2+x1^2+x1*x2+2*x2^2
     module m = mp_res_mat(h,1);
     print(m);
     ==> x0, x1, x2, 0, 0, 0, 0,0, 0, 0,
     ==> 0,  x0, 0,  x1,x2,0, 0,0, 0, 0,
     ==> 0,  0,  x0, 0, x1,x2,0,0, 0, 0,
     ==> -10,0,  0,  1, 0, 1, 0,0, 0, 0,
     ==> 0,  0,  0,  0, x0,0, 0,x1,x2,0,
     ==> -16,0,  0,  1, 1, 2, 0,0, 0, 0,
     ==> 0,  -10,0,  0, 0, 0, 1,0, 1, 0,
     ==> 0,  0,  -10,0, 0, 0, 0,1, 0, 1,
     ==> 0,  -16,0,  0, 0, 0, 1,1, 2, 0,
     ==> 0,  0,  -16,0, 0, 0, 0,1, 1, 2 
     // computing Macaulay resultant (should be the same as above!)
     det(m);
     ==> 2*x0^4-18*x0^2*x1^2-4*x0^2*x1*x2-22*x0^2*x2^2+16*x1^4-80*x1^3*x2+52*x1^2*\
        x2^2+120*x1*x2^3+36*x2^4
     // compute numerical sparse resultant matrix
     setring rsq;
     ideal ir= 15+2*x1+5*x2,x1^2 + x2^2 - 10,x1^2 + x1*x2 + 2*x2^2 - 16;
     module mn = mp_res_mat(ir);
     print(mn);
     ==> 15,0, -10,0,  0, 0, 0,  -16,0,  0,  
     ==> 5, 15,0,  -10,0, 0, 0,  0,  -16,0,  
     ==> 0, 5, 1,  0,  0, 0, 0,  2,  0,  0,  
     ==> 0, 0, 0,  1,  0, 0, 0,  0,  2,  0,  
     ==> 2, 0, 0,  0,  15,0, -10,0,  0,  -16,
     ==> 0, 2, 0,  0,  5, 15,0,  1,  0,  0,  
     ==> 0, 0, 0,  0,  0, 5, 1,  0,  1,  2,  
     ==> 0, 0, 1,  0,  2, 0, 0,  1,  0,  0,  
     ==> 0, 0, 0,  1,  0, 2, 0,  0,  1,  1,  
     ==> 0, 0, 0,  0,  0, 0, 1,  0,  0,  1   
     // computing sparse resultant
     det(mn);
     ==> -7056


File: singular.hlp,  Node: interpolate,  Next: fglm_solve,  Prev: mp_res_mat,  Up: solve_lib

D.7.2.5 interpolate
...................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     interpolate(p,v,d); p,v=ideals of numbers, d=integer

*Assume:*
     Ground field K is the field of rational numbers, p and v are lists
     of elements of the ground field K with p[j] != -1,0,1, size(p) = n
     (= number of vars) and size(v)=N=(d+1)^n.

*Return:*
     poly f, the unique polynomial f of degree n*d with prescribed
     values v[i] at the points p(i)=(p[1]^(i-1),..,p[n]^(i-1)),
     i=1,..,N.

*Note:*
     mainly useful when n=1, i.e. f is satisfying f(p^(i-1)) = v[i],
     i=1..d+1.

*Example:*
     LIB "solve.lib";
     ring r1 = 0,(x),lp;
     // determine f with deg(f) = 4 and
     // v = values of f at points 3^0, 3^1, 3^2, 3^3, 3^4
     ideal v=16,0,11376,1046880,85949136;
     interpolate( 3, v, 4 );
     ==> 2x4-22x2+36

* Menu:

See also:
* vandermonde::

*See also:* *note vandermonde::.


File: singular.hlp,  Node: fglm_solve,  Next: lex_solve,  Prev: interpolate,  Up: solve_lib

D.7.2.6 fglm_solve
..................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     fglm_solve(i [, p] ); i ideal, p integer

*Assume:*
     the ground field has char 0.

*Return:*
     a list of numbers, the complex roots of i;
     p>0: gives precision of complex numbers in decimal digits (default:
     p=30).

*Note:*
     The procedure uses a standard basis of i to determine all complex
     roots of i.
     It creates a ring rC with the same number of variables but with
     complex coefficients (and precision p).

*Example:*
     LIB "solve.lib";
     ring r = 0,(x,y),lp;
     // compute the intersection points of two curves
     ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
     fglm_solve(s,10);
     ==> // name of new ring: rC
     ==> // list of roots: rlist
     rlist;
     ==> [1]:
     ==>    [1]:
     ==>       2.8284271247
     ==>    [2]:
     ==>       1.4142135624
     ==> [2]:
     ==>    [1]:
     ==>       -2.8284271247
     ==>    [2]:
     ==>       -1.4142135624
     ==> [3]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       -3
     ==> [4]:
     ==>    [1]:
     ==>       -1
     ==>    [2]:
     ==>       3


File: singular.hlp,  Node: lex_solve,  Next: simplexOut,  Prev: fglm_solve,  Up: solve_lib

D.7.2.7 lex_solve
.................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     lex_solve( i[,p] ); i=ideal, p=integer,

       p>0: gives precision of complex numbers in decimal digits (default: p=30).
      
*Assume:*
     i is a reduced lexicographical Groebner bases of a zero-dimensional
     ideal, sorted by increasing leading terms.

*Return:*
     nothing

*Create:*
     The procedure creates a complec ring with the same variables but
     with complex coefficients (and precision p).
     In this ring a list rlist of numbers is created, in which the
     complex roots of i are stored.

*Example:*
     LIB "solve.lib";
     ring r = 0,(x,y),lp;
     // compute the intersection points of two curves
     ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
     lex_solve(stdfglm(s),10);
     ==> // name of new ring: rC
     ==> // list of roots: rlist
     rlist;
     ==> [1]:
     ==>    [1]:
     ==>       2.8284271247
     ==>    [2]:
     ==>       1.4142135624
     ==> [2]:
     ==>    [1]:
     ==>       -2.8284271247
     ==>    [2]:
     ==>       -1.4142135624
     ==> [3]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       -3
     ==> [4]:
     ==>    [1]:
     ==>       -1
     ==>    [2]:
     ==>       3


File: singular.hlp,  Node: simplexOut,  Next: triangLf_solve,  Prev: lex_solve,  Up: solve_lib

D.7.2.8 simplexOut
..................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     simplexOut(l); l list

*Assume:*
     l is the output of simplex.

*Return:*
     nothing. The procedure prints the computed solution of simplex (as
     strings) in a nice format.

*Example:*
     LIB "solve.lib";
     ring r = (real,10),(x),lp;
     // consider the max. problem:
     //
     //    maximize  x(1) + x(2) + 3*x(3) - 0.5*x(4)
     //
     //  with constraints:   x(1) +          2*x(3)          <= 740
     //                             2*x(2)          - 7*x(4) <=   0
     //                               x(2) -   x(3) + 2*x(4) >=   0.5
     //                      x(1) +   x(2) +   x(3) +   x(4)  =   9
     //
     matrix sm[5][5]=   0, 1, 1, 3,-0.5,
     740,-1, 0,-2, 0,
     0, 0,-2, 0, 7,
     0.5, 0,-1, 1,-2,
     9,-1,-1,-1,-1;
     int n = 4;  // number of constraints
     int m = 4;  // number of variables
     int m1= 2;  // number of <= constraints
     int m2= 1;  // number of >= constraints
     int m3= 1;  // number of == constraints
     list sol=simplex(sm, n, m, m1, m2, m3);
     simplexOut(sol);
     ==> z = 17.025
     ==> x2 = 3.325
     ==> x4 = 0.95
     ==> x3 = 4.725

* Menu:

See also:
* simplex::

*See also:* *note simplex::.


File: singular.hlp,  Node: triangLf_solve,  Next: triangM_solve,  Prev: simplexOut,  Up: solve_lib

D.7.2.9 triangLf_solve
......................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     triangLf_solve(i [, p] ); i ideal, p integer,
     p>0: gives precision of complex numbers in digits (default: p=30).

*Assume:*
     the ground field has char 0; i is a zero-dimensional ideal

*Return:*
     nothing

*Create:*
     The procedure creates a ring rC with the same number of variables
     but with complex coefficients (and precision p).
     In rC a list rlist of numbers is created, in which the complex
     roots of i are stored.
     The proc uses a triangular system (Lazard's Algorithm with
     factorization) computed from a standard basis to determine
     recursively all complex roots with Laguerre's algorithm of input
     ideal i.

*Example:*
     LIB "solve.lib";
     ring r = 0,(x,y),lp;
     // compute the intersection points of two curves
     ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
     triangLf_solve(s,10);
     ==> // name of new ring: rC
     ==> // list of roots: rlist
     rlist;
     ==> [1]:
     ==>    [1]:
     ==>       -1
     ==>    [2]:
     ==>       3
     ==> [2]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       -3
     ==> [3]:
     ==>    [1]:
     ==>       2.8284271247
     ==>    [2]:
     ==>       1.4142135624
     ==> [4]:
     ==>    [1]:
     ==>       -2.8284271247
     ==>    [2]:
     ==>       -1.4142135624


File: singular.hlp,  Node: triangM_solve,  Next: triangL_solve,  Prev: triangLf_solve,  Up: solve_lib

D.7.2.10 triangM_solve
......................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     triangM_solve(i [, p ] ); i=ideal, p=integer,
     p>0: gives precision of complex numbers in digits (default: p=30).

*Assume:*
     the ground field has char 0;
     i zero-dimensional ideal

*Return:*
     nothing

*Create:*
     The procedure creates a ring rC with the same number of variables
     but with complex coefficients (and precision p).
     In rC a list rlist of numbers is created, in which the complex
     roots of i are stored.
     The proc uses a triangular system (Moellers Algorithm) computed
     from a standard basis to determine recursively all complex roots
     with Laguerre's algorithm of input ideal i.

*Example:*
     LIB "solve.lib";
     ring r = 0,(x,y),lp;
     // compute the intersection points of two curves
     ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
     triangM_solve(s,10);
     ==> // name of new ring: rC
     ==> // list of roots: rlist
     rlist;
     ==> [1]:
     ==>    [1]:
     ==>       2.8284271247
     ==>    [2]:
     ==>       1.4142135624
     ==> [2]:
     ==>    [1]:
     ==>       -2.8284271247
     ==>    [2]:
     ==>       -1.4142135624
     ==> [3]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       -3
     ==> [4]:
     ==>    [1]:
     ==>       -1
     ==>    [2]:
     ==>       3


File: singular.hlp,  Node: triangL_solve,  Next: triang_solve,  Prev: triangM_solve,  Up: solve_lib

D.7.2.11 triangL_solve
......................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     triangL_solve(i [, p] ); i=ideal, p=integer,
     p>0: gives precision of complex numbers in digits (default: p=30).

*Assume:*
     the ground field has char 0; i is a zero-dimensional ideal.

*Return:*
     nothing

*Create:*
     The procedure creates a ring rC with the same number of variables
     but with complex coefficients (and precision p).
     In rC a list rlist of numbers is created, in which the complex
     roots of i are stored.
     The proc uses a triangular system (Lazard's Algorithm) computed
     from a standard basis to determine recursively all complex roots
     with Laguerre's algorithm of input ideal i.

*Example:*
     LIB "solve.lib";
     ring r = 0,(x,y),lp;
     // compute the intersection points of two curves
     ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
     triangL_solve(s,10);
     ==> // name of new ring: rC
     ==> // list of roots: rlist
     rlist;
     ==> [1]:
     ==>    [1]:
     ==>       2.8284271247
     ==>    [2]:
     ==>       1.4142135624
     ==> [2]:
     ==>    [1]:
     ==>       -2.8284271247
     ==>    [2]:
     ==>       -1.4142135624
     ==> [3]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       -3
     ==> [4]:
     ==>    [1]:
     ==>       -1
     ==>    [2]:
     ==>       3


File: singular.hlp,  Node: triang_solve,  Prev: triangL_solve,  Up: solve_lib

D.7.2.12 triang_solve
.....................

Procedure from library `solve.lib' (*note solve_lib::).

*Usage:*
     triang_solve(l,p [, d] ); l=list, p,d=integers,
     l a list of finitely many triangular systems, such that the union
     of their varieties equals the variety of the initial ideal.
     p>0: gives precision of complex numbers in digits,
     d>0: gives precision (1<d<p) for near-zero-determination,
     (default: d=1/2*p).

*Assume:*
     the ground field has char 0;
     l was computed using Algorithm of Lazard or Algorithm of Moeller
     (see triang.lib).

*Return:*
     nothing

*Create:*
     The procedure creates a ring rC with the same number of variables
     but with complex coefficients (and precision p).
     In rC a list rlist of numbers is created, in which the complex
     roots of i are stored.

*Example:*
     LIB "solve.lib";
     ring r = 0,(x,y),lp;
     // compute the intersection points of two curves
     ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
     triang_solve(triangLfak(stdfglm(s)),10);
     ==> // name of new ring: rC
     ==> // list of roots: rlist
     rlist;
     ==> [1]:
     ==>    [1]:
     ==>       -1
     ==>    [2]:
     ==>       3
     ==> [2]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       -3
     ==> [3]:
     ==>    [1]:
     ==>       2.8284271247
     ==>    [2]:
     ==>       1.4142135624
     ==> [4]:
     ==>    [1]:
     ==>       -2.8284271247
     ==>    [2]:
     ==>       -1.4142135624


File: singular.hlp,  Node: triang_lib,  Next: ntsolve_lib,  Prev: solve_lib,  Up: Symbolic-numerical solving

D.7.3 triang_lib
----------------

*Library:*
     triang.lib

*Purpose:*
     Decompose Zero-dimensional Ideals into Triangular Sets

*Author:*
     D. Hillebrand

*Procedures:*

* Menu:

* triangL:: Decomposition of (G) into triangular systems (Lazard).
* triangLfak:: Decomp. of (G) into tri. systems plus factorization.
* triangM:: Decomposition of (G) into triangular systems (Moeller).
* triangMH:: Decomp. of (G) into tri. syst. with disjoint varieties.


File: singular.hlp,  Node: triangL,  Next: triangLfak,  Up: triang_lib

D.7.3.1 triangL
...............

Procedure from library `triang.lib' (*note triang_lib::).

*Usage:*
     triangL(G); G=ideal

*Assume:*
     G is the reduced lexicographical Groebner bases of the
     zero-dimensional ideal (G), sorted by increasing leading terms.

*Return:*
     a list of finitely many triangular systems, such that the union of
     their varieties equals the variety of (G).

*Note:*
     Algorithm of Lazard (see: Lazard, D.: Solving zero-dimensional
     algebraic systems, J. Symb. Comp. 13, 117 - 132, 1992).

*Example:*
     LIB "triang.lib";
     ring rC5 = 0,(e,d,c,b,a),lp;
     triangL(stdfglm(cyclic(5)));


File: singular.hlp,  Node: triangLfak,  Next: triangM,  Prev: triangL,  Up: triang_lib

D.7.3.2 triangLfak
..................

Procedure from library `triang.lib' (*note triang_lib::).

*Usage:*
     triangLfak(G); G=ideal

*Assume:*
     G is the reduced lexicographical Groebner bases of the
     zero-dimensional ideal (G), sorted by increasing leading terms.

*Return:*
     a list of finitely many triangular systems, such that the union of
     their varieties equals the variety of (G).

*Note:*
     Algorithm of Lazard with factorization (see: Lazard, D.: Solving
     zero-dimensional algebraic systems, J. Symb. Comp. 13, 117 - 132,
     1992).

*Remark:*
     each polynomial of the triangular systems is factorized.

*Example:*
     LIB "triang.lib";
     ring rC5 = 0,(e,d,c,b,a),lp;
     triangLfak(stdfglm(cyclic(5)));


File: singular.hlp,  Node: triangM,  Next: triangMH,  Prev: triangLfak,  Up: triang_lib

D.7.3.3 triangM
...............

Procedure from library `triang.lib' (*note triang_lib::).

*Usage:*
     triangM(G[,i]); G=ideal, i=integer,

*Assume:*
     G is the reduced lexicographical Groebner bases of the
     zero-dimensional ideal (G), sorted by increasing leading terms.

*Return:*
     a list of finitely many triangular systems, such that the union of
     their varieties equals the variety of (G).  If i = 2, then each
     polynomial of the triangular systems is factorized.

*Note:*
     Algorithm of Moeller (see: Moeller, H.M.:
     On decomposing systems of polynomial equations with
     finitely many solutions, Appl. Algebra Eng. Commun. Comput. 4, 217
     - 230, 1993).

*Example:*
     LIB "triang.lib";
     ring rC5 = 0,(e,d,c,b,a),lp;
     triangM(stdfglm(cyclic(5))); //oder: triangM(stdfglm(cyclic(5)),2);


File: singular.hlp,  Node: triangMH,  Prev: triangM,  Up: triang_lib

D.7.3.4 triangMH
................

Procedure from library `triang.lib' (*note triang_lib::).

*Usage:*
     triangMH(G[,i]); G=ideal, i=integer

*Assume:*
     G is the reduced lexicographical Groebner bases of the
     zero-dimensional ideal (G), sorted by increasing leading terms.

*Return:*
     a list of finitely many triangular systems, such that the disjoint
     union of their varieties equals the variety of (G).  If i = 2, then
     each polynomial of the triangular systems is factorized.

*Note:*
     Algorithm of Moeller and Hillebrand (see: Moeller, H.M.: On
     decomposing systems of polynomial equations with finitely many
     solutions, Appl. Algebra Eng. Commun. Comput. 4, 217 - 230, 1993
     and Hillebrand, D.: Triangulierung nulldimensionaler Ideale -
     Implementierung und Vergleich zweier Algorithmen, master thesis,
     Universitaet Dortmund, Fachbereich Mathematik, Prof. Dr. H.M.
     Moeller, 1999).

*Example:*
     LIB "triang.lib";
     ring rC5 = 0,(e,d,c,b,a),lp;
     triangMH(stdfglm(cyclic(5)));


File: singular.hlp,  Node: ntsolve_lib,  Next: zeroset_lib,  Prev: triang_lib,  Up: Symbolic-numerical solving

D.7.4 ntsolve_lib
-----------------

*Library:*
     ntsolve.lib

*Purpose:*
     Real Newton Solving of Polynomial Systems

*Authors:*
     Wilfred Pohl, email: pohl@mathematik.uni-kl.de
     Dietmar Hillebrand

*Procedures:*

* Menu:

* nt_solve:: find one real root of 0-dimensional ideal G
* triMNewton:: find one real root for 0-dim triangular system G


File: singular.hlp,  Node: nt_solve,  Next: triMNewton,  Up: ntsolve_lib

D.7.4.1 nt_solve
................

Procedure from library `ntsolve.lib' (*note ntsolve_lib::).

*Usage:*
     nt_solve(gls,ini[,ipar]); gls,ini= ideals, ipar=list/intvec,
     gls: contains the equations, for which a solution will be computed
     ini: ideal of initial values (approximate solutions to start with),
     ipar: control integers (default: ipar = 100,10)

      ipar[1]: max. number of iterations
      ipar[2]: accuracy (we have the l_2-norm ||.||): accept solution `sol'
               if ||gls(sol)|| < eps0*(0.1^ipar[2])
               where eps0 = ||gls(ini)|| is the initial error
       
*Assume:*
     gls is a zerodimensional ideal with nvars(basering) = size(gls)
     (>1)

*Return:*
     ideal, coordinates of one solution (if found), 0 else

*Note:*
     if printlevel >0: displays comments (default =0)

*Example:*
     LIB "ntsolve.lib";
     ring rsq = (real,40),(x,y,z,w),lp;
     ideal gls =  x2+y2+z2-10, y2+z3+w-8, xy+yz+xz+w5 - 1,w3+y;
     ideal ini = 3.1,2.9,1.1,0.5;
     intvec ipar = 200,0;
     ideal sol = nt_solve(gls,ini,ipar);
     sol;
     ==> sol[1]=0.8698104581550055082008024750939710335537
     ==> sol[2]=2.8215774457503246008496262517717182369409
     ==> sol[3]=1.1323120084664179900060940157112668717318
     ==> sol[4]=-1.413071026406678849397999475590194239628


File: singular.hlp,  Node: triMNewton,  Prev: nt_solve,  Up: ntsolve_lib

D.7.4.2 triMNewton
..................

Procedure from library `ntsolve.lib' (*note ntsolve_lib::).

*Usage:*
     triMNewton(G,a[,ipar]); G,a= ideals, ipar=list/intvec

*Assume:*
     G: g1,..,gn, a triangular system of n equations in n vars, i.e.
gi=gi(var(n-i+1),..,var(n)),
     a: ideal of numbers, coordinates of an approximation of a common
     zero of G to start with (with a[i] to be substituted in var(i)),
     ipar: control integer vector (default: ipar = 100,10)

       ipar[1]: max. number of iterations
       ipar[2]: accuracy (we have as norm |.| absolute value ):
                accept solution `sol' if |G(sol)| < |G(a)|*(0.1^ipar[2]).
       
*Return:*
     an ideal, coordinates of a better approximation of a zero of G

*Example:*
     LIB "ntsolve.lib";
     ring r = (real,30),(z,y,x),(lp);
     ideal i = x^2-1,y^2+x4-3,z2-y4+x-1;
     ideal a = 2,3,4;
     intvec e = 20,10;
     ideal l = triMNewton(i,a,e);
     l;
     ==> l[1]=-2.000000000042265738880279143423
     ==> l[2]=1.41421356237309504880168872421
     ==> l[3]=1


File: singular.hlp,  Node: zeroset_lib,  Prev: ntsolve_lib,  Up: Symbolic-numerical solving

D.7.5 zeroset_lib
-----------------

*Library:*
     zeroset.lib

*Purpose:*
     Procedures For Roots and Factorization

*Author:*
     Thomas Bayer, email: tbayer@mathematik.uni-kl.de
     http://wwwmayr.informatik.tu-muenchen.de/personen/bayert/ Current
     Adress: Institut fuer Informatik, TU Muenchen

*Overview:*
     Algorithms for finding the zero-set of a zero-dim. ideal in
     Q(a)[x_1,..,x_n], Roots and Factorization of univariate polynomials
     over Q(a)[t] where a is an algebraic number. Written in the frame
     of the diploma thesis (advisor: Prof. Gert-Martin Greuel)
     'Computations of moduli spaces of semiquasihomogeneous
     singularities and an implementation in Singular'.  This library is
     meant as a preliminary extension of the functionality of Singular
     for univariate factorization of polynomials over simple algebraic
     extensions in characteristic 0.
     Subprocedures with postfix 'Main' require that the ring contains a
     variable 'a' and no parameters, and the ideal 'mpoly', where
     'minpoly' from the basering is stored.

*Procedures:*

* Menu:

* EGCD:: gcd over an algebraic extension field of Q
* Factor:: factorization of f over an algebraic extension field
* Quotient:: quotient q of f w.r.t. g (in f = q*g + remainder)
* Remainder:: remainder of the division of f by g
* Roots:: computes all roots of f in an extension field of Q
* SQFRNorm:: norm of f (f must be squarefree)
* ZeroSet:: zero-set of the 0-dim. ideal I

*Auxiliary procedures:*

* Menu:

* EGCDMain:: gcd over an algebraic extension field of Q
* FactorMain:: factorization of f over an algebraic extension field
* InvertNumberMain:: inverts an element of an algebraic extension field
* QuotientMain:: quotient of f w.r.t. g
* RemainderMain:: remainder of the division of f by g
* RootsMain:: computes all roots of f, might extend the ground field
* SQFRNormMain:: norm of f (f must be squarefree)
* ContainedQ:: f in data ?
* SameQ:: a == b (list a,b)


File: singular.hlp,  Node: EGCD,  Next: Factor,  Up: zeroset_lib

D.7.5.1 EGCD
............

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     EGCD(f, g); where f,g are polynomials

*Purpose:*
     compute the polynomial gcd of f and g over Q(a)[x]

*Return:*
     polynomial h s.t. h is a greatest common divisor of f and g (not
     nec.  monic)

*Assume:*
     basering = Q(a)[t]

*Example:*
     LIB "zeroset.lib";
     ring R = (0,a), x, lp;
     minpoly = a2+1;
     poly f =  x4 - 1;
     poly g = x2 - 2*a*x - 1;
     EGCD(f, g);
     ==> (-4a)*x-4


File: singular.hlp,  Node: Factor,  Next: Quotient,  Prev: EGCD,  Up: zeroset_lib

D.7.5.2 Factor
..............

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     Factor(f); where f is a polynomial

*Purpose:*
     compute the factorization of the squarefree poly f over Q(a)[t]

*Return:*
     list with two entries

       _[1] = factors (monic), first entry is the leading coefficient
       _[2] = multiplicities (not yet implemented)
       
*Assume:*
     basering must be the univariate polynomial ring over a field, which
     is Q or a simple extension of Q given by a minpoly.

*Note:*
     if basering = Q[t] then this is the built-in `factorize'

*Example:*
     LIB "zeroset.lib";
     ring R = (0,a), x, lp;
     minpoly = a2+1;
     poly f =  x4 - 1;
     list fl = Factor(f);
     fl;
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=(40a+60)*x+(40a+60)
     ==>    _[3]=(1/65a-29/130)*x+(-1/65a+29/130)
     ==>    _[4]=(4a)*x+4
     ==>    _[5]=(7/520a+1/130)*x+(1/130a-7/520)
     ==> [2]:
     ==>    _[1]=1
     ==>    _[2]=1
     ==>    _[3]=1
     ==>    _[4]=1
     ==>    _[5]=1
     fl[1][1]*fl[1][2]*fl[1][3]*fl[1][4]*fl[1][5] - f;
     ==> 0


File: singular.hlp,  Node: Quotient,  Next: Remainder,  Prev: Factor,  Up: zeroset_lib

D.7.5.3 Quotient
................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     Quotient(f, g); where f,g are polynomials;

*Purpose:*
     compute the quotient q and remainder r s.t. f = g*q + r, deg(r) <
     deg(g)

*Return:*
     list of polynomials

       _[1] = quotient  q
       _[2] = remainder r
       
*Assume:*
     basering = Q[x] or Q(a)[x]

*Example:*
     LIB "zeroset.lib";
     ring R = (0,a), x, lp;
     minpoly = a2+1;
     poly f =  x4 - 2;
     poly g = x - a;
     list qr = Quotient(f, g);
     qr;
     ==> [1]:
     ==>    x3+(a)*x2-x+(-a)
     ==> [2]:
     ==>    0
     qr[1]*g + qr[2] - f;
     ==> 1


File: singular.hlp,  Node: Remainder,  Next: Roots,  Prev: Quotient,  Up: zeroset_lib

D.7.5.4 Remainder
.................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     Remainder(f, g); where f,g are polynomials

*Purpose:*
     compute the remainder of the division of f by g, i.e. a polynomial
     r s.t. f = g*q + r, deg(r) < deg(g).

*Return:*
     poly

*Assume:*
     basering = Q[x] or Q(a)[x]

*Example:*
     LIB "zeroset.lib";
     ring R = (0,a), x, lp;
     minpoly = a2+1;
     poly f =  x4 - 1;
     poly g = x3 - 1;
     Remainder(f, g);
     ==> x-1


File: singular.hlp,  Node: Roots,  Next: SQFRNorm,  Prev: Remainder,  Up: zeroset_lib

D.7.5.5 Roots
.............

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     Roots(f); where f is a polynomial

*Purpose:*
     compute all roots of f in a finite extension of the ground field
     without multiplicities.

*Return:*
     ring, a polynomial ring over an extension field of the ground
     field, containing a list 'roots' and polynomials 'newA' and 'f':

       - 'roots' is the list of roots of the polynomial f (no multiplicities)
       - if the ground field is Q(a') and the extension field is Q(a), then
         'newA' is the representation of a' in Q(a). 
         If the basering contains a parameter 'a' and the minpoly remains unchanged
         then 'newA' = 'a'.
         If the basering does not contain a parameter then 'newA' = 'a' (default).
       - 'f' is the polynomial f in Q(a) (a' being substituted by 'newA')
       
*Assume:*
     ground field to be Q or a simple extension of Q given by a minpoly

*Example:*
     LIB "zeroset.lib";
     ring R = (0,a), x, lp;
     minpoly = a2+1;
     poly f = x3 - a;
     def R1 = Roots(f);
     ==> 
     ==> // 'Roots' created a new ring which contains the list 'roots' and
     ==> // the polynomials 'f' and 'newA'
     ==> // To access the roots, newA and the new representation of f, type
     ==>    def R = Roots(f); setring R; roots; newA; f;
     ==> 
     setring R1;
     minpoly;
     ==> (a4-a2+1)
     newA;
     ==> (a3)
     f;
     ==> x3+(-a3)
     roots;
     ==> [1]:
     ==>    (-a3)
     ==> [2]:
     ==>    (a3-a)
     ==> [3]:
     ==>    (a)
     map F;
     F[1] = roots[1];
     F(f);
     ==> 0


File: singular.hlp,  Node: SQFRNorm,  Next: ZeroSet,  Prev: Roots,  Up: zeroset_lib

D.7.5.6 SQFRNorm
................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     SQFRNorm(f); where f is a polynomial

*Purpose:*
     compute the norm of the squarefree polynomial f in Q(a)[x].

*Return:*
     list with 3 entries

       _[1] = squarefree norm of g (poly)
       _[2] = g (= f(x - s*a)) (poly)
       _[3] = s (int)
       
*Assume:*
     f must be squarefree, basering = Q(a)[x] and minpoly != 0.

*Note:*
     the norm is an element of Q[x]

*Example:*
     LIB "zeroset.lib";
     ring R = (0,a), x, lp;
     minpoly = a2+1;
     poly f =  x4 - 2*x + 1;
     SQFRNorm(f);
     ==> [1]:
     ==>    x8+4*x6-4*x5+8*x4+8*x3-4*x2+8*x+8
     ==> [2]:
     ==>    x4+(-4a)*x3-6*x2+(4a-2)*x+(2a+2)
     ==> [3]:
     ==>    1


File: singular.hlp,  Node: ZeroSet,  Next: EGCDMain,  Prev: SQFRNorm,  Up: zeroset_lib

D.7.5.7 ZeroSet
...............

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     ZeroSet(I [,opt] ); I=ideal, opt=integer

*Purpose:*
     compute the zero-set of the zero-dim. ideal I, in a finite
     extension of the ground field.

*Return:*
     ring, a polynomial ring over an extension field of the ground
     field, containing a list 'zeroset', a polynomial 'newA', and an
     ideal 'id':

       - 'zeroset' is the list of the zeros of the ideal I, each zero is an ideal.
       - if the ground field is Q(a') and the extension field is Q(a), then
         'newA' is the representation of a' in Q(a).
         If the basering contains a parameter 'a' and the minpoly remains unchanged
         then 'newA' = 'a'.
         If the basering does not contain a parameter then 'newA' = 'a' (default).    
       - 'id' is the ideal I in Q(a)[x_1,...] (a' substituted by 'newA')
       
*Assume:*
     dim(I) = 0, and ground field to be Q or a simple extension of Q
     given by a minpoly.

*Options:*
     opt = 0 no primary decomposition (default)
     opt > 0 primary decomposition

*Note:*
     If I contains an algebraic number (parameter) then 'I' must be
     transformed w.r.t. 'newA' in the new ring.

*Example:*
     LIB "zeroset.lib";
     ring R = (0,a), (x,y,z), lp;
     minpoly = a2 + 1;
     ideal I = x2 - 1/2, a*z - 1, y - 2;
     def T = ZeroSet(I);
     ==> 1
     setring T;
     minpoly;
     ==> (4a4+4a2+9)
     newA;
     ==> (1/3a3+5/6a)
     id;
     ==> id[1]=(1/3a3+5/6a)*z-1
     ==> id[2]=y-2
     ==> id[3]=2*x2-1
     zeroset;
     ==> [1]:
     ==>    _[1]=(1/3a3-1/6a)
     ==>    _[2]=2
     ==>    _[3]=(-1/3a3-5/6a)
     ==> [2]:
     ==>    _[1]=(-1/3a3+1/6a)
     ==>    _[2]=2
     ==>    _[3]=(-1/3a3-5/6a)
     map F1 = basering, zeroset[1];
     map F2 = basering, zeroset[2];
     F1(id);
     ==> _[1]=0
     ==> _[2]=0
     ==> _[3]=0
     F2(id);
     ==> _[1]=0
     ==> _[2]=0
     ==> _[3]=0


File: singular.hlp,  Node: EGCDMain,  Next: FactorMain,  Prev: ZeroSet,  Up: zeroset_lib

D.7.5.8 EGCDMain
................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Purpose:*
     compute the polynomial gcd of f and g over Q(a)[x]

*Return:*
     poly

*Assume:*
     basering = Q[x,a] and ideal mpoly is defined (it might be 0), this
     represents the ring Q(a)[x] together with its minimal polynomial.


File: singular.hlp,  Node: FactorMain,  Next: InvertNumberMain,  Prev: EGCDMain,  Up: zeroset_lib

D.7.5.9 FactorMain
..................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Purpose:*
     compute the factorization of the squarefree poly f over Q(a)[t],
     minpoly = p(a).

*Return:*
     list with 2 entries

       _[1] = factors, first is a constant
       _[2] = multiplicities (not yet implemented)
       
*Assume:*
     basering = Q[x,a], representing Q(a)[x]. An ideal mpoly must be
     defined, representing the minimal polynomial (it might be 0!).


File: singular.hlp,  Node: InvertNumberMain,  Next: QuotientMain,  Prev: FactorMain,  Up: zeroset_lib

D.7.5.10 InvertNumberMain
.........................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     InvertNumberMain(f); where f is a polynomial

*Purpose:*
     compute 1/f if f is a number in Q(a) i.e., f is represented by a
     polynomial in Q[a].

*Return:*
     poly 1/f

*Assume:*
     basering = Q[x_1,...,x_n,a], ideal mpoly must be defined and != 0 !


File: singular.hlp,  Node: QuotientMain,  Next: RemainderMain,  Prev: InvertNumberMain,  Up: zeroset_lib

D.7.5.11 QuotientMain
.....................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     QuotientMain(f, g); where f,g are polynomials

*Purpose:*
     compute the quotient q and remainder r s.t. f = g*q + r, deg(r) <
     deg(g)

*Return:*
     list of polynomials

       _[1] = quotient  q
       _[2] = remainder r
       
*Assume:*
     basering = Q[x,a] and ideal mpoly is defined (it might be 0), this
     represents the ring Q(a)[x] together with its minimal polynomial.


File: singular.hlp,  Node: RemainderMain,  Next: RootsMain,  Prev: QuotientMain,  Up: zeroset_lib

D.7.5.12 RemainderMain
......................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     RemainderMain(f, g); where f,g are polynomials

*Purpose:*
     compute the remainder r s.t. f = g*q + r, deg(r) < deg(g)

*Return:*
     poly

*Assume:*
     basering = Q[x,a] and ideal mpoly is defined (it might be 0), this
     represents the ring Q(a)[x] together with its minimal polynomial.


File: singular.hlp,  Node: RootsMain,  Next: SQFRNormMain,  Prev: RemainderMain,  Up: zeroset_lib

D.7.5.13 RootsMain
..................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     RootsMain(f); where f is a polynomial

*Purpose:*
     compute all roots of f in a finite extension of the ground field
     without multiplicities.

*Return:*
     list, all entries are polynomials

       _[1] = roots of f, each entry is a polynomial
       _[2] = 'newA' - if the ground field is Q(a') and the extension field
              is Q(a), then 'newA' is the representation of a' in Q(a)
       _[3] = minpoly of the algebraic extension of the ground field
       
*Assume:*
     basering = Q[x,a] ideal mpoly must be defined, it might be 0!

*Note:*
     might change the ideal mpoly !!


File: singular.hlp,  Node: SQFRNormMain,  Next: ContainedQ,  Prev: RootsMain,  Up: zeroset_lib

D.7.5.14 SQFRNormMain
.....................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     SQFRNorm(f); where f is a polynomial

*Purpose:*
     compute the norm of the squarefree polynomial f in Q(a)[x].

*Return:*
     list with 3 entries

       _[1] = squarefree norm of g (poly)
       _[2] = g (= f(x - s*a)) (poly)
       _[3] = s (int)
       
*Assume:*
     f must be squarefree, basering = Q[x,a] and ideal mpoly is equal to
     'minpoly',this represents the ring Q(a)[x] together with 'minpoly'.

*Note:*
     the norm is an element of Q[x]


File: singular.hlp,  Node: ContainedQ,  Next: SameQ,  Prev: SQFRNormMain,  Up: zeroset_lib

D.7.5.15 ContainedQ
...................

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     ContainedQ(data, f [, opt]); data=list; f=any type, opt=integer

*Purpose:*
     test if f is an element of data.

*Return:*
     int
     0 if f not contained in data
     1 if f contained in data

*Options:*
     opt = 0 : use '==' for comparing f with elements from data
     opt = 1 : use `SameQ' for comparing f with elements from data


File: singular.hlp,  Node: SameQ,  Prev: ContainedQ,  Up: zeroset_lib

D.7.5.16 SameQ
..............

Procedure from library `zeroset.lib' (*note zeroset_lib::).

*Usage:*
     SameQ(a, b); a,b=list/intvec

*Purpose:*
     test a == b elementwise, i.e., a[i] = b[i].

*Return:*
     int
     0 if a != b
     1 if a == b


File: singular.hlp,  Node: Visualization,  Next: Coding theory,  Prev: Symbolic-numerical solving,  Up: SINGULAR libraries

D.8 Visualization
=================

* Menu:

* graphics_lib:: procedures to draw  with Mathematica
* latex_lib:: procedures for typesetting in TeX
* paramet_lib:: procedures for parametrizations
* surf_lib:: interface to the surf program


File: singular.hlp,  Node: graphics_lib,  Next: latex_lib,  Prev: Visualization,  Up: Visualization

D.8.1 graphics_lib
------------------

*Library:*
     graphics.lib

*Purpose:*
     Procedures to use Graphics with Mathematica

*Author:*
     Christian Gorzel, gorzelc@math.uni-muenster.de

*Procedures:*

* Menu:

* staircase:: Mathematica text for displaying staircase of I
* mathinit:: string for loading Mathematica's ImplicitPlot
* mplot:: Mathematica text for various plots


File: singular.hlp,  Node: staircase,  Next: mathinit,  Up: graphics_lib

D.8.1.1 staircase
.................

Procedure from library `graphics.lib' (*note graphics_lib::).

*Usage:*
     staircase(s,I); s a string, I ideal in two variables

*Return:*
     string with Mathematica input for displaying staircase diagrams of
     an ideal I, i.e. exponent vectors of the initial ideal of I

*Note:*
     ideal I should be given by a standard basis. Let s="" and copy and
     paste the result into a Mathematica notebook.

*Example:*
     LIB "graphics.lib";
     ring r0 = 0,(x,y),ls;
     ideal I = -1x2y6-1x4y2, 7x6y5+1/2x7y4+6x4y6;
     staircase("",std(I));
     ring r1 = 0,(x,y),dp;
     ideal I = fetch(r0,I);
     staircase("",std(I));
     ring r2 = 0,(x,y),wp(2,3);
     ideal I = fetch(r0,I);
     staircase("",std(I));
     // Paste the output into a Mathematica notebook
     // active evalutation of the cell with SHIFT RETURN


File: singular.hlp,  Node: mathinit,  Next: mplot,  Prev: staircase,  Up: graphics_lib

D.8.1.2 mathinit
................

Procedure from library `graphics.lib' (*note graphics_lib::).

*Usage:*
     mathinit();

*Return:*
     initializing string for loading Mathematica's ImplicitPlot

*Example:*
     LIB "graphics.lib";
     mathinit();
     // Paste the output into a Mathematica notebook
     // active evalutation of the cell with SHIFT RETURN


File: singular.hlp,  Node: mplot,  Prev: mathinit,  Up: graphics_lib

D.8.1.3 mplot
.............

Procedure from library `graphics.lib' (*note graphics_lib::).

*Usage:*
     mplot(fname, I [,I1,I2,..,s] ); fname=string; I,I1,I2,..=ideals,
     s=string representing the plot region.
     Use the ideals I1,I2,.. in order to produce multiple plots (they
     need to have the same number of entries as I!).

*Return:*
     string, text with Mathematica commands to display a plot

*Note:*
     The plotregion is defaulted to -1,1 around zero.
     For implicit given curves enter first the string returned by proc
     mathinit into Mathematica in order to load ImplicitPlot.  The
     following conventions for I are used:

       - ideal with 2 entries in one variable means a parametrised plane curve,
       - ideal with 3 entries in one variable means a parametrised space curve,
       - ideal with 3 entries in two variables means a parametrised surface,
       - ideal with 2 entries in two variables means an implicit curve
         given as I[1]==I[2],
       - ideal with 1 entry (or one polynomial) in two variables means
         an implicit curve given as  f == 0,
       
*Example:*
     LIB "graphics.lib";
     // ---------  plane curves ------------
     ring rr0 = 0,x,dp; export rr0;
     ideal I = x3 + x, x2;
     ideal J = x2, -x+x3;
     mplot("",I,J,"-2,2");
     // Paste the output into a Mathematica notebook
     // active evalutation of the cell with SHIFT RETURN
     // --------- space curves --------------
     I = x3,-1/10x3+x2,x2;
     mplot("",I);
     // Paste the output into a Mathematica notebook
     // active evalutation of the cell with SHIFT RETURN
     // ----------- surfaces -------------------
     ring rr1 = 0,(x,y),dp; export rr1;
     ideal J = xy,y,x2;
     mplot("",J,"-2,1","1,2");
     // Paste the output into a Mathematica notebook
     // active evalutation of the cell with SHIFT RETURN
     kill rr0,rr1;


File: singular.hlp,  Node: latex_lib,  Next: paramet_lib,  Prev: graphics_lib,  Up: Visualization

D.8.2 latex_lib
---------------

*Library:*
     latex.lib

*Purpose:*
     Typesetting of Singular-Objects in LaTeX2e

*Author:*
     Christian Gorzel, gorzelc@math.uni-muenster.de

*Procedures:*

* Menu:

* closetex:: writes closing line for LaTeX-document
* opentex:: writes header for LaTeX-file fnm
* tex:: calls LaTeX2e for LaTeX-file fnm
* texdemo:: produces a file explaining the features of this lib
* texfactorize:: creates string in LaTeX-format for factors of poly f
* texmap:: creates string in LaTeX-format for map m:r1->r2
* texname:: creates string in LaTeX-format for identifier
* texobj:: creates string in LaTeX-format for any (basic) type
* texpoly:: creates string in LaTeX-format for poly
* texproc:: creates string in LaTeX-format of text from proc p
* texring:: creates string in LaTeX-format for ring/qring
* rmx:: removes .aux and .log files of LaTeX-files
* xdvi:: calls xdvi for dvi-files

*Global variables:*
     TeXwidth, TeXnofrac, TeXbrack, TeXproj, TeXaligned, TeXreplace,
     NoDollars are used to control the typesetting.  Call `texdemo();'
     to obtain a LaTeX2e file `texlibdemo.tex' explaining the features
     of `latex.lib' and its global variables.

       `TeXwidth' (int) -1, 0, 1..9, >9:  controls breaking of long polynomials
       `TeXnofrac' (int) flag:  write 1/2 instead of \frac{1}{2}
       `TeXbrack' (string) "{", "(", "<", "|", empty string: 
                                        controls brackets around ideals and matrices
       `TeXproj' (int) flag:  write ":" instead of "," in vectors
       `TeXaligned' (int) flag:  write maps (and ideals) aligned
       `TeXreplace' (list) list entries = 2 strings:  replacing symbols
       `NoDollars' (int) flag:  suppresses surrounding $ signs


File: singular.hlp,  Node: closetex,  Next: opentex,  Up: latex_lib

D.8.2.1 closetex
................

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     closetex(fname); fname string

*Return:*
     nothing; writes a LaTeX2e closing line into file `<fname>'.

*Note:*
     preceding ">>" are deleted and suffix ".tex" (if not given) is
     added to `fname'.

*Example:*
     LIB "latex.lib";
     opentex("exmpl");
     texobj("exmpl","{\\large \\bf hello}");
     closetex("exmpl");


File: singular.hlp,  Node: opentex,  Next: tex,  Prev: closetex,  Up: latex_lib

D.8.2.2 opentex
...............

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     opentex(fname); fname string

*Return:*
     nothing; writes a LaTeX2e header into a new file `<fname>'.

*Note:*
     preceding ">>" are deleted and suffix ".tex" (if not given) is
     added to `fname'.

*Example:*
     LIB "latex.lib";
     opentex("exmpl");
     texobj("exmpl","hello");
     closetex("exmpl");


File: singular.hlp,  Node: tex,  Next: texdemo,  Prev: opentex,  Up: latex_lib

D.8.2.3 tex
...........

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     tex(fname); fname string

*Return:*
     nothing; calls latex (LaTeX2e) for compiling the file fname

*Note:*
     preceding ">>" are deleted and suffix ".tex" (if not given) is
     added to `fname'.

*Example:*
     LIB "latex.lib";
     ring r;
     ideal I = maxideal(7);
     opentex("exp001");              // open latex2e document
     texobj("exp001","An ideal ",I);
     closetex("exp001");
     tex("exp001"); 
     ==> calling  latex2e  for : exp001.tex 
     ==> 
     ==> This is TeX, Version 3.14159 (Web2C 7.3.1)
     ==> (exp001.tex
     ==> LaTeX2e <1998/12/01> patch level 1
     ==> Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
        man, i
     ==> talian, nohyphenation, loaded.
     ==> (/usr/share/texmf/tex/latex/base/article.cls
     ==> Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
     ==> (/usr/share/texmf/tex/latex/base/size10.clo))
     ==> (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
     ==> (/usr/share/texmf/tex/latex/amslatex/amstext.sty
     ==> (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
     ==> (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
     ==> (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
     ==> (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
     ==> (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
     ==> No file exp001.aux.
     ==> (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
     ==> (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
     ==> Output written on exp001.dvi (1 page, 2912 bytes).
     ==> Transcript written on exp001.log.
     system("sh","rm exp001.*");
     ==> 0


File: singular.hlp,  Node: texdemo,  Next: texfactorize,  Prev: tex,  Up: latex_lib

D.8.2.4 texdemo
...............

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     texdemo();

*Return:*
     nothing; generates a LaTeX2e file called `texlibdemo.tex'
     explaining the features of `latex.lib' and its global variables.

*Note:*
     this proc may take some time.


File: singular.hlp,  Node: texfactorize,  Next: texmap,  Prev: texdemo,  Up: latex_lib

D.8.2.5 texfactorize
....................

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     texfactorize(fname,f); fname string, f poly

*Return:*
     if `fname=""': string, f as a product of its irreducible factors
     otherwise: append this string to the file `<fname>', and return
     nothing.

*Note:*
     preceding ">>" are deleted and suffix ".tex" (if not given) is
     added to `fname'.

*Example:*
     LIB "latex.lib";
     ring r2 = 13,(x,y),dp;
     poly f = (x+1+y)^2*x3y*(2x-2y)*y12;
     texfactorize("",f);
     ==> $-2\cdot x^{3}\cdot y^{13}\cdot (-x+y)\cdot (x+y+1)^{2}$
     ring R49 = (7,a),x,dp;
     minpoly = a2+a+3;
     poly f = (a24x5+x3)*a2x6*(x+1)^2;
     f;
     ==> (a+3)*x13+(2a-1)*x12+(-2a+1)*x10+(-a-3)*x9
     texfactorize("",f);
     ==> $(a+3)\cdot (x-1)\cdot (x+1)^{3}\cdot x^{9}$


File: singular.hlp,  Node: texmap,  Next: texname,  Prev: texfactorize,  Up: latex_lib

D.8.2.6 texmap
..............

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     texmap(fname,m,@r1,@r2); fname string, m string/map, @r1,@r2 rings

*Return:*
     if `fname=""': string, the map m from @r1 to @r2 (preceded by its
     name if m = string) in TeX-typesetting;
     otherwise: append this string to the file `<fname>', and return
     nothing.

*Note:*
     preceding ">>" are deleted in `fname', and suffix ".tex" (if not
     given) is added to `fname'.  If m is a string then it has to be the
     name of an existing map from @r1 to @r2.

*Example:*
     LIB "latex.lib";
     // -------- prepare for example ---------
     if (defined(TeXaligned)) {int Teali=TeXaligned; kill TeXaligned;}
     if (defined(TeXreplace)) {list Terep=TeXreplace; kill TeXreplace;}
     // -------- the example starts here ---------
     //
     string fname = "tldemo";
     ring @r1=0,(x,y,z),dp;
     if(system("with","Namespaces")) { exportto(Current, @r1); }
     else { export @r1; }
     ==> // ** `@r1` is already global
     ring r2=0,(u,v),dp;
     map @phi =(@r1,u2,uv -v,v2); export @phi;
     ==> // ** `@phi` is already global
     list TeXreplace;
     TeXreplace[1] = list("@phi","\\phi");    // @phi --> \phi
     export TeXreplace;
     ==> // ** `TeXreplace` is already global
     texmap("","@phi",@r1,r2);                // standard form
     ==> $$
     ==> \begin{array}{rcc}
     ==> \phi:\Q[x,y,z] & \longrightarrow & \Q[u,v]\\[2mm]
     ==> \left(x,y,z\right) & \longmapsto & 
     ==>  \left(
     ==> \begin{array}{c}
     ==> u^{2}\\
     ==> uv-v\\
     ==> v^{2}
     ==> \end{array}
     ==> \right)
     ==> \end{array}
     ==> $$
     //
     int TeXaligned; export TeXaligned;       // map in one line
     ==> // ** `TeXaligned` is already global
     texmap("",@phi,@r1,r2);
     ==> $\Q[x,y,z]\longrightarrow\Q[u,v], \ \left(x,y,z\right)\longmapsto \left(u\
        ^{2},uv-v,v^{2}\right)$
     //
     kill @r1,TeXreplace,TeXaligned;
     //
     // --- restore global variables if previously defined ---
     if (defined(Teali)) {int TeXaligned=Teali; export TeXaligned; kill Teali;}
     if (defined(Terep)) {list TeXreplace=Terep; export TeXreplace; kill Terep;}


File: singular.hlp,  Node: texname,  Next: texobj,  Prev: texmap,  Up: latex_lib

D.8.2.7 texname
...............

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     texname(fname,s); fname,s strings

*Return:*
     if `fname=""': string, the transformed string s, where the
     following rules apply:

                s' + "~"             -->  "\\tilde{"+ s' +"}"
               "_" + int             -->       "_{" + int +"}" 
            "[" + s' + "]"           -->      "_{" + s' + "}"
             "A..Z" + int            --> "A..Z" + "^{" + int + "}"    
             "a..z" + int            --> "a..z" + "_{" + int + "}"
          "(" + int + "," + s' + ")" --> "_{"+ int +"}" + "^{" + s'+"}"

     Anyhow, strings which begin with a `"{"' are only changed by
     deleting the first and last character (intended to remove the
     surrounding curly brackets).

     if `fname!=""': append the transformed string s to the file
     `<fname>', and return nothing.

*Note:*
     preceding ">>" are deleted in `fname', and suffix ".tex" (if not
     given) is added to `fname'.

*Example:*
     LIB "latex.lib";
     ring r = 0,(x,y),lp;
     poly f = 3xy4 + 2xy2 + x5y3 + x + y6;
     texname("","{f(10)}");
     ==> f(10)
     texname("","f(10) =");
     ==> f_{10} =
     texname("","n1");
     ==> n_{1}
     texname("","T1_12");
     ==> T^{1}_{12}
     texname("","g'_11");
     ==> g'_{11}
     texname("","f23");
     ==> f_{23}
     texname("","M[2,3]");
     ==> M_{2,3}
     texname("","A(0,3);");
     ==> A_{0}^{3};
     texname("","E~(3)");
     ==> \tilde{E}_{3}


File: singular.hlp,  Node: texobj,  Next: texpoly,  Prev: texname,  Up: latex_lib

D.8.2.8 texobj
..............

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     texobj(fname,l); fname string, l list

*Return:*
     if `fname=""': string, the entries of l in LaTeX-typesetting;
     otherwise: append this string to the file `<fname>', and return
     nothing.

*Note:*
     preceding ">>" are deleted in `fname', and suffix ".tex" (if not
     given) is added to `fname'.

*Example:*
     LIB "latex.lib";
     // -------- prepare for example ---------
     if (defined(TeXaligned)) {int Teali=TeXaligned; kill TeXaligned;}
     if (defined(TeXbrack)){string Tebra=TeXbrack; kill TeXbrack;}
     //
     //  --------------  typesetting for polynomials ----------
     ring r = 0,(x,y),lp;
     poly f = x5y3 + 3xy4 + 2xy2 + y6;
     f;
     ==> x5y3+3xy4+2xy2+y6
     texobj("",f);
     ==> $$\begin{array}{rl}
     ==> & x^{5}y^{3}+3xy^{4}+2xy^{2}+y^{6}\\
     ==> \end{array}
     ==> $$
     ==> 
     //  --------------  typesetting for ideals ----------
     ideal G = jacob(f);
     G;
     ==> G[1]=5x4y3+3y4+2y2
     ==> G[2]=3x5y2+12xy3+4xy+6y5
     texobj("",G);
     ==> $$\left(
     ==> \begin{array}{c}
     ==> 5x^{4}y^{3}+3y^{4}+2y^{2}, \\
     ==> 3x^{5}y^{2}+12xy^{3}+4xy+6y^{5}
     ==> \end{array}
     ==> \right)$$
     ==> 
     //  --------------  variation of typesetting for ideals ----------
     int TeXaligned = 1; export TeXaligned;
     ==> // ** `TeXaligned` is already global
     string TeXbrack = "<"; export TeXbrack;
     ==> // ** `TeXbrack` is already global
     texobj("",G);
     ==> $\left<5x^{4}y^{3}+3y^{4}+2y^{2},3x^{5}y^{2}+12xy^{3}+4xy+6y^{5}\right>$
     ==> 
     kill TeXaligned, TeXbrack;
     //  --------------  typesetting for matrices ----------
     matrix J = jacob(G);
     texobj("",J);
     ==> $$\left(
     ==> \begin{array}{*{2}{c}}
     ==> 20x^{3}y^{3} & 15x^{4}y^{2}+12y^{3}+4y \\
     ==> 15x^{4}y^{2}+12y^{3}+4y & 6x^{5}y+36xy^{2}+4x+30y^{4}
     ==> \end{array}
     ==> \right)
     ==> $$
     ==> 
     //  --------------  typesetting for intmats ----------
     intmat m[3][4] = 9,2,4,5,2,5,-2,4,-6,10,-1,2,7;
     texobj("",m);
     ==> $$\left(
     ==> \begin{array}{*{4}{r}}
     ==> 9 & 2 & 4 & 5\\
     ==> 2 & 5 & -2 & 4\\
     ==> -6 & 10 & -1 & 2
     ==> \end{array}
     ==> \right)
     ==> $$
     ==> 
     //
     // --- restore global variables if previously defined ---
     if (defined(Teali)){int TeXaligned=Teali; export TeXaligned; kill Teali;}
     if (defined(Tebra)){string TeXbrack=Tebra; export TeXbrack; kill Tebra;}


File: singular.hlp,  Node: texpoly,  Next: texproc,  Prev: texobj,  Up: latex_lib

D.8.2.9 texpoly
...............

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     texpoly(fname,p); fname string, p poly

*Return:*
     if `fname=""': string, the poly p in LaTeX-typesetting;
     otherwise: append this string to the file `<fname>', and return
     nothing.

*Note:*
     preceding ">>" are deleted in `fname', and suffix ".tex" (if not
     given) is added to `fname'.

*Example:*
     LIB "latex.lib";
     ring r0=0,(x,y,z),dp;
     poly f = -1x^2 + 2;
     texpoly("",f);
     ==> $-x^{2}+2$
     ring rr= real,(x,y,z),dp;
     texpoly("",2x2y23z);
     ==> $2.000x^{2}y^{23}z$
     ring r7= 7,(x,y,z),dp;
     poly f = 2x2y23z;
     texpoly("",f);
     ==> $2x^{2}y^{23}z$
     ring rab =(0,a,b),(x,y,z),dp;
     poly f = (-2a2 +b3 -2)/a * x2y4z5 + (a2+1)*x + a+1;
     f;
     ==> (-2a2+b3-2)/(a)*x2y4z5+(a2+1)*x+(a+1)
     texpoly("",f);
     ==> $-\frac{2a^{2}-b^{3}+2}{a}x^{2}y^{4}z^{5}+(a^{2}+1)x+(a+1)$


File: singular.hlp,  Node: texproc,  Next: texring,  Prev: texpoly,  Up: latex_lib

D.8.2.10 texproc
................

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     texproc(fname,pname); fname,pname strings

*Assume:*
     ``pname`' is a procedure.

*Return:*
     if `fname=""': string, the proc ``pname`' in a verbatim environment
     in LaTeX-typesetting;
     otherwise: append this string to the file `<fname>', and return
     nothing.

*Note:*
     preceding ">>" are deleted in `fname', and suffix ".tex" (if not
     given) is added to `fname'.
     `texproc' cannot be applied to itself correctly.

*Example:*
     LIB "latex.lib";
     proc exp(int i,int j,list #)
     { string s;
     if (size(#))
     {
     for(i;i<=j;i++)
     { s = s + string(j) + string(#); }
     }
     return(s);
     }
     export exp;
     ==> // ** `exp` is already global
     texproc("","exp");
     ==> \begin{verbatim}
     ==> proc exp(int i,int j,list #)
     ==> { 
     ==>  string s;
     ==> if (size(#))
     ==> {
     ==> for(i;i<=j;i++)
     ==> { s = s + string(j) + string(#); }
     ==> }
     ==> return(s);
     ==> 
     ==> }
     ==> \end{verbatim}
     ==> 
     kill exp;


File: singular.hlp,  Node: texring,  Next: rmx,  Prev: texproc,  Up: latex_lib

D.8.2.11 texring
................

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     texring(fname, r[,L]); fname string, r ring, L list

*Return:*
     if `fname=""': string, the ring in TeX-typesetting;
     otherwise: append this string to the file `<fname>' and return
     nothing.

*Note:*
     preceding ">>" are deleted and suffix ".tex" (if not given) is
     added to `fname'.
     The optional list L is assumed to be a list of strings which
     control, e.g., the symbol for the field of coefficients.
     For more details call `texdemo();' (generates a LaTeX2e file called
     `texlibdemo.tex' which explains all features of `texring').

*Example:*
     LIB "latex.lib";
     ring r0 = 0,(x,y),dp;                // char = 0, polynomial ordering
     texring("",r0);
     ==> $\Q[x,y]$
     //
     ring r7 =7,(x(0..2)),ds;             // char = 7, local ordering
     texring("",r7);
     ==> $\Z_{7}[[x_{0},x_{1},x_{2}]]$
     //
     ring r1 = 0,(x1,x2,y1,y2),wp(1,2,3,4);
     texring("",r1);
     ==> $\Q[x_{1},x_{2},y_{1},y_{2}]$
     //
     ring rr = real,(x),dp;               // real numbers
     texring("",rr);
     ==> $\R[x]$
     //
     ring rabc =(0,t1,t2,t3),(x,y),dp;    // ring with parameters
     texring("",rabc);
     ==> $\Q(t_{1},t_{2},t_{3})[x,y]$
     //
     ring ralg = (7,a),(x1,x2),ds;        // algebraic extension
     minpoly = a2-a+3;
     texring("",ralg);
     ==> $\Z_{7}(a)[[x_{1},x_{2}]]$
     texring("",ralg,"mipo");
     ==> $\Z_{7}(a)/(a^{2}-a+3)[[x_{1},x_{2}]]$
     //
     ring r49=(49,a),x,dp;                // Galois field  
     texring("",r49);
     ==> $\F_{49}[x]$
     //
     setring r0;                          // quotient ring
     ideal i = x2-y3;
     qring q = std(i);
     texring("",q);
     ==> $\Q[x,y]/\left(y^{3}-x^{2}\right)
     ==> $
     //
     // ------------------ additional features -------------------
     ring r9 =0,(x(0..9)),ds;
     texring("",r9,1);
     ==> $\Q[[x_{0},\ldots,x_{9}]]$
     texring("",r9,"C","{","^G");
     ==> $\C\{x_{0},x_{1},x_{2},x_{3},x_{4},x_{5},x_{6},x_{7},x_{8},x_{9}\}^G$
     //
     ring rxy = 0,(x(1..5),y(1..6)),ds;
     intvec v = 5,6;
     texring("",rxy,v);
     ==> $\Q[[x_{1},\ldots,x_{5},y_{1},\ldots,y_{6}]]$


File: singular.hlp,  Node: rmx,  Next: xdvi,  Prev: texring,  Up: latex_lib

D.8.2.12 rmx
............

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     rmx(fname); fname string

*Return:*
     nothing; removes the `.log' and `.aux' files associated to the
     LaTeX file <fname>.

*Note:*
     If `fname' ends by `".dvi"' or `".tex"', the `.dvi' or `.tex' file
     will be deleted, too.

*Example:*
     LIB "latex.lib";
     ring r;
     poly f = x+y+z;
     opentex("exp001");              // defaulted latex2e document
     texobj("exp001","A polynom",f);
     closetex("exp001");
     tex("exp001");
     ==> calling  latex2e  for : exp001.tex 
     ==> 
     ==> This is TeX, Version 3.14159 (Web2C 7.3.1)
     ==> (exp001.tex
     ==> LaTeX2e <1998/12/01> patch level 1
     ==> Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
        man, i
     ==> talian, nohyphenation, loaded.
     ==> (/usr/share/texmf/tex/latex/base/article.cls
     ==> Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
     ==> (/usr/share/texmf/tex/latex/base/size10.clo))
     ==> (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
     ==> (/usr/share/texmf/tex/latex/amslatex/amstext.sty
     ==> (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
     ==> (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
     ==> (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
     ==> (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
     ==> (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
     ==> No file exp001.aux.
     ==> (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
     ==> (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
     ==> Output written on exp001.dvi (1 page, 308 bytes).
     ==> Transcript written on exp001.log.
     rmx("exp001");   // removes aux and log file of exp001
     system("sh","rm exp001.*");
     ==> 0


File: singular.hlp,  Node: xdvi,  Prev: rmx,  Up: latex_lib

D.8.2.13 xdvi
.............

Procedure from library `latex.lib' (*note latex_lib::).

*Usage:*
     xdvi(fname[,style]); fname,style = string

*Return:*
     nothing; displays dvi-file fname.dvi with previewer xdvi

*Note:*
     ending .dvi may miss in fname
     style overwrites the default setting xdvi

*Example:*
     LIB "latex.lib";
     intmat m[3][4] = 9,2,4,5,2,5,-2,4,-6,10,-1,2,7;
     opentex("exp001"); 
     texobj("exp001","An intmat:  ",m);
     closetex("exp001");
     tex("exp001");
     ==> calling  latex2e  for : exp001.tex 
     ==> 
     ==> This is TeX, Version 3.14159 (Web2C 7.3.1)
     ==> (exp001.tex
     ==> LaTeX2e <1998/12/01> patch level 1
     ==> Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
        man, i
     ==> talian, nohyphenation, loaded.
     ==> (/usr/share/texmf/tex/latex/base/article.cls
     ==> Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
     ==> (/usr/share/texmf/tex/latex/base/size10.clo))
     ==> (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
     ==> (/usr/share/texmf/tex/latex/amslatex/amstext.sty
     ==> (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
     ==> (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
     ==> (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
     ==> (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
     ==> (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
     ==> No file exp001.aux.
     ==> (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
     ==> (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
     ==> Output written on exp001.dvi (1 page, 524 bytes).
     ==> Transcript written on exp001.log.
     xdvi("exp001");
     ==> calling  xdvi  for : exp001 
     ==> 
     system("sh","rm exp001.*");
     ==> 0


File: singular.hlp,  Node: paramet_lib,  Next: surf_lib,  Prev: latex_lib,  Up: Visualization

D.8.3 paramet_lib
-----------------

*Library:*
     paramet.lib

*Purpose:*
     Parametrization of Varieties

*Author:*
     Thomas Keilen, keilen@mathematik.uni-kl.de

*Procedures:*

* Menu:

* parametrize:: parametrizes a prime ideal via the normalization
* parametrizepd:: calculates the prim.dec. and parametrizes the components
* parametrizesing:: parametrizes an isolated plane curve singularity

*Overview:*
     A library to compute parametrizations of algebraic varieties (if
     possible) with the aid of a normalization, or a primary
     decomposition, resp. to compute a parametrization of a plane curve
     singularity with the aid of a Hamburger-Noether expansion.

* Menu:

See also:
* hnoether_lib::
* normal_lib::
* primdec_lib::

*See also:* *note hnoether_lib::; *note normal_lib::; *note
primdec_lib::.


File: singular.hlp,  Node: parametrize,  Next: parametrizepd,  Up: paramet_lib

D.8.3.1 parametrize
...................

Procedure from library `paramet.lib' (*note paramet_lib::).

*Usage:*
     parametrize(I); I ideal in an arbitrary number of variables, whose
     radical is prime, in a ring with global ordering

*Create:*
     If the parametrization is successful, the basering will be changed
     to the parametrization ring, that is to the ring PR=0,(s,t),dp;
     respectively PR=0,t(1..d),dp;, depending on the dimension of the
     parametrized variety.

*Return:*
     a list containing the parametrization ideal resp. the original
     ideal, the number of variables needed for the parametrization resp.
     0, and 1 resp. 0 depending on whether the parametrization was
     successful or not

*Example:*
     LIB "paramet.lib";
     ring RING=0,(x,y,z),dp;
     ideal I=z2-y2x2+x3;
     parametrize(I);
     ==> [1]:
     ==>    _[1]=s2-t2
     ==>    _[2]=s
     ==>    _[3]=s2t-t3
     ==> [2]:
     ==>    2
     ==> [3]:
     ==>    1

* Menu:

See also:
* normal::
* parametrizepd::
* primdecGTZ::
* radical::

*See also:* *note normal::; *note parametrizepd::; *note primdecGTZ::;
*note radical::.


File: singular.hlp,  Node: parametrizepd,  Next: parametrizesing,  Prev: parametrize,  Up: paramet_lib

D.8.3.2 parametrizepd
.....................

Procedure from library `paramet.lib' (*note paramet_lib::).

*Usage:*
     parametrizepd(I); I ideal in a polynomial ring with global ordering

*Create:*
     If the parametrization is successful, the basering will be changed
     to the parametrization ring, that is to the ring PR=0,(s,t),dp;
     respectively PR=0,t(1..d),dp;, depending on the dimension of the
     parametrized variety.

*Return:*
     a list of lists, where each entry contains the parametrization of a
     primary component of I resp. 0, the number of variables resp. 0,
     and 1 resp. 0 depending on whether the parametrization of the
     component was successful or not

*Example:*
     LIB "paramet.lib";
     ring RING=0,(x,y,z),dp;
     ideal I=(x2-y2z2+z3)*(x2-z2-z3),(x2-y2z2+z3)*yz;
     parametrizepd(I);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=s2t-t3
     ==>       _[2]=s
     ==>       _[3]=s2-t2
     ==>    [2]:
     ==>       2
     ==>    [3]:
     ==>       1
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=0
     ==>       _[2]=s
     ==>       _[3]=0
     ==>    [2]:
     ==>       1
     ==>    [3]:
     ==>       1
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=s3-s
     ==>       _[2]=0
     ==>       _[3]=s2-1
     ==>    [2]:
     ==>       1
     ==>    [3]:
     ==>       1

* Menu:

See also:
* normal::
* parametrize::
* primdecGTZ::

*See also:* *note normal::; *note parametrize::; *note primdecGTZ::.


File: singular.hlp,  Node: parametrizesing,  Prev: parametrizepd,  Up: paramet_lib

D.8.3.3 parametrizesing
.......................

Procedure from library `paramet.lib' (*note paramet_lib::).

*Usage:*
     parametrizesing(f); f a polynomial in two variables, ordering ls or
     ds

*Create:*
     If the parametrization is successful, the basering will be changed
     to the parametrization ring, that is to the ring 0,(x,y),ls;

*Return:*
     a list containing the parametrizations of the different branches of
     the singularity at the origin resp. 0, if f was not of the desired
     kind

*Example:*
     LIB "paramet.lib";
     ring RING=0,(x,y),ls;
     poly f=(x^2-y^3)*(x^2-y^2-y^3);
     parametrizesing(f);
     ==> [1]:
     ==>    _[1]=x
     ==>    _[2]=x-1/2x2
     ==> [2]:
     ==>    _[1]=x
     ==>    _[2]=-x-1/2x2
     ==> [3]:
     ==>    _[1]=x3
     ==>    _[2]=x2

* Menu:

See also:
* develop::
* hnexpansion::
* hnoether_lib::

*See also:* *note develop::; *note hnexpansion::; *note hnoether_lib::.


File: singular.hlp,  Node: surf_lib,  Prev: paramet_lib,  Up: Visualization

D.8.4 surf_lib
--------------

*Library:*
     surf.lib

*Purpose:*
     Procedures for Graphics with Surf

*Author:*
     Hans Schoenemann,
     the program surf is written by Stefan Endrass

*Note:*
     To use this library requires the program `surf' to be installed.
     `surf' is only available for Linux PCs and Sun workstations.   You
     can download `surf' either from
     `http://sourceforge.net/projects/surf'   or from
     `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils/'.

*Procedures:*

* Menu:

* plot:: plots plane curves and surfaces


File: singular.hlp,  Node: plot,  Up: surf_lib

D.8.4.1 plot
............

Procedure from library `surf.lib' (*note surf_lib::).

*Usage:*
     plot(I); I ideal or poly

*Assume:*
     I defines a plane curve or a surface given by one equation

*Return:*
     nothing

*Note:*
     requires the external program 'surf' to be installed

*Example:*
     LIB "surf.lib";
     // ---------  plane curves ------------
     ring rr0 = 0,(x1,x2),dp;
     ideal I = x1^3 - x2^2;
     plot(I);
     ring rr1 = 0,(x,y,z),dp;
     ideal I(1) = 2x2-1/2x3 +1-y+1;
     plot(I(1));
     //  ---- Singular Logo --------------
     poly logo = ((x+3)^3 + 2*(x+3)^2 - y^2)*(x^3 - y^2)*((x-3)^3-2*(x-3)^2-y^2);
     plot(logo);
     // Steiner surface
     ideal J(2) = x^2*y^2+x^2*z^2+y^2*z^2-17*x*y*z;
     plot(J(2));
     // --------------------
     plot(x*(x2-y2)+z2);
     // E7
     plot(x^3-x*y^3+z^2);
     // Whitney umbrella
     plot(z^2-x^2*y);


File: singular.hlp,  Node: Coding theory,  Prev: Visualization,  Up: SINGULAR libraries

D.9 Coding theory
=================

* Menu:

* brnoeth_lib:: Brill-Noether algorithm, Weierstrass semigroups and AG codes


File: singular.hlp,  Node: brnoeth_lib,  Up: Coding theory

D.9.1 brnoeth_lib
-----------------

*Library:*
     brnoeth.lib

*Purpose:*
     Brill-Noether Algorithm, Weierstrass-SG and AG-codes

*Authors:*
     Jose Ignacio Farran Martin, ignfar@eis.uva.es
     Christoph Lossen, lossen@mathematik.uni-kl.de

*Overview:*
     Implementation of the Brill-Noether algorithm for solving the
     Riemann-Roch problem and applications in Algebraic Geometry codes.
     The computation of Weierstrass semigroups is also implemented.
     The procedures are intended only for plane (singular) curves
     defined over a prime field of positive characteristic.
     For more information about the library see the end of the file
     brnoeth.lib.

*Main procedures:*

* Menu:

* Adj_div:: computes the conductor of a curve
* NSplaces:: computes non-singular places with given degrees
* BrillNoether:: computes a vector space basis of the linear system L(D)
* Weierstrass:: computes the Weierstrass semigroup of C at P up to m
* extcurve:: extends the curve C to an extension of degree d
* AGcode_L:: computes the evaluation AG code with divisors G and D
* AGcode_Omega:: computes the residual AG code with divisors G and D
* prepSV:: preprocessing for the basic decoding algorithm
* decodeSV:: decoding of a word with the basic decoding algorithm

*Auxiliary procedures:*

* Menu:

* closed_points:: computes the zero-set of a zero-dim. ideal in 2 vars
* dual_code:: computes the dual code
* sys_code:: computes an equivalent systematic code
* permute_L:: applies a permutation to a list

* Menu:

See also:
* hnoether_lib::
* triang_lib::

*See also:* *note hnoether_lib::; *note triang_lib::.


File: singular.hlp,  Node: Adj_div,  Next: NSplaces,  Up: brnoeth_lib

D.9.1.1 Adj_div
...............

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     Adj_div( f [,l] ); f a poly, [l a list]

*Return:*
     list L with the computed data:

       L[1] a list of rings: L[1][1]=aff_r (affine), L[1][2]=Proj_R (projective),
       L[2] an intvec with 2 entries (degree, genus),
       L[3] a list of intvec (closed places),
       L[4] an intvec (conductor),
       L[5] a list of lists:
          L[5][d][1] a (local) ring over an extension of degree d,
          L[5][d][2] an intvec (degrees of base points of places of degree d)
       
*Note:*
     `Adj_div(f);' computes and stores the fundamental data of the plane
     curve defined by f as needed for AG codes.
     In the affine ring you can find the following data:

        poly CHI:  affine equation of the curve,
        ideal Aff_SLocus:  affine singular locus (std),
        list Inf_Points:  points at infinity
                 Inf_Points[1]:  singular points
                 Inf_Points[2]:  non-singular points,
        list Aff_SPoints:  affine singular points (if not empty).
        
     In the projective ring you can find the projective equation CHI of
     the curve (poly).
     In the local rings L[5][d][1] you find:

        list POINTS:  base points of the places of degree d,
        list LOC_EQS:  local equations of the curve at the base points,
        list BRANCHES:  Hamburger-Noether developments of the places,
        list PARAMETRIZATIONS:  local parametrizations of the places,
        
     Each entry of the list L[3] corresponds to one closed place (i.e.,
     a place and all its conjugates) which is represented by an intvec
     of size two, the first entry is the degree of the place (in
     particular, it tells the local ring where to find the data
     describing one representative of the closed place), and the second
     one is the position of those data in the lists POINTS, etc., inside
     this local ring.
     In the intvec L[4] (conductor) the i-th entry corresponds to the
     i-th entry in the list of places L[3].

     With no optional arguments, the conductor is computed by local
     invariants of the singularities; otherwise it is computed by the
     Dedekind formula.
     An affine point is represented by a list P where P[1] is std of a
     prime ideal and P[2] is an intvec containing the position of the
     places above P in the list of closed places L[3].
     If the point is at infinity, P[1] is a homogeneous irreducible
     polynomial in two variables.

     If `printlevel>=0' additional comments are displayed (default:
     `printlevel=0').

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list C=Adj_div(y9+y8+xy6+x2y3+y2+x3);
     ==> The genus of the curve is 3
     def aff_R=C[1][1];      // the affine ring
     setring aff_R;
     listvar(aff_R);         // data in the affine ring
     ==> // aff_R                [0]  *ring
     ==> // Inf_Points           [0]  list, size: 2
     ==> // Aff_SPoints          [0]  list, size: 3
     ==> // Aff_SLocus           [0]  ideal (SB), 2 generator(s)
     ==> // CHI                  [0]  poly
     CHI;                    // affine equation of the curve
     ==> x3+x2y3+xy6+y9+y8+y2
     Aff_SLocus;             // ideal of the affine singular locus
     ==> Aff_SLocus[1]=y8+y2
     ==> Aff_SLocus[2]=x2+y6
     Aff_SPoints[1];         // 1st affine singular point: (1:1:1), no.1
     ==> [1]:
     ==>    _[1]=y2+y+1
     ==>    _[2]=x+1
     ==> [2]:
     ==>    1
     Inf_Points[1];          // singular point(s) at infinity: (1:0:0), no.4
     ==> [1]:
     ==>    [1]:
     ==>       y
     ==>    [2]:
     ==>       4
     Inf_Points[2];          // list of non-singular points at infinity
     ==> empty list
     //
     def proj_R=C[1][2];     // the projective ring
     setring proj_R;
     CHI;                    // projective equation of the curve
     ==> x3z6+x2y3z4+xy6z2+y9+y8z+y2z7
     C[2][1];                // degree of the curve
     ==> 9
     C[2][2];                // genus of the curve
     ==> 3
     C[3];                   // list of computed places
     ==> [1]:
     ==>    2,1
     ==> [2]:
     ==>    1,1
     ==> [3]:
     ==>    1,2
     ==> [4]:
     ==>    1,3
     C[4];                   // adjunction divisor (all points are singular!)
     ==> 2,2,2,42
     //
     // we look at the place(s) of degree 2 by changing to the ring
     C[5][2][1];
     ==> //   characteristic : 2
     ==> //   1 parameter    : a 
     ==> //   minpoly        : ...
     ==> //   number of vars : 3
     ==> //        block   1 : ordering ls
     ==> //                  : names    x y t 
     ==> //        block   2 : ordering C
     def S(2)=C[5][2][1];
     setring S(2);
     POINTS;                // base point(s) of place(s) of degree 2: (1:a:1)
     ==> [1]:
     ==>    [1]:
     ==>       1
     ==>    [2]:
     ==>       (a)
     ==>    [3]:
     ==>       1
     LOC_EQS;               // local equation(s)
     ==> [1]:
     ==>    y2+y3+(a+1)*y4+y6+(a+1)*y8+y9+(a)*xy2+(a+1)*xy4+xy6+(a+1)*x2y+(a)*x2y2\
        +x2y3+x3
     PARAMETRIZATIONS;      // parametrization(s) and exactness
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=t2+(a+1)*t3
     ==>       _[2]=t3+(a+1)*t4
     ==>    [2]:
     ==>       3,4
     BRANCHES;              // Hamburger-Noether development
     ==> [1]:
     ==>    [1]:
     ==>       _[1,1]=0
     ==>       _[1,2]=x
     ==>       _[1,3]=0
     ==>       _[2,1]=0
     ==>       _[2,2]=1
     ==>       _[2,3]=(a+1)
     ==>    [2]:
     ==>       1,-4
     ==>    [3]:
     ==>       0
     ==>    [4]:
     ==>       y+(a+1)*xy+(a)*x2y+(a)*x2y2+(a+1)*x3+x3y+x3y3+(a)*x4+(a+1)*x4y2+(a+\
        1)*x4y3+x5+x5y2+(a)*x6+(a+1)*x6y2+x6y4+x6y5+x7y+(a+1)*x8+(a+1)*x8y+x8y4+(\
        a+1)*x8y6+x9+x9y7+(a+1)*x10+x11y6+(a+1)*x12y4+x13y5+x14+x14y+x15y4+x16+(a\
        +1)*x16y2+x17y3+x19y2+(a+1)*x20+x21y+x23
     printlevel=plevel;

* Menu:

See also:
* NSplaces::
* closed_points::

*See also:* *note NSplaces::; *note closed_points::.


File: singular.hlp,  Node: NSplaces,  Next: BrillNoether,  Prev: Adj_div,  Up: brnoeth_lib

D.9.1.2 NSplaces
................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     NSplaces( h, CURVE ), where h is an intvec and CURVE is a list

*Return:*
     list L with updated data of CURVE after computing all non-singular
     affine closed places whose degrees are in the intvec h:

        in L[1][1]: (affine ring) lists Aff_Points(d) with affine non-singular
                    (closed) points of degree d (if non-empty),
        in L[3]:    the newly computed closed places are added,
        in L[5]:    local rings created/updated to store (repres. of) new places.
        
     See *note Adj_div:: for a description of the entries in L.

*Note:*
     The list_expression should be the output of the procedure Adj_div.
     If `printlevel>=0' additional comments are displayed (default:
     `printlevel=0').

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list C=Adj_div(x3y+y3+x);
     ==> The genus of the curve is 3
     // The list of computed places:
     C[3];
     ==> [1]:
     ==>    1,1
     ==> [2]:
     ==>    1,2
     // create places up to degree 4
     list L=NSplaces(1..4,C);
     // The list of computed places is now:
     L[3];
     ==> [1]:
     ==>    1,1
     ==> [2]:
     ==>    1,2
     ==> [3]:
     ==>    1,3
     ==> [4]:
     ==>    2,1
     ==> [5]:
     ==>    3,1
     ==> [6]:
     ==>    3,2
     ==> [7]:
     ==>    3,3
     ==> [8]:
     ==>    3,4
     ==> [9]:
     ==>    3,5
     ==> [10]:
     ==>    3,6
     ==> [11]:
     ==>    3,7
     ==> [12]:
     ==>    4,1
     ==> [13]:
     ==>    4,2
     ==> [14]:
     ==>    4,3
     // e.g., affine non-singular points of degree 4 :
     def aff_r=L[1][1];
     setring aff_r;
     Aff_Points(4);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=y2+y+1
     ==>       _[2]=x2+xy+x+1
     ==>    [2]:
     ==>       12
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=y4+y3+y2+y+1
     ==>       _[2]=x+y2+y+1
     ==>    [2]:
     ==>       13
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=y4+y3+1
     ==>       _[2]=x+y3+y
     ==>    [2]:
     ==>       14
     // e.g., base point of the 1st place of degree 4 :
     def S(4)=L[5][4][1];
     setring S(4);
     POINTS[1];
     ==> [1]:
     ==>    (a3)
     ==> [2]:
     ==>    (a2+a)
     ==> [3]:
     ==>    1
     printlevel=plevel;

* Menu:

See also:
* Adj_div::
* closed_points::

*See also:* *note Adj_div::; *note closed_points::.


File: singular.hlp,  Node: BrillNoether,  Next: Weierstrass,  Prev: NSplaces,  Up: brnoeth_lib

D.9.1.3 BrillNoether
....................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     BrillNoether(G,CURVE); G an intvec, CURVE a list

*Return:*
     list of ideals (each of them with two homogeneous generators, which
     represent the numerator, resp. denominator, of a rational
function).
     The corresponding rational functions form a vector basis of the
     linear system L(G), G a rational divisor over a non-singular curve.

*Note:*
     The procedure must be called from the ring CURVE[1][2], where CURVE
     is the output of the procedure `NSplaces'.
     The intvec G represents a rational divisor supported on the closed
     places of CURVE[3] (e.g. `G=2,0,-1;' means 2 times the closed place
     1 minus 1 times the closed place 3).

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list C=Adj_div(x3y+y3+x);
     ==> The genus of the curve is 3
     C=NSplaces(1..4,C);
     // the first 3 Places in C[3] are of degree 1.
     // we define the rational divisor G = 4*C[3][1]+4*C[3][3] (of degree 8):
     intvec G=4,0,4;
     def R=C[1][2];
     setring R;
     list LG=BrillNoether(G,C);
     ==> Vector basis successfully computed 
     // here is the vector basis of L(G):
     LG;
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=1
     ==> [2]:
     ==>    _[1]=y
     ==>    _[2]=x
     ==> [3]:
     ==>    _[1]=z
     ==>    _[2]=x
     ==> [4]:
     ==>    _[1]=y2
     ==>    _[2]=x2
     ==> [5]:
     ==>    _[1]=xz2+y3
     ==>    _[2]=x3
     ==> [6]:
     ==>    _[1]=xyz2+y4
     ==>    _[2]=x4
     printlevel=plevel;

* Menu:

See also:
* Adj_div::
* NSplaces::
* Weierstrass::

*See also:* *note Adj_div::; *note NSplaces::; *note Weierstrass::.


File: singular.hlp,  Node: Weierstrass,  Next: extcurve,  Prev: BrillNoether,  Up: brnoeth_lib

D.9.1.4 Weierstrass
...................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     Weierstrass( i, m, CURVE ); i,m integers and CURVE a list

*Return:*
     list WS of two lists:

       WS[1] list of integers (Weierstr. semigroup of the curve at place i up to m)
       WS[2] list of ideals (the associated rational functions)
       
*Note:*
     The procedure must be called from the ring CURVE[1][2], where CURVE
     is the output of the procedure `NSplaces'.
     i represents the place CURVE[3][i].
     Rational functions are represented by numerator/denominator in form
     of ideals with two homogeneous generators.

*Warning:*
     The place must be rational, i.e., necessarily CURVE[3][i][1]=1.

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list C=Adj_div(x3y+y3+x);
     ==> The genus of the curve is 3
     C=NSplaces(1..4,C);
     def R=C[1][2];
     setring R;
     // Place C[3][1] has degree 1 (i.e it is rational);
     list WS=Weierstrass(1,7,C);
     ==> Vector basis successfully computed 
     // the first part of the list is the Weierstrass semigroup up to 7 :
     WS[1];
     ==> [1]:
     ==>    0
     ==> [2]:
     ==>    3
     ==> [3]:
     ==>    5
     ==> [4]:
     ==>    6
     ==> [5]:
     ==>    7
     // and the second part are the corresponding functions :
     WS[2];
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=1
     ==> [2]:
     ==>    _[1]=y
     ==>    _[2]=z
     ==> [3]:
     ==>    _[1]=xy
     ==>    _[2]=z2
     ==> [4]:
     ==>    _[1]=y2
     ==>    _[2]=z2
     ==> [5]:
     ==>    _[1]=y3
     ==>    _[2]=xz2
     printlevel=plevel;

* Menu:

See also:
* Adj_div::
* BrillNoether::
* NSplaces::

*See also:* *note Adj_div::; *note BrillNoether::; *note NSplaces::.


File: singular.hlp,  Node: extcurve,  Next: AGcode_L,  Prev: Weierstrass,  Up: brnoeth_lib

D.9.1.5 extcurve
................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     extcurve( d, CURVE ); d an integer, CURVE a list

*Return:*
     list L which is the update of the list CURVE with additional
     entries

        L[1][3]: ring (p,a),(x,y),lp (affine),
        L[1][4]: ring (p,a),(x,y,z),lp (projective),
        L[1][5]: ring (p,a),(x,y,t),ls (local),
        L[2][3]: int  (the number of rational places),
        
     the rings being defined over a field extension of degree d.
     If d<2 then `extcurve(d,CURVE);' creates a list L which is the
     update of the list CURVE with additional entries

        L[1][5]: ring p,(x,y,t),ls,
        L[2][3]: int  (the number of computed places over the base field).
        
     In both cases, in the ring L[1][5] lists with the data for all the
     computed rational places (after a field extension of degree d) are
     created (see *note Adj_div::):

        lists POINTS, LOC_EQS, BRANCHES, PARAMETRIZATIONS.
        
*Note:*
     The list CURVE should be the output of `NSplaces', and must contain
     (at least) one place of degree d.
     You actually need all the places with degree dividing d.
     Otherwise, not all the places are computed, but only part of them.
     This procedure must be executed before constructing AG codes, even
     if no extension is needed. The ring L[1][4] must be active when
     constructing codes over the field extension.

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list C=Adj_div(x5+y2+y);
     ==> The genus of the curve is 2
     C=NSplaces(1..4,C);
     // since we have all points up to degree 4, we can extend the curve
     // to that extension, in order to get rational points over F_16;
     C=extcurve(4,C);
     ==> Total number of rational places : NrRatPl = 33
     // e.g., display the basepoint of place no. 32:
     def R=C[1][5];
     setring R;
     POINTS[32];
     ==> [1]:
     ==>    (a3+a2+a+1)
     ==> [2]:
     ==>    (a2+a)
     ==> [3]:
     ==>    1
     printlevel=plevel;

* Menu:

See also:
* AGcode_L::
* AGcode_Omega::
* Adj_div::
* NSplaces::
* closed_points::

*See also:* *note AGcode_L::; *note AGcode_Omega::; *note Adj_div::;
*note NSplaces::; *note closed_points::.


File: singular.hlp,  Node: AGcode_L,  Next: AGcode_Omega,  Prev: extcurve,  Up: brnoeth_lib

D.9.1.6 AGcode_L
................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     AGcode_L( G, D, EC ); G,D intvec, EC a list

*Return:*
     a generator matrix for the evaluation AG code defined by the
     divisors G and D.

*Note:*
     The procedure must be called within the ring EC[1][4], where EC is
     the output of `extcurve(d)' (or within the ring EC[1][2] if d=1).
     The entry i in the intvec D refers to the i-th rational place in
     EC[1][5] (i.e., to POINTS[i], etc., see *note extcurve::).
     The intvec G represents a rational divisor (see *note
     BrillNoether:: for more details).
     The code evaluates the vector basis of L(G) at the rational places
     given by D.

*Warnings:*
     G should satisfy  2*genus-2 < deg(G) < size(D)  $ 2*genus-2 < deg(G) < size(D) $
     , which is not checked by the algorithm.
     G and D should have disjoint supports (checked by the algorithm).

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list HC=Adj_div(x3+y2+y);
     ==> The genus of the curve is 1
     HC=NSplaces(1..2,HC);
     HC=extcurve(2,HC);
     ==> Total number of rational places : NrRatPl = 9
     def ER=HC[1][4];
     setring ER;
     intvec G=5;      // the rational divisor G = 5*HC[3][1]
     intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
     // let us construct the corresponding evaluation AG code :
     matrix C=AGcode_L(G,D,HC);
     ==> Vector basis successfully computed 
     // here is a linear code of type [8,5,>=3] over F_4
     print(C);
     ==> 0,0,(a),  (a+1),1,  1,    (a+1),(a),  
     ==> 1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),
     ==> 1,1,1,    1,    1,  1,    1,    1,    
     ==> 0,0,(a+1),(a),  1,  1,    (a),  (a+1),
     ==> 0,0,(a+1),(a),  (a),(a+1),1,    1     
     printlevel=plevel;

* Menu:

See also:
* AGcode_Omega::
* Adj_div::
* BrillNoether::
* extcurve::

*See also:* *note AGcode_Omega::; *note Adj_div::; *note BrillNoether::;
*note extcurve::.


File: singular.hlp,  Node: AGcode_Omega,  Next: prepSV,  Prev: AGcode_L,  Up: brnoeth_lib

D.9.1.7 AGcode_Omega
....................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     AGcode_Omega( G, D, EC ); G,D intvec, EC a list

*Return:*
     a generator matrix for the residual AG code defined by the divisors
     G and D.

*Note:*
     The procedure must be called within the ring EC[1][4], where EC is
     the output of `extcurve(d)' (or within the ring EC[1][2] if d=1).
     The entry i in the intvec D refers to the i-th rational place in
     EC[1][5] (i.e., to POINTS[i], etc., see *note extcurve::).
     The intvec G represents a rational divisor (see *note
     BrillNoether:: for more details).
     The code computes the residues of a vector space basis of

     \Omega(G-D) $\Omega(G-D)$
      at the rational places given by D.

*Warnings:*
     G should satisfy  2*genus-2 < deg(G) < size(D)  $ 2*genus-2 < deg(G) < size(D) $
     , which is not checked by the algorithm.
     G and D should have disjoint supports (checked by the algorithm).

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list HC=Adj_div(x3+y2+y);
     ==> The genus of the curve is 1
     HC=NSplaces(1..2,HC);
     HC=extcurve(2,HC);
     ==> Total number of rational places : NrRatPl = 9
     def ER=HC[1][4];
     setring ER;
     intvec G=5;      // the rational divisor G = 5*HC[3][1]
     intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
     // let us construct the corresponding residual AG code :
     matrix C=AGcode_Omega(G,D,HC);
     ==> Vector basis successfully computed 
     // here is a linear code of type [8,3,>=5] over F_4
     print(C);
     ==> 0,    (a),(a),(a),  (a+1),1,0,  0,
     ==> (a+1),1,  (a),0,    (a),  0,(a),0,
     ==> (a+1),0,  (a),(a+1),(a+1),0,0,  1 
     printlevel=plevel;

* Menu:

See also:
* AGcode_L::
* Adj_div::
* BrillNoether::
* extcurve::

*See also:* *note AGcode_L::; *note Adj_div::; *note BrillNoether::;
*note extcurve::.


File: singular.hlp,  Node: prepSV,  Next: decodeSV,  Prev: AGcode_Omega,  Up: brnoeth_lib

D.9.1.8 prepSV
..............

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     prepSV( G, D, F, EC ); G,D,F intvecs and EC a list

*Return:*
     list E of size n+3, where n=size(D). All its entries but E[n+3] are
     matrices:

        E[1]:  parity check matrix for the current AG code
        E[2] ... E[n+2]:  matrices used in the procedure decodeSV
        E[n+3]:  intvec with
            E[n+3][1]: correction capacity 
     epsilon
$epsilon$
      of the algorithm
            E[n+3][2]: designed Goppa distance 
     delta
$delta$
      of the current AG code
        
*Note:*
     Computes the preprocessing for the basic (Skorobogatov-Vladut)
     decoding algorithm.
     The procedure must be called within the ring EC[1][4], where EC is
     the output of `extcurve(d)' (or in the ring EC[1][2] if d=1)
     The intvec G and F represent rational divisors (see *note
     BrillNoether:: for more details).
     The intvec D refers to rational places (see *note AGcode_Omega::
     for more details.).  The current AG code is `AGcode_Omega(G,D,EC)'.
     If you know the exact minimum distance d and you want to use it in
     `decodeSV' instead of delta $delta$
     , you can change the value of E[n+3][2] to d before applying
     decodeSV.
     If you have a systematic encoding for the current code and want to
     keep it during the decoding, you must previously permute D (using
     `permute_L(D,P);'), e.g., according to the permutation P=L[3], L
     being the output of `sys_code'.

*Warnings:*
     F must be a divisor with support disjoint from the support of D and
     with degree epsilon + genus $epsilon + genus$
     , where

     epsilon:=[(deg(G)-3*genus+1)/2] $epsilon:=[(deg(G)-3*genus+1)/2]$
.
     G should satisfy  2*genus-2 < deg(G) < size(D)  $ 2*genus-2 < deg(G) < size(D) $
     , which is not checked by the algorithm.
     G and D should also have disjoint supports (checked by the
     algorithm).

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list HC=Adj_div(x3+y2+y);
     ==> The genus of the curve is 1
     HC=NSplaces(1..2,HC);
     HC=extcurve(2,HC);
     ==> Total number of rational places : NrRatPl = 9
     def ER=HC[1][4];
     setring ER;
     intvec G=5;      // the rational divisor G = 5*HC[3][1]
     intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
     // construct the corresp. residual AG code of type [8,3,>=5] over F_4:
     matrix C=AGcode_Omega(G,D,HC);
     ==> Vector basis successfully computed 
     // we can correct 1 error and the genus is 1, thus F must have degree 2
     // and support disjoint from that of D;
     intvec F=2;
     list SV=prepSV(G,D,F,HC);
     ==> Vector basis successfully computed 
     ==> Vector basis successfully computed 
     ==> Vector basis successfully computed 
     // now everything is prepared to decode with the basic algorithm;
     // for example, here is a parity check matrix to compute the syndrome :
     print(SV[1]);
     ==> 0,0,(a),  (a+1),1,  1,    (a+1),(a),  
     ==> 1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),
     ==> 1,1,1,    1,    1,  1,    1,    1,    
     ==> 0,0,(a+1),(a),  1,  1,    (a),  (a+1),
     ==> 0,0,(a+1),(a),  (a),(a+1),1,    1     
     // and here you have the correction capacity of the algorithm :
     int epsilon=SV[size(D)+3][1];
     epsilon;
     ==> 1
     printlevel=plevel;

* Menu:

See also:
* AGcode_Omega::
* decodeSV::
* extcurve::
* permute_L::
* sys_code::

*See also:* *note AGcode_Omega::; *note decodeSV::; *note extcurve::;
*note permute_L::; *note sys_code::.


File: singular.hlp,  Node: decodeSV,  Next: closed_points,  Prev: prepSV,  Up: brnoeth_lib

D.9.1.9 decodeSV
................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     decodeSV( y, K ); y a row-matrix and K a list

*Return:*
     a codeword (row-matrix) if possible, resp. the 0-matrix (of size 1)
     if decoding is impossible.
     For decoding the basic (Skorobogatov-Vladut) decoding algorithm is
     applied.

*Note:*
     The list_expression should be the output K of the procedure
`prepSV'.
     The matrix_expression should be a (1 x n)-matrix, where n =
ncols(K[1]).
     The decoding may fail if the number of errors is greater than the
     correction capacity of the algorithm.

*Example:*
     LIB "brnoeth.lib";
     int plevel=printlevel;
     printlevel=-1;
     ring s=2,(x,y),lp;
     list HC=Adj_div(x3+y2+y);
     ==> The genus of the curve is 1
     HC=NSplaces(1..2,HC);
     HC=extcurve(2,HC);
     ==> Total number of rational places : NrRatPl = 9
     def ER=HC[1][4];
     setring ER;
     intvec G=5;      // the rational divisor G = 5*HC[3][1]
     intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
     // construct the corresp. residual AG code of type [8,3,>=5] over F_4:
     matrix C=AGcode_Omega(G,D,HC);
     ==> Vector basis successfully computed 
     // we can correct 1 error and the genus is 1, thus F must have degree 2
     // and support disjoint from that of D
     intvec F=2;
     list SV=prepSV(G,D,F,HC);
     ==> Vector basis successfully computed 
     ==> Vector basis successfully computed 
     ==> Vector basis successfully computed 
     // now we produce 1 error on the zero-codeword :
     matrix y[1][8];
     y[1,3]=a;
     // and then we decode :
     print(decodeSV(y,SV));
     ==> 0,0,0,0,0,0,0,0
     printlevel=plevel;

* Menu:

See also:
* AGcode_Omega::
* extcurve::
* prepSV::

*See also:* *note AGcode_Omega::; *note extcurve::; *note prepSV::.


File: singular.hlp,  Node: closed_points,  Next: dual_code,  Prev: decodeSV,  Up: brnoeth_lib

D.9.1.10 closed_points
......................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     closed_points(I); I an ideal

*Return:*
     list of prime ideals (each a Groebner basis), corresponding to the
     (distinct affine closed) points of V(I)

*Note:*
     The ideal must have dimension 0, the basering must have 2
     variables, the ordering must be lp, and the base field must be
     finite and prime.
     It might be convenient to set the option(redSB) in advance.

*Example:*
     LIB "brnoeth.lib";
     ring s=2,(x,y),lp;
     // this is just the affine plane over F_4 :
     ideal I=x4+x,y4+y;
     list L=closed_points(I);
     // and here you have all the points :
     L;
     ==> [1]:
     ==>    _[1]=y2+y+1
     ==>    _[2]=x+y
     ==> [2]:
     ==>    _[1]=y2+y+1
     ==>    _[2]=x+1
     ==> [3]:
     ==>    _[1]=y2+y+1
     ==>    _[2]=x+y+1
     ==> [4]:
     ==>    _[1]=y2+y+1
     ==>    _[2]=x
     ==> [5]:
     ==>    _[1]=y+1
     ==>    _[2]=x2+x+1
     ==> [6]:
     ==>    _[1]=y+1
     ==>    _[2]=x+1
     ==> [7]:
     ==>    _[1]=y+1
     ==>    _[2]=x
     ==> [8]:
     ==>    _[1]=y
     ==>    _[2]=x2+x+1
     ==> [9]:
     ==>    _[1]=y
     ==>    _[2]=x+1
     ==> [10]:
     ==>    _[1]=y
     ==>    _[2]=x

* Menu:

See also:
* triang_lib::

*See also:* *note triang_lib::.


File: singular.hlp,  Node: dual_code,  Next: sys_code,  Prev: closed_points,  Up: brnoeth_lib

D.9.1.11 dual_code
..................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     dual_code(G); G a matrix of numbers

*Return:*
     a generator matrix of the dual code generated by G

*Note:*
     The input should be a matrix G of numbers.
     The output is also a parity check matrix for the code defined by G

*Example:*
     LIB "brnoeth.lib";
     ring s=2,T,lp;
     // here is the Hamming code of length 7 and dimension 3
     matrix G[3][7]=1,0,1,0,1,0,1,0,1,1,0,0,1,1,0,0,0,1,1,1,1;
     print(G);
     ==> 1,0,1,0,1,0,1,
     ==> 0,1,1,0,0,1,1,
     ==> 0,0,0,1,1,1,1 
     matrix H=dual_code(G);
     print(H);
     ==> 1,1,1,0,0,0,0,
     ==> 1,0,0,1,1,0,0,
     ==> 0,1,0,1,0,1,0,
     ==> 1,1,0,1,0,0,1 


File: singular.hlp,  Node: sys_code,  Next: permute_L,  Prev: dual_code,  Up: brnoeth_lib

D.9.1.12 sys_code
.................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     sys_code(C); C is a matrix of constants

*Return:*
     list L with:

        L[1] is the generator matrix in standard form of an equivalent code,
        L[2] is the parity check matrix in standard form of such code,
        L[3] is an intvec which represents the needed permutation.
        
*Note:*
     Computes a systematic code which is equivalent to the given one.
     The input should be a matrix of numbers.
     The output has to be interpreted as follows: if the input was the
     generator matrix of an AG code then one should apply the
     permutation L[3] to the divisor D of rational points by means of
     `permute_L(D,L[3]);' before continuing to work with the code (for
     instance, if you want to use the systematic encoding together with
     a decoding algorithm).

*Example:*
     LIB "brnoeth.lib";
     ring s=3,T,lp;
     matrix C[2][5]=0,1,0,1,1,0,1,0,0,1;
     print(C);
     ==> 0,1,0,1,1,
     ==> 0,1,0,0,1 
     list L=sys_code(C);
     L[3];
     ==> 2,4,3,1,5
     // here is the generator matrix in standard form
     print(L[1]);
     ==> 1,0,0,0,1,
     ==> 0,1,0,0,0 
     // here is the control matrix in standard form
     print(L[2]);
     ==> 0, 0,1,0,0,
     ==> 0, 0,0,1,0,
     ==> -1,0,0,0,1 
     // we can check that both codes are dual to each other
     print(L[1]*transpose(L[2]));
     ==> 0,0,0,
     ==> 0,0,0 

* Menu:

See also:
* AGcode_Omega::
* permute_L::
* prepSV::

*See also:* *note AGcode_Omega::; *note permute_L::; *note prepSV::.


File: singular.hlp,  Node: permute_L,  Prev: sys_code,  Up: brnoeth_lib

D.9.1.13 permute_L
..................

Procedure from library `brnoeth.lib' (*note brnoeth_lib::).

*Usage:*
     permute_L( L, P ); L,P either intvecs or lists

*Return:*
     list obtained from L by applying the permutation given by P.

*Note:*
     If P is a list, all entries must be integers.

*Example:*
     LIB "brnoeth.lib";
     list L=list();
     L[1]="a";
     L[2]="b";
     L[3]="c";
     L[4]="d";
     intvec P=1,3,4,2;
     // the list L is permuted according to P :
     permute_L(L,P);
     ==> [1]:
     ==>    a
     ==> [2]:
     ==>    c
     ==> [3]:
     ==>    d
     ==> [4]:
     ==>    b

* Menu:

See also:
* AGcode_Omega::
* prepSV::
* sys_code::

*See also:* *note AGcode_Omega::; *note prepSV::; *note sys_code::.


File: singular.hlp,  Node: Release Notes,  Next: Index,  Prev: SINGULAR libraries,  Up: Top

E Release Notes
***************

* Menu:

* News and changes::
* Downloading instructions::
* Unix installation instructions::
* Windows installation instructions::
* Macintosh installation instructions::


File: singular.hlp,  Node: News and changes,  Next: Downloading instructions,  Up: Release Notes

E.1 News and changes
====================

NEWS in SINGULAR 2-0-4
**********************

The current version 2-0-4 is an update to the release series version
2-0.

Changes with respect to version 2-0-3:

Factorizing algorithms revisited
================================

Starting with version 2-0-4, we use NTL (by Victor Shoup) for factoring
univariate polynomials. The multivariate factoring code in
libfac/factory does now also work over algebraic extension fields.

Help system is configurable via LIB/help.cnf
============================================

The help browsers of Singular can be configured via the file
LIB/help.cnf, also the addition of new help browsers is possible.

Extensions of the ring concept
==============================

new coefficient domains: arbitrary long real and complex numbers

no restriction on number of parameters

degree bound on exponent values (maximum is now 2^31, standard 2^15)

non-positives weights get a better handling (converts wp/Wp to ws/Ws)

handle blocks of mixed orders correctly

maximal prime characteristic is now 2147483629 instead of 32003

Changes in SINGULAR libraries
=============================

The documentation of libraries was generally improved.
*note equising_lib::
     procedures esStratum, isEquising now also for reducible polynomials

     new procedures: tau_es (codim of mu-const stratum in semi-universal
     def. base); esIdeal ((Wahl's) equisingularity ideal)

*note gaussman_lib::
     added bernstein: roots of the Bernstein polynomial of t

*note hnoether_lib::
     HNdevelop, reddevelop, essdevelop are obsolete, replaced by
     hnexpansion
     multsequence is "repaired" (since branches computed by hnexpansion
     et al) are now ordered according to the needs of multsequence.
     newtonpoly needs no longer that ordering of the basering is ls
     new procedures: is_NND      test if f is Newton non-degenerate

*note homolog_lib::
     new procedures: depth, fitting, flatteningStrat, isCM, isFlat,
     isLocallyFree, isReg, KoszulHomology, tensorMod, Tor

*note matrix_lib::
     in proc tensor(A,B):  check if ncols(A)==0

*note normal_lib::
     new procedure: deltaLoc(f,S);      (sum of) delta invariant(s) at
     conjugated singular points
     proc genus makes now use of is_NND of hnoether.lib

*note primdec_lib::
     optimizations again

*note solve_lib::
     procedure laguerre_solve ignores no longer the 2nd parameter
     (precision of internal computation)
     new procedure simplexOut:     prints solution of simplex in nice
     format

Internal Changes
================

normal form computation uses
     Bucket representation of polynomials.

factorization
     revisited, missing cases implemented

NTL
     NTL is used for univariate factorization

source code
     adapted for use with gcc 3.1/3.2, gmp 4.x

Porting
=======

   * Singular is available for ix86-libc5, ix86-libc6, HPUX_9, HPUX_10,
     SunOS-4, SunOS-5, IRIX-6, ix86-Win (Windows 95/98/ME/NT/2K/XP),
     FreeBSD 4.x, MacOS X Windows 95/98/ME/NT/2K/XP and MacOS X

   * `MP' functionality is not available on Windows 95/98/ME/NT/2K/XP
     and MacOS X.

   * Singular 2-0-2 was the last version for MacOS 9


File: singular.hlp,  Node: Downloading instructions,  Next: Unix installation instructions,  Prev: News and changes,  Up: Release Notes

E.2 Downloading instructions
============================

SINGULAR is available as binary program for most common hard- and
software platforms. Release versions of SINGULAR can be downloaded with
ftp from our FTP site
     `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/',
or, using your favorite WWW browser, from
     `http://www.mathematik.uni-kl.de/ftp/pub/Math/Singular/'.

To download SINGULAR for a Unix platform
========================================

Make sure that you have approximately 20 MByte of free disk space and
follow these steps.

  1. You need to download two (archive) files:

     `Singular-2-0-4-share.tar.gz'
          contains architecture independent data like documentation and
          libraries
          `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-share.tar.gz'

     `Singular-2-0-4-<uname>.tar.gz'
          contains architecture dependent executables, like the SINGULAR
          program.

     `<uname>' is a description of the processor and operating system
     for which SINGULAR is compiled. Choose one of the following:
     `ix86-Linux'   PC's running under Linux with `libc' version 6 (e.g.,
                    for SuSe Linux distribution version >= 6; RedHat Linux
                    distribution version >= 5.2).
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-Linux.tar.gz'
     `ix86-Linux-libc5'PC's running under Linux with `libc' version 5 (if you
                    are not sure which `libc' version you have, run `ldd
                    /bin/ls').
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-Linux-libc5.tar.gz'
     `ix86-freebsd' 's running under FreeBSD
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-freebsd.tar.gz'
     `ix86-Win'     PC's running Windows 95/98/ME/NT/2K/XP which have Cygwin
                    version 1.3.9 (or higher) already installed. Unless you
                    are familiar with Cygwin, we recommend that you download
                    one of the self-extracting archives as described below.
     `HPUX-9'       HP workstations running under HPUX version 9
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-HPUX-9.tar.gz'
     `HPUX-10'      HP workstations running under HPUX version 10
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-HPUX-10.tar.gz'
     `SunOS-5'      Sun workstations running Solaris version 5
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-SunOS-5.tar.gz'
     `IRIX-6'       IRIX workstations running IRIX version 6
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-IRIX-6.tar.gz'
     `AIX-4'        AIX workstations running AIX version 4
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-AIX-4.tar.gz'
     `PowerMacintosh-darwin'PowerMacintosh running Mac OS X
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/OsX/Singular-2-0-4-PowerMacintosh-darwin.tar.gz'
     `DecAlpha-Linux'Digital Dec Alpha running Linux (RedHat 5.2)
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-DecAlpha-Linux.tar.gz'
     `DecAlpha-OSF1'Digital Dec Alpha running OSF 1
                    `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-DecAlpha-OSF1.tar.gz'
     Please contact us if you can not find an appropriate architecture
     dependent archive.

  2. Simply change to the directory in which you wish to install
     SINGULAR (usually wherever you install 3rd-party software):

          cd /usr/local/	

     SINGULAR specific subdirectories will be created in such a way that
     multiple versions and multiple architecture dependent files of
     SINGULAR can peaceably coexist under the same `/usr/local/' tree.

  3. Unpack the archives:

          gzip -dc Singular-2-0-4-<uname>.tar.gz | tar -pxf -
          gzip -dc Singular-2-0-4-share.tar.gz | tar -pxf -

     If you have downloaded `Singular-2-0-4-share.zip', unpack with

          unzip -u Singular-2-0-4-share.zip

  4. After unpacking, see the created file `Singular/2-0-4/INSTALL'
     (which is also located at
     `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/INSTALL_unix.html'
     for details on how to finish the installation.

To download SINGULAR for Windows 95/98/ME/NT/2K/XP
==================================================

  1. Download one of the following self-extracting archives:

     `Singular-2-0-4-Compact.exe (ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/Singular-2-0-4-Compact.exe)'
          Minimal archive to download. Installs Singular and minimal set
          of needed tools and DLLs.

     `Singular-2-0-4-Typical.exe (ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/Singular-2-0-4-Typical.exe)'
          Typical archive to download. Installs Singular and the XEmacs
          editor to run ESingular.

  2. Double-click (or, execute), the self-extracting archives, and
     *carefully* follow the instructions given there.

  3. If, while running setup, you obtain the following message `Setup
     failed to launch installation engine:' `Error loading type
     library/DLL', then you need to download and execute Microsoft
     DCOM98 package
     `http://www.microsoft.com/com/dcom/dcom98/download.asp'.  Such a
     problem could appear on Win 95/98.

  4. In case of problems, see the created file `/etc/INSTALL.txt' (which
     is also located at
     `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/INSTALL_win.htm'
     for details on how to finish the installation.

To download SINGULAR for the Macintosh
======================================

For the SINGULAR version for Mac OS X refer to the Unix section.
The SINGULAR version for Mac OS 9 is available as
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-2-html.sea.hqx'
(documentation) and
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-2-ppc-MPW.sea.hqx'
(binaries and libraries).  The file
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/INSTALL_mac.html'
gives details on how to finish the installation.


File: singular.hlp,  Node: Unix installation instructions,  Next: Windows installation instructions,  Prev: Downloading instructions,  Up: Release Notes

E.3 Unix installation instructions
==================================

To install SINGULAR on a Unix platform, you need the following two
archives:
`Singular-2-0-4-share.tar.gz'
     contains architecture independent data like documentation and
     libraries (alternatively, you may also download
     `Singular-2-0-4-share.zip').

`Singular-2-0-4-<uname>.tar.gz'
     contains architecture dependent executables, like the SINGULAR
     program.

`<uname>' is a description of the processor and operating system for
which SINGULAR is compiled (e.g, `ix86-Linux'). Please contact us if you
can not find an appropriate architecture dependent archive.

You can obtain these (and other) archives from
     `ftp://www.mathematik.uni-kl.de/pub/Math/Singular'.

To install SINGULAR
===================

Make sure that you have approximately 12MByte of free disk space and
follow these steps.
  1. Simply change to the directory in which you wish to install
     SINGULAR (usually wherever you install 3rd-party software), for
     example:

          cd /usr/local
          or
          mkdir install;cd install 
          (you do not need root privileges in this case)

     SINGULAR specific subdirectories will be created in such a way that
     multiple versions and multiple architecture dependent files of
     SINGULAR can peaceably coexist under the same `/usr/local' tree.

  2. Unpack the archives:

          gzip -dc <path_to>/Singular-2-0-4-<uname>.tar.gz | tar -pxf -
          gzip -dc <path_to>/Singular-2-0-4-share.tar.gz | tar -pxf -

     This creates the the directory Singular/2-0-4 with
     (sub)directories           which contain
     `<uname>'                  `Singular' and `ESingular' executables
     `LIB'                      SINGULAR libraries (`*.lib' files)
     `emacs'                    files for the SINGULAR Emacs user interface
     `info'                     info files of SINGULAR manual
     `html'                     html files of SINGULAR manual
     `doc'                      miscellaneous documentation files
     `examples'                 SINGULAR examples (`*.sing' files)

     For the executable to work, the directory layout must look pretty
     much like this; the executable looks for "sibling" directories at
     run-time to figure out where its SINGULAR libraries and on-line
     documentation files are. These constraints on the local directory
     layout are necessary to avoid having to hard-code pathnames into
     the executables, or require that environment variables be set
     before running the executable. In particular, you *must not move or
     copy* the SINGULAR executables to another place, but use soft-links
     instead.

The following steps are optional:

   * Arrange that typing `Singular' at the shell prompt starts up the
     installed SINGULAR executable.

     If you have root permission, do:

          ln -s `pwd`/Singular/2-0-4/<uname>/Singular  /usr/local/bin/Singular-2-0-4
          ln -s `pwd`/Singular/2-0-4/<uname>/ESingular  /usr/local/bin/ESingular-2-0-4
          ln -s /usr/local/bin/Singular-2-0-4 /usr/local/bin/Singular
          ln -s /usr/local/bin/ESingular-2-0-4 /usr/local/bin/ESingular

     Otherwise, append the directory ``pwd`/Singular/2-0-4/<uname>/' to
     your `$PATH' environment variable. For the `csh' (or, `tcsh') shell
     do:

          set path=(`pwd`/Singular/2-0-4/<uname> $path)

     For the `bash' (or, `ksh') shell do:

          export PATH=`pwd`/Singular/2-0-4/<uname>/:$PATH

     You also might want to adjust your personal start-up files
     (`~/.cshrc' for `csh', `~/.tcshrc' for `tcsh', or `~/.profile' for
     `bash') accordingly, so that the `$PATH' variable is set
     automatically each time you login.

     *IMPORTANT:* Do _never_ move or copy the file
     `Singular/2-0-4/<uname>/Singular' to another place, but use
     soft-links instead.

   * If you wish to use any of following features of SINGULAR, make sure
     that the respective programs are installed on your system:

     *Feature*                            *Requires*
     running `ESingular', or `Singular'   Emacs version 20 or higher, or,
     within Emacs                         XEmacs version 20.3 or higher
                                          (ESingular is only included in the
                                          Linux distribution, on other Unix
                                          platforms you can download the
                                          Singular emacs lisp files but we
                                          give no warranties for specific
                                          platforms).
     on-line `html' help                  netscape browser
     on-line `info' help                  info, or tkinfo texinfo browser
                                          programs
     TAB completion and history           shared readline library, i.e.
     mechanism of ASCII-terminal          `/usr/lib/libreadline.so'
     interface
     visualization of curves and          surf version 0.9 or higher (only
     surfaces                             available for Linux and Solaris).

     You may download most of these programs from

          `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils/'.

   * Customize the on-line help system:

     By default, on-line help is displayed in the `html' format using
     the `netscape' program.

     However, this behavior can be customized in several ways using the
     SINGULAR commands `system("--browser",<browser>)' and
     `system("--allow-net", 1)' (or, by starting up SINGULAR with the
     respective command line options).

     In particular, creating the file `Singular/2-0-4/LIB/.singularrc'
     and putting the SINGULAR command

          system("--allow-net", 1);

     in it, allows the on-line help system to fetch its `html' pages
     from Singular's WWW home site (http://www.singular.uni-kl.de) in
     case its local html pages are not found. That is, you may delete
     your local html pages, after setting this option.

     See also *note The online help system::, *note Command line
     options::, and *note Startup sequence::, for more details on
     customizing the on-line help system.

   * Add the line

          * Singular:(singular.hlp).     A system for polynomial computations

     to your system-wide `dir' file (usually `/usr/info/dir' or
     `/usr/local/info/dir' and  copy or soft-link the file
     `Singular/2-0-4/info/singular.hlp' to the directory of your `dir'
     file.
     This assures that the SINGULAR manual can be  accessed from
     stand-alone texinfo browser programs such as `info' or `Emacs'.
     (It is not necessary for the use of the help system from within
     `Singular'.)

Troubleshooting
===============

   * General: SINGULAR can not find its libraries or on-line help

       1. Make sure that you have read and/or execute permission the
          files and directories of the Singular distribution. If in
          doubt, `cd' to the directory where you unpacked SINGULAR, and
          do (as root, if necessary):

               chmod -R a+rX Singular

       2. Start up SINGULAR, and issue the command
          `system("Singular");'.  If this does not return the correct
          and expanded location of the SINGULAR executable, then you
          found a bug in SINGULAR, which we ask you to report (see
          below).

       3. Check whether the directories containing the libraries and
          on-line help files can be found by SINGULAR: If `$bindir'
          denotes the directory where the SINGULAR executable resides,
          then SINGULAR looks for library files as follows:
          (0) the current directory
          (1) all dirs of the environment variable SINGULARPATH
          (2) `$bindir/LIB'
          (3) `$bindir/../LIB'
          (4) `/usr/local/Singular/2-0-4/LIB'
          (4) `/usr/local/Singular/LIB'
          The on-line `info' files need to be at  `$bindir/../info' and
          the `html' pages at `$bindir/../html'.

     You can inspect the found library and `info'/`html' directories by
     starting up SINGULAR with the `--version' option, or by issuing the
     SINGULAR command `system("--version");'.

   * Under SuSE-Linux, ESINGULAR does not display a prompt: This is due
     to the very restrictive access rights of `/dev/pty*' of the
     standard SuSE (http:/www.suse.de) distribution (starting from
     version 6.3 on). As root, do one of the following: Either

          chmod 666 /dev/pty*

     or,

          chmod g+s $(which emacs)
          chgrp tty $(which emacs)
          chmod g+s $(which xemacs)
          chgrp tty $(which xemacs)

     See also `http://sdb.suse.de/sdb/de/html/ke_devpts-63.html' for
     details.

   * For `HPUX' systems:
     The /etc/termcap files which are pre-installed on these systems are
     broken which leads to messages like

          Name collision between 9826 9836

     when SINGULAR is started. To fix this, you can get fixed termcap
     files from `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils'
     by downloading the files termcap-<uname-description> and either
     replace your /etc/termcap file by the file found there, or view,
     and redo the respective changes by `diff''ing the downloaded and
     the original file.

   * For `ix86-Linux' systems:
     Due to some incompatibilities of shared libraries, the start-up of
     SINGULAR might fail with messages like

            Can not find shared library ...

     For DEBIAN systems, try to do `ln -s /usr/lib/libncurses.so
     /usr/lib/libncurses.so.4'.
     If this fails (and on other systems) download and install
     `Singular-2-0-4-ix86-Linux-static.tar.gz'.

   * For `AIX' systems:
     The default `info' program of the system is not GNU's texinfo
     browser which is used to display the on-line documentation in the
     `info' format. Therefore, the distribution of the AIX executable
     already contains the `info' browser program.  If you remove this
     program, make sure that the GNU `info' program is executed if you
     call '`info'' from your shell.

   * For any other troubles:
     Please send an email to <singular@mathematik.uni-kl.de> and include
     the header which is displayed by starting up SINGULAR with the `-v'
     option, and a description of your machine (issue the command `uname
     -a' on your shell) in your report.


File: singular.hlp,  Node: Windows installation instructions,  Next: Macintosh installation instructions,  Prev: Unix installation instructions,  Up: Release Notes

E.4 Windows installation instructions
=====================================

For the impatient:
==================

   * If you run Windows NT/2K/XP, make sure you are logged in with the
     `Administrator' rights.

   * If you have some older version of `Singular' installed, please
     uninstall it before installing `Singular-2-0-4'. It is recommended
     to install the new `Singular' in the same directory where the
     previous version was installed. Thus your existing environment will
     be used automatically.

   * If you have `Cygwin' or `XEmacs' installed and they do not belong
     of some previous `Singular' installation, please read the
     information below.

   * Execute the self-extracting installation archive and *carefully*
     follow the instructions given there.  Setup will analyze your
     system, create the corresponding configuration and give you further
     tips on the installation process.

   * In case of troubles, see the installed files `/etc/INSTALL.txt',
     `/etc/TROUBLESHOOTING.txt' or visit the *Singular Forum* at
     `http://www.singular.uni-kl.de/forum'.

Installation preliminaries
==========================

Running `Singular' on MS Windows requires that the Cygwin DLL
(dynamically linked library) version 1.3.9 or higher is installed on
your system (see `http://sources.redhat.com/cygwin/' for details about
Cygwin). We install and configure `Cygwin' version 1.3.9 automatically,
if the `BasicCygwin' component is selected (default setting).

To run `ESingular' (i.e. `Singular' within its Emacs interface) on MS
Windows requires furthermore that the `XEmacs' editor is installed on
your system. We install and configure `XEmacs' version 21.1.13
automatically, if the `XEmacs' component is selected.

The `Singular' installation is divided into the following components
(you see them explicitly if you choose the Custom Setup Type during the
installation):
`*Program Files:*'
             
     `Singular'
          Contains the `Singular' Program, documentation and example
          files.
          All files of this component are installed under the directory
          `/usr/local/Singular/2-0-4'

     `BasicCygwin'
          Contains the Cygwin DLL and basic tools/programs (like `bash'
          or `info') of the  Cygwin environment.
          The Cygwin DLL and programs are installed in the directory
          `/bin'. Miscellaneous documentation and configuration files
          are installed into the directory `/etc'.

     `XEmacs'
          Contains the Cygwin port of the `XEmacs' editor (see
          `http://www.xemacs.org' for more about `XEmacs') version
          21.1.13.
          All files of this component are installed under the directory
          `/usr/local'.

     `ESingular'
          Contains the `ESingular', the most comfortable Singular
          interface.  Requires `XEmacs' to run.

`*Remark:*'
     All essential DLLs, some programs and symbolic links are installed
     in the directory `/usr/local/Singular/2-0-4/ix86-Win', which must
     be present in your `PATH' system variable.

`*Help Files:*'

     `WinHelp'
          Contains Singular Manual, converted to Windows help format
          (.hlp).  We recommend to install it, because it is small in
          size. Moreover, we set it as default help browser in all the
          Singular executables.

     `HTML Help'
          Contains the "native" Singular Manual. It's not included by
          default, because it is much bigger than WinHelp, though it has
          better typesetting of mathematical formulae.

The Typical Setup Type of the Singular-2-0-4-Typical.exe contains
`BasicCygwin', `Singular', `XEmacs', `ESingular', `WinHelp' and `HTML
Help' components. The Compact Setup Type does not contain only the `HTML
Help' component.

Downloading preliminaries
=========================

To install `Singular' on a PC running Windows 95/98/ME/NT/2K/XP, you
need to download *one* of the following archive files:

Minimal archive: Singular-2-0-4-Compact.exe (Singular-2-0-4-Compact.exe)
(`BasicCygwin', `Singular', `WinHelp' components)

Typical archive : Singular-2-0-4-Typical.exe
(Singular-2-0-4-Typical.exe)      (`BasicCygwin', `Singular', `XEmacs',
`ESingular', `WinHelp', `HTML Help' components)

You can obtain these (and other) archives either from the `WINDOWS'
directory on the `Singular' CD or from
     `ftp://www.mathematik.uni-kl.de/pub/Math/Singular/'.

Installing Singular
===================

The recent Setup program analyzes your system, e.g. it detects whether
Cygwin and XEmacs are present and functional. Then it gives you hints
and/or error messages with instructions during the installation.

`If you have Cygwin installed'
     If the version of `cygwin1.dll' is not less than 1.3.9,         you
     will be prompted that the `BasicCygwin' component will not
     be installed. Moreover, the existing Cygwin root directory will be
     proposed as         the default installation directory. You can
     accept it, then         `Singular' will be placed into the existing
     Cygwin environment.          If you choose another destination,
     `Singular' will use Cygwin         programs anyway. If your Cygwin
     has incorrect settings (like         inconsistent mount points
     among the important ones), `Singular'         Setup will correct
     them.
     If setup could not detect `cygwin', present in the system, you
     can try to break the installation, start it once more, choose the
     "Custom" setup type and unselect the `BasicCygwin' component.

`If you have XEmacs installed'
     The `Cygwin' port of `XEmacs' version 21.1.13 together         with
     the most         important packages is included in the
     distribution. The use of         non-`Cygwin' ports or earlier
     `Cygwin' ports has some         quirks and does not work
     properly together with `Singular' (i.e., running `ESingular'
     results in problems). Nevertheless, if you want to test the
     compatibility of `ESingular' with your own `XEmacs', just
     de-select the XEmacs component, but leave `ESingular' selected.
     If your `XEmacs' happens to be incompatible with ESingular, you can
        install just the XEmacs component and use in fact two different
     `XEmacs' programs.          The setup program will search for
     `XEmacs' and packages         in `<TARGETDIR>/usr/local/lib' (here
     `<TARGETDIR>' is the directory which you selected while running
     setup). If you have `Cygwin' and the Cygwin port of
     `XEmacs', you might have `XEmacs' installed there. To avoid
     overwriting your `XEmacs' files, setup will ask you what to do.

Customizing Singular
====================

The following step(s) are optional:
   * To conveniently access all files on your computer, mount the drives
     of your disk(s):

       1. Open a rxvt terminal (from Start->Programs->Singular
          2.0->Tools).

       2. For each drive (letter) issue the following command (the drive
          `C:' is used in the example):

               mount -f -s -t C: /C

     After mounting the drive(s) this way, you can conveniently access
     the files on a drive from the `bash' shell and from `XEmacs' using
     the `/C/' prefix. Otherwise, you need to type `/cygdrive/C' - that
     is the Cygwin convention. You can get more information on `mount'
     command by invoking `mount --help'. Command `umount' unmount the
     selected mount point.

   * Create your personal `HOME' directory.
     Various applications (e.g., `bash' or `XEmacs') store user-specific
     configuration/customization files in the `HOME' directory of the
     current user. During the installation, the `HOME' directory is
     globally set for all users to `/home/Singular'. To create your
     individual  `HOME' directory follow these steps:

       1. Create a directory (folder), say, `C:\home\MyHome'.

       2. Copy all files from `/home/Singular' to `C:\home\MyHome'.

       3. Set the _user_ environment variable `HOME' to
          `C:\home\MyHome':
          On Windows 95/98/ME, edit the respective line the
          `AUTOEXEC.BAT' file.
          On Windows NT/2K/XP add an entry in your `Environment' control
          panel.

       4. Restart your computer (On Windows 95/98/ME).

     You may furthermore examine the files copied into your `HOME'
     directory and adjust (i.e. edit) them to your personal
     preferences/needs. System-wide settings are stored in the file
     `/etc/profile'.

Uninstalling Singular
=====================

You can uninstall individual or all installed components by opening the
`Software' shortcut of the `Control panel'.  Simply double-click the
`Singular' item and follow the instructions given there.

For any other troubles, please send an email to
<singular@mathematik.uni-kl.de> and include the header which is
displayed by starting up `Singular' with the `-v' option, and a
description of your machine and operating system.


File: singular.hlp,  Node: Macintosh installation instructions,  Prev: Windows installation instructions,  Up: Release Notes

E.5 Macintosh installation instructions
=======================================

For the SINGULAR version for Mac OS X refer to the Unix section.  The
SINGULAR version for Mac OS 9 is available as
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-4-html.sea.hqx'
(documentation) and
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-4-ppc-MPW.sea.hqx'
(binaries and libraries).  The file
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/INSTALL_mac.txt'
gives details on how to finish the installation.

Installation preliminaries
==========================

This is the final distribution of SINGULAR as MPW tool.  Newer versions
of SINGULAR will only be available for MacOS X (which is handled like
other UNIX-systems).  To install SINGULAR on a Macintosh (PPC only), you
need the file `Singular-2-0-2-ppc-MPW.sea.hqx' resp.
`Singular-2-0-2-ppc-MPW.hqx' which you can obtain by public ftp from
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular'.  Furthermore, you
need MacOS version >= 8.5 with an installed MPW shell.  This version
works also without Carbon.

Installing SINGULAR on MacOS X
==============================

Please see `INSTALL_unix.html'.  In contrast to other Unix systems,
under MacOS X, SINGULAR is only available as a shell command and there
is no Emacs interface.  Enter `Singular' in a terminal under Aqua to run
SINGULAR.  Alternatively, you may choose `Terminal' as the application
to open the file `Singular' with and put it into the dock.

Installing Singular
===================

  1. Make sure that you have MPW  installed on your system.  See below
     for instructions on how to install MPW and how to avoid conflicts
     with the `Carbon.lib'.

  2. Download the file `Singular-2-0-2-ppc-MPW.sea.hqx'.

  3. Expand the downloaded file using a standard Expander (like Compact
     Pro or StuffIt) to obtain the corresponding self-extracting
     `Singular-2-0-2-ppc-MPW.sea' file.

  4. Click on the self-extracting `Singular-2-0-2-ppc-MPW.sea' file.
     This  will create a new folder named `Singular:' which contains the
     SINGULAR program in the subfolder `2-0-2:ppc-MPW:'.  Do not change
     the structure of the subfolders.

  5. Make the folder which contains the executable to the working
     directory of the MPW shell.  To start SINGULAR, you need to type
     `Singular' in the MPW worksheet.  Clicking on the SINGULAR icon on
     the desktop, starts up the MPW shell (the working directory of the
     MPW shell is then the directory of the executable).  If you start
     the MPW shell manually, you must set the working directory to the
     directory of the SINGULAR program.  You may use the directory menu
     or write into the startup file of the MPW shell the line

          setdirectory "{Boot}"Singular:2-0-2:ppc-MPW:

     if `"{Boot}"Singular:2-0-2:ppc-MPW:' is the folder of the
     executable.

     After unpacking, you will have a directory structure like:

     `Singular:2-0-2:ppc-MPW:Singular'
          Singular executable

     `Singular:2-0-2:ppc-MPW:libparse'
          parser for Singular libraries

     `Singular:2-0-2:LIB:'
          Singular libraries

     `Singular:2-0-2:LIB:gftables:'
          Singular gftables

     `Singular:2-0-2:doc:singular.idx'
          index of inline help

     `Singular:2-0-2:doc:singular.hlp'
          file for inline help

     `Singular:2-0-2:README'
          information of the distribution

     `Singular:2-0-2:README.hlml'

     `Singular:2-0-2:COPYING'
          license information

     `Singular:2-0-2:COPYING.html'

     `Singular:2-0-2:NEWS'
          news in the distribution

     `Singular:2-0-2:NEWS.html'

     `Singular:2-0-2:INSTALL'
          instructions like this file

     The SINGULAR libraries have a special form to work here.  Do not
     use the libraries from other distributions.  They are not
     compatible.  A supplementary file is `Singular-2-0-2-html.sea.hqx'
     which contains the html pages.  You can use this with a browser but
     not from the program SINGULAR.  The self-extracting archive will
     create the folder `html:' and you may extract it at
     `"{Boot}"Singular:2-0-2:'.

Installing MPW
==============

The final version of MPW is downloadable from Apple at
`ftp://ftp.apple.com/developer/Tool_Chest/Core_Mac_OS_Tools/MPW_etc./MPW-GM_Images/'.
Older versions of `Carbon.lib' may conflict with the latest MPW.  In
this case, you need to update `Carbon.lib' or work without it.

Restrictions
============

Some typical Unix features of SINGULAR are not working with MPW, e.g.
links and cooperation with other programs like XEmacs and xterm.

For any other troubles, please send an email to
<singular@mathematik.uni-kl.de> and include the header which is
displayed by starting up SINGULAR with the `-v' option, and a
description of your machine and operating system.


File: singular.hlp,  Node: Index,  Prev: Release Notes,  Up: Top

F Index
*******

 [index ]
* Menu:

* !:                                     Special characters.  (line  58)
* !=:                                    Special characters.  (line  42)
* != <1>:                                boolean expressions. (line   5)
* ":                                     Special characters.  (line  67)
* #:                                     Special characters.  (line 104)
* $:                                     Special characters.  (line 107)
* %:                                     Special characters.  (line  33)
* &&:                                    Special characters.  (line  61)
* && <1>:                                boolean operations.  (line   5)
* (:                                     Special characters.  (line  11)
* ):                                     Special characters.  (line  11)
* *:                                     Special characters.  (line  26)
* **:                                    Special characters.  (line  36)
* +:                                     Special characters.  (line  20)
* -:                                     Special characters.  (line  23)
* -allow-net:                            Command line options.
                                                              (line  26)
* -b:                                    Command line options.
                                                              (line 109)
* -batch:                                Command line options.
                                                              (line 109)
* -browser:                              Command line options.
                                                              (line  31)
* -c:                                    Command line options.
                                                              (line  73)
* -d:                                    Command line options.
                                                              (line  13)
* -e:                                    Command line options.
                                                              (line  17)
* -echo:                                 Command line options.
                                                              (line  17)
* -emacs:                                Command line options.
                                                              (line 128)
* -emacs-dir:                            Command line options.
                                                              (line 132)
* -emacs-load:                           Command line options.
                                                              (line 136)
* -execute:                              Command line options.
                                                              (line  73)
* -h:                                    Command line options.
                                                              (line  23)
* -help:                                 Command line options.
                                                              (line  23)
* -min-time:                             Command line options.
                                                              (line  95)
* -MPhost:                               Command line options.
                                                              (line 120)
* -MPport:                               Command line options.
                                                              (line 115)
* -no-out:                               Command line options.
                                                              (line  50)
* -no-rc:                                Command line options.
                                                              (line  39)
* -no-stdlib:                            Command line options.
                                                              (line  43)
* -no-tty:                               Command line options.
                                                              (line  53)
* -no-warn:                              Command line options.
                                                              (line  47)
* -q:                                    Command line options.
                                                              (line  57)
* -quiet:                                Command line options.
                                                              (line  57)
* -r:                                    Command line options.
                                                              (line  88)
* -random:                               Command line options.
                                                              (line  88)
* -sdb:                                  Command line options.
                                                              (line  13)
* -singular:                             Command line options.
                                                              (line 139)
* -ticks-per-sec:                        Command line options.
                                                              (line 103)
* -u:                                    Command line options.
                                                              (line  80)
* -user-option:                          Command line options.
                                                              (line  80)
* -v:                                    Command line options.
                                                              (line  63)
* -verbose:                              Command line options.
                                                              (line  63)
* ..:                                    Special characters.  (line  94)
* .singularrc file:                      Startup sequence.    (line  10)
* .singularrc file, no loading:          Command line options.
                                                              (line  39)
* /:                                     Special characters.  (line  29)
* //:                                    Special characters.  (line  76)
* // <1>:                                Special characters.  (line  79)
* // <2>:                                Special characters.  (line  82)
* ;:                                     Special characters.  (line  85)
* <:                                     Special characters.  (line  54)
* < <1>:                                 filecmd.             (line   5)
* <=:                                    Special characters.  (line  51)
* <= <1>:                                boolean expressions. (line   5)
* <>:                                    Special characters.  (line  42)
* <> <1>:                                boolean expressions. (line   5)
* =:                                     Special characters.  (line   8)
* ==:                                    Special characters.  (line  39)
* == <1>:                                boolean expressions. (line   5)
* >:                                     Special characters.  (line  48)
* >=:                                    Special characters.  (line  45)
* >= <1>:                                boolean expressions. (line   5)
* ?:                                     Special characters.  (line  73)
* ? <1>:                                 help.                (line  20)
* [:                                     Special characters.  (line  14)
* \:                                     Special characters.  (line  91)
* ]:                                     Special characters.  (line  14)
* ^:                                     Special characters.  (line  36)
* _:                                     Special characters.  (line  98)
* `:                                     Special characters.  (line  70)
* ||:                                    Special characters.  (line  64)
* || <1>:                                boolean operations.  (line   5)
* ~:                                     Special characters.  (line 101)
* ~ <1>:                                 ~.                   (line   5)
* a, ordering:                           Extra weight vector. (line   5)
* absValue:                              absValue.            (line   5)
* actionIsProper:                        actionIsProper.      (line   5)
* addcol:                                addcol.              (line   5)
* addrow:                                addrow.              (line   5)
* adjoint:                               adjoint.             (line   5)
* adjunction divisor:                    Adj_div.             (line  65)
* Adj_div:                               Adj_div.             (line   5)
* AGcode_L:                              AGcode_L.            (line   5)
* AGcode_Omega:                          AGcode_Omega.        (line   5)
* ainvar.lib:                            ainvar_lib.          (line   5)
* ainvar_lib:                            ainvar_lib.          (line   5)
* algDependent:                          algDependent.        (line   5)
* algebra.lib:                           algebra_lib.         (line   5)
* Algebraic dependence:                  Algebraic dependence.
                                                              (line   5)
* algebraic field extension:             splitring.           (line  35)
* Algebraic Geometry codes:              brnoeth_lib.         (line  47)
* algebra_containment:                   algebra_containment. (line   5)
* algebra_lib:                           algebra_lib.         (line   5)
* algorithm of Bigatti, La Scala and Robbiano: Bigatti and La Scala and Robbiano.
                                                              (line   5)
* algorithm of Conti and Traverso:       Conti and Traverso.  (line   5)
* algorithm of Di Biase and Urbanke:     Di Biase and Urbanke.
                                                              (line   5)
* algorithm of Hosten and Sturmfels:     Hosten and Sturmfels.
                                                              (line   5)
* algorithm of Pottier:                  Pottier.             (line   5)
* alg_kernel:                            alg_kernel.          (line   5)
* all.lib:                               all_lib.             (line   5)
* allowing net access:                   Command line options.
                                                              (line  26)
* allprint:                              allprint.            (line   5)
* allsquarefree:                         allsquarefree.       (line   5)
* all_lib:                               all_lib.             (line   5)
* and:                                   boolean operations.  (line   5)
* and <1>:                               Evaluation of logical expressions.
                                                              (line   5)
* Ann:                                   Ann.                 (line   5)
* annil:                                 annil.               (line   5)
* ArnoldAction:                          ArnoldAction.        (line   5)
* ASCII:                                 ASCII.               (line   5)
* ASCII links:                           ASCII links.         (line   5)
* attrib:                                attrib.              (line   5)
* A_L:                                   A_L.                 (line   5)
* A_Z:                                   A_Z.                 (line   5)
* Bachmann, Olaf:                        Preface.             (line 105)
* Background:                            Background.          (line   5)
* bareiss:                               bareiss.             (line   5)
* basicinvariants:                       basicinvariants.     (line   5)
* bernstein:                             bernstein.           (line   5)
* Bernstein polynomial:                  bernstein.           (line  21)
* betti:                                 betti.               (line   5)
* Betti number:                          Syzygies and resolutions.
                                                              (line  79)
* Bigatti-La Scala-Robbiano algorithm:   Bigatti and La Scala and Robbiano.
                                                              (line   5)
* BinDir:                                Loading of a library.
                                                              (line   5)
* binomial:                              binomial.            (line   5)
* block:                                 Flow control.        (line   5)
* block <1>:                             Control structures.  (line   5)
* blowup0:                               blowup0.             (line   5)
* boolean expressions:                   boolean expressions. (line   5)
* boolean operations:                    boolean operations.  (line   5)
* bracket:                               Usage of brackets.   (line   5)
* Branches of an Isolated Space Curve Singularity: Branches of an Isolated Space Curve Singularity.
                                                              (line   5)
* break:                                 break.               (line   5)
* break point:                           ~.                   (line   5)
* breakpoint:                            breakpoint.          (line   5)
* Brieskorn lattice:                     gaussman_lib.        (line  46)
* Brieskorn lattice <1>:                 gmsring.             (line  28)
* Brieskorn lattice <2>:                 gmsnf.               (line  23)
* Brieskorn lattice <3>:                 gmscoeffs.           (line  23)
* Brieskorn lattice <4>:                 bernstein.           (line  21)
* Brieskorn lattice <5>:                 monodromy.           (line  25)
* Brieskorn lattice <6>:                 spectrum.            (line  23)
* Brieskorn lattice <7>:                 sppairs.             (line  25)
* Brieskorn lattice <8>:                 vfilt.               (line  27)
* Brieskorn lattice <9>:                 vwfilt.              (line  29)
* Brieskorn lattice <10>:                tmatrix.             (line  22)
* Brieskorn lattice <11>:                endvfilt.            (line  26)
* Brieskorn lattice <12>:                mondromy_lib.        (line  33)
* Brill-Noether algorithm:               brnoeth_lib.         (line  47)
* BrillNoether:                          BrillNoether.        (line   5)
* brnoeth.lib:                           brnoeth_lib.         (line   5)
* brnoeth_lib:                           brnoeth_lib.         (line   5)
* browser, command line option:          Command line options.
                                                              (line  31)
* browser, setting the:                  system.              (line  80)
* browsers:                              The online help system.
                                                              (line  14)
* browsers, setting the:                 system.              (line  80)
* Buchberger algorithm for toric ideals: Buchberger algorithm.
                                                              (line   5)
* bug, ESingular:                        Unix installation instructions.
                                                              (line 195)
* busadj:                                busadj.              (line   5)
* C programming language:                Major differences to the C programming language.
                                                              (line   5)
* C, module ordering:                    Module orderings.    (line  25)
* c, module ordering:                    Module orderings.    (line  64)
* case:                                  No case or switch statement.
                                                              (line   5)
* category in a library:                 Format of a library. (line  56)
* Change of rings:                       Change of rings.     (line   5)
* changechar:                            changechar.          (line   5)
* changeord:                             changeord.           (line   5)
* changes:                               News and changes.    (line   5)
* changevar:                             changevar.           (line   5)
* char:                                  char.                (line   5)
* characteristic exponents:              invariants.          (line  55)
* Characteristic sets:                   Characteristic sets. (line   5)
* charpoly:                              charpoly.            (line   5)
* charstr:                               charstr.             (line   5)
* char_series:                           char_series.         (line   5)
* Classification:                        Classification.      (line   5)
* classify:                              classify.            (line   5)
* classify.lib:                          classify_lib.        (line   5)
* classify_lib:                          classify_lib.        (line   5)
* cleardenom:                            cleardenom.          (line   5)
* close:                                 close.               (line   5)
* closed_points:                         closed_points.       (line   5)
* closetex:                              closetex.            (line   5)
* closureFrac:                           closureFrac.         (line   5)
* closureRingtower:                      closureRingtower.    (line   5)
* clrSBmod:                              clrSBmod.            (line   5)
* CMtype:                                CMtype.              (line   5)
* Coding theory:                         Coding theory.       (line   5)
* coef:                                  coef.                (line   5)
* coefficient field:                     number.              (line   5)
* coeffs:                                coeffs.              (line   5)
* colred:                                colred.              (line   5)
* comma:                                 Usage of commas.     (line   5)
* Command line options:                  Command line options.
                                                              (line   5)
* command-line option, setting value of: system.              (line  80)
* command-line option, value of:         system.              (line  75)
* command-line options, print all values of: system.          (line  72)
* command-line options, short help:      Command line options.
                                                              (line  23)
* Commands:                              Functions and system variables.
                                                              (line   5)
* Commutative algebra:                   Commutative algebra. (line   5)
* completeReduction:                     completeReduction.   (line   5)
* complex:                               Rings and orderings. (line  23)
* Components of Windows installation:    Windows installation instructions.
                                                              (line  44)
* compress:                              compress.            (line   5)
* concat:                                concat.              (line   5)
* conductor, degree:                     invariants.          (line  55)
* ContainedQ:                            ContainedQ.          (line   5)
* content:                               content.             (line   5)
* Conti-Traverso algorithm:              Conti and Traverso.  (line   5)
* continue:                              continue.            (line   5)
* continue <1>:                          Behavior of continue.
                                                              (line   5)
* contract:                              contract.            (line   5)
* contributors:                          system.              (line  52)
* Control structures:                    Control structures.  (line   5)
* control_Matrix:                        control_Matrix.      (line   5)
* copyright:                             Preface.             (line   5)
* corank:                                corank.              (line   5)
* Critical points:                       Critical points.     (line   5)
* cup:                                   cup.                 (line   5)
* cupproduct:                            cupproduct.          (line   5)
* curve singularities:                   hnoether_lib.        (line  53)
* curve singularities <1>:               parametrizesing.     (line  21)
* Customization of the Emacs interface:  Customization of the Emacs interface.
                                                              (line   5)
* cyclic:                                cyclic.              (line   5)
* Cyclic roots:                          Cyclic roots.        (line   5)
* cyclotomic:                            cyclotomic.          (line   5)
* Data types:                            Data types.          (line   5)
* DBM links:                             DBM links.           (line   5)
* dbprint:                               dbprint.             (line   5)
* debugger:                              Source code debugger.
                                                              (line   5)
* debugging library code:                Source code debugger.
                                                              (line   5)
* Debugging tools:                       Debugging tools.     (line   5)
* debugLib, option:                      option.              (line 150)
* debug_log:                             debug_log.           (line   5)
* dec1var:                               dec1var.             (line   5)
* decodeSV:                              decodeSV.            (line   5)
* def:                                   def.                 (line   5)
* def declarations:                      def declarations.    (line   5)
* DefaultDir:                            Loading of a library.
                                                              (line   5)
* defined:                               defined.             (line   5)
* deform:                                deform.              (line   5)
* deform.lib:                            deform_lib.          (line   5)
* Deformations:                          Deformations.        (line   5)
* deform_lib:                            deform_lib.          (line   5)
* defring:                               defring.             (line   5)
* defringp:                              defringp.            (line   5)
* defrings:                              defrings.            (line   5)
* deg:                                   deg.                 (line   5)
* degBound:                              degBound.            (line   5)
* degree:                                degree.              (line   5)
* degree <1>:                            Miscellaneous oddities.
                                                              (line  51)
* degree lexicographical ordering:       Global orderings.    (line  38)
* degree reverse lexicographical ordering: Global orderings.  (line  24)
* degreepart:                            degreepart.          (line   5)
* delete:                                delete.              (line   5)
* deleteSublist:                         deleteSublist.       (line   5)
* delta:                                 delta.               (line   5)
* delta invariant:                       deltaLoc.            (line  36)
* delta invariant <1>:                   delta.               (line  26)
* delta invariant.:                      normal.              (line  37)
* deltaLoc:                              deltaLoc.            (line   5)
* Demo mode:                             Demo mode.           (line   5)
* denominator:                           denominator.         (line   5)
* Depth:                                 Depth.               (line   5)
* depth:                                 depth.               (line   5)
* derivate:                              derivate.            (line   5)
* det:                                   det.                 (line   5)
* detadj:                                detadj.              (line   5)
* det_B:                                 det_B.               (line   5)
* develop:                               develop.             (line   5)
* Di Biase-Urbanke algorithm:            Di Biase and Urbanke.
                                                              (line   5)
* diag:                                  diag.                (line   5)
* diag_test:                             diag_test.           (line   5)
* diff:                                  diff.                (line   5)
* dim:                                   dim.                 (line   5)
* dim_slocus:                            dim_slocus.          (line   5)
* discr:                                 discr.               (line   5)
* DISPLAY environment variable:          The online help system.
                                                              (line  90)
* displayHNE:                            displayHNE.          (line   5)
* displayInvariants:                     displayInvariants.   (line   5)
* displayMultsequence:                   displayMultsequence. (line   5)
* div:                                   int operations.      (line   5)
* div <1>:                               Miscellaneous oddities.
                                                              (line   6)
* division:                              division.            (line   5)
* Documentation of a library:            Documentation of a library.
                                                              (line   5)
* downloading:                           Downloading instructions.
                                                              (line   5)
* Dp, global ordering:                   Global orderings.    (line  38)
* dp, global ordering:                   Global orderings.    (line  24)
* Ds, local ordering:                    Local orderings.     (line  33)
* ds, local ordering:                    Local orderings.     (line  19)
* dsum:                                  dsum.                (line   5)
* dual_code:                             dual_code.           (line   5)
* dump:                                  dump.                (line   5)
* echo:                                  echo.                (line   5)
* Editing input:                         Editing input.       (line   5)
* Editing SINGULAR input files with Emacs: Editing SINGULAR input files with Emacs.
                                                              (line   5)
* EGCD:                                  EGCD.                (line   5)
* EGCDMain:                              EGCDMain.            (line   5)
* eigenvals:                             eigenvals.           (line   5)
* elim:                                  elim.                (line   5)
* elim.lib:                              elim_lib.            (line   5)
* elim1:                                 elim1.               (line   5)
* eliminate:                             eliminate.           (line   5)
* Elimination:                           Elimination.         (line   5)
* elimlinearpart:                        elimlinearpart.      (line   5)
* elimpart:                              elimpart.            (line   5)
* elimpartanyr:                          elimpartanyr.        (line   5)
* elim_lib:                              elim_lib.            (line   5)
* else:                                  if.                  (line   5)
* Emacs:                                 Emacs user interface.
                                                              (line   5)
* Emacs, a quick guide:                  A quick guide to Emacs.
                                                              (line   5)
* Emacs, customization of Singular mode: Customization of the Emacs interface.
                                                              (line   5)
* Emacs, editing Singular input files:   Editing SINGULAR input files with Emacs.
                                                              (line   5)
* Emacs, important commands:             Top 20 Emacs commands.
                                                              (line   5)
* Emacs, overview:                       A quick guide to Emacs.
                                                              (line   5)
* Emacs, running Singular under:         Running SINGULAR under Emacs.
                                                              (line   5)
* Emacs, Singular demo mode:             Demo mode.           (line   5)
* Emacs, user interface:                 Emacs user interface.
                                                              (line   5)
* endomorphism filtration:               endvfilt.            (line  26)
* endvfilt:                              endvfilt.            (line   5)
* environment variable, DISPLAY:         The online help system.
                                                              (line  90)
* equidim:                               equidim.             (line   5)
* equidimMax:                            equidimMax.          (line   5)
* equidimMaxEHV:                         equidimMaxEHV.       (line   5)
* equiRadical:                           equiRadical.         (line   5)
* equising.lib:                          equising_lib.        (line   5)
* equisingular stratum:                  esStratum.           (line  42)
* equisingularity ideal:                 esIdeal.             (line  26)
* equising_lib:                          equising_lib.        (line   5)
* ERROR:                                 ERROR.               (line   5)
* error recovery:                        The SINGULAR prompt. (line   5)
* esIdeal:                               esIdeal.             (line   5)
* ESingular, no prompt:                  Unix installation instructions.
                                                              (line 195)
* esStratum:                             esStratum.           (line   5)
* eval:                                  eval.                (line   5)
* evaluate_reynolds:                     evaluate_reynolds.   (line   5)
* Evaluation of logical expressions:     Evaluation of logical expressions.
                                                              (line   5)
* evnf:                                  evnf.                (line   5)
* example:                               example.             (line   5)
* Examples:                              Examples.            (line   5)
* Examples of ring declarations:         Examples of ring declarations.
                                                              (line   5)
* execute:                               execute.             (line   5)
* exit:                                  exit.                (line   5)
* exit <1>:                              quit.                (line   5)
* export:                                export.              (line   5)
* expression list:                       Data types.          (line   5)
* Ext:                                   Computation of Ext.  (line   5)
* Ext <1>:                               Ext.                 (line   5)
* extcurve:                              extcurve.            (line   5)
* extdevelop:                            extdevelop.          (line   5)
* extendring:                            extendring.          (line   5)
* extension of rings:                    splitring.           (line  35)
* extgcd:                                extgcd.              (line   5)
* Extra weight vector:                   Extra weight vector. (line   5)
* Ext_R:                                 Ext_R.               (line   5)
* facstd:                                facstd.              (line   5)
* Factor:                                Factor.              (line   5)
* factorH:                               factorH.             (line   5)
* factorial:                             factorial.           (line   5)
* Factorization:                         Factorization.       (line   5)
* factorize:                             factorize.           (line   5)
* FactorMain:                            FactorMain.          (line   5)
* factory:                               Preface.             (line   5)
* Fast lexicographical GB:               Fast lexicographical GB.
                                                              (line   5)
* fastelim:                              fastelim.            (line   5)
* fastHC, option:                        option.              (line  61)
* fetch:                                 fetch.               (line   5)
* fetchall:                              fetchall.            (line   5)
* fglm:                                  fglm.                (line   5)
* fglm <1>:                              stdfglm.             (line  21)
* fglmquot:                              fglmquot.            (line   5)
* fglm_solve:                            fglm_solve.          (line   5)
* fibonacci:                             fibonacci.           (line   5)
* field:                                 number.              (line   5)
* file, .singularrc:                     Startup sequence.    (line  10)
* filecmd:                               filecmd.             (line   5)
* find:                                  find.                (line   5)
* finduni:                               finduni.             (line   5)
* findvars:                              findvars.            (line   5)
* finite field:                          number.              (line   5)
* Finite fields:                         Finite fields.       (line   5)
* finitenessTest:                        finitenessTest.      (line   5)
* finvar.lib:                            finvar_lib.          (line   5)
* finvar_lib:                            finvar_lib.          (line   5)
* First steps:                           First steps.         (line   5)
* fitting:                               fitting.             (line   5)
* flatten:                               flatten.             (line   5)
* flatteningStrat:                       flatteningStrat.     (line   5)
* Flow control:                          Flow control.        (line   5)
* for:                                   for.                 (line   5)
* Format of a library:                   Format of a library. (line   5)
* Formatting output:                     Formatting output.   (line   5)
* fprintf:                               fprintf.             (line   5)
* Free resolution:                       Free resolution.     (line   5)
* freemodule:                            freemodule.          (line   5)
* freerank:                              freerank.            (line   5)
* Fru"bis-Kru"ger, Anne:                 Preface.             (line 105)
* Functions:                             Functions.           (line   5)
* furtherInvar:                          furtherInvar.        (line   5)
* further_hn_proc:                       further_hn_proc.     (line   5)
* galois field:                          number.              (line   5)
* Gauss-Manin connection:                Gauss-Manin connection.
                                                              (line   5)
* Gauss-Manin connection <1>:            gaussman_lib.        (line  46)
* Gauss-Manin connection <2>:            gmsring.             (line  28)
* Gauss-Manin connection <3>:            gmsnf.               (line  23)
* Gauss-Manin connection <4>:            gmscoeffs.           (line  23)
* Gauss-Manin connection <5>:            bernstein.           (line  21)
* Gauss-Manin connection <6>:            monodromy.           (line  25)
* Gauss-Manin connection <7>:            spectrum.            (line  23)
* Gauss-Manin connection <8>:            sppairs.             (line  25)
* Gauss-Manin connection <9>:            vfilt.               (line  27)
* Gauss-Manin connection <10>:           vwfilt.              (line  29)
* Gauss-Manin connection <11>:           tmatrix.             (line  22)
* Gauss-Manin connection <12>:           endvfilt.            (line  26)
* Gauss-Manin connection <13>:           mondromy_lib.        (line  33)
* Gauss-Manin connection <14>:           spectrumnd.          (line  27)
* gaussman.lib:                          gaussman_lib.        (line   5)
* gaussman_lib:                          gaussman_lib.        (line   5)
* gaussred:                              gaussred.            (line   5)
* gaussred_pivot:                        gaussred_pivot.      (line   5)
* gauss_col:                             gauss_col.           (line   5)
* gauss_nf:                              gauss_nf.            (line   5)
* gauss_row:                             gauss_row.           (line   5)
* gcd:                                   gcd.                 (line   5)
* gen:                                   gen.                 (line   5)
* General command syntax:                General command syntax.
                                                              (line   5)
* General concepts:                      General concepts.    (line   5)
* General purpose:                       General purpose.     (line   5)
* General syntax of a ring declaration:  General syntax of a ring declaration.
                                                              (line   5)
* general weighted lexicographical ordering: Local orderings. (line  53)
* general weighted reverse lexicographical ordering: Local orderings.
                                                              (line  46)
* general.lib:                           general_lib.         (line   5)
* general_lib:                           general_lib.         (line   5)
* genericid:                             genericid.           (line   5)
* genericmat:                            genericmat.          (line   5)
* genus:                                 genus.               (line   5)
* German Umlaute:                        Limitations.         (line  40)
* getData:                               getData.             (line   5)
* getdump:                               getdump.             (line   5)
* getenv:                                system.              (line  37)
* Getting started:                       Getting started.     (line   5)
* Global orderings:                      Global orderings.    (line   5)
* GMP:                                   Preface.             (line   5)
* gmscoeffs:                             gmscoeffs.           (line   5)
* gmsnf:                                 gmsnf.               (line   5)
* gmsring:                               gmsring.             (line   5)
* graphics.lib:                          graphics_lib.        (line   5)
* graphics_lib:                          graphics_lib.        (line   5)
* Grassmann, Hubert:                     Preface.             (line 108)
* Greuel, Gert-Martin:                   Preface.             (line 101)
* groebner:                              groebner.            (line   5)
* ground field:                          number.              (line   5)
* group_reynolds:                        group_reynolds.      (line   5)
* GTZmod:                                GTZmod.              (line   5)
* GTZopt:                                GTZopt.              (line   5)
* Guidelines for writing a library:      Guidelines for writing a library.
                                                              (line   5)
* G_a -Invariants:                       G_a -Invariants.     (line   5)
* H2basis:                               H2basis.             (line   5)
* Hamburger-Noether expansion:           hnoether_lib.        (line  53)
* Hamburger-Noether expansions:          Adj_div.             (line  65)
* hardware platform:                     system.              (line  33)
* Hcode:                                 Hcode.               (line   5)
* headStand:                             headStand.           (line   5)
* help:                                  help.                (line   5)
* help browsers:                         The online help system.
                                                              (line  14)
* help browsers, dummy:                  The online help system.
                                                              (line  40)
* help browsers, dummy <1>:              The online help system.
                                                              (line  46)
* help browsers, emacs:                  The online help system.
                                                              (line  43)
* help browsers, html:                   The online help system.
                                                              (line  21)
* help browsers, info:                   The online help system.
                                                              (line  37)
* help browsers, netscape:               The online help system.
                                                              (line  27)
* help browsers, setting command to use: The online help system.
                                                              (line  93)
* help browsers, setting the:            system.              (line  80)
* help browsers, tkinfo:                 The online help system.
                                                              (line  30)
* help browsers, winhlp:                 The online help system.
                                                              (line  24)
* help browsers, xinfo:                  The online help system.
                                                              (line  33)
* help string of a library:              The help string of a library.
                                                              (line   5)
* help string of a procedure:            The help string of procedures.
                                                              (line   5)
* help, accessing over the net:          Command line options.
                                                              (line  26)
* help, online help system:              The online help system.
                                                              (line   5)
* hessenberg:                            hessenberg.          (line   5)
* highcorner:                            highcorner.          (line   5)
* hilb:                                  hilb.                (line   5)
* Hilbert function:                      stdhilb.             (line  24)
* Hilbert function <1>:                  Hilbert function.    (line   5)
* Hilbert series:                        Hilbert function.    (line   5)
* HilbertSeries:                         HilbertSeries.       (line   5)
* HilbertWeights:                        HilbertWeights.      (line   5)
* hilbPoly:                              hilbPoly.            (line   5)
* hilbvec:                               hilbvec.             (line   5)
* hnexpansion:                           hnexpansion.         (line   5)
* hnoether.lib:                          hnoether_lib.        (line   5)
* hnoether_lib:                          hnoether_lib.        (line   5)
* Hom:                                   Hom.                 (line   5)
* HomJJ:                                 HomJJ.               (line   5)
* homog:                                 homog.               (line   5)
* homolog.lib:                           homolog_lib.         (line   5)
* homology:                              homology.            (line   5)
* homolog_lib:                           homolog_lib.         (line   5)
* Hosten-Sturmfels algorithm:            Hosten and Sturmfels.
                                                              (line   5)
* How to enter and exit:                 How to enter and exit.
                                                              (line   5)
* How to use this manual:                How to use this manual.
                                                              (line   5)
* howto, download:                       Downloading instructions.
                                                              (line   5)
* howto, install on Macintosh:           Macintosh installation instructions.
                                                              (line   5)
* howto, install on Unix:                Unix installation instructions.
                                                              (line   5)
* howto, install on Windows:             Windows installation instructions.
                                                              (line   5)
* hres:                                  hres.                (line   5)
* html, default help:                    The online help system.
                                                              (line  21)
* html, default help <1>:                The online help system.
                                                              (line  24)
* hypersurface singularity:              mondromy_lib.        (line  33)
* id2mod:                                id2mod.              (line   5)
* ideal:                                 ideal.               (line   5)
* ideal declarations:                    ideal declarations.  (line   5)
* ideal expressions:                     ideal expressions.   (line   5)
* Ideal membership:                      Standard bases.      (line  41)
* ideal operations:                      ideal operations.    (line   5)
* ideal related functions:               ideal related functions.
                                                              (line   5)
* ideal, toric:                          Toric ideals.        (line   5)
* ideals:                                Miscellaneous oddities.
                                                              (line  67)
* idealSimplify:                         idealSimplify.       (line   5)
* idealSplit:                            idealSplit.          (line   5)
* identifier:                            Identifier resolution.
                                                              (line   5)
* Identifiers, syntax of:                Names.               (line   5)
* if:                                    if.                  (line   5)
* ImageGroup:                            ImageGroup.          (line   5)
* ImageVariety:                          ImageVariety.        (line   5)
* image_of_variety:                      image_of_variety.    (line   5)
* imap:                                  imap.                (line   5)
* Imap, option:                          option.              (line 143)
* imapall:                               imapall.             (line   5)
* impart:                                impart.              (line   5)
* Implemented algorithms:                Implemented algorithms.
                                                              (line   5)
* IN:                                    lead.                (line  18)
* indepSet:                              indepSet.            (line   5)
* Index:                                 Index.               (line   5)
* indexed names:                         Special characters.  (line  11)
* indSet:                                indSet.              (line   5)
* info:                                  The online help system.
                                                              (line  37)
* info <1>:                              The online help system.
                                                              (line 135)
* INFO environment variable:             The online help system.
                                                              (line  93)
* info in a library:                     Format of a library. (line  15)
* info string of a library:              The help string of a library.
                                                              (line   5)
* init_debug:                            init_debug.          (line   5)
* inout.lib:                             inout_lib.           (line   5)
* inout_lib:                             inout_lib.           (line   5)
* input:                                 Input and output.    (line   5)
* insert:                                insert.              (line   5)
* instructions, downloading:             Downloading instructions.
                                                              (line   5)
* instructions, Macintosh installation:  Macintosh installation instructions.
                                                              (line   5)
* instructions, Unix installation:       Unix installation instructions.
                                                              (line   5)
* instructions, Windows installation:    Windows installation instructions.
                                                              (line   5)
* inSubring:                             inSubring.           (line   5)
* int:                                   int.                 (line   5)
* int declarations:                      int declarations.    (line   5)
* int expressions:                       int expressions.     (line   5)
* int operations:                        int operations.      (line   5)
* int related functions:                 int related functions.
                                                              (line   5)
* integer division:                      Miscellaneous oddities.
                                                              (line   6)
* integer programming:                   Integer programming. (line   5)
* Interactive use:                       Interactive use.     (line   5)
* interface, Emacs:                      Emacs user interface.
                                                              (line   5)
* internalfunctions:                     internalfunctions.   (line   5)
* interpolate:                           interpolate.         (line   5)
* interred:                              interred.            (line   5)
* Interrupting SINGULAR:                 Interrupting SINGULAR.
                                                              (line   5)
* intersect:                             intersect.           (line   5)
* intersection:                          intersection.        (line   5)
* intersection multiplicity:             intersection.        (line  20)
* intmat:                                intmat.              (line   5)
* intmat declarations:                   intmat declarations. (line   5)
* intmat expressions:                    intmat expressions.  (line   5)
* intmat operations:                     intmat operations.   (line   5)
* intmat related functions:              intmat related functions.
                                                              (line   5)
* intmat type cast:                      intmat type cast.    (line   5)
* intprog.lib:                           intprog_lib.         (line   5)
* intprog_lib:                           intprog_lib.         (line   5)
* Introduction:                          Introduction.        (line   5)
* intStrategy, option:                   option.              (line  66)
* intvec:                                intvec.              (line   5)
* intvec declarations:                   intvec declarations. (line   5)
* intvec expressions:                    intvec expressions.  (line   5)
* intvec operations:                     intvec operations.   (line   5)
* intvec related functions:              intvec related functions.
                                                              (line   5)
* Invariant theory:                      Invariant theory.    (line   5)
* InvariantQ:                            InvariantQ.          (line   5)
* InvariantRing:                         InvariantRing.       (line   5)
* invariantRing:                         invariantRing.       (line   5)
* invariants:                            invariants.          (line   5)
* Invariants of a finite group:          Invariants of a finite group.
                                                              (line   5)
* invariant_basis:                       invariant_basis.     (line   5)
* invariant_basis_reynolds:              invariant_basis_reynolds.
                                                              (line   5)
* invariant_ring:                        invariant_ring.      (line   5)
* invariant_ring_random:                 invariant_ring_random.
                                                              (line   5)
* inverse:                               inverse.             (line   5)
* inverse_B:                             inverse_B.           (line   5)
* inverse_L:                             inverse_L.           (line   5)
* InvertNumberMain:                      InvertNumberMain.    (line   5)
* invunit:                               invunit.             (line   5)
* irreducible power series:              is_irred.            (line  26)
* isCM:                                  isCM.                (line   5)
* isCMcod2:                              isCMcod2.            (line   5)
* isEquising:                            isEquising.          (line   5)
* isFlat:                                isFlat.              (line   5)
* isLocallyFree:                         isLocallyFree.       (line   5)
* isReg:                                 isReg.               (line   5)
* is_active:                             is_active.           (line   5)
* is_bijective:                          is_bijective.        (line   5)
* is_ci:                                 is_ci.               (line   5)
* is_complex:                            is_complex.          (line   5)
* is_homog:                              is_homog.            (line   5)
* is_injective:                          is_injective.        (line   5)
* is_irred:                              is_irred.            (line   5)
* is_is:                                 is_is.               (line   5)
* is_NND:                                is_NND.              (line   5)
* is_reg:                                is_reg.              (line   5)
* is_regs:                               is_regs.             (line   5)
* is_surjective:                         is_surjective.       (line   5)
* is_zero:                               is_zero.             (line   5)
* jacob:                                 jacob.               (line   5)
* jacoblift:                             jacoblift.           (line   5)
* jet:                                   jet.                 (line   5)
* jordan:                                jordan.              (line   5)
* jordanbasis:                           jordanbasis.         (line   5)
* jordanmatrix:                          jordanmatrix.        (line   5)
* jordannf:                              jordannf.            (line   5)
* katsura:                               katsura.             (line   5)
* kbase:                                 kbase.               (line   5)
* keepring:                              keepring.            (line   5)
* Keilen, Thomas:                        Preface.             (line 105)
* kernel:                                preimage.            (line   5)
* kernel <1>:                            kernel.              (line   5)
* Kernel of module homomorphisms:        Kernel of module homomorphisms.
                                                              (line   5)
* kill:                                  kill.                (line   5)
* killall:                               killall.             (line   5)
* killattrib:                            killattrib.          (line   5)
* kill_rings:                            kill_rings.          (line   5)
* kmemory:                               kmemory.             (line   5)
* kohom:                                 kohom.               (line   5)
* kontrahom:                             kontrahom.           (line   5)
* koszul:                                koszul.              (line   5)
* KoszulHomology:                        KoszulHomology.      (line   5)
* Kru"ger, Kai:                          Preface.             (line 105)
* KSpencerKernel:                        KSpencerKernel.      (line   5)
* laguerre:                              laguerre.            (line   5)
* laguerre_solve:                        laguerre_solve.      (line   5)
* latex.lib:                             latex_lib.           (line   5)
* latex_lib:                             latex_lib.           (line   5)
* lcm:                                   lcm.                 (line   5)
* lead:                                  lead.                (line   5)
* leadcoef:                              leadcoef.            (line   5)
* leadexp:                               leadexp.             (line   5)
* leadmonom:                             leadmonom.           (line   5)
* Levandovskyy, Viktor:                  Preface.             (line 105)
* lexicographical ordering:              Global orderings.    (line  10)
* lex_solve:                             lex_solve.           (line   5)
* LIB:                                   LIB.                 (line   5)
* lib2doc:                               lib2doc.             (line   5)
* libfac:                                Preface.             (line   5)
* libparse:                              libparse.            (line   5)
* Libraries:                             Libraries.           (line   5)
* library, documentation:                Documentation of a library.
                                                              (line   5)
* library, Guidelines for writing:       Guidelines for writing a library.
                                                              (line   5)
* library, help string:                  The help string of a library.
                                                              (line   5)
* library, info string:                  The help string of a library.
                                                              (line   5)
* library, info string <1>:              template_lib.        (line 138)
* library, procedures:                   Procedures in a library.
                                                              (line   5)
* library, template:                     template_lib.        (line   5)
* library, template.lib:                 template_lib.        (line 138)
* library, typesetting of help strings:  Typesetting of help strings.
                                                              (line   5)
* LIBs:                                  SINGULAR libraries.  (line   5)
* lift:                                  lift.                (line   5)
* liftstd:                               liftstd.             (line   5)
* lift_kbase:                            lift_kbase.          (line   5)
* lift_rel_kb:                           lift_rel_kb.         (line   5)
* Limitations:                           Limitations.         (line   5)
* linalg.lib:                            linalg_lib.          (line   5)
* linalg_lib:                            linalg_lib.          (line   5)
* Linear algebra:                        Linear algebra.      (line   5)
* linear code, dual:                     dual_code.           (line  18)
* linear code, systematic:               sys_code.            (line  28)
* LinearActionQ:                         LinearActionQ.       (line   5)
* LinearCombinationQ:                    LinearCombinationQ.  (line   5)
* LinearizeAction:                       LinearizeAction.     (line   5)
* linearpart:                            linearpart.          (line   5)
* link:                                  link.                (line   5)
* link <1>:                              Parallelization with MPtcp links.
                                                              (line   5)
* link declarations:                     link declarations.   (line   5)
* link expressions:                      link expressions.    (line   5)
* link related functions:                link related functions.
                                                              (line   5)
* list:                                  list.                (line   5)
* list declarations:                     list declarations.   (line   5)
* list expressions:                      list expressions.    (line   5)
* list operations:                       list operations.     (line   5)
* list related functions:                list related functions.
                                                              (line   5)
* listvar:                               listvar.             (line   5)
* Loading of a library:                  Loading of a library.
                                                              (line   5)
* loadLib, option:                       option.              (line 147)
* loadProc, option:                      option.              (line 153)
* local names:                           Names in procedures. (line   5)
* Local orderings:                       Local orderings.     (line   5)
* local weighted lexicographical ordering: Local orderings.   (line  53)
* local weighted reverse lexicographical ordering: Local orderings.
                                                              (line  46)
* localInvar:                            localInvar.          (line   5)
* locstd:                                locstd.              (line   5)
* Long coefficients:                     Long coefficients.   (line   5)
* Lossen, Christoph:                     Preface.             (line 105)
* lp, global ordering:                   Global orderings.    (line  10)
* lprint:                                lprint.              (line   5)
* lres:                                  lres.                (line   5)
* ls, local ordering:                    Local orderings.     (line  12)
* M, ordering:                           Matrix orderings.    (line   5)
* Macintosh installation:                Macintosh installation instructions.
                                                              (line   5)
* map:                                   map.                 (line   5)
* map declarations:                      map declarations.    (line   5)
* map expressions:                       map expressions.     (line   5)
* map operations:                        map operations.      (line   5)
* mapall:                                mapall.              (line   5)
* mapIsFinite:                           mapIsFinite.         (line   5)
* Mathematical background:               Mathematical background.
                                                              (line   5)
* mathematical objects:                  Representation of mathematical objects.
                                                              (line   5)
* mathinit:                              mathinit.            (line   5)
* matrix:                                matrix.              (line   5)
* matrix declarations:                   matrix declarations. (line   5)
* matrix expressions:                    matrix expressions.  (line   5)
* matrix operations:                     matrix operations.   (line   5)
* Matrix orderings:                      Matrix orderings.    (line   5)
* matrix related functions:              matrix related functions.
                                                              (line   5)
* matrix type cast:                      matrix type cast.    (line   5)
* matrix.lib:                            matrix_lib.          (line   5)
* matrixT1:                              matrixT1.            (line   5)
* matrix_lib:                            matrix_lib.          (line   5)
* mat_rk:                                mat_rk.              (line   5)
* Max:                                   Max.                 (line   5)
* maxcoef:                               maxcoef.             (line   5)
* maxdeg:                                maxdeg.              (line   5)
* maxdeg1:                               maxdeg1.             (line   5)
* maxideal:                              maxideal.            (line   5)
* mdouble:                               mdouble.             (line   5)
* mem, option:                           option.              (line 156)
* memory:                                memory.              (line   5)
* memory managment:                      memory.              (line   5)
* Milnor:                                Milnor and Tjurina.  (line   5)
* milnor:                                milnor.              (line   5)
* milnorcode:                            milnorcode.          (line   5)
* Min:                                   Min.                 (line   5)
* minAssChar:                            minAssChar.          (line   5)
* minAssGTZ:                             minAssGTZ.           (line   5)
* minbase:                               minbase.             (line   5)
* mindeg:                                mindeg.              (line   5)
* mindeg1:                               mindeg1.             (line   5)
* minimal display time, setting the:     system.              (line  80)
* MinimalDecomposition:                  MinimalDecomposition.
                                                              (line   5)
* minipoly:                              minipoly.            (line   5)
* minor:                                 minor.               (line   5)
* minpoly:                               minpoly.             (line   5)
* minres:                                minres.              (line   5)
* minRes, option:                        option.              (line  77)
* minSatMod:                             minSatMod.           (line   5)
* mixed Hodge structure:                 gaussman_lib.        (line  46)
* mixed Hodge structure <1>:             spectrum.            (line  23)
* mixed Hodge structure <2>:             sppairs.             (line  25)
* mixed Hodge structure <3>:             vfilt.               (line  27)
* mixed Hodge structure <4>:             vwfilt.              (line  29)
* mixed Hodge structure <5>:             tmatrix.             (line  22)
* mixed Hodge structure <6>:             endvfilt.            (line  26)
* mod:                                   int operations.      (line   5)
* mod <1>:                               number operations.   (line   5)
* mod2id:                                mod2id.              (line   5)
* modDec:                                modDec.              (line   5)
* ModEqn:                                ModEqn.              (line   5)
* module:                                module.              (line   5)
* module declarations:                   module declarations. (line   5)
* module expressions:                    module expressions.  (line   5)
* module operations:                     module operations.   (line   5)
* module ordering c:                     Module orderings.    (line  64)
* module ordering C:                     Module orderings.    (line  25)
* Module orderings:                      Module orderings.    (line   5)
* module related functions:              module related functions.
                                                              (line   5)
* Modules and and their annihilator:     Modules and their annihilator.
                                                              (line   5)
* modulesEqual:                          modulesEqual.        (line   5)
* module_containment:                    module_containment.  (line   5)
* modulo:                                modulo.              (line   5)
* mod_versal:                            mod_versal.          (line   5)
* molien:                                molien.              (line   5)
* mondromy.lib:                          mondromy_lib.        (line   5)
* mondromy_lib:                          mondromy_lib.        (line   5)
* monitor:                               monitor.             (line   5)
* monodromy:                             gaussman_lib.        (line  46)
* Monodromy:                             mondromy_lib.        (line  33)
* monodromy <1>:                         monodromy.           (line   5)
* monodromy <2>:                         monodromy.           (line  25)
* monodromyB:                            monodromyB.          (line   5)
* monomial orderings:                    General definitions for orderings.
                                                              (line   5)
* Monomial orderings:                    Monomial orderings.  (line   5)
* monomial orderings introduction:       Introduction to orderings.
                                                              (line   5)
* Monomial orderings, Term orderings:    Term orderings.      (line   5)
* monomials and precedence:              Miscellaneous oddities.
                                                              (line  39)
* morsesplit:                            morsesplit.          (line   5)
* MP:                                    Preface.             (line   5)
* MP links:                              MP links.            (line   5)
* MP, groebner basis computations:       groebner.            (line  33)
* MPfile links:                          MPfile links.        (line   5)
* mplot:                                 mplot.               (line   5)
* mpresmat:                              mpresmat.            (line   5)
* mprimdec.lib:                          mprimdec_lib.        (line   5)
* mprimdec_lib:                          mprimdec_lib.        (line   5)
* MPtcp:                                 Parallelization with MPtcp links.
                                                              (line   5)
* MPtcp links:                           MPtcp links.         (line   5)
* mp_res_mat:                            mp_res_mat.          (line   5)
* mregular.lib:                          mregular_lib.        (line   5)
* mregular_lib:                          mregular_lib.        (line   5)
* mres:                                  mres.                (line   5)
* mstd:                                  mstd.                (line   5)
* msum:                                  msum.                (line   5)
* mtripple:                              mtripple.            (line   5)
* mult:                                  mult.                (line   5)
* mult <1>:                              Miscellaneous oddities.
                                                              (line  51)
* multBound:                             multBound.           (line   5)
* multcol:                               multcol.             (line   5)
* multiplicities, sequence of:           invariants.          (line  55)
* multiplicity sequence:                 multsequence.        (line  53)
* multrow:                               multrow.             (line   5)
* multsequence:                          multsequence.        (line   5)
* nameof:                                nameof.              (line   5)
* names:                                 names.               (line   5)
* Names:                                 Names.               (line   5)
* Names in procedures:                   Names in procedures. (line   5)
* nblocks:                               system.              (line  63)
* ncols:                                 ncols.               (line   5)
* negative degree lexicographical ordering: Local orderings.  (line  33)
* negative degree reverse lexicographical ordering: Local orderings.
                                                              (line  19)
* negative lexicographical ordering:     Local orderings.     (line  12)
* net access:                            Command line options.
                                                              (line  26)
* netscape:                              The online help system.
                                                              (line  27)
* NETSCAPE environment variable:         The online help system.
                                                              (line  93)
* Neumann, Wolfgang:                     Preface.             (line 108)
* newline:                               string.              (line   5)
* news:                                  News and changes.    (line   5)
* Newton non-degenerate:                 is_NND.              (line  19)
* Newton polygon:                        newtonpoly.          (line  22)
* Newton polygon <1>:                    is_NND.              (line  19)
* newtonpoly:                            newtonpoly.          (line   5)
* NF:                                    reduce.              (line   5)
* nf_icis:                               nf_icis.             (line   5)
* noether:                               noether.             (line   5)
* noetherNormal:                         noetherNormal.       (line   5)
* non-english special characters:        Limitations.         (line  40)
* none, option:                          option.              (line  53)
* normal:                                normal.              (line   5)
* Normal form:                           Standard bases.      (line  24)
* normal.lib:                            normal_lib.          (line   5)
* normalform:                            normalform.          (line   5)
* normalI:                               normalI.             (line   5)
* Normalization:                         Normalization.       (line   5)
* normalization:                         normal.              (line  37)
* normalization <1>:                     parametrize.         (line  24)
* normalization <2>:                     parametrizepd.       (line  23)
* normalize:                             normalize.           (line   5)
* normal_lib:                            normal_lib.          (line   5)
* not:                                   boolean operations.  (line   5)
* notBuckets, option:                    option.              (line  89)
* notRegularity, option:                 option.              (line  82)
* notSugar, option:                      option.              (line  86)
* npars:                                 npars.               (line   5)
* nres:                                  nres.                (line   5)
* nrows:                                 nrows.               (line   5)
* nselect:                               nselect.             (line   5)
* NSplaces:                              NSplaces.            (line   5)
* ntsolve.lib:                           ntsolve_lib.         (line   5)
* ntsolve_lib:                           ntsolve_lib.         (line   5)
* nt_solve:                              nt_solve.            (line   5)
* NullCone:                              NullCone.            (line   5)
* number:                                number.              (line   5)
* number declarations:                   number declarations. (line   5)
* number expressions:                    number expressions.  (line   5)
* number operations:                     number operations.   (line   5)
* number related functions:              number related functions.
                                                              (line   5)
* number_e:                              number_e.            (line   5)
* number_pi:                             number_pi.           (line   5)
* numerator:                             numerator.           (line   5)
* nvars:                                 nvars.               (line   5)
* Objects:                               Objects.             (line   5)
* oldStd, option:                        option.              (line  72)
* online help:                           The online help system.
                                                              (line   5)
* open:                                  open.                (line   5)
* opentex:                               opentex.             (line   5)
* opposite Hodge filtration:             tmatrix.             (line  22)
* option:                                option.              (line   5)
* or:                                    boolean operations.  (line   5)
* or <1>:                                Evaluation of logical expressions.
                                                              (line   5)
* orbit_variety:                         orbit_variety.       (line   5)
* ord:                                   ord.                 (line   5)
* orderings:                             General definitions for orderings.
                                                              (line   5)
* orderings introduction:                Introduction to orderings.
                                                              (line   5)
* orderings, a:                          Extra weight vector. (line   5)
* orderings, global:                     Global orderings.    (line   5)
* orderings, local:                      Local orderings.     (line   5)
* orderings, M:                          Matrix orderings.    (line   5)
* orderings, product:                    Product orderings.   (line   5)
* ordstr:                                ordstr.              (line   5)
* ord_test:                              ord_test.            (line   5)
* orthogonalize:                         orthogonalize.       (line   5)
* outer:                                 outer.               (line   5)
* output:                                Input and output.    (line   5)
* par:                                   par.                 (line   5)
* Parallelization:                       Parallelization with MPtcp links.
                                                              (line   5)
* paramet.lib:                           paramet_lib.         (line   5)
* Parameter list:                        Parameter list.      (line   5)
* parameter, as numbers:                 number.              (line   5)
* Parameters:                            Parameters.          (line   5)
* parametrisation:                       parametrisation.     (line   5)
* parametrization:                       parametrisation.     (line  39)
* parametrization <1>:                   parametrize.         (line  24)
* parametrization <2>:                   parametrizepd.       (line  23)
* parametrization <3>:                   parametrizesing.     (line  21)
* parametrize:                           parametrize.         (line   5)
* parametrizepd:                         parametrizepd.       (line   5)
* parametrizesing:                       parametrizesing.     (line   5)
* paramet_lib:                           paramet_lib.         (line   5)
* pardeg:                                pardeg.              (line   5)
* parstr:                                parstr.              (line   5)
* partial_molien:                        partial_molien.      (line   5)
* path:                                  Loading of a library.
                                                              (line   5)
* pause:                                 pause.               (line   5)
* permcol:                               permcol.             (line   5)
* permrow:                               permrow.             (line   5)
* permute_L:                             permute_L.           (line   5)
* Pfister, Gerhard:                      Preface.             (line 101)
* pid:                                   system.              (line  30)
* plot:                                  plot.                (line   5)
* pmat:                                  pmat.                (line   5)
* Pohl, Wilfred:                         Preface.             (line 105)
* Polar curves:                          Polar curves.        (line   5)
* poly:                                  poly.                (line   5)
* poly declarations:                     poly declarations.   (line   5)
* poly expressions:                      poly expressions.    (line   5)
* poly operations:                       poly operations.     (line   5)
* poly related functions:                poly related functions.
                                                              (line   5)
* poly.lib:                              poly_lib.            (line   5)
* Polynomial data:                       Polynomial data.     (line   5)
* poly_lib:                              poly_lib.            (line   5)
* posweight:                             posweight.           (line   5)
* pos_def:                               pos_def.             (line   5)
* Pottier algorithm:                     Pottier.             (line   5)
* power:                                 power.               (line   5)
* power_products:                        power_products.      (line   5)
* preComp:                               preComp.             (line   5)
* Preface:                               Preface.             (line   5)
* preimage:                              preimage.            (line   5)
* prepareAss:                            prepareAss.          (line   5)
* prepMat:                               prepMat.             (line   5)
* prepSV:                                prepSV.              (line   5)
* presolve.lib:                          presolve_lib.        (line   5)
* presolve_lib:                          presolve_lib.        (line   5)
* Primary decomposition:                 Primary decomposition.
                                                              (line   5)
* primary_char0:                         primary_char0.       (line   5)
* primary_char0_no_molien:               primary_char0_no_molien.
                                                              (line   5)
* primary_char0_no_molien_random:        primary_char0_no_molien_random.
                                                              (line   5)
* primary_char0_random:                  primary_char0_random.
                                                              (line   5)
* primary_charp:                         primary_charp.       (line   5)
* primary_charp_no_molien:               primary_charp_no_molien.
                                                              (line   5)
* primary_charp_no_molien_random:        primary_charp_no_molien_random.
                                                              (line   5)
* primary_charp_random:                  primary_charp_random.
                                                              (line   5)
* primary_charp_without:                 primary_charp_without.
                                                              (line   5)
* primary_charp_without_random:          primary_charp_without_random.
                                                              (line   5)
* primary_invariants:                    primary_invariants.  (line   5)
* primary_invariants_random:             primary_invariants_random.
                                                              (line   5)
* primdec.lib:                           primdec_lib.         (line   5)
* PrimdecA:                              PrimdecA.            (line   5)
* PrimdecB:                              PrimdecB.            (line   5)
* primdecGTZ:                            primdecGTZ.          (line   5)
* primdecSY:                             primdecSY.           (line   5)
* primdec_lib:                           primdec_lib.         (line   5)
* prime:                                 prime.               (line   5)
* primeClosure:                          primeClosure.        (line   5)
* primecoeffs:                           primecoeffs.         (line   5)
* primefactors:                          primefactors.        (line   5)
* primes:                                primes.              (line   5)
* primitiv.lib:                          primitiv_lib.        (line   5)
* primitive:                             primitive.           (line   5)
* primitive element:                     primitive.           (line  34)
* primitive_extra:                       primitive_extra.     (line   5)
* primitiv_lib:                          primitiv_lib.        (line   5)
* primTest:                              primTest.            (line   5)
* print:                                 print.               (line   5)
* printf:                                printf.              (line   5)
* printlevel:                            printlevel.          (line   5)
* proc:                                  proc.                (line   5)
* proc declaration:                      proc declaration.    (line   5)
* Procedure commands:                    Procedure commands.  (line   5)
* Procedure definition:                  Procedure definition.
                                                              (line   5)
* procedure, ASCII help:                 mdouble.             (line  19)
* procedure, ASCII/Texinfo help:         msum.                (line  37)
* procedure, texinfo help:               mtripple.            (line  23)
* Procedures:                            Procedures.          (line   5)
* Procedures and LIB:                    Procedures and LIB.  (line   5)
* Procedures and libraries:              Procedures and libraries.
                                                              (line   5)
* Procedures in a library:               Procedures in a library.
                                                              (line   5)
* procedures, help string:               The help string of procedures.
                                                              (line   5)
* procedures, static:                    Procedure definition.
                                                              (line   5)
* product:                               product.             (line   5)
* Product orderings:                     Product orderings.   (line   5)
* progress watch:                        option.              (line  95)
* prompt:                                The SINGULAR prompt. (line   5)
* prompt, option:                        option.              (line 159)
* prot, option:                          option.              (line  95)
* protocoll of computations:             option.              (line  95)
* prune:                                 prune.               (line   5)
* Puiseux expansion:                     hnoether_lib.        (line  53)
* Puiseux pairs:                         Puiseux pairs.       (line   5)
* Puiseux pairs <1>:                     invariants.          (line  55)
* puiseux2generators:                    puiseux2generators.  (line   5)
* qhmatrix:                              qhmatrix.            (line   5)
* qhmoduli.lib:                          qhmoduli_lib.        (line   5)
* qhmoduli_lib:                          qhmoduli_lib.        (line   5)
* qhspectrum:                            qhspectrum.          (line   5)
* qhweight:                              qhweight.            (line   5)
* qring:                                 qring.               (line   5)
* qring <1>:                             Miscellaneous oddities.
                                                              (line  73)
* qring declaration:                     qring declaration.   (line   5)
* quickclass:                            quickclass.          (line   5)
* quit:                                  quit.                (line   5)
* quot:                                  quot.                (line   5)
* quote:                                 quote.               (line   5)
* quotient:                              quotient.            (line   5)
* Quotient:                              Quotient.            (line   5)
* QuotientEquations:                     QuotientEquations.   (line   5)
* QuotientMain:                          QuotientMain.        (line   5)
* radical:                               radical.             (line   5)
* radicalEHV:                            radicalEHV.          (line   5)
* rad_con:                               rad_con.             (line   5)
* random:                                random.              (line   5)
* random number generator, seed:         system.              (line  80)
* random.lib:                            random_lib.          (line   5)
* randomBinomial:                        randomBinomial.      (line   5)
* randomid:                              randomid.            (line   5)
* randomLast:                            randomLast.          (line   5)
* randommat:                             randommat.           (line   5)
* random_lib:                            random_lib.          (line   5)
* read:                                  read.                (line   5)
* reading, option:                       option.              (line 162)
* readline:                              Preface.             (line   5)
* real:                                  Rings and orderings. (line  23)
* redefine, option:                      option.              (line 165)
* redSB, option:                         option.              (line 101)
* redTail, option:                       option.              (line 105)
* redThrough, option:                    option.              (line 111)
* reduce:                                reduce.              (line   5)
* reduced standard basis:                option.              (line 101)
* reduction:                             reduction.           (line   5)
* ReesAlgebra:                           ReesAlgebra.         (line   5)
* reesclos.lib:                          reesclos_lib.        (line   5)
* reesclos_lib:                          reesclos_lib.        (line   5)
* References:                            References.          (line   5)
* regularity:                            regularity.          (line   5)
* regularity <1>:                        Syzygies and resolutions.
                                                              (line  79)
* reg_CM:                                reg_CM.              (line   5)
* reg_curve:                             reg_curve.           (line   5)
* reg_moncurve:                          reg_moncurve.        (line   5)
* relative_orbit_variety:                relative_orbit_variety.
                                                              (line   5)
* Release Notes:                         Release Notes.       (line   5)
* relweight:                             relweight.           (line   5)
* Remainder:                             Remainder.           (line   5)
* RemainderMain:                         RemainderMain.       (line   5)
* repart:                                repart.              (line   5)
* representation, math objects:          Representation of mathematical objects.
                                                              (line   5)
* res:                                   res.                 (line   5)
* reservedName:                          reservedName.        (line   5)
* Resolution:                            Resolution.          (line   5)
* resolution:                            resolution.          (line   5)
* resolution declarations:               resolution declarations.
                                                              (line   5)
* resolution expressions:                resolution expressions.
                                                              (line   5)
* resolution related functions:          resolution related functions.
                                                              (line   5)
* resolution, computation of:            res.                 (line   7)
* resolution, hilbert-driven:            hres.                (line   5)
* resolution, La Scala's method:         lres.                (line   5)
* resultant:                             resultant.           (line   5)
* return:                                return.              (line   5)
* return type of procedures:             Return type of procedures.
                                                              (line   5)
* returnSB, option:                      option.              (line  56)
* reverse lexicographical ordering:      Global orderings.    (line  17)
* ReynoldsImage:                         ReynoldsImage.       (line   5)
* ReynoldsOperator:                      ReynoldsOperator.    (line   5)
* reynolds_molien:                       reynolds_molien.     (line   5)
* ring:                                  ring.                (line   5)
* ring declarations:                     ring declarations.   (line   5)
* ring operations:                       ring operations.     (line   5)
* ring related functions:                ring related functions.
                                                              (line   5)
* ring.lib:                              ring_lib.            (line   5)
* Rings and orderings:                   Rings and orderings. (line   5)
* Rings and standard bases:              Rings and standard bases.
                                                              (line   5)
* ringtensor:                            ringtensor.          (line   5)
* ringweights:                           ringweights.         (line   5)
* ring_lib:                              ring_lib.            (line   5)
* rinvar.lib:                            rinvar_lib.          (line   5)
* rinvar_lib:                            rinvar_lib.          (line   5)
* rMacaulay:                             rMacaulay.           (line   5)
* rmx:                                   rmx.                 (line   5)
* rm_unitcol:                            rm_unitcol.          (line   5)
* rm_unitrow:                            rm_unitrow.          (line   5)
* RootDir:                               Loading of a library.
                                                              (line   5)
* Roots:                                 Roots.               (line   5)
* RootsMain:                             RootsMain.           (line   5)
* rowred:                                rowred.              (line   5)
* rp, global ordering:                   Global orderings.    (line  17)
* Running SINGULAR under Emacs:          Running SINGULAR under Emacs.
                                                              (line   5)
* rvalue:                                No rvalue of increments and assignments.
                                                              (line   5)
* rvar:                                  rvar.                (line   5)
* SameQ:                                 SameQ.               (line   5)
* sat:                                   sat.                 (line   5)
* Saturation:                            Saturation.          (line   5)
* Schmidt, Jens:                         Preface.             (line 108)
* Scho"nemann, Hans:                     Preface.             (line 101)
* Schulze, Mathias:                      Preface.             (line 105)
* SDB breakpoint:                        Source code debugger.
                                                              (line  55)
* SDB debugger:                          Source code debugger.
                                                              (line  55)
* sdb, source code debugger:             Source code debugger.
                                                              (line   5)
* SearchPath:                            Loading of a library.
                                                              (line   5)
* secondary_and_irreducibles_no_molien:  secondary_and_irreducibles_no_molien.
                                                              (line   5)
* secondary_char0:                       secondary_char0.     (line   5)
* secondary_charp:                       secondary_charp.     (line   5)
* secondary_not_cohen_macaulay:          secondary_not_cohen_macaulay.
                                                              (line   5)
* secondary_no_molien:                   secondary_no_molien. (line   5)
* select:                                select.              (line   5)
* select1:                               select1.             (line   5)
* semiCMcod2:                            semiCMcod2.          (line   5)
* semigroup of values:                   invariants.          (line  55)
* separateHNE:                           separateHNE.         (line   5)
* separator:                             separator.           (line   5)
* setenv:                                system.              (line  41)
* sethnering:                            sethnering.          (line   5)
* setring:                               setring.             (line   5)
* sh:                                    system.              (line  26)
* short:                                 short.               (line   5)
* shortid:                               shortid.             (line   5)
* show:                                  show.                (line   5)
* showrecursive:                         showrecursive.       (line   5)
* simplex:                               simplex.             (line   5)
* simplexOut:                            simplexOut.          (line   5)
* simplify:                              simplify.            (line   5)
* SimplifyIdeal:                         SimplifyIdeal.       (line   5)
* sing.lib:                              sing_lib.            (line   5)
* Singular:                              system.              (line  68)
* SINGULAR libraries:                    SINGULAR libraries.  (line   5)
* Singular, customization of Emacs user interface: Customization of the Emacs interface.
                                                              (line   5)
* Singular, demo mode:                   Demo mode.           (line   5)
* Singular, editing input files with Emacs: Editing SINGULAR input files with Emacs.
                                                              (line   5)
* Singular, important commands of Emacs interface: Top 20 Emacs commands.
                                                              (line   5)
* Singular, running within Emacs:        Running SINGULAR under Emacs.
                                                              (line   5)
* SINGULARHIST:                          Editing input.       (line   5)
* singularities:                         gaussman_lib.        (line  46)
* Singularities:                         Singularities.       (line   5)
* singularities <1>:                     gmsring.             (line  28)
* singularities <2>:                     gmsnf.               (line  23)
* singularities <3>:                     gmscoeffs.           (line  23)
* singularities <4>:                     bernstein.           (line  21)
* singularities <5>:                     monodromy.           (line  25)
* singularities <6>:                     spectrum.            (line  23)
* singularities <7>:                     sppairs.             (line  25)
* singularities <8>:                     vfilt.               (line  27)
* singularities <9>:                     vwfilt.              (line  29)
* singularities <10>:                    tmatrix.             (line  22)
* singularities <11>:                    endvfilt.            (line  26)
* singularities <12>:                    spectrumnd.          (line  27)
* singularity:                           singularity.         (line   5)
* SINGULARPATH:                          Loading of a library.
                                                              (line   5)
* singularrc:                            Startup sequence.    (line  10)
* sing_lib:                              sing_lib.            (line   5)
* size:                                  size.                (line   5)
* size <1>:                              Miscellaneous oddities.
                                                              (line  67)
* skewmat:                               skewmat.             (line   5)
* sleep:                                 status.              (line   5)
* slocus:                                slocus.              (line   5)
* solve:                                 solve.               (line   5)
* solve.lib:                             solve_lib.           (line   5)
* solvelinearpart:                       solvelinearpart.     (line   5)
* solve_IP:                              solve_IP.            (line   5)
* solve_lib:                             solve_lib.           (line   5)
* sort:                                  sort.                (line   5)
* sortandmap:                            sortandmap.          (line   5)
* sortier:                               sortier.             (line   5)
* sortvars:                              sortvars.            (line   5)
* sortvec:                               sortvec.             (line   5)
* Source code debugger, invocation:      Command line options.
                                                              (line  13)
* source code debugger, sdb:             Source code debugger.
                                                              (line   5)
* spadd:                                 spadd.               (line   5)
* sparseid:                              sparseid.            (line   5)
* sparsemat:                             sparsemat.           (line   5)
* sparsematrix:                          sparsematrix.        (line   5)
* sparsepoly:                            sparsepoly.          (line   5)
* sparsetriag:                           sparsetriag.         (line   5)
* spcurve.lib:                           spcurve_lib.         (line   5)
* spcurve_lib:                           spcurve_lib.         (line   5)
* Special characters:                    Special characters.  (line   5)
* special characters, non-english:       Limitations.         (line  40)
* specialModulesEqual:                   specialModulesEqual. (line   5)
* spectral pairs:                        gaussman_lib.        (line  46)
* spectral pairs <1>:                    sppairs.             (line  25)
* spectral pairs <2>:                    vwfilt.              (line  29)
* spectrum:                              gaussman_lib.        (line  46)
* spectrum <1>:                          spectrum.            (line   5)
* spectrum <2>:                          spectrum.            (line  23)
* spectrum <3>:                          sppairs.             (line  25)
* spectrum <4>:                          vfilt.               (line  27)
* spectrum <5>:                          vwfilt.              (line  29)
* spectrum <6>:                          spectrumnd.          (line  27)
* spectrum.lib:                          spectrum_lib.        (line   5)
* spectrumnd:                            spectrumnd.          (line   5)
* spectrum_lib:                          spectrum_lib.        (line   5)
* spgamma:                               spgamma.             (line   5)
* spgeomgenus:                           spgeomgenus.         (line   5)
* spissemicont:                          spissemicont.        (line   5)
* split:                                 split.               (line   5)
* splitring:                             splitring.           (line   5)
* splitting:                             splitting.           (line   5)
* spmilnor:                              spmilnor.            (line   5)
* spmul:                                 spmul.               (line   5)
* spnf:                                  spnf.                (line   5)
* sppairs:                               sppairs.             (line   5)
* sppnf:                                 sppnf.               (line   5)
* sppprint:                              sppprint.            (line   5)
* spprint:                               spprint.             (line   5)
* sprintf:                               sprintf.             (line   5)
* spsemicont:                            spsemicont.          (line   5)
* spsub:                                 spsub.               (line   5)
* SQFRNorm:                              SQFRNorm.            (line   5)
* SQFRNormMain:                          SQFRNormMain.        (line   5)
* squarefree:                            squarefree.          (line   5)
* sres:                                  sres.                (line   5)
* StabEqn:                               StabEqn.             (line   5)
* StabEqnId:                             StabEqnId.           (line   5)
* StabOrder:                             StabOrder.           (line   5)
* staircase:                             staircase.           (line   5)
* Standard bases:                        Standard bases.      (line   5)
* standard.lib:                          standard_lib.        (line  10)
* standard_lib:                          standard_lib.        (line  10)
* Startup sequence:                      Startup sequence.    (line   5)
* static procedures:                     Procedure definition.
                                                              (line   5)
* status:                                status.              (line   5)
* std:                                   std.                 (line   5)
* stdfglm:                               stdfglm.             (line   5)
* stdhilb:                               stdhilb.             (line   5)
* stdModulesEqual:                       stdModulesEqual.     (line   5)
* Stobbe, Ru"diger:                      Preface.             (line 108)
* stratify:                              stratify.            (line   5)
* stratify.lib:                          stratify_lib.        (line   5)
* stratify_lib:                          stratify_lib.        (line   5)
* string:                                string.              (line   5)
* string <1>:                            Miscellaneous oddities.
                                                              (line  83)
* string declarations:                   string declarations. (line   5)
* string expressions:                    string expressions.  (line   5)
* string operations:                     string operations.   (line   5)
* string related functions:              string related functions.
                                                              (line   5)
* string type cast:                      string type cast.    (line   5)
* stripHNE:                              stripHNE.            (line   5)
* submat:                                submat.              (line   5)
* subrInterred:                          subrInterred.        (line   5)
* subst:                                 subst.               (line   5)
* substitute:                            substitute.          (line   5)
* sugarCrit, option:                     option.              (line 118)
* sum:                                   sum.                 (line   5)
* surf.lib:                              surf_lib.            (line   5)
* surf_lib:                              surf_lib.            (line   5)
* SuSE, ESingular bug:                   Unix installation instructions.
                                                              (line 195)
* suspend:                               status.              (line   5)
* SV-decoding algorithm:                 decodeSV.            (line  25)
* SV-decoding algorithm, preprocessing:  prepSV.              (line  57)
* swap:                                  swap.                (line   5)
* switch:                                No case or switch statement.
                                                              (line   5)
* Symbolic-numerical solving:            Symbolic-numerical solving.
                                                              (line   5)
* symmat:                                symmat.              (line   5)
* sym_gauss:                             sym_gauss.           (line   5)
* system:                                system.              (line   5)
* System variables:                      System variables.    (line   5)
* system, -:                             system.              (line  72)
* system, -long_option_name:             system.              (line  75)
* system, -long_option_name=value:       system.              (line  80)
* system, browsers:                      system.              (line  88)
* system, contributors:                  system.              (line  52)
* system, gen:                           system.              (line  56)
* system, getenv:                        system.              (line  37)
* system, nblocks:                       system.              (line  63)
* system, pid:                           system.              (line  30)
* system, setenv:                        system.              (line  41)
* system, sh:                            system.              (line  26)
* system, Singular:                      system.              (line  68)
* system, tty:                           system.              (line  46)
* system, uname:                         system.              (line  33)
* system, version:                       system.              (line  49)
* sys_code:                              sys_code.            (line   5)
* syz:                                   syz.                 (line   5)
* Syzygies and resolutions:              Syzygies and resolutions.
                                                              (line   5)
* T1:                                    T1 and T2.           (line   5)
* T2:                                    T1 and T2.           (line   5)
* tab:                                   tab.                 (line   5)
* Table:                                 Table.               (line   5)
* tangentcone:                           tangentcone.         (line   5)
* tau_es:                                tau_es.              (line   5)
* Template for writing a library:        template_lib.        (line   5)
* template.lib:                          template_lib.        (line 128)
* template.lib <1>:                      template_lib.        (line 138)
* template_lib:                          template_lib.        (line   5)
* template_lib <1>:                      template_lib.        (line 128)
* tensor:                                tensor.              (line   5)
* tensorMod:                             tensorMod.           (line   5)
* term orderings:                        General definitions for orderings.
                                                              (line   5)
* term orderings introduction:           Introduction to orderings.
                                                              (line   5)
* testPrimary:                           testPrimary.         (line   5)
* tex:                                   tex.                 (line   5)
* texdemo:                               texdemo.             (line   5)
* texfactorize:                          texfactorize.        (line   5)
* texmap:                                texmap.              (line   5)
* texname:                               texname.             (line   5)
* texobj:                                texobj.              (line   5)
* texpoly:                               texpoly.             (line   5)
* texproc:                               texproc.             (line   5)
* texring:                               texring.             (line   5)
* The online help system:                The online help system.
                                                              (line   5)
* The SINGULAR language:                 The SINGULAR language.
                                                              (line   5)
* time limit on computations:            groebner.            (line  33)
* timeFactorize:                         timeFactorize.       (line   5)
* timer:                                 timer.               (line   5)
* timer <1>:                             rtimer.              (line   5)
* timer resolution, setting the:         system.              (line  80)
* timeStd:                               timeStd.             (line   5)
* tjurina:                               tjurina.             (line   5)
* Tjurina:                               Milnor and Tjurina.  (line   5)
* Tjurina <1>:                           Tjurina.             (line   5)
* Tjurina number:                        deltaLoc.            (line  36)
* tkinfo:                                The online help system.
                                                              (line  30)
* tmatrix:                               tmatrix.             (line   5)
* tolessvars:                            tolessvars.          (line   5)
* Top 20 Emacs commands:                 Top 20 Emacs commands.
                                                              (line   5)
* Tor:                                   Tor.                 (line   5)
* toric ideals:                          Toric ideals.        (line   5)
* Toric ideals and integer programming:  Toric ideals and integer programming.
                                                              (line   5)
* toric.lib:                             toric_lib.           (line   5)
* toric_ideal:                           toric_ideal.         (line   5)
* toric_lib:                             toric_lib.           (line   5)
* toric_std:                             toric_std.           (line   5)
* trace:                                 trace.               (line   5)
* TRACE:                                 TRACE var.           (line   5)
* TransferIdeal:                         TransferIdeal.       (line   5)
* transpose:                             transpose.           (line   5)
* triagmatrix:                           triagmatrix.         (line   5)
* triang.lib:                            triang_lib.          (line   5)
* triangL:                               triangL.             (line   5)
* triangLfak:                            triangLfak.          (line   5)
* triangLf_solve:                        triangLf_solve.      (line   5)
* triangL_solve:                         triangL_solve.       (line   5)
* triangM:                               triangM.             (line   5)
* triangMH:                              triangMH.            (line   5)
* triangM_solve:                         triangM_solve.       (line   5)
* triang_lib:                            triang_lib.          (line   5)
* triang_solve:                          triang_solve.        (line   5)
* Tricks and pitfalls:                   Tricks and pitfalls. (line   5)
* triMNewton:                            triMNewton.          (line   5)
* tty:                                   system.              (line  46)
* type:                                  type.                (line   5)
* Type casting:                          Type conversion and casting.
                                                              (line  45)
* Type conversion:                       Type conversion and casting.
                                                              (line   8)
* typeof:                                typeof.              (line   5)
* Typesetting of help strings:           Typesetting of help strings.
                                                              (line   5)
* T_1:                                   T_1.                 (line   5)
* T_12:                                  T_12.                (line   5)
* T_2:                                   T_2.                 (line   5)
* uname:                                 system.              (line  33)
* unitmat:                               unitmat.             (line   5)
* Unix installation:                     Unix installation instructions.
                                                              (line   5)
* untyped definitions:                   def.                 (line   5)
* UpperMonomials:                        UpperMonomials.      (line   5)
* uressolve:                             uressolve.           (line   5)
* ures_solve:                            ures_solve.          (line   5)
* usage, option:                         option.              (line 168)
* user interface, Emacs:                 Emacs user interface.
                                                              (line   5)
* U_D_O:                                 U_D_O.               (line   5)
* V-filtration:                          gaussman_lib.        (line  46)
* V-filtration <1>:                      spectrum.            (line  23)
* V-filtration <2>:                      sppairs.             (line  25)
* V-filtration <3>:                      vfilt.               (line  27)
* V-filtration <4>:                      vwfilt.              (line  29)
* V-filtration <5>:                      tmatrix.             (line  22)
* V-filtration <6>:                      endvfilt.            (line  26)
* valvars:                               valvars.             (line   5)
* vandermonde:                           vandermonde.         (line   5)
* var:                                   var.                 (line   5)
* varstr:                                varstr.              (line   5)
* vdim:                                  vdim.                (line   5)
* vector:                                vector.              (line   5)
* vector declarations:                   vector declarations. (line   5)
* vector expressions:                    vector expressions.  (line   5)
* vector operations:                     vector operations.   (line   5)
* vector related functions:              vector related functions.
                                                              (line   5)
* versal:                                versal.              (line   5)
* version:                               system.              (line  49)
* version in a library:                  Format of a library. (line  40)
* vfilt:                                 vfilt.               (line   5)
* Visualization:                         Visualization.       (line   5)
* voice:                                 voice.               (line   5)
* vwfilt:                                vwfilt.              (line   5)
* watchdog:                              watchdog.            (line   5)
* wedge:                                 wedge.               (line   5)
* Weierstrass:                           Weierstrass.         (line   5)
* Weierstrass semigroup:                 brnoeth_lib.         (line  47)
* weight:                                weight.              (line   5)
* weight filtration:                     gaussman_lib.        (line  46)
* weight filtration <1>:                 sppairs.             (line  25)
* weight filtration <2>:                 vwfilt.              (line  29)
* weighted lexicographical ordering:     Global orderings.    (line  59)
* weighted reverse lexicographical ordering: Global orderings.
                                                              (line  52)
* weightM, option:                       option.              (line 122)
* Westenberger, Eric:                    Preface.             (line 105)
* which:                                 which.               (line   5)
* while:                                 while.               (line   5)
* Wichmann, Tim:                         Preface.             (line 105)
* Windows installation:                  Windows installation instructions.
                                                              (line   5)
* Windows installation, components:      Windows installation instructions.
                                                              (line  44)
* wp, global ordering:                   Global orderings.    (line  52)
* WP, global ordering:                   Global orderings.    (line  59)
* write:                                 write.               (line   5)
* writelist:                             writelist.           (line   5)
* ws, local ordering:                    Local orderings.     (line  46)
* Ws, local ordering:                    Local orderings.     (line  53)
* xdvi:                                  xdvi.                (line   5)
* xinfo:                                 The online help system.
                                                              (line  33)
* XINFO environment variable:            The online help system.
                                                              (line  93)
* XTERM environment variable:            The online help system.
                                                              (line  93)
* zerodec:                               zerodec.             (line   5)
* zeroMod:                               zeroMod.             (line   5)
* zeroOpt:                               zeroOpt.             (line   5)
* ZeroSet:                               ZeroSet.             (line   5)
* zeroset.lib:                           zeroset_lib.         (line   5)
* zeroset_lib:                           zeroset_lib.         (line   5)

<font size="-1">
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; User manual for <a href="http://www.singular.uni-kl.de/"><i>Singular</i></a> version 2-0-4, October 2002,
generated by <a href="http://www.nongnu.org/texi2html/"><i>texi2html</i></a>.
</font>

</body>
</html>
