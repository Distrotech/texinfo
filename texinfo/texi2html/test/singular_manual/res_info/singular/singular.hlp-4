This is singular.hlp, produced by makeinfo version 4.13 from
singular.texi.


File: singular.hlp,  Node: Ext,  Next: fitting,  Prev: Ext_R,  Up: homolog_lib

D.4.3.5 Ext
...........

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     Ext(v,M,N[,any]); v int resp. intvec, M,N modules

*Compute:*
     A presentation of Ext^k(M',N'); for k=v[1],v[2],... where
     M'=coker(M) and N'=coker(N). Let

                 0 <-- M' <-- F0 <-M-- F1 <-- F2 <--... ,   
                 0 <-- N' <-- G0 <--N- G1

     be a free resolution of M', resp. a presentation of N'. Consider
     the commutative diagram

                     0                  0                  0
                     |^                 |^                 |^
             --> Hom(Fk-1,N') -Ak-> Hom(Fk,N') -Ak+1-> Hom(Fk+1,N')
                     |^                 |^                 |^
             --> Hom(Fk-1,G0) -Ak-> Hom(Fk,G0) -Ak+1-> Hom(Fk+1,G0)
                                        |^                 |^
                                        |C                 |B
                                    Hom(Fk,G1) ------> Hom(Fk+1,G1)

                (Ak,Ak+1 induced by M and B,C induced by N).

     Let K=modulo(Ak+1,B), J=module(Ak)+module(C) and Ext=modulo(K,J),
     then we have exact sequences

              R^p --K-> Hom(Fk,G0) --Ak+1-> Hom(Fk+1,G0)/im(B),

              R^q -Ext-> R^p --K-> Hom(Fk,G0)/(im(Ak)+im(C)).

     Hence, Ext presents Ext^k(M',N').

*Return:*
     - module Ext, a presentation of Ext^k(M',N') if v is of type int
     - a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.
     - In case of a third argument of any type return a list l:

                  l[1] = module Ext/list of Ext^k
                  l[2] = SB of Ext/list of SB of Ext^k
                  l[3] = matrix/list of matrices, each representing a kbase of Ext^k
                            (if finite dimensional)

*Display:*
     printlevel >=0: dimension, vdim of Ext^k for each k (default).
     printlevel >=1: matrices Ak, Ak+1 and kbase of Ext^k in Hom(Fk,G0)
     (if finite dimensional)

*Note:*
     In order to compute Ext^k(M,N) use the command
     Ext(k,syz(M),syz(N)); or: list P=mres(M,2); list Q=mres(N,2);
     Ext(k,P[2],Q[2]);

*Example:*
     LIB "homolog.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 0,(x,y),dp;
     ideal i    = x2-y3;
     ideal j    = x2-y5;
     list E     = Ext(0..2,i,j);    // Ext^k(r/i,r/j) for k=0,1,2 over r
     ==> // Computing Ext^0 (help Ext; gives an explanation):
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
     ==> // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
     ==> // then Hom(F0,G0)-->Hom(F1,G0) is given by:
     ==> y3-x2
     ==> // and Hom(F-1,G0) + Hom(F0,G1)-->Hom(F0,G0) is given by:
     ==> 0,-y5+x2
     ==> 
     ==> // dimension of Ext^0:  -1
     ==> 
     ==> // Computing Ext^1 (help Ext; gives an explanation):
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
     ==> // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
     ==> // then Hom(F1,G0)-->Hom(F2,G0) is given by:
     ==> 0
     ==> // and Hom(F0,G0) + Hom(F1,G1)-->Hom(F1,G0) is given by:
     ==> y3-x2,-y5+x2
     ==> 
     ==> // dimension of Ext^1:  0
     ==> // vdim of Ext^1:       10
     ==> 
     ==> // Computing Ext^2 (help Ext; gives an explanation):
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
     ==> // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
     ==> // then Hom(F2,G0)-->Hom(F3,G0) is given by:
     ==> 1
     ==> // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
     ==> 0,-y5+x2
     ==> 
     ==> // dimension of Ext^2:  -1
     ==> 
     qring R    = std(i);
     ideal j    = fetch(r,j);
     module M   = [-x,y],[-y2,x];
     printlevel = 2;
     module E1  = Ext(1,M,j);       // Ext^1(R^2/M,R/j) over R=r/i
     ==> // Computing Ext^1 (help Ext; gives an explanation):
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
     ==> // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
     ==> // then Hom(F1,G0)-->Hom(F2,G0) is given by:
     ==> x, -y,
     ==> y2,-x 
     ==> // and Hom(F0,G0) + Hom(F1,G1)-->Hom(F1,G0) is given by:
     ==> x, -y,-y5+x2,0,    
     ==> y2,-x,0,     -y5+x2
     ==> 
     ==> // dimension of Ext^1:  -1
     ==> 
     list l     = Ext(4,M,M,1);     // Ext^4(R^2/M,R^2/M) over R=r/i
     ==> // Computing Ext^4 (help Ext; gives an explanation):
     ==> // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
     ==> // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
     ==> // then Hom(F4,G0)-->Hom(F5,G0) is given by:
     ==> x, -y,0, 0, 
     ==> y2,-x,0, 0, 
     ==> 0, 0, x, -y,
     ==> 0, 0, y2,-x 
     ==> // and Hom(F3,G0) + Hom(F4,G1)-->Hom(F4,G0) is given by:
     ==> x, -y,0, 0, -x,0, -y2,0,  
     ==> y2,-x,0, 0, 0, -x,0,  -y2,
     ==> 0, 0, x, -y,y, 0, x,  0,  
     ==> 0, 0, y2,-x,0, y, 0,  x   
     ==> 
     ==> // dimension of Ext^4:  0
     ==> // vdim of Ext^4:       2
     ==> 
     ==> // columns of matrix are kbase of Ext^4 in Hom(F4,G0)
     ==> 1,0,
     ==> 0,y,
     ==> 0,1,
     ==> 1,0 
     ==> 
     ==> // element 1 of kbase of Ext^4 in Hom(F4,G0)
     ==> // as matrix: F4-->G0
     ==> 1,0,
     ==> 0,1 
     ==> // element 2 of kbase of Ext^4 in Hom(F4,G0)
     ==> // as matrix: F4-->G0
     ==> 0,y,
     ==> 1,0 
     ==> 
     printlevel = p;


File: singular.hlp,  Node: fitting,  Next: flatteningStrat,  Prev: Ext,  Up: homolog_lib

D.4.3.6 fitting
...............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     fitting (M,n); M module, n int

*Return:*
     ideal, (standard basis of) n-th Fitting ideal of M'=coker(M).

*Example:*
     LIB "homolog.lib";
     ring R=0,x(0..4),dp;
     matrix M[2][4]=x(0),x(1),x(2),x(3),x(1),x(2),x(3),x(4);
     print(M);
     ==> x(0),x(1),x(2),x(3),
     ==> x(1),x(2),x(3),x(4) 
     fitting(M,-1);
     ==> _[1]=0
     fitting(M,0);
     ==> _[1]=x(3)^2-x(2)*x(4)
     ==> _[2]=x(2)*x(3)-x(1)*x(4)
     ==> _[3]=x(1)*x(3)-x(0)*x(4)
     ==> _[4]=x(2)^2-x(0)*x(4)
     ==> _[5]=x(1)*x(2)-x(0)*x(3)
     ==> _[6]=x(1)^2-x(0)*x(2)
     fitting(M,1);
     ==> _[1]=x(4)
     ==> _[2]=x(3)
     ==> _[3]=x(2)
     ==> _[4]=x(1)
     ==> _[5]=x(0)
     fitting(M,2);
     ==> _[1]=1


File: singular.hlp,  Node: flatteningStrat,  Next: Hom,  Prev: fitting,  Up: homolog_lib

D.4.3.7 flatteningStrat
.......................

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     flatteningStrat(M); M module

*Return:*
     list of ideals.
     The list entries L[1],...,L[r] describe the flattening
     stratification of M'=coker(M): setting L[0]=0, L[r+1]=1, the
     flattening stratification is given by the open sets
     Spec(A/V(L[i-1])) \ V(L[i]), i=1,...,r+1 (A = basering).

*Note:*
     for more information see the book 'A Singular Introduction to
     Commutative Algebra' (by Greuel/Pfister, Springer 2002).

*Example:*
     LIB "homolog.lib";
     ring A = 0,x(0..4),dp;
     // presentation matrix:
     matrix M[2][4] = x(0),x(1),x(2),x(3),x(1),x(2),x(3),x(4);
     list L = flatteningStrat(M);
     L;
     ==> [1]:
     ==>    _[1]=x(3)^2-x(2)*x(4)
     ==>    _[2]=x(2)*x(3)-x(1)*x(4)
     ==>    _[3]=x(1)*x(3)-x(0)*x(4)
     ==>    _[4]=x(2)^2-x(0)*x(4)
     ==>    _[5]=x(1)*x(2)-x(0)*x(3)
     ==>    _[6]=x(1)^2-x(0)*x(2)
     ==> [2]:
     ==>    _[1]=x(4)
     ==>    _[2]=x(3)
     ==>    _[3]=x(2)
     ==>    _[4]=x(1)
     ==>    _[5]=x(0)


File: singular.hlp,  Node: Hom,  Next: homology,  Prev: flatteningStrat,  Up: homolog_lib

D.4.3.8 Hom
...........

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     Hom(M,N,[any]); M,N=modules

*Compute:*
     A presentation of Hom(M',N'), M'=coker(M), N'=coker(N) as follows:
     let

             F1 --M-> F0 -->M' --> 0,    G1 --N-> G0 --> N' --> 0  

     be presentations of M' and N'. Consider

                                            0               0
                                            |^              |^
                 0 --> Hom(M',N') ----> Hom(F0,N') ----> Hom(F1,N')
                                            |^              |^
            (A:  induced by M)          Hom(F0,G0) --A-> Hom(F1,G0)
                                            |^              |^
            (B,C:induced by N)              |C              |B
                                        Hom(F0,G1) ----> Hom(F1,G1)

     Let D=modulo(A,B) and Hom=modulo(D,C), then we have exact sequences

             R^p  --D-> Hom(F0,G0) --A-> Hom(F1,G0)/im(B),

           R^q -Hom-> R^p --D-> Hom(F0,G0)/im(C) --A-> Hom(F1,G0)/im(B).

     Hence Hom presents Hom(M',N')

*Return:*
     module Hom, a presentation of Hom(M',N'), resp., in case of 3
     arguments, a list l (of size <=3):

                - l[1] = Hom
                - l[2] = SB of Hom
                - l[3] = kbase of coker(Hom) (if finite dimensional, not 0),
                         represented by elements in Hom(F0,G0) via mapping D

*Display:*
     printlevel >=0: (affine) dimension of Hom (default)
     printlevel >=1: D and C and kbase of coker(Hom) in Hom(F0,G0)
     printlevel >=2: elements of kbase of coker(Hom) as matrix :F0->G0

*Note:*
     DISPLAY is as described only for a direct call of 'Hom'. Calling
     'Hom' from another proc has the same effect as decreasing
     printlevel by 1.

*Example:*
     LIB "homolog.lib";
     int p     = printlevel;
     printlevel= 1;   //in 'example proc' printlevel has to be increased by 1
     ring r    = 0,(x,y),dp;
     ideal i   = x2-y3,xy;
     qring q   = std(i);
     ideal i   = fetch(r,i);
     module M  = [-x,y],[-y2,x],[x3];
     module H  = Hom(M,i);
     ==> // dimension of Hom:  0
     ==> // vdim of Hom:       5
     ==> 
     ==> // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
     ==> // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
     ==> y,x, 0,
     ==> x,y2,x2
     ==> // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
     ==> -y3+x2,0,     xy,0,
     ==> 0,     -y3+x2,0, xy
     ==> 
     print(H);
     ==> 0, x, 0,y2,0, 
     ==> y, 0, 0,-x,x2,
     ==> -1,-1,x,0, 0  
     printlevel= 2;
     list L    = Hom(M,i,1);"";
     ==> // dimension of Hom:  0
     ==> // vdim of Hom:       5
     ==> 
     ==> // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
     ==> // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
     ==> y,x, 0,
     ==> x,y2,x2
     ==> // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
     ==> -y3+x2,0,     xy,0,
     ==> 0,     -y3+x2,0, xy
     ==> 
     ==> // element 1 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
     ==> y2,xy
     ==> // element 2 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
     ==> y,x
     ==> // element 3 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
     ==> x2,xy2
     ==> // element 4 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
     ==> x,y2
     ==> // element 5 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
     ==> 0,x2
     ==> 
     printlevel=1;
     ring s    = 3,(x,y,z),(c,dp);
     ideal i   = jacob(ideal(x2+y5+z4));
     qring rq=std(i);
     matrix M[2][2]=xy,x3,5y,4z,x2;
     matrix N[3][2]=x2,x,y3,3xz,x2z,z;
     print(M);
     ==> xy,x3,
     ==> -y,z  
     print(N);
     ==> x2, x,
     ==> y3, 0,
     ==> x2z,z 
     list l=Hom(M,N,1);
     ==> // dimension of Hom:  0
     ==> // vdim of Hom:       16
     ==> 
     ==> // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
     ==> // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
     ==> 0,0, 0,0, 0,   0,0,   1,
     ==> 0,0, 0,0, 0,   0,y3z2,0,
     ==> 0,0, 0,0, 0,   1,0,   0,
     ==> 0,0, 0,y3,y2z2,0,0,   0,
     ==> 0,0, 1,0, 0,   0,0,   0,
     ==> z,y3,0,0, 0,   0,0,   0 
     ==> // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
     ==> x2, 0,  x,0,
     ==> 0,  x2, 0,x,
     ==> y3, 0,  0,0,
     ==> 0,  y3, 0,0,
     ==> x2z,0,  z,0,
     ==> 0,  x2z,0,z 
     ==> 
     ==> // columns of matrix are kbase of Hom in Hom(F0,G0)
     ==> 0, 0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,0,   
     ==> 0, 0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,y3z2,
     ==> 0, 0, 0, 0,0,0,   y2z2,yz2,z2,y2z,yz,z,y2,y,1,0,   
     ==> 0, 0, 0, 0,0,y2z2,0,   0,  0, 0,  0, 0,0, 0,0,0,   
     ==> 0, y3,y2,y,1,0,   0,   0,  0, 0,  0, 0,0, 0,0,0,   
     ==> y3,0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,0    
     printlevel = p;


File: singular.hlp,  Node: homology,  Next: isCM,  Prev: Hom,  Up: homolog_lib

D.4.3.9 homology
................

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     homology(A,B,M,N);

*Compute:*
     Let M and N be submodules of R^m and R^n presenting M'=R^m/M,
     N'=R^n/N (R=basering) and let A,B matrices inducing maps

              R^k --A--> R^m --B--> R^n.

     Compute a presentation of the module

              ker(B)/im(A) := ker(M'/im(A) --B--> N'/im(BM)+im(BA)).

     If B induces a map M'->N' (i.e BM=0) and if im(A) is contained in
     ker(B) (that is, BA=0) then ker(B)/im(A) is the homology of the
     complex

              R^k--A-->M'--B-->N'. 

*Return:*
     module H, a presentation of ker(B)/im(A).

*Note:*
     homology returns a free module of rank m if ker(B)=im(A).

*Example:*
     LIB "homolog.lib";
     ring r;
     ideal id=maxideal(4);
     qring qr=std(id);
     module N=maxideal(3)*freemodule(2);
     module M=maxideal(2)*freemodule(2);
     module B=[2x,0],[x,y],[z2,y];
     module A=M;
     module H=homology(A,B,M,N);
     H=std(H);
     // dimension of homology:
     dim(H);
     ==> 0
     // vector space dimension: 
     vdim(H);
     ==> 19
     ring s=0,x,ds;
     qring qs=std(x4);
     module A=[x];
     module B=A;
     module M=[x3];
     module N=M;
     homology(A,B,M,N);
     ==> _[1]=gen(1)


File: singular.hlp,  Node: isCM,  Next: isFlat,  Prev: homology,  Up: homolog_lib

D.4.3.10 isCM
.............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     isCM(M); M module

*Return:*
     1 if M'=coker(M) is Cohen-Macaulay;
     0 if this is not the case.

*Assume:*
     basering is local.

*Example:*
     LIB "homolog.lib";
     ring R=0,(x,y,z),ds;  // local ring R = Q[x,y,z]_<x,y,z>
     module M=xz,yz,z2;   
     isCM(M);             // test if R/<xz,yz,z2> is Cohen-Macaulay
     ==> 0
     M=x2+y2,z7;          // test if R/<x2+y2,z7> is Cohen-Macaulay
     isCM(M);
     ==> 1


File: singular.hlp,  Node: isFlat,  Next: isLocallyFree,  Prev: isCM,  Up: homolog_lib

D.4.3.11 isFlat
...............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     isFlat(M); M module

*Return:*
     1 if M'=coker(M) is flat;
     0 if this is not the case.

*Example:*
     LIB "homolog.lib";
     ring A = 0,(x,y),dp;
     matrix M[3][3] = x-1,y,x,x,x+1,y,x2,xy+x+1,x2+y;
     print(M);
     ==> x-1,y,     x,  
     ==> x,  x+1,   y,  
     ==> x2, xy+x+1,x2+y
     isFlat(M);             // coker(M) is not flat over A=Q[x,y]
     ==> 0
     qring B = std(x2+x-y);   // the ring B=Q[x,y]/<x2+x-y>
     matrix M = fetch(A,M);
     isFlat(M);             // coker(M) is flat over B
     ==> 1
     setring A;
     qring C = std(x2+x+y);   // the ring C=Q[x,y]/<x2+x+y>
     matrix M = fetch(A,M);
     isFlat(M);             // coker(M) is not flat over C
     ==> 0


File: singular.hlp,  Node: isLocallyFree,  Next: isReg,  Prev: isFlat,  Up: homolog_lib

D.4.3.12 isLocallyFree
......................

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     isLocallyFree(M,r); M module, r int

*Return:*
     1 if M'=coker(M) is locally free of constant rank r;
     0 if this is not the case.

*Example:*
     LIB "homolog.lib";
     ring R=0,(x,y,z),dp;
     matrix M[2][3];     // the presentation matrix
     M=x-1,y-1,z,y-1,x-2,x;
     ideal I=fitting(M,0); // 0-th Fitting ideal of coker(M)
     qring Q=I;
     matrix M=fetch(R,M);
     isLocallyFree(M,1); // as R/I-module, coker(M) is locally free of rk 1
     ==> 1
     isLocallyFree(M,0);
     ==> 0


File: singular.hlp,  Node: isReg,  Next: kernel,  Prev: isLocallyFree,  Up: homolog_lib

D.4.3.13 isReg
..............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     isReg(I,M); I ideal, M module

*Return:*
     1 if given (ordered) list of generators for I is coker(M)-sequence;
     0 if this is not the case.

*Example:*
     LIB "homolog.lib";
     ring R = 0,(x,y,z),dp;
     ideal I = x*(y-1),y,z*(y-1);
     isReg(I,0);             // given list of generators is Q[x,y,z]-sequence
     ==> 1
     I = x*(y-1),z*(y-1),y;  // change sorting of generators 
     isReg(I,0);
     ==> 0
     ring r = 0,(x,y,z),ds;  // local ring
     ideal I=fetch(R,I);
     isReg(I,0);             // result independent of sorting of generators
     ==> 1


File: singular.hlp,  Node: kernel,  Next: kohom,  Prev: isReg,  Up: homolog_lib

D.4.3.14 kernel
...............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     kernel(A,M,N);

*Compute:*
     Let M and N be submodules of R^m and R^n, presenting M'=R^m/M,
     N'=R^n/N (R=basering), and let A:R^m->R^n be a matrix inducing a
     map A':M'->N'. Then kernel(A,M,N); computes a presentation K of
     ker(A') as in the commutative diagram:

                    ker(A') --->  M' --A'--> N'
                       |^         |^         |^
                       |          |          |
                       R^r  ---> R^m --A--> R^n
                       |^         |^         |^
                       |K         |M         |N
                       |          |          |
                       R^s  ---> R^p -----> R^q

*Return:*
     module K, a presentation of ker(A':coker(M)->coker(N)).

*Example:*
     LIB "homolog.lib";
     ring r;
     module N=[2x,x],[0,y];
     module M=maxideal(1)*freemodule(2);
     matrix A[2][2]=2x,0,x,y,z2,y;
     module K=kernel(A,M,N);
     // dimension of kernel:  
     dim(std(K));
     ==> 0
     // vector space dimension of kernel: 
     vdim(std(K));
     ==> 2
     print(K);
     ==> z,0,y,0,x,0,
     ==> 0,z,0,y,0,x 


File: singular.hlp,  Node: kohom,  Next: kontrahom,  Prev: kernel,  Up: homolog_lib

D.4.3.15 kohom
..............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     kohom(A,k); A=matrix, k=integer

*Return:*
     matrix Hom(R^k,A), i.e. let A be a matrix defining a map F1->F2 of
     free R-modules, then the matrix of Hom(R^k,F1)->Hom(R^k,F2) is
     computed (R=basering).

*Example:*
     LIB "homolog.lib";
     ring r;
     matrix n[2][3]=x,y,5,z,77,33;
     print(kohom(n,3));
     ==> x,0,0,y, 0, 0, 5, 0, 0,
     ==> 0,x,0,0, y, 0, 0, 5, 0,
     ==> 0,0,x,0, 0, y, 0, 0, 5,
     ==> z,0,0,77,0, 0, 33,0, 0,
     ==> 0,z,0,0, 77,0, 0, 33,0,
     ==> 0,0,z,0, 0, 77,0, 0, 33


File: singular.hlp,  Node: kontrahom,  Next: KoszulHomology,  Prev: kohom,  Up: homolog_lib

D.4.3.16 kontrahom
..................

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     kontrahom(A,k); A=matrix, k=integer

*Return:*
     matrix Hom(A,R^k), i.e. let A be a matrix defining a map F1->F2 of
     free R-modules, then the matrix of Hom(F2,R^k)->Hom(F1,R^k) is
     computed (R=basering).

*Example:*
     LIB "homolog.lib";
     ring r;
     matrix n[2][3]=x,y,5,z,77,33;
     print(kontrahom(n,3));
     ==> x,z, 0,0, 0,0, 
     ==> y,77,0,0, 0,0, 
     ==> 5,33,0,0, 0,0, 
     ==> 0,0, x,z, 0,0, 
     ==> 0,0, y,77,0,0, 
     ==> 0,0, 5,33,0,0, 
     ==> 0,0, 0,0, x,z, 
     ==> 0,0, 0,0, y,77,
     ==> 0,0, 0,0, 5,33 


File: singular.hlp,  Node: KoszulHomology,  Next: tensorMod,  Prev: kontrahom,  Up: homolog_lib

D.4.3.17 KoszulHomology
.......................

Procedure from library `homolog.lib' (*note homolog_lib::).

*Compute:*
     A presentation of the p-th Koszul homology module
     H_p(f_1,...,f_k;M'), where M'=coker(M) and f_1,...,f_k are the
     given (ordered list of generators of the) ideal I. The computed
     presentation is minimized via prune. In particular, if
     H_p(f_1,...,f_k;M')=0 then the return value is 0.

*Return:*
     module H, s.th. coker(H) = H_p(f_1,...,f_k;M').

*Note:*
     size of input ideal has to be <= 20.

*Example:*
     LIB "homolog.lib";
     ring R=0,x(1..3),dp;
     ideal x=maxideal(1);
     module M=0;
     KoszulHomology(x,M,0);  // H_0(x,R), x=(x_1,x_2,x_3)
     ==> _[1]=x(3)*gen(1)
     ==> _[2]=x(2)*gen(1)
     ==> _[3]=x(1)*gen(1)
     KoszulHomology(x,M,1);  // H_1(x,R), x=(x_1,x_2,x_3)
     ==> _[1]=0
     qring S=std(x(1)*x(2));
     module M=0;
     ideal x=maxideal(1);
     KoszulHomology(x,M,1);
     ==> _[1]=-x(3)*gen(1)
     ==> _[2]=-x(2)*gen(1)
     ==> _[3]=-x(1)*gen(1)
     KoszulHomology(x,M,2);
     ==> _[1]=0


File: singular.hlp,  Node: tensorMod,  Next: Tor,  Prev: KoszulHomology,  Up: homolog_lib

D.4.3.18 tensorMod
..................

Procedure from library `homolog.lib' (*note homolog_lib::).

*Usage:*
     tensorMod(M,N); M,N modules

*Compute:*
     presentation matrix A of the tensor product T of the modules
     M'=coker(M), N'=coker(N): if matrix(M) defines a map M: R^r->R^s
     and matrix(N) defines a map N: R^p->R^q, then A defines a
     presentation

                   R^(sp+rq) --A-> R^(sq)  --> T --> 0 .

*Return:*
     matrix A satisfying coker(A) = tensorprod(coker(M),coker(N)) .

*Example:*
     LIB "homolog.lib";
     ring A=0,(x,y,z),dp;
     matrix M[3][3]=1,2,3,4,5,6,7,8,9;
     matrix N[2][2]=x,y,0,z;
     print(M);
     ==> 1,2,3,
     ==> 4,5,6,
     ==> 7,8,9 
     print(N);
     ==> x,y,
     ==> 0,z 
     print(tensorMod(M,N));
     ==> x,y,0,0,0,0,1,0,2,0,3,0,
     ==> 0,z,0,0,0,0,0,1,0,2,0,3,
     ==> 0,0,x,y,0,0,4,0,5,0,6,0,
     ==> 0,0,0,z,0,0,0,4,0,5,0,6,
     ==> 0,0,0,0,x,y,7,0,8,0,9,0,
     ==> 0,0,0,0,0,z,0,7,0,8,0,9 


File: singular.hlp,  Node: Tor,  Prev: tensorMod,  Up: homolog_lib

D.4.3.19 Tor
............

Procedure from library `homolog.lib' (*note homolog_lib::).

*Compute:*
     a presentation of Tor_k(M',N'), for k=v[1],v[2],... , where
     M'=coker(M) and N'=coker(N): let

                 0 <-- M' <-- G0 <-M-- G1                
                 0 <-- N' <-- F0 <--N- F1 <-- F2 <--...  

     be a presentation of M', resp. a free resolution of N', and
     consider the commutative diagram

                    0                    0                    0
                    |^                   |^                   |^
            Tensor(M',Fk+1) -Ak+1-> Tensor(M',Fk) -Ak-> Tensor(M',Fk-1)
                    |^                   |^                   |^
            Tensor(G0,Fk+1) -Ak+1-> Tensor(G0,Fk) -Ak-> Tensor(G0,Fk-1)
                                         |^                   |^
                                         |C                   |B
                                    Tensor(G1,Fk) ----> Tensor(G1,Fk-1)

                 (Ak,Ak+1 induced by N and B,C induced by M).

     Let K=modulo(Ak,B), J=module(C)+module(Ak+1) and Tor=modulo(K,J),
     then we have exact sequences

              R^p  --K-> Tensor(G0,Fk) --Ak-> Tensor(G0,Fk-1)/im(B),

              R^q -Tor-> R^p --K-> Tensor(G0,Fk)/(im(C)+im(Ak+1)). 

     Hence, Tor presents Tor_k(M',N').

*Return:*
     - if v is of type int: module Tor, a presentation of Tor_k(M',N');
     - if v is of type intvec: a list of Tor_k(M',N') (k=v[1],v[2],...);
     - in case of a third argument of any type: list l with

          l[1] = module Tor/list of Tor_k(M',N'),
          l[2] = SB of Tor/list of SB of Tor_k(M',N'),
          l[3] = matrix/list of matrices, each representing a kbase of Tor_k(M',N')
                     (if finite dimensional), or 0.

*Display:*
     printlevel >=0: (affine) dimension of Tor_k for each k (default).
     printlevel >=1: matrices Ak, Ak+1 and kbase of Tor_k in
     Tensor(G0,Fk) (if finite dimensional).

*Note:*
     In order to compute Tor_k(M,N) use the command
     Tor(k,syz(M),syz(N)); or: list P=mres(M,2); list Q=mres(N,2);
     Tor(k,P[2],Q[2]);

*Example:*
     LIB "homolog.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 0,(x,y),dp;
     ideal i    = x2,y;
     ideal j    = x;
     list E     = Tor(0..2,i,j);    // Tor_k(r/i,r/j) for k=0,1,2 over r
     ==> // dimension of Tor_0:  0
     ==> // vdim of Tor_0:       1
     ==> 
     ==> // Computing Tor_1 (help Tor; gives an explanation):
     ==> // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
     ==> // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
     ==> // coker(N), then Tensor(G0,F1)-->Tensor(G0,F0) is given by:
     ==> x
     ==> // and Tensor(G0,F2) + Tensor(G1,F1)-->Tensor(G0,F1) is given by:
     ==> 0,x2,y
     ==> 
     ==> // dimension of Tor_1:  0
     ==> // vdim of Tor_1:       1
     ==> 
     ==> // Computing Tor_2 (help Tor; gives an explanation):
     ==> // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
     ==> // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
     ==> // coker(N), then Tensor(G0,F2)-->Tensor(G0,F1) is given by:
     ==> 0
     ==> // and Tensor(G0,F3) + Tensor(G1,F2)-->Tensor(G0,F2) is given by:
     ==> 1,x2,y
     ==> 
     ==> // dimension of Tor_2:  -1
     ==> 
     qring R    = std(i);
     ideal j    = fetch(r,j);
     module M   = [x,0],[0,x];
     printlevel = 2;
     module E1  = Tor(1,M,j);       // Tor_1(R^2/M,R/j) over R=r/i
     ==> // Computing Tor_1 (help Tor; gives an explanation):
     ==> // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
     ==> // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
     ==> // coker(N), then Tensor(G0,F1)-->Tensor(G0,F0) is given by:
     ==> x,0,
     ==> 0,x 
     ==> // and Tensor(G0,F2) + Tensor(G1,F1)-->Tensor(G0,F1) is given by:
     ==> x,0,x,0,
     ==> 0,x,0,x 
     ==> 
     ==> // dimension of Tor_1:  0
     ==> // vdim of Tor_1:       2
     ==> 
     list l     = Tor(3,M,M,1);     // Tor_3(R^2/M,R^2/M) over R=r/i
     ==> // Computing Tor_3 (help Tor; gives an explanation):
     ==> // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
     ==> // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
     ==> // coker(N), then Tensor(G0,F3)-->Tensor(G0,F2) is given by:
     ==> x,0,0,0,
     ==> 0,x,0,0,
     ==> 0,0,x,0,
     ==> 0,0,0,x 
     ==> // and Tensor(G0,F4) + Tensor(G1,F3)-->Tensor(G0,F3) is given by:
     ==> x,0,0,0,x,0,0,0,
     ==> 0,x,0,0,0,x,0,0,
     ==> 0,0,x,0,0,0,x,0,
     ==> 0,0,0,x,0,0,0,x 
     ==> 
     ==> // dimension of Tor_3:  0
     ==> // vdim of Tor_3:       4
     ==> 
     ==> // columns of matrix are kbase of Tor_3 in Tensor(G0,F3)
     ==> 1,0,0,0,
     ==> 0,1,0,0,
     ==> 0,0,1,0,
     ==> 0,0,0,1 
     ==> 
     printlevel = p;


File: singular.hlp,  Node: mprimdec_lib,  Next: mregular_lib,  Prev: homolog_lib,  Up: Commutative algebra

D.4.4 mprimdec_lib
------------------

*Library:*
     mprimdec.lib

*Purpose:*
     procedures for primary decomposition of modules

*Authors:*
     Alexander Dreyer, dreyer@mathematik.uni-kl.de; adreyer@web.de

*Remark:*
     These procedures are implemented to be used in characteristic 0.
     They also work in positive characteristic >> 0.
     In small characteristic and for algebraic extensions, the
     procedures via Gianni, Trager, Zacharias may not terminate.

*Procedures:*

* Menu:

* separator:: computes a list of separators of prime ideals
* PrimdecA:: (not necessarily minimal) primary decomposition via Shimoyama/Yokoyama (suggested by Graebe)
* PrimdecB:: (not necessarily minimal) primary decomposition for pseudo-primary ideals
* modDec:: minimal primary decomposition via Shimoyama/Yokoyama (suggested by Graebe)
* zeroMod:: minimal zero-dimensional primary decomposition via Gianni, Trager and Zacharias
* GTZmod:: minimal primary decomposition via Gianni, Trager and Zacharias
* dec1var:: primary decomposition for one variable
* annil:: the annihilator of M/N in the basering
* splitting:: splitting to simpler modules
* primTest:: tests whether i is prime or homogeneous
* preComp:: enhanced Version of splitting
* indSet:: lists with varstrings of(in)dependent variables
* GTZopt:: a faster version of GTZmod
* zeroOpt:: a faster version of zeroMod
* clrSBmod:: extracts an minimal SB from a SB
* minSatMod:: minimal saturation of N w.r.t. I
* specialModulesEqual:: checks for equality of standard bases of modules if N1 is contained in N2 or vice versa
* stdModulesEqual:: checks for equality of standard bases
* modulesEqual:: checks for equality of modules
* getData:: extracts oldData and computes the remaining data


File: singular.hlp,  Node: separator,  Next: PrimdecA,  Up: mprimdec_lib

D.4.4.1 separator
.................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     separator(l); list l of prime ideals

*Return:*
     list sepList;
     a list of separators of the prime ideals in l,
     i.e. polynomials p_ij, s.th. p_ij is in l[j],
     for all l[j] not contained in l[i]
     but p_ij is not in l[i]

*Example:*
     LIB "mprimdec.lib";
     ring r=0,(x,y,z),dp;
     ideal i=(x2y,xz2,y2z,z3);
     list l=minAssGTZ(i);
     list sepL=separator(l);
     sepL;
     ==> [1]:
     ==>    x
     ==> [2]:
     ==>    y


File: singular.hlp,  Node: PrimdecA,  Next: PrimdecB,  Prev: separator,  Up: mprimdec_lib

D.4.4.2 PrimdecA
................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     PrimdecA (N[, i]); module N, int i

*Return:*
     list l
     a (not necessarily minimal) primary decomposition of N computed by
     a generalized version of
     the algorithm of Schimoyama/Yokoyama,
     if i=1 is given, the factorizing Groebner is used
     to compute the isolated primes.

*Example:*
     LIB "mprimdec.lib";
     ring r=0,(x,y,z),dp;
     module N=x*gen(1)+ y*gen(2),
     x*gen(1)-x2*gen(2);
     list l=PrimdecA(N);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=x*gen(1)+y*gen(2)
     ==>       _[2]=x*gen(2)-gen(1)
     ==>    [2]:
     ==>       _[1]=x2+y
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=gen(2)
     ==>       _[2]=x*gen(1)
     ==>    [2]:
     ==>       _[1]=x
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=y*gen(1)
     ==>       _[2]=y*gen(2)
     ==>       _[3]=x*gen(1)
     ==>       _[4]=x*gen(2)
     ==>    [2]:
     ==>       _[1]=y
     ==>       _[2]=x


File: singular.hlp,  Node: PrimdecB,  Next: modDec,  Prev: PrimdecA,  Up: mprimdec_lib

D.4.4.3 PrimdecB
................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     PrimdecB (N, p); pseudo-primary module N, isolated prime ideal p

*Return:*
     list l
     a (not necessarily minimal) primary decomposition of N

*Example:*
     LIB "mprimdec.lib";
     ring r=0,(x,y,z),dp;
     module N=y*gen(1),y2*gen(2),yz*gen(2),yx*gen(2);
     ideal p=y;
     list l=PrimdecB(N,p);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=y*gen(1)
     ==>       _[2]=y*gen(2)
     ==>    [2]:
     ==>       _[1]=y
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=y*gen(1)
     ==>       _[2]=y*gen(2)
     ==>       _[3]=x*gen(1)
     ==>       _[4]=x*gen(2)
     ==>    [2]:
     ==>       _[1]=y
     ==>       _[2]=x
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=z*gen(1)
     ==>       _[2]=z*gen(2)
     ==>       _[3]=y*gen(1)
     ==>       _[4]=x*gen(1)
     ==>       _[5]=x*gen(2)
     ==>       _[6]=y2*gen(2)
     ==>    [2]:
     ==>       _[1]=z
     ==>       _[2]=y
     ==>       _[3]=x


File: singular.hlp,  Node: modDec,  Next: zeroMod,  Prev: PrimdecB,  Up: mprimdec_lib

D.4.4.4 modDec
..............

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     modDec (N[, i]); module N, int i

*Return:*
     list l
     a minimal primary decomposition of N
     computed by an generalized version of
     the algorithm of Schimoyama/Yokoyama,
     if i=1 is given, the factorizing Groebner is used

*Example:*
     LIB "mprimdec.lib";
     ring r=0,(x,y,z),dp;
     module N=x*gen(1)+ y*gen(2),
     x*gen(1)-x2*gen(2);
     list l=modDec(N);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=x*gen(1)+y*gen(2)
     ==>       _[2]=x*gen(2)-gen(1)
     ==>    [2]:
     ==>       _[1]=x2+y
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=gen(2)
     ==>       _[2]=x*gen(1)
     ==>    [2]:
     ==>       _[1]=x


File: singular.hlp,  Node: zeroMod,  Next: GTZmod,  Prev: modDec,  Up: mprimdec_lib

D.4.4.5 zeroMod
...............

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     zeroMod (N[, check]); zero-dimensional module N[, module check]

*Return:*
     list l
     the minimal primary decomposition of a zero-dimensional module N,
     computed by a generalized version of the algorithm
     of Gianni, Trager and Zacharias

*Note:*
     if the parameter check is given, only components
     not containing check are computed

*Example:*
     LIB "mprimdec.lib";
     ring r=0,z,dp;
     module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
     list l=zeroMod(N);
     ==> 2
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=gen(1)
     ==>       _[2]=gen(3)
     ==>       _[3]=z*gen(2)-gen(2)
     ==>    [2]:
     ==>       _[1]=z-1
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=gen(2)
     ==>       _[2]=gen(3)
     ==>       _[3]=z*gen(1)
     ==>    [2]:
     ==>       _[1]=z
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=gen(1)
     ==>       _[2]=gen(2)
     ==>       _[3]=z*gen(3)+gen(3)
     ==>    [2]:
     ==>       _[1]=z+1


File: singular.hlp,  Node: GTZmod,  Next: dec1var,  Prev: zeroMod,  Up: mprimdec_lib

D.4.4.6 GTZmod
..............

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     GTZmod (N[, check]); module N[, module check]

*Return:*
     list l
     the minimal primary decomposition of the module N,
     computed by a generalized version of the algorithm
     of Gianny, Trager and Zacharias

*Note:*
     if the parameter check is given, only components
     not containing check are computed

*Example:*
     LIB "mprimdec.lib";
     ring r=0,(x,y,z),dp;
     module N=x*gen(1)+ y*gen(2),
     x*gen(1)-x2*gen(2);
     list l=GTZmod(N);
     ==> 2
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=x*gen(1)+y*gen(2)
     ==>       _[2]=x*gen(2)-gen(1)
     ==>    [2]:
     ==>       _[1]=x2+y
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=gen(2)
     ==>       _[2]=x*gen(1)
     ==>    [2]:
     ==>       _[1]=x


File: singular.hlp,  Node: dec1var,  Next: annil,  Prev: GTZmod,  Up: mprimdec_lib

D.4.4.7 dec1var
...............

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     dec1var (N); zero-dimensional module N[, module check]

*Return:*
     list l
     the minimal primary decomposition of a submodule N of R^s if
     nvars(R)=1

*Note:*
     if the parameter check is given, only components
     not containing check are computed

*Example:*
     LIB "mprimdec.lib";
     ring r=0,z,dp;
     module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
     list l=dec1var(N);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=gen(1)
     ==>       _[2]=gen(3)
     ==>       _[3]=z*gen(2)-gen(2)
     ==>    [2]:
     ==>       _[1]=z-1
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=gen(2)
     ==>       _[2]=gen(3)
     ==>       _[3]=z*gen(1)
     ==>    [2]:
     ==>       _[1]=z
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=gen(1)
     ==>       _[2]=gen(2)
     ==>       _[3]=z*gen(3)+gen(3)
     ==>    [2]:
     ==>       _[1]=z+1


File: singular.hlp,  Node: annil,  Next: splitting,  Prev: dec1var,  Up: mprimdec_lib

D.4.4.8 annil
.............

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     annil(N); module N

*Return:*
     ideal ann=std(quotient(N,freemodule(nrows(N))));
     the annihilator of M/N in the basering

*Note:*
     ann is a std basis in the basering

*Example:*
     LIB "mprimdec.lib";
     ring r=0,(x,y,z),dp;
     module N=x*gen(1), y*gen(2);
     ideal ann=annil(N);
     ann;
     ==> ann[1]=xy


File: singular.hlp,  Node: splitting,  Next: primTest,  Prev: annil,  Up: mprimdec_lib

D.4.4.9 splitting
.................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     splitting(N[,check[, ann]]); module N, module check, ideal ann

*Return:*
     (l, check) list l, module check
     the elements of l consists of a triple with
     [1] of type module [2] and [3] of type ideal
     s.th. the intersection of the modules is equal to the
     zero-dimensional module N, furthermore l[j][3]=annil(l[j][1]) if
     l[j][2]!=0 then the module l[j][1] is primary
     with associated prime l[j][2],
     and check=intersect(check, l[j][1]) is computed

*Note:*
     if the parameter check is given, only components not containing
     check are computed; if ann is given, ann is used instead of
     annil(N)

*Example:*
     LIB "mprimdec.lib";
     ring r=0,z,lp;
     module N=z*gen(1), (z+1)*gen(2);
     N=std(N);
     list l; module check;
     (l, check)=splitting(N);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=gen(2)
     ==>       _[2]=z*gen(1)
     ==>    [2]:
     ==>       _[1]=z
     ==>    [3]:
     ==>       _[1]=z
     ==>    [4]:
     ==>       _[1]=z
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=gen(1)
     ==>       _[2]=z*gen(2)+gen(2)
     ==>    [2]:
     ==>       _[1]=z+1
     ==>    [3]:
     ==>       _[1]=z+1
     ==>    [4]:
     ==>       _[1]=z+1
     check;
     ==> check[1]=z*gen(2)+gen(2)
     ==> check[2]=z*gen(1)


File: singular.hlp,  Node: primTest,  Next: preComp,  Prev: splitting,  Up: mprimdec_lib

D.4.4.10 primTest
.................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     primTest(i[, p]); a zero-dimensional ideal i, irreducible poly p in
     i

*Return:*
     if i neither is prime nor is homogeneous then ideal(0) is returned,
     else radical(i)

*Example:*
     LIB "mprimdec.lib";
     ring r=0,(x,y,z),lp;
     ideal i=x+1,y-1,z;
     i=std(i);
     ideal primId=primTest(i,z);
     primId;
     ==> primId[1]=z
     ==> primId[2]=y-1
     ==> primId[3]=x+1
     i=x,z2,yz,y2;
     i=std(i);
     primId=primTest(i);
     primId;
     ==> primId[1]=x
     ==> primId[2]=y
     ==> primId[3]=z


File: singular.hlp,  Node: preComp,  Next: indSet,  Prev: primTest,  Up: mprimdec_lib

D.4.4.11 preComp
................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     preComp(N,check[, ann]); module N, module check, ideal ann

*Return:*
     (l, check) list l, module check
     the elements of l consists of a triple with
     [1] of type module [2] and [3] of type ideal
     s.th. the intersection of the modules is equal to the
     zero-dimensional module N, furthermore l[j][3]=annil(l[j][1]) if
     l[j][2]!=0 then the module l[j][1] is primary
     with associated prime l[j][2],
     and check=intersect(check, l[j][1]) is computed

*Note:*
     only components not containing check are computed;
     if ann is given, ann is used instead of annil(N)

*Example:*
     LIB "mprimdec.lib";
     ring r=0,z,lp;
     module N=z*gen(1), (z+1)*gen(2);
     N=std(N);
     list l; module check;
     (l, check)=preComp(N,freemodule(2));
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=z*gen(1)
     ==>       _[2]=gen(2)
     ==>    [2]:
     ==>       _[1]=z
     ==>    [3]:
     ==>       _[1]=z
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=gen(1)
     ==>       _[2]=z*gen(2)+gen(2)
     ==>    [2]:
     ==>       _[1]=z+1
     ==>    [3]:
     ==>       _[1]=z+1
     check;
     ==> check[1]=z*gen(1)
     ==> check[2]=z*gen(2)+gen(2)


File: singular.hlp,  Node: indSet,  Next: GTZopt,  Prev: preComp,  Up: mprimdec_lib

D.4.4.12 indSet
...............

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     indSet(i); i ideal

*Return:*
     list with two entrees
     both are lists of new varstrings with the dependent variables the
     independent set, the ordstring with the corresp. block ordering,
     and the integer where the independent set starts in the varstring

*Note:*
     the first entry gives the strings for all maximal independent sets
     the second gives the strings for the independent sets,
     which cannot be enhanced

*Example:*
     LIB "mprimdec.lib";
     ring s1=(0,x,y),(a,b,c,d,e,f,g),lp;
     ideal i=ea-fbg,fa+be,ec-fdg,fc+de;
     i=std(i);
     list  l=indSet(i);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       [1]:
     ==>          e,f
     ==>       [2]:
     ==>          a,b,c,d,g
     ==>       [3]:
     ==>          (C,dp(2),dp)
     ==>       [4]:
     ==>          5
     ==> [2]:
     ==>    [1]:
     ==>       [1]:
     ==>          a,b,c,d
     ==>       [2]:
     ==>          e,f,g
     ==>       [3]:
     ==>          (C,dp(4),dp)
     ==>       [4]:
     ==>          3
     ==>    [2]:
     ==>       [1]:
     ==>          a,c,e
     ==>       [2]:
     ==>          b,d,f,g
     ==>       [3]:
     ==>          (C,dp(3),dp)
     ==>       [4]:
     ==>          4


File: singular.hlp,  Node: GTZopt,  Next: zeroOpt,  Prev: indSet,  Up: mprimdec_lib

D.4.4.13 GTZopt
...............

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     GTZopt (N[, check]); module N[, module check]

*Return:*
     list l
     the minimal primary decomposition of the module N,
     computed by a generalized and optimized version of
     the algorithm of Gianny, Trager and Zacharias

*Note:*
     if the parameter check is given, only components
     not containing check are computed

*Example:*
     LIB "mprimdec.lib";
     ring r=0,(x,y,z),dp;
     module N=x*gen(1)+ y*gen(2),
     x*gen(1)-x2*gen(2);
     list l=GTZopt(N);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=x*gen(1)+y*gen(2)
     ==>       _[2]=x*gen(2)-gen(1)
     ==>    [2]:
     ==>       _[1]=x2+y
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=gen(2)
     ==>       _[2]=x*gen(1)
     ==>    [2]:
     ==>       _[1]=x


File: singular.hlp,  Node: zeroOpt,  Next: clrSBmod,  Prev: GTZopt,  Up: mprimdec_lib

D.4.4.14 zeroOpt
................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     zeroOpt (N[, check]); zero-dimensional module N[, module check]

*Return:*
     list l
     the minimal primary decomposition of a zero-dimensional module N,
     computed by a generalized and optimized version of the algorithm of
     Gianny, Trager and Zacharias

*Note:*
     if the parameter check is given, only components
     not containing check are computed

*Example:*
     LIB "mprimdec.lib";
     ring r=0,z,dp;
     module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
     list l=zeroOpt(N);
     l;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=gen(1)
     ==>       _[2]=z*gen(2)-gen(2)
     ==>       _[3]=gen(3)
     ==>    [2]:
     ==>       _[1]=z-1
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=z*gen(1)
     ==>       _[2]=gen(2)
     ==>       _[3]=gen(3)
     ==>    [2]:
     ==>       _[1]=z
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=gen(1)
     ==>       _[2]=gen(2)
     ==>       _[3]=z*gen(3)+gen(3)
     ==>    [2]:
     ==>       _[1]=z+1


File: singular.hlp,  Node: clrSBmod,  Next: minSatMod,  Prev: zeroOpt,  Up: mprimdec_lib

D.4.4.15 clrSBmod
.................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     clrSBmod(N); N module which is SB ordered by monomial ordering

*Return:*
     module = minimal SB

*Example:*
     LIB "mprimdec.lib";
     ring  r = (0,a,b),(x,y,z),dp;
     module N1=ax2+y,a2x+y,bx;
     module N2=clrSBmod(N1);
     N2;
     ==> N2[1]=(a)*x2*gen(1)+y*gen(1)
     ==> N2[2]=(b)*x*gen(1)


File: singular.hlp,  Node: minSatMod,  Next: specialModulesEqual,  Prev: clrSBmod,  Up: mprimdec_lib

D.4.4.16 minSatMod
..................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     minSatMod(N, I); module N, ideal I

*Return:*
     list with 2 elements:
     [1]=sat(N,product(I))[1],
     [2]=p, the polynomial of minimal degree s.th. [1]=quotient(N,p)

*Example:*
     LIB "mprimdec.lib";
     ring  r = 0,(x,y,z),dp;
     module N=xy*gen(1);
     ideal h=yz,z2;
     list l=minSatMod(N,h);
     l;
     ==> [1]:
     ==>    _[1]=x*gen(1)
     ==> [2]:
     ==>    y


File: singular.hlp,  Node: specialModulesEqual,  Next: stdModulesEqual,  Prev: minSatMod,  Up: mprimdec_lib

D.4.4.17 specialModulesEqual
............................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     specialModulesEqual(N1, N2) N1, N2 standard bases of modules, s.th.
     N1 is contained in N2 or vice versa

*Return:*
     int i
     if (N1==N2) then i=1
     else i=0

*Example:*
     LIB "mprimdec.lib";
     ring  r = 0,(x,y,z),dp;
     module N1=x*freemodule(2);
     module N2=xy*freemodule(2);
     int i=specialModulesEqual(N1,N2);
     i;
     ==> 0
     N2=N1;
     i=specialModulesEqual(N1,N2);
     i;
     ==> 1


File: singular.hlp,  Node: stdModulesEqual,  Next: modulesEqual,  Prev: specialModulesEqual,  Up: mprimdec_lib

D.4.4.18 stdModulesEqual
........................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     stdModulesEqual(N1, N2) N1, N2 standard bases of modules,

*Return:*
     int i
     if (N1==N2) then i=1
     else i=0

*Example:*
     LIB "mprimdec.lib";
     ring  r = 0,(x,y,z),dp;
     module N1=x*freemodule(2);
     module N2=xy*freemodule(2);
     int i=stdModulesEqual(N1,N2);
     i;
     ==> 0
     N2=N1;
     i=stdModulesEqual(N1,N2);
     i;
     ==> 1


File: singular.hlp,  Node: modulesEqual,  Next: getData,  Prev: stdModulesEqual,  Up: mprimdec_lib

D.4.4.19 modulesEqual
.....................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     modulesEqual(N1, N2) N1, N2 modules,

*Return:*
     int i
     if (N1==N2) then i=1
     else i=0

*Example:*
     LIB "mprimdec.lib";
     ring  r = 0,(x,y,z),dp;
     module N1=x*freemodule(2);
     module N2=xy*freemodule(2);
     int i=modulesEqual(N1,N2);
     i;
     ==> 0
     N2=N1;
     i=modulesEqual(N1,N2);
     i;
     ==> 1


File: singular.hlp,  Node: getData,  Prev: modulesEqual,  Up: mprimdec_lib

D.4.4.20 getData
................

Procedure from library `mprimdec.lib' (*note mprimdec_lib::).

*Usage:*
     getData(N, l[, noCheck]); module N, list l[, int noCheck]

*Return:*
     (ann, check, M, checked)
     ideal ann, module check, M, int checked

     if l[1] is contained in N [and noCheck is not given]
     then checked=1, ann=ideal(0), check=0, M=0;
     else checked=0, M=freemodule(nrows(N)); check=l[1]
     (resp. check=M if l is an empty list) and
     if size(l)>1 then ann=l[2] else ann is the annihilator of M/N.

*Note:*
     ann is a std basis in the basering

*Example:*
     LIB "mprimdec.lib";
     ring  r = 0,(x,y,z),lp;
     module N=x*gen(1),y*gen(2);
     N=std(N);
     ideal ann; module check, M; int checked; list l;
     (ann, check, M, checked)=getData(N,l);
     ann; check; M; checked;
     ==> ann[1]=xy
     ==> check[1]=gen(1)
     ==> check[2]=gen(2)
     ==> M[1]=gen(1)
     ==> M[2]=gen(2)
     ==> 0
     l=list(check,ann);
     (ann, check, M, checked)=getData(N,l);
     ann; check; M; checked;
     ==> ann[1]=xy
     ==> check[1]=gen(1)
     ==> check[2]=gen(2)
     ==> M[1]=gen(1)
     ==> M[2]=gen(2)
     ==> 0
     l=list(N);
     (ann, check, M, checked)=getData(N,l);
     ann; check; M; checked;
     ==> ann[1]=0
     ==> check[1]=0
     ==> M[1]=0
     ==> 1


File: singular.hlp,  Node: mregular_lib,  Next: normal_lib,  Prev: mprimdec_lib,  Up: Commutative algebra

D.4.5 mregular_lib
------------------

*Library:*
     mregular.lib

*Purpose:*
     Castelnuovo-Mumford Regularity of CM-Schemes and Curves

*Authors:*
     I.Bermejo, ibermejo@ull.es
     Ph.Gimenez, pgimenez@agt.uva.es
     G.-M.Greuel, greuel@mathematik.uni-kl.de

*Overview:*
     A library for computing the Castelnuovo-Mumford regularity of a
     subscheme of the projective n-space that DOES NOT require the
     computation of a minimal graded free resolution of the saturated
     ideal defining the subscheme.  The procedures are based on two
     papers by Isabel Bermejo and Philippe Gimenez: 'On
     Castelnuovo-Mumford regularity of projective curves'
     Proc.Amer.Math.Soc.  128(5) (2000), and 'Computing the
     Castelnuovo-Mumford regularity of some subschemes of Pn using
     quotients of monomial ideals', Proceedings of MEGA-2000, J. Pure
     Appl. Algebra (to appear).
     The algorithm assumes the variables to be in Noether position.

*Procedures:*

* Menu:

* reg_CM:: regularity of arith. C-M subscheme V(id_sat) of Pn
* reg_curve:: regularity of projective curve V(id_sat) in Pn
* reg_moncurve:: regularity of projective monomial curve defined by li


File: singular.hlp,  Node: reg_CM,  Next: reg_curve,  Up: mregular_lib

D.4.5.1 reg_CM
..............

Procedure from library `mregular.lib' (*note mregular_lib::).

*Usage:*
     reg_CM (i); i ideal

*Return:*
     an integer, the Castelnuovo-Mumford regularity of i-sat.

*Assume:*
     i is a homogeneous ideal of the basering S=K[x(0)..x(n)] where the
     field K is infinite, and S/i-sat is Cohen-Macaulay.  Assume that
     K[x(n-d),...,x(n)] is a Noether normalization of S/i-sat where
     d=dim S/i -1. If this is not the case, compute a Noether
     normalization e.g. by using the proc noetherNormal from
     algebra.lib.

*Note:*
     The output is reg(X)=reg(i-sat) where X is the arithmetically
     Cohen-Macaulay subscheme of the projective n-space defined by i.
     If printlevel > 0 (default = 0) additional information is
     displayed.  In particular, the value of the regularity of the
     Hilbert function of S/i-sat is given.

*Example:*
     LIB "mregular.lib";
     ring s=0,x(0..5),dp;
     ideal i=x(2)^2-x(4)*x(5),x(1)*x(2)-x(0)*x(5),x(0)*x(2)-x(1)*x(4),
     x(1)^2-x(3)*x(5),x(0)*x(1)-x(2)*x(3),x(0)^2-x(3)*x(4);
     reg_CM(i);
     ==> 2
     // Additional information can be obtained as follows:
     printlevel = 1;
     reg_CM(i);
     ==> // Ideal i of S defining an arithm. Cohen-Macaulay subscheme X of P5:
     ==> //   - dimension of X: 2
     ==> //   - i is saturated: YES
     ==> //   - regularity of the Hilbert function of S/i-sat: -1
     ==> //   - time for computing reg(X): 0 sec.
     ==> // Castelnuovo-Mumford regularity of X:
     ==> 2


File: singular.hlp,  Node: reg_curve,  Next: reg_moncurve,  Prev: reg_CM,  Up: mregular_lib

D.4.5.2 reg_curve
.................

Procedure from library `mregular.lib' (*note mregular_lib::).

*Usage:*
     reg_curve (i[,e]); i ideal, e integer

*Return:*
     an integer, the Castelnuovo-Mumford regularity of i-sat.

*Assume:*
     i is a homogeneous ideal of the basering S=K[x(0)..x(n)] where the
     field K is infinite, and it defines a projective curve C in the
     projective n-space (dim(i)=2). We assume that K[x(n-1),x(n)] is a
     Noether normalization of S/i-sat.
     e=0: (default)
     Uses a random choice of an element of K when it is necessary.  This
     is absolutely safe (if the element is bad, another random choice
     will be done until a good element is found).
     e=1: Substitutes the random choice of an element of K by a simple
     transcendental field extension of K.

*Note:*
     The output is the integer reg(C)=reg(i-sat).
     If printlevel > 0 (default = 0) additional information is
     displayed.  In particular, says if C is arithmetically
     Cohen-Macaulay or not, determines in which step of a minimal graded
     free resolution of i-sat the regularity of C is attained, and
     sometimes gives the value of the regularity of the Hilbert function
     of S/i-sat (otherwise, an upper bound is given).

*Example:*
     LIB "mregular.lib";
     ring s = 0,(x,y,z,t),dp;
     // 1st example is Ex.2.5 in [Bermejo-Gimenez], Proc.Amer.Math.Soc. 128(5):
     ideal i  = x17y14-y31, x20y13, x60-y36z24-x20z20t20;
     reg_curve(i);
     ==> 72
     // 2nd example is Ex.2.9 in [Bermejo-Gimenez], Proc.Amer.Math.Soc. 128(5):
     int k=43;
     ideal j=x17y14-y31,x20y13,x60-y36z24-x20z20t20,y41*z^k-y40*z^(k+1);
     reg_curve(j);
     ==> 93
     // Additional information can be obtained as follows:
     printlevel = 1;
     reg_curve(j);
     ==> // Ideal i of S defining a projective curve C in P3:
     ==> //   - i is saturated: YES
     ==> //   - C is arithm. Cohen-Macaulay: NO
     ==> //   - reg(C) attained at the last step of a m.g.f.r. of i-sat: YES
     ==> //   - regularity of the Hilbert function of S/i-sat: 92
     ==> //   - time for computing reg(C): 0 sec.
     ==> // Castelnuovo-Mumford regularity of C:
     ==> 93


File: singular.hlp,  Node: reg_moncurve,  Prev: reg_curve,  Up: mregular_lib

D.4.5.3 reg_moncurve
....................

Procedure from library `mregular.lib' (*note mregular_lib::).

*Usage:*
     reg_moncurve (a0,...,an) ; ai integers with a0=0 < a1 < ... < an=:d

*Return:*
     an integer, the Castelnuovo-Mumford regularity of the projective
     monomial curve C in Pn parametrically defined by:
     x(0)=t^d , x(1)=s^(a1)t^(d-a1), ... , x(n)=s^d.

*Assume:*
     a0=0 < a1 < ... < an are integers and the base field is infinite.

*Note:*
     The defining ideal I(C) in S is determined using elimination.  The
     procedure reg_curve is improved in this case since one knows
     beforehand that the dimension is 2, that the variables are in
     Noether position, that I(C) is prime.
     If printlevel > 0 (default = 0) additional information is
     displayed.  In particular, says if C is arithmetically
     Cohen-Macaulay or not, determines in which step of a minimal graded
     free resolution of I(C) the regularity is attained, and sometimes
     gives the value of the regularity of the Hilbert function of S/I(C)
     (otherwise, an upper bound is given).

*Example:*
     LIB "mregular.lib";
     // The 1st example is the twisted cubic:
     reg_moncurve(0,1,2,3);
     ==> 2
     // The 2nd. example is the non arithm. Cohen-Macaulay monomial curve in P4
     // parametrized by: x(0)-s6,x(1)-s5t,x(2)-s3t3,x(3)-st5,x(4)-t6:
     reg_moncurve(0,1,3,5,6);
     ==> 3
     // Additional information can be obtained as follows:
     printlevel = 1;
     reg_moncurve(0,1,3,5,6);
     ==> // Sequence of integers defining a monomial curve C in P4:
     ==> //   - time for computing ideal I(C) of S (elimination): 0 sec.
     ==> //   - C is arithm. Cohen-Macaulay: NO
     ==> //   - reg(C) attained at the last step of a m.g.f.r. of I(C): YES
     ==> //   - reg(C) attained at the second last step of a m.g.f.r. of I(C): YES
     ==> //   - regularity of the Hilbert function of S/I(C): 2
     ==> //   - time for computing reg(C): 0 sec.
     ==> // Castelnuovo-Mumford regularity of C:
     ==> 3


File: singular.hlp,  Node: normal_lib,  Next: primdec_lib,  Prev: mregular_lib,  Up: Commutative algebra

D.4.6 normal_lib
----------------

*Library:*
     normal.lib

*Purpose:*
     Normalization of Affine Rings

*Authors:*
     G.-M. Greuel, greuel@mathematik.uni-kl.de,
     G. Pfister, pfister@mathematik.uni-kl.de

*Main procedures:*

* Menu:

* normal:: computes the normalization of basering/I, resp. computes the normalization of basering/I and the delta invariant
* HomJJ:: presentation of End_R(J) as affine ring, L a list
* genus:: computes genus of the projective curve defined by I

*Auxiliary procedure:*

* Menu:

* deltaLoc:: (sum of) delta invariant(s) at conjugated singular points


File: singular.hlp,  Node: normal,  Next: HomJJ,  Up: normal_lib

D.4.6.1 normal
..............

Procedure from library `normal.lib' (*note normal_lib::).

*Usage:*
     normal(i [,choose]); i a radical ideal, choose empty, 1 or "wd" if
     choose=1 the normalization of the associated primes is computed
     (which is sometimes more efficient); if `choose="wd"' the delta
     invariant is computed simultaneously; this may take much more time
     in the reducible case, since the factorizing standard basis
     algorithm cannot be used.

*Assume:*
     The ideal must be radical, for non-radical ideals the output may be
     wrong (i=radical(i); makes i radical)

*Return:*
     a list of rings, say nor and in case of `choose="wd"' an integer at
     the end of the list.  Each ring `nor[i]' contains two ideals with
     given names `norid' and `normap' such that
     - the direct sum of the rings `nor[i]/norid' is the normalization
     of basering/id;
     - `normap' gives the normalization map from basering/id to
     `nor[i]/norid' (for each i).

*Note:*
     to use the i-th ring type: `def R=nor[i]; setring R;'.
     Increasing printlevel displays more comments (default:
     printlevel=0).
     Not implemented for local or mixed orderings.
     If the input ideal i is weighted homogeneous a weighted ordering
     may be used (qhweight(i); computes weights).

*Example:*
     LIB "normal.lib";
     ring r=32003,(x,y,z),wp(2,1,2);
     ideal i=z3-xy4;
     list nor=normal(i);
     ==> 
     ==> // 'normal' created a list of 1 ring(s).
     ==> // nor[1+1] is the delta-invariant in case of choose=wd.
     ==> // To see the rings, type (if the name of your list is nor):
     ==>      show( nor);
     ==> // To access the 1-st ring and map (similar for the others), type:
     ==>      def R = nor[1]; setring R;  norid; normap;
     ==> // R/norid is the 1-st ring of the normalization and
     ==> // normap the map from the original basering to R/norid
     show(nor);
     ==> // list, 1 element(s):
     ==> [1]:
     ==>    // ring: (32003),(T(1),T(2),T(3)),(a(2,1,1),dp(3),C);
     ==>    // minpoly = 0
     ==> // objects belonging to this ring:
     ==> // normap               [0]  ideal, 3 generator(s)
     ==> // norid                [0]  ideal, 1 generator(s)
     def r1=nor[1];
     setring r1;
     norid;
     ==> norid[1]=T(3)3-T(1)T(2)
     normap;
     ==> normap[1]=T(1)
     ==> normap[2]=T(2)
     ==> normap[3]=T(2)T(3)
     ring s=0,(x,y),dp;
     ideal i=(x-y^2)^2 - y*x^3;
     nor=normal(i,"wd");
     ==> 
     ==> // 'normal' created a list of 1 ring(s).
     ==> // nor[1+1] is the delta-invariant in case of choose=wd.
     ==> // To see the rings, type (if the name of your list is nor):
     ==>      show( nor);
     ==> // To access the 1-st ring and map (similar for the others), type:
     ==>      def R = nor[1]; setring R;  norid; normap;
     ==> // R/norid is the 1-st ring of the normalization and
     ==> // normap the map from the original basering to R/norid
     //the delta-invariant
     nor[size(nor)];
     ==> 3


File: singular.hlp,  Node: HomJJ,  Next: genus,  Prev: normal,  Up: normal_lib

D.4.6.2 HomJJ
.............

Procedure from library `normal.lib' (*note normal_lib::).

*Usage:*
     HomJJ (Li); Li = list: ideal SBid, ideal id, ideal J, poly p

*Assume:*
     R = P/id, P = basering, a polynomial ring, id an ideal of P,
     SBid = standard basis of id,
     J = ideal of P containing the polynomial p,
     p = nonzero divisor of R

*Compute:*
     Endomorphism ring End_R(J)=Hom_R(J,J) with its ring structure as
     affine ring, together with the canonical map R -> Hom_R(J,J), where
     R is the quotient ring of P modulo the standard basis SBid.

*Return:*
     a list l of two objects

              l[1] : a polynomial ring, containing two ideals, 'endid' and 'endphi'
                    such that l[1]/endid = Hom_R(J,J) and
                    endphi describes the canonical map R -> Hom_R(J,J)
              l[2] : an integer which is 1 if phi is an isomorphism, 0 if not
              l[3] : an integer, the contribution to delta

*Note:*
     printlevel >=1: display comments (default: printlevel=0)

*Example:*
     LIB "normal.lib";
     ring r   = 0,(x,y),wp(2,3);
     ideal id = y^2-x^3;
     ideal J  = x,y;
     poly p   = x;
     list Li = std(id),id,J,p;
     list L   = HomJJ(Li);
     def end = L[1];    // defines ring L[1], containing ideals endid, endphi
     setring end;       // makes end the basering
     end;
     ==> //   characteristic : 0
     ==> //   number of vars : 1
     ==> //        block   1 : ordering dp
     ==> //                  : names    T(1) 
     ==> //        block   2 : ordering C
     endid;             // end/endid is isomorphic to End(r/id) as ring
     ==> endid[1]=0
     map psi = r,endphi;// defines the canonical map r/id -> End(r/id)
     psi;
     ==> psi[1]=T(1)^2
     ==> psi[2]=T(1)^3


File: singular.hlp,  Node: genus,  Next: deltaLoc,  Prev: HomJJ,  Up: normal_lib

D.4.6.3 genus
.............

Procedure from library `normal.lib' (*note normal_lib::).

*Usage:*
     genus(I) or genus(i,1); I a 1-dimensional ideal

*Return:*
     an integer, the geometric genus p_g = p_a - delta of the projective
     curve defined by I, where p_a is the arithmetic genus.

*Note:*
     delta is the sum of all local delta-invariants of the
     singularities, i.e. dim(R'/R), R' the normalization of the local
     ring R of the singularity.
     genus(i,1) uses the normalization to compute delta. Usually this is
     slow but sometimes not.

*Example:*
     LIB "normal.lib";
     ring r=0,(x,y),dp;
     ideal i=y^9 - x^2*(x - 1)^9;
     genus(i);
     ==> 0


File: singular.hlp,  Node: deltaLoc,  Prev: genus,  Up: normal_lib

D.4.6.4 deltaLoc
................

Procedure from library `normal.lib' (*note normal_lib::).

*Usage:*
     deltaLoc(f,J); f poly, J ideal

*Assume:*
     f is reduced bivariate polynomial; basering has exactly two
     variables; J is irreducible prime component of the singular locus
     of f (e.g., one entry of the output of `minAssGTZ(I);', I =
     <f,jacob(f)>).

*Return:*
     list L:

     `L[1]'; int:
          the sum of (local) delta invariants of f at the (conjugated)
          singular          points given by J.

     `L[2]'; int:
          the sum of (local) Tjurina numbers of f at the (conjugated)
          singular          points given by J.

     `L[3]'; int:
          the sum of (local) number of branches of f at the (conjugated)
                   singular points given by J.

*Note:*
     procedure makes use of `execute'; increasing printlevel displays
     more comments (default: printlevel=0).

*Example:*
     LIB "normal.lib";
     ring r=0,(x,y),dp;
     poly f=(x2+y^2-1)^3 +27x2y2;
     ideal I=f,jacob(f);
     I=std(I);
     list qr=minAssGTZ(I);
     size(qr);
     ==> 6
     // each component of the singular locus either describes a cusp or a pair
     // of conjugated nodes:
     deltaLoc(f,qr[1]); 
     ==> [1]:
     ==>    1
     ==> [2]:
     ==>    2
     ==> [3]:
     ==>    1
     deltaLoc(f,qr[2]); 
     ==> [1]:
     ==>    1
     ==> [2]:
     ==>    2
     ==> [3]:
     ==>    1
     deltaLoc(f,qr[3]); 
     ==> [1]:
     ==>    1
     ==> [2]:
     ==>    2
     ==> [3]:
     ==>    1
     deltaLoc(f,qr[4]); 
     ==> [1]:
     ==>    1
     ==> [2]:
     ==>    2
     ==> [3]:
     ==>    1
     deltaLoc(f,qr[5]); 
     ==> [1]:
     ==>    2
     ==> [2]:
     ==>    2
     ==> [3]:
     ==>    4
     deltaLoc(f,qr[6]);
     ==> [1]:
     ==>    2
     ==> [2]:
     ==>    2
     ==> [3]:
     ==>    4

* Menu:

See also:
* delta::
* tjurina::

*See also:* *note delta::; *note tjurina::.


File: singular.hlp,  Node: primdec_lib,  Next: primitiv_lib,  Prev: normal_lib,  Up: Commutative algebra

D.4.7 primdec_lib
-----------------

*Library:*
     primdec.lib

*Purpose:*
     Primary Decomposition and Radical of Ideals

*Authors:*
     Gerhard Pfister, pfister@mathematik.uni-kl.de (GTZ)
     Wolfram Decker, decker@math.uni-sb.de (SY)
     Hans Schoenemann, hannes@mathematik.uni-kl.de (SY)

*Overview:*
     Algorithms for primary decomposition based on the ideas of Gianni,
     Trager and Zacharias (implementation by Gerhard Pfister),
     respectively based on the ideas of Shimoyama and Yokoyama
     (implementation by Wolfram Decker and Hans Schoenemann).
     The procedures are implemented to be used in characteristic 0.
     They also work in positive characteristic >> 0.
     In small characteristic and for algebraic extensions, primdecGTZ
     may not terminate.
     Algorithms for the computation of the radical based on the ideas of
     Krick, Logar and Kemper (implementation by Gerhard Pfister).

*Procedures:*

* Menu:

* Ann:: annihilator of R^n/M, R=basering, M in R^n
* primdecGTZ:: complete primary decomposition via Gianni,Trager,Zacharias
* primdecSY:: complete primary decomposition via Shimoyama-Yokoyama
* minAssGTZ:: the minimal associated primes via Gianni,Trager,Zacharias
* minAssChar:: the minimal associated primes using characteristic sets
* testPrimary:: tests the result of the primary decomposition
* radical:: computes the radical of I via Krick/Logar and Kemper
* radicalEHV:: computes the radical of I via Eisenbud,Huneke,Vasconcelos
* equiRadical:: the radical of the equidimensional part of the ideal I
* prepareAss:: list of radicals of the equidimensional components of I
* equidim:: weak equidimensional decomposition of I
* equidimMax:: equidimensional locus of I
* equidimMaxEHV:: equidimensional locus of I via Eisenbud,Huneke,Vasconcelos
* zerodec:: zerodimensional decomposition via Monico


File: singular.hlp,  Node: Ann,  Next: primdecGTZ,  Up: primdec_lib

D.4.7.1 Ann
...........

Procedure from library `primdec.lib' (*note primdec_lib::).


File: singular.hlp,  Node: primdecGTZ,  Next: primdecSY,  Prev: Ann,  Up: primdec_lib

D.4.7.2 primdecGTZ
..................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     primdecGTZ(i); i ideal

*Return:*
     a list pr of primary ideals and their associated primes:

        pr[i][1]   the i-th primary component,
        pr[i][2]   the i-th prime component.

*Note:*
     Algorithm of Gianni/Trager/Zacharias.
     Designed for characteristic 0, works also in char k > 0, if it
     terminates (may result in an infinite loop in small
     characteristic!)

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),lp;
     poly  p = z2+1;
     poly  q = z3+2;
     ideal i = p*q^2,y-z2;
     list pr = primdecGTZ(i);
     pr;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=z6+4z3+4
     ==>       _[2]=y-z2
     ==>    [2]:
     ==>       _[1]=z3+2
     ==>       _[2]=y-z2
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=z2+1
     ==>       _[2]=y-z2
     ==>    [2]:
     ==>       _[1]=z2+1
     ==>       _[2]=y-z2


File: singular.hlp,  Node: primdecSY,  Next: minAssGTZ,  Prev: primdecGTZ,  Up: primdec_lib

D.4.7.3 primdecSY
.................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     primdecSY(i); i ideal, c int

*Return:*
     a list pr of primary ideals and their associated primes:

        pr[i][1]   the i-th primary component,
        pr[i][2]   the i-th prime component.

*Note:*
     Algorithm of Shimoyama/Yokoyama.

        if c=0,  the given ordering of the variables is used,
        if c=1,  minAssChar tries to use an optimal ordering,
        if c=2,  minAssGTZ is used,
        if c=3,  minAssGTZ and facstd are used.

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),lp;
     poly  p = z2+1;
     poly  q = z3+2;
     ideal i = p*q^2,y-z2;
     list pr = primdecSY(i);
     pr;
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=z6+4z3+4
     ==>       _[2]=y-z2
     ==>    [2]:
     ==>       _[1]=z3+2
     ==>       _[2]=y-z2
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=z2+1
     ==>       _[2]=y+1
     ==>    [2]:
     ==>       _[1]=z2+1
     ==>       _[2]=y+1


File: singular.hlp,  Node: minAssGTZ,  Next: minAssChar,  Prev: primdecSY,  Up: primdec_lib

D.4.7.4 minAssGTZ
.................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     minAssGTZ(i); i ideal
     minAssGTZ(i,1); i ideal does not use the factorizing Groebner

*Return:*
     a list, the minimal associated prime ideals of i.

*Note:*
     Designed for characteristic 0, works also in char k > 0 based on an
     algorithm of Yokoyama

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),dp;
     poly  p = z2+1;
     poly  q = z3+2;
     ideal i = p*q^2,y-z2;
     list pr = minAssGTZ(i);
     pr;
     ==> [1]:
     ==>    _[1]=z2+1
     ==>    _[2]=-z2+y
     ==> [2]:
     ==>    _[1]=z3+2
     ==>    _[2]=-z2+y


File: singular.hlp,  Node: minAssChar,  Next: testPrimary,  Prev: minAssGTZ,  Up: primdec_lib

D.4.7.5 minAssChar
..................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     minAssChar(i[,c]); i ideal, c int.

*Return:*
     list, the minimal associated prime ideals of i.

*Note:*
     If c=0, the given ordering of the variables is used.
     Otherwise, the system tries to find an optimal ordering, which in
     some cases may considerably speed up the algorithm.
     Due to a bug in the factorization, the result may be not completely
     decomposed in small characteristic.

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),dp;
     poly  p = z2+1;
     poly  q = z3+2;
     ideal i = p*q^2,y-z2;
     list pr = minAssChar(i);
     pr;
     ==> [1]:
     ==>    _[1]=y+1
     ==>    _[2]=z2+1
     ==> [2]:
     ==>    _[1]=z2-y
     ==>    _[2]=yz+2
     ==>    _[3]=y2+2z


File: singular.hlp,  Node: testPrimary,  Next: radical,  Prev: minAssChar,  Up: primdec_lib

D.4.7.6 testPrimary
...................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     testPrimary(pr,k); pr a list, k an ideal.

*Assume:*
     pr is the result of primdecGTZ(k) or primdecSY(k).

*Return:*
     int, 1 if the intersection of the ideals in pr is k, 0 if not

*Example:*
     LIB "primdec.lib";
     ring  r = 32003,(x,y,z),dp;
     poly  p = z2+1;
     poly  q = z4+2;
     ideal i = p^2*q^3,(y-z3)^3,(x-yz+z4)^4;
     list pr = primdecGTZ(i);
     testPrimary(pr,i);
     ==> 1


File: singular.hlp,  Node: radical,  Next: radicalEHV,  Prev: testPrimary,  Up: primdec_lib

D.4.7.7 radical
...............

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     radical(i); i ideal.

*Return:*
     ideal, the radical of i.

*Note:*
     A combination of the algorithms of Krick/Logar and Kemper is used.
     Works also in positive characteristic (Kempers algorithm).

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),dp;
     poly  p = z2+1;
     poly  q = z3+2;
     ideal i = p*q^2,y-z2;
     ideal pr= radical(i);
     pr;
     ==> pr[1]=z2-y
     ==> pr[2]=y2z+yz+2y+2


File: singular.hlp,  Node: radicalEHV,  Next: equiRadical,  Prev: radical,  Up: primdec_lib

D.4.7.8 radicalEHV
..................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     radicalEHV(i); i ideal.

*Return:*
     ideal, the radical of i.

*Note:*
     Uses the algorithm of Eisenbud/Huneke/Vasconcelos, which reduces
     the computation to the complete intersection case, by taking, in
     the general case, a generic linear combination of the input.
     Works only in characteristic 0 or p large.

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),dp;
     poly  p = z2+1;
     poly  q = z3+2;
     ideal i = p*q^2,y-z2;
     ideal pr= radicalEHV(i);
     pr;
     ==> pr[1]=z2-y
     ==> pr[2]=y2z+yz+2y+2
     ==> pr[3]=y3+y2+2yz+2z


File: singular.hlp,  Node: equiRadical,  Next: prepareAss,  Prev: radicalEHV,  Up: primdec_lib

D.4.7.9 equiRadical
...................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     equiRadical(i); i ideal

*Return:*
     ideal, intersection of associated primes of i of maximal dimension.

*Note:*
     A combination of the algorithms of Krick/Logar and Kemper is used.
     Works also in positive characteristic (Kempers algorithm).

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),dp;
     poly  p = z2+1;
     poly  q = z3+2;
     ideal i = p*q^2,y-z2;
     ideal pr= equiRadical(i);
     pr;
     ==> pr[1]=z2-y
     ==> pr[2]=y2z+yz+2y+2


File: singular.hlp,  Node: prepareAss,  Next: equidim,  Prev: equiRadical,  Up: primdec_lib

D.4.7.10 prepareAss
...................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     prepareAss(i); i ideal

*Return:*
     list, the radicals of the maximal dimensional components of i.

*Note:*
     Uses algorithm of Eisenbud/Huneke/Vasconcelos.

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),dp;
     poly  p = z2+1;
     poly  q = z3+2;
     ideal i = p*q^2,y-z2;
     list pr = prepareAss(i);
     pr;
     ==> [1]:
     ==>    _[1]=z2-y
     ==>    _[2]=y2z+yz+2y+2


File: singular.hlp,  Node: equidim,  Next: equidimMax,  Prev: prepareAss,  Up: primdec_lib

D.4.7.11 equidim
................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     equidim(i) or equidim(i,1) ; i ideal

*Return:*
     list of equidimensional ideals a[1],...,a[s] with:
     - a[s] the equidimensional locus of i, i.e. the intersection of the
     primary ideals of dimension of i
     - a[1],...,a[s-1] the lower dimensional equidimensional loci.

*Note:*
     An embedded component q (primary ideal) of i can be replaced in the
     decomposition by a primary ideal q1 with the same radical as q.
     `equidim(i,1)' uses the algorithm of Eisenbud/Huneke/Vasconcelos.

*Example:*
     LIB "primdec.lib";
     ring  r = 32003,(x,y,z),dp;
     ideal i = intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
     equidim(i);
     ==> [1]:
     ==>    _[1]=z4
     ==>    _[2]=y5
     ==>    _[3]=x5
     ==>    _[4]=x3z3
     ==>    _[5]=x4y4
     ==> [2]:
     ==>    _[1]=yz
     ==>    _[2]=xz
     ==>    _[3]=x2
     ==> [3]:
     ==>    _[1]=z


File: singular.hlp,  Node: equidimMax,  Next: equidimMaxEHV,  Prev: equidim,  Up: primdec_lib

D.4.7.12 equidimMax
...................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     equidimMax(i); i ideal

*Return:*
     ideal of equidimensional locus (of maximal dimension) of i.

*Example:*
     LIB "primdec.lib";
     ring  r = 32003,(x,y,z),dp;
     ideal i = intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
     equidimMax(i);
     ==> _[1]=z


File: singular.hlp,  Node: equidimMaxEHV,  Next: zerodec,  Prev: equidimMax,  Up: primdec_lib

D.4.7.13 equidimMaxEHV
......................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     equidimMaxEHV(i); i ideal

*Return:*
     ideal, the equidimensional component (of maximal dimension) of i.

*Note:*
     Uses algorithm of Eisenbud, Huneke and Vasconcelos.

*Example:*
     LIB "primdec.lib";
     ring  r = 0,(x,y,z),dp;
     ideal i=intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
     equidimMaxEHV(i);
     ==> _[1]=z


File: singular.hlp,  Node: zerodec,  Prev: equidimMaxEHV,  Up: primdec_lib

D.4.7.14 zerodec
................

Procedure from library `primdec.lib' (*note primdec_lib::).

*Usage:*
     zerodec(I); I ideal

*Assume:*
     I is zero-dimensional, the characteristic of the ground field is 0

*Return:*
     list of primary ideals, the zero-dimensional decomposition of I

*Note:*
     The algorithm (of Monico), works well only for a small total number
     of solutions (`vdim(std(I))' should be < 100) and without
     parameters. In practice, it works also in large characteristic p>0
     but may fail for small p.
     If printlevel > 0 (default = 0) additional information is
     displayed.

*Example:*
     LIB "primdec.lib";
     ring r  = 0,(x,y),dp;
     ideal i = x2-2,y2-2;
     list pr = zerodec(i);
     pr;
     ==> [1]:
     ==>    _[1]=y2-2
     ==>    _[2]=xy-2
     ==>    _[3]=x2-2
     ==> [2]:
     ==>    _[1]=y2-2
     ==>    _[2]=xy+2
     ==>    _[3]=x2-2


File: singular.hlp,  Node: primitiv_lib,  Next: reesclos_lib,  Prev: primdec_lib,  Up: Commutative algebra

D.4.8 primitiv_lib
------------------

*Library:*
     primitiv.lib

*Purpose:*
     Computing a Primitive Element

*Author:*
     Martin Lamm, email: lamm@mathematik.uni-kl.de

*Procedures:*

* Menu:

* primitive:: find minimal polynomial for a primitive element
* primitive_extra:: find primitive element for two generators
* splitring:: define ring extension with name R and switch to it


File: singular.hlp,  Node: primitive,  Next: primitive_extra,  Up: primitiv_lib

D.4.8.1 primitive
.................

Procedure from library `primitiv.lib' (*note primitiv_lib::).

*Usage:*
     primitive(i); i ideal

*Assume:*
     i is given by generators m[1],...,m[n] such that for j=1,...,n
     - m[j] is a polynomial in k[x(1),...,x(j)]
     - m[j](a[1],...,a[j-1],x(j)) is the minimal polynomial for a[j]
     over k(a[1],...,a[j-1])
     (k the ground field of the current basering and x(1),...,x(n) the
     ring variables).

*Return:*
     ideal j in k[x(n)] with
     - j[1] a minimal polynomial for a primitive element b of
     k(a[1],...,a[n]) over k,
     - j[2],...,j[n+1] polynomials in k[x(n)] such that j[i+1](b)=a[i]
     for i=1,...,n.

*Note:*
     the number of variables in the basering has to be exactly n, the
     number of given generators (i.e., minimal polynomials).
     If the ground field k has only a few elements it may happen that no
     linear combination of a[1],...,a[n] is a primitive element. In this
     case `primitive(i)' returns the zero ideal, and one should use
     `primitive_extra(i)' instead.

*Example:*
     LIB "primitiv.lib";
     ring exring=0,(x,y),dp;
     ideal i=x2+1,y2-x;                  // compute Q(i,i^(1/2))=:L
     ideal j=primitive(i);
     j[1];                               // L=Q(a) with a=(-1)^(1/4)
     ==> y4+1
     j[2];                               // i=a^2
     ==> y2
     j[3];                               // i^(1/2)=a
     ==> y
     // the 2nd element was already primitive!
     j=primitive(ideal(x2-2,y2-3));      // compute Q(sqrt(2),sqrt(3))
     j[1];
     ==> y4-10y2+1
     j[2];
     ==> 1/2y3-9/2y
     j[3];
     ==> -1/2y3+11/2y
     // no element was primitive -- the calculation of primitive elements 
     // is based on a random choice.

* Menu:

See also:
* primitive_extra::

*See also:* *note primitive_extra::.


File: singular.hlp,  Node: primitive_extra,  Next: splitring,  Prev: primitive,  Up: primitiv_lib

D.4.8.2 primitive_extra
.......................

Procedure from library `primitiv.lib' (*note primitiv_lib::).

*Usage:*
     primitive_extra(i); i ideal

*Assume:*
     The ground field of the basering is k=Q or k=Z/pZ and the ideal i
     is given by 2 generators f,g with the following properties:

        f is the minimal polynomial of a in k[x], 
        g is a polynomial in k[x,y] s.th. g(a,y) is the minpoly of b in k(a)[y].

     Here, x is the name of the first ring variable, y the name of the
     second.

*Return:*
     ideal j in k[y] such that

        j[1] is the minimal polynomial for a primitive element c of k(a,b) over k,
        j[2] is a polynomial s.th. j[2](c)=a.

*Note:*
     While `primitive(i)' may fail for finite fields,
     `primitive_extra(i)' tries all elements of k(a,b) and, hence,
     always finds a primitive element.
     In order to do this (try all elements), field extensions like
     Z/pZ(a) are not allowed for the ground field k.
     `primitive_extra(i)' assumes that the second generator, g, is monic
     as polynomial in (k[x])[y].

*Example:*
     LIB "primitiv.lib";
     ring exring=3,(x,y),dp;
     ideal i=x2+1,y3+y2-1;
     primitive_extra(i);
     ==> _[1]=y6-y5+y4-y3-y-1
     ==> _[2]=y5+y4+y2+y+1
     ring extension=(3,y),x,dp;
     minpoly=y6-y5+y4-y3-y-1;
     number a=y5+y4+y2+y+1;
     a^2;
     ==> -1
     factorize(x2+1);
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=x+(-y5-y4-y2-y-1)
     ==>    _[3]=x+(y5+y4+y2+y+1)
     ==> [2]:
     ==>    1,1,1
     factorize(x3+x2-1);
     ==> [1]:
     ==>    _[1]=1
     ==>    _[2]=x+(-y5-y4-y3-y2-y-1)
     ==>    _[3]=x+(y5+y4+y2+1)
     ==>    _[4]=x+(y3+y+1)
     ==> [2]:
     ==>    1,1,1,1


File: singular.hlp,  Node: splitring,  Prev: primitive_extra,  Up: primitiv_lib

D.4.8.3 splitring
.................

Procedure from library `primitiv.lib' (*note primitiv_lib::).

*Usage:*
     splitring(f,R[,L]); f poly, R string, L list of polys and/or ideals
     (optional)

*Assume:*
     f is univariate and irreducible over the active basering.
     The active ring must allow an algebraic extension (e.g., it cannot
     be a transcendent ring extension of Q or Z/p).

*Create:*
     a ring with name R, in which f is reducible, and CHANGE to it.

*Return:*
     list L mapped into the new ring R, if L is given; else nothing

*Note:*
     If the old ring has no parameter, the name `a' is chosen for the
     parameter of R (if `a' is no ring variable; if it is, `b' is
     chosen, etc.; if `a,b,c,o' are ring variables, `splitring(f,R[,L])'
     produces an error message), otherwise the name of the parameter is
     kept and only the minimal polynomial is changed.
     The names of the ring variables and the orderings are not affected.

     It is also allowed to call `splitring' with R="".  Then the old
     basering will be REPLACED by the new ring (with the same name as
     the old ring).

*Example:*
     LIB "primitiv.lib";
     ring r=0,(x,y),dp;
     splitring(x2-2,"r1");   // change to Q(sqrt(2))
     // change to Q(sqrt(2),sqrt(sqrt(2)))=Q(a) and return the transformed 
     // old parameter:
     splitring(x2-a,"r2",a); 
     ==> // new minimal polynomial: a4-2
     ==> [1]:
     ==>    (a2)
     // the result is (a)^2 = (sqrt(sqrt(2)))^2
     nameof(basering);
     ==> r2
     r2;
     ==> //   characteristic : 0
     ==> //   1 parameter    : a 
     ==> //   minpoly        : (a4-2)
     ==> //   number of vars : 2
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y 
     ==> //        block   2 : ordering C
     kill r1; kill r2;


File: singular.hlp,  Node: reesclos_lib,  Next: intprog_lib,  Prev: primitiv_lib,  Up: Commutative algebra

D.4.9 reesclos_lib
------------------

*Library:*
     reesclos.lib

*Purpose:*
     procedures to compute the int. closure of an ideal

*Author:*
     Tobias Hirsch, email: hirsch@math.tu-cottbus.de

*Overview:*
     A library to compute the integral closure of an ideal I in a
     polynomial ring R=K[x(1),...,x(n)] using the Rees Algebra R[It] of
     I. It computes the integral closure of R[It] (in the same manner as
     done in the library 'normal.lib'), which is a graded subalgebra of
     R[t]. The degree-k-component is the integral closure of the k-th
     power of I.
     These procedures can also be used to compute the integral closure
     R^ of an integral domain R=k[x(1),...,x(n)]/ker, ker a prime ideal,
     in its quotient field K=Q(R), as an affine ring
     R^=k[T(1),...,T(s)]]/J and to get representations of elements of R^
     as fractions of elements of R.

*Procedures:*

* Menu:

* ReesAlgebra:: computes the Rees Algebra of an ideal I
* normalI:: computes the integral closure of an ideal I using R[It]
* primeClosure:: computes the integral closure of the int. domain R
* closureRingtower:: defines the rings in the list L as global objects R(i)
* closureFrac:: computes fractions representing elements of R^=L[n]


File: singular.hlp,  Node: ReesAlgebra,  Next: normalI,  Up: reesclos_lib

D.4.9.1 ReesAlgebra
...................

Procedure from library `reesclos.lib' (*note reesclos_lib::).

*Usage:*
     ReesAlgebra (I); I = ideal

*Return:*
     The Rees algebra R[It] as an affine ring, where I is an ideal in R.
     The procedure returns a list containing two rings:
     [1]: a ring, say RR; in the ring an ideal ker such that
     R[It]=RR/ker

     [2]: a ring, say Kxt; the basering with additional variable t
     containing an ideal mapI that defines the map RR->Kxt

*Example:*
     LIB "reesclos.lib";
     ring R = 0,(x,y),dp;
     ideal I = x2,xy4,y5;
     list L = ReesAlgebra(I);
     def Rees = L[1];       // defines the ring Rees, containing the ideal ker
     setring Rees;          // passes to the ring Rees
     Rees;
     ==> //   characteristic : 0
     ==> //   number of vars : 5
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y U(1) U(2) U(3) 
     ==> //        block   2 : ordering C
     ker;                   // R[It] is isomorphic to Rees/ker
     ==> ker[1]=y*U(2)-x*U(3)
     ==> ker[2]=y^3*U(1)*U(3)-U(2)^2
     ==> ker[3]=y^4*U(1)-x*U(2)
     ==> ker[4]=x*y^2*U(1)*U(3)^2-U(2)^3
     ==> ker[5]=x^2*y*U(1)*U(3)^3-U(2)^4
     ==> ker[6]=x^3*U(1)*U(3)^4-U(2)^5


File: singular.hlp,  Node: normalI,  Next: primeClosure,  Prev: ReesAlgebra,  Up: reesclos_lib

D.4.9.2 normalI
...............

Procedure from library `reesclos.lib' (*note reesclos_lib::).

*Usage:*
     normalI(I [,p[,c]]); I an ideal, p and c optional integers

*Return:*
     the integral closure of I,...,I^p. If p is not given, or p==0,
     compute the closure of all powers up to the maximum degree in t
     occurring in the generators of the closure of R[It] (so this is the
     last one that is not just the sum/product of the above ones).  c is
     transferred to the procedure primeClosure and toggles its behavior
     in computing the integral closure of R[It].
     The result is a list containing the closure of the desired powers
     of I as ideals of the basering.

*Example:*
     LIB "reesclos.lib";
     ring R=0,(x,y),dp;
     ideal I = x2,xy4,y5;
     list J = normalI(I);
     I;
     ==> I[1]=x2
     ==> I[2]=xy4
     ==> I[3]=y5
     J;                             // J[1] is the integral closure of I
     ==> [1]:
     ==>    _[1]=x2
     ==>    _[2]=y5
     ==>    _[3]=-xy3


File: singular.hlp,  Node: primeClosure,  Next: closureRingtower,  Prev: normalI,  Up: reesclos_lib

D.4.9.3 primeClosure
....................

Procedure from library `reesclos.lib' (*note reesclos_lib::).

*Usage:*
     primeClosure(L [,c]); L a list of a ring containing a prime ideal
     ker, c an optional integer

*Return:*
     a list L consisting of rings L[1],...,L[n] such that
     - L[1] is a copy of (not a reference to!) the input ring L[1] - all
     rings L[i] contain ideals ker, L[2],...,L[n] contain ideals phi
     such that
     L[1]/ker -> ... -> L[n]/ker
     are injections given by the corresponding ideals phi, and L[n]/ker
     is the integral closure of L[1]/ker in its quotient field.  - all
     rings L[i] contain a polynomial nzd such that elements of L[i]/ker
     are quotients of elements of L[i-1]/ker with denominator nzd via
     the injection phi.

*Note:*
     - L is constructed by recursive calls of primeClosure itself.  - c
     determines the choice of nzd:
     - c not given or equal to 0: first generator of the ideal SL, the
     singular locus of Spec(L[i]/ker)
     - c<>0: the generator of SL with least number of monomials.

*Example:*
     LIB "reesclos.lib";
     ring R=0,(x,y),dp;
     ideal I=x4,y4;
     def K=ReesAlgebra(I)[1];        // K contains ker such that K/ker=R[It]
     list L=primeClosure(K);
     def R(1)=L[1];                  // L[4] contains ker, L[4]/ker is the
     def R(4)=L[4];                  // integral closure of L[1]/ker
     setring R(1);
     R(1);
     ==> //   characteristic : 0
     ==> //   number of vars : 4
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y U(1) U(2) 
     ==> //        block   2 : ordering C
     ker;
     ==> ker[1]=y^4*U(1)-x^4*U(2)
     setring R(4);
     R(4);
     ==> //   characteristic : 0
     ==> //   number of vars : 7
     ==> //        block   1 : ordering a
     ==> //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
     ==> //                  : weights     1    1    1    1    1    1    1 
     ==> //        block   2 : ordering dp
     ==> //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
     ==> //        block   3 : ordering C
     ker;
     ==> ker[1]=T(2)*T(5)-T(1)*T(7)
     ==> ker[2]=T(1)*T(5)-T(2)*T(6)
     ==> ker[3]=T(5)*T(6)-T(3)*T(7)
     ==> ker[4]=T(4)*T(6)-T(5)*T(7)
     ==> ker[5]=T(5)^2-T(6)*T(7)
     ==> ker[6]=T(4)*T(5)-T(7)^2
     ==> ker[7]=T(3)*T(5)-T(6)^2
     ==> ker[8]=T(2)^2*T(6)-T(1)^2*T(7)
     ==> ker[9]=T(3)*T(4)-T(6)*T(7)
     ==> ker[10]=T(1)*T(4)-T(2)*T(7)
     ==> ker[11]=T(2)*T(3)-T(1)*T(6)
     ==> ker[12]=T(2)^2*T(6)^2-T(1)^2*T(6)*T(7)


File: singular.hlp,  Node: closureRingtower,  Next: closureFrac,  Prev: primeClosure,  Up: reesclos_lib

D.4.9.4 closureRingtower
........................

Procedure from library `reesclos.lib' (*note reesclos_lib::).

*Usage:*
     closureRingtower(list L); L a list of rings

*Create:*
     rings R(1),...,R(n) such that R(i)=L[i] for all i

*Example:*
     LIB "reesclos.lib";
     ring R=0,(x,y),dp;
     ideal I=x4,y4;
     list L=primeClosure(ReesAlgebra(I)[1]);
     closureRingtower(L);
     R(1);
     ==> //   characteristic : 0
     ==> //   number of vars : 4
     ==> //        block   1 : ordering dp
     ==> //                  : names    x y U(1) U(2) 
     ==> //        block   2 : ordering C
     R(4);
     ==> //   characteristic : 0
     ==> //   number of vars : 7
     ==> //        block   1 : ordering a
     ==> //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
     ==> //                  : weights     1    1    1    1    1    1    1 
     ==> //        block   2 : ordering dp
     ==> //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
     ==> //        block   3 : ordering C


File: singular.hlp,  Node: closureFrac,  Prev: closureRingtower,  Up: reesclos_lib

D.4.9.5 closureFrac
...................

Procedure from library `reesclos.lib' (*note reesclos_lib::).

*Create:*
     a list fraction of two elements of L[1], such that
     f=fraction[1]/fraction[2] via the injections phi L[i]->L[i+1].

*Example:*
     LIB "reesclos.lib";
     ring R=0,(x,y),dp;
     ideal ker=x2+y2;
     export R;
     ==> // ** `R` is already global
     list L=primeClosure(R);          // We normalize R/ker
     closureRingtower(L);             // Now R/ker=R(1) with normalization R(2)
     setring R(2);
     kill(R);
     phi;                             // The map R(1)-->R(2)
     ==> phi[1]=T(1)*T(2)
     ==> phi[2]=T(1)
     poly f=T(1)*T(2);                // We will get a representation of f
     export R(2);
     ==> // ** `R(2)` is already global
     closureFrac(L);
     setring R(1);
     kill (R(2));
     fraction;                        // f=fraction[1]/fraction[2] via phi
     ==> [1]:
     ==>    xy
     ==> [2]:
     ==>    y


File: singular.hlp,  Node: intprog_lib,  Next: toric_lib,  Prev: reesclos_lib,  Up: Commutative algebra

D.4.10 intprog_lib
------------------

*Library:*
     intprog.lib

*Purpose:*
     Integer Programming with Groebner Basis Methods

*Author:*
     Christine Theis, email: ctheis@math.uni-sb.de

*Procedures:*

* Menu:

* solve_IP:: procedures for solving Integer Programming problems


File: singular.hlp,  Node: solve_IP,  Up: intprog_lib

D.4.10.1 solve_IP
.................

Procedure from library `intprog.lib' (*note intprog_lib::).

*Usage:*
     solve_IP(A,bx,c,alg); A intmat, bx intvec, c intvec, alg string.
     solve_IP(A,bx,c,alg); A intmat, bx list of intvec, c intvec, alg
     string.
     solve_IP(A,bx,c,alg,prsv); A intmat, bx intvec, c intvec, alg
     string, prsv intvec.
     solve_IP(A,bx,c,alg,prsv); A intmat, bx list of intvec, c intvec,
     alg string, prsv intvec.

*Return:*
     same type as bx: solution of the associated integer programming
     problem(s) as explained in

     *note Toric ideals and integer programming::.

*Note:*
     This procedure returns the solution(s) of the given IP-problem(s)
     or the message `not solvable'.
     One may call the procedure with several different algorithms:
     - the algorithm of Conti/Traverso (ct),
     - the positive variant of the algorithm of Conti/Traverso (pct),
     - the algorithm of Conti/Traverso using elimination (ect),
     - the algorithm of Pottier (pt),
     - an algorithm of Bigatti/La Scala/Robbiano (blr),
     - the algorithm of Hosten/Sturmfels (hs),
     - the algorithm of DiBiase/Urbanke (du).  The argument `alg' should
     be the abbreviation for an algorithm as above: ct, pct, ect, pt,
     blr, hs or du.

     `ct' allows computation of an optimal solution of the IP-problem
     directly from the right-hand vector b.
     The same is true for its `positive' variant `pct' which may only be
     applied if A and b have nonnegative entries.
     All other algorithms need initial solutions of the IP-problem.

     If `alg' is chosen to be `ct' or `pct', bx is read as the right
     hand vector b of the system Ax=b. b should then be an intvec of
     size m where m is the number of rows of A.
     Furthermore, bx and A should be nonnegative if `pct' is used.  If
     `alg' is chosen to be `ect',`pt',`blr',`hs' or `du', bx is read as
     an initial solution x of the system Ax=b.  bx should then be a
     nonnegative intvec of size n where n is the number of columns of A.

     If `alg' is chosen to be `blr' or `hs', the algorithm needs a
     vector with positive coefficients in the row space of A.
     If no row of A contains only positive entries, one has to use the
     versions of solve_IP which take such a vector prsv as an argument.

     solve_IP may also be called with a list bx of intvecs instead of a
     single intvec.

*Example:*
     LIB "intprog.lib";
     // 1. call with single right-hand vector
     intmat A[2][3]=1,1,0,0,1,1;
     intvec b1=1,1;
     intvec c=2,2,1;
     intvec solution_vector=solve_IP(A,b1,c,"pct");
     solution_vector;"";
     ==> 0,1,0
     ==> 
     // 2. call with list of right-hand vectors
     intvec b2=-1,1;
     list l=b1,b2;
     l;
     ==> [1]:
     ==>    1,1
     ==> [2]:
     ==>    -1,1
     list solution_list=solve_IP(A,l,c,"ct");
     solution_list;"";
     ==> [1]:
     ==>    0,1,0
     ==> [2]:
     ==>    not solvable
     ==> 
     // 3. call with single initial solution vector
     A=2,1,-1,-1,1,2;
     b1=3,4,5;
     solve_IP(A,b1,c,"du");"";
     ==> 0,7,2
     ==> 
     // 4. call with single initial solution vector
     //    and algorithm needing a positive row space vector
     solution_vector=solve_IP(A,b1,c,"hs");"";
     ==> ERROR: The chosen algorithm needs a positive vector in the row space of t\
        he matrix.
     ==> 0
     ==> 
     // 5. call with single initial solution vector
     //     and positive row space vector
     intvec prsv=1,2,1;
     solution_vector=solve_IP(A,b1,c,"hs",prsv);
     solution_vector;"";
     ==> 0,7,2
     ==> 
     // 6. call with list of initial solution vectors
     //    and positive row space vector
     b2=7,8,0;
     l=b1,b2;
     l;
     ==> [1]:
     ==>    3,4,5
     ==> [2]:
     ==>    7,8,0
     solution_list=solve_IP(A,l,c,"blr",prsv);
     solution_list;
     ==> [1]:
     ==>    0,7,2
     ==> [2]:
     ==>    7,8,0

* Menu:

See also:
* Integer programming::
* intprog_lib::
* toric_lib::

*See also:* *note Integer programming::; *note intprog_lib::; *note
toric_lib::.


File: singular.hlp,  Node: toric_lib,  Prev: intprog_lib,  Up: Commutative algebra

D.4.11 toric_lib
----------------

*Library:*
     toric.lib

*Purpose:*
     Standard Basis of Toric Ideals

*Author:*
     Christine Theis, email: ctheis@math.uni-sb.de

*Procedures:*

* Menu:

* toric_ideal:: computes the toric ideal of A
* toric_std:: standard basis of I by a specialized Buchberger algorithm


File: singular.hlp,  Node: toric_ideal,  Next: toric_std,  Up: toric_lib

D.4.11.1 toric_ideal
....................

Procedure from library `toric.lib' (*note toric_lib::).

*Usage:*
     toric_ideal(A,alg); A intmat, alg string
     toric_ideal(A,alg,prsv); A intmat, alg string, prsv intvec

*Return:*
     ideal: standard basis of the toric ideal of A

*Note:*
     These procedures return the standard basis of the toric ideal of A
     with respect to the term ordering in the current basering. Not all
     term orderings are supported: The usual global term orderings may
     be used, but no block orderings combining them.
     One may call the procedure with several different algorithms:
     - the algorithm of Conti/Traverso using elimination (ect),
     - the algorithm of Pottier (pt),
     - an algorithm of Bigatti/La Scala/Robbiano (blr),
     - the algorithm of Hosten/Sturmfels (hs),
     - the algorithm of DiBiase/Urbanke (du).
     The argument `alg' should be the abbreviation for an algorithm as
     above: ect, pt, blr, hs or du.

     If `alg' is chosen to be `blr' or `hs', the algorithm needs a
     vector with positive coefficients in the row space of A.
     If no row of A contains only positive entries, one has to use the
     second version of toric_ideal which takes such a vector as its
     third argument.
     For the mathematical background, see

     *note Toric ideals and integer programming::.

*Example:*
     LIB "toric.lib";
     ring r=0,(x,y,z),dp;
     // call with two arguments
     intmat A[2][3]=1,1,0,0,1,1;
     A;
     ==> 1,1,0,
     ==> 0,1,1 
     ideal I=toric_ideal(A,"du");
     I;
     ==> I[1]=xz-y
     I=toric_ideal(A,"blr");
     ==> ERROR: The chosen algorithm needs a positive vector in the row space of t\
        he matrix.
     I;
     ==> I[1]=0
     // call with three arguments
     intvec prsv=1,2,1;
     I=toric_ideal(A,"blr",prsv);
     I;
     ==> I[1]=xz-y

* Menu:

See also:
* Toric ideals::
* intprog_lib::
* toric_lib::
* toric_std::

*See also:* *note Toric ideals::; *note intprog_lib::; *note
toric_lib::; *note toric_std::.


File: singular.hlp,  Node: toric_std,  Prev: toric_ideal,  Up: toric_lib

D.4.11.2 toric_std
..................

Procedure from library `toric.lib' (*note toric_lib::).

*Usage:*
     toric_std(I); I ideal

*Return:*
     ideal: standard basis of I

*Note:*
     This procedure computes the standard basis of I using a specialized
     Buchberger algorithm. The generating system by which I is given has
     to consist of binomials of the form x^u-x^v. There is no real check
     if I is toric. If I is generated by binomials of the above form,
     but not toric, toric_std computes an ideal `between' I and its
     saturation with respect to all variables.
     For the mathematical background, see

     *note Toric ideals and integer programming::.

*Example:*
     LIB "toric.lib";
     ring r=0,(x,y,z),wp(3,2,1);
     // call with toric ideal (of the matrix A=(1,1,1))
     ideal I=x-y,x-z;
     ideal J=toric_std(I);
     J;
     ==> J[1]=y-z
     ==> J[2]=x-z
     // call with the same ideal, but badly chosen generators:
     // 1) not only binomials
     I=x-y,2x-y-z;
     J=toric_std(I);
     ==> ERROR: Generator 2 of the input ideal is no difference of monomials.
     // 2) binomials whose monomials are not relatively prime
     I=x-y,xy-yz,y-z;
     J=toric_std(I);
     ==> Warning: The monomials of generator 2 of the input ideal are not relative\
        ly prime.
     J;
     ==> J[1]=y-z
     ==> J[2]=x-z
     // call with a non-toric ideal that seems to be toric
     I=x-yz,xy-z;
     J=toric_std(I);
     J;
     ==> J[1]=y2-1
     ==> J[2]=x-yz
     // comparison with real standard basis and saturation
     ideal H=std(I);
     H;
     ==> H[1]=x-yz
     ==> H[2]=y2z-z
     LIB "elim.lib";
     sat(H,xyz);
     ==> [1]:
     ==>    _[1]=x-yz
     ==>    _[2]=y2-1
     ==> [2]:
     ==>    1

* Menu:

See also:
* Toric ideals::
* intprog_lib::
* toric_ideal::
* toric_lib::

*See also:* *note Toric ideals::; *note intprog_lib::; *note
toric_ideal::; *note toric_lib::.


File: singular.hlp,  Node: Singularities,  Next: Invariant theory,  Prev: Commutative algebra,  Up: SINGULAR libraries

D.5 Singularities
=================

* Menu:

* classify_lib:: procedures for the Arnold-classifier of singularities
* deform_lib:: procedures for computing miniversal deformation
* equising_lib:: procedures for equisingularity strata
* gaussman_lib:: procedures for gauss-manin connection of a singularity
* hnoether_lib:: procedures for the Hamburger-Noether (Puiseux) development
* mondromy_lib:: procedures to compute the monodromy of a singularity
* qhmoduli_lib:: procedures for moduli spaces of sqh-singularities
* sing_lib:: procedures for computing invariants of singularities
* spcurve_lib:: procedures for cm codimension 2 singularities
* spectrum_lib:: procedures for computing singularity spectra


File: singular.hlp,  Node: classify_lib,  Next: deform_lib,  Prev: Singularities,  Up: Singularities

D.5.1 classify_lib
------------------

*Library:*
     classify.lib

*Purpose:*
     Arnold Classifier of Singularities

*Authors:*
     Kai Krueger, krueger@mathematik.uni-kl.de
     Corina Baciu, baciu@mathematik.uni-kl.de

*Overview:*
     A library for classifying isolated hypersurface singularities
     w.r.t. right equivalence, based on the determinator of
     singularities by V.I. Arnold.

*Procedures:*

* Menu:

* basicinvariants:: computes Milnor number, determinacy-bound and corank of
* classify:: normal form of poly f determined with Arnold's method
* corank:: computes the corank of f (i.e. of the Hessian of f)
* Hcode:: coding of intvec v according to the number repetitions
* init_debug:: print trace and debugging information depending on int n
* internalfunctions:: display names of internal procedures of this library
* milnorcode:: Hilbert poly of [e-th] Milnor algebra coded with Hcode
* morsesplit:: residual part of f after applying the splitting lemma
* quickclass:: normal form of f determined by invariants (milnorcode)
* singularity:: normal form of singularity given by its name s and index
* swap:: returns b,a
* A_L:: shortcut for quickclass(f) or normalform(s)
* normalform:: normal form of singularity given by its name s
* debug_log:: print trace and debugging information w.r.t level>@DeBug


File: singular.hlp,  Node: basicinvariants,  Next: classify,  Up: classify_lib

D.5.1.1 basicinvariants
.......................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     basicinvariants(f); f = poly

*Compute:*
     Compute basic invariants of f: an upper bound d for the
     determinacy, the milnor number mu and the corank c of f

*Return:*
     intvec: d, mu, c

*Example:*
     LIB "classify.lib";
     ring r=0,(x,y,z),ds;
     basicinvariants((x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3);
     ==> 5,4,2


File: singular.hlp,  Node: classify,  Next: corank,  Prev: basicinvariants,  Up: classify_lib

D.5.1.2 classify
................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     classify(f); f=poly

*Compute:*
     normal form and singularity type of f with respect to right
     equivalence, as given in the book "Singularities of differentiable
     maps, Volume I" by V.I. Arnold, S.M. Gusein-Zade, A.N. Varchenko

*Return:*
     normal form of f, of type poly

*Remark:*
     This version of classify is only beta. Please send bugs and
     comments to: "Kai Krueger" <krueger@mathematik.uni-kl.de>
     Be sure to have at least Singular version 1.0.1. Updates can be
     found at:
     URL=http://www.mathematik.uni-kl.de/~krueger/Singular/

*Note:*
     type init_debug(n); (0 <= n <= 10) in order to get intermediate
     information, higher values of n give more information.
     The proc creates several global objects with names all starting
     with @, hence there should be no name conflicts

*Example:*
     LIB "classify.lib";
     ring r=0,(x,y,z),ds;
     poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
     classify(f);
     ==> About the singularity :
     ==>           Milnor number(f)   = 4
     ==>           Corank(f)          = 2
     ==>           Determinacy       <= 5
     ==> Guessing type via Milnorcode:   D[k]=D[4]
     ==> 
     ==> Computing normal form ...
     ==> I have to apply the splitting lemma. This will take some time....:-)
     ==>    Arnold step number 4
     ==> The singularity
     ==>    -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
     ==> is R-equivalent to D[4].
     ==>    Milnor number = 4
     ==>    modality      = 0
     ==> 2z2+x2y+y3
     init_debug(3);
     ==> Debugging level change from  0  to  3
     classify(f);
     ==> Computing Basicinvariants of f ...
     ==> About the singularity :
     ==>           Milnor number(f)   = 4
     ==>           Corank(f)          = 2
     ==>           Determinacy       <= 5
     ==> Hcode: 1,2,1,0,0
     ==> Milnor code :  1,1,1
     ==> Debug:(2):  entering HKclass3_teil_1 1,1,1
     ==> Debug:(2):  finishing HKclass3_teil_1
     ==> Guessing type via Milnorcode:   D[k]=D[4]
     ==> 
     ==> Computing normal form ...
     ==> I have to apply the splitting lemma. This will take some time....:-)
     ==> Debug:(3):  Split the polynomial below using determinacy:  5
     ==> Debug:(3):  9y2-12yz+4z2-x3+6x2y-4x2z+xyz+x4+3x2y3
     ==> Debug:(2):  Permutations: 3,2,1
     ==> Debug:(2):  Permutations: 3,2,1
     ==> Debug:(2):  rank determined with Morse rg= 1
     ==> Residual singularity f= -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
     ==> Step 3
     ==>    Arnold step number 4
     ==> The singularity
     ==>    -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
     ==> is R-equivalent to D[4].
     ==>    Milnor number = 4
     ==>    modality      = 0
     ==> Debug:(2):  Decode:
     ==> Debug:(2):  S_in= D[4]   s_in= D[4]                          
     ==> Debug:(2):  Looking for Normalform of  D[k] with (k,r,s) = ( 4 , 0 , 0 )
     ==> Debug:(2):  Opening Singalarity-database:  
     ==>  DBM: NFlist
     ==> Debug:(2):  DBMread( D[k] )= x2y+y^(k-1) .
     ==> Debug:(2):  S= f = x2y+y^(k-1);  Tp= x2y+y^(k-1) Key= I_D[k]
     ==> Polynom f= x2y+y3   crk= 2   Mu= 4  MlnCd= 1,1,1
     ==> Debug:(2):  Info= x2y+y3
     ==> Debug:(2):  Normal form NF(f)= 2*x(3)^2+x(1)^2*x(2)+x(2)^3
     ==> 2z2+x2y+y3


File: singular.hlp,  Node: corank,  Next: Hcode,  Prev: classify,  Up: classify_lib

D.5.1.3 corank
..............

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     corank(f); f=poly

*Return:*
     the corank of the Hessian matrix of f, of type int

*Remark:*
     corank(f) is the number of variables occurring in the residual
     singularity after applying 'morsesplit' to f

*Example:*
     LIB "classify.lib";
     ring r=0,(x,y,z),ds;
     poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
     corank(f);
     ==> 2


File: singular.hlp,  Node: Hcode,  Next: init_debug,  Prev: corank,  Up: classify_lib

D.5.1.4 Hcode
.............

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     Hcode(v); v=intvec

*Return:*
     intvec, coding v according to the number of successive repetitions
     of an entry

*Example:*
     LIB "classify.lib";
     intvec v1 = 1,3,5,5,2;
     Hcode(v1);
     ==> 1,0,1,0,2,0,0,1,0
     intvec v2 = 1,2,3,4,4,4,4,4,4,4,3,2,1;
     Hcode(v2);
     ==> 1,1,1,7,1,1,1


File: singular.hlp,  Node: init_debug,  Next: internalfunctions,  Prev: Hcode,  Up: classify_lib

D.5.1.5 init_debug
..................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     init_debug([level]); level=int

*Compute:*
     Set the global variable @DeBug to level. The variable @DeBug is
     used by the function debug_log(level, list of strings) to know when
     to print the list of strings. init_debug() reports only changes of
     @DeBug.

*Note:*
     The procedure init_debug(n); is useful as trace-mode. n may range
     from 0 to 10, higher values of n give more information.

*Example:*
     LIB "classify.lib";
     init_debug();
     debug_log(1,"no trace information printed");
     init_debug(1);
     ==> Debugging level change from  0  to  1
     debug_log(1,"some trace information");
     ==> some trace information
     init_debug(2);
     ==> Debugging level change from  1  to  2
     debug_log(2,"nice for debugging scripts");
     ==> Debug:(2):  nice for debugging scripts
     init_debug(0);
     ==> Debugging switched off.


File: singular.hlp,  Node: internalfunctions,  Next: milnorcode,  Prev: init_debug,  Up: classify_lib

D.5.1.6 internalfunctions
.........................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     internalfunctions();

*Return:*
     nothing, display names of internal procedures of classify.lib

*Example:*
     LIB "classify.lib";
     internalfunctions();
     ==>    Internal functions for the classification using Arnold's method,
     ==>    the function numbers correspond to numbers in Arnold's classifier:
     ==> Klassifiziere(poly f);      //determine the type of the singularity f
     ==>   Funktion1bis (poly f, list cstn)
     ==>   Funktion3 (poly f, list cstn)
     ==>   Funktion6 (poly f, list cstn)
     ==>   Funktion13 (poly f, list cstn)
     ==>   Funktion17 (poly f, list cstn)
     ==>   Funktion25 (poly f, list cstn)
     ==>   Funktion40 (poly f, list cstn, int k)
     ==>   Funktion47 (poly f, list cstn)
     ==>   Funktion50 (poly f, list cstn)
     ==>   Funktion58 (poly fin, list cstn)
     ==>   Funktion59 (poly f, list cstn)
     ==>   Funktion66 (poly f, list cstn)
     ==>   Funktion82 (poly f, list cstn)
     ==>   Funktion83 (poly f, list cstn)
     ==>   Funktion91 (poly f, list cstn, int k)
     ==>   Funktion92 (poly f, list cstn, int k)
     ==>   Funktion93 (poly f, list cstn, int k)
     ==>   Funktion94 (poly f, list cstn, int k)
     ==>   Funktion95 (poly f, list cstn, int k)
     ==>   Funktion96 (poly f, list cstn, int k)
     ==>   Funktion97 (poly f, list cstn)
     ==>   Isomorphie_s82_x (poly f, poly fk, int k)
     ==>   Isomorphie_s82_z (poly f, poly fk, int k)
     ==>   Isomorphie_s17 (poly f, poly fk, int k, int ct)
     ==>   printresult (string f,string typ,int Mu,int m,int corank,int K)
     ==>   
     ==>    Internal functions for the classifcation by invariants:
     ==>   Cubic (poly f)
     ==>   parity (int e)             //return the parity of e
     ==>   HKclass (intvec i)
     ==>   HKclass3( intvec i, string SG_Typ, int cnt)
     ==>   HKclass3_teil_1 (intvec i, string SG_Typ, int cnt)
     ==>   HKclass5 (intvec i, string SG_Typ, int cnt)
     ==>   HKclass5_teil_1 (intvec i, string SG_Typ, int cnt)
     ==>   HKclass5_teil_2 (intvec i, string SG_Typ, int cnt)
     ==>   HKclass7 (intvec i, string SG_Typ, int cnt)
     ==>   HKclass7_teil_1 (intvec i, string SG_Typ, int cnt)
     ==>   
     ==>    Internal functions for the Morse-splitting lemma:
     ==>   Morse(poly fi, int K, int corank)  //splitting lemma itself
     ==>   Coeffs (list #)
     ==>   Coeff
     ==>   
     ==>    Internal functions providing tools:
     ==>   ReOrder(poly f)
     ==>   Singularitaet(string typ,int k,int r,int s,poly a,poly b,poly c,poly d)
     ==>   RandomPolyK
     ==>   Faktorisiere(poly f, poly g, int p, int k)   compute g = (ax+by^k)^p
     ==>   Teile(poly f, poly g);             //divides f by g
     ==>   GetRf(poly f, int n);
     ==>   Show(poly f);
     ==>   checkring();
     ==>   DecodeNormalFormString(string s);
     ==>   Setring(int n, string ringname);
     ==>   


File: singular.hlp,  Node: milnorcode,  Next: morsesplit,  Prev: internalfunctions,  Up: classify_lib

D.5.1.7 milnorcode
..................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     milnorcode(f[,e]); f=poly, e=int

*Return:*
     intvec, coding the Hilbert function of the e-th Milnor algebra of
     f, i.e. of basering/(jacob(f)^e) (default e=1), according to proc
     Hcode

*Example:*
     LIB "classify.lib";
     ring r=0,(x,y,z),ds;
     poly f=x2y+y3+z2;
     milnorcode(f);
     ==> 1,1,1
     milnorcode(f,2);  // a big second argument may result in memory overflow
     ==> 1,0,1,0,2,0,0,1,0


File: singular.hlp,  Node: morsesplit,  Next: quickclass,  Prev: milnorcode,  Up: classify_lib

D.5.1.8 morsesplit
..................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     morsesplit(f); f=poly

*Return:*
     Normal form of f in M^3 after application of the splitting lemma

*Compute:*
     apply the splitting lemma (generalized Morse lemma) to f

*Example:*
     LIB "classify.lib";
     ring r=0,(x,y,z),ds;
     export r;
     ==> // ** `r` is already global
     init_debug(1);
     ==> Debugging level is set to  1
     poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
     poly g=morsesplit(f);
     ==> Residual singularity f= -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
     g;
     ==> -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3


File: singular.hlp,  Node: quickclass,  Next: singularity,  Prev: morsesplit,  Up: classify_lib

D.5.1.9 quickclass
..................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     quickclass(f); f=poly

*Return:*
     Normal form of f in Arnold's list

*Remark:*
     try to determine the normal form of f by invariants, mainly by
     computing the Hilbert function of the Milnor algebra, no coordinate
     change is needed (see also proc 'milnorcode').

*Example:*
     LIB "classify.lib";
     ring r=0,(x,y,z),ds;
     poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
     quickclass(f);
     ==> Singularity R-equivalent to :  D[k]=D[4]
     ==> normal form : z2+x2y+y3
     ==> z2+x2y+y3


File: singular.hlp,  Node: singularity,  Next: swap,  Prev: quickclass,  Up: classify_lib

D.5.1.10 singularity
....................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     singularity(t, l); t=string (name of singularity),
     l=list of integers/polynomials (indices/parameters of singularity)

*Compute:*
     get the singularity named by type t from the database.  list l is
     as follows:
     l= k [,r [,s [,a [,b [,c [,d]..]: k,r,s=int a,b,c,d=poly.
     The name of the dbm-database file is: NFlist.[dir,pag].  The file
     is found in the current directory. If it does not exist, please run
     the script MakeDBM first.

*Return:*
     Normal form and corank of the singularity named by type t and its
     index (indices) l.

*Example:*
     LIB "classify.lib";
     ring r=0,(x,y,z),(c,ds);
     init_debug(0);
     singularity("E[6k]",6);
     ==> [1]:
     ==>    x3+xy13+y19
     ==> [2]:
     ==>    2
     singularity("T[k,r,s]", 3, 7, 5);
     ==> [1]:
     ==>    x3+xyz+z5+y7
     ==> [2]:
     ==>    3
     poly f=y;
     singularity("J[k,r]", 4, 0, 0, f);
     ==> [1]:
     ==>    x3+x2y4+y13
     ==> [2]:
     ==>    2


File: singular.hlp,  Node: swap,  Next: A_L,  Prev: singularity,  Up: classify_lib

D.5.1.11 swap
.............

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     swap(a,b);

*Return:*
     b,a if b,a is the input (any type)

*Example:*
     LIB "classify.lib";
     swap("variable1","variable2");
     ==> variable2 variable1


File: singular.hlp,  Node: A_L,  Next: normalform,  Prev: swap,  Up: classify_lib

D.5.1.12 A_L
............

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     A_L(f); f poly
     A_L(s); s string, the name of the singularity

*Compute:*
     the normal form of f in Arnold's list of singularities in case 1,
     in case 2 nothing has to be computed.

*Return:*
     A_L(f): compute via 'milnorcode' the class of f and return the
     normal form of f found in the database.
     A_L("name"): get the normal form from the database for the
     singularity given by its name.

*Example:*
     LIB "classify.lib";
     ring r=0,(a,b,c),ds;
     poly f=A_L("E[13]");
     f;
     ==> c2+a3+ab5+b8
     A_L(f);
     ==> Singularity R-equivalent to :  E[6k+1]=E[13]
     ==> normal form : c2+a3+ab5+b8
     ==> c2+a3+ab5+b8


File: singular.hlp,  Node: normalform,  Next: debug_log,  Prev: A_L,  Up: classify_lib

D.5.1.13 normalform
...................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     normalform(s); s=string

*Return:*
     Arnold's normal form of singularity with name s

*Example:*
     LIB "classify.lib";
     ring r=0,(a,b,c),ds;
     normalform("E[13]");
     ==> c2+a3+ab5+b8


File: singular.hlp,  Node: debug_log,  Prev: normalform,  Up: classify_lib

D.5.1.14 debug_log
..................

Procedure from library `classify.lib' (*note classify_lib::).

*Usage:*
     debug_log(level,li); level=int, li=comma separated "message" list

*Compute:*
     print "messages" if level>=@DeBug.
     useful for user-defined trace messages.

*Example:*
     LIB "classify.lib";
     example init_debug;
     ==> // proc init_debug from lib classify.lib
     ==> EXAMPLE:
     ==>   init_debug();
     ==>   debug_log(1,"no trace information printed");
     ==>   init_debug(1);
     ==> Debugging level change from  0  to  1
     ==>   debug_log(1,"some trace information");
     ==> some trace information
     ==>   init_debug(2);
     ==> Debugging level change from  1  to  2
     ==>   debug_log(2,"nice for debugging scripts");
     ==> Debug:(2):  nice for debugging scripts
     ==>   init_debug(0);
     ==> Debugging switched off.
     ==> 

* Menu:

See also:
* init_debug::

*See also:* *note init_debug::.


File: singular.hlp,  Node: deform_lib,  Next: equising_lib,  Prev: classify_lib,  Up: Singularities

D.5.2 deform_lib
----------------

*Library:*
     deform.lib

*Purpose:*
     Miniversal Deformation of Singularities and Modules

*Author:*
     Bernd Martin, email: martin@math.tu-cottbus.de

*Procedures:*

* Menu:

* versal:: miniversal deformation of isolated singularity Fo
* mod_versal:: miniversal deformation of module Mo modulo ideal I
* lift_kbase:: lifting N into standard kbase of M
* lift_rel_kb:: relative lifting N into a kbase of M
* kill_rings:: kills the exported rings from above


File: singular.hlp,  Node: versal,  Next: mod_versal,  Up: deform_lib

D.5.2.1 versal
..............

Procedure from library `deform.lib' (*note deform_lib::).

*Usage:*
     versal(Fo[,d,any]); Fo=ideal, d=int, any=list

*Compute:*
     miniversal deformation of Fo up to degree d (default d=100),

*Create:*
     Rings (exported):
     'my'Px = extending the basering Po by new variables given by
     "A,B,.." (deformation parameters), returns as basering; the new
     variables precede the old ones, the ordering is the product between
     "ls" and "ord(Po)"
     'my'Qx = Px/Fo extending Qo=Po/Fo,
     'my'So = the embedding-ring of the versal base space,
     'my'Ox = Px/Js extending So/Js. (default my="")

     Matrices (in Px, exported):
     Js = giving the versal base space (obstructions),
     Fs = giving the versal family of Fo,
     Rs = giving the lifting of Ro=syz(Fo).

     If d is defined (!=0), it computes up to degree d.
     If 'any' is defined and any[1] is no string, interactive version.
     Otherwise 'any' gives predefined strings:
     "my","param","order","out" ("my" prefix-string, "param" is a letter
     (e.g. "A") for the name of first parameter or (e.g. "A(") for index
     parameter variables, "order" ordering string for ring extension),
     "out" name of output-file).

*Note:*
     printlevel < 0 no output at all,
     printlevel >=0,1,2,.. informs you, what is going on;
     this proc uses 'execute'.

*Example:*
     LIB "deform.lib";
     int p          = printlevel;
     printlevel     = 0;
     ring r1        = 0,(x,y,z,u,v),ds;
     matrix m[2][4] = x,y,z,u,y,z,u,v;
     ideal Fo       = minor(m,2);
     // cone over rational normal curve of degree 4
     versal(Fo);
     ==> // ready: T_1 and T_2
     ==> // start computation in degree 2.
     ==> 
     ==> // Result belongs to ring Px.
     ==> // Equations of total space of miniversal deformation are 
     ==> // given by Fs, equations of miniversal base space by Js.
     ==> // Make Px the basering and list objects defined in Px by typing:
     ==>    setring Px; show(Px);
     ==>    listvar(matrix);
     ==> // NOTE: rings Qx, Px, So are alive!
     ==> // (use 'kill_rings("");' to remove)
     setring Px;
     // ___ Equations of miniversal base space ___:
     Js;"";
     ==> Js[1,1]=BD
     ==> Js[1,2]=-AD+D2
     ==> Js[1,3]=-CD
     ==> 
     // ___ Equations of miniversal total space ___:
     Fs;"";
     ==> Fs[1,1]=-u2+zv+Bu+Dv
     ==> Fs[1,2]=-zu+yv-Au+Du
     ==> Fs[1,3]=-yu+xv+Cu+Dz
     ==> Fs[1,4]=z2-yu+Az+By
     ==> Fs[1,5]=yz-xu+Bx-Cz
     ==> Fs[1,6]=-y2+xz+Ax+Cy
     ==> 


File: singular.hlp,  Node: mod_versal,  Next: lift_kbase,  Prev: versal,  Up: deform_lib

D.5.2.2 mod_versal
..................

Procedure from library `deform.lib' (*note deform_lib::).

*Usage:*
     mod_versal(Mo,I[,d,any]); I=ideal, M=module, d=int, any =list

*Compute:*
     miniversal deformation of coker(Mo) over Qo=Po/Io, Po=basering;

*Create:*
     Ringsr (exported):
     'my'Px = extending the basering by new variables (deformation
     parameters), the new variables precede the old ones,
     the ordering is the product between "my_ord"
     and "ord(Po)"
     'my'Qx = Px/Io extending Qo (returns as basering),
     'my'Ox = Px/(Io+Js) ring of the versal deformation of coker(Ms),
     'my'So = embedding-ring of the versal base space. (default 'my'="")

     Matrices (in Qx, exported):
     Js = giving the versal base space (obstructions),
     Ms = giving the versal family of Mo,
     Ls = giving the lifting of syzygies Lo=syz(Mo),

     If d is defined (!=0), it computes up to degree d.
     If 'any' is defined and any[1] is no string, interactive version.
     Otherwise 'any' gives predefined strings:"my","param","order","out"
     ("my" prefix-string, "param" is a letter (e.g. "A") for the name of
     first parameter or (e.g. "A(") for index parameter variables, "ord"
     ordering string for ring extension), "out" name of output-file).

*Note:*
     printlevel < 0 no output at all,
     printlevel >=0,1,2,.. informs you, what is going on,
     this proc uses 'execute'.

*Example:*
     LIB "deform.lib";
     int p = printlevel;
     printlevel = 1;
     ring  Ro = 0,(x,y),wp(3,4);
     ideal Io = x4+y3;
     matrix Mo[2][2] = x2,y,-y2,x2;
     mod_versal(Mo,Io);
     ==> // vdim (Ext^2) = 4
     ==> // vdim (Ext^1) = 4
     ==> // ready: Ext1 and Ext2
     ==> // Ext1 is quasi-homogeneous represented: 3,6,1,4
     ==> // infinitesimal extension
     ==> x2-Ax-B,   y+Cx+D,
     ==> -y2+Cxy+Dy,x2+Ax+B
     ==> // start deg = 2
     ==> // start deg = 3
     ==> // start deg = 4
     ==> // start deg = 5
     ==> // finished in degree 
     ==> 5
     ==> // quasi-homogeneous weights of miniversal base
     ==> 3,6,1,4
     ==> // Result belongs to qring Qx
     ==> // Equations of total space of miniversal deformation are in Js
     ==> -2AB+A3+3CD2-BC3-3AC2D+A2C3,
     ==> -B2+A2B+D3-3BC2D+ABC3
     ==> // Matrix of the deformed module is Ms and lifted syzygies are Ls.
     ==> // Make Qx the basering and list objects defined in Qx by typing:
     ==>    listvar(ring);setring Qx; show(Qx);listvar(ideal);listvar(matrix);
     ==> // NOTE: rings Qx, Ox, So are still alive!
     ==> // (use: 'kill_rings();' to remove them)
     printlevel = p;
     if(system("with","Namespaces")) {
     if(nameof(Current) == "Ring" ) {
     kill Top::Px,Top::Qx,Top::So;
     } else {
     kill Ring::Px,Ring::So;
     }
     }
     kill Px,Qx,So;


File: singular.hlp,  Node: lift_kbase,  Next: lift_rel_kb,  Prev: mod_versal,  Up: deform_lib

D.5.2.3 lift_kbase
..................

Procedure from library `deform.lib' (*note deform_lib::).

*Usage:*
     lift_kbase(N,M); N,M=poly/ideal/vector/module

*Return:*
     matrix A, coefficient matrix expressing N as linear combination of
     k-basis of M. Let the k-basis have k elements and size(N)=c
     columns.  Then A satisfies:
     matrix(reduce(N,std(M)),k,c) = matrix(kbase(std(M)))*A

*Assume:*
     dim(M)=0 and the monomial ordering is a well ordering or the last
     block of the ordering is c or C

*Example:*
     LIB "deform.lib";
     ring R=0,(x,y),ds;
     module M=[x2,xy],[y2,xy],[0,xx],[0,yy];
     module N=[x3+xy,x],[x,x+y2];
     print(M);
     ==> x2,y2,0, 0,
     ==> xy,xy,x2,y2
     module kb=kbase(std(M));
     print(kb);
     ==> y2,xy,y,x,1,0,0,0,
     ==> 0, 0, 0,0,0,y,x,1 
     print(N);
     ==> xy+x3,x,  
     ==> x,    x+y2
     matrix A=lift_kbase(N,M);
     print(A);
     ==> 0,0,
     ==> 1,0,
     ==> 0,0,
     ==> 0,1,
     ==> 0,0,
     ==> 0,0,
     ==> 1,1,
     ==> 0,0 
     matrix(reduce(N,std(M)),nrows(kb),ncols(A)) - matrix(kbase(std(M)))*A;
     ==> _[1,1]=0
     ==> _[1,2]=0
     ==> _[2,1]=0
     ==> _[2,2]=0


File: singular.hlp,  Node: lift_rel_kb,  Next: kill_rings,  Prev: lift_kbase,  Up: deform_lib

D.5.2.4 lift_rel_kb
...................

Procedure from library `deform.lib' (*note deform_lib::).

*Usage:*
     lift_rel_kb(N,M[,kbaseM,p]);

*Assume:*
     [p a monomial ] or the product of all variables
     N, M modules of same rank, M depending only on variables not in p
     and vdim(M) is finite in this ring,
     [ kbaseM the kbase of M in the subring given by variables not in p
     ]
     warning: these assumptions are not checked by the procedure

*Return:*
     matrix A, whose j-th columns present the coeff's of N[j] in kbaseM,
     i.e. kbaseM*A = reduce(N,std(M))

*Example:*
     LIB "deform.lib";
     ring r=0,(A,B,x,y),dp;
     module M      = [x2,xy],[xy,y3],[y2],[0,x];
     module kbaseM = [1],[x],[xy],[y],[0,1],[0,y],[0,y2];
     poly f=xy;
     module N = [AB,BBy],[A3xy+x4,AB*(1+y2)];
     matrix A = lift_rel_kb(N,M,kbaseM,f);
     print(A);
     ==> AB,0, 
     ==> 0, 0, 
     ==> 0, A3,
     ==> 0, 0, 
     ==> 0, AB,
     ==> B2,0, 
     ==> 0, AB 
     "TEST:";
     ==> TEST:
     print(matrix(kbaseM)*A-matrix(reduce(N,std(M))));
     ==> 0,0,
     ==> 0,0 


File: singular.hlp,  Node: kill_rings,  Prev: lift_rel_kb,  Up: deform_lib

D.5.2.5 kill_rings
..................

Procedure from library `deform.lib' (*note deform_lib::).

*Usage:*
     kill_rings([string]);

*Return:*
     nothing, but kills exported rings generated by procedures 'versal'
     and 'mod_versal' with optional prefix 'string'


File: singular.hlp,  Node: equising_lib,  Next: gaussman_lib,  Prev: deform_lib,  Up: Singularities

D.5.3 equising_lib
------------------

*Library:*
     equising.lib

*Purpose:*
     Equisingularity Stratum of a Family of Plane Curves

*Author:*
     Christoph Lossen, lossen@mathematik.uni-kl.de
     Andrea Mindnich, mindnich@mathematik.uni-kl.de

*Main procedures:*

* Menu:

* tau_es:: codim of mu-const stratum in semi-universal def. base
* esIdeal:: (Wahl's) equisingularity ideal of f
* esStratum:: equisingularity stratum of a family F
* isEquising:: tests if a given deformation is equisingular

*Auxiliary procedure:*

* Menu:

* control_Matrix:: computes list of blowing-up data


File: singular.hlp,  Node: tau_es,  Next: esIdeal,  Up: equising_lib

D.5.3.1 tau_es
..............

Procedure from library `equising.lib' (*note equising_lib::).

*Usage:*
     tau_es(f); f poly

*Assume:*
     f is a reduced bivariate polynomial, the basering has precisely two
     variables, is local and no qring.

*Return:*
     int, the codimension of the mu-const stratum in the semi-universal
     deformation base.

*Note:*
     printlevel>=1 displays additional information.
     When called with any additional parameter, the computation of the
     Milnor number is avoided (no check for NND).

*Example:*
     LIB "equising.lib";
     ring r=32003,(x,y),ds;
     poly f=(x4-y4)^2-x10;
     tau_es(f);
     ==> 42

* Menu:

See also:
* esIdeal::
* invariants::
* tjurina::

*See also:* *note esIdeal::; *note invariants::; *note tjurina::.


File: singular.hlp,  Node: esIdeal,  Next: esStratum,  Prev: tau_es,  Up: equising_lib

D.5.3.2 esIdeal
...............

Procedure from library `equising.lib' (*note equising_lib::).

*Usage:*
     esIdeal(f); f poly

*Assume:*
     f is a reduced bivariate polynomial, the basering has precisely two
     variables, is local and no qring, and the characteristic of the
     ground field does not divide mult(f).

*Return:*
     list of two ideals:

               _[1]:  equisingularity ideal of f (in sense of Wahl)
               _[2]:  equisingularity ideal of f with fixed section

*Note:*
     if some of the above condition is not satisfied then return value
     is list(0,0).

*Example:*
     LIB "equising.lib";
     ring r=0,(x,y),ds;
     poly f=x7+y7+(x-y)^2*x2y2; 
     list K=esIdeal(f);
     ==> polynomial is Newton degenerated !
     ==> 
     ==> // 
     ==> // versal deformation with triv. section
     ==> // =====================================
     ==> // 
     ==> // 
     ==> // Compute equisingular Stratum over Spec(C[t]/t^2)
     ==> // ================================================
     ==> // 
     ==> // finished
     ==> // 
     option(redSB);
     // Wahl's equisingularity ideal:
     std(K[1]);
     ==> _[1]=4x4y-10x2y3+6xy4+21x6+14y6
     ==> _[2]=4x3y2-6x2y3+2xy4+7x6
     ==> _[3]=x2y4-xy5
     ==> _[4]=x7
     ==> _[5]=xy6
     ==> _[6]=y7
     ring rr=0,(x,y),ds;
     poly f=x4+4x3y+6x2y2+4xy3+y4+2x2y15+4xy16+2y17+xy23+y24+y30+y31;
     list K=esIdeal(f);
     ==> polynomial is Newton degenerated !
     ==> 
     ==> // 
     ==> // versal deformation with triv. section
     ==> // =====================================
     ==> // 
     ==> // 
     ==> // Compute equisingular Stratum over Spec(C[t]/t^2)
     ==> // ================================================
     ==> // 
     ==> // finished
     ==> // 
     vdim(std(K[1]));
     ==> 68
     // the latter should be equal to: 
     tau_es(f);
     ==> 68

* Menu:

See also:
* esStratum::
* tau_es::

*See also:* *note esStratum::; *note tau_es::.


File: singular.hlp,  Node: esStratum,  Next: isEquising,  Prev: esIdeal,  Up: equising_lib

D.5.3.3 esStratum
.................

Procedure from library `equising.lib' (*note equising_lib::).

*Usage:*
     esStratum(F[,m,L]); F poly, m int, L list

*Assume:*
     F defines a deformation of a reduced bivariate polynomial f and the
     characteristic of the basering does not divide mult(f).
     If nv is the number of variables of the basering, then the first
     nv-2 variables are the deformation parameters.
     If the basering is a qring, ideal(basering) must only depend on the
     deformation parameters.

*Compute:*
     equations for the stratum of equisingular deformations with fixed
     (trivial) section.

*Return:*
     list l: either consisting of an ideal and an integer, where

       l[1]=ideal defining the equisingular stratum
       l[2]=1 if some error has occured,  l[2]=0 otherwise;

     or consisting of a ring and an integer, where

       l[1]=ESSring is a ring extension of basering containing the ideal ES 
             (describing the ES-stratum) and the poly p_F=F,
       l[2]=1 if some error has occured,  l[2]=0 otherwise.

*Note:*
     L is supposed to be the output of reddevelop (with the given
     ordering of the variables appearing in f).
     If m is given, the ES Stratum over A/maxideal(m) is computed.
     This procedure uses `execute' or calls a procedure using `execute'.
     printlevel>=2 displays additional information.

*Example:*
     LIB "equising.lib";
     int p=printlevel; 
     printlevel=1;
     ring r = 0,(a,b,c,d,e,f,g,x,y),ds;
     poly F = (x2+2xy+y2+x5)+ax+by+cx2+dxy+ey2+fx3+gx4;
     list M = esStratum(F);
     M[1];
     ==> _[1]=g
     ==> _[2]=f
     ==> _[3]=b
     ==> _[4]=a
     ==> _[5]=-4c+4d-4e+d2-4ce
     printlevel=3;    // displays additional information
     esStratum(F,2);  // es stratum over Q[a,b,c,d,e,f,g] / <a,b,c,d,e,f,g>^2
     ==> // 
     ==> // Compute HN development
     ==> // ----------------------
     ==> // finished
     ==> // 
     ==> // Blowup Step 1 completed
     ==> // Blowup Step 2 completed
     ==> // Blowup Step 3 completed
     ==> // 1 branch finished
     ==> // 
     ==> // Elimination starts:
     ==> // -------------------
     ==> // finished
     ==> // 
     ==> // output of 'esStratum' is list consisting of:
     ==> //    _[1] = ideal defining equisingular stratum
     ==> //    _[2] = 0
     ==> [1]:
     ==>    _[1]=b
     ==>    _[2]=a
     ==>    _[3]=c-d+e
     ==>    _[4]=g
     ==>    _[5]=f
     ==> [2]:
     ==>    0
     ideal I = f-fa,e+b;
     qring q = std(I);
     poly F = imap(r,F);
     esStratum(F);
     ==> // 
     ==> // Compute HN development
     ==> // ----------------------
     ==> // finished
     ==> // 
     ==> // Blowup Step 1 completed
     ==> // Blowup Step 2 completed
     ==> // Blowup Step 3 completed
     ==> // 1 branch finished
     ==> // 
     ==> // Elimination starts:
     ==> // -------------------
     ==> // finished
     ==> // 
     ==> // output of 'esStratum' is list consisting of:
     ==> //    _[1] = ideal defining equisingular stratum
     ==> //    _[2] = 0
     ==> [1]:
     ==>    _[1]=e
     ==>    _[2]=a
     ==>    _[3]=-4c+4d+d2
     ==>    _[4]=g
     ==> [2]:
     ==>    0
     printlevel=p;

* Menu:

See also:
* esIdeal::
* isEquising::

*See also:* *note esIdeal::; *note isEquising::.


File: singular.hlp,  Node: isEquising,  Next: control_Matrix,  Prev: esStratum,  Up: equising_lib

D.5.3.4 isEquising
..................

Procedure from library `equising.lib' (*note equising_lib::).

*Usage:*
     isEquising(F[,m,L]); F poly, m int, L list

*Assume:*
     F defines a deformation of a reduced bivariate polynomial f and the
     characteristic of the basering does not divide mult(f).
     If nv is the number of variables of the basering, then the first
     nv-2 variables are the deformation parameters.
     If the basering is a qring, ideal(basering) must only depend on the
     deformation parameters.

*Compute:*
     tests if the given family is equisingular along the trivial
     section.

*Return:*
     int: 1 if the family is equisingular, 0 otherwise.

*Note:*
     L is supposed to be the output of reddevelop (with the given
     ordering of the variables appearing in f).
     If m is given, the family is considered over A/maxideal(m).
     This procedure uses `execute' or calls a procedure using `execute'.
     printlevel>=2 displays additional information.

*Example:*
     LIB "equising.lib";
     ring r = 0,(a,b,x,y),ds;
     poly F = (x2+2xy+y2+x5)+ay3+bx5;
     isEquising(F);
     ==> 0
     ideal I = ideal(a);
     qring q = std(I);
     poly F = imap(r,F);
     isEquising(F);
     ==> 1
     ring rr=0,(A,B,C,x,y),ls;
     poly f=x7+y7+(x-y)^2*x2y2;
     poly F=f+A*y*diff(f,x)+B*x*diff(f,x);
     isEquising(F);  
     ==> 0
     isEquising(F,2);    // computation over  Q[a,b] / <a,b>^2
     ==> 1


File: singular.hlp,  Node: control_Matrix,  Prev: isEquising,  Up: equising_lib

D.5.3.5 control_Matrix
......................

Procedure from library `equising.lib' (*note equising_lib::).

*Assume:*
     L is the output of multsequence(reddevelop(f)).

*Return:*
     list M of 4 intmat's:

       M[1] contains the multiplicities at the respective infinitely near points 
            p[i,j] (i=step of blowup+1, j=branch) - if branches j=k,...,k+m pass 
            through the same p[i,j] then the multiplicity is stored in M[1][k,j], 
            while M[1][k+1]=...=M[1][k+m]=0.   
       M[2] contains the number of branches meeting at p[i,j] (again, the information 
            is stored according to the above rule)   
       M[3] contains the information about the splitting of M[1][i,j] with respect to 
            different tangents of branches at p[i,j] (information is stored only for 
            minimal j>=k corresponding to a new tangent direction). 
            The entries are the sum of multiplicities of all branches with the 
            respective tangent.
       M[4] contains the maximal sum of higher multiplicities for a branch passing 
            through p[i,j] ( = degree Bound for blowing up)  

*Note:*
     the branches are ordered in such a way that only consecutive
     branches can meet at an infinitely near point.
     the final rows of the matrices M[1],...,M[3] is (1,1,1,...,1), and
     correspond to infinitely near points such that the strict
     transforms of the branches are smooth and intersect the exceptional
     divisor transversally.

* Menu:

See also:
* multsequence::

*See also:* *note multsequence::.


File: singular.hlp,  Node: gaussman_lib,  Next: hnoether_lib,  Prev: equising_lib,  Up: Singularities

D.5.4 gaussman_lib
------------------

*Library:*
     gaussman.lib

*Purpose:*
     Algorithmic Gauss-Manin Connection

*Author:*
     Mathias Schulze, email: mschulze@mathematik.uni-kl.de

*Overview:*
     A library to compute Hodge-theoretic invariants
     of isolated hypersurface singularities

*Procedures:*

* Menu:

* gmsring:: Gauss-Manin system of t with variable s
* gmsnf:: Gauss-Manin normal form of p
* gmscoeffs:: Gauss-Manin basis representation of p
* bernstein:: roots of the Bernstein polynomial of t
* monodromy:: Jordan data of complex monodromy of t
* spectrum:: singularity spectrum of t
* sppairs:: spectral pairs of t
* spnf:: spectrum normal form of (a,m,V)
* sppnf:: spectral pairs normal form of (a,w,m,V)
* vfilt:: V-filtration of t on Brieskorn lattice
* vwfilt:: weighted V-filtration of t on Brieskorn lattice
* tmatrix:: C[[s]]-matrix of t on Brieskorn lattice
* endvfilt:: endomorphism V-filtration on Jacobian algebra
* spprint:: print spectrum sp
* sppprint:: print spectral pairs spp
* spadd:: sum of spectra sp1 and sp2
* spsub:: difference of spectra sp1 and sp2
* spmul:: linear combination of spectra sp
* spissemicont:: semicontinuity test of spectrum sp
* spsemicont:: semicontinuous combinations of spectra sp0 in sp
* spmilnor:: Milnor number of spectrum sp
* spgeomgenus:: geometrical genus of spectrum sp
* spgamma:: gamma invariant of spectrum sp

* Menu:

See also:
* mondromy_lib::
* spectrum_lib::

*See also:* *note mondromy_lib::; *note spectrum_lib::.


File: singular.hlp,  Node: gmsring,  Next: gmsnf,  Up: gaussman_lib

D.5.4.1 gmsring
...............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     gmsring(t,s); poly t, string s

*Assume:*
     characteristic 0; local degree ordering;
     isolated critical point 0 of t

*Return:*

     ring G;  Gauss-Manin system of t with variable s
       poly gmspoly=t;
       ideal gmsjacob;  Jacobian ideal of t
       ideal gmsstd;  standard basis of Jacobian ideal
       matrix gmsmatrix;  matrix(gmsjacob)*gmsmatrix==matrix(gmsstd)
       ideal gmsbasis;  monomial vector space basis of Jacobian algebra
       int gmsmaxdeg;  maximal weight of variables

*Note:*
     gmsbasis is a C[[s]]-basis of H" and [t,s]=s^2

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     def G=gmsring(t,"s");
     setring(G);
     gmspoly;
     ==> x2y2+x5+y5
     print(gmsjacob);
     ==> 2xy2+5x4,
     ==> 2x2y+5y4
     print(gmsstd);
     ==> 2x2y+5y4,
     ==> 2xy2+5x4,
     ==> 5x5-5y5,
     ==> 10y6+25x3y4
     print(gmsmatrix);
     ==> 0,1,x, -2xy,  
     ==> 1,0,-y,2y2+5x3
     print(gmsbasis);
     ==> y5,
     ==> y4,
     ==> y3,
     ==> y2,
     ==> xy,
     ==> y,
     ==> x4,
     ==> x3,
     ==> x2,
     ==> x,
     ==> 1
     gmsmaxdeg;
     ==> 1


File: singular.hlp,  Node: gmsnf,  Next: gmscoeffs,  Prev: gmsring,  Up: gaussman_lib

D.5.4.2 gmsnf
.............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     gmsnf(p,K); poly p, int K

*Assume:*
     basering returned by gmsring

*Return:*

     list nf;
       ideal nf[1];  projection of p to <gmsbasis>C[[s]] mod s^(K+1)
       ideal nf[2];  p==nf[1]+nf[2]

*Note:*
     computation can be continued by setting p=nf[2]

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     def G=gmsring(t,"s");
     setring(G);
     list l0=gmsnf(gmspoly,0);
     print(l0[1]);
     ==> -1/2y5
     list l1=gmsnf(gmspoly,1);
     print(l1[1]);
     ==> -1/2y5+1/2s
     list l=gmsnf(l0[2],1);
     print(l[1]);
     ==> 1/2s


File: singular.hlp,  Node: gmscoeffs,  Next: bernstein,  Prev: gmsnf,  Up: gaussman_lib

D.5.4.3 gmscoeffs
.................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     gmscoeffs(p,K); poly p, int K

*Assume:*
     basering constructed by gmsring

*Return:*

     list l;
       matrix l[1];  C[[s]]-basis representation of p mod s^(K+1)
       ideal l[2];  p==matrix(gmsbasis)*l[1]+l[2]

*Note:*
     computation can be continued by setting p=l[2]

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     def G=gmsring(t,"s");
     setring(G);
     list l0=gmscoeffs(gmspoly,0);
     print(l0[1]);
     ==> -1/2,
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0    
     list l1=gmscoeffs(gmspoly,1);
     print(l1[1]);
     ==> -1/2,
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 0,   
     ==> 1/2s 
     list l=gmscoeffs(l0[2],1);
     print(l[1]);
     ==> 0,  
     ==> 0,  
     ==> 0,  
     ==> 0,  
     ==> 0,  
     ==> 0,  
     ==> 0,  
     ==> 0,  
     ==> 0,  
     ==> 0,  
     ==> 1/2s


File: singular.hlp,  Node: bernstein,  Next: monodromy,  Prev: gmscoeffs,  Up: gaussman_lib

D.5.4.4 bernstein
.................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     bernstein(t); poly t

*Assume:*
     characteristic 0; local degree ordering;
     isolated critical point 0 of t

*Return:*
     ideal r; roots of the Bernstein polynomial b excluding the root -1

*Note:*
     the roots of b are negative rational numbers and -1 is a root of b

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     bernstein(t);
     ==> [1]:
     ==>    _[1]=-1/2
     ==>    _[2]=-7/10
     ==>    _[3]=-9/10
     ==>    _[4]=-1
     ==>    _[5]=-11/10
     ==>    _[6]=-13/10
     ==> [2]:
     ==>    2,1,1,2,1,1


File: singular.hlp,  Node: monodromy,  Next: spectrum,  Prev: bernstein,  Up: gaussman_lib

D.5.4.5 monodromy
.................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     monodromy(t); poly t

*Assume:*
     characteristic 0; local degree ordering;
     isolated critical point 0 of t

*Return:*

     list l;  Jordan data jordan(M) of monodromy matrix exp(-2*pi*i*M)
       ideal l[1]; 
         number l[1][i];  eigenvalue of i-th Jordan block of M
       intvec l[2]; 
         int l[2][i];  size of i-th Jordan block of M
       intvec l[3]; 
         int l[3][i];  multiplicity of i-th Jordan block of M

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     monodromy(t);
     ==> [1]:
     ==>    _[1]=1/2
     ==>    _[2]=7/10
     ==>    _[3]=9/10
     ==>    _[4]=1
     ==>    _[5]=11/10
     ==>    _[6]=13/10
     ==> [2]:
     ==>    2,1,1,1,1,1
     ==> [3]:
     ==>    1,2,2,1,2,2

* Menu:

See also:
* linalg_lib::
* mondromy_lib::

*See also:* *note linalg_lib::; *note mondromy_lib::.


File: singular.hlp,  Node: spectrum,  Next: sppairs,  Prev: monodromy,  Up: gaussman_lib

D.5.4.6 spectrum
................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spectrum(t); poly t

*Assume:*
     characteristic 0; local degree ordering;
     isolated critical point 0 of t

*Return:*

     list sp;  singularity spectrum of t
       ideal sp[1];
         number sp[1][i];  i-th spectral number
       intvec sp[2];
         int sp[2][i];  multiplicity of i-th spectral number

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     spprint(spectrum(t));
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)

* Menu:

See also:
* spectrum_lib::

*See also:* *note spectrum_lib::.


File: singular.hlp,  Node: sppairs,  Next: spnf,  Prev: spectrum,  Up: gaussman_lib

D.5.4.7 sppairs
...............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     sppairs(t); poly t

*Assume:*
     characteristic 0; local degree ordering;
     isolated critical point 0 of t

*Return:*

     list spp;  spectral pairs of t
       ideal spp[1];
         number spp[1][i];  V-filtration index of i-th spectral pair
       intvec spp[2];
         int spp[2][i];  weight filtration index of i-th spectral pair
       intvec spp[3];
         int spp[3][i];  multiplicity of i-th spectral pair

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     sppprint(sppairs(t));
     ==> ((-1/2,2),1),((-3/10,1),2),((-1/10,1),2),((0,1),1),((1/10,1),2),((3/10,1)\
        ,2),((1/2,0),1)

* Menu:

See also:
* spectrum_lib::

*See also:* *note spectrum_lib::.


File: singular.hlp,  Node: spnf,  Next: sppnf,  Prev: sppairs,  Up: gaussman_lib

D.5.4.8 spnf
............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Assume:*
     ncols(a)==size(m)==size(V); typeof(V[i])=="int"

*Return:*
     order (a[i][,V[i]]) with multiplicity m[i] lexicographically


File: singular.hlp,  Node: sppnf,  Next: vfilt,  Prev: spnf,  Up: gaussman_lib

D.5.4.9 sppnf
.............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Assume:*
     ncols(e)=size(w)=size(m)=size(V); typeof(V[i])=="module"

*Return:*
     order (a[i][,w[i]][,V[i]]) with multiplicity m[i] lexicographically


File: singular.hlp,  Node: vfilt,  Next: vwfilt,  Prev: sppnf,  Up: gaussman_lib

D.5.4.10 vfilt
..............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     vfilt(t); poly t

*Assume:*
     characteristic 0; local degree ordering;
     isolated critical point 0 of t

*Return:*

     list v;  V-filtration on H"/s*H"
       ideal v[1];
         number v[1][i];  V-filtration index of i-th spectral number
       intvec v[2];
         int v[2][i];  multiplicity of i-th spectral number
       list v[3];
         module v[3][i];  vector space of i-th graded part in terms of v[4]
       ideal v[4];  monomial vector space basis of H"/s*H"
       ideal v[5];  standard basis of Jacobian ideal

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     vfilt(t);
     ==> [1]:
     ==>    _[1]=-1/2
     ==>    _[2]=-3/10
     ==>    _[3]=-1/10
     ==>    _[4]=0
     ==>    _[5]=1/10
     ==>    _[6]=3/10
     ==>    _[7]=1/2
     ==> [2]:
     ==>    1,2,2,1,2,2,1
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=gen(11)
     ==>    [2]:
     ==>       _[1]=gen(10)
     ==>       _[2]=gen(6)
     ==>    [3]:
     ==>       _[1]=gen(9)
     ==>       _[2]=gen(4)
     ==>    [4]:
     ==>       _[1]=gen(5)
     ==>    [5]:
     ==>       _[1]=gen(3)
     ==>       _[2]=gen(8)
     ==>    [6]:
     ==>       _[1]=gen(2)
     ==>       _[2]=gen(7)
     ==>    [7]:
     ==>       _[1]=gen(1)
     ==> [4]:
     ==>    _[1]=y5
     ==>    _[2]=y4
     ==>    _[3]=y3
     ==>    _[4]=y2
     ==>    _[5]=xy
     ==>    _[6]=y
     ==>    _[7]=x4
     ==>    _[8]=x3
     ==>    _[9]=x2
     ==>    _[10]=x
     ==>    _[11]=1
     ==> [5]:
     ==>    _[1]=2x2y+5y4
     ==>    _[2]=2xy2+5x4
     ==>    _[3]=5x5-5y5
     ==>    _[4]=10y6+25x3y4

* Menu:

See also:
* spectrum_lib::

*See also:* *note spectrum_lib::.


File: singular.hlp,  Node: vwfilt,  Next: tmatrix,  Prev: vfilt,  Up: gaussman_lib

D.5.4.11 vwfilt
...............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     vwfilt(t); poly t

*Assume:*
     characteristic 0; local degree ordering;
     isolated critical point 0 of t

*Return:*

     list vw;  weighted V-filtration on H"/s*H"
       ideal vw[1];
         number vw[1][i];  V-filtration index of i-th spectral pair
       intvec vw[2];
         int vw[2][i];  weight filtration index of i-th spectral pair
       intvec vw[3];
         int vw[3][i];  multiplicity of i-th spectral pair
       list vw[4];
         module vw[4][i];  vector space of i-th graded part in terms of vw[5]
       ideal vw[5];  monomial vector space basis of H"/s*H"
       ideal vw[6];  standard basis of Jacobian ideal

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     vwfilt(t);
     ==> [1]:
     ==>    _[1]=-1/2
     ==>    _[2]=-3/10
     ==>    _[3]=-1/10
     ==>    _[4]=0
     ==>    _[5]=1/10
     ==>    _[6]=3/10
     ==>    _[7]=1/2
     ==> [2]:
     ==>    2,1,1,1,1,1,0
     ==> [3]:
     ==>    1,2,2,1,2,2,1
     ==> [4]:
     ==>    [1]:
     ==>       _[1]=gen(11)
     ==>    [2]:
     ==>       _[1]=gen(10)
     ==>       _[2]=gen(6)
     ==>    [3]:
     ==>       _[1]=gen(9)
     ==>       _[2]=gen(4)
     ==>    [4]:
     ==>       _[1]=gen(5)
     ==>    [5]:
     ==>       _[1]=gen(3)
     ==>       _[2]=gen(8)
     ==>    [6]:
     ==>       _[1]=gen(2)
     ==>       _[2]=gen(7)
     ==>    [7]:
     ==>       _[1]=gen(1)
     ==> [5]:
     ==>    _[1]=y5
     ==>    _[2]=y4
     ==>    _[3]=y3
     ==>    _[4]=y2
     ==>    _[5]=xy
     ==>    _[6]=y
     ==>    _[7]=x4
     ==>    _[8]=x3
     ==>    _[9]=x2
     ==>    _[10]=x
     ==>    _[11]=1
     ==> [6]:
     ==>    _[1]=2x2y+5y4
     ==>    _[2]=2xy2+5x4
     ==>    _[3]=5x5-5y5
     ==>    _[4]=10y6+25x3y4

* Menu:

See also:
* spectrum_lib::

*See also:* *note spectrum_lib::.


File: singular.hlp,  Node: tmatrix,  Next: endvfilt,  Prev: vwfilt,  Up: gaussman_lib

D.5.4.12 tmatrix
................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     tmatrix(t); poly t

*Assume:*
     characteristic 0; local degree ordering;
     isolated critical point 0 of t

*Return:*

     list l=A0,A1,T,M;
       matrix A0,A1;  t=A0+s*A1+s^2*(d/ds) on H" w.r.t. C[[s]]-basis M*T
       module T;  C-basis of C^mu
       ideal M;  monomial C-basis of H"/sH"

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     list A=tmatrix(t);
     print(A[1]);
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 0,0,0,0,0,0,0,0,0,0,0,
     ==> 1,0,0,0,0,0,0,0,0,0,0 
     print(A[2]);
     ==> 1/2,0,   0,   0,   0,   0,0,    0,    0,    0,    0, 
     ==> 0,  7/10,0,   0,   0,   0,0,    0,    0,    0,    0, 
     ==> 0,  0,   7/10,0,   0,   0,0,    0,    0,    0,    0, 
     ==> 0,  0,   0,   9/10,0,   0,0,    0,    0,    0,    0, 
     ==> 0,  0,   0,   0,   9/10,0,0,    0,    0,    0,    0, 
     ==> 0,  0,   0,   0,   0,   1,0,    0,    0,    0,    0, 
     ==> 0,  0,   0,   0,   0,   0,11/10,0,    0,    0,    0, 
     ==> 0,  0,   0,   0,   0,   0,0,    11/10,0,    0,    0, 
     ==> 0,  0,   0,   0,   0,   0,0,    0,    13/10,0,    0, 
     ==> 0,  0,   0,   0,   0,   0,0,    0,    0,    13/10,0, 
     ==> 0,  0,   0,   0,   0,   0,0,    0,    0,    0,    3/2
     print(A[3]);
     ==> -1445/64,0,  0,  0,0,85/8,0,0,0,0,1/2,
     ==> 0,       125,0,  0,0,0,   0,0,1,0,0,  
     ==> 0,       0,  0,  5,0,0,   1,0,0,0,0,  
     ==> 0,       0,  0,  0,4,0,   0,0,0,0,0,  
     ==> 2,       0,  0,  0,0,1,   0,0,0,0,0,  
     ==> 0,       0,  16, 0,0,0,   0,0,0,0,0,  
     ==> 0,       0,  125,0,0,0,   0,0,0,1,0,  
     ==> 0,       0,  0,  0,5,0,   0,1,0,0,0,  
     ==> 0,       0,  0,  4,0,0,   0,0,0,0,0,  
     ==> 0,       16, 0,  0,0,0,   0,0,0,0,0,  
     ==> -1,      0,  0,  0,0,0,   0,0,0,0,0   
     print(A[4]);
     ==> y5,
     ==> y4,
     ==> y3,
     ==> y2,
     ==> xy,
     ==> y,
     ==> x4,
     ==> x3,
     ==> x2,
     ==> x,
     ==> 1


File: singular.hlp,  Node: endvfilt,  Next: spprint,  Prev: tmatrix,  Up: gaussman_lib

D.5.4.13 endvfilt
.................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     endvfilt(v); list v

*Assume:*
     v returned by vfilt

*Return:*

     list ev;  V-filtration on Jacobian algebra
       ideal ev[1];
         number ev[1][i];  i-th V-filtration index
       intvec ev[2];
         int ev[2][i];  i-th multiplicity
       list ev[3];
         module ev[3][i];  vector space of i-th graded part in terms of ev[4]
       ideal ev[4];  monomial vector space basis of Jacobian algebra
       ideal ev[5];  standard basis of Jacobian ideal

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     poly t=x5+x2y2+y5;
     endvfilt(vfilt(t));
     ==> [1]:
     ==>    _[1]=0
     ==>    _[2]=1/5
     ==>    _[3]=2/5
     ==>    _[4]=1/2
     ==>    _[5]=3/5
     ==>    _[6]=4/5
     ==>    _[7]=1
     ==> [2]:
     ==>    1,2,2,1,2,2,1
     ==> [3]:
     ==>    [1]:
     ==>       _[1]=gen(11)
     ==>    [2]:
     ==>       _[1]=gen(10)
     ==>       _[2]=gen(6)
     ==>    [3]:
     ==>       _[1]=gen(9)
     ==>       _[2]=gen(4)
     ==>    [4]:
     ==>       _[1]=gen(5)
     ==>    [5]:
     ==>       _[1]=gen(8)
     ==>       _[2]=gen(3)
     ==>    [6]:
     ==>       _[1]=gen(7)
     ==>       _[2]=gen(2)
     ==>    [7]:
     ==>       _[1]=gen(1)
     ==> [4]:
     ==>    _[1]=y5
     ==>    _[2]=y4
     ==>    _[3]=y3
     ==>    _[4]=y2
     ==>    _[5]=xy
     ==>    _[6]=y
     ==>    _[7]=x4
     ==>    _[8]=x3
     ==>    _[9]=x2
     ==>    _[10]=x
     ==>    _[11]=1
     ==> [5]:
     ==>    _[1]=2x2y+5y4
     ==>    _[2]=2xy2+5x4
     ==>    _[3]=5x5-5y5
     ==>    _[4]=10y6+25x3y4


File: singular.hlp,  Node: spprint,  Next: sppprint,  Prev: endvfilt,  Up: gaussman_lib

D.5.4.14 spprint
................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spprint(sp); list sp

*Return:*
     string s; spectrum sp

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)


File: singular.hlp,  Node: sppprint,  Next: spadd,  Prev: spprint,  Up: gaussman_lib

D.5.4.15 sppprint
.................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     sppprint(spp); list spp

*Return:*
     string s; spectral pairs spp

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list spp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(2,1,1,1,1,1,0),intvec(1,2,2,1,2,2,1));
     sppprint(spp);
     ==> ((-1/2,2),1),((-3/10,1),2),((-1/10,1),2),((0,1),1),((1/10,1),2),((3/10,1)\
        ,2),((1/2,0),1)


File: singular.hlp,  Node: spadd,  Next: spsub,  Prev: sppprint,  Up: gaussman_lib

D.5.4.16 spadd
..............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spadd(sp1,sp2); list sp1, list sp2

*Return:*
     list sp; sum of spectra sp1 and sp2

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp1);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
     list sp2=list(ideal(-1/6,1/6),intvec(1,1));
     spprint(sp2);
     ==> (-1/6,1),(1/6,1)
     spprint(spadd(sp1,sp2));
     ==> (-1/2,1),(-3/10,2),(-1/6,1),(-1/10,2),(0,1),(1/10,2),(1/6,1),(3/10,2),(1/\
        2,1)


File: singular.hlp,  Node: spsub,  Next: spmul,  Prev: spadd,  Up: gaussman_lib

D.5.4.17 spsub
..............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spsub(sp1,sp2); list sp1, list sp2

*Return:*
     list sp; difference of spectra sp1 and sp2

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp1);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
     list sp2=list(ideal(-1/6,1/6),intvec(1,1));
     spprint(sp2);
     ==> (-1/6,1),(1/6,1)
     spprint(spsub(sp1,sp2));
     ==> (-1/2,1),(-3/10,2),(-1/6,-1),(-1/10,2),(0,1),(1/10,2),(1/6,-1),(3/10,2),(\
        1/2,1)


File: singular.hlp,  Node: spmul,  Next: spissemicont,  Prev: spsub,  Up: gaussman_lib

D.5.4.18 spmul
..............

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spmul(sp0,k); list sp0, int[vec] k

*Return:*
     list sp; linear combination of spectra sp0 with coefficients k

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
     spprint(spmul(sp,2));
     ==> (-1/2,2),(-3/10,4),(-1/10,4),(0,2),(1/10,4),(3/10,4),(1/2,2)
     list sp1=list(ideal(-1/6,1/6),intvec(1,1));
     spprint(sp1);
     ==> (-1/6,1),(1/6,1)
     list sp2=list(ideal(-1/3,0,1/3),intvec(1,2,1));
     spprint(sp2);
     ==> (-1/3,1),(0,2),(1/3,1)
     spprint(spmul(list(sp1,sp2),intvec(1,2)));
     ==> (-1/3,2),(-1/6,1),(0,4),(1/6,1),(1/3,2)


File: singular.hlp,  Node: spissemicont,  Next: spsemicont,  Prev: spmul,  Up: gaussman_lib

D.5.4.19 spissemicont
.....................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spissemicont(sp[,1]); list sp, int opt

*Return:*

     int k=
       1;  if sum of sp is positive on all intervals [a,a+1) [and (a,a+1)]
       0;  if sum of sp is negative on some interval [a,a+1) [or (a,a+1)]

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp1);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
     list sp2=list(ideal(-1/6,1/6),intvec(1,1));
     spprint(sp2);
     ==> (-1/6,1),(1/6,1)
     spissemicont(spsub(sp1,spmul(sp2,3)));
     ==> 1
     spissemicont(spsub(sp1,spmul(sp2,4)));
     ==> 0


File: singular.hlp,  Node: spsemicont,  Next: spmilnor,  Prev: spissemicont,  Up: gaussman_lib

D.5.4.20 spsemicont
...................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spsemicont(sp0,sp,k[,1]); list sp0, list sp

*Return:*

     list l;
       intvec l[i];  if the spectra sp0 occur with multiplicities k
                     in a deformation of a [quasihomogeneous] singularity
                     with spectrum sp then k<=l[i]

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp0=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp0);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
     list sp1=list(ideal(-1/6,1/6),intvec(1,1));
     spprint(sp1);
     ==> (-1/6,1),(1/6,1)
     list sp2=list(ideal(-1/3,0,1/3),intvec(1,2,1));
     spprint(sp2);
     ==> (-1/3,1),(0,2),(1/3,1)
     list sp=sp1,sp2;
     list l=spsemicont(sp0,sp);
     l;
     ==> [1]:
     ==>    3
     ==> [2]:
     ==>    2,1
     spissemicont(spsub(sp0,spmul(sp,l[1])));
     ==> 1
     spissemicont(spsub(sp0,spmul(sp,l[1]-1)));
     ==> 1
     spissemicont(spsub(sp0,spmul(sp,l[1]+1)));
     ==> 0


File: singular.hlp,  Node: spmilnor,  Next: spgeomgenus,  Prev: spsemicont,  Up: gaussman_lib

D.5.4.21 spmilnor
.................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spmilnor(sp); list sp

*Return:*
     int mu; Milnor number of spectrum sp

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
     spmilnor(sp);
     ==> 11


File: singular.hlp,  Node: spgeomgenus,  Next: spgamma,  Prev: spmilnor,  Up: gaussman_lib

D.5.4.22 spgeomgenus
....................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spgeomgenus(sp); list sp

*Return:*
     int g; geometrical genus of spectrum sp

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
     spgeomgenus(sp);
     ==> 6


File: singular.hlp,  Node: spgamma,  Prev: spgeomgenus,  Up: gaussman_lib

D.5.4.23 spgamma
................

Procedure from library `gaussman.lib' (*note gaussman_lib::).

*Usage:*
     spgamma(sp); list sp

*Return:*
     number gamma; gamma invariant of spectrum sp

*Example:*
     LIB "gaussman.lib";
     ring R=0,(x,y),ds;
     list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
     spprint(sp);
     ==> (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
     spgamma(sp);
     ==> 1/240


File: singular.hlp,  Node: hnoether_lib,  Next: mondromy_lib,  Prev: gaussman_lib,  Up: Singularities

D.5.5 hnoether_lib
------------------

*Library:*
     hnoether.lib

*Purpose:*
     Hamburger-Noether (Puiseux) Development

*Author:*
     Martin Lamm, lamm@mathematik.uni-kl.de

*Overview:*
     A library for computing the Hamburger-Noether, resp. Puiseux,
     development of a plane curve singularity following [Campillo, A.:
     Algebroid curves in positive characteristic, Springer LNM 813
     (1980)].
     The library contains also procedures for computing the
     (topological) numerical invariants of plane curve singularities.

*Main procedures:*

* Menu:

* hnexpansion:: Hamburger-Noether (H-N) development of f
* sethnering:: changes to the hnering created by hnexpansion
* develop:: H-N development of irreducible curves
* extdevelop:: extension of the H-N development hne of f
* parametrisation:: a parametrization of f
* displayHNE:: display H-N development as an ideal
* invariants:: invariants of f, e.g. the characteristic exponents
* displayInvariants:: display invariants of f
* multsequence:: sequence of multiplicities
* displayMultsequence:: display sequence of multiplicities
* intersection:: intersection multiplicity of two curves
* stripHNE:: reduce amount of memory consumed by hne
* is_irred:: test if f is irreducible
* delta:: delta invariant of f
* newtonpoly:: (local) Newton polygon of f
* is_NND:: test if f is Newton non-degenerate

*Auxiliary procedures:*

* Menu:

* puiseux2generators:: convert Puiseux pairs to generators of semigroup
* separateHNE:: number of quadratic transf. needed for separation
* squarefree:: a squarefree divisor of the poly f
* allsquarefree:: the maximal squarefree divisor of the poly f
* further_hn_proc:: show further procedures useful for interactive use


File: singular.hlp,  Node: hnexpansion,  Next: sethnering,  Up: hnoether_lib

D.5.5.1 hnexpansion
...................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     hnexpansion(f); or hnexpansion(f,"ess"); f poly

*Usage:*
     hnexpansion(f); f poly

*Assume:*
     f is a bivariate polynomial (in the first 2 ring variables)

*Create:*
     ring with variables `x,y' and ordering `ls' over a field extension
     of the current basering's ground field, since the Hamburger-Noether
     development usually does not exist in the originally given
     basering. The field extension is chosen minimally.
     Moreover, in the ring a list `hne' of lists `hne[i]' is created
     (corresponding to the output of `develop(f[i])', f[i] a branch of
     f, but the last entry being omitted).

     `hne[i][1]'; matrix:
          Each row contains the coefficients of the corresponding line
          of the          Hamburger-Noether expansion (HNE) for f[i].
          The end of the line is          marked in the matrix by the
          first ring variable (usually x).

     `hne[i][2]'; intvec:
          indicating the length of lines of the HNE

     `hne[i][3]'; int:
          0  if the 1st ring variable was transversal (with respect to
          f[i]),
          1  if the variables were changed at the beginning of the
          computation,
          -1  if an error has occurred.

     `hne[i][4]'; poly:
          the transformed polynomial of f[i] to make it possible to
          extend the          Hamburger-Noether development a posteriori
          without having to do          all the previous calculation
          once again (0 if not needed)

*Return:*
     a list, say `hn', containing the created ring

*Note:*
     to use the ring type: `def HNEring=hn[i]; setring HNEring;'.
     If f is known to be irreducible as a power series, `develop(f)'
     could be chosen instead to avoid the change of basering.
     Increasing `printlevel' leads to more and more comments.

*Usage:*
     hnexpansion(f,"ess"); f poly

*Assume:*
     f is a bivariate polynomial (in the first 2 ring variables)

*Create:*
     ring with variables `x,y' and ordering `ls' over a field extension
     of the current basering's ground field, since the Hamburger-Noether
     development usually does not exist in the originally given
     basering. The field extension is chosen minimally.
     Moreover, in the ring a list `hne' of lists `hne[i]' is created
     (corresponding to the output of `develop(f[i])', f[i] an
     "essential" branch of f, but the last entry being omitted). See
     `hnexpansion' above for more details.

*Return:*
     a list, say `hn', containing the created ring

*Note:*
     to use the ring type: `def hnering=hn[i]; setring hnering;'.
     Alternatively you may use the procedure sethnering and type:
     `sethnering(hn);'
     If the HNE needs a field extension, some of the branches will be
     conjugate. In this case `hnexpansion(f,"ess")' reduces the
     computation to one representative for each group of conjugate
branches.
     Note that the degree of each branch is in general less than the
     degree of the field extension in which all HNEs can be put.
     Use `hnexpansion(f)' to compute a complete HNE, i.e., a HNE for all
branches.
     Increasing `printlevel' leads to more and more comments.

*Example:*
     LIB "hnoether.lib";
     ring r=0,(x,y),ls;
     list hn=hnexpansion(x4-y6);
     show(hn);
     ==> // list, 1 element(s):
     ==> [1]:
     ==>    // ring: (0),(x,y),(ls(2),C);
     ==>    // minpoly = 0
     ==> // objects belonging to this ring:
     ==> // hne                  [0]  list, size: 2
     def hnering=hn[1];
     setring hnering;
     size(hne);           // number of branches
     ==> 2
     print(hne[1][1]);    // HN-matrix of 1st branch
     ==> 0,x,0,
     ==> 0,1,x 
     parametrisation(hne);    // parametrization of the two branches
     ==> [1]:
     ==>    _[1]=x3
     ==>    _[2]=x2
     ==> [2]:
     ==>    _[1]=-x3
     ==>    _[2]=-x2
     /////////////////////////////////////////////////////////
     ring s=2,(x,y),ls;
     poly f=(x4+x2y+y2)*(x3+xy2+y3);
     // --------- compute all branches: ---------
     hn=hnexpansion(f);
     ==> // new minimal polynomial: a6+a5+a3+a2+1
     hnering=hn[1];
     setring hnering;
     displayHNE(hne[1]);   // HN-matrix of 1st branch
     ==> HNE[1]=y+(a^4+a+1)*z(0)
     ==> HNE[2]=x+z(0)
     displayHNE(hne[4]);   // HN-matrix of 4th branch
     ==> HNE[1]=y+(a^4+a^2+a+1)*z(0)^2
     ==> HNE[2]=x+z(0)
     setring s;
     // --- compute only one of conjugate branches: ---
     hn=hnexpansion(f,"ess");
     ==> // new minimal polynomial: a6+a5+a3+a2+1
     hnering=hn[1];
     setring hnering;
     displayHNE(hne);
     ==> // Hamburger-Noether development of branch nr.1:
     ==> HNE[1]=y+(a^4+a^2)*z(0)
     ==> HNE[2]=x+z(0)
     ==> 
     ==> // Hamburger-Noether development of branch nr.2:
     ==> HNE[1]=y+(a^4+a^2+a)*z(0)^2
     ==> HNE[2]=x+z(0)
     ==> 
     // no. 1 of hnexpansion(f,"ess") represents no. 1 - 3 of hnexpansion(f) and
     // no. 2 of hnexpansion(f,"ess") represents no. 4 + 5 of hnexpansion(f)

* Menu:

See also:
* develop::
* displayHNE::
* extdevelop::
* parametrisation::

*See also:* *note develop::; *note displayHNE::; *note extdevelop::;
*note parametrisation::.


File: singular.hlp,  Node: sethnering,  Next: develop,  Prev: hnexpansion,  Up: hnoether_lib

D.5.5.2 sethnering
..................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     sethnering(L[,s]); L list, s string (optional)

*Assume:*
     L is a list containing a ring (e.g. the output of `hnexpansion').

*Create:*
     The procedure creates a ring with name given by the optional
     parameter s resp. with name hnering, if no optional parameter is
     given, and changes your ring to this ring. The new ring will be the
     ring given as the first entry in the list L.

*Return:*
     nothing.

*Example:*
     LIB "hnoether.lib";
     // -------- prepare for example ---------
     if (defined(hnering))
     {
     def rette@ring=hnering;
     if (nameof(basering)=="hnering")
     {
     int wechsel=1;
     }
     else
     {
     int wechsel;
     }
     kill hnering;
     }
     // ------ the example starts here -------
     ring r=0,(x,y),ls;
     nameof(basering);
     ==> r
     sethnering(hnexpansion(x4-y6)); // Creates hnering and changes to it!
     nameof(basering);
     ==> hnering
     // --- restore HNEring if previously defined ---
     kill hnering;
     if (defined(rette@ring)) {
     def hnering=rette@ring;
     export hnering;
     if (wechsel==1)
     {
     setring hnering;
     }
     }

* Menu:

See also:
* hnexpansion::

*See also:* *note hnexpansion::.


File: singular.hlp,  Node: develop,  Next: extdevelop,  Prev: sethnering,  Up: hnoether_lib

D.5.5.3 develop
...............

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     develop(f [,n]); f poly, n int

*Assume:*
     f is a bivariate polynomial (in the first 2 ring variables) and
     irreducible as power series (for reducible f use `hnexpansion').

*Return:*
     list `L' with:

     `L[1]'; matrix:
          Each row contains the coefficients of the corresponding line
          of the          Hamburger-Noether expansion (HNE). The end of
          the line is marked in          the matrix by the first ring
          variable (usually x).

     `L[2]'; intvec:
          indicating the length of lines of the HNE

     `L[3]'; int:
          0  if the 1st ring variable was transversal (with respect to
          f),
          1  if the variables were changed at the beginning of the
          computation,
          -1  if an error has occurred.

     `L[4]'; poly:
          the transformed polynomial of f to make it possible to extend
          the          Hamburger-Noether development a posteriori
          without having to do          all the previous calculation
          once again (0 if not needed)

     `L[5]'; int:
          1  if the curve has exactly one branch (i.e., is irreducible),

          0  else (i.e., the curve has more than one HNE, or f is not
          valid).

*Display:*
     The (non zero) elements of the HNE (if not called by another proc).

*Note:*
     The optional parameter `n' affects only the computation of the LAST
     line of the HNE. If it is given, the HN-matrix `L[1]' will have at
     least `n' columns.
     Otherwise, the number of columns will be chosen minimal such that
     the matrix contains all necessary information (i.e., all lines of
     the HNE but the last (which is in general infinite) have place).
     If `n' is negative, the algorithm is stopped as soon as the
     computed information is sufficient for `invariants(L)', but the
     HN-matrix `L[1]' may still contain undetermined elements, which are
     marked with the 2nd variable (of the basering).
     For time critical computations it is recommended to use `ring
     ...,(x,y),ls' as basering - it increases the algorithm's speed.
     If `printlevel>=0' comments are displayed (default is
     `printlevel=0').

*Example:*
     LIB "hnoether.lib";
     ring exring = 7,(x,y),ds;
     list hne=develop(4x98+2x49y7+x11y14+2y14);
     print(hne[1]);
     ==> 0,0, 0,0,0,0,3,x,
     ==> 0,x, 0,0,0,0,0,0,
     ==> 0,0, 0,x,0,0,0,0,
     ==> 0,x, 0,0,0,0,0,0,
     ==> 0,-1,0,0,0,0,0,0 
     // therefore the HNE is:
     // z(-1)= 3*z(0)^7 + z(0)^7*z(1),
     // z(0) = z(1)*z(2),       (there is 1 zero in the 2nd row before x)
     // z(1) = z(2)^3*z(3),     (there are 3 zeroes in the 3rd row)
     // z(2) = z(3)*z(4),
     // z(3) = -z(4)^2 + 0*z(4)^3 +...+ 0*z(4)^8 + ?*z(4)^9 + ...
     // (the missing x in the last line indicates that it is not complete.)
     hne[2];
     ==> 7,1,3,1,-1
     parametrisation(hne);
     ==> [1]:
     ==>    _[1]=-x14
     ==>    _[2]=-3x98-x109
     // parametrization:   x(t)= -t^14+O(t^21),  y(t)= -3t^98+O(t^105)
     // (the term -t^109 in y may have a wrong coefficient)
     displayHNE(hne);
     ==> HNE[1]=-y+3*z(0)^7+z(0)^7*z(1)
     ==> HNE[2]=-x+z(1)*z(2)
     ==> HNE[3]=z(2)^3*z(3)
     ==> HNE[4]=z(3)*z(4)
     ==> HNE[5]=-z(4)^2

* Menu:

See also:
* displayHNE::
* extdevelop::
* hnexpansion::

*See also:* *note displayHNE::; *note extdevelop::; *note hnexpansion::.


File: singular.hlp,  Node: extdevelop,  Next: parametrisation,  Prev: develop,  Up: hnoether_lib

D.5.5.4 extdevelop
..................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     extdevelop(L,N); list L, int N

*Assume:*
     L is the output of `develop(f)', or of `extdevelop(l,n)', or one
     entry in the list `hne' in the ring created by
     `hnexpansion(f[,"ess"])'.

*Return:*
     an extension of the Hamburger-Noether development of f as a list in
     the same format as L has (up to the last entry in the output of
`develop(f)').
     Type `help develop;', resp. `help hnexpansion;' for more details.

*Note:*
     The new HN-matrix will have at least N columns (if the HNE is not
     finite). In particular, if f is irreducible then (in most cases)
     `extdevelop(develop(f),N)' will produce the same result as
`develop(f,N)'.
     If the matrix M of L has n columns then, compared with
     `parametrisation(L)', `paramametrize(extdevelop(L,N))' will
     increase the exactness by at least (N-n) more significant
     monomials.

*Example:*
     LIB "hnoether.lib";
     if (defined(HNEring))
     {
     def save_r_i_n_g=HNEring;
     kill HNEring;
     }
     // ------ the example starts here -------
     ring exring=0,(x,y),dp;
     list hn=hnexpansion(x14-3y2x11-y3x10-y2x9+3y4x8+y5x7+3y4x6+x5*(-y6+y5)
     -3y6x3-y7x2+y8);
     def HNEring=hn[1];
     setring HNEring;  
     export(HNEring);  
     ==> // ** `HNEring` is already global
     print(hne[1][1]);    // HNE of 1st branch is finite
     ==> 0,x,0,
     ==> 0,1,x 
     print(extdevelop(hne[1],5)[1]);
     ==>  No extension is possible
     ==> 0,x,0,
     ==> 0,1,x 
     print(hne[2][1]);    // HNE of 2nd branch can be extended
     ==> 0,x,0,
     ==> 0,1,x,
     ==> 0,1,-1
     list ehne=extdevelop(hne[2],5);
     print(ehne[1]);      // new HN-matrix has 5 columns
     ==> 0,x,0, 0,0,
     ==> 0,1,x, 0,0,
     ==> 0,1,-1,1,-1
     parametrisation(hne[2]);
     ==> [1]:
     ==>    _[1]=x4-x5-x6+x7
     ==>    _[2]=x6-2x7+2x9-x10
     parametrisation(ehne);
     ==> [1]:
     ==>    _[1]=x4-x5+x6-x7-x8+x9-x10+x11
     ==>    _[2]=x6-2x7+3x8-4x9+2x10-2x12+4x13-3x14+2x15-x16
     if (defined(save_r_i_n_g))
     {
     kill HNEring;
     def HNEring=save_r_i_n_g;
     }

* Menu:

See also:
* develop::
* hnexpansion::
* parametrisation::

*See also:* *note develop::; *note hnexpansion::; *note
parametrisation::.


File: singular.hlp,  Node: parametrisation,  Next: displayHNE,  Prev: extdevelop,  Up: hnoether_lib

D.5.5.5 parametrisation
.......................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     parametrisation(INPUT [,x]); INPUT list or poly, x int (optional)

*Assume:*
     INPUT is either a bivariate polynomial f defining a plane curve
     singularity, or it is the output of `hnexpansion(f[,"ess"])', or of
     `develop(f)', or of `extdevelop(develop(f),n)', or the list @{hne}
     in the ring created by `hnexpansion(f)' respectively one entry
     thereof.

*Return:*
     a list L containing a parametrization L[i] for each branch f[i] of
     f in the following format:
     - if only the list INPUT is given, L[i] is an ideal of two
     polynomials p[1],p[2]: if the HNE of was finite then
     f[i](p[1],p[2])=0; if not, the "real" parametrization will be two
     power series and p[1],p[2] are truncations of these series.
     - if the optional parameter x is given, L[i] is itself a list:
     L[i][1] is the parametrization ideal as above and L[i][2] is an
     intvec with two entries indicating the highest degree up to which
     the coefficients of the monomials in L[i][1] are exact (entry -1
     means that the corresponding parametrization is exact).

*Note:*
     If the basering has only 2 variables, the first variable is chosen
     as indefinite. Otherwise, the 3rd variable is chosen.
     In case the Hamburger-Noether expansion of the curve f is needed
     for other purposes as well it is better to calculate this first
     with the aid of `hnexpansion' and use it as input instead of the
     polynomial itself.

*Example:*
     LIB "hnoether.lib";
     ring exring=0,(x,y,t),ds;
     // 1st Example: input is a polynomial
     poly g=(x2-y3)*(x3-y5);
     parametrisation(g);
     ==> [1]:
     ==>    _[1]=t3
     ==>    _[2]=t2
     ==> [2]:
     ==>    _[1]=t5
     ==>    _[2]=t3
     // 2nd Example: input is the ring of a Hamburger-Noether expansion
     poly h=x2-y2-y3;
     list hn=hnexpansion(h);
     parametrisation(h,1);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=t
     ==>       _[2]=t-1/2t2
     ==>    [2]:
     ==>       -1,2
     ==> [2]:
     ==>    [1]:
     ==>       _[1]=t
     ==>       _[2]=-t-1/2t2
     ==>    [2]:
     ==>       -1,2
     // 3rd Example: input is a Hamburger-Noether expansion
     poly f=x3+2xy2+y2;
     list hne=develop(f);
     list hne_extended=extdevelop(hne,10);
     //   compare the matrices ...
     print(hne[1]);
     ==> 0,x,
     ==> 0,-1
     print(hne_extended[1]);
     ==> 0,x, 0,0,0,0, 0,0,0,0, 
     ==> 0,-1,0,2,0,-4,0,8,0,-16
     // ... and the resulting parametrizations:
     parametrisation(hne);
     ==> [1]:
     ==>    _[1]=-t2
     ==>    _[2]=-t3
     parametrisation(hne_extended);
     ==> [1]:
     ==>    _[1]=-t2+2t4-4t6+8t8-16t10
     ==>    _[2]=-t3+2t5-4t7+8t9-16t11
     parametrisation(hne_extended,0);
     ==> [1]:
     ==>    [1]:
     ==>       _[1]=-t2+2t4-4t6+8t8-16t10
     ==>       _[2]=-t3+2t5-4t7+8t9-16t11
     ==>    [2]:
     ==>       10,11

* Menu:

See also:
* develop::
* extdevelop::

*See also:* *note develop::; *note extdevelop::.


File: singular.hlp,  Node: displayHNE,  Next: invariants,  Prev: parametrisation,  Up: hnoether_lib

D.5.5.6 displayHNE
..................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     displayHNE(L[,n]); L list, n int

*Assume:*
     L is the output of `develop(f)', or of `exdevelop(f,n)', or of
     `hnexpansion(f[,"ess"])', or (one entry in) the list `hne' in the
     ring created by `hnexpansion(f[,"ess"])'.

*Return:*
     - if only one argument is given, no return value, but display an
     ideal HNE of the following form:

               HNE[1]=-y+[]*z(0)^1+[]*z(0)^2+...+z(0)^<>*z(1)
               HNE[2]=-x+          []*z(1)^2+...+z(1)^<>*z(2)
               HNE[3]=             []*z(2)^2+...+z(2)^<>*z(3)
               .......             ..........................
               HNE[r+1]=           []*z(r)^2+[]*z(r)^3+......

     where `x',`y' are the first 2 variables of the basering.  The
     values of `[]' are the coefficients of the Hamburger-Noether
     matrix, the values of `<>' are represented by `x' in the HN-matrix.
     - if a second argument is given, create and export a new ring with
     name `displayring' containing an ideal `HNE' as described above.
     - if L corresponds to the output of `hnexpansion(f[,"ess"])' or to
     the list `hne' in the ring created by `hnexpansion(f[,"ess"])',
     `displayHNE(L[,n])' shows the HNE's of all branches of f in the
     form described above. The optional parameter is then ignored.

*Note:*
     The 1st line of the above ideal (i.e., `HNE[1]') means that
     `y=[]*z(0)^1+...', the 2nd line (`HNE[2]') means that
     `x=[]*z(1)^2+...', so you can see which indeterminate corresponds
     to which line (it's also possible that `x' corresponds to the 1st
     line and `y' to the 2nd).

*Example:*
     LIB "hnoether.lib";
     ring r=0,(x,y),dp;
     poly f=x3+2xy2+y2;
     list hn=develop(f);
     displayHNE(hn);
     ==> HNE[1]=-y+z(0)*z(1)
     ==> HNE[2]=-x-z(1)^2

* Menu:

See also:
* develop::
* hnexpansion::

*See also:* *note develop::; *note hnexpansion::.


File: singular.hlp,  Node: invariants,  Next: displayInvariants,  Prev: displayHNE,  Up: hnoether_lib

D.5.5.7 invariants
..................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     invariants(INPUT); INPUT list or poly

*Assume:*
     INPUT is the output of `develop(f)', or of
     `extdevelop(develop(f),n)', or one entry in the list `hne' of the
     HNEring created by `hnexpansion'.

*Return:*
     list, if INPUT contains a valid HNE:

         invariants(INPUT)[1]:  intvec    (characteristic exponents)
         invariants(INPUT)[2]:  intvec    (generators of the semigroup)
         invariants(INPUT)[3]:  intvec    (Puiseux pairs, 1st components)
         invariants(INPUT)[4]:  intvec    (Puiseux pairs, 2nd components)
         invariants(INPUT)[5]:  int       (degree of the conductor)
         invariants(INPUT)[6]:  intvec    (sequence of multiplicities)

     an empty list, if INPUT contains no valid HNE.

*Assume:*
     INPUT is bivariate polynomial f or the output of
     `hnexpansion(f[,"ess"])', or the list `hne' in the HNEring created
     by `hnexpansion'.

*Return:*
     list INV, such that INV[i] is the output of
     `invariants(develop(f[i]))' as above, where f[i] is the ith branch
     of the curve f, and the last entry contains further invariants of f
     in the format:

         INV[i][1]    : intvec    (characteristic exponents)
         INV[i][2]    : intvec    (generators of the semigroup)
         INV[i][3]    : intvec    (Puiseux pairs, 1st components)
         INV[i][4]    : intvec    (Puiseux pairs, 2nd components)
         INV[i][5]    : int       (degree of the conductor)
         INV[i][6]    : intvec    (sequence of multiplicities)
         INV[last][1] : intmat    (contact matrix of the branches)
         INV[last][2] : intmat    (intersection multiplicities of the branches)
         INV[last][3] : int       (delta invariant of f)

*Note:*
     In case the Hamburger-Noether expansion of the curve f is needed
     for other purposes as well it is better to calculate this first
     with the aid of `hnexpansion' and use it as input instead of the
     polynomial itself.

*Example:*
     LIB "hnoether.lib";
     ring exring=0,(x,y),dp;
     list hne=develop(y4+2x3y2+x6+x5y);
     list INV=invariants(hne);
     INV[1];                   // the characteristic exponents
     ==> 4,6,7
     INV[2];                   // the generators of the semigroup of values
     ==> 4,6,13
     INV[3],INV[4];            // the Puiseux pairs in packed form
     ==> 3,7 2,2
     INV[5] / 2;               // the delta-invariant
     ==> 8
     INV[6];                   // the sequence of multiplicities
     ==> 4,2,2,1,1
     // To display the invariants more 'nicely':
     displayInvariants(hne);
     ==>  characteristic exponents  : 4,6,7
     ==>  generators of semigroup   : 4,6,13
     ==>  Puiseux pairs             : (3,2)(7,2)
     ==>  degree of the conductor   : 16
     ==>  delta invariant           : 8
     ==>  sequence of multiplicities: 4,2,2,1,1
     /////////////////////////////
     INV=invariants((x2-y3)*(x3-y5));
     INV[1][1];                // the characteristic exponents of the first branch
     ==> 2,3
     INV[2][6];                // the sequence of multiplicities of the second branch
     ==> 3,2,1,1
     print(INV[size(INV)][1]);         // the contact matrix of the branches
     ==>      0     3
     ==>      3     0
     print(INV[size(INV)][2]);         // the intersection numbers of the branches
     ==>      0     9
     ==>      9     0
     INV[size(INV)][3];                // the delta invariant of the curve
     ==> 14

* Menu:

See also:
* develop::
* displayInvariants::
* intersection::
* multsequence::

*See also:* *note develop::; *note displayInvariants::; *note
intersection::; *note multsequence::.


File: singular.hlp,  Node: displayInvariants,  Next: multsequence,  Prev: invariants,  Up: hnoether_lib

D.5.5.8 displayInvariants
.........................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     displayInvariants(INPUT); INPUT list or poly

*Assume:*
     INPUT is a bivariate polynomial, or the output of `develop(f)', or
     of `extdevelop(develop(f),n)', or (one entry of) the list `hne' in
     the ring created by `hnexpansion(f[,"ess"])'.

*Return:*
     none

*Display:*
     invariants of the corresponding branch, resp. of all branches, in a
     better readable form.

*Note:*
     In case the Hamburger-Noether expansion of the curve f is needed
     for other purposes as well it is better to calculate this first
     with the aid of `hnexpansion' and use it as input instead of the
     polynomial itself.

*Example:*
     LIB "hnoether.lib";
     ring exring=0,(x,y),dp;
     list hne=develop(y4+2x3y2+x6+x5y);
     displayInvariants(hne);
     ==>  characteristic exponents  : 4,6,7
     ==>  generators of semigroup   : 4,6,13
     ==>  Puiseux pairs             : (3,2)(7,2)
     ==>  degree of the conductor   : 16
     ==>  delta invariant           : 8
     ==>  sequence of multiplicities: 4,2,2,1,1

* Menu:

See also:
* develop::
* hnexpansion::
* intersection::
* invariants::

*See also:* *note develop::; *note hnexpansion::; *note intersection::;
*note invariants::.


File: singular.hlp,  Node: multsequence,  Next: displayMultsequence,  Prev: displayInvariants,  Up: hnoether_lib

D.5.5.9 multsequence
....................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     multsequence(INPUT); INPUT list or poly

*Assume:*
     INPUT is the output of `develop(f)', or of
     `extdevelop(develop(f),n)', or one entry in the list `hne' of the
     ring created by `hnexpansion(f)'.

*Return:*
     intvec corresponding to the multiplicity sequence of (a branch) of
     the curve (the same as `invariants(INPUT)[6]').

*Assume:*
     INPUT is a bivariate polynomial, or the output of `hnexpansion(f)',
     or the list `hne' in the ring created by `hnexpansion(f)'.

*Return:*
     list of two integer matrices:

     `multsequence(INPUT)[1][i,*]'
          contains the multiplicities of the branches at their
          infinitely near point    of 0 in its (i-1) order neighbourhood
          (i.e., i=1: multiplicity of the    branches themselves, i=2:
          multiplicity of their 1st quadratic transformed,    etc.,
          Hence, `multsequence(INPUT)[1][*,j]' is the multiplicity
          sequence    of branch j.

     `multsequence(INPUT)[2][i,*]':
          contains the information which of these infinitely near points
          coincide.

*Note:*
     The order of elements of the list `hne' obtained from
     `hnexpansion(f[,"ess")' must not be changed (because then the
     coincident infinitely near points couldn't be grouped together, cf.
     meaning of 2nd intmat in example).  Hence, it is not wise to
     compute the HNE of several polynomials separately, put them into a
     list INPUT and call `multsequence(INPUT)'.
     Use `displayMultsequence' to produce a better readable output for
     reducible curves on the screen.
     In case the Hamburger-Noether expansion of the curve f is needed
     for other purposes as well it is better to calculate this first
     with the aid of `hnexpansion' and use it as input instead of the
     polynomial itself.

*Example:*
     LIB "hnoether.lib";
     // -------- prepare for example ---------
     if (nameof(basering)=="HNEring") {
     def rettering=HNEring;
     kill HNEring;
     }
     // ------ the example starts here -------
     ring r=0,(x,y),dp;
     list hn=hnexpansion((x6-y10)*(x+y2-y3)*(x+y2+y3));   // 4 branches
     def HNEring=hn[1];
     setring HNEring;
     multsequence(hne[1]),"  |  ",multsequence(hne[2]),"  |  ",
     multsequence(hne[3]),"  |  ",multsequence(hne[4]);
     ==> 3,2,1,1   |   3,2,1,1   |   1   |   1
     multsequence(hne);
     ==> [1]:
     ==>    3,3,1,1,
     ==>    2,2,1,1,
     ==>    1,1,1,1,
     ==>    1,1,1,1,
     ==>    1,1,1,1 
     ==> [2]:
     ==>    4,0,0,0,
     ==>    4,0,0,0,
     ==>    2,2,0,0,
     ==>    2,1,1,0,
     ==>    1,1,1,1 
     // The meaning of the entries of the 2nd matrix is as follows:
     displayMultsequence(hne);
     ==> [(3,3,1,1)],
     ==> [(2,2,1,1)],
     ==> [(1,1),(1,1)],
     ==> [(1,1),(1),(1)],
     ==> [(1),(1),(1),(1)]
     // --- restore HNEring if previously defined ---
     kill HNEring,r;
     if (defined(rettering)) {
     setring rettering;
     def HNEring=rettering;
     export HNEring;
     }

* Menu:

See also:
* develop::
* displayMultsequence::
* hnexpansion::
* separateHNE::

*See also:* *note develop::; *note displayMultsequence::; *note
hnexpansion::; *note separateHNE::.


File: singular.hlp,  Node: displayMultsequence,  Next: intersection,  Prev: multsequence,  Up: hnoether_lib

D.5.5.10 displayMultsequence
............................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     displayMultsequence(INPUT); INPUT list or poly

*Assume:*
     INPUT is a bivariate polynomial, or the output of `develop(f)', or
     of `extdevelop(develop(f),n)', or of of `hnexpansion(f[,"ess"])',
     or (one entry in) the list `hne' of the ring created by
     `hnexpansion(f[,"ess "])'.

*Return:*
     nothing

*Display:*
     the sequence of multiplicities:

      - if `INPUT=develop(f)' or `INPUT=extdevelop(develop(f),n)' or `INPUT=hne[i]':
                           `a , b , c , ....... , 1'
      - if `INPUT=f' or `INPUT=hnexpansion(f[,"ess"])' or `INPUT=hne':
                           `[(a_1, .... , b_1 , .... , c_1)],'
                           `[(a_2, ... ), ... , (... , c_2)],'
                           ` ........................................ ,'
                           `[(a_n),(b_n), ....., (c_n)]'
          with:
            `a_1 , ... , a_n' the sequence of multiplicities of the 1st branch,
            `[...]' the multiplicities of the j-th transformed of all branches,
            `(...)' indicating branches meeting in an infinitely near point.

*Note:*
     The same restrictions for INPUT as in `multsequence' apply.
     In case the Hamburger-Noether expansion of the curve f is needed
     for other purposes as well it is better to calculate this first
     with the aid of `hnexpansion' and use it as input instead of the
     polynomial itself.

*Example:*
     LIB "hnoether.lib";
     // ------ the example starts here -------
     ring r=0,(x,y),dp;
     //// Example 1: Input = output of develop
     displayMultsequence(develop(x3-y5));
     ==> The sequence of multiplicities is   3,2,1,1
     //// Example 2: Input = bivariate polynomial
     displayMultsequence((x6-y10)*(x+y2-y3)*(x+y2+y3));
     ==> [(3,3,1,1)],
     ==> [(2,2,1,1)],
     ==> [(1,1),(1,1)],
     ==> [(1,1),(1),(1)],
     ==> [(1),(1),(1),(1)]

* Menu:

See also:
* develop::
* hnexpansion::
* multsequence::
* separateHNE::

*See also:* *note develop::; *note hnexpansion::; *note multsequence::;
*note separateHNE::.


File: singular.hlp,  Node: intersection,  Next: stripHNE,  Prev: displayMultsequence,  Up: hnoether_lib

D.5.5.11 intersection
.....................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     intersection(hne1,hne2); hne1, hne2 lists

*Assume:*
     hne1, hne2 represent a HNE (i.e., are the output of `develop(f)',
     or of `extdevelop(develop(f),n)', or one entry of the list `hne' in
     the ring created by `hnexpansion(f[,"ess"])').

*Return:*
     int, the intersection multiplicity of the branches corresponding to
     hne1 and hne2.

*Example:*
     LIB "hnoether.lib";
     // ------ the example starts here -------
     ring r=0,(x,y),dp;
     list hn=hnexpansion((x2-y3)*(x2+y3));
     def HNEring=hn[1];
     setring HNEring;
     intersection(hne[1],hne[2]);
     ==> 6

* Menu:

See also:
* displayInvariants::
* hnexpansion::

*See also:* *note displayInvariants::; *note hnexpansion::.


File: singular.hlp,  Node: stripHNE,  Next: is_irred,  Prev: intersection,  Up: hnoether_lib

D.5.5.12 stripHNE
.................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     stripHNE(L); L list

*Assume:*
     L is the output of `develop(f)', or of `extdevelop(develop(f),n)',
     or (one entry of) the list `hne' in the ring created by
     `hnexpansion(f[,"ess"])'.

*Return:*
     list in the same format as L, but all polynomials L[4], resp.
     L[i][4], are set to zero.

*Note:*
     The purpose of this procedure is to remove huge amounts of data no
     longer needed. It is useful, if one or more of the polynomials in L
     consume much memory. It is still possible to compute invariants,
     parametrizations etc. with the stripped HNE(s), but it is not
     possible to use `extdevelop' with them.

*Example:*
     LIB "hnoether.lib";
     ring r=0,(x,y),dp;
     list hne=develop(x2+y3+y4);
     hne;
     ==> [1]:
     ==>    _[1,1]=0
     ==>    _[1,2]=x
     ==>    _[2,1]=0
     ==>    _[2,2]=-1
     ==> [2]:
     ==>    1,-1
     ==> [3]:
     ==>    1
     ==> [4]:
     ==>    x4-2x2y+y2+y
     ==> [5]:
     ==>    1
     stripHNE(hne);
     ==> [1]:
     ==>    _[1,1]=0
     ==>    _[1,2]=x
     ==>    _[2,1]=0
     ==>    _[2,2]=-1
     ==> [2]:
     ==>    1,-1
     ==> [3]:
     ==>    1
     ==> [4]:
     ==>    0
     ==> [5]:
     ==>    1

* Menu:

See also:
* develop::
* extdevelop::
* hnexpansion::

*See also:* *note develop::; *note extdevelop::; *note hnexpansion::.


File: singular.hlp,  Node: is_irred,  Next: delta,  Prev: stripHNE,  Up: hnoether_lib

D.5.5.13 is_irred
.................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     is_irred(f); f poly

*Assume:*
     f is a squarefree bivariate polynomial (in the first 2 ring
     variables).

*Return:*
     int (0 or 1):
     - `is_irred(f)=1' if f is irreducible as a formal power series over
     the algebraic closure of its coefficient field (f defines an
     analytically irreducible curve at zero),
     - `is_irred(f)=0' otherwise.

*Note:*
     0 and units in the ring of formal power series are considered to be
     not irreducible.

*Example:*
     LIB "hnoether.lib";
     ring exring=0,(x,y),ls;
     is_irred(x2+y3);
     ==> 1
     is_irred(x2+y2);
     ==> 0
     is_irred(x2+y3+1);
     ==> 0


File: singular.hlp,  Node: delta,  Next: newtonpoly,  Prev: is_irred,  Up: hnoether_lib

D.5.5.14 delta
..............

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     delta(INPUT); INPUT a polynomial defining an isolated plane curve
     singularity at 0, or the Hamburger-Noether expansion thereof, i.e.
     the output of `develop(f)', or the output of
     `hnexpansion(f[,"ess"])', or (one of the entries of) the list `hne'
     in the ring created by `hnexpansion(f[,"ess"])'.

*Return:*
     the delta invariant of the singularity at 0, the vector space
     dimension of R~/R, where R~ is the normalization of the singularity
     R=basering/f

*Note:*
     In case the Hamburger-Noether expansion of the curve f is needed
     for other purposes as well it is better to calculate this first
     with the aid of `hnexpansion' and use it as input instead of the
     polynomial itself.

*Example:*
     LIB "hnoether.lib";
     ring r = 32003,(x,y),ds;
     poly f = x25+x24-4x23-1x22y+4x22+8x21y-2x21-12x20y-4x19y2+4x20+10x19y
     +12x18y2-24x18y-20x17y2-4x16y3+x18+60x16y2+20x15y3-9x16y
     -80x14y3-10x13y4+36x14y2+60x12y4+2x11y5-84x12y3-24x10y5
     +126x10y4+4x8y6-126x8y5+84x6y6-36x4y7+9x2y8-1y9;
     delta(f);
     ==> 96

* Menu:

See also:
* deltaLoc::
* invariants::

*See also:* *note deltaLoc::; *note invariants::.


File: singular.hlp,  Node: newtonpoly,  Next: is_NND,  Prev: delta,  Up: hnoether_lib

D.5.5.15 newtonpoly
...................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     newtonpoly(f); f poly

*Assume:*
     basering has exactly two variables;
     f is convenient, that is, f(x,0) != 0 != f(0,y).

*Return:*
     list of intvecs (= coordinates x,y of the Newton polygon of f).

*Note:*
     Procedure uses `execute'; this can be avoided by calling
     `newtonpoly(f,1)' if the ordering of the basering is `ls'.

*Example:*
     LIB "hnoether.lib";
     ring r=0,(x,y),ls;
     poly f=x5+2x3y-x2y2+3xy5+y6-y7;
     newtonpoly(f);
     ==> [1]:
     ==>    0,6
     ==> [2]:
     ==>    2,2
     ==> [3]:
     ==>    3,1
     ==> [4]:
     ==>    5,0


File: singular.hlp,  Node: is_NND,  Next: puiseux2generators,  Prev: newtonpoly,  Up: hnoether_lib

D.5.5.16 is_NND
...............

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     is_NND(f[,mu,NP]); f poly, mu int, NP list of intvecs

*Assume:*
     f is convenient, that is, f(x,0) != 0 != f(0,y);
     mu (optional) is Milnor number of f.
     NP (optional) is output of `newtonpoly(f)'.

*Return:*
     int: 1 if f in Newton non-degenerate, 0 otherwise.

*Example:*
     LIB "hnoether.lib";
     ring r=0,(x,y),ls;
     poly f=x5+y3;
     is_NND(f);
     ==> 1
     poly g=(x-y)^5+3xy5+y6-y7;
     is_NND(g);
     ==> 0
     // if already computed, one should give the Minor number and Newton polygon
     // as second and third input: 
     int mu=milnor(g);
     list NP=newtonpoly(g);
     is_NND(g,mu,NP);
     ==> 0

* Menu:

See also:
* newtonpoly::

*See also:* *note newtonpoly::.


File: singular.hlp,  Node: puiseux2generators,  Next: separateHNE,  Prev: is_NND,  Up: hnoether_lib

D.5.5.17 puiseux2generators
...........................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     puiseux2generators(m,n); m,n intvec

*Assume:*
     m, resp. n, represent the 1st, resp. 2nd, components of Puiseux
     pairs (e.g., `m=invariants(L)[3]', `n=invariants(L)[4]').

*Return:*
     intvec of the generators of the semigroup of values.

*Example:*
     LIB "hnoether.lib";
     // take (3,2),(7,2),(15,2),(31,2),(63,2),(127,2) as Puiseux pairs:
     puiseux2generators(intvec(3,7,15,31,63,127),intvec(2,2,2,2,2,2));
     ==> 64,96,208,424,852,1706,3413

* Menu:

See also:
* invariants::

*See also:* *note invariants::.


File: singular.hlp,  Node: separateHNE,  Next: squarefree,  Prev: puiseux2generators,  Up: hnoether_lib

D.5.5.18 separateHNE
....................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     separateHNE(hne1,hne2); hne1, hne2 lists

*Assume:*
     hne1, hne2 are HNEs (=output of `develop(f)',
     `extdevelop(develop(f),n)', or one entry in the list `hne' in the
     ring created by `hnexpansion(f[,"ess"])'.

*Return:*
     number of quadratic transformations needed to separate both curves
     (branches).

*Example:*
     LIB "hnoether.lib";
     int p=printlevel; printlevel=-1;
     ring r=0,(x,y),dp;
     list hne1=develop(x);
     list hne2=develop(x+y);
     list hne3=develop(x+y2);
     separateHNE(hne1,hne2);  // two transversal lines
     ==> 1
     separateHNE(hne1,hne3);  // one quadratic transform. gives 1st example
     ==> 2
     printlevel=p;

* Menu:

See also:
* develop::
* displayMultsequence::
* hnexpansion::
* multsequence::

*See also:* *note develop::; *note displayMultsequence::; *note
hnexpansion::; *note multsequence::.


File: singular.hlp,  Node: squarefree,  Next: allsquarefree,  Prev: separateHNE,  Up: hnoether_lib

D.5.5.19 squarefree
...................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     squarefree(f); f poly

*Assume:*
     f is a bivariate polynomial (in the first 2 ring variables).

*Return:*
     poly, a squarefree divisor of f.

*Note:*
     Usually, the return value is the greatest squarefree divisor, but
     there is one exception: factors with a p-th root, p the
     characteristic of the basering, are lost.

*Example:*
     LIB "hnoether.lib";
     ring exring=3,(x,y),dp;
     squarefree((x3+y)^2);
     ==> x3+y
     squarefree((x+y)^3*(x-y)^2); // Warning: (x+y)^3 is lost
     ==> x-y
     squarefree((x+y)^4*(x-y)^2); // result is (x+y)*(x-y)
     ==> x2-y2

* Menu:

See also:
* allsquarefree::

*See also:* *note allsquarefree::.


File: singular.hlp,  Node: allsquarefree,  Next: further_hn_proc,  Prev: squarefree,  Up: hnoether_lib

D.5.5.20 allsquarefree
......................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage :*
     allsquarefree(f,g); f,g poly

*Assume:*
     g is the output of `squarefree(f)'.

*Return:*
     the greatest squarefree divisor of f.

*Note  :*
     This proc uses factorize to get the missing factors of f not in g
     and, therefore, may be slow.

*Example:*
     LIB "hnoether.lib";
     ring exring=7,(x,y),dp;
     poly f=(x+y)^7*(x-y)^8;
     poly g=squarefree(f);
     g;                      // factor x+y lost, since characteristic=7
     ==> x-y
     allsquarefree(f,g);     // all factors (x+y)*(x-y) found
     ==> x2-y2

* Menu:

See also:
* squarefree::

*See also:* *note squarefree::.


File: singular.hlp,  Node: further_hn_proc,  Prev: allsquarefree,  Up: hnoether_lib

D.5.5.21 further_hn_proc
........................

Procedure from library `hnoether.lib' (*note hnoether_lib::).

*Usage:*
     further_hn_proc();

*Note:*
     The library `hnoether.lib' contains some more procedures which are
     not shown when typing `help hnoether.lib;'. They may be useful for
     interactive use (e.g. if you want to do the calculation of an HN
     development "by hand" to see the intermediate results), and they
     can be enumerated by calling `further_hn_proc()'.
     Use `help <procedure>;' for detailed information about each of
     them.

*Example:*
     LIB "hnoether.lib";
     further_hn_proc();
     ==> 
     ==>  The following procedures are also part of `hnoether.lib':
     ==> 
     ==>  getnm(f);           intersection pts. of Newton polygon with axes
     ==>  T_Transform(f,Q,N); returns f(y,xy^Q)/y^NQ (f: poly, Q,N: int)
     ==>  T1_Transform(f,d,M); returns f(x,y+d*x^M)  (f: poly,d:number,M:int)
     ==>  T2_Transform(f,d,M,N,ref);   a composition of T1 & T
     ==>  koeff(f,I,J);       gets coefficient of indicated monomial of poly f
     ==>  redleit(f,S,E);     restriction of monomials of f to line (S-E)
     ==>  leit(f,n,m);        special case of redleit (for irred. polynomials)
     ==>  testreducible(f,n,m); tests whether f is reducible
     ==>  charPoly(f,M,N);    characteristic polynomial of f
     ==>  find_in_list(L,p);  find int p in list L
     ==>  get_last_divisor(M,N); last divisor in Euclid's algorithm
     ==>  factorfirst(f,M,N); try to factor f without `factorize'
     ==>  factorlist(L);      factorize a list L of polynomials
     ==>  referencepoly(D);   a polynomial f s.t. D is the Newton diagram of f


File: singular.hlp,  Node: mondromy_lib,  Next: qhmoduli_lib,  Prev: hnoether_lib,  Up: Singularities

D.5.6 mondromy_lib
------------------

*Library:*
     mondromy.lib

*Purpose:*
     Monodromy of an Isolated Hypersurface Singularity

*Author:*
     Mathias Schulze, email: mschulze@mathematik.uni-kl.de

*Overview:*
     A library to compute the monodromy of an isolated hypersurface
     singularity.  It uses an algorithm by Brieskorn (manuscripta math.
     2 (1970), 103-161) to compute a connection matrix of the
     meromorphic Gauss-Manin connection up to arbitrarily high order,
     and an algorithm of Gerard and Levelt (Ann. Inst.  Fourier,
     Grenoble 23,1 (1973), pp. 157-195) to transform it to a simple
     pole.

*Procedures:*

* Menu:

* detadj:: determinant and adjoint matrix of square matrix U
* invunit:: series inverse of polynomial u up to order n
* jacoblift:: lifts f^kappa in jacob(f) with minimal kappa
* monodromyB:: monodromy of isolated hypersurface singularity f
* H2basis:: basis of Brieskorn lattice H"

* Menu:

See also:
* gaussman_lib::

*See also:* *note gaussman_lib::.


File: singular.hlp,  Node: detadj,  Next: invunit,  Up: mondromy_lib

D.5.6.1 detadj
..............

Procedure from library `mondromy.lib' (*note mondromy_lib::).

*Usage:*
     detadj(U); U matrix

*Assume:*
     U is a square matrix with non zero determinant.

*Return:*
     The procedure returns a list with at most 2 entries.
     If U is not a square matrix, the list is empty.
     If U is a square matrix, then the first entry is the determinant of
     U.  If U is a square matrix and the determinant of U not zero, then
     the second entry is the adjoint matrix of U.

*Display:*
     The procedure displays comments if printlevel>=1.

*Example:*
     LIB "mondromy.lib";
     ring R=0,x,dp;
     matrix U[2][2]=1,1+x,1+x2,1+x3;
     list daU=detadj(U);
     daU[1];
     ==> -x2-x
     print(daU[2]);
     ==> x3+1, -x-1,
     ==> -x2-1,1    


File: singular.hlp,  Node: invunit,  Next: jacoblift,  Prev: detadj,  Up: mondromy_lib

D.5.6.2 invunit
...............

Procedure from library `mondromy.lib' (*note mondromy_lib::).

*Usage:*
     invunit(u,n); u poly, n int

*Assume:*
     The polynomial u is a series unit.

*Return:*
     The procedure returns the series inverse of u up to order n or a
     zero polynomial if u is no series unit.

*Display:*
     The procedure displays comments if printlevel>=1.

*Example:*
     LIB "mondromy.lib";
     ring R=0,(x,y),dp;
     invunit(2+x3+xy4,10);
     ==> 1/8x2y8-1/16x9+1/4x4y4+1/8x6-1/4xy4-1/4x3+1/2


File: singular.hlp,  Node: jacoblift,  Next: monodromyB,  Prev: invunit,  Up: mondromy_lib

D.5.6.3 jacoblift
.................

Procedure from library `mondromy.lib' (*note mondromy_lib::).

*Usage:*
     jacoblift(f); f poly

*Assume:*
     The polynomial f in a series ring (local ordering) defines an
     isolated hypersurface singularity.

*Return:*
     The procedure returns a list with entries kappa, xi, u of type int,
     vector, poly such that kappa is minimal with f^kappa in jacob(f), u
     is a unit, and u*f^kappa=(matrix(jacob(f))*xi)[1,1].

*Display:*
     The procedure displays comments if printlevel>=1.

*Example:*
     LIB "mondromy.lib";
     ring R=0,(x,y),ds;
     poly f=x2y2+x6+y6;
     jacoblift(f);
     ==> [1]:
     ==>    2
     ==> [2]:
     ==>    1/2x2y3*gen(2)+1/6x7*gen(1)+5/6x6y*gen(2)-2/3xy6*gen(1)+1/6y7*gen(2)-4\
        x4y5*gen(2)-3/2x9y2*gen(1)-15/2x8y3*gen(2)+9/2x3y8*gen(1)-3/2x2y9*gen(2)
     ==> [3]:
     ==>    1-9x2y2


File: singular.hlp,  Node: monodromyB,  Next: H2basis,  Prev: jacoblift,  Up: mondromy_lib

D.5.6.4 monodromyB
..................

Procedure from library `mondromy.lib' (*note mondromy_lib::).

*Usage:*
     monodromyB(f[,opt]); f poly, opt int

*Assume:*
     The polynomial f in a series ring (local ordering) defines an
     isolated hypersurface singularity.

*Return:*
     The procedure returns a residue matrix M of the meromorphic
     Gauss-Manin connection of the singularity defined by f or an empty
     matrix if the assumptions are not fulfilled.  If opt=0 (default),
     exp(-2*pi*i*M) is a monodromy matrix of f, else, only the
     characteristic polynomial of exp(-2*pi*i*M) coincides with the
     characteristic polynomial of the monodromy of f.

*Display:*
     The procedure displays more comments for higher printlevel.

*Example:*
     LIB "mondromy.lib";
     ring R=0,(x,y),ds;
     poly f=x2y2+x6+y6;
     matrix M=monodromyB(f);
     print(M);
     ==> 7/6,0,  0,0,  0,  0,0,   0,-1/2,0,  0,  0,    0,       
     ==> 0,  7/6,0,0,  0,  0,-1/2,0,0,   0,  0,  0,    0,       
     ==> 0,  0,  1,0,  0,  0,0,   0,0,   0,  0,  0,    0,       
     ==> 0,  0,  0,4/3,0,  0,0,   0,0,   0,  0,  0,    0,       
     ==> 0,  0,  0,0,  4/3,0,0,   0,0,   0,  0,  0,    0,       
     ==> 0,  0,  0,0,  0,  1,0,   0,0,   0,  0,  0,    0,       
     ==> 0,  0,  0,0,  0,  0,5/6, 0,0,   0,  0,  0,    0,       
     ==> 0,  0,  0,0,  0,  0,0,   1,0,   0,  0,  0,    0,       
     ==> 0,  0,  0,0,  0,  0,0,   0,5/6, 0,  0,  0,    0,       
     ==> 0,  0,  0,0,  0,  0,0,   0,0,   2/3,0,  0,    0,       
     ==> 0,  0,  0,0,  0,  0,0,   0,0,   0,  2/3,0,    0,       
     ==> 0,  0,  0,0,  0,  0,0,   0,0,   0,  0,  47/44,-625/396,
     ==> 0,  0,  0,0,  0,  0,0,   0,0,   0,  0,  9/44, -3/44    


File: singular.hlp,  Node: H2basis,  Prev: monodromyB,  Up: mondromy_lib

D.5.6.5 H2basis
...............

Procedure from library `mondromy.lib' (*note mondromy_lib::).

*Usage:*
     H2basis(f); f poly

*Assume:*
     The polynomial f in a series ring (local ordering) defines an
     isolated hypersurface singularity.

*Return:*
     The procedure returns a list of representatives of a C{f}-basis of
     the Brieskorn lattice H"=Omega^(n+1)/df^dOmega^(n-1).

*Theory:*
     H" is a free C{f}-module of rank milnor(f).

*Display:*
     The procedure displays more comments for higher printlevel.

*Example:*
     LIB "mondromy.lib";
     ring R=0,(x,y),ds;
     poly f=x2y2+x6+y6;
     H2basis(f);
     ==> [1]:
     ==>    x4
     ==> [2]:
     ==>    x2y2
     ==> [3]:
     ==>    y4
     ==> [4]:
     ==>    x3
     ==> [5]:
     ==>    x2y
     ==> [6]:
     ==>    xy2
     ==> [7]:
     ==>    y3
     ==> [8]:
     ==>    x2
     ==> [9]:
     ==>    xy
     ==> [10]:
     ==>    y2
     ==> [11]:
     ==>    x
     ==> [12]:
     ==>    y
     ==> [13]:
     ==>    1


File: singular.hlp,  Node: qhmoduli_lib,  Next: sing_lib,  Prev: mondromy_lib,  Up: Singularities

D.5.7 qhmoduli_lib
------------------

*Library:*
     qhmoduli.lib

*Purpose:*
     Moduli Spaces of Semi-Quasihomogeneous Singularities

*Author:*
     Thomas Bayer, email: bayert@in.tum.de

*Procedures:*

* Menu:

* ArnoldAction:: Induced action of G_f on T_.
* ModEqn:: Equations of the moduli space for principal part f
* QuotientEquations:: Equations of Variety(I)/G w.r.t. action 'A'
* StabEqn:: Equations of the stabilizer of f.
* StabEqnId:: Equations of the stabilizer of the qhom. ideal I.
* StabOrder:: Order of the stabilizer of f.
* UpperMonomials:: Upper basis of the Milnor algebra of f.
* Max:: maximal integer contained in 'data'
* Min:: minimal integer contained in 'data'
* Table:: list, i-th entry is cmd(i), lb <= i <= ub


File: singular.hlp,  Node: ArnoldAction,  Next: ModEqn,  Up: qhmoduli_lib

D.5.7.1 ArnoldAction
....................

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     ArnoldAction(f, [Gf, B]); poly f; list Gf, B;
     'Gf' is a list of two rings (coming from 'StabEqn')

*Purpose:*
     compute the induced action of the stabilizer G of f on T_, where T_
     is given by the upper monomials B of the Milnor algebra of f.

*Assume:*
     f is quasihomogeneous

*Return:*
     polynomial ring over the same ground field, containing the ideals
     'actionid' and 'stabid'.
     - 'actionid' is the ideal defining the induced action of Gf on T_
     - 'stabid' is the ideal of the stabilizer Gf in the new ring

*Example:*
     LIB "qhmoduli.lib";
     ring B   = 0,(x,y,z), ls;
     poly f = -z5+y5+x2z+x2y;
     def R = ArnoldAction(f);
     setring R;
     actionid;
     ==> actionid[1]=-s(2)*t(1)+s(3)*t(1)
     ==> actionid[2]=-s(2)^2*t(2)+2*s(2)^2*t(3)^2+s(3)^2*t(2)
     ==> actionid[3]=s(2)*t(3)+s(3)*t(3)
     stabid;
     ==> stabid[1]=s(2)*s(3)
     ==> stabid[2]=s(1)^2*s(2)+s(1)^2*s(3)-1
     ==> stabid[3]=s(1)^2*s(3)^2-s(3)
     ==> stabid[4]=s(1)^2+s(2)^4-s(3)^4
     ==> stabid[5]=s(1)^4+s(2)^3-s(3)^3
     ==> stabid[6]=-s(1)^2*s(3)+s(3)^5


File: singular.hlp,  Node: ModEqn,  Next: QuotientEquations,  Prev: ArnoldAction,  Up: qhmoduli_lib

D.5.7.2 ModEqn
..............

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     ModEqn(f [, opt]); poly f; int opt;

*Purpose:*
     compute equations of the moduli space of semiquasihomogeneous
     hypersurface singularity with principal part f w.r.t. right
     equivalence

*Assume:*
     f quasihomogeneous polynomial with an isolated singularity at 0

*Return:*
     polynomial ring, possibly a simple extension of the ground field of
     the basering, containing the ideal 'modid'
     - 'modid' is the ideal of the moduli space if opt is even (> 0).
     otherwise it contains generators of the coordinate ring R of the
     moduli space (note : Spec(R) is the moduli space)

*Options:*
     1 compute equations of the mod. space,
     2 use a primary decomposition
     4 compute E_f0, i.e., the image of G_f0
     To combine options, add their value, default: opt =7

*Example:*
     LIB "qhmoduli.lib";
     ring B   = 0,(x,y), ls;
     poly f = -x4 + xy5;
     def R = ModEqn(f);
     setring R;
     modid;
     ==> modid[1]=Y(5)^2-Y(4)*Y(6)
     ==> modid[2]=Y(4)*Y(5)-Y(3)*Y(6)
     ==> modid[3]=Y(3)*Y(5)-Y(2)*Y(6)
     ==> modid[4]=Y(2)*Y(5)-Y(1)*Y(6)
     ==> modid[5]=Y(4)^2-Y(2)*Y(6)
     ==> modid[6]=Y(3)*Y(4)-Y(1)*Y(6)
     ==> modid[7]=Y(2)*Y(4)-Y(1)*Y(5)
     ==> modid[8]=Y(3)^2-Y(1)*Y(5)
     ==> modid[9]=Y(2)*Y(3)-Y(1)*Y(4)
     ==> modid[10]=Y(2)^2-Y(1)*Y(3)


File: singular.hlp,  Node: QuotientEquations,  Next: StabEqn,  Prev: ModEqn,  Up: qhmoduli_lib

D.5.7.3 QuotientEquations
.........................

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     QuotientEquations(G,action,emb [, opt]); ideal G,action,emb;int opt

*Purpose:*
     compute the quotient of the variety given by the parameterization
     'emb' by the linear action 'action' of the algebraic group G.

*Assume:*
     'action' is linear, G must be finite if the Reynolds operator is
     needed (i.e., NullCone(G,action) returns some non-invariant polys)

*Return:*
     polynomial ring over a simple extension of the ground field of the
     basering, containing the ideals 'id' and 'embedid'.
     - 'id' contains the equations of the quotient, if opt = 1; if opt =
     0, 2, 'id' contains generators of the coordinate ring R of the
     quotient (Spec(R) is the quotient)
     - 'embedid' = 0, if opt = 1;
     if opt = 0, 2, it is the ideal defining the equivariant embedding

*Options:*
     1 compute equations of the quotient,
     2 use a primary decomposition when computing the Reynolds operator
     To combine options, add their value, default: opt =3.


File: singular.hlp,  Node: StabEqn,  Next: StabEqnId,  Prev: QuotientEquations,  Up: qhmoduli_lib

D.5.7.4 StabEqn
...............

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     StabEqn(f); f polynomial

*Purpose:*
     compute the equations of the isometry group of f.

*Assume:*
     f semiquasihomogeneous polynomial with an isolated singularity at 0

*Return:*
     list of two ring 'S1', 'S2'
     - 'S1' contains the equations of the stabilizer (ideal 'stabid')
     - 'S2' contains the action of the stabilizer (ideal 'actionid')

*Global:*
     varSubsList, contains the index j s.t. x(i) -> x(i)t(j) ...

*Example:*
     LIB "qhmoduli.lib";
     ring B = 0,(x,y,z), ls;
     poly f = -z5+y5+x2z+x2y;
     list stab = StabEqn(f);
     def S1 = stab[1]; setring S1;  stabid;
     ==> stabid[1]=s(2)*s(3)
     ==> stabid[2]=s(1)^2*s(2)+s(1)^2*s(3)-1
     ==> stabid[3]=s(1)^2*s(3)^2-s(3)
     ==> stabid[4]=s(2)^4-s(3)^4+s(1)^2
     ==> stabid[5]=s(1)^4+s(2)^3-s(3)^3
     ==> stabid[6]=s(3)^5-s(1)^2*s(3)
     def S2 = stab[2]; setring S2;  actionid;
     ==> actionid[1]=s(1)*x
     ==> actionid[2]=s(3)*y+s(2)*z
     ==> actionid[3]=s(2)*y+s(3)*z


File: singular.hlp,  Node: StabEqnId,  Next: StabOrder,  Prev: StabEqn,  Up: qhmoduli_lib

D.5.7.5 StabEqnId
.................

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     StabEqn(I, w); I ideal, w intvec

*Purpose:*
     compute the equations of the isometry group of the ideal I each
     generator of I is fixed by the stabilizer.

*Assume:*
     I semiquasihomogeneous ideal wrt 'w' with an isolated singularity
     at 0

*Return:*
     list of two ring 'S1', 'S2'
     - 'S1' contains the equations of the stabilizer (ideal 'stabid')
     - 'S2' contains the action of the stabilizer (ideal 'actionid')

*Global:*
     varSubsList, contains the index j s.t. t(i) -> t(i)t(j) ...

*Example:*
     LIB "qhmoduli.lib";
     ring B   = 0,(x,y,z), ls;
     ideal I = x2,y3,z6;
     intvec w = 3,2,1;
     list stab = StabEqnId(I, w);
     ==> // ** redefining d **
     ==> // ** redefining newcoMx **
     ==> // ** redefining coMx **
     ==> // ** redefining d **
     ==> // ** redefining newcoMx **
     ==> // ** redefining coMx **
     def S1 = stab[1]; setring S1;  stabid;
     ==> stabid[1]=s(1)^2-1
     ==> stabid[2]=s(2)^3-1
     ==> stabid[3]=s(3)^6-1
     def S2 = stab[2]; setring S2;  actionid;
     ==> actionid[1]=s(1)*x
     ==> actionid[2]=s(2)*y
     ==> actionid[3]=s(3)*z


File: singular.hlp,  Node: StabOrder,  Next: UpperMonomials,  Prev: StabEqnId,  Up: qhmoduli_lib

D.5.7.6 StabOrder
.................

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     StabOrder(f); poly f;

*Purpose:*
     compute the order of the stabilizer group of f.

*Assume:*
     f quasihomogeneous polynomial with an isolated singularity at 0

*Return:*
     int

*Global:*
     varSubsList


File: singular.hlp,  Node: UpperMonomials,  Next: Max,  Prev: StabOrder,  Up: qhmoduli_lib

D.5.7.7 UpperMonomials
......................

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     UpperMonomials(poly f, [intvec w])

*Purpose:*
     compute the upper monomials of the milnor algebra of f.

*Assume:*
     f is quasihomogeneous (w.r.t. w)

*Return:*
     ideal

*Example:*
     LIB "qhmoduli.lib";
     ring B   = 0,(x,y,z), ls;
     poly f = -z5+y5+x2z+x2y;
     UpperMonomials(f);
     ==> _[1]=y3z3
     ==> _[2]=x2y3
     ==> _[3]=x2y2


File: singular.hlp,  Node: Max,  Next: Min,  Prev: UpperMonomials,  Up: qhmoduli_lib

D.5.7.8 Max
...........

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     Max(data); intvec/list of integers data

*Purpose:*
     find the maximal integer contained in 'data'

*Return:*
     list

*Assume:*
     'data' contains only integers and is not empty


File: singular.hlp,  Node: Min,  Next: Table,  Prev: Max,  Up: qhmoduli_lib

D.5.7.9 Min
...........

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     Min(data); intvec/list of integers data

*Purpose:*
     find the minimal integer contained in 'data'

*Return:*
     list

*Assume:*
     'data' contains only integers and is not empty


File: singular.hlp,  Node: Table,  Prev: Min,  Up: qhmoduli_lib

D.5.7.10 Table
..............

Procedure from library `qhmoduli.lib' (*note qhmoduli_lib::).

*Usage:*
     Table(cmd,i, lb, ub); string cmd, i; int lb, ub

*Purpose:*
     generate a list of size ub - lb + 1 s.t. _[i] = cmd(i)

*Return:*
     list


File: singular.hlp,  Node: sing_lib,  Next: spcurve_lib,  Prev: qhmoduli_lib,  Up: Singularities

D.5.8 sing_lib
--------------

*Library:*
     sing.lib

*Purpose:*
     Invariants of Singularities

*Authors:*
     Gert-Martin Greuel, email: greuel@mathematik.uni-kl.de
     Bernd Martin, email: martin@math.tu-cottbus.de

*Procedures:*

* Menu:

* deform:: infinitesimal deformations of ideal i
* dim_slocus:: dimension of singular locus of ideal i
* is_active:: is poly f an active element mod id? (id ideal/module)
* is_ci:: is ideal i a complete intersection?
* is_is:: is ideal i an isolated singularity?
* is_reg:: is poly f a regular element mod id? (id ideal/module)
* is_regs:: are gen's of ideal i regular sequence modulo id?
* locstd:: SB for local degree ordering without cancelling units
* milnor:: milnor number of ideal i; (assume i is ICIS in nf)
* nf_icis:: generic combinations of generators; get ICIS in nf
* slocus:: ideal of singular locus of ideal i
* qhspectrum:: spectrum numbers of w-homogeneous polynomial f
* Tjurina:: SB of Tjurina module of ideal i (assume i is ICIS)
* tjurina:: Tjurina number of ideal i (assume i is ICIS)
* T_1:: T^1-module of ideal i
* T_2:: T^2-module of ideal i
* T_12:: T^1- and T^2-module of ideal i
* tangentcone:: compute tangent cone of id


File: singular.hlp,  Node: deform,  Next: dim_slocus,  Up: sing_lib

D.5.8.1 deform
..............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     deform(id); id=ideal or poly

*Return:*
     matrix, columns are kbase of infinitesimal deformations

*Example:*
     LIB "sing.lib";
     ring r   = 32003,(x,y,z),ds;
     ideal i  = xy,xz,yz;
     matrix T = deform(i);
     print(T);
     ==> x,0,0,
     ==> 0,0,z,
     ==> 0,y,0 
     print(deform(x3+y5+z2));
     ==> xy3,y3,xy2,y2,xy,y,x,1


File: singular.hlp,  Node: dim_slocus,  Next: is_active,  Prev: deform,  Up: sing_lib

D.5.8.2 dim_slocus
..................

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     dim_slocus(i); i ideal or poly

*Return:*
     dimension of singular locus of i

*Example:*
     LIB "sing.lib";
     ring r  = 32003,(x,y,z),ds;
     ideal i = x5+y6+z6,x2+2y2+3z2;
     dim_slocus(i);
     ==> 0


File: singular.hlp,  Node: is_active,  Next: is_ci,  Prev: dim_slocus,  Up: sing_lib

D.5.8.3 is_active
.................

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     is_active(f,id); f poly, id ideal or module

*Return:*
     1 if f is an active element modulo id (i.e.
     dim(id)=dim(id+f*R^n)+1, if id is a submodule of R^n) resp. 0 if f
     is not active.  The basering may be a quotient ring

*Note:*
     regular parameters are active but not vice versa (id may have
     embedded components). proc is_reg tests whether f is a regular
     parameter

*Example:*
     LIB "sing.lib";
     ring r   =32003,(x,y,z),ds;
     ideal i  = yx3+y,yz3+y3z;
     poly f   = x;
     is_active(f,i);
     ==> 1
     qring q  = std(x4y5);
     poly f   = x;
     module m = [yx3+x,yx3+y3x];
     is_active(f,m);
     ==> 0


File: singular.hlp,  Node: is_ci,  Next: is_is,  Prev: is_active,  Up: sing_lib

D.5.8.4 is_ci
.............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     is_ci(i); i ideal

*Return:*
     intvec = sequence of dimensions of ideals (j[1],...,j[k]), for
     k=1,...,size(j), where j is minimal base of i. i is a complete
     intersection if last number equals nvars-size(i)

*Note:*
     dim(0-ideal) = -1. You may first apply simplify(i,10); in order to
     delete zeroes and multiples from set of generators
     printlevel >=0: display comments (default)

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;                // display comments
     ring r     = 32003,(x,y,z),ds;
     ideal i    = x4+y5+z6,xyz,yx2+xz2+zy7;
     is_ci(i);
     ==> // complete intersection of dim 0
     ==> // dim-sequence:
     ==> 2,1,0
     i          = xy,yz;
     is_ci(i);
     ==> // no complete intersection
     ==> // dim-sequence:
     ==> 2,2
     printlevel = p;


File: singular.hlp,  Node: is_is,  Next: is_reg,  Prev: is_ci,  Up: sing_lib

D.5.8.5 is_is
.............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     is_is(id); id ideal or poly

*Return:*
     intvec = sequence of dimensions of singular loci of ideals
     generated by id[1]..id[i], k = 1..size(id);
     dim(0-ideal) = -1;
     id defines an isolated singularity if last number is 0

*Note:*
     printlevel >=0: display comments (default)

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 32003,(x,y,z),ds;
     ideal i    = x2y,x4+y5+z6,yx2+xz2+zy7;
     is_is(i);
     ==> // dim of singular locus = 0
     ==> // isolated singularity if last number is 0 in dim-sequence:
     ==> 2,1,0
     poly f     = xy+yz;
     is_is(f);
     ==> // dim of singular locus = 1
     ==> // isolated singularity if last number is 0 in dim-sequence:
     ==> 1
     printlevel = p;


File: singular.hlp,  Node: is_reg,  Next: is_regs,  Prev: is_is,  Up: sing_lib

D.5.8.6 is_reg
..............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     is_reg(f,id); f poly, id ideal or module

*Return:*
     1 if multiplication with f is injective modulo id, 0 otherwise

*Note:*
     let R be the basering and id a submodule of R^n. The procedure
     checks injectivity of multiplication with f on R^n/id. The basering
     may be a quotient ring

*Example:*
     LIB "sing.lib";
     ring r  = 32003,(x,y),ds;
     ideal i = x8,y8;
     ideal j = (x+y)^4;
     i       = intersect(i,j);
     poly f  = xy;
     is_reg(f,i);
     ==> 0


File: singular.hlp,  Node: is_regs,  Next: locstd,  Prev: is_reg,  Up: sing_lib

D.5.8.7 is_regs
...............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     is_regs(i[,id]); i poly, id ideal or module (default: id=0)

*Return:*
     1 if generators of i are a regular sequence modulo id, 0 otherwise

*Note:*
     let R be the basering and id a submodule of R^n. The procedure
     checks injectivity of multiplication with i[k] on R^n/id+i[1..k-1].
     The basering may be a quotient ring
     printlevel >=0: display comments (default)
     printlevel >=1: display comments during computation

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r1    = 32003,(x,y,z),ds;
     ideal i    = x8,y8,(x+y)^4;
     is_regs(i);
     ==> // checking whether element 1 is regular mod 1 .. 0
     ==> // checking whether element 2 is regular mod 1 .. 1
     ==> // checking whether element 3 is regular mod 1 .. 2
     ==> // elements 1..2 are regular, 3 is not regular mod 1..2
     ==> 0
     module m   = [x,0,y];
     i          = x8,(x+z)^4;;
     is_regs(i,m);
     ==> // checking whether element 1 is regular mod 1 .. 0
     ==> // checking whether element 2 is regular mod 1 .. 1
     ==> // elements are a regular sequence of length 2
     ==> 1
     printlevel = p;


File: singular.hlp,  Node: locstd,  Next: milnor,  Prev: is_regs,  Up: sing_lib

D.5.8.8 locstd
..............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     locstd (id); id = ideal

*Return:*
     a standard basis for a local degree ordering

*Note:*
     the procedure homogenizes id w.r.t. a new 1st variable @t@,
     computes a SB wrt (dp(1),dp) and substitutes @t@ by 1.
     Hence the result is a SB with respect to an ordering which sorts
     first w.r.t. the order and then refines it with dp. This is a local
     degree ordering.
     This is done in order to avoid cancellation of units and thus be
     able to use option(contentSB);

*Example:*
     LIB "sing.lib";
     ring R = 0,(x,y,z),ds;
     ideal i  = xyz+z5,2x2+y3+z7,3z5+y5;
     locstd(i);
     ==> _[1]=y5+3z5
     ==> _[2]=3x4y3z8-4x3y3z9+6x2y4z9+3y5z10
     ==> _[3]=3x4z13-4x3z14+6x2yz14+3y2z15
     ==> _[4]=3x4yz12-4x3yz13+6x2y2z13+3y3z14
     ==> _[5]=2x2z9+x2y2z8+y3z9
     ==> _[6]=2x2y4z5+y7z5-3x2yz9
     ==> _[7]=6y2z10-3x2y3z8+4xy3z9-3y4z9
     ==> _[8]=3x2y2z8+3y3z9+2xy4z8
     ==> _[9]=18z14-4xy6z8+3y7z8-9x2yz12
     ==> _[10]=xyz+z5
     ==> _[11]=3xz6-y4z5
     ==> _[12]=3y3z6+2xy4z5-3xyz9
     ==> _[13]=y4z5-2xz9-xy2z8
     ==> _[14]=3z10+2xyz9+xy3z8
     ==> _[15]=2x2z5+y3z5-xyz8
     ==> _[16]=y4z-2xz5+yz8
     ==> _[17]=3z6+2xyz5-y2z8
     ==> _[18]=2x2+y3+z7


File: singular.hlp,  Node: milnor,  Next: nf_icis,  Prev: locstd,  Up: sing_lib

D.5.8.9 milnor
..............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     milnor(i); i ideal or poly

*Return:*
     Milnor number of i, if i is ICIS (isolated complete intersection
     singularity) in generic form, resp. -1 if not

*Note:*
     use proc nf_icis to put generators in generic form
     printlevel >=0: display comments (default)

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 32003,(x,y,z),ds;
     ideal j    = x5+y6+z6,x2+2y2+3z2,xyz+yx;
     milnor(j);
     ==> //sequence of discriminant numbers: 100,149,70
     ==> 21
     poly f     = x7+y7+(x-y)^2*x2y2+z2;
     milnor(f);
     ==> 28
     printlevel = p;


File: singular.hlp,  Node: nf_icis,  Next: slocus,  Prev: milnor,  Up: sing_lib

D.5.8.10 nf_icis
................

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     nf_icis(i); i ideal

*Return:*
     ideal = generic linear combination of generators of i if i is an
     ICIS (isolated complete intersection singularity), return i if not

*Note:*
     this proc is useful in connection with proc milnor
     printlevel >=0: display comments (default)

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 32003,(x,y,z),ds;
     ideal i    = x3+y4,z4+yx;
     nf_icis(i);
     ==> // complete intersection of dim 1
     ==> // dim-sequence:
     ==> // dim of singular locus = 0
     ==> // isolated singularity if last number is 0 in dim-sequence:
     ==> // dim of singular locus = 0
     ==> // isolated singularity if last number is 0 in dim-sequence:
     ==> // ICIS in generic form after 1 genericity loop(s)
     ==> _[1]=2xy+x3+y4+2z4
     ==> _[2]=xy+z4
     ideal j    = x3+y4,xy,yz;
     nf_icis(j);
     ==> // no complete intersection
     ==> // dim-sequence:
     ==> // no complete intersection
     ==> _[1]=x3+y4
     ==> _[2]=xy
     ==> _[3]=yz
     printlevel = p;


File: singular.hlp,  Node: slocus,  Next: qhspectrum,  Prev: nf_icis,  Up: sing_lib

D.5.8.11 slocus
...............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     slocus(i); i ideal

*Return:*
     ideal of singular locus of i

*Example:*
     LIB "sing.lib";
     ring r  = 0,(u,v,w,x,y,z),dp;
     ideal i = wx,wy,wz,vx,vy,vz,ux,uy,uz,y3-x2;;
     slocus(i);
     ==> _[1]=x
     ==> _[2]=w
     ==> _[3]=v
     ==> _[4]=u
     ==> _[5]=y2


File: singular.hlp,  Node: qhspectrum,  Next: Tjurina,  Prev: slocus,  Up: sing_lib

D.5.8.12 qhspectrum
...................

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     qhspectrum(f,w); f=poly, w=intvec;

*Assume:*
     f is a weighted homogeneous isolated singularity w.r.t. the weights
     given by w; w must consist of as many positive integers as there
     are variables of the basering

*Compute:*
     the spectral numbers of the w-homogeneous polynomial f, computed in
     a ring of characteristic 0

*Return:*
     intvec d,s1,...,su where:
     d = w-degree(f) and si/d = i-th spectral-number(f)
     No return value if basering has parameters or if f is no isolated
     singularity, displays a warning in this case

*Example:*
     LIB "sing.lib";
     ring r;
     poly f=x3+y5+z2;
     intvec w=10,6,15;
     qhspectrum(f,w);
     ==> 30,1,7,11,13,17,19,23,29
     // the spectrum numbers are:
     // 1/30,7/30,11/30,13/30,17/30,19/30,23/30,29/30


File: singular.hlp,  Node: Tjurina,  Next: tjurina,  Prev: qhspectrum,  Up: sing_lib

D.5.8.13 Tjurina
................

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     Tjurina(id[,<any>]); id=ideal or poly

*Assume:*
     id=ICIS (isolated complete intersection singularity)

*Return:*
     standard basis of Tjurina-module of id,
     of type module if id=ideal, resp. of type ideal if id=poly.  If a
     second argument is present (of any type) return a list:
     [1] = Tjurina number,
     [2] = k-basis of miniversal deformation,
     [3] = SB of Tjurina module,
     [4] = Tjurina module

*Display:*
     Tjurina number if printlevel >= 0 (default)

*Note:*
     Tjurina number = -1 implies that id is not an ICIS

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 0,(x,y,z),ds;
     poly f     = x5+y6+z7+xyz;        // singularity T[5,6,7]
     list T     = Tjurina(f,"");
     ==> // Tjurina number = 16
     show(T[1]);                       // Tjurina number, should be 16
     ==> // int, size 1
     ==> 16
     show(T[2]);                       // basis of miniversal deformation
     ==> // ideal, 16 generator(s)
     ==> z6,
     ==> z5,
     ==> z4,
     ==> z3,
     ==> z2,
     ==> z,
     ==> y5,
     ==> y4,
     ==> y3,
     ==> y2,
     ==> y,
     ==> x4,
     ==> x3,
     ==> x2,
     ==> x,
     ==> 1
     show(T[3]);                       // SB of Tjurina ideal
     ==> // ideal, 6 generator(s)
     ==> xy+7z6,
     ==> xz+6y5,
     ==> yz+5x4,
     ==> 5x5-6y6,
     ==> 6y6,
     ==> z7
     show(T[4]); "";                   // Tjurina ideal
     ==> // ideal, 4 generator(s)
     ==> yz+5x4,
     ==> xz+6y5,
     ==> xy+7z6,
     ==> xyz+x5+y6+z7
     ==> 
     ideal j    = x2+y2+z2,x2+2y2+3z2;
     show(kbase(Tjurina(j)));          // basis of miniversal deformation
     ==> // Tjurina number = 5
     ==> // module, 5 generator(s)
     ==> [z]
     ==> [y]
     ==> [x]
     ==> [1]
     ==> [0,1]
     hilb(Tjurina(j));                 // Hilbert series of Tjurina module
     ==> // Tjurina number = 5
     ==> //         2 t^0
     ==> //        -3 t^1
     ==> //        -3 t^2
     ==> //         7 t^3
     ==> //        -3 t^4
     ==> 
     ==> //         2 t^0
     ==> //         3 t^1
     ==> // dimension (local)   = 0
     ==> // multiplicity = 5
     printlevel = p;


File: singular.hlp,  Node: tjurina,  Next: T_1,  Prev: Tjurina,  Up: sing_lib

D.5.8.14 tjurina
................

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     tjurina(id); id=ideal or poly

*Assume:*
     id=ICIS (isolated complete intersection singularity)

*Return:*
     int = Tjurina number of id

*Note:*
     Tjurina number = -1 implies that id is not an ICIS

*Example:*
     LIB "sing.lib";
     ring r=32003,(x,y,z),(c,ds);
     ideal j=x2+y2+z2,x2+2y2+3z2;
     tjurina(j);
     ==> 5


File: singular.hlp,  Node: T_1,  Next: T_2,  Prev: tjurina,  Up: sing_lib

D.5.8.15 T_1
............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     T_1(id[,<any>]); id = ideal or poly

*Return:*
     T_1(id): of type module/ideal if id is of type ideal/poly.  We call
     T_1(id) the T_1-module of id. It is a std basis of the presentation
     of 1st order deformations of P/id, if P is the basering.  If a
     second argument is present (of any type) return a list of 3
     modules:
     [1]= T_1(id)
     [2]= generators of normal bundle of id, lifted to P
     [3]= module of relations of [2], lifted to P
     (note: transpose[3]*[2]=0 mod id)
     The list contains all non-easy objects which must be computed to
     get T_1(id).

*Display:*
     k-dimension of T_1(id) if printlevel >= 0 (default)

*Note:*
     T_1(id) itself is usually of minor importance. Nevertheless, from
     it all relevant information can be obtained. The most important are
     probably vdim(T_1(id)); (which computes the Tjurina number),
     hilb(T_1(id)); and kbase(T_1(id));
     If T_1 is called with two argument, then matrix([2])*(kbase([1]))
     represents a basis of 1st order semiuniversal deformation of id
     (use proc 'deform', to get this in a direct way).
     For a complete intersection the proc Tjurina is faster

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 32003,(x,y,z),(c,ds);
     ideal i    = xy,xz,yz;
     module T   = T_1(i);
     ==> // dim T_1 = 3
     vdim(T);                      // Tjurina number = dim_K(T_1), should be 3
     ==> 3
     list L=T_1(i,"");
     ==> // dim T_1 = 3
     module kB  = kbase(L[1]);
     print(L[2]*kB);               // basis of 1st order miniversal deformation
     ==> 0,0,0,
     ==> z,0,0,
     ==> 0,y,z 
     show(L[2]);                   // presentation of normal bundle
     ==> // module, 6 generator(s)
     ==> [x]
     ==> [y,z]
     ==> [0,x,y]
     ==> [0,z]
     ==> [0,0,y]
     ==> [0,0,z]
     print(L[3]);                  // relations of i
     ==> z, 0,
     ==> -y,y,
     ==> 0, -x
     print(transpose(L[3])*L[2]);  // should be 0 (mod i)
     ==> xz,0, -xy,-yz,0,  0, 
     ==> 0, yz,0,  yz, -xy,-xz
     printlevel = p;


File: singular.hlp,  Node: T_2,  Next: T_12,  Prev: T_1,  Up: sing_lib

D.5.8.16 T_2
............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     T_2(id[,<any>]); id = ideal

*Return:*
     T_2(id): T_2-module of id . This is a std basis of a presentation
     of the module of obstructions of R=P/id, if P is the basering.  If
     a second argument is present (of any type) return a list of 4
     modules and 1 ideal:
     [1]= T_2(id)
     [2]= standard basis of id (ideal)
     [3]= module of relations of id (=1st syzygy module of id)
     [4]= presentation of syz/kos
     [5]= relations of Hom_P([3]/kos,R), lifted to P
     The list contains all non-easy objects which must be computed to
     get T_2(id).

*Display:*
     k-dimension of T_2(id) if printlevel >= 0 (default)

*Note:*
     The most important information is probably vdim(T_2(id)).  Use proc
     miniversal to get equations of miniversal deformation.

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;
     ring  r    = 32003,(x,y),(c,dp);
     ideal j    = x6-y4,x6y6,x2y4-x5y2;
     module T   = T_2(j);
     ==> // dim T_2 = 6
     vdim(T);
     ==> 6
     hilb(T);"";
     ==> //         1 t^0
     ==> //        -1 t^2
     ==> //        -1 t^3
     ==> //         1 t^5
     ==> 
     ==> //         1 t^0
     ==> //         2 t^1
     ==> //         2 t^2
     ==> //         1 t^3
     ==> // dimension (affine)  = 0
     ==> // degree      = 6
     ==> 
     ring r1    = 0,(x,y,z),dp;
     ideal id   = xy,xz,yz;
     list L     = T_2(id,"");
     ==> // dim T_2 = 0
     vdim(L[1]);                           // vdim of T_2
     ==> 0
     print(L[3]);                          // syzygy module of id
     ==> -z,-z,
     ==> y, 0, 
     ==> 0, x  
     printlevel = p;


File: singular.hlp,  Node: T_12,  Next: tangentcone,  Prev: T_2,  Up: sing_lib

D.5.8.17 T_12
.............

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     T_12(i[,any]); i = ideal

*Return:*
     T_12(i): list of 2 modules:
     * standard basis of T_1-module =T_1(i), 1st order deformations
     * standard basis of T_2-module =T_2(i), obstructions of R=P/i
     If a second argument is present (of any type) return a list of 9
     modules, matrices, integers:
     [1]= standard basis of T_1-module
     [2]= standard basis of T_2-module
     [3]= vdim of T_1
     [4]= vdim of T_2
     [5]= matrix, whose cols present infinitesimal deformations
     [6]= matrix, whose cols are generators of relations of i(=syz(i))
     [7]= matrix, presenting Hom_P(syz/kos,R), lifted to P
     [8]= presentation of T_1-module, no std basis
     [9]= presentation of T_2-module, no std basis

*Display:*
     k-dimension of T_1 and T_2 if printlevel >= 0 (default)

*Note:*
     Use proc miniversal from deform.lib to get miniversal deformation
     of i, the list contains all objects used by proc miniversal

*Example:*
     LIB "sing.lib";
     int p      = printlevel;
     printlevel = 1;
     ring r     = 200,(x,y,z,u,v),(c,ws(4,3,2,3,4));
     ideal i    = xz-y2,yz2-xu,xv-yzu,yu-z3,z2u-yv,zv-u2;
     //a cyclic quotient singularity
     list L     = T_12(i,1);
     ==> // dim T_1 = 5
     ==> // dim T_2 = 3
     print(L[5]);             //matrix of infin. deformations
     ==> 0,  0,  0,  0,  0,  
     ==> yz, y,  z2, 0,  0,  
     ==> -z3,-z2,-zu,yz, yu, 
     ==> -z2,-z, -u, 0,  0,  
     ==> zu, u,  v,  -z2,-zu,
     ==> 0,  0,  0,  u,  v   
     printlevel = p;


File: singular.hlp,  Node: tangentcone,  Prev: T_12,  Up: sing_lib

D.5.8.18 tangentcone
....................

Procedure from library `sing.lib' (*note sing_lib::).

*Usage:*
     tangentcone(id [,n]); id = ideal, n = int

*Return:*
     the tangent cone of id

*Note:*
     the procedure works for any monomial ordering.
     If n=0 use std w.r.t. local ordering ds, if n=1 use locstd

*Example:*
     LIB "sing.lib";
     ring R = 0,(x,y,z),ds;
     ideal i  = 7xyz+z5,x2+y3+z7,5z5+y5;
     tangentcone(i);
     ==> _[1]=x2
     ==> _[2]=7xyz
     ==> _[3]=y5+5z5
     ==> _[4]=7y4z
     ==> _[5]=35z6


File: singular.hlp,  Node: spcurve_lib,  Next: spectrum_lib,  Prev: sing_lib,  Up: Singularities

D.5.9 spcurve_lib
-----------------

*Library:*
     spcurve.lib

*Purpose:*
     Deformations and Invariants of CM-codim 2 Singularities

*Author:*
     Anne Fruehbis-Krueger, anne@mathematik.uni-kl.de

*Procedures:*

* Menu:

* isCMcod2:: presentation matrix of the ideal i, if i is CM
* CMtype:: Cohen-Macaulay type of the ideal i
* matrixT1:: 1st order deformation T1 in matrix description
* semiCMcod2:: semiuniversal deformation of maximal minors of M
* discr:: discriminant of semiuniversal deformation
* qhmatrix:: weights if M is quasihomogeneous
* relweight:: relative matrix weight of N w.r.t. weights (W,a)
* posweight:: deformation of coker(M) of non-negative weight
* KSpencerKernel:: kernel of the Kodaira-Spencer map


File: singular.hlp,  Node: isCMcod2,  Next: CMtype,  Up: spcurve_lib

D.5.9.1 isCMcod2
................

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Usage:*
     isCMcod2(i); i an ideal

*Return:*
     presentation matrix of i, if i is Cohen-Macaulay of codimension 2
     a zero matrix otherwise

*Example:*
     LIB "spcurve.lib";
     ring r=32003,(x,y,z),ds;
     ideal i=xz,yz,x^3-y^4;
     print(isCMcod2(i));
     ==> -y,-x2,
     ==> x, y3, 
     ==> 0, z   


File: singular.hlp,  Node: CMtype,  Next: matrixT1,  Prev: isCMcod2,  Up: spcurve_lib

D.5.9.2 CMtype
..............

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Usage:*
     CMtype(i); i an ideal, CM of codimension 2

*Return:*
     Cohen-Macaulay type of i (integer)
     (-1, if i is not Cohen-Macaulay of codimension 2)

*Example:*
     LIB "spcurve.lib";
     ring r=32003,(x,y,z),ds;
     ideal i=xy,xz,yz;
     CMtype(i);
     ==> 2


File: singular.hlp,  Node: matrixT1,  Next: semiCMcod2,  Prev: CMtype,  Up: spcurve_lib

D.5.9.3 matrixT1
................

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Usage:*
     matrixT1(M,n); M matrix, n integer

*Assume:*
     M is a presentation matrix of an ideal i, CM of codimension 2;
     consider i as a family of ideals in a ring in the first n variables
     where the remaining variables are considered as parameters

*Return:*
     list consisting of the k x (k+1) matrix M and a module K_M such
     that T1=Mat(k,k+1;R)/K_M is the space of first order deformations
     of i

*Example:*
     LIB "spcurve.lib";
     ring r=32003,(x(1),x(2),x(3)),ds;
     ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
     matrix M=isCMcod2(curve);
     matrixT1(M,3);
     ==> [1]:
     ==>    _[1,1]=0
     ==>    _[1,2]=-x(3)
     ==>    _[2,1]=-x(2)
     ==>    _[2,2]=x(2)
     ==>    _[3,1]=x(1)
     ==>    _[3,2]=0
     ==> [2]:
     ==>    _[1]=gen(5)
     ==>    _[2]=gen(4)-gen(3)
     ==>    _[3]=-gen(2)
     ==>    _[4]=x(1)*gen(5)-x(2)*gen(3)
     ==>    _[5]=x(1)*gen(6)-x(2)*gen(4)
     ==>    _[6]=x(2)*gen(3)-x(3)*gen(1)
     ==>    _[7]=x(2)*gen(4)-x(3)*gen(2)
     ==>    _[8]=-x(3)*gen(2)
     ==>    _[9]=x(2)*gen(2)-x(2)*gen(1)
     ==>    _[10]=x(1)*gen(1)
     ==>    _[11]=-x(3)*gen(4)
     ==>    _[12]=x(2)*gen(4)-x(2)*gen(3)
     ==>    _[13]=x(1)*gen(3)
     ==>    _[14]=-x(3)*gen(6)
     ==>    _[15]=x(2)*gen(6)-x(2)*gen(5)
     ==>    _[16]=x(1)*gen(5)


File: singular.hlp,  Node: semiCMcod2,  Next: discr,  Prev: matrixT1,  Up: spcurve_lib

D.5.9.4 semiCMcod2
..................

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Usage:*
     semiCMcod2(M,t1); M matrix, t1 module

*Assume:*
     M is a presentation matrix of an ideal i, CM of codimension 2, and
     t1 is a presentation of the space of first order deformations of i
     ((M,t1) as returned by the procedure matrixT1)

*Create:*
     new basering with name rneu

*Return:*
     ideal in rneu describing the semiuniversal deformation of i

*Note:*
     The current basering should not contain any variables named A(j)
     where j is some integer!

*Example:*
     LIB "spcurve.lib";
     ring r=32003,(x(1),x(2),x(3)),ds;
     ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
     matrix M=isCMcod2(curve);
     list l=matrixT1(M,3);
     semiCMcod2(l[1],std(l[2]));
     ==> _[1]=A(2)*A(3)-x(2)*A(3)-x(1)*x(2)
     ==> _[2]=A(1)*A(3)+x(1)*x(3)
     ==> _[3]=-x(2)*A(1)-x(3)*A(2)+x(2)*x(3)


File: singular.hlp,  Node: discr,  Next: qhmatrix,  Prev: semiCMcod2,  Up: spcurve_lib

D.5.9.5 discr
.............

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Usage:*
     discr(sem,n); sem ideal, n integer

*Assume:*
     sem is the versal deformation of an ideal of codimension 2.
     the first n variables of the ring are treated as variables all the
     others as parameters

*Return:*
     ideal describing the discriminant

*Note:*
     This is not a powerful algorithm!

*Example:*
     LIB "spcurve.lib";
     ring r=32003,(x(1),x(2),x(3)),ds;
     ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
     matrix M=isCMcod2(curve);
     list l=matrixT1(M,3);
     def sem=semiCMcod2(l[1],std(l[2]));
     basering;
     ==> //   characteristic : 32003
     ==> //   number of vars : 6
     ==> //        block   1 : ordering ds
     ==> //                  : names    x(1) x(2) x(3) 
     ==> //        block   2 : ordering dp
     ==> //                  : names    A(1) A(2) A(3) 
     ==> //        block   3 : ordering C
     discr(sem,3);
     ==> _[1]=A(1)*A(2)*A(3)


File: singular.hlp,  Node: qhmatrix,  Next: relweight,  Prev: discr,  Up: spcurve_lib

D.5.9.6 qhmatrix
................

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Usage:*
     qhmatrix(M); M a k x (k+1) matrix

*Return:*
     list, consisting of an integer vector containing the weights of the
     variables of the basering and an integer matrix giving the weights
     of the entries of M, if M is quasihomogeneous; zero integer vector
     and zero integer matrix, if M is not quasihomogeneous, i.e. does
     not allow row and column weights

*Example:*
     LIB "spcurve.lib";
     ring r=0,(x,y,z),ds;
     matrix M[3][2]=z,0,y,x,x^3,y;
     qhmatrix(M);
     ==> [1]:
     ==>    1,2,1
     ==> [2]:
     ==>    1,0,
     ==>    2,1,
     ==>    3,2 
     pmat(M);
     ==> z,  0, 
     ==> y,  x, 
     ==> x3, y


File: singular.hlp,  Node: relweight,  Next: posweight,  Prev: qhmatrix,  Up: spcurve_lib

D.5.9.7 relweight
.................

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Assume:*
     N is a non-zero matrix
     W is an integer matrix of the same size as N
     a is an integer vector giving the weights of the variables

*Return:*
     integer, max(a-weighted order(N_ij) - W_ij | all entries ij)
     string "ERROR" if sizes do not match

*Example:*
     LIB "spcurve.lib";
     ring r=32003,(x,y,z),ds;
     matrix N[2][3]=z,0,y,x,x^3,y;
     intmat W[2][3]=1,1,1,1,1,1;
     intvec a=1,1,1;
     relweight(N,W,a);
     ==> 2


File: singular.hlp,  Node: posweight,  Next: KSpencerKernel,  Prev: relweight,  Up: spcurve_lib

D.5.9.8 posweight
.................

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Usage:*
     posweight(M,t1,n[,s]); M matrix, t1 module, n int, s string
     n=0 : all deformations of non-negative weight
     n=1 : only non-constant deformations of non-negative weight
     n=2 : all deformations of positive weight
     As an optional parameter the name of a new ring may be specified.

*Assume:*
     M is a presentation matrix of a Cohen-Macaulay codimension 2 ideal
     and t1 is its T1 space in matrix notation

*Create:*
     new basering (default name: rneu); a different name for this ring
     may be given as a 4th parameter

*Return:*
     list, consisting of a presentation matrix describing the
     deformation given by the generators of T1 of non-negative/positive
     weight and the weight vector for the new variables

*Note:*
     The current basering should not contain any variables named T(i)
     where i is some integer!

*Example:*
     LIB "spcurve.lib";
     ring r=32003,(x(1),x(2),x(3)),ds;
     ideal curve=(x(3)-x(1)^2)*x(3),(x(3)-x(1)^2)*x(2),x(2)^2-x(1)^7*x(3);
     matrix M=isCMcod2(curve);
     list l=matrixT1(M,3);
     list li=posweight(l[1],std(l[2]),0);
     pmat(li[1]);
     ==> T(2)+x(1)*T(1), -x(3)+x(1)^2, 
     ==> -x(3),          x(2),         
     ==> x(2),           -x(1)^7
     li[2];
     ==> 3,1


File: singular.hlp,  Node: KSpencerKernel,  Prev: posweight,  Up: spcurve_lib

D.5.9.9 KSpencerKernel
......................

Procedure from library `spcurve.lib' (*note spcurve_lib::).

*Usage:*
     KSpencerKernel(M[,s][,v]); M matrix, s string, v intvec
     optional parameters (please specify in this order, if both are
     present):
     * s = first of the names of the new rings
     e.g. "R" leads to ring names R and R1
     * v of size n(n+1) leads to the following module ordering
     gen(v[1]) > gen(v[2]) > ... > gen(v[n(n+1)]) where the matrix entry
     ij corresponds to gen((i-1)*n+j)

*Assume:*
     M is a quasihomogeneous n x (n+1) matrix where the n minors define
     an isolated space curve singularity

*Create:*
     2 new rings (default names: rneu and reneu)
     different ring names may be specified as a 2nd parameter

*Return:*
     coefficient matrix representing the kernel of the Kodaira- Spencer
     map of the family of non-negative deformations having the given
     singularity as special fibre

*Note:*
     * the initial basering should not contain variables with name e(i)
     or T(i), since those variable names will internally be used by the
     script
     * setting an intvec with 5 entries and name watchProgress shows the
     progress of the computations:
     watchProgress[1]>0 => option(prot) in groebner commands
     watchProgress[2]>0 => trace output for highcorner
     watchProgress[3]>0 => output of deformed matrix
     watchProgress[4]>0 => result of elimination step
     watchProgress[4]>1 => trace output of multiplications with xyz and
     subsequent reductions
     watchProgress[5]>0 => matrix representing the kernel using print

*Example:*
     LIB "spcurve.lib";
     ring r=0,(x,y,z),ds;
     matrix M[3][2]=z-x^7,0,y^2,z,x^9,y;
     def KS=KSpencerKernel(M,"ar");
     print(KS);
     ==> T(7),   0,      0,      0,     0,     0,     0,     0,  
     ==> KS[2,1],6*T(3), 3*T(7), 0,     0,     0,     0,     0,  
     ==> KS[3,1],KS[3,2],KS[3,3],6*T(3),3*T(7),0,     0,     0,  
     ==> 10*T(4),8*T(1), 7*T(5), 5*T(2),4*T(6),2*T(8),2*T(3),T(7)
     nameof(basering);
     ==> ar
     basering;
     ==> //   characteristic : 0
     ==> //   number of vars : 17
     ==> //        block   1 : ordering Ws
     ==> //                  : names    e(1) e(2) e(3) e(4) e(5) e(6) x y z 
     ==> //                  : weights  -21 -10 -32 -21 -27 -16 3 16 21 
     ==> //        block   2 : ordering wp
     ==> //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) T(8) 
     ==> //                  : weights     8    5    2   10    7    4    1    2 
     ==> //        block   3 : ordering C


File: singular.hlp,  Node: spectrum_lib,  Prev: spcurve_lib,  Up: Singularities

D.5.10 spectrum_lib
-------------------

*Library:*
     spectrum.lib

*Purpose:*
     Singularity Spectrum for Nondegenerate Singularities

*Author:*
     S. Endrass

*Procedures:*

* Menu:

* spectrumnd:: spectrum of nondegenerate isolated singularity f


File: singular.hlp,  Node: spectrumnd,  Up: spectrum_lib

D.5.10.1 spectrumnd
...................

Procedure from library `spectrum.lib' (*note spectrum_lib::).

*Usage:*
     spectrumnd(f[,1]); poly f

*Assume:*
     basering has characteristic 0 and local ordering,
     f has isolated singularity at 0 and nondegenerate principal part

*Return:*

     list S:
       ideal S[1]: spectral numbers in increasing order
       intvec S[2]:
         int S[2][i]: multiplicity of spectral number S[1][i]

*Note:*
     if a second argument 1 is given,
     no test for a degenerate principal part will be done
     SEE_ALSO: gaussman_lib

*Example:*
     LIB "spectrum.lib";
     ring R=0,(x,y),ds;
     poly f=x^31+x^6*y^7+x^2*y^12+x^13*y^2+y^29;
     spectrumnd(f);
     ==> [1]:
     ==>    _[1]=-67/79
     ==>    _[2]=-62/79
     ==>    _[3]=-45/58
     ==>    _[4]=-57/79
     ==>    _[5]=-41/58
     ==>    _[6]=-55/79
     ==>    _[7]=-52/79
     ==>    _[8]=-37/58
     ==>    _[9]=-50/79
     ==>    _[10]=-18/29
     ==>    _[11]=-47/79
     ==>    _[12]=-45/79
     ==>    _[13]=-33/58
     ==>    _[14]=-16/29
     ==>    _[15]=-43/79
     ==>    _[16]=-42/79
     ==>    _[17]=-40/79
     ==>    _[18]=-1/2
     ==>    _[19]=-15/31
     ==>    _[20]=-14/29
     ==>    _[21]=-38/79
     ==>    _[22]=-27/58
     ==>    _[23]=-14/31
     ==>    _[24]=-35/79
     ==>    _[25]=-25/58
     ==>    _[26]=-13/31
     ==>    _[27]=-33/79
     ==>    _[28]=-12/29
     ==>    _[29]=-23/58
     ==>    _[30]=-31/79
     ==>    _[31]=-12/31
     ==>    _[32]=-30/79
     ==>    _[33]=-21/58
     ==>    _[34]=-11/31
     ==>    _[35]=-28/79
     ==>    _[36]=-10/29
     ==>    _[37]=-26/79
     ==>    _[38]=-19/58
     ==>    _[39]=-10/31
     ==>    _[40]=-25/79
     ==>    _[41]=-9/29
     ==>    _[42]=-17/58
     ==>    _[43]=-23/79
     ==>    _[44]=-9/31
     ==>    _[45]=-8/29
     ==>    _[46]=-21/79
     ==>    _[47]=-15/58
     ==>    _[48]=-8/31
     ==>    _[49]=-20/79
     ==>    _[50]=-7/29
     ==>    _[51]=-19/79
     ==>    _[52]=-18/79
     ==>    _[53]=-7/31
     ==>    _[54]=-13/58
     ==>    _[55]=-6/29
     ==>    _[56]=-16/79
     ==>    _[57]=-6/31
     ==>    _[58]=-15/79
     ==>    _[59]=-11/58
     ==>    _[60]=-14/79
     ==>    _[61]=-5/29
     ==>    _[62]=-13/79
     ==>    _[63]=-5/31
     ==>    _[64]=-9/58
     ==>    _[65]=-11/79
     ==>    _[66]=-4/29
     ==>    _[67]=-4/31
     ==>    _[68]=-10/79
     ==>    _[69]=-7/58
     ==>    _[70]=-9/79
     ==>    _[71]=-3/29
     ==>    _[72]=-8/79
     ==>    _[73]=-3/31
     ==>    _[74]=-7/79
     ==>    _[75]=-5/58
     ==>    _[76]=-6/79
     ==>    _[77]=-2/29
     ==>    _[78]=-2/31
     ==>    _[79]=-5/79
     ==>    _[80]=-3/58
     ==>    _[81]=-4/79
     ==>    _[82]=-3/79
     ==>    _[83]=-1/29
     ==>    _[84]=-1/31
     ==>    _[85]=-2/79
     ==>    _[86]=-1/58
     ==>    _[87]=-1/79
     ==>    _[88]=0
     ==>    _[89]=1/79
     ==>    _[90]=1/58
     ==>    _[91]=2/79
     ==>    _[92]=1/31
     ==>    _[93]=1/29
     ==>    _[94]=3/79
     ==>    _[95]=4/79
     ==>    _[96]=3/58
     ==>    _[97]=5/79
     ==>    _[98]=2/31
     ==>    _[99]=2/29
     ==>    _[100]=6/79
     ==>    _[101]=5/58
     ==>    _[102]=7/79
     ==>    _[103]=3/31
     ==>    _[104]=8/79
     ==>    _[105]=3/29
     ==>    _[106]=9/79
     ==>    _[107]=7/58
     ==>    _[108]=10/79
     ==>    _[109]=4/31
     ==>    _[110]=4/29
     ==>    _[111]=11/79
     ==>    _[112]=9/58
     ==>    _[113]=5/31
     ==>    _[114]=13/79
     ==>    _[115]=5/29
     ==>    _[116]=14/79
     ==>    _[117]=11/58
     ==>    _[118]=15/79
     ==>    _[119]=6/31
     ==>    _[120]=16/79
     ==>    _[121]=6/29
     ==>    _[122]=13/58
     ==>    _[123]=7/31
     ==>    _[124]=18/79
     ==>    _[125]=19/79
     ==>    _[126]=7/29
     ==>    _[127]=20/79
     ==>    _[128]=8/31
     ==>    _[129]=15/58
     ==>    _[130]=21/79
     ==>    _[131]=8/29
     ==>    _[132]=9/31
     ==>    _[133]=23/79
     ==>    _[134]=17/58
     ==>    _[135]=9/29
     ==>    _[136]=25/79
     ==>    _[137]=10/31
     ==>    _[138]=19/58
     ==>    _[139]=26/79
     ==>    _[140]=10/29
     ==>    _[141]=28/79
     ==>    _[142]=11/31
     ==>    _[143]=21/58
     ==>    _[144]=30/79
     ==>    _[145]=12/31
     ==>    _[146]=31/79
     ==>    _[147]=23/58
     ==>    _[148]=12/29
     ==>    _[149]=33/79
     ==>    _[150]=13/31
     ==>    _[151]=25/58
     ==>    _[152]=35/79
     ==>    _[153]=14/31
     ==>    _[154]=27/58
     ==>    _[155]=38/79
     ==>    _[156]=14/29
     ==>    _[157]=15/31
     ==>    _[158]=1/2
     ==>    _[159]=40/79
     ==>    _[160]=42/79
     ==>    _[161]=43/79
     ==>    _[162]=16/29
     ==>    _[163]=33/58
     ==>    _[164]=45/79
     ==>    _[165]=47/79
     ==>    _[166]=18/29
     ==>    _[167]=50/79
     ==>    _[168]=37/58
     ==>    _[169]=52/79
     ==>    _[170]=55/79
     ==>    _[171]=41/58
     ==>    _[172]=57/79
     ==>    _[173]=45/58
     ==>    _[174]=62/79
     ==>    _[175]=67/79
     ==> [2]:
     ==>    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,\
        1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,2,1,1,1\
        ,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,4,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,\
        1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1\
        ,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1


File: singular.hlp,  Node: Invariant theory,  Next: Symbolic-numerical solving,  Prev: Singularities,  Up: SINGULAR libraries

D.6 Invariant theory
====================

* Menu:

* finvar_lib:: procedures to compute invariant rings of finite groups
* ainvar_lib:: procedures to compute invariants rings of the additive group
* rinvar_lib:: procedures to compute invariants ring of reductive groups
* stratify_lib:: algorithmic stratification by the Greuel-Pfister algorithm


File: singular.hlp,  Node: finvar_lib,  Next: ainvar_lib,  Prev: Invariant theory,  Up: Invariant theory

D.6.1 finvar_lib
----------------

*Library:*
     finvar.lib

*Purpose:*
     Invariant Rings of Finite Groups

*Author:*
     Agnes E. Heydtmann, email: agnes@math.uni-sb.de

*Overview:*
     A library for computing polynomial invariants of finite matrix
     groups and generators of related varieties. The algorithms are
     based on B. Sturmfels, G. Kemper and W. Decker et al..

*Main procedures:*

* Menu:

* invariant_ring:: generators of the invariant ring (i.r.)
* invariant_ring_random:: generators of the i.r., randomized alg.
* primary_invariants:: primary invariants (p.i.)
* primary_invariants_random:: primary invariants, randomized alg.

*Auxiliary procedures:*

* Menu:

* cyclotomic:: cyclotomic polynomial
* group_reynolds:: finite group and Reynolds operator (R.o.)
* molien:: Molien series (M.s.)
* reynolds_molien:: Reynolds operator and Molien series
* partial_molien:: partial expansion of Molien series
* evaluate_reynolds:: image under the Reynolds operator
* invariant_basis:: basis of homogeneous invariants of a degree
* invariant_basis_reynolds:: as invariant_basis(), with R.o.
* primary_char0:: primary invariants in char 0
* primary_charp:: primary invariant in char p
* primary_char0_no_molien:: p.i., char 0, without Molien series
* primary_charp_no_molien:: p.i., char p, without Molien series
* primary_charp_without:: p.i., char p, without R.o. or Molien series
* primary_char0_random:: primary invariants in char 0, randomized
* primary_charp_random:: primary invariants in char p, randomized
* primary_char0_no_molien_random:: p.i., char 0, without M.s., randomized
* primary_charp_no_molien_random:: p.i., char p, without M.s., randomized
* primary_charp_without_random:: p.i., char p, without R.o. or M.s., random.
* power_products:: exponents for power products
* secondary_char0:: secondary (s.i.) invariants in char 0
* secondary_charp:: secondary invariants in char p
* secondary_no_molien:: secondary invariants, without Molien series
* secondary_and_irreducibles_no_molien:: s.i. & irreducible s.i., without M.s.
* secondary_not_cohen_macaulay:: s.i. when invariant ring not Cohen-Macaulay
* orbit_variety:: ideal of the orbit variety
* relative_orbit_variety:: ideal of a relative orbit variety
* image_of_variety:: ideal of the image of a variety


File: singular.hlp,  Node: invariant_ring,  Next: invariant_ring_random,  Up: finvar_lib

D.6.1.1 invariant_ring
......................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     invariant_ring(G1,G2,...[,flags]);
     G1,G2,...: <matrices> generating a finite matrix group, flags: an
     optional <intvec> with three entries: if the first one equals 0,
     the program attempts to compute the Molien series and Reynolds
     operator, if it equals 1, the program is told that the Molien
     series should not be computed, if it equals -1 characteristic 0 is
     simulated, i.e. the Molien series is computed as if the base field
     were characteristic 0 (the user must choose a field of large prime
     characteristic, e.g.  32003) and if the first one is anything else,
     it means that the characteristic of the base field divides the
     group order (i.e. it will not even be attempted to compute the
     Reynolds operator or Molien series), the second component should
     give the size of intervals between canceling common factors in the
     expansion of Molien series, 0 (the default) means only once after
     generating all terms, in prime characteristic also a negative
     number can be given to indicate that common factors should always
     be canceled when the expansion is simple (the root of the extension
     field occurs not among the coefficients)

*Return:*
     primary and secondary invariants (both of type <matrix>) generating
     the invariant ring with respect to the matrix group generated by
     the matrices in the input and irreducible secondary invariants
     (type <matrix>) if the Molien series was available

*Display:*
     information about the various stages of the program if the third
     flag does not equal 0

*Theory:*
     Bases of homogeneous invariants are generated successively and
     those are chosen as primary invariants that lower the dimension of
     the ideal generated by the previously found invariants (see
     "Generating a Noetherian Normalization of the Invariant Ring of a
     Finite Group" by Decker, Heydtmann, Schreyer (1998)). In the
     non-modular case secondary invariants are calculated by finding a
     basis (in terms of monomials) of the basering modulo the primary
     invariants, mapping to invariants with the Reynolds operator and
     using those or their power products such that they are linearly
     independent modulo the primary invariants (see "Some Algorithms in
     Invariant Theory of Finite Groups" by Kemper and Steel (1997)). In
     the modular case they are generated according to "Generating
     Invariant Rings of Finite Groups over Arbitrary Fields" by Kemper
     (1996).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix P,S,IS=invariant_ring(A);
     print(P);
     ==> z2,x2+y2,x2y2
     print(S);
     ==> 1,xyz,x2z-y2z,x3y-xy3
     print(IS);
     ==> xyz,x2z-y2z,x3y-xy3


File: singular.hlp,  Node: invariant_ring_random,  Next: primary_invariants,  Prev: invariant_ring,  Up: finvar_lib

D.6.1.2 invariant_ring_random
.............................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     invariant_ring_random(G1,G2,...,r[,flags]);
     G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
     where -|r| to |r| is the range of coefficients of random
     combinations of bases elements that serve as primary invariants,
     flags: an optional <intvec> with three entries: if the first equals
     0, the program attempts to compute the Molien series and Reynolds
     operator, if it equals 1, the program is told that the Molien
     series should not be computed, if it equals -1 characteristic 0 is
     simulated, i.e. the Molien series is computed as if the base field
     were characteristic 0 (the user must choose a field of large prime
     characteristic, e.g. 32003) and if the first one is anything else,
     then the characteristic of the base field divides the group order
     (i.e. we will not even attempt to compute the Reynolds operator or
     Molien series), the second component should give the size of
     intervals between canceling common factors in the expansion of the
     Molien series, 0 (the default) means only once after generating all
     terms, in prime characteristic also a negative number can be given
     to indicate that common factors should always be canceled when the
     expansion is simple (the root of the extension field does not occur
     among the coefficients)

*Return:*
     primary and secondary invariants (both of type <matrix>) generating
     invariant ring with respect to the matrix group generated by the
     matrices in the input and irreducible secondary invariants (type
     <matrix>) if the Molien series was available

*Display:*
     information about the various stages of the program if the third
     flag does not equal 0

*Theory:*
     is the same as for invariant_ring except that random combinations
     of basis elements are chosen as candidates for primary invariants
     and hopefully they lower the dimension of the previously found
     primary invariants by the right amount.

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix P,S,IS=invariant_ring_random(A,1);
     print(P);
     ==> z2,x2+y2,x4+y4-z4
     print(S);
     ==> 1,xyz,x2z-y2z,x3y-xy3
     print(IS);
     ==> xyz,x2z-y2z,x3y-xy3


File: singular.hlp,  Node: primary_invariants,  Next: primary_invariants_random,  Prev: invariant_ring_random,  Up: finvar_lib

D.6.1.3 primary_invariants
..........................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_invariants(G1,G2,...[,flags]);
     G1,G2,...: <matrices> generating a finite matrix group, flags: an
     optional <intvec> with three entries, if the first one equals 0
     (also the default), the program attempts to compute the Molien
     series and Reynolds operator, if it equals 1, the program is told
     that the Molien series should not be computed, if it equals -1
     characteristic 0 is simulated, i.e. the Molien series is computed
     as if the base field were characteristic 0 (the user must choose a
     field of large prime characteristic, e.g. 32003) and if the first
     one is anything else, it means that the characteristic of the base
     field divides the group order, the second component should give the
     size of intervals between canceling common factors in the expansion
     of the Molien series, 0 (the default) means only once after
     generating all terms, in prime characteristic also a negative
     number can be given to indicate that common factors should always
     be canceled when the expansion is simple (the root of the extension
     field occurs not among the coefficients)

*Display:*
     information about the various stages of the program if the third
     flag does not equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring and if
     computable Reynolds operator (type <matrix>) and Molien series
     (type <matrix>) or ring name (type string) where the Molien series
     can be found in the char p case; if the first flag is 1 and we are
     in the non-modular case then an <intvec> is returned giving some of
     the degrees where no non-trivial homogeneous invariants can be
     found

*Theory:*
     Bases of homogeneous invariants are generated successively and
     those are chosen as primary invariants that lower the dimension of
     the ideal generated by the previously found invariants (see paper
     "Generating a Noetherian Normalization of the Invariant Ring of a
     Finite Group" by Decker, Heydtmann, Schreyer (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=primary_invariants(A);
     print(L[1]);
     ==> z2,x2+y2,x2y2


File: singular.hlp,  Node: primary_invariants_random,  Next: cyclotomic,  Prev: primary_invariants,  Up: finvar_lib

D.6.1.4 primary_invariants_random
.................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_invariants_random(G1,G2,...,r[,flags]);
     G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
     where -|r| to |r| is the range of coefficients of the random
     combinations of bases elements, flags: an optional <intvec> with
     three entries, if the first one equals 0 (also the default), the
     program attempts to compute the Molien series and Reynolds
     operator, if it equals 1, the program is told that the Molien
     series should not be computed, if it equals -1 characteristic 0 is
     simulated, i.e. the Molien series is computed as if the base field
     were characteristic 0 (the user must choose a field of large prime
     characteristic, e.g.  32003) and if the first one is anything else,
     it means that the characteristic of the base field divides the
     group order, the second component should give the size of intervals
     between canceling common factors in the expansion of the Molien
     series, 0 (the default) means only once after generating all terms,
     in prime characteristic also a negative number can be given to
     indicate that common factors should always be canceled when the
     expansion is simple (the root of the extension field does not occur
     among the coefficients)

*Display:*
     information about the various stages of the program if the third
     flag does not equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring and if
     computable Reynolds operator (type <matrix>) and Molien series
     (type <matrix>), if the first flag is 1 and we are in the
     non-modular case then an <intvec> is returned giving some of the
     degrees where no non-trivial homogeneous invariants can be found

*Theory:*
     Bases of homogeneous invariants are generated successively and
     random linear combinations are chosen as primary invariants that
     lower the dimension of the ideal generated by the previously found
     invariants (see "Generating a Noetherian Normalization of the
     Invariant Ring of a Finite Group" by Decker, Heydtmann, Schreyer
     (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=primary_invariants_random(A,1);
     print(L[1]);
     ==> z2,x2+y2,x4+y4-z4


File: singular.hlp,  Node: cyclotomic,  Next: group_reynolds,  Prev: primary_invariants_random,  Up: finvar_lib

D.6.1.5 cyclotomic
..................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     cyclotomic(i); i integer > 0

*Returns:*
     the i-th cyclotomic polynomial (type <poly>) as one in the first
     ring variable

*Theory:*
     x^i-1 is divided by the j-th cyclotomic polynomial where j takes on
     the value of proper divisors of i

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     print(cyclotomic(25));
     ==> x20+x15+x10+x5+1


File: singular.hlp,  Node: group_reynolds,  Next: molien,  Prev: cyclotomic,  Up: finvar_lib

D.6.1.6 group_reynolds
......................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     group_reynolds(G1,G2,...[,v]);
     G1,G2,...: nxn <matrices> generating a finite matrix group, v: an
     optional <int>

*Assume:*
     n is the number of variables of the basering, g the number of group
     elements

*Return:*
     a <list>, the first list element will be a gxn <matrix>
     representing the Reynolds operator if we are in the non-modular
     case; if the characteristic is >0, minpoly==0 and the finite group
     non-cyclic the second list element is an <int> giving the lowest
     common multiple of the matrix group elements' order (used in
     molien); in general all other list elements are nxn <matrices>
     listing all elements of the finite group

*Display:*
     information if v does not equal 0

*Theory:*
     The entire matrix group is generated by getting all left products
     of generators with the new elements from the last run through the
     loop (or the generators themselves during the first run). All the
     ones that have been generated before are thrown out and the program
     terminates when no new elements found in one run. Additionally each
     time a new group element is found the corresponding ring mapping of
     which the Reynolds operator is made up is generated. They are
     stored in the rows of the first return value.

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     print(L[1]);
     ==> y, -x,-z,
     ==> -x,-y,z, 
     ==> -y,x, -z,
     ==> x, y, z  
     print(L[2..size(L)]);
     ==> 0, 1,0,
     ==> -1,0,0,
     ==> 0, 0,-1
     ==> -1,0, 0,
     ==> 0, -1,0,
     ==> 0, 0, 1 
     ==> 0,-1,0,
     ==> 1,0, 0,
     ==> 0,0, -1
     ==> 1,0,0,
     ==> 0,1,0,
     ==> 0,0,1 


File: singular.hlp,  Node: molien,  Next: reynolds_molien,  Prev: group_reynolds,  Up: finvar_lib

D.6.1.7 molien
..............

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     molien(G1,G2,...[,ringname,lcm,flags]);
     G1,G2,...: nxn <matrices>, all elements of a finite matrix group,
     ringname: a <string> giving a name for a new ring of characteristic
     0 for the Molien series in case of prime characteristic, lcm: an
     <int> giving the lowest common multiple of the elements' orders in
     case of prime characteristic, minpoly==0 and a non-cyclic group,
     flags: an optional <intvec> with three components: if the first
     element is not equal to 0 characteristic 0 is simulated, i.e. the
     Molien series is computed as if the base field were characteristic
     0 (the user must choose a field of large prime characteristic, e.g.
     32003), the second component should give the size of intervals
     between canceling common factors in the expansion of the Molien
     series, 0 (the default) means only once after generating all terms,
     in prime characteristic also a negative number can be given to
     indicate that common factors should always be canceled when the
     expansion is simple (the root of the extension field does not occur
     among the coefficients)

*Assume:*
     n is the number of variables of the basering, G1,G2... are the
     group elements generated by group_reynolds(), lcm is the second
     return value of group_reynolds()

*Return:*
     in case of characteristic 0 a 1x2 <matrix> giving enumerator and
     denominator of Molien series; in case of prime characteristic a
     ring with the name `ringname` of characteristic 0 is created where
     the same Molien series (named M) is stored

*Display:*
     information if the third component of flags does not equal 0

*Theory:*
     In characteristic 0 the terms 1/det(1-xE) for all group elements of
     the Molien series are computed in a straight forward way. In prime
     characteristic a Brauer lift is involved. The returned matrix gives
     enumerator and denominator of the expanded version where common
     factors have been canceled.

*Example:*
     LIB "finvar.lib";
     "         note the case of prime characteristic"; 
     ==>          note the case of prime characteristic
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     matrix M=molien(L[2..size(L)]);
     print(M);
     ==> x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
     ring S=3,(x,y,z),dp;
     string newring="alksdfjlaskdjf";
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     molien(L[2..size(L)],newring);
     setring alksdfjlaskdjf;
     print(M);
     ==> x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
     setring S;
     kill alksdfjlaskdjf;


File: singular.hlp,  Node: reynolds_molien,  Next: partial_molien,  Prev: molien,  Up: finvar_lib

D.6.1.8 reynolds_molien
.......................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     reynolds_molien(G1,G2,...[,ringname,flags]);
     G1,G2,...: nxn <matrices> generating a finite matrix group,
     ringname: a <string> giving a name for a new ring of characteristic
     0 for the Molien series in case of prime characteristic, flags: an
     optional <intvec> with three components: if the first element is
     not equal to 0 characteristic 0 is simulated, i.e. the Molien
     series is computed as if the base field were characteristic 0 (the
     user must choose a field of large prime characteristic, e.g. 32003)
     the second component should give the size of intervals between
     canceling common factors in the expansion of the Molien series, 0
     (the default) means only once after generating all terms, in prime
     characteristic also a negative number can be given to indicate that
     common factors should always be canceled when the expansion is
     simple (the root of the extension field does not occur among the
     coefficients)

*Assume:*
     n is the number of variables of the basering, G1,G2... are the
     group elements generated by group_reynolds(), g is the size of the
     group

*Return:*
     a gxn <matrix> representing the Reynolds operator is the first
     return value and in case of characteristic 0 a 1x2 <matrix> giving
     enumerator and denominator of Molien series is the second one; in
     case of prime characteristic a ring with the name `ringname` of
     characteristic 0 is created where the same Molien series (named M)
     is stored

*Display:*
     information if the third component of flags does not equal 0

*Theory:*
     The entire matrix group is generated by getting all left products
     of the generators with new elements from the last run through the
     loop (or the generators themselves during the first run). All the
     ones that have been generated before are thrown out and the program
     terminates when are no new elements found in one run. Additionally
     each time a new group element is found the corresponding ring
     mapping of which the Reynolds operator is made up is generated.
     They are stored in the rows of the first return value. In
     characteristic 0 the terms 1/det(1-xE) is computed whenever a new
     element E is found. In prime characteristic a Brauer lift is
     involved and the terms are only computed after the entire matrix
     group is generated (to avoid the modular case). The returned matrix
     gives enumerator and denominator of the expanded version where
     common factors have been canceled.

*Example:*
     LIB "finvar.lib";
     "         note the case of prime characteristic"; 
     ==>          note the case of prime characteristic
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix REY,M=reynolds_molien(A);
     print(REY);
     ==> y, -x,-z,
     ==> -x,-y,z, 
     ==> -y,x, -z,
     ==> x, y, z  
     print(M);
     ==> x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
     ring S=3,(x,y,z),dp;
     string newring="Qadjoint";
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix REY=reynolds_molien(A,newring);
     print(REY);
     ==> y, -x,-z,
     ==> -x,-y,z, 
     ==> -y,x, -z,
     ==> x, y, z  
     setring Qadjoint;
     print(M);
     ==> x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
     setring S;
     kill Qadjoint;


File: singular.hlp,  Node: partial_molien,  Next: evaluate_reynolds,  Prev: reynolds_molien,  Up: finvar_lib

D.6.1.9 partial_molien
......................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     partial_molien(M,n[,p]);
     M: a 1x2 <matrix>, n: an <int> indicating number of terms in the
     expansion, p: an optional <poly>

*Assume:*
     M is the return value of molien or the second return value of
     reynolds_molien, p ought to be the second return value of a
     previous run of partial_molien and avoids recalculating known terms

*Return:*
     n terms (type <poly>) of the partial expansion of the Molien series
     (first n if there is no third parameter given, otherwise the next n
     terms depending on a previous calculation) and an intermediate
     result (type <poly>) of the calculation to be used as third
     parameter in a next run of partial_molien

*Theory:*
     The following calculation is implemented:

     (1+a1x+a2x^2+...+anx^n)/(1+b1x+b2x^2+...+bmx^m)=(1+(a1-b1)x+...
     (1+b1x+b2x^2+...+bmx^m)
     ---------------
        (a1-b1)x+(a2-b2)x^2+...
        (a1-b1)x+b1(a1-b1)x^2+...

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix REY,M=reynolds_molien(A);
     poly p(1..2);
     p(1..2)=partial_molien(M,5);
     p(1);
     ==> 4x5+5x4+2x3+2x2+1
     p(1..2)=partial_molien(M,5,p(2));
     p(1);
     ==> 18x10+12x9+13x8+8x7+8x6


File: singular.hlp,  Node: evaluate_reynolds,  Next: invariant_basis,  Prev: partial_molien,  Up: finvar_lib

D.6.1.10 evaluate_reynolds
..........................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     evaluate_reynolds(REY,I);
     REY: a <matrix> representing the Reynolds operator, I: an arbitrary
     <ideal>

*Assume:*
     REY is the first return value of group_reynolds() or
     reynolds_molien()

*Returns:*
     image of the polynomials defining I under the Reynolds operator
     (type <ideal>)

*Note:*
     the characteristic of the coefficient field of the polynomial ring
     should not divide the order of the finite matrix group

*Theory:*
     REY has been constructed in such a way that each row serves as a
     ring mapping of which the Reynolds operator is made up.

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     ideal I=x2,y2,z2;
     print(evaluate_reynolds(L[1],I));
     ==> 1/2x2+1/2y2,
     ==> 1/2x2+1/2y2,
     ==> z2


File: singular.hlp,  Node: invariant_basis,  Next: invariant_basis_reynolds,  Prev: evaluate_reynolds,  Up: finvar_lib

D.6.1.11 invariant_basis
........................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     invariant_basis(g,G1,G2,...);
     g: an <int> indicating of which degree (>0) the homogeneous basis
     should be, G1,G2,...: <matrices> generating a finite matrix group

*Returns:*
     the basis (type <ideal>) of the space of invariants of degree g

*Theory:*
     A general polynomial of degree g is generated and the generators of
     the matrix group applied. The difference ought to be 0 and this way
     a system of linear equations is created. It is solved by computing
     syzygies.

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     print(invariant_basis(2,A));
     ==> x2+y2,
     ==> z2


File: singular.hlp,  Node: invariant_basis_reynolds,  Next: primary_char0,  Prev: invariant_basis,  Up: finvar_lib

D.6.1.12 invariant_basis_reynolds
.................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     invariant_basis_reynolds(REY,d[,flags]);
     REY: a <matrix> representing the Reynolds operator, d: an <int>
     indicating of which degree (>0) the homogeneous basis should be,
     flags: an optional <intvec> with two entries: its first component
     gives the dimension of the space (default <0 meaning unknown) and
     its second component is used as the number of polynomials that
     should be mapped to invariants during one call of evaluate_reynolds
     if the dimension of the space is unknown or the number such that
     number x dimension polynomials are mapped to invariants during one
     call of evaluate_reynolds

*Assume:*
     REY is the first return value of group_reynolds() or
     reynolds_molien() and flags[1] given by partial_molien

*Return:*
     the basis (type <ideal>) of the space of invariants of degree d

*Theory:*
     Monomials of degree d are mapped to invariants with the Reynolds
     operator. A linearly independent set is generated with the help of
     minbase.

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     intvec flags=0,1,0;
     matrix REY,M=reynolds_molien(A,flags);
     flags=8,6;
     print(invariant_basis_reynolds(REY,6,flags));
     ==> z6,
     ==> x2z4+y2z4,
     ==> x2y2z2,
     ==> x3yz2-xy3z2,
     ==> x4z2+y4z2,
     ==> x4y2+x2y4,
     ==> x5y-xy5,
     ==> x6+y6


File: singular.hlp,  Node: primary_char0,  Next: primary_charp,  Prev: invariant_basis_reynolds,  Up: finvar_lib

D.6.1.13 primary_char0
......................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_char0(REY,M[,v]);
     REY: a <matrix> representing the Reynolds operator, M: a 1x2
     <matrix> representing the Molien series, v: an optional <int>

*Assume:*
     REY is the first return value of group_reynolds or reynolds_molien
     and M the one of molien or the second one of reynolds_molien

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring

*Theory:*
     Bases of homogeneous invariants are generated successively and
     those are chosen as primary invariants that lower the dimension of
     the ideal generated by the previously found invariants (see paper
     "Generating a Noetherian Normalization of the Invariant Ring of a
     Finite Group" by Decker, Heydtmann, Schreyer (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix REY,M=reynolds_molien(A);
     matrix P=primary_char0(REY,M);
     print(P);
     ==> z2,x2+y2,x2y2


File: singular.hlp,  Node: primary_charp,  Next: primary_char0_no_molien,  Prev: primary_char0,  Up: finvar_lib

D.6.1.14 primary_charp
......................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_charp(REY,ringname[,v]);
     REY: a <matrix> representing the Reynolds operator, ringname: a
     <string> giving the name of a ring where the Molien series is
     stored, v: an optional <int>

*Assume:*
     REY is the first return value of group_reynolds or reynolds_molien
     and ringname gives the name of a ring of characteristic 0 that has
     been created by molien or reynolds_molien

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring

*Theory:*
     Bases of homogeneous invariants are generated successively and
     those are chosen as primary invariants that lower the dimension of
     the ideal generated by the previously found invariants (see paper
     "Generating a Noetherian Normalization of the Invariant Ring of a
     Finite Group" by Decker, Heydtmann, Schreyer (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=3,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     string newring="alskdfj";
     molien(L[2..size(L)],newring);
     matrix P=primary_charp(L[1],newring);
     if(system("with","Namespaces")) { kill Top::`newring`; }
     kill `newring`;
     print(P);
     ==> z2,x2+y2,x2y2


File: singular.hlp,  Node: primary_char0_no_molien,  Next: primary_charp_no_molien,  Prev: primary_charp,  Up: finvar_lib

D.6.1.15 primary_char0_no_molien
................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_char0_no_molien(REY[,v]);
     REY: a <matrix> representing the Reynolds operator, v: an optional
     <int>

*Assume:*
     REY is the first return value of group_reynolds or reynolds_molien

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring and an
     <intvec> listing some of the degrees where no non-trivial
     homogeneous invariants are to be found

*Theory:*
     Bases of homogeneous invariants are generated successively and
     those are chosen as primary invariants that lower the dimension of
     the ideal generated by the previously found invariants (see paper
     "Generating a Noetherian Normalization of the Invariant Ring of a
     Finite Group" by Decker, Heydtmann, Schreyer (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     list l=primary_char0_no_molien(L[1]);
     print(l[1]);
     ==> z2,x2+y2,x2y2


File: singular.hlp,  Node: primary_charp_no_molien,  Next: primary_charp_without,  Prev: primary_char0_no_molien,  Up: finvar_lib

D.6.1.16 primary_charp_no_molien
................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_charp_no_molien(REY[,v]);
     REY: a <matrix> representing the Reynolds operator, v: an optional
     <int>

*Assume:*
     REY is the first return value of group_reynolds or reynolds_molien

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring and an
     <intvec> listing some of the degrees where no non-trivial
     homogeneous invariants are to be found

*Theory:*
     Bases of homogeneous invariants are generated successively and
     those are chosen as primary invariants that lower the dimension of
     the ideal generated by the previously found invariants (see paper
     "Generating a Noetherian Normalization of the Invariant Ring of a
     Finite Group" by Decker, Heydtmann, Schreyer (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=3,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     list l=primary_charp_no_molien(L[1]);
     print(l[1]);
     ==> z2,x2+y2,x2y2


File: singular.hlp,  Node: primary_charp_without,  Next: primary_char0_random,  Prev: primary_charp_no_molien,  Up: finvar_lib

D.6.1.17 primary_charp_without
..............................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_charp_without(G1,G2,...[,v]);
     G1,G2,...: <matrices> generating a finite matrix group, v: an
     optional <int>

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring

*Theory:*
     Bases of homogeneous invariants are generated successively and
     those are chosen as primary invariants that lower the dimension of
     the ideal generated by the previously found invariants (see paper
     "Generating a Noetherian Normalization of the Invariant Ring of a
     Finite Group" by Decker, Heydtmann, Schreyer (1998)). No Reynolds
     operator or Molien series is used.

*Example:*
     LIB "finvar.lib";
     ring R=2,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix P=primary_charp_without(A);
     print(P);
     ==> x+y,z,xy


File: singular.hlp,  Node: primary_char0_random,  Next: primary_charp_random,  Prev: primary_charp_without,  Up: finvar_lib

D.6.1.18 primary_char0_random
.............................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_char0_random(REY,M,r[,v]);
     REY: a <matrix> representing the Reynolds operator, M: a 1x2
     <matrix> representing the Molien series, r: an <int> where -|r| to
     |r| is the range of coefficients of the random combinations of
     bases elements, v: an optional <int>

*Assume:*
     REY is the first return value of group_reynolds or reynolds_molien
     and M the one of molien or the second one of reynolds_molien

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring

*Theory:*
     Bases of homogeneous invariants are generated successively and
     random linear combinations are chosen as primary invariants that
     lower the dimension of the ideal generated by the previously found
     invariants (see "Generating a Noetherian Normalization of the
     Invariant Ring of a Finite Group" by Decker, Heydtmann, Schreyer
     (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     matrix REY,M=reynolds_molien(A);
     matrix P=primary_char0_random(REY,M,1);
     print(P);
     ==> z2,x2+y2,x4+y4-z4


File: singular.hlp,  Node: primary_charp_random,  Next: primary_char0_no_molien_random,  Prev: primary_char0_random,  Up: finvar_lib

D.6.1.19 primary_charp_random
.............................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_charp_random(REY,ringname,r[,v]);
     REY: a <matrix> representing the Reynolds operator, ringname: a
     <string> giving the name of a ring where the Molien series is
     stored, r: an <int> where -|r| to |r| is the range of coefficients
     of the random combinations of bases elements, v: an optional <int>

*Assume:*
     REY is the first return value of group_reynolds or reynolds_molien
     and ringname gives the name of a ring of characteristic 0 that has
     been created by molien or reynolds_molien

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring

*Theory:*
     Bases of homogeneous invariants are generated successively and
     random linear combinations are chosen as primary invariants that
     lower the dimension of the ideal generated by the previously found
     invariants (see "Generating a Noetherian Normalization of the
     Invariant Ring of a Finite Group" by Decker, Heydtmann, Schreyer
     (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=3,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     string newring="alskdfj";
     molien(L[2..size(L)],newring);
     matrix P=primary_charp_random(L[1],newring,1);
     if(system("with","Namespaces")) { kill Top::`newring`; }
     kill `newring`;
     print(P);
     ==> z2,x2+y2,x4+y4-z4


File: singular.hlp,  Node: primary_char0_no_molien_random,  Next: primary_charp_no_molien_random,  Prev: primary_charp_random,  Up: finvar_lib

D.6.1.20 primary_char0_no_molien_random
.......................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_char0_no_molien_random(REY,r[,v]);
     REY: a <matrix> representing the Reynolds operator, r: an <int>
     where -|r| to |r| is the range of coefficients of the random
     combinations of bases elements, v: an optional <int>

*Assume:*
     REY is the first return value of group_reynolds or reynolds_molien

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring and an
     <intvec> listing some of the degrees where no non-trivial
     homogeneous invariants are to be found

*Theory:*
     Bases of homogeneous invariants are generated successively and
     random linear combinations are chosen as primary invariants that
     lower the dimension of the ideal generated by the previously found
     invariants (see "Generating a Noetherian Normalization of the
     Invariant Ring of a Finite Group" by Decker, Heydtmann, Schreyer
     (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=0,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     list l=primary_char0_no_molien_random(L[1],1);
     print(l[1]);
     ==> z2,x2+y2,x4+y4-z4


File: singular.hlp,  Node: primary_charp_no_molien_random,  Next: primary_charp_without_random,  Prev: primary_char0_no_molien_random,  Up: finvar_lib

D.6.1.21 primary_charp_no_molien_random
.......................................

Procedure from library `finvar.lib' (*note finvar_lib::).

*Usage:*
     primary_charp_no_molien_random(REY,r[,v]);
     REY: a <matrix> representing the Reynolds operator, r: an <int>
     where -|r| to |r| is the range of coefficients of the random
     combinations of bases elements, v: an optional <int>

*Assume:*
     REY is the first return value of group_reynolds or reynolds_molien

*Display:*
     information about the various stages of the program if v does not
     equal 0

*Return:*
     primary invariants (type <matrix>) of the invariant ring and an
     <intvec> listing some of the degrees where no non-trivial
     homogeneous invariants are to be found

*Theory:*
     Bases of homogeneous invariants are generated successively and
     random linear combinations are chosen as primary invariants that
     lower the dimension of the ideal generated by the previously found
     invariants (see "Generating a Noetherian Normalization of the
     Invariant Ring of a Finite Group" by Decker, Heydtmann, Schreyer
     (1998)).

*Example:*
     LIB "finvar.lib";
     ring R=3,(x,y,z),dp;
     matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
     list L=group_reynolds(A);
     list l=primary_charp_no_molien_random(L[1],1);
     print(l[1]);
     ==> z2,x2+y2,x4+y4-z4

