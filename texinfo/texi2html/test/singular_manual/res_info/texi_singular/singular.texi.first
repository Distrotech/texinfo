\input texinfo    @c -*-texinfo-*-
@comment Id: singular.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment This file was generated by doc2tex.pl from singular.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT singular.doc INSTEAD
@comment this file contains the main structure of the manual


@c ------------------------
@c %**start of header
@c ------------------------
@c DO not edit this file. 

@set VERSION 2-0-4
@set VERSION_DATE October 2002
@set SHORT_VERSION 2-0
@set RPM_VERSION 2.0.4
@setfilename singular.hlp
@settitle Singular 2-0-4 Manual
@c @setchapternewpage odd
@paragraphindent 0
@c ------------------------
@c %**end of header
@c ------------------------

@c --------------------- general settings --------------------

@set singularmanual 1
@c @set namespaces 1
@c DO not edit this file. 

@set _UNAME ix86-Linux
@set ix86-Linux
@c --------------------- end general setting --------------------


@c --------------------- invisible Info header ------------------------
This is the texinfo file describing Singular (version 2-0-4)
@c --------------------- end Info invisible header --------------------


@c --------------------- tex titlepage --------------------

@c print short table of contents in tex right after titlepage
@c Detailed ToC is printed at the end of the manual
@shortcontents

@c -----------------------Top node-----------------------------------
@node Top, Preface, (dir), (dir)

@center @strong{SINGULAR}
@center A Computer Algebra System for Polynomial Computations
@center User Manual for @sc{Singular} Version 2-0-4
@center @uref{http://www.singular.uni-kl.de}


@menu
* Preface::
* Introduction::
* General concepts::
* Data types::
* Functions and system variables::
* Tricks and pitfalls::
* Examples::
* Polynomial data::
* Mathematical background::
* SINGULAR libraries::
* Release Notes::
* Index::
@end menu

@c ----------------------------------------------------------------------------
@node Preface, Introduction, Top, Top
@chapter Preface
@cindex Preface
@comment -*-texinfo-*-
@comment Id: COPYING.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the copyright notice on Singular

@cindex copyright
@cindex factory
@cindex GMP
@cindex MP
@cindex readline
@cindex libfac

@center @sc{Singular} version 2-0-4
@center @uref{http://www.uni-kl.de/,,University of Kaiserslautern}
@center @uref{http://www.mathematik.uni-kl.de/,,Department of Mathematics} and  @uref{http://www.mathematik.uni-kl.de/~zca/,,Centre for Computer Algebra}
@center Authors: @uref{http://www.mathematik.uni-kl.de/~greuel,,G.-M. Greuel}, @uref{http://www.mathematik.uni-kl.de/~pfister,,G. Pfister}, @uref{http://www.mathematik.uni-kl.de/~hannes,,H. Schoenemann}

@center Copyright @copyright{} 1986-2003
@sp 2
@center @strong{NOTICE}

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation ( version 2 of the License );
with the following additional restrictions (which override any conflicting
restrictions in the GPL):

The following software used with @sc{Singular} have their own copyright:
the omalloc library, the readline library,
the Gnu Multiple Precision Library (GMP),
NTL: A Library for doing Number Theory (NTL),
the Multi Protocol library (MP), the
Singular-Factory library, the Singular-libfac library, and,
for the Windows distributions the Cygwin DLL and the Cygwin tools (Cygwin), and the
XEmacs editor (XEmacs).

Their copyrights and licenses can be found in the accompanying files
which are distributed along with these packages.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
(see @uref{http://www.gnu.org/copyleft/gpl.html,,GPL})

Please send any comments or bug reports to
@email{singular@@mathematik.uni-kl.de}.

Please register yourself as a @sc{Singular} user by using the
registration form on the @sc{Singular} homepage
              @uref{http://www.singular.uni-kl.de}.
If for some reason you cannot access the registration form, you
can also register by sending an email to
              @email{singular@@mathematik.uni-kl.de}
with subject line @code{register} and body containing the following data:
     your name, email address, organisation, country and platform(s).


If you use Singular or parts thereof in a project and/or publish
results that were partly obtained using @sc{Singular}, we ask you to
cite @sc{Singular} and inform us thereof -- see
@uref{http://www.singular.uni-kl.de/how_to_cite.html},
for information on how to cite Singular.

@heading Availability

The latest information about @sc{Singular} is always available from
@uref{http://www.singular.uni-kl.de}.
The program @sc{Singular} and the above mentioned parts are available via
anonymous ftp through the following addresses:
@table @asis
@item GMP, libreadline
@copyright{} Free Software Foundation
@* @uref{ftp://ftp.gnu.ai.mit.edu} or its mirrors
@item MP
@copyright{} Gray/Kajler/Wang, Kent State University
@* @uref{http://www.symbolicnet.org/areas/protocols/mp.html}
@item NTL
@copyright{} Victor Shoup
@* @uref{ftp://www.shoup.net}
@item Singular-Factory
@copyright{} Greuel/Stobbe, University of Kaiserslautern:
@* @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/Factory}
@item Singular-libfac
@copyright{}  Messollen, University of Saarbr@"ucken:
@* @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/Libfac}
@item @sc{Singular} binaries and sources
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/} or via a
WWW brow@-ser from
@uref{http://www.mathematik.uni-kl.de/ftp/pub/Math/Singular/}
@item Cygwin
@uref{http://www.cygwin.com/}
@item Xemacs
@uref{http://www.xemacs.org}
@end table

@heading Acknowledgements

The development of @sc{Singular} is directed and coordinated by
Gert-Martin Greuel, Gerhard Pfister, and Hans
Sch@"onemann.

@cindex  Greuel, Gert-Martin
@cindex  Pfister, Gerhard
@cindex Sch@"onemann, Hans

Currently, the @sc{Singular} team has the following members:
Olaf Bachmann,
Anne Fr@"ubis-Kr@"uger,
Thomas Keilen,
Kai Kr@"uger,
Christoph Lossen,
Viktor Levandovskyy,
Wilfred Pohl,
Mathias Schulze,
Eric Westenberger,
and
Tim Wichmann.
@cindex Bachmann, Olaf
@cindex Fr@"ubis-Kr@"uger, Anne
@cindex Keilen, Thomas
@cindex Kr@"uger, Kai
@cindex Lossen, Christoph
@cindex Levandovskyy, Viktor
@cindex Pohl, Wilfred
@cindex Schulze, Mathias
@cindex Westenberger, Eric
@cindex Wichmann, Tim

Past members of the @sc{Singular} team are:
Hubert Grassmann,
Wolfgang Neumann,
Jens Schmidt,
R@"udiger Stobbe.
@cindex Grassmann, Hubert
@cindex Neumann, Wolfgang
@cindex Schmidt, Jens
@cindex Stobbe, R@"udiger

Further contributions to @sc{Singular} were made by:
Thomas Bayer,
Isabelle Bermejo,
Stephan Endra@ss{},
Jose Ignacio Farran Martin,
Wolfram Decker,
Philippe Gimenez,
Christian Gorzel,
Agnes Heydtmann,
Dietmar Hillebrand,
Tobias Hirsch,
Martin Lamm,
Bernd Martin,
Michael Me@ss{}ollen,
Thomas N@"u@ss{}ler,
Moritz Wenk.


We should like to acknowledge the financial support given by
the Volkswagen-Stiftung,
the Deutsche Forschungsgemeinschaft
and the Stiftung f@"ur Innovation des Landes Rheinland-Pfalz
to the @sc{Singular} project.


@c ----------------------------------------------------------------------------
@node Introduction, General concepts, Preface, Top
@chapter Introduction
@cindex Introduction

@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from start.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT start.doc INSTEAD
@comment Id: start.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the "Introduction" chapter.
@c * wichmann: + added changes by GMG.

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').


@menu
* Background::
* How to use this manual::
* Getting started::
@end menu

@c ------------------------------------------------------------------
@node Background, How to use this manual, Introduction, Introduction
@section Background
@cindex Background

@sc{Singular} is a Computer Algebra system for polynomial
computations with emphasis on the special needs of commutative
algebra, algebraic geometry, and singularity theory.

@sc{Singular}'s main computational objects are ideals and
modules over a large variety of baserings. The baserings are polynomial
rings or localizations thereof over a field (e.g., finite fields, the
rationals, floats, algebraic extensions, transcendental extensions) or
quotient rings with respect to an ideal.

@sc{Singular} features one of the fastest and most general
implementations of various algorithms for computing Groebner
resp.@: standard bases. The implementation includes Buchberger's algorithm
(if the ordering is a well ordering) and Mora's algorithm (if the
ordering is a tangent cone ordering) as special cases.  Furthermore, it
provides polynomial factorizations, resultant, characteristic set and
gcd computations, syzygy and free-resolution computations, and many more
related functionalities.

Based on an easy-to-use interactive shell and a C-like programming
language, @sc{Singular}'s internal functionality is augmented and
user-extendible by libraries written in the @sc{Singular} programming
language. A general and efficient implementation of communication links
allows @sc{Singular} to make its functionality available to other
programs.

@sc{Singular}'s development started in 1984 with an implementation of
Mora's Tangent Cone algorithm in Modula-2 on an Atari computer (K.P.
Neuendorf, G. Pfister,
H.@: Schoenemann; Humboldt-Universitaet
@tex
H.\ Sch\"onemann; Humboldt-Universit\"at
@end tex
 zu Berlin).  The need for a new system arose from the investigation of
mathematical problems coming from singularity theory which none of the
existing systems was able to compute.

In the early 1990s @sc{Singular}'s "home-town" moved to
Kaiserslautern, a general standard basis algorithm was implemented in C
and @sc{Singular} was ported to Unix, MS-DOS, Windows NT, and MacOS.

Continuous extensions (like polynomial factorization, gcd computations,
links) and refinements led in 1997 to the release of @sc{Singular}
version 1.0 and in 1998 to the release of version 1.2
(much faster standard and Groebner bases computations based on Hilbert series
and on improved implementations of the algorithms,
libraries for primary decomposition, ring normalization, etc.)

For the highlights of the new @sc{Singular} version 2-0-4 see @ref{News and changes}.

@c Thus, we hope to offer a useful system
@c for dealing with local and global computational aspects
@c of systems of polynomial equations.

@c ------------------------------------------------------------------
@node How to use this manual, Getting started, Background, Introduction
@section How to use this manual
@cindex How to use this manual

@subsubheading For the impatient user
In @ref{Getting started}, some simple examples explain how to use
@sc{Singular}  in a step-by-step manner.

@ref{Examples} should come next for real learning-by-doing or to quickly
solve some given mathematical problems without dwelling too deeply into
@sc{Singular}.
This chapter contains a lot of real-life examples and
detailed instructions and explanations on how to solve mathematical
problems using @sc{Singular}.

@c ------------------------------------------------------------------------
@subsubheading For the systematic user
In @ref{General concepts}, all basic concepts which are important to use
and to understand @sc{Singular} are developed.  But even for users
preferring the systematic approach it will be helpful to have a look at
the examples in @ref{Getting started}, every now and then. The topics in
the chapter are organized more or less in the order the novice user has
to deal with them.

@itemize @bullet
@item
In @ref{Interactive use}, and its subsections there are some words on
entering and exiting @sc{Singular}, followed by a number of other
aspects concerning the interactive user-interface.

@item
To do anything more than trivial integer computations, one needs to
define a basering in @sc{Singular}.  This is explained in detail in
@ref{Rings and orderings}.

@item
An overview of the algorithms implemented in the kernel of @sc{Singular}
is given in @ref{Implemented algorithms}.

@item
In @ref{The SINGULAR language}, language specific concepts are
introduced such as the notions of names and objects, data types and
conversion between them, etc.

@item
In @ref{Input and output}, @sc{Singular}'s mechanisms to store and
retrieve data are discussed.

@item
The more complex concepts of procedures and libraries as
well as tools to debug them are considered in the following sections:
@ref{Procedures}, @ref{Libraries}, and @ref{Debugging tools}.

@end itemize

@ref{Data types}, is a complete treatment for @sc{Singular}'s data types
where each section corresponds to one data type, alphabetically sorted.
For each data type, its purpose is explained, the syntax of its
declaration is given, and related operations and functions are
listed. Examples illustrate its usage.

@ref{Functions and system variables}, is an alphabetically ordered
reference list of all of @sc{Singular}'s functions, control structures,
and system variables.  Each entry includes a description of the syntax
and semantics of the item being explained as well as one or more
examples on how to use it.

@subsubheading Miscellaneous
@ref{Tricks and pitfalls}, is a loose collection of limitations and
features which may be unexpected by those who expect the
@sc{Singular} language to be an exact copy of the C programming language or of
some Computer Algebra system's languages.  But some mathematical hints are
collected there, as well.

@ref{Mathematical background}, introduces some of the mathematical
notions and definitions used throughout this manual.  For example, if in
doubt what exactly @sc{Singular} means by a ``negative degree reverse
lexicographical ordering'' one should refer to this chapter.

@ref{SINGULAR libraries}, lists the
libraries which come with @sc{Singular} and the functions contained in
them, respectively.
@c ------------------------------------------------------------------------

@subsubheading Typographical conventions
Throughout this manual, the following typographical conventions are
adopted:

@itemize @bullet
@item
text in @code{typewriter} denotes @sc{Singular} input and output as well
as reserved names:

@itemize @asis
@item The basering can be set using the command @code{setring}.
@end itemize

@item
the arrow @expansion{} denotes @sc{Singular} output:

@itemize @asis
@item @code{poly p=x+y+z;}
@item @code{p*p;}
@item @code{@expansion{} x2+2xy+y2+2xz+2yz+z2}
@end itemize

@item
square brackets are used to denote parts of syntax descriptions which
are optional:

@itemize @asis
[optional_text] required_text
@end itemize

@item
keys are denoted using typewriter, for example:

@itemize @asis
@item @code{N} (press the key @code{N} to get to the next node in help
mode)
@item @code{RETURN} (press @code{RETURN} to finish an input line)
@item @code{CTRL-P} (press control key together with the key @code{P} to
get the previous input line)
@end itemize

@end itemize

@c ------------------------------------------------------------------
@node Getting started,  , How to use this manual, Introduction
@section Getting started
@cindex Getting started

@sc{Singular} is a special purpose system for polynomial
computations. Hence, most of the powerful computations in @sc{Singular}
require the prior definition of a ring. Most important rings are
polynomial rings over a field, localizations hereof, or quotient rings of
such rings modulo an ideal. However, some simple computations with
integers (machine integers of limited size) and manipulations of strings
are available without a ring.

@menu
* First steps::
* Rings and standard bases::
* Procedures and libraries::
* Change of rings::
* Modules and their annihilator::
* Resolution::
@end menu

@c ------------------------------------------------------------------
@node First steps, Rings and standard bases, Getting started, Getting started
@subsection First steps
@cindex First steps

Once @sc{Singular} is started, it awaits an input after the prompt
@code{>}.  Every statement has to be terminated by @code{;} .

@smallexample
37+5;
@expansion{} 42
@end smallexample

All objects have a type, e.g., integer variables are defined by
the word @code{int}. An assignment is done by the symbol @code{=} .

@smallexample
int k = 2;
@end smallexample

@noindent Test for equality resp.@: inequality is done using @code{==}
resp.@: @code{!=} (or @code{<>}), where @code{0} represents the boolean
value FALSE, any other value represents TRUE.

@smallexample
k == 2;
@expansion{} 1
k != 2;
@expansion{} 0
@end smallexample

@noindent The value of an object is displayed by simply typing its name.

@smallexample
k;
@expansion{} 2
@end smallexample

@noindent On the other hand the output is suppressed if an assignment
is made.

@smallexample
int j;
j = k+1;
@end smallexample

@noindent The last displayed (!) result is always available
with the special symbol @code{_} .

@smallexample
2*_;   // the value from k displayed above
@expansion{} 4
@end smallexample

Text starting with @code{//} denotes a comment and is ignored in
calculations, as seen in the previous example. Furthermore @sc{Singular}
maintains a history of the previous lines of input, which may be accessed by
@code{CTRL-P} (previous) and @code{CTRL-N} (next) or the arrows on the
keyboard. Note that the history is not available on Macintosh systems.

The whole manual is available online by typing the command @code{help;} .
Explanation on single topics, e.g., on @code{intmat}, which defines a
matrix of integers, are obtained by

@smallexample
help intmat;
@end smallexample

@noindent This shows the text of @ref{intmat}, in the printed manual.

Next, we define a
@tex
$3 \times 3$
@end tex
3 x 3
 matrix of integers and initialize it with some values, row by row
from left to right:

@smallexample
intmat m[3][3] = 1,2,3,4,5,6,7,8,9;
@end smallexample

@noindent A single matrix entry may be selected and changed using
square brackets @code{[} and @code{]}.

@smallexample
m[1,2]=0;
m;
@expansion{} 1,0,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9
@end smallexample

To calculate the trace of this matrix, we use a @code{for} loop. The
curly brackets @code{@{} and @code{@}} denote the beginning resp.@:
end of a block. If you define a variable without giving an initial
value, as the variable @code{tr} in the example below, @sc{Singular}
assigns a default value for the specific type. In this case, the default
value for integers is @code{0}. Note that the integer variable @code{j}
has already been defined above.

@smallexample
int tr;
for ( j=1; j <= 3; j++ ) @{ tr=tr + m[j,j]; @}
tr;
@expansion{} 15
@end smallexample

Variables of type string can also be defined and used without a ring
being active. Strings are delimited by @code{"} (double quotes). They
may be used to comment the output of a computation or to give it a nice
format. If a string contains valid @sc{Singular} commands, it can be
executed using the function @code{execute}. The result is the same as if
the commands would have been written on the command line. This feature
is especially useful to define new rings inside procedures.

@smallexample
"example for strings:";
@expansion{} example for strings:
string s="The element of m ";
s = s + "at position [2,3] is:";  // concatenation of strings by +
s , m[2,3] , ".";
@expansion{} The element of m at position [2,3] is: 6 .
s="m[2,1]=0; m;";
execute(s);
@expansion{} 1,0,3,
@expansion{} 0,5,6,
@expansion{} 7,8,9
@end smallexample

This example shows that expressions can be separated by @code{,} (comma)
giving a list of expressions. @sc{Singular} evaluates each expression in
this list and prints all results separated by spaces.

@c ------------------------------------------------------------------
@node Rings and standard bases, Procedures and libraries, First steps, Getting started
@subsection Rings and standard bases
@cindex Rings and standard bases

To calculate with objects as ideals, matrices, modules, and polynomial
vectors, a ring has to be defined first.

@smallexample
ring r = 0,(x,y,z),dp;
@end smallexample

The definition of a ring consists of three parts: the first part
determines the ground field, the second part determines the names of the
ring variables, and the third part determines the monomial ordering to
be used. So the example above declares a polynomial ring called @code{r}
with a ground field of characteristic 
@math{0}
@tex
$0$
@end tex
 (i.e., the rational
numbers) and ring variables called @code{x}, @code{y}, and @code{z}. The
@code{dp} at the end means that the degree reverse lexicographical
ordering should be used.

Other ring declarations:

@table @code
@item ring r1=32003,(x,y,z),dp;
characteristic 32003, variables @code{x}, @code{y}, and @code{z} and
ordering @code{dp}.

@item ring r2=32003,(a,b,c,d),lp;
characteristic 32003, variable names @code{a}, @code{b}, @code{c},
@code{d} and lexicographical ordering.

@item ring r3=7,(x(1..10)),ds;
characteristic 7, variable names @code{x(1)},@dots{},@code{x(10)}, negative
degree reverse lexicographical ordering (@code{ds}).

@item ring r4=(0,a),(mu,nu),lp;
transcendental extension of 
@math{Q}
@tex
$Q$
@end tex
 by 
@math{a}
@tex
$a$
@end tex
, variable names
@code{mu} and @code{nu}.

@item ring r5=real,(a,b),lp;
floating point numbers (single machine precision),
variable names @code{a} and @code{b}.

@item ring r6=(real,50),(a,b),lp;
floating point numbers with extended precision of 50 digits,
variable names @code{a} and @code{b}.

@item ring r7=(complex,50,i),(a,b),lp;
complex floating point numbers with extended precision of 50 digits
and imaginary unit @code{i},
variable names @code{a} and @code{b}.
@end table

@c Another valid characteristic would be, for example, a prime number less
@c or equal to 32003. The name of the ring variables may be any
@c valid @sc{Singular} name. Even indexed names are allowed, so
@c @code{x(1..10)} specifies the ring variables @code{x(1)}, @dots{},
@c @code{x(10)}. @sc{Singular} offers the possibility to calculate with any
@c monomial ordering, some orderings are predefined with special names like
@c @code{dp} in the example above. Another important example is the
@c lexicographical ordering called @code{lp}.
@c
Typing the name of a ring prints its definition. The example below
shows that the default ring in @sc{Singular} is 
@math{Z/32003[x,y,z]}
@tex
$Z/32003[x,y,z]$
@end tex

with degree reverse lexicographical ordering:

@smallexample
@c computed example Rings_and_standard_bases start.doc:494 
ring r8;
r8;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@c end example Rings_and_standard_bases start.doc:494
@end smallexample

Defining a ring makes this ring the current active basering, so each
ring definition above switches to a new basering. The concept of rings
in @sc{Singular} is discussed in detail in
@ref{Rings and orderings}.

The basering is now @code{r8}. Since we want to calculate in the ring
@code{r}, which we defined first, we have to switch back to it. This can
be done using the function @code{setring}:

@smallexample
setring r;
@end smallexample

Once a ring is active, we can define polynomials. A monomial, say
@tex
$x^3$
@end tex
x^3
may be entered in two ways: either using the power operator @code{^},
saying @code{x^3}, or in short-hand notation without operator, saying
@code{x3}. Note that the short-hand notation is forbidden if the name
of the ring variable consists of more than one character. Note, that
@sc{Singular} always expands brackets and automatically sorts the terms
with respect to the monomial ordering of the basering.

@smallexample
poly f =  x3+y3+(x-y)*x2y2+z2;
f;
@expansion{} x3y2-x2y3+x3+y3+z2
@end smallexample

The command @code{size} determines in general the number of ''single
entries`` in an object. In particular, for polynomials, @code{size}
determines the number of monomials.

@smallexample
size(f);
@expansion{} 5
@end smallexample

A natural question is to ask if a point, e.g., @code{(x,y,z)=(1,2,0)}, lies
on the variety defined by the polynomials @code{f} and @code{g}. For
this we define an ideal generated by both polynomials, substitute the
coordinates of the point for the ring variables, and check if the result
is zero:

@smallexample
poly g =  f^2 *(2x-y);
ideal I = f,g;
ideal J = subst(I,var(1),1);
J = subst(J,var(2),2);
J = subst(J,var(3),0);
J;
@expansion{} J[1]=5
@expansion{} J[2]=0
@end smallexample

@noindent Since the result is not zero, the point @code{(1,2,0)} does
not lie on the variety @code{V(f,g)}.

Another question is to decide whether some function vanishes on a
variety, or in algebraic terms if a polynomial is contained in a given
ideal. For this we calculate a standard basis using the command
@code{groebner} and afterwards reduce the polynomial with respect to
this standard basis.

@smallexample
ideal sI = groebner(f);
reduce(g,sI);
@expansion{} 0
@end smallexample

@noindent As the result is @code{0} the polynomial @code{g} belongs to the
ideal defined by @code{f}.

The function @code{groebner}, like many other functions in
@sc{Singular}, prints a protocol during calculations, if desired. The
command @code{option(prot);} enables protocolling whereas
@code{option(noprot);} turns it off.
@ref{option}, explains the meaning
of the different symbols printed during calculations.

The command @code{kbase} calculates a basis of the polynomial ring
modulo an ideal, if the quotient ring is finite dimensional.
As an example we calculate the Milnor number of a
hypersurface singularity in the global and local case. This is the
vector space dimension of the polynomial ring modulo the Jacobian ideal
in the global case resp.@: of the power series ring modulo the Jacobian
ideal in the local case. @xref{Critical points}, for a detailed
explanation.

The Jacobian ideal is obtained with the command @code{jacob}.

@smallexample
ideal J = jacob(f);
@expansion{} // ** redefining J **
J;
@expansion{} J[1]=3x2y2-2xy3+3x2
@expansion{} J[2]=2x3y-3x2y2+3y2
@expansion{} J[3]=2z
@end smallexample

@noindent @sc{Singular} prints the line @code{// ** redefining J
**}. This indicates that we have previously defined a variable with name
@code{J} of type ideal (see above).

To obtain a representing set of the quotient vector space we first
calculate a standard basis, then we apply the function @code{kbase} to
this standard basis.

@smallexample
J = groebner(J);
ideal K = kbase(J);
K;
@expansion{} K[1]=y4
@expansion{} K[2]=xy3
@expansion{} K[3]=y3
@expansion{} K[4]=xy2
@expansion{} K[5]=y2
@expansion{} K[6]=x2y
@expansion{} K[7]=xy
@expansion{} K[8]=y
@expansion{} K[9]=x3
@expansion{} K[10]=x2
@expansion{} K[11]=x
@expansion{} K[12]=1
@end smallexample

@noindent Then

@smallexample
size(K);
@expansion{} 12
@end smallexample

@noindent gives the desired vector space dimension
@tex
$K[x,y,z]/\hbox{\rm jacob}(f)$.
@end tex
K[x,y,z]/jacob(f).
As in @sc{Singular} the functions may take the input directly from
earlier calculations, the whole sequence of commands may be written
in one single statement.

@smallexample
size(kbase(groebner(jacob(f))));
@expansion{} 12
@end smallexample

When we are not interested in a basis of the quotient vector space, but
only in the resulting dimension we may even use the command @code{vdim}
and write:

@smallexample
vdim(groebner(jacob(f)));
@expansion{} 12
@end smallexample

@c ------------------------------------------------------------------
@node Procedures and libraries, Change of rings, Rings and standard bases, Getting started
@subsection Procedures and libraries
@cindex Procedures and libraries

@sc{Singular} offers a comfortable programming language, with a syntax
close to C. So it is possible to define procedures which collect several
commands to a new one. Procedures are defined with the keyword
@code{proc} followed by a name and an optional parameter list with
specified types.  Finally, a procedure may return values using the
command @code{return}.

Define the following procedure called @code{Milnor}:

@smallexample
proc Milnor (poly h)
@{
  return(vdim(groebner(jacob(h))));
@}
@end smallexample

Note: if you have entered the first line of the procedure and pressed
@code{RETURN}, @sc{Singular} prints the prompt @code{.} (dot) instead of
the usual prompt @code{>} . This shows that the input is incomplete and
@sc{Singular} expects more lines. After typing the closing curly
bracket, @sc{Singular} prints the usual prompt indicating that the input
is now complete.

@noindent Then call the procedure:

@smallexample
Milnor(f);
@expansion{} 12
@end smallexample

@noindent Note that the result may depend on the basering as we will
see in the next chapter.

The distribution of  @sc{Singular} contains  several libraries, each of
which is a collection of useful
procedures based on the kernel commands, which extend the functionality
of @sc{Singular}. The command @code{help "all.lib";} lists all libraries
together with a one-line explanation.
@c The command @code{help}
@c library_name@code{;} lists all procedures of the library, @code{help}
@c proc_name@code{;} shows an explanation of the procedure after the
@c library has been loaded. The command @code{LIB "all.lib";} loads all
@c libraries.

One of these libraries is @code{sing.lib} which already contains a
procedure called @code{milnor} to calculate the Milnor number not only
for hypersurfaces but more generally for complete intersection
singularities.

Libraries are loaded with the command @code{LIB}. Some additional
information during the process of loading is displayed on the screen,
which we omit here.

@smallexample
LIB "sing.lib";
@end smallexample

As all input in @sc{Singular} is case sensitive, there is no conflict with
the previously  defined procedure @code{Milnor}, but the result is the same.

@smallexample
milnor(f);
@expansion{} 12
@end smallexample

The procedures in a library have a help part
which is displayed by typing

@smallexample
help milnor;
@c @expansion{} // proc milnor from lib sing.lib
@c @expansion{} proc milnor (ideal i)
@c @expansion{} USAGE:   milnor(i); i ideal or poly
@c @expansion{} RETURN:  Milnor number of i, if i is ICIS (isolated complete intersection
@c @expansion{}          singularity) in generic form, resp. -1 if not
@c @expansion{} NOTE:    use proc nf_icis to put generators in generic form
@c @expansion{}          printlevel >=0: display comments (default)
@c @expansion{} EXAMPLE: example milnor; shows an example
@c @expansion{}
@end smallexample

@noindent as well as some examples, which are executed by

@smallexample
example milnor;
@c @expansion{} // proc milnor from lib sing.lib
@c @expansion{} EXAMPLE:
@c @expansion{}    int p      = printlevel;
@c @expansion{}    printlevel = 1;
@c @expansion{}    ring r     = 32003,(x,y,z),ds;
@c @expansion{}    ideal j    = x5+y6+z6,x2+2y2+3z2,xyz+yx;
@c @expansion{}    milnor(j);
@c @expansion{} //sequence of discriminant numbers: 100,149,70
@c @expansion{} 21
@c @expansion{}    poly f     = x7+y7+(x-y)^2*x2y2+z2;
@c @expansion{}    milnor(f);
@c @expansion{} 28
@c @expansion{}    printlevel = p;
@c @expansion{}
@end smallexample

@noindent Likewise, the library itself has a help part, to show a list of
all the functions
available for the user which are contained in the library.

@smallexample
help sing.lib;
@end smallexample

@noindent The output of the help commands is omitted here.

@c ------------------------------------------------------------------
@node Change of rings, Modules and their annihilator, Procedures and libraries, Getting started
@subsection Change of rings
@cindex Change of rings

To calculate the local Milnor number we have to do the calculation with the
same commands in a ring with local ordering.
Define the localization of the polynomial ring at the origin
(@pxref{Polynomial data}, and @ref{Mathematical background}).

@smallexample
ring rl = 0,(x,y,z),ds;
@end smallexample

This ordering determines the standard basis which will be calculated.
Fetch the polynomial defined in the ring @code{r} into this new ring,
thus avoiding retyping the input.

@smallexample
poly f = fetch(r,f);
f;
@expansion{} z2+x3+y3+x3y2-x2y3
@end smallexample

@noindent Instead of @code{fetch} we can use the function @code{imap}
which is more general but less efficient.
The most general way to fetch data from one ring to another is to use maps,
this will be explained in @ref{map}.

In this ring the terms are ordered by increasing exponents. The local Milnor
number is now

@smallexample
Milnor(f);
@expansion{} 4
@end smallexample

This shows that @code{f} has outside the origin in affine 3-space
singularities with local Milnor number adding up to
@tex
$12-4=8$.
@end tex
12-4=8.
Using global and local orderings as above is a convenient way to check
whether a variety has singularities outside the origin.

The command @code{jacob} applied twice gives the Hessian of @code{f}, a
3x3 - matrix.

@smallexample
matrix H = jacob(jacob(f));
H;
@expansion{} H[1,1]=6x+6xy2-2y3
@expansion{} H[1,2]=6x2y-6xy2
@expansion{} H[1,3]=0
@expansion{} H[2,1]=6x2y-6xy2
@expansion{} H[2,2]=6y+2x3-6x2y
@expansion{} H[2,3]=0
@expansion{} H[3,1]=0
@expansion{} H[3,2]=0
@expansion{} H[3,3]=2
@end smallexample

The @code{print} command displays the matrix in a nicer form.

@smallexample
print(H);
@expansion{} 6x+6xy2-2y3,6x2y-6xy2,  0,
@expansion{} 6x2y-6xy2,  6y+2x3-6x2y,0,
@expansion{} 0,          0,          2
@end smallexample

We may calculate the determinant and (the ideal generated by all) minors of
a given size.

@smallexample
det(H);
@expansion{} 72xy+24x4-72x3y+72xy3-24y4-48x4y2+64x3y3-48x2y4
minor(H,1);  // the 1x1 - minors
@expansion{} _[1]=2
@expansion{} _[2]=6y+2x3-6x2y
@expansion{} _[3]=6x2y-6xy2
@expansion{} _[4]=6x2y-6xy2
@expansion{} _[5]=6x+6xy2-2y3
@end smallexample

The algorithm of the standard basis computations may be
affected by the command @code{option}. For example, a reduced standard
basis of the ideal generated by the
@tex
$1 \times 1$-minors
@end tex
1 x 1 - minors
 of H  is obtained in the following way:
@smallexample
option(redSB);
groebner(minor(H,1));
@expansion{} _[1]=1
@end smallexample

This shows that 1 is contained in the ideal of the
@tex
$1 \times 1$-minors,
@end tex
1 x 1 - minors,
hence the corresponding variety is empty.
@c Coming back to some mathematical considerations, we study the problem how
@c to calculate some ....

@c ------------------------------------------------------------------
@c REMEMBER TO EDIT NEXT AND PREVIOUS NODE IF YOU UNCOMMENT THIS NODE!
@c @node Maps and elimination, Modules and their annihilator, Change of rings, Getting started
@c @subsection Maps and elimination
@c @cindex Maps and elimination

@c ------------------------------------------------------------------
@node Modules and their annihilator, Resolution, Change of rings, Getting started
@subsection Modules and their annihilator
@cindex Modules and and their annihilator

Now we shall give three more advanced examples.

@sc{Singular} is able to handle modules over all the rings,
which can be defined as a basering. A free module of rank @code{n}
is defined as follows:

@smallexample
ring rr;
int n = 4;
freemodule(4);
@expansion{} _[1]=gen(1)
@expansion{} _[2]=gen(2)
@expansion{} _[3]=gen(3)
@expansion{} _[4]=gen(4)
typeof(_);
@expansion{} module
print(freemodule(4));
@expansion{} 1,0,0,0,
@expansion{} 0,1,0,0,
@expansion{} 0,0,1,0,
@expansion{} 0,0,0,1
@end smallexample

To define a module, we give a list of vectors generating a submodule of
a free module. Then this set of vectors may be identified with the
columns of a matrix.  For that reason in @sc{Singular} matrices and
modules may be interchanged. However, the representation is different
(modules may be considered as sparse represented matrices).

@smallexample
ring r =0,(x,y,z),dp;
module MD = [x,0,x],[y,z,-y],[0,z,-2y];
matrix MM = MD;
print(MM);
@expansion{} x,y,0,
@expansion{} 0,z,z,
@expansion{} x,-y,-2y
@end smallexample

However the submodule 
@math{MD}
@tex
$MD$
@end tex
 may also be considered as the module
of relations of the factor module
@tex
$r^3/MD$.
@end tex
r^3/MD.
In this way, @sc{Singular} can treat arbitrary finitely generated modules
over the
basering (@pxref{Representation of mathematical objects}).

In order to get the module of relations of 
@math{MD}
@tex
$MD$
@end tex
,
we use the command @code{syz}.

@smallexample
syz(MD);
@expansion{} _[1]=x*gen(3)-x*gen(2)+y*gen(1)
@end smallexample

We want to calculate, as an application, the annihilator of a given module.
Let
@tex
$M = r^3/U$,
@end tex
M = r^3/U,
where U is our defining module of relations for the module
@tex
$M$.
@end tex
M.

@smallexample
module U = [z3,xy2,x3],[yz2,1,xy5z+z3],[y2z,0,x3],[xyz+x2,y2,0],[xyz,x2y,1];
@end smallexample

Then, by definition, the annihilator of M is the ideal
@tex
$\hbox{ann}(M) = \{a \mid aM = 0 \}$
@end tex
ann(M) = @{a | aM = 0 @}
which is by the description of M the same as
@tex
$\{ a \mid ar^3 \in U \}$.
@end tex
@{ a | ar^3 contained in U@}.
Hence we have to calculate the quotient
@tex
$U \colon r^3 $.
@end tex
U:r^3.
The rank of the free module is determined by the choice of U and is the
number of rows of the corresponding matrix. This may be determined by
the function @code{nrows}. All we have to do now is the following:

@smallexample
quotient(U,freemodule(nrows(U)));
@end smallexample

@noindent The result is too big to be shown here.

@c ------------------------------------------------------------------
@node Resolution,  , Modules and their annihilator, Getting started
@subsection Resolution
@cindex Resolution

There are several commands in @sc{Singular} for computing free resolutions.
The most general command is @code{res(... ,n)} which determines heuristically
what method to use for the given problem. It computes the free resolution
up to the length 
@math{n}
@tex
$n$
@end tex
, where 
@math{n=0}
@tex
$n=0$
@end tex
 corresponds to the full resolution.

Here we use the possibility to inspect the calculation process using the
option @code{prot}.

@smallexample
ring R;      // the default ring in char 32003
R;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z
@expansion{} //        block   2 : ordering C
ideal I = x4+x3y+x2yz,x2y2+xy2z+y2z2,x2z2+2xz3,2x2z2+xyz2;
option(prot);
resolution rs = res(I,0);
@expansion{} using lres
@expansion{} 4(m0)4(m1).5(m1)g.g6(m1)...6(m2)..
@end smallexample

@noindent Disable this protocol with

@smallexample
option(noprot);
@end smallexample

When we enter the name of the calculated resolution, we get a pictorial
description of the minimized resolution where the exponents denote the rank of the
free modules. Note that the calculated resolution itself may not yet be minimal.

@smallexample
rs;
@expansion{} 1      4      5      2      0
@expansion{}R  <-- R  <-- R  <-- R  <-- R
@expansion{}
@expansion{}0      1      2      3      4
print(betti(rs),"betti");
@expansion{}            0     1     2     3
@expansion{} ------------------------------
@expansion{}     0:     1     -     -     -
@expansion{}     1:     -     -     -     -
@expansion{}     2:     -     -     -     -
@expansion{}     3:     -     4     1     -
@expansion{}     4:     -     -     1     -
@expansion{}     5:     -     -     3     2
@expansion{} ------------------------------
@expansion{} total:     1     4     5     2
@end smallexample

In order to minimize the resolution, that is to calculate the maps of the minimal 
free resolution, we use the command @code{minres}:

@smallexample
rs=minres(rs);
@end smallexample

A single module in this resolution is obtained (as usual) with the
brackets @code{[} and @code{]}. The @code{print} command can be used to
display a module in a more readable format:

@smallexample
print(rs[3]);
@expansion{} z3,   -xyz-y2z-4xz2+16z3,
@expansion{} 0,    -y2,
@expansion{} -y+4z,48z, 
@expansion{} x+2z, 48z, 
@expansion{} 0,    x+y-z  
@end smallexample

In this case, the output is to be interpreted as follows: the 3rd syzygy
module of R/I, @code{rs[3]}, is the rank-2-submodule of
@tex
$R^5$
@end tex
R^5
generated by the vectors
@tex
$(z^3,0,-y+4z,x+2z,0)$ and $(-xyz-y^2z-4xz^2+16z^3,-y^2,48z,48z,x+y-z)$.
@end tex
(z^3,0,-y+4z,x+2z,0) and (-xyz-y^2z-4xz^2+16z^3,-y^2,48z,48z,x+y-z).

@c ----------------------------------------------------------------------------
@node General concepts, Data types, Introduction, Top
@chapter General concepts
@cindex General concepts
@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from general.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT general.doc INSTEAD
@comment Id: general.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the general information about Singular

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').

@menu
* Interactive use::
* Emacs user interface::
* Rings and orderings::
* Implemented algorithms::
* The SINGULAR language::
* Input and output::
* Procedures::
* Libraries::
* Guidelines for writing a library::
* Debugging tools::
@end menu


@c ---------------------------------------------------------------------------
@node Interactive use, Emacs user interface, General concepts, General concepts
@section Interactive use
@cindex Interactive use

In this section, aspects of interactive use are discussed.  This
includes how to enter and exit @sc{Singular}, how to interpret its
prompt, how to get the online help, and so on.

There are a few important notes which one should not forget:
@itemize @bullet
@item
every command has to be terminated by a @code{;} (semicolon) followed
by a @key{RETURN}
@item
the online help is accessible by means of the @code{help} function
@end itemize

@menu
* How to enter and exit::
* The SINGULAR prompt::
* The online help system::
* Interrupting SINGULAR::
* Editing input::
* Command line options::
* Startup sequence::
@end menu

@c --------------------------------------------------------------------------
@node How to enter and exit, The SINGULAR prompt, Interactive use, Interactive use
@subsection How to enter and exit
@cindex How to enter and exit

@sc{Singular} can either be run in ASCII-terminal or within Emacs.

To start @sc{Singular} in its ASCII-terminal user interface,  enter
@code{Singular} at the system prompt. The
@sc{Singular} banner appears which, among others, reports the version
and the compilation date.

To start @sc{Singular} in its Emacs user interface, either enter
@code{ESingular} at the system prompt, or type @code{M-x singular}
within a running Emacs (provided you have loaded the file
@code{singular.el} in your running Emacs, see @ref{Running SINGULAR
under Emacs} for details).

Generally, we recommend to use @sc{Singular} in its Emacs interface,
since this offers many more features and is more convenient to
use than the ASCII-terminal interface (@pxref{Emacs user interface}).

To exit @sc{Singular} type @code{quit;}, @code{exit;} or @code{$} (or,
when running within Emacs preferably type @code{C-c $}).

@sc{Singular} and @code{ESingular} may also be started with command line
options and with
filenames as arguments. More generally, the synopsis of @sc{Singular} is
@smallexample
Singular  [options] [file1 [file2 @dots{}]]
ESingular  [options] [file1 [file2 @dots{}]]
@end smallexample

@xref{Command line options}, @ref{Startup sequence}, @ref{Running SINGULAR
under Emacs}.


@c --------------------------------------------------------------------------
@node The SINGULAR prompt,The online help system,How to enter and exit, Interactive use
@subsection The SINGULAR prompt
@cindex prompt
@cindex error recovery
The @sc{Singular} prompt @code{>} (larger than) asks the user for input
of commands.  The ``continuation'' prompt @code{.} (period) asks the
user for input of missing parts of a command (remember the semicolon at
the end of every command).

@sc{Singular} does not interpret the semicolon as the end of a command
if it occurs inside a string.  Also, @sc{Singular} waits for blocks
(sequences of commands enclosed in curly brackets) to be closed before
prompting with @code{>} for more commands.  Thus, if @sc{Singular} does
not respond with its regular prompt after typing a semicolon it may wait
for a @code{"} or a @code{@}} first.

Additional semicolons will not harm @sc{Singular} since they are
interpreted as empty statements.

@c --------------------------------------------------------------------------
@node The online help system,Interrupting SINGULAR, The SINGULAR prompt,Interactive use
@subsection The online help system
@cindex The online help system
@cindex online help
@cindex help, online help system

The online help system is invoked with the @code{help} command.
@code{?} may be used as a synonym for @code{help}.  Simply typing
@code{help;} displays the ``top'' of the help system (i.e., the title
page of the @sc{Singular} manual) which offers a
short table of contents.  Typing @code{help} topic@code{;} shows the
available documentation on topic.  Here, topic may be either a function
name or, more generally, any index entry of the @sc{Singular}
manual. Furthermore, topic may contain wildcard characters.
@xref{help}, for more information.

@cindex browsers
@cindex help browsers
Online help information can be displayed in various help browsers. The
following table lists a summary of the supported browsers. See below for
more details about particular browsers.

@multitable @columnfractions .2 .2 .6
@item @strong{Browser} @tab @strong{Platform}
@tab @strong{Description}

@item html
@cindex help browsers, html
@cindex html, default help
@tab Windows
@tab displays html version of manual in your default html browser

@item winhlp
@cindex help browsers, winhlp
@cindex html, default help
@tab Windows
@tab displays Windows help (.hlp) version of manual

@item netscape
@cindex netscape
@cindex help browsers, netscape
@tab Unix, Windows
@tab uses @code{netscape} to display html version of manual

@item tkinfo
@cindex tkinfo
@cindex help browsers, tkinfo
@tab Unix
@tab uses the @code{tkinfo} program to display texinfo version of manual

@item xinfo
@cindex xinfo
@cindex help browsers, xinfo
@tab Unix, Windows
@tab uses the @code{info} program to display texinfo version of manual in an
extra @code{xterm}

@item info
@cindex info
@cindex help browsers, info
@tab Unix, Windows
@tab uses the @code{info} program to display texinfo version of manual

@item builtin
@cindex help browsers, dummy
@tab all
@tab simply outputs the help information in plain ASCII format

@item emacs
@cindex help browsers, emacs
@tab Unix, Windows
@tab when running @sc{Singular} within (X)emacs, display help in
(X)emacs info buffer.

@item dummy
@tab all
@cindex help browsers, dummy
@tab displays error message about no available help browser
@end multitable

The browser which is used to display the help information, can be either
set at startup time with the command line option  (@pxref{Command line
options})
@smallexample
--brower=<browser>
@end smallexample
or with the @sc{Singular} command (@pxref{system})
@smallexample
system("--browser", <browser>);
@end smallexample
The  @sc{Singular} command
@smallexample
system("browsers");
@end smallexample
lists all available browsers and the command
@smallexample
system("--browser");
@end smallexample
returns the currently used browser.

If no browser is explicitly set by the user, then the first (w.r.t. the
order of the browsers in the table above) available browser is
chosen. In other words, the default browser is @code{netscape} for Unix
platforms, and @code{html} for Windows, unless
your local set-up does not allow to run it.

The @code{.singularrc} (@pxref{Startup sequence}) file is a good place
to set your default browser. Recall that if a file
@code{$HOME/.singularrc} exists on your system, then the content of this
file is executed before the first user input. Hence, putting
@smallexample
if (system("version") >= 1306) // keep backwards-compatibility
@{
  if (! system("--emacs")
  @{
    // only set help browser if not running within emacs
    system("--browser", "info");
  @}
  // if help browser is later on set to netscape,
  // allow it to fetch HTML pages from the net
  system("--allow-net", 1);
@}; // the last semicolon is important: otherwise no ">", but "." prompt
@end smallexample
in your file @code{$HOME/.singularrc} sets your default browser to
@code{info}, unless @sc{Singular} is run within emacs (in which case the
default browser is set automatically to @code{emacs}).


Obviously, certain external files and programs are required for the
@sc{Singular} help system to work correctly. If something is not available
or goes wrong, here are some tips for troubleshooting the help system:

@itemize @bullet
@item
@cindex DISPLAY environment variable
@cindex environment variable, DISPLAY
Under Unix, the environment variable @code{DISPLAY} has to be set for
the browsers @code{netscape}, @code{tkinfo}, and @code{xinfo} to work.

@item
@cindex NETSCAPE environment variable
@cindex XINFO environment variable
@cindex XTERM environment variable
@cindex INFO environment variable
@cindex help browsers, setting command to use
The help browsers @code{netscape}, @code{tkinfo}, @code{xinfo}, and
@code{info} are only available if the respective programs are installed
on your system (for @code{xinfo}, the programs @code{xterm} and
@code{info} are necessary). You can explicitly specify which program to
use, by setting appropriate environment variables (whose names
are the names of the respective programs in all up-case letters).
@*For example,
to use the program @code{navigator} with a private colormap as
@code{netscape} help browser, set the environment variable
@code{NETSCAPE} to the value
@code{"navigator -install"}.
@c TBC (@xref{Setting environment variables}).

@item
If the help browser @code{netscape} can not find the local html
pages of the @sc{Singular} manual (which it looks for at
@code{$RootDir/html} -- see @ref{Loading of a library} for more info on
@code{$RootDir}) @emph{and} the (command-line) option @code{--allow-net}
has @emph{explicitly} been set (see @ref{Command line options} and
@ref{system} for more info on
setting values of command-line options), then it dispatches the html
pages from
@url{http://www.singular.uni-kl.de/Manual} (note that
the non-local net-access of HTML pages is disabled, by default).
@*An
alternative location of a local directory where the html pages reside
can be specified by setting the environment variable
@code{SINGULAR_HTML_DIR}.
@c TBC (@xref{Setting environment variables}).

@item
The help browsers @code{tkinfo}, @code{xinfo}, @code{info}, and
@code{builtin} need the (info) file @code{singular.hlp} which it looks
for at @code{$RootDir/info/singular.hlp} (see @ref{Loading of a library}
for more info on @code{$RootDir}).  An alternative
location of the info file of the manual can be specified by setting the
environment variable @code{SINGULAR_INFO_FILE}.
@c TBC (@xref{Setting environment variables}).
@end itemize

@c inserted refs from general.doc:308
@menu
See also:
* Command line options::
* Loading of a library::
* Startup sequence::
* system::
@end menu
@c end inserted refs from general.doc:308

@subsubheading Info help browsers
@cindex info

The help browsers @code{tkinfo}, @code{xinfo} and @code{info} (so-called
info help browsers) are based on the
@code{info} program from the Gnu @code{texinfo} package.  @xref{Top, An
Introduction to Info, Getting started, info, The Info Manual}, for more
information.

For info help browsers, the online manual is decomposed into ``nodes''
of information, closely
related to the division of the printed manual into sections and
subsections.  A node contains text describing a specific topic at a
specific level of detail.  The top line of a node is its ``header''.
The node's header tells the name of the current node (@code{Node:}), the
name of the next node (@code{Next:}), the name of the previous node
(@code{Prev:}), and the name of the upper node (@code{Up:}).

To move within info, type commands consisting of single characters.  Do
not type @code{RETURN}.  Do not use cursor keys, either.  Using some of
the cursor keys by accident might pop to some totally different node.
Type @code{l} to return to the original node.  Some of the @code{info}
commands read input from the command line at the bottom line.  The
@code{TAB} key may be used to complete partially entered input.

The most important commands are:
@table @asis
@item @code{q}
leaves the online help system
@item @code{n}
goes to the next node
@item @code{p}
goes to the previous node
@item @code{u}
goes to the upper node
@item @code{m}
picks a menu item specified by name
@item @code{f}
follows a cross reference
@item @code{l}
goes to the previously visited node
@item @code{b}
goes to the beginning of the current node
@item @code{e}
goes to the end of the current node
@item @code{SPACE}
scrolls forward a page
@item @code{DEL}
scrolls backward a page
@item @code{h}
invokes info tutorial (use @code{l} to return to the manual or
@code{CTRL-X 0} to remove extra window)
@item @code{CTRL-H}
shows a short overview on the online help system (use @code{l} to return
to the manual or @code{CTRL-X 0} to remove extra window)
@item @code{s}
searches through the manual for a specified string, and selects the node in
which the next occurrence is found
@item @code{1}, @dots{}, @code{9}
picks i-th subtopic from a menu
@end table

@c --------------------------------------------------------------------------
@node Interrupting SINGULAR,Editing input,The online help system,Interactive use
@subsection Interrupting SINGULAR
@cindex Interrupting SINGULAR

On Unix-like operating systems and on Windows NT, typing @code{CTRL-C}
(or, alternatively @code{C-c C-c}, when running within Emacs),
interrupts @sc{Singular}.  @sc{Singular} prints the current command and
the current line and prompts for further action.  The following choices
are available:
@table @code
@item a
returns to the top level after finishing the current (kernel) command. Notice
that commands of the @sc{Singular} kernel (like @code{std}) can not be
aborted, i.e. (@code{a})bort only happens whenever the interpreter is active.
@item c
continues
@item q
quits  @sc{Singular}
@end table

@c --------------------------------------------------------------------------
@node Editing input,Command line options,Interrupting SINGULAR,Interactive use
@subsection Editing input
@cindex Editing input
@cindex SINGULARHIST

@c This section describes only a subset of the key bindings of
@c @sc{Singular} binaries built with the GNU Readline library.
@c @xref{Command Line Editing, GNU Readline Library, Command Line Editing,
@c readline, The GNU Readline Library Manual}, for more information.

The following keys can be used for editing the input and retrieving
previous input lines:
@table @code
@item TAB
provides command line completion for function names and file names
@item CTRL-B
moves cursor left
@item CTRL-F
moves cursor right
@item CTRL-A
moves cursor to beginning of line
@item CTRL-E
moves cursor to end of line
@item CTRL-D
deletes character under cursor
@* Warning: on an empty line, @code{CTRL-D} is interpreted as the
@code{EOF} character which immediately terminates @sc{Singular}.
@item BACKSPACE
@itemx DELETE
@itemx CTRL-H
deletes character before cursor
@item CTRL-K
kills from cursor to end of line
@item CTRL-U
kills from cursor to beginning of line
@item CTRL-N
saves current line on history and gives next line
@item CTRL-P
saves current line on history and gives previous line
@item RETURN
saves the current line to the history and
sends it to the @sc{Singular} parser for interpretation
@end table

When run under a Unix-like operating system and in its ASCII-terminal
user interface,   @sc{Singular} tries to dynamically link at runtime
with the GNU Readline library. @xref{Command Line Editing, GNU Readline
Library, Command Line Editing, readline, The GNU Readline Library
Manual}, for more information. If a shared version of this library can
be found on your machine, then additional command-line editing
features like  history completion are available.
In particular, if @sc{Singular} is able to load that library and
if the environment
variable @code{SINGULARHIST} is set and has a name of a file as value,
then the input history is stored across sessions using this
file. Otherwise, i.e., if the environment variable @code{SINGULARHIST}
is not set, then the history of the last inputs is only available for
the commands of the current session.

@c --------------------------------------------------------------------------
@node Command line options, Startup sequence, Editing input, Interactive use
@subsection Command line options
@cindex Command line options

The synopsis of @sc{Singular} is
@smallexample
Singular  [options] [file1 [file2 @dots{}]]
ESingular  [options] [file1 [file2 @dots{}]]
@end smallexample
Options can be given in both, their long and short format. The following
options control the general behavior of @sc{Singular}:
@table @asis

@item @code{-d}, @code{--sdb}
@cindex -d
@cindex --sdb
@cindex Source code debugger, invocation
Enable the use of the source code debugger.
@xref{Source code debugger}.

@item @code{-e}, @code{--echo[=VAL]}
@cindex -e
@cindex --echo
Set value of variable @code{echo} to @code{VAL} (integer in the range
0, @dots{}, 9). Without an argument, @code{echo} is set to 1, which echoes
all input coming from a file. By default, the value of @code{echo} is
0. @xref{echo}.

@item @code{-h}, @code{--help}
@cindex -h
@cindex --help
@cindex command-line options, short help
Print a one-line description of each command line option and exit.

@item @code{--allow-net}
@cindex --allow-net
@cindex net access
@cindex allowing net access
@cindex help, accessing over the net
Allow the @code{netscape} and @code{html} help browser to fetch HTML manual pages over
the net from the WWW home-site of @sc{Singular}. @xref{The online help
system}, for more info.

@item @code{--browser=VAL}
@cindex --browser
@cindex browser, command line option
Use @code{VAL} as browser for the @sc{Singular} online manual.
@*@code{VAL} may be one of @code{html} (Windows only), @code{netscape}, @code{xinfo},
@code{tkinfo}, @code{info}, @code{builtin}, or @code{emacs}. Depending
on your platform and local
installation, only some browsers might be available. The default browser
is @code{html} for Windows and @code{netscape} for Unix
platforms. @xref{The online help system}, for more info.

@item @code{--no-rc}
@cindex --no-rc
@cindex .singularrc file, no loading
Do not execute the @code{.singularrc} file on start-up.  By default,
this file is executed on start-up.  @xref{Startup sequence}.

@item @code{--no-stdlib}
@cindex --no-stdlib
Do not load the library @code{standard.lib} on start-up. By default,
this library is loaded on start-up.  @xref{Startup sequence}.

@item @code{--no-warn}
@cindex --no-warn
Do not display warning messages.

@item @code{--no-out}
@cindex --no-out
Suppress display of all output.

@item @code{-t}, @code{--no-tty}
@cindex --no-tty
Do not redefine the terminal characteristics.  This option should be
used for batch processes.

@item @code{-q}, @code{--quiet}
@cindex -q
@cindex --quiet
Do not print the start-up banner and messages when loading
libraries. Furthermore, redirect @code{stderr}
(all error messages) to @code{stdout} (normal output channel).  This
option should be used if @sc{Singular}'s output is redirected to a file.

@item @code{-v}, @code{--verbose}
@cindex --verbose
@cindex -v
Print extended information about the version and configuration of
@sc{Singular}  (used optional parts, compilation date, start of random
generator etc.). This information should be included if a user reports
an error to the authors.
@end table

The following command line options allow manipulations of the timer and
the pseudo random generator and enable the passing of commands and strings
to @sc{Singular}:

@table @asis
@item @code{-c}, @code{--execute=STRING}
@cindex -c
@cindex --execute
Execute @code{STRING} as (a sequence of) @sc{Singular} commands on
start-up after the @code{.singularrc} file is executed, but prior to
executing the files given on the command line.  E.g., @code{Singular -c
"help all.lib; quit;"} shows the help for the library @code{all.lib} and
exits.

@item @code{-u}, @code{--user-option=STRING}
@cindex -u
@cindex --user-option
Returns @code{STRING} on @code{system("--user-option")}. This is useful
for passing arbitrary arguments from the command line to the
@sc{Singular} interpreter.  E.g.,
@*@code{Singular -u "xxx.dump" -c 'getdump(system("--user-option"))'}
reads the file @code{xxx.dump} at
start-up and allows the user to start working with all the objects
defined in a previous session.

@item @code{-r}, @code{--random=SEED}
@cindex -r
@cindex --random
Seed (i.e., set the initial value of) the pseudo random generator with
integer @code{SEED}.  If this option is not given, then the random
generator is seeded with a time-based @code{SEED} (the number of
seconds since January, 1, 1970, on Unix-like operating systems, to be
precise).

@item @code{--min-time=SECS}
@cindex --min-time
If the @code{timer} (@pxref{timer}), resp.@:  @code{rtimer}
(@pxref{rtimer}) , variable is
set, report only
times larger than @code{SECS} seconds (@code{SECS} needs to be a
floating point number greater than 0).  By default, this value is set to
0.5 (i.e., half a second).  E.g., the option @code{--min-time=0.01}
forces @sc{Singular} to report all times larger than 1/100 of a
second.

@item @code{--ticks-per-sec=TICKS}
@cindex --ticks-per-sec
Set unit of timer to @code{TICKS} ticks per second (i.e., the value
reported by the @code{timer} and @code{rtimer} variable divided by
@code{TICKS} gives the time in seconds).  By default, this value is 1.

@end table

The next three options are of interest for the use with MP links:
@table @asis
@item @code{-b}, @code{--batch}
@cindex -b
@cindex --batch
Run in MP batch mode. Opens a TCP/IP connection with host specified by
@code{--MPhost} at the port specified by @code{--MPport}. Input is read
from and output is written to this connection in the MP format.
@xref{MPtcp links}.

@item @code{--MPport=PORT}
@cindex --MPport
Use @code{PORT} as default port number for MP connections (whenever not
further specified). This option is mandatory when the @code{--batch}
option is given.  @xref{MPtcp links}.

@item @code{--MPhost=HOST}
@cindex --MPhost
Use @code{HOST} as default host for MP connections (whenever not
further specified).  This option is mandatory when the @code{--batch}
option is given.  @xref{MPtcp links}.
@end table

Finally, the following options are only available when running
@code{ESingular} (see @ref{Running SINGULAR under Emacs} for details).

@table @code

@item --emacs=EMACS
@cindex --emacs
Use @code{EMACS} as Emacs program to run the @sc{Singular} Emacs
interface, where @code{EMACS} may e.g. be emacs ore xemacs.

@item --emacs-dir=DIR
@cindex --emacs-dir
Set the singular-emacs-home-directory, which is the directory where
singular.el can be found, to @code{DIR}.

@item --emacs-load=FILE
@cindex --emacs-load
Load @code{FILE} on Emacs start-up, instead of the default load file.

@item --singular=PROG
@cindex --singular
Start @code{PROG} as @sc{Singular} program within Emacs
@end table

The value of options given to @sc{Singular} (resp.@: their default values,
if an option was not given), can be checked with the command
@code{system("--}long_option_name@code{")}.  @xref{system}.
@smallexample
@c computed example Command_line_options general.doc:658 
  system("--quiet");    // if ``quiet'' 1, otherwise 0
@expansion{} 1
  system("--min-time"); // minimal reported time
@expansion{} 0.5
  system("--random");   // seed of the random generator
@expansion{} 12345678
@c end example Command_line_options general.doc:658
@end smallexample

Furthermore, the value of options (e.g., @code{--browser}) can be
re-set while @sc{Singular} is running with the command
@code{system("--}long_option_name_string @code{",}expression@code{)}. @xref{system}.
@smallexample
  system("--browser", "builtin");  // sets browser to 'builtin'
  system("--ticks-per-sec", 100);  // sets timer resolution to 100
@end smallexample


@c --------------------------------------------------------------------------

@node Startup sequence, , Command line options, Interactive use
@subsection Startup sequence
@cindex Startup sequence

On start-up, @sc{Singular}
@enumerate
@item
loads the library @code{standard.lib} (provided the @code{--no-stdlib}
option was not given),

@item
@cindex file, .singularrc
@cindex .singularrc file
@cindex singularrc
searches the current directory and then the
home directory of the user, and then all directories contained in the
library @code{SearchPath} (see @ref{Loading of a library} for more info
on @code{SearchPath}) for a file named @code{.singularrc} and
executes it, if found (provided the @code{--no-rc} option was not
given),

@item
executes the string specified with the @code{--execute} command line
option,

@item
executes the files @code{file1}, @code{file2} @dots{}  (given on the command
line) in that order.
@end enumerate

@strong{Note:} @code{.singularrc} file(s) are an appropriate place for
setting some default values of (command-line) options.

For example, a system administrator might remove the locally installed
HTML version of the manual and put a @code{.singularrc} file
with the following content
@smallexample
if (system("version") >= 1306) // assure backwards-compatibility
@{
  system("--allow-net", 1);
@}; // the last semicolon is important: otherwise no ">", but "." prompt
@end smallexample
in the directory containing the @sc{Singular} libraries, thereby
allowing to fetch the HTML on-line help from the WWW home-site of
@sc{Singular}.

On the other hand, a single user might put a @code{.singularrc} with the
following content
@smallexample
if (system("version") >= 1306) // assure backwards-compatibility
@{
  if (! system("--emacs"))
  @{
    // set default browser to info, unless we run within emacs
    system("--browser", "info");
  @}
@}; // the last semicolon is important: otherwise no ">", but "." prompt
@end smallexample
in his home directory, which sets the default help browser to
@code{info} (unless @sc{Singular} is run within emacs) and thereby
prevents the execution of the"global"
@code{.singularrc} file installed by the system administrator (since the
@code{.singularrc} file of the user is found before the "global"
@code{.singularrc} file installed by the system administrator).

@c ---------------------------------------------------------------------------
@node Emacs user interface, Rings and orderings, Interactive use, General concepts
@section Emacs user interface
@cindex Emacs, user interface
@cindex Emacs
@cindex interface, Emacs
@cindex user interface, Emacs

Besides running @sc{Singular} in an ASCII-terminal, @sc{Singular} might
also be run within Emacs. Emacs (or, XEmacs which is very similar) is a
powerful and freely available text editor, which, among others,
provides a framework for the implementation of interactive user
interfaces. Starting from version 1.3.6, @sc{Singular} provides such an
implementation, the so-called @sc{Singular} Emacs mode, or Emacs user
interface.

Generally, we recommend to use the Emacs interface,
instead of the ASCII-terminal interface: The Emacs interface does not
only provide everything the ASCII-terminal interface provides, but
offers much more. Among others, it offers
@itemize @bullet
@item
color-highlighting
@item
truncation of long lines
@item
folding of input and output
@item
TAB-completion for help topics
@item
highlighting of matching parentheses
@item
key-bindings and interactive menus for most user interface commands and
for basic @sc{Singular} commands (such as loading of libraries and files)
@item
a mode for running interactive @sc{Singular} demonstrations
@item
convenient ways to edit @sc{Singular} input files
@item
interactive customization of nearly all aspects of the user-interface.
@end itemize

To use the @sc{Singular}-Emacs interface you need to have Emacs version
20 or higher, or XEmacs
version 20.3 or higher installed on your system. These
editors can be downloaded for most hard- and software platforms
(including Windows
95/98/NT, but excluding the Macintosh), from either
@uref{http://www.fsf.org/software/emacs/emacs.html} (Emacs), from
@uref{http://www.xemacs.org} (XEmacs), or from our ftp site at
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils/}. The
differences between Emacs and XEmacs w.r.t. the  @sc{Singular}-Emacs
interface are marginal -- which editor to use is mainly a matter of personal
preferences.

The simplest way to start-up @sc{Singular} in its Emacs interface is by
running the program @code{ESingular} which is contained in the Singular
distribution. Alternatively, @sc{Singular} can be started within an
already running Emacs -- see @ref{Running SINGULAR under Emacs} for
details.

The next section gives  a tutorial-like introduction to Emacs. This
introductory section is
followed by sections which explain the functionality of various aspects
of the Emacs user interface in more detail: how to start/restart/kill
@sc{Singular} within Emacs, how to run an interactive demonstration, how
to customize the Emacs user interface, etc. Finally, the 20 most
important commands of the Emacs interface together with their key
bindings are listed.

@menu
* A quick guide to Emacs::
* Running SINGULAR under Emacs::
* Demo mode::
* Customization of the Emacs interface::
* Editing SINGULAR input files with Emacs::
* Top 20 Emacs commands::
@end menu

@c --------------------------------------------------------------------------
@node A quick guide to Emacs, Running SINGULAR under Emacs, Emacs user interface, Emacs user interface
@subsection A quick guide to Emacs
@cindex Emacs, overview
@cindex Emacs, a quick guide

This section gives a tutorial-like introduction to Emacs. Especially to
users who are not familiar with Emacs, we recommend that they go through
this section and try out the described features.

Emacs commands generally involve the @code{CONTROL} key (sometimes
labeled @code{CTRL} or @code{CTL}) or the @code{META} key.  On some
keyboards, the @code{META} key is labeled @code{ALT} or @code{EDIT} or
something else (for example, on Sun keyboards, the diamond key to the
left of the space-bar is @code{META}).  If there is no @code{META} key,
the @code{ESC} key can be used, instead.  Rather than writing out
@code{META} or
@code{CONTROL} each time we want to prefix a character, we will use the
following abbreviations:

@multitable @columnfractions .2 .8
@item @code{C-<chr>}
@tab means hold the @code{CONTROL} key while typing the character
@code{<chr>}. Thus, @code{C-f} would be: hold the @code{CONTROL} key and
type @code{f}.
@item @code{M-<chr>}
@tab means hold the @code{META} key down while typing @code{<chr>}.  If there
is no @code{META} key, type @key{ESC}, release it, then type the
character @code{<chr>}.
@end multitable

For user new to Emacs, we highly recommend that they go through the
interactive Emacs tutorial: type @code{C-h t} to start it.

For others, it is important to understand the following Emacs concepts:
@table @asis
@item window
In Emacs terminology, a window refers to separate panes within the same
window of the window system, and not to overlapping, separate
windows. When using @sc{Singular} within Emacs, extra windows may appear
which display help or output from certain commands. The most important
window commands are:
@multitable @columnfractions 2. .3 .5
@item @code{C-x 1}
@tab @code{File->Un-Split}
@tab Un-Split window (i.e., kill other windows)
@item @code{C-x o}
@tab
@tab Goto other window, i.e. move cursor into other window.
@end multitable

@item cursor and point
The location of the cursor in the text is also called "point".  To
paraphrase, the cursor shows on the screen where point is located in
the text. Here is a summary of simple cursor-moving operations:
@multitable @columnfractions .2 .8
@item @code{C-f} @tab   Move forward a character
@item @code{C-b} @tab   Move backward a character
@item @code{M-f} @tab   Move forward a word
@item @code{M-b} @tab   Move backward a word
@item @code{C-a} @tab   Move to the beginning of line
@item @code{C-e} @tab   Move to the end of line
@end multitable

@item buffer
Any text you see in an Emacs window is always part of some buffer. For
example, each file you are editing with Emacs is stored inside a buffer,
but also @sc{Singular} is running inside an Emacs buffer. Each buffer
has a name: for example, the buffer of a file you edit usually has the
same name as the file, @sc{Singular} is running in a buffer which has
the name @code{*singular*} (or, @code{*singular<2>*},
@code{*singular<3>*}, etc., if you have multiple @sc{Singular}
sessions within the same Emacs).

When you are asked for input to an Emacs command, the cursor
moves to the bottom line of Emacs, i.e., to a special buffer, called the
"minibuffer". Typing @key{RETURN} within the minibuffer, ends the
input, typing @key{SPACE} within the minibuffer, lists all possible
input values to the interactive Emacs command.

The most important buffer commands are
@multitable @columnfractions .2 .8
@item @code{C-x b} @tab Switch buffer
@item @code{C-x k} @tab Kill current buffer
@end multitable
Alternatively, you can switch to or kill buffers using the @code{Buffer}
menu.

@item Executing commands
Emacs commands are executed by typing @code{M-x <command-name>}
(remember that @key{SPACE} completes partial
command names). Important and frequently used commands have short-cuts
for their execution: Key bindings or even menu entries. For example, a
file can be loaded with @code{M-x load-file}, or @code{C-x C-f}, or with
the @code{File->Open} menu.

@item How to exit
To end the Emacs (and, @sc{Singular}) session,
type @code{C-x C-c} (two characters), or use the @code{File -> Exit}
menu.

@item When Emacs is hung
If Emacs stops responding to your commands, you can stop it safely by
typing @code{C-g}, or, if this fails, by typing @code{C-]}.

@item More help
Nearly all aspects of Emacs are very well documented: type
@code{C-h}  and then a character saying what kind of help you want.
For example, typing @code{C-h i} enters the @code{Info} documentation
browser.

@item Using the mouse
Emacs is fully integrated with the mouse. In particular, clicking the
right mouse button brings up a pop-up menu which usually contains a few
commonly used commands.
@end table

@c --------------------------------------------------------------------------
@node Running SINGULAR under Emacs, Demo mode, A quick guide to Emacs, Emacs user interface
@subsection Running SINGULAR under Emacs
@cindex Emacs, running Singular under
@cindex Singular, running within Emacs
@cindex Running SINGULAR under Emacs

There are two ways to start the @sc{Singular} Emacs interface: Typing
@code{ESingular} instead of @code{Singular} on the command shell
launches a new Emacs process, initializes the interface and runs
@sc{Singular} within Emacs. The other way is to start the interface in
an already running Emacs, by typing @code{M-x singular} inside
Emacs. This initializes the interface and runs @sc{Singular} within
Emacs. Both ways are described in more detail below.

Note: To properly run the Emacs interface, several files are needed
which usually reside in the @code{emacs} subdirectory of your
@sc{Singular} distribution. This directory is called
singular-emacs-home-directory in the following.

@subheading Starting the interface using ESingular

As mentioned above, @code{ESingular} is an "out-of-the-box" solution:
You don't have to add special things to your @code{.emacs} startup file
to initialize the interface; everything is done for you in a special
file called @code{.emacs-singular} (which comes along with the
@sc{Singular} distribution and resides in the
singular-emacs-home-directory) which is automatically loaded on Emacs
startup (and the loading of the @code{.emacs} file is automatically
suppressed).

The customizable variables of the @sc{Singular} Emacs interface are set
to defaults which give the novice user a very shell like
feeling of the interface. Nevertheless, these default settings can be
changed, see @ref{Customization of the Emacs interface}. Besides other
Emacs initializations, such as fontification or blinking parentheses, a
new menu item called @code{Singular} is added to the main menu,
providing menu items for starting @sc{Singular}. On XEmacs, a button
starting @sc{Singular} is added to the main toolbar.

The @sc{Singular} interface is started automatically; once you see a
buffer called @code{*singular*} and the @sc{Singular} prompt you are
ready to start your @sc{Singular} session.

@code{ESingular} inherits all @code{Singular} options. For a description
off all these options, see @ref{Command line options}. Additionally
there are the following options which are special to @code{ESingular}:

@multitable @columnfractions .3 .7

@item command-line option /
@*environment variable
@tab functionality

@item @code{--emacs=EMACS}
@*@code{ESINGULAR_EMACS}
@tab Use @code{EMACS} as Emacs program to run the @sc{Singular} Emacs
interface, where @code{EMACS} may e.g. be emacs or xemacs.

@item @code{--emacs-dir=DIR}
@*@code{ESINGULAR_EMACS_DIR}
@tab Set the singular-emacs-home-directory, which is the directory where
singular.el can be found,  to @code{DIR}.

@item @code{--emacs-load=FILE}
@*@code{ESINGULAR_EMACS_LOAD}
@tab Load @code{FILE} on Emacs start-up, instead of the default load file.

@item @code{--singular=PROG}
@*@code{ESINGULAR_SINGULAR}
@tab Start @code{PROG} as @sc{Singular} program within Emacs

@end multitable

Notice that values of these options can also be given by setting the
above mentioned environment variables (where values  given as
command-line arguments take priority over values given by environment
variables).

@subheading Starting the interface within a running Emacs

If you are a more experienced Emacs user and you already have your own
local @code{.emacs} startup file, you might want to start the interface
out of your running Emacs without using @code{ESingular}. For this, you
should add the following lisp code to your @code{.emacs} file:

@smallexample
(setq load-path (cons "<singular-emacs-home-directory>" load-path))
(autoload 'singular "singular"
  "Start Singular using default values." t)
(autoload 'singular-other "singular"
  "Ask for arguments and start Singular." t)
@end smallexample

Then typing @code{M-x singular} in a running Emacs session initializes
the interface in a new buffer and launches a @sc{Singular} process. The
@sc{Singular} prompt comes up and you are ready to start your
@sc{Singular} session.

It is a good idea to take a look at the (well documented) file
@code{.emacs-singular} in the singular-emacs-home-directory, which comes
along with the distribution. In it you find some useful initializations
of the @sc{Singular} interface as well as some lisp code, which, for
example, adds a button to the XEmacs toolbar. Some of this code might be
useful for your @code{.emacs} file, too. And if you are a Emacs wizard,
it is of course a good idea to take a look at @code{singular.el} in the
singular-emacs-home-directory.

@subheading Starting, interrupting and stopping SINGULAR

There are the following commands to start and stop @sc{Singular}:

@itemize @bullet
@item @code{singular-other} (or menu @code{Singular}, item
@code{Start...})

Starts a @sc{Singular} process and asks for the following four
parameters in the minibuffer area:

@enumerate
@item
The Singular executable. This can either be a file name with complete
path, e.g., @code{/local/bin/Singular}. Then exactly this executable is
started. The path may contain the character @code{~} denoting your home
directory. Or it can be the name of a command without path, e.g.,
@code{Singular}. Then the executable is searched for in your
@code{$PATH} environment variable.

@item
The default working directory. This is the path to an existing
directory, e.g., @code{~/work}. The current directory is set to this
directory before @sc{Singular} is started.

@item
Command line options. You can set any @sc{Singular} command line
option (see @ref{Command line options}).

@item
The buffer name. You can specify the name of the buffer the interface is
running in.

@end enumerate

@item @code{singular} (or menu @code{Singular}, item @code{Start
default})

Starts @sc{Singular} with default settings for the executable, the
working directory, command line switches, and the buffer name. You can
customize this default settings, see
@ref{Customization of the Emacs interface}.

@item @code{singular-exit-singular} (bound to @code{C-c $} or menu
@code{Singular}, item @code{Exit})

Kills the running @sc{Singular} process of the current
buffer (but does not kill the buffer). Once you have killed a
@sc{Singular} process you can start a new one in the same buffer with
the command @code{singular} (or select the item @code{Start default} of
the @code{Singular} menu).

@item @code{singular-restart} (bound to @code{C-c C-r} or menu
@code{Singular}, item @code{Restart})

Kills the running @sc{Singular} process of the current buffer and starts
a new process in the same buffer with exactly the same command line
arguments as before.

@item @code{singular-control-c} (bound to @code{C-c C-c} or menu @code{Singular}, item @code{Interrupt})

Interrupt the Singular process running in the current buffer. Asks
whether to (@code{a})bort the current @sc{Singular} command,
(@code{q})uit or (@code{r})estart the current @sc{Singular} process, or
(@code{c})ontinue without doing anything (default).
@end itemize

Whenever a @sc{Singular} process is started within the Emacs interface,
the contents of a special startup file (by default
@code{~/.emacs-singularrc}) is pasted as input to @sc{Singular} at the
very end of the usual startup sequence (see @ref{Startup sequence}). The
name of the startup file can be changed, see
@ref{Customization of the Emacs interface}.


@c --------------------------------------------------------------------------
@node Demo mode, Customization of the Emacs interface, Running SINGULAR under Emacs, Emacs user interface
@subsection Demo mode
@cindex Emacs, Singular demo mode
@cindex Singular, demo mode
@cindex Demo mode

The Emacs interface can be used to run interactive @sc{Singular}
demonstrations. A demonstration is started by loading a so-called
@sc{Singular} demo file with the Emacs command
@code{singular-demo-load}, bound to
@code{C-c C-d}, or with the menu @code{Commands->Load Demo}.

A @sc{Singular} demo file should consist of @sc{Singular} commands
separated by blank lines. When running a demo, the input up to the next
blank line is echoed to the screen. Hitting @key{RETURN} executes the
echoed commands and shows their output. Hitting @key{RETURN} again,
echos the next commands to the screen, and so on, until all commands of
the demo file are executed. While running a demo, you can
execute other commands on the @sc{Singular} prompt: the next input of
from the demo file is then echoed again, if you hit @key{RETURN} on
an empty input line.

A @sc{Singular} demo can prematurely be exited by either starting
another demo, or by executing the Emacs command
@code{singular-demo-exit} (menu: @code{Commands->Exit Demo}).

Some aspects of running @sc{Singular} demos can be customized.
@xref{Customization of the Emacs interface}, for more info.


@c --------------------------------------------------------------------------
@node Customization of the Emacs interface, Editing SINGULAR input files with Emacs, Demo mode, Emacs user interface
@subsection Customization of the Emacs interface
@cindex Emacs, customization of Singular mode
@cindex Singular, customization of Emacs user interface
@cindex Customization of the Emacs interface

Emacs provides a convenient interface to customize the behavior of
Emacs and the SINGULAR Emacs interface for your own needs. You enter the
customize environment by either calling @code{M-x customize} (on XEmacs
you afterwards have to enter @code{emacs} in the minibuffer area) or by
selecting the menu item @code{Options->Customize->Emacs...} for XEmacs,
and the menu item @code{Help->Customize->Toplevel Customization Group}
for Emacs, resp. A brief introduction to the customization mode comes up
with the customization buffer. All customizable parameters are
hierarchically grouped and you can browse through all these groups and
change the values of the parameters using the mouse. At the end you can
safe the settings to a special file making your changes permanent.

To change the settings of the @sc{Singular} Emacs interface you can
either select the item @code{Preferences} of the @code{Singular} menu,
call @code{M-x customize-group} and give the argument
@code{singular-interactive} in the minibuffer area, or browse from the
top-level customization group through the path
@code{External->Singular->Singular interactive}.

The @sc{Singular} interface customization buffer is divided into four
groups:

@itemize @bullet
@item Singular Faces

Here you can specify various faces used if font-lock-mode is enabled
(which it is, by default).

@item Singular Sections And Foldings

Here you can specify special faces for @sc{Singular} input and output
and change the text used as replacement for folded sections.

For doing this, you also might
find handy the function @code{customize-face-at-point},
which let's you customize the face at the current position of
point. This function is automatically defined if you run
@code{ESingular}). Otherwise, you should add its definition (see below)
to your personal @code{.emacs} file.

@item Singular Interactive Miscellaneous

Here you can specify various different things such as the behavior of
the cursor keys, the name of the special @sc{Singular} startup file, the
appearance of the help window, or the default values for the
@code{singular} command.
@c Time: I find this sentence rather confusing
@c For a first look at customization of the
@c interface, this is probably the best group.


@item Singular Demo Mode

Here you can specify how chunks of the demo file are divided, or specify
a default directory for demo files.
@end itemize

When you run @code{ESingular}, the settings of customized variables are
saved in the file @code{$HOME/.emacs-singular-cust}. Otherwise, the
settings are appended to your @code{.emacs} file. Among others, this
means that the customized settings of @code{ESingular} are not
automatically  taken over by a "normal" Emacs, and vice versa.


@c --------------------------------------------------------------------------
@node Editing SINGULAR input files with Emacs, Top 20 Emacs commands, Customization of the Emacs interface, Emacs user interface
@subsection Editing SINGULAR input files with Emacs
@cindex Emacs, editing Singular input files
@cindex Singular, editing input files with Emacs
@cindex Editing SINGULAR input files with Emacs

Since @sc{Singular}'s programming language is similar to C, you
should use the Emacs C/C++-mode to edit @sc{Singular} input files and
@sc{Singular} libraries. Among others, this Emacs mode provides
automatic indentation, line-breaking and keyword highlighting.

When running @code{ESingular}, the C/C++-mode is automatically turned on
whenever a file with the suffix @code{.sing}, or @code{.lib} is loaded.

For Emacs sessions which were not started by @code{ESingular},  you
should add the following to your @code{.emacs} file:
@smallexample
;; turn on c++-mode for files ending in ".sing" and ".lib"
(setq auto-mode-alist (cons '("\\.sing\\'" . c++-mode) auto-mode-alist))
(setq auto-mode-alist (cons '("\\.lib\\'" .  c++-mode) auto-mode-alist))
;; turn-on fontification for c++-mode
(add-hook 'c++-mode-hook
         (function (lambda () (font-lock-mode 1))))
;; turn on aut-new line and hungry-delete
(add-hook 'c++-mode-hook
          (function (lambda () (c-toggle-auto-hungry-state 1))))
;; a handy function for customization
(defun customize-face-at-point ()
  "Customize face which point is at."
  (interactive)
  (let ((face (get-text-property (point) 'face)))
    (if face
        (customize-face face)
      (message "No face defined at point"))))

@end smallexample

Notice that you can change the default settings for source-code
highlighting (colors, fonts, etc.) by customizing the respective faces
using the @code{Customize} feature of Emacs. For doing this, you might
find handy the above given function @code{customize-face-at-point},
which lets you customize the face of the current position of point (this
function is automatically defined if you run @code{ESingular}).

@c --------------------------------------------------------------------------
@node Top 20 Emacs commands,,Editing SINGULAR input files with Emacs, Emacs user interface
@subsection Top 20 Emacs commands
@cindex Emacs, important commands
@cindex Singular, important commands of Emacs interface
@cindex Top 20 Emacs commands

Here is a list of the 20 probably most useful commands when using the
@sc{Singular} Emacs interface.

Starting and stopping of @sc{Singular}:

@itemize @bullet

@item @code{singular} (menu @code{Singular->Start Default...}): starts
@sc{Singular} using default arguments.

@item @code{singular-other} (menu @code{Singular->Start}): starts
@sc{Singular} asking for several arguments in the minibuffer area.

@item @code{singular-exit} (key @code{C-c $} or menu
@code{Singular->Exit}): kills the @sc{Singular} process running in the
current buffer (but does not kill the buffer).

@item @code{singular-restart} (key @code{C-c C-r} or menu
@code{Singular->Restart}): kills the @sc{Singular} process running in
the current buffer and starts a new @sc{Singular} process with exactly
the same arguments as before.

@end itemize

Editing input and output:

@itemize @bullet

@item @code{singular-beginning-of-line} (key @code{C-a}): moves point to
beginning of line, then skip past the @sc{Singular} prompt, if any.

@item @code{singular-toggle-truncate-lines} (key @code{C-c C-t} or menu
@code{Commands->Truncate lines}): toggles whether long lines should be
truncated or not. If lines are not truncated, the commands
@code{singular-scroll-left} and @code{singular-scroll-right} are useful
to scroll left and right, resp.

@item @code{singular-dynamic-complete} (key @code{TAB}): performs
context specific completion. If point is inside a string, file name
completion is done. If point is at the end of a help command (i.e.,
@code{help} or @code{?}), completion on @sc{Singular} help topics is
done. If point is at the end of an example command (i.e.,
@code{example}), completion is done on @sc{Singular} examples. In all
other cases, completion on @sc{Singular} commands is done.

@c note: add space between Fold/ Unfold to avoid overfull line
@item @code{singular-folding-toggle-fold-latest-output} (key @code{C-c
C-o} or menu @code{Commands->Fold/ Unfold Latest Output}): toggles
folding of the latest output section. If your last @sc{Singular} command
produced a huge output, simply type @code{C-c C-o} and it will be
replaced by a single line.

@item @code{singular-folding-toggle-fold-at-point} (key @code{C-c C-f}
or menu @code{Commands->Fold/Unfold At Point}): toggles folding of the
section the point currently is in.

@item @code{singular-folding-fold-all-output} (menu @code{Commands->Fold
All Output}): folds all @sc{Singular} output, replacing each output
section by a single line.

@item @code{singular-folding-unfold-all-output} (menu
@code{Commands->Unfold All Output}): unfolds all @sc{Singular} output
sections showing their true contents.

@end itemize

Loading of files and @sc{Singular} demo mode:

@itemize @bullet

@item @code{singular-load-library} (key @code{C-c C-l} or menu
@code{Commands->Libraries->other...}): asks for a standard library name
or a library file in the minibuffer (hit @code{TAB} for completion) and
loads the library into @sc{Singular}. The submenu @code{Libraries} of
the @code{Commands} menu also provides a separate menu item for each
standard library.

@item @code{singular-load-file} (key @code{C-c <} or menu
@code{Commands->Load File...}): asks for a file name in the minibuffer
(which is expanded using @code{expand-file-name} if given a prefix
argument) and loads the file into @sc{Singular}.

@item @code{singular-demo-load} (key @code{C-c C-d} or menu
@code{Commands->Load Demo...}): asks for a file name of a @sc{Singular}
demo file in the minibuffer area (hit @code{SPACE} for completion) and
enters the @sc{Singular} demo mode showing the first chunk of the demo.

@item @code{singular-demo-exit} (menu @code{Commands->Exit Demo}):
exits from @sc{Singular} demo mode and cleans up everything that is
left from the demo.

@end itemize

Help and Customization:

@itemize @bullet

@item @code{singular-help} (key @code{C-h C-s} or menu
@code{Singular->Singular Help}): asks for a @sc{Singular} help topic in
the minibuffer (hit @code{TAB} for completion) and shows the help text
in a separate buffer.

@item @code{singular-example} (key @code{C-c C-e} or menu
@code{Singular->Singular Example}): asks for a @sc{Singular} command in
the minibuffer (hit @code{TAB} for completion) and executes the example
of this command in the current @sc{Singular} buffer.

@item @code{customize-group} (menu @code{Singular->Preferences}): enters
the customization group of the @sc{Singular} Emacs interface. (If called
via @code{M-x customize-group} give argument @code{singular-interactive}
in the minibuffer area.)

@end itemize


@c ---------------------------------------------------------------------------
@c ---------------------------------------------------------------------------
@node Rings and orderings, Implemented algorithms, Emacs user interface, General concepts
@section Rings and orderings
@cindex Rings and orderings

All non-trivial algorithms in @sc{Singular} require the prior definition of
a ring. Such a ring can be

@enumerate
@item
a polynomial ring over a field,
@item
a localization of a polynomial ring,
@item
a quotient ring by an ideal of one of 1.@: or 2.,
@item
a tensor product of one of 1.@: or 2.
@end enumerate

Except for quotient rings, all of these rings are realized by choosing a
coefficient field, ring variables, and an appropriate global or local
monomial ordering on the ring variables.  @xref{Term orderings},
@ref{Mathematical background}.

The coefficient field of the rings may be

@cindex real
@cindex complex
@enumerate
@item
the field of rational numbers 
@math{Q}
@tex
$Q$
@end tex
,
@item
@tex
finite fields $Z/p$, $p$ a prime $\le 2147483629$,
@end tex
finite fields Z/p, p a prime <= 2147483629,
@item
@tex
finite fields $\hbox{GF}(p^n)$ with $p^n$ elements, $p$ a prime, $p^n \le 2^{15}$,
@end tex
finite fields GF(p^n) with p^n elements, p a prime, p^n <= 2^15,
@item
transcendental extension of 
@math{Q}
@tex
$Q$
@end tex
 or 
@math{Z/p}
@tex
$Z/p$
@end tex
,
@item
simple algebraic extension of 
@math{Q}
@tex
$Q$
@end tex
 or 
@math{Z/p}
@tex
$Z/p$
@end tex
,
@item
the field of real numbers represented by floating point
numbers of a user defined precision.
@item
the field of complex numbers represented by (pairs of) floating point
numbers of a user defined precision.
@end enumerate

Throughout this manual, the current active ring in @sc{Singular} is
called basering.  The reserved name @code{basering} in @sc{Singular} is
an alias for the current active ring.  The basering can be set by
declaring a new ring as described in the following subsections or with
the commands @code{setring} and @code{keepring}.  @xref{keepring},
@ref{setring}.

Objects of ring dependent types are local to a ring. To access them
after a change of the basering they have to be mapped using @code{map} or by
the functions @code{imap} or @code{fetch}.  @xref{Objects}, @ref{fetch},
@ref{imap}, @ref{map}.

All changes of the basering in a procedure are local to this procedure
unless a @code{keepring} command is used as the last statement of the
procedure.  @xref{Procedures}, @ref{keepring}.

@menu
* Examples of ring declarations::
* General syntax of a ring declaration::
* Term orderings::
@end menu

@c --------------------------------------
@node Examples of ring declarations, General syntax of a ring declaration, Rings and orderings, Rings and orderings
@subsection Examples of ring declarations
@cindex Examples of ring declarations

The exact syntax of a ring declaration is given in the next two
subsections; this subsection lists some examples first. Note that the
ordering has to be chosen such that the unit-elements of the
ring are precisely those elements with leading monomial 1.  For more
information, see @ref{Monomial orderings}.

Every floating point number in a ring consists of two parts, which may be
chosen from the user. The leading part represents the number and the rest
is for the numerical stability. Two numbers with a difference only in the
rest are equal.

@itemize @bullet
@item
the ring 
@math{Z/32003[x,y,z]}
@tex
$Z/32003[x,y,z]$
@end tex
 with degree reverse lexicographical
ordering.  The exact ring declaration may be omitted in the first
example since this is the default ring:

@smallexample
ring r;
ring r = 32003,(x,y,z),dp;
@end smallexample

@item
the ring 
@math{Q[a,b,c,d]}
@tex
$Q[a,b,c,d]$
@end tex
 with lexicographical ordering:

@smallexample
ring r = 0,(a,b,c,d),lp;
@end smallexample

@item
the ring 
@math{Z/7[x,y,z]}
@tex
$Z/7[x,y,z]$
@end tex
 with local degree reverse lexicographical
ordering.  The non-prime 10 is converted to the next lower prime in the
second example:

@smallexample
ring r = 7,(x,y,z),ds;
ring r = 10,(x,y,z),ds;
@end smallexample

@item
the ring
@tex
$Z/7[x_1,\ldots,x_6]$
@end tex
Z/7[x1,@dots{},x6]
with lexicographical ordering for
@tex
$x_1,x_2,x_3$
@end tex
x1,x2,x3
and degree reverse lexicographical ordering for
@tex
$x_4,x_5,x_6$:
@end tex
x4,x5,x6:

@smallexample
ring r = 7,(x(1..6)),(lp(3),dp);
@end smallexample

@item
the localization of 
@math{(Q[a,b,c])[x,y,z]}
@tex
$(Q[a,b,c])[x,y,z]$
@end tex
 at the maximal ideal

@math{(x,y,z)}
@tex
$(x,y,z)$
@end tex
:

@smallexample
ring r = 0,(x,y,z,a,b,c),(ds(3), dp(3));
@end smallexample

@item
the ring 
@math{Q[x,y,z]}
@tex
$Q[x,y,z]$
@end tex
 with weighted reverse lexicographical ordering.
The variables 
@math{x}
@tex
$x$
@end tex
, 
@math{y}
@tex
$y$
@end tex
, and 
@math{z}
@tex
$z$
@end tex
 have the weights 2, 1,
and 3, respectively, and  vectors are first ordered by components (in
descending order) and then by monomials:
@smallexample
ring r = 0,(x,y,z),(c,wp(2,1,3));
@end smallexample
For ascending component order, the component ordering @code{C} has to be
used.

@item
the ring 
@math{K[x,y,z]}
@tex
$K[x,y,z]$
@end tex
, where 
@math{K=Z/7(a,b,c)}
@tex
$K=Z/7(a,b,c)$
@end tex
 denotes the transcendental
extension of 
@math{Z/7}
@tex
$Z/7$
@end tex
 by 
@math{a}
@tex
$a$
@end tex
, 
@math{b}
@tex
$b$
@end tex
 and 
@math{c}
@tex
$c$
@end tex
 with degree
lexicographical ordering:

@smallexample
ring r = (7,a,b,c),(x,y,z),Dp;
@end smallexample

@item
the ring 
@math{K[x,y,z]}
@tex
$K[x,y,z]$
@end tex
, where 
@math{K=Z/7[a]}
@tex
$K=Z/7[a]$
@end tex
 denotes the algebraic extension of
degree 2 of 
@math{Z/7}
@tex
$Z/7$
@end tex
 by 
@math{a.}
@tex
$a.$
@end tex
 In other words, 
@math{K}
@tex
$K$
@end tex
 is the finite field with
49 elements.  In the first case, 
@math{a}
@tex
$a$
@end tex
 denotes an algebraic
element over 
@math{Z/7}
@tex
$Z/7$
@end tex
 with minimal polynomial
@tex
$\mu_a=a^2+a+3$,
@end tex
mu_a=a^2+a+3,
in the second case, 
@math{a}
@tex
$a$
@end tex

refers to some generator of the cyclic group of units of 
@math{K}
@tex
$K$
@end tex
:

@smallexample
ring r = (7,a),(x,y,z),dp; minpoly = a^2+a+3;
ring r = (7^2,a),(x,y,z),dp;
@end smallexample

@item
the ring 
@math{R[x,y,z]}
@tex
$R[x,y,z]$
@end tex
, where 
@math{R}
@tex
$R$
@end tex
 denotes the field of real
numbers represented by simple precision floating point numbers. This is
a special case:

@smallexample
ring r = real,(x,y,z),dp;
@end smallexample

@item
the ring 
@math{R[x,y,z]}
@tex
$R[x,y,z]$
@end tex
, where 
@math{R}
@tex
$R$
@end tex
 denotes the field of real
numbers represented by floating point numbers of 50 valid decimal digits
and the same number of digits for the rest:

@smallexample
ring r = (real,50),(x,y,z),dp;
@end smallexample

@item
the ring 
@math{R[x,y,z]}
@tex
$R[x,y,z]$
@end tex
, where 
@math{R}
@tex
$R$
@end tex
 denotes the field of real
numbers represented by floating point numbers of 10 valid decimal digits
and with 50 digits for the rest:

@smallexample
ring r = (real,10,50),(x,y,z),dp;
@end smallexample

@item
the ring 
@math{R(j)[x,y,z]}
@tex
$R(j)[x,y,z]$
@end tex
, where 
@math{R}
@tex
$R$
@end tex
 denotes the field of real
numbers represented by floating point numbers of 30 valid decimal digits
and the same number for the rest. 
@math{j}
@tex
$j$
@end tex
 denotes the imaginary unit.

@smallexample
ring r = (complex,30,j),(x,y,z),dp;
@end smallexample

@item
the ring 
@math{R(i)[x,y,z]}
@tex
$R(i)[x,y,z]$
@end tex
, where 
@math{R}
@tex
$R$
@end tex
 denotes the field of real
numbers represented by floating point numbers of 6 valid decimal digits
and the same number for the rest. 
@math{i}
@tex
$i$
@end tex
 is the default for the imaginary unit.

@smallexample
ring r = complex,(x,y,z),dp;
@end smallexample

@item
the quotient ring 
@math{Z/7[x,y,z]}
@tex
$Z/7[x,y,z]$
@end tex
 modulo the square of the maximal
ideal 
@math{(x,y,z)}
@tex
$(x,y,z)$
@end tex
:

@smallexample
ring R = 7,(x,y,z), dp;
qring r = std(maxideal(2));
@end smallexample
@end itemize

@c ---------------------------------------------------------------------------
@node General syntax of a ring declaration, Term orderings, Examples of ring declarations, Rings and orderings
@subsection General syntax of a ring declaration
@cindex General syntax of a ring declaration

@subsubheading Rings
@c ------------------------------------------------------------
@c   This piece of text (partially) exists also in the
@c   file types.doc, chapter "ring declarations".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
@table @strong
@item Syntax:
@code{ring} name @code{=} @code{(}coefficient_field@code{),}
  @code{(} names_of_ring_variables @code{),}
  @code{(} ordering @code{);}
@item Default:
@code{32003,(x,y,z),(dp,C);}
@item Purpose:
declares a ring and sets it as the current basering.
@end table

The coefficient_field is given by one of the following:
@enumerate
@item
a non-negative int_expression less or equal 32003.
@* The int_expression should either be 0, specifying the field of
rational numbers Q, or a prime number p, specifying the finite field
with p elements.  If it is not a prime number, int_expression is
converted to the next lower prime number.

@item
an expression_list of an int_expression and one or more names.
@* The int_expression specifies the characteristic of the coefficient
field as described above. The names are used as parameters in
transcendental or algebraic extensions of the coefficient
field. Algebraic extensions are implemented for one parameter only. In
this case, a minimal polynomial has to be defined by assignment to
@code{minpoly}. @xref{minpoly}.

@item
an expression_list of an int_expression and a name.
@* The int_expression has to be a prime number p to the power of a
positive integer n. This defines the Galois field
@tex
$\hbox{GF}(p^n)$ with $p^n$ elements, where $p^n$ has to be smaller or equal $2^{15}$.
@end tex
GF(p^n) with p^n elements, where p^n has to be smaller or equal 2^15.
The given name refers to a primitive element of
@tex
$\hbox{GF}(p^n)$
@end tex
GF(p^n)
generating the multiplicative group.  Due to a different internal
representation, the arithmetic operations in these coefficient fields
are faster than arithmetic operations in algebraic extensions as
described above.

@item
an expression_list of the name @code{real} and two optional int_expression
giving the precision in decimal digits and
the size for the stabilizing rest. The default for the rest is the same size
as for the representation.
An exception is the name @code{real} without any integers.
These numbers are implemented as machine floating point numbers
of single precision.
Note that computations over all these fields are not exact.

@item
an expression_list of the name @code{complex},
two optional int_expression and a name.
This specifies the field of complex numbers represented with floating point
numbers with a precision similar to @code{real}. An expression_list
without int_expression defines a precision and rest with length 6.
The name of the imaginary unit is given by the last parameter.
Note that computations over these fields are not exact.
@end enumerate

'names_of_ring_variables' is a list of names or indexed names.

'ordering' is a list of block orderings where each block ordering is either

@enumerate
@item
@code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, or @code{Ds}
optionally followed by a size parameter in parentheses.

@item
@code{wp}, @code{Wp}, @code{ws}, @code{Ws}, or @code{a} followed by a
weight vector given as an intvec_expression in parentheses.

@item
@code{M} followed by an intmat_expression in parentheses.

@item
@code{c} or @code{C}.
@end enumerate

For the definition of the orderings, see @ref{Monomial orderings}.

If one of coefficient_field, names_of_ring_variables, and ordering
consists of only one entry, the parentheses around this entry may be
omitted.
@c ------------------------------------------------------------
@c   End of duplicate piece of text.
@c ------------------------------------------------------------

@subsubheading Quotient rings
@c ------------------------------------------------------------
@c   This piece of text (partially) exists also in the
@c   file types.doc, chapter "qring declarations", and in
@c   singular.doc, chapter "Miscellaneous oddities".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
@table @strong
@item Syntax:
@code{qring} name @code{=} ideal_expression @code{;}
@item Default:
none
@item Purpose:
declares a quotient ring as the basering modulo ideal_expression.  Sets
it as current basering.
@end table

ideal_expression has to be represented by a standard basis.

The most convenient way to map objects from a ring to its quotient ring
and vice versa is to use the @code{fetch} function (@pxref{fetch}).

@sc{Singular} computes in a quotient ring as long as possible with the
given representative of a polynomial, say, @code{f}.  I.e., it usually
does not reduce @code{f} w.r.t. the quotient ideal.  This is only done
when necessary
during standard bases computations or by an explicit reduction using
the command @code{reduce(f, std(0))} (@pxref{reduce}).

@strong{Example:}
@smallexample
@c computed example Quotient_rings general.doc:1784 
  ring r=32003,(x,y),dp;
  poly f=x3+yx2+3y+4;
  qring q=std(maxideal(2));
  basering;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 2
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering C
@expansion{} // quotient ring from ideal
@expansion{} _[1]=y2
@expansion{} _[2]=xy
@expansion{} _[3]=x2
  poly g=fetch(r, f);
  g;
@expansion{} x3+x2y+3y+4
  reduce(g,std(0));
@expansion{} 3y+4
@c end example Quotient_rings general.doc:1784
@end smallexample

@c ------------------------------------------------------------
@c   End of duplicate piece of text.
@c ------------------------------------------------------------

@c ---------------------------------------------------------------------------
@node Term orderings,  , General syntax of a ring declaration, Rings and orderings
@subsection Term orderings
@cindex Monomial orderings, Term orderings

Any polynomial (resp.@: vector) in @sc{Singular} is ordered w.r.t. a
term ordering (or, monomial ordering), which has to be specified
together with the declaration of a ring. @sc{Singular} stores and
displays a polynomial (resp.@: vector) w.r.t. this ordering, i.e., the
greatest monomial (also called the leading monomial) is the first one
appearing in the output polynomial, and the smallest monomial is the last one.

@strong{Remark:} The novice user should generally use the ordering
@code{dp} for computations in the polynomial ring
@tex
$K[x_1,\ldots,x_n]$,
@end tex
K[x1,...,xn],
resp.@:  @code{ds} for computations in the localization
@tex
$\hbox{Loc}_{(x)}K[x_1,\ldots,x_n])$.
@end tex
Loc_(x)K[x1,...,xn]).
For more details, see @ref{Polynomial data}.

In a ring declaration, @sc{Singular} offers the following orderings:
@enumerate
@item Global orderings
@table @asis
@item @code{lp}
lexicographical ordering

@item @code{dp}
degree reverse lexicographical ordering

@item @code{Dp}
degree lexicographical ordering

@item @code{wp(} intvec_expression @code{)}
weighted reverse lexicographical ordering; the weight vector may
consist of positive integers only.

@item @code{Wp(} intvec_expression @code{)}
weighted lexicographical ordering; the weight vector may consist of
positive integers only.
@end table

Global orderings are well-orderings, i.e., 
@math{1 < x}
@tex
$1 < x$
@end tex
 for each ring
variable 
@math{x}
@tex
$x$
@end tex
. They are denoted by a @code{p} as the second
character in their name.

@item Local orderings
@table @asis
@item @code{ls}
negative lexicographical ordering

@item @code{ds}
negative degree reverse lexicographical ordering

@item @code{Ds}
negative degree lexicographical ordering

@item @code{ws(} intvec_expression @code{)}
(general) weighted reverse lexicographical ordering; the first element
of the weight vector has to be non-zero.

@item @code{Ws(} intvec_expression @code{)}
(general) weighted lexicographical ordering; the first element
of the weight vector has to be non-zero.
@end table

Local orderings are not well-orderings. They are denoted by an @code{s}
as the second character in their name.

@item Matrix orderings
@table @asis
@item @code{M(} intmat_expression @code{)}
intmat_expression has to be an invertible square matrix
@end table

Using matrix orderings, @sc{Singular} can compute standard bases
w.r.t.@: any monomial ordering that is compatible with the natural
semi-group structure on the monomials. In practice, the predefined global
and local orderings together with the block orderings should be
sufficient in most cases. These orderings are faster than their
corresponding matrix orderings since evaluation of a matrix ordering is
time consuming.

@item Extra weight vector
@table @asis
@item @code{a(} intvec_expression @code{)}
an extra weight vector @code{a(} intvec_expression @code{)} may precede
any monomial ordering
@end table

@item Product ordering
@table @asis
@item @code{(} ordering [ @code{(} int_expression @code{)} ]@code{,} @dots{} @code{)}
any of the above orderings and the extra weight vector may be combined
to yield product or block orderings
@end table

The orderings @code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, and
@code{Ds} may be followed by an int_expression in parentheses giving the
size of the block. For the last block the size is calculated
automatically. For the weighted orderings the size of the block is given
by the size of the weight vector. The same holds analogously for matrix
orderings.

@item Module orderings
@table @asis
@itemx @code{(} ordering@code{,} @dots{}@code{, C )}
@item @code{(} ordering@code{,} @dots{}@code{, c )}
sort polynomial vectors by the monomial ordering first, then by
components

@itemx @code{( C,} ordering@code{,} @dots{} @code{)}
@item @code{( c,} ordering@code{,} @dots{} @code{)}
sort polynomial vectors by components first, then by the monomial
ordering
@end table

Here a capital @code{C} sorts generators in ascending order, i.e.,
@code{gen(1)} < @code{gen(2)} < @enddots{} A small @code{c} sorts in
descending order, i.e., @code{gen(1)} > @code{gen(2)} > @enddots{} It is
not necessary to specify the module ordering explicitly since @code{(}
ordering@code{,} @dots{}@code{, C )} is the default.

In fact, @code{c} or @code{C} may be specified anywhere in a product
ordering specification, not only at its beginning or end.  All monomial
block orderings preceding the component ordering have higher precedence,
all monomial block orderings following after it have lower precedence.
@end enumerate

For a mathematical description of these orderings, see
@ref{Polynomial data}.

@c ---------------------------------------------------------------------------
@node Implemented algorithms, The SINGULAR language, Rings and orderings, General concepts
@section Implemented algorithms
@cindex Implemented algorithms

The basic algorithm in @sc{Singular} is a general standard basis algorithm for
any monomial ordering which is compatible with the natural semi-group
structure of the exponents. This includes well-orderings
(Buchberger algorithm to compute a Groebner basis)
and tangent cone orderings (Mora algorithm) as special cases.

Nonetheless, there are a lot of other important algorithms:
@itemize @bullet

@item
Algorithms to compute the standard operations on ideals and modules:
intersection, ideal quotient, elimination, etc.

@item
Different Syzygy algorithms and algorithms to compute free resolutions
of modules.

@item
Combinatorial algorithms to compute dimensions, Hilbert series,
multiplicities, etc.

@item
Algorithms for univariate and multivariate polynomial factorization,
resultant and gcd computations.
@end itemize

@c ----------------------------------------------------------------------
@subheading Commands to compute standard bases
@table @code
@item facstd
@ref{facstd}
@*computes a list of Groebner bases via the Factorizing Groebner Basis
Algorithm, i.e., their intersection has the same radical as the original ideal. It need not
be a Groebner basis of the given ideal.

The intersection of the zero-sets is the zero-set of the given ideal.
@item fglm
@ref{fglm}
@*computes a Groebner basis provided that a reduced Groebner basis
w.r.t.@: another ordering is given.

Implements the so-called FGLM (Faugere, Gianni, Lazard, Mora) algorithm.
The given ideal must be zero-dimensional.
@item groebner
@ref{groebner}@*
computes a standard resp.@: Groebner bases using a heuristically chosen
method.

This is the preferred method to compute a standard resp.@: Groebner
bases.
@item mstd
@ref{mstd}
@*computes a standard basis and a minimal set of generators.
@item std
@ref{std}
@*computes a standard resp.@: Groebner basis.
@item stdfglm
@ref{stdfglm}
@*computes a Groebner basis in a ring with a ``difficult'' ordering
(e.g., lexicographical) via @code{std} w.r.t.@: a ``simple'' ordering and
@code{fglm}.

The given ideal must be zero-dimensional.
@item stdhilb
@ref{stdhilb}@*
computes a Groebner basis in a ring with a ``difficult'' ordering
(e.g., lexicographical) via @code{std} w.r.t.@: a ``simple'' ordering
and a @code{std} computation guided by the Hilbert series.
@end table

@c ----------------------------------------------------------------------
@subheading Further processing of standard bases
The next commands require the input to be a standard basis.

@table @code
@item degree
@ref{degree}
@*computes the (Krull) dimension, codimension and the multiplicity.

The result is only displayed on the screen.
@item dim
@ref{dim}@*
computes the dimension of the ideal resp.@: module.
@item highcorner
@ref{highcorner}@*
computes the smallest monomial not contained in the ideal resp.@: module.
The ideal resp.@: module has to be finite dimensional as a vector space
over the ground field.
@item hilb
@ref{hilb}@*
computes the first, and resp.@: or, second Hilbert series of an ideal
resp.@: module.
@item kbase
@ref{kbase}@* computes a vector space basis (consisting of monomials) of
the quotient of a ring by an ideal resp.@: of a free module by a
submodule.

The ideal resp.@: module has to be finite dimensional as a vector space
over the ground field and has to be represented by a standard basis w.r.t.@:
the ring ordering.
@item mult
@ref{mult}@*
computes the degree of the monomial ideal resp.@: module generated by
the leading monomials of the input.
@item reduce
@ref{reduce}@*
reduces a polynomial, vector, ideal or module to its normal form with
respect to an ideal or module represented by a standard basis.
@item vdim
@ref{vdim}@*
computes the vector space dimension of a ring (resp.@: free module)
modulo an ideal (resp.@: module).
@end table

@c ----------------------------------------------------------------------
@subheading Commands to compute resolutions
@table @code
@item res
@ref{res}@*
computes a free resolution of an ideal or module using a heuristically
chosen method.
This is the preferred method to compute free resolutions of ideals or
modules.
@item lres
@ref{lres}@*
computes a free resolution of an ideal or module with La Scala's
method. The input needs to be homogeneous.
@item mres
@ref{mres}@*
computes a minimal free resolution of an ideal or module with the Syzygy
method.
@item sres
@ref{sres}@*
computes a free resolution of an ideal or module with Schreyer's
method. The input has to be a standard basis.
@item nres
@ref{nres}@*
computes a free resolution of an ideal or module with the standard basis
method.
@item syz
@ref{syz}@*
computes the first Syzygy (i.e., the module of relations of the
given generators).
@end table

@c ----------------------------------------------------------------------
@subheading Further processing of resolutions
@table @code
@item betti
@ref{betti}@*
computes the graded Betti numbers of a module from a free resolution.
@item minres
@ref{minres}@*
minimizes a free resolution of an ideal or module.
@item regularity
@ref{regularity}@*
computes the regularity of a homogeneous ideal resp.@: module from a given
minimal free resolution.
@end table

@c ----------------------------------------------------------------------
@subheading Processing of polynomials
@table @code
@item char_series
@ref{char_series}@*
computes characteristic sets of polynomial ideals.
@item extgcd
@ref{extgcd}@*
computes the extended gcd of two polynomials.

Implemented as extended Euclidean Algorithm.  Applicable for univariate
polynomials only.
@item factorize
@ref{factorize}@*
computes factorization of univariate and multivariate polynomials into
irreducible factors.

The most basic algorithm is univariate factorization in prime
characteristic.  The Cantor-Zassenhaus Algorithm is used in this case.
For characteristic 0, a univariate Hensel-lifting is done to lift from
prime characteristic to characteristic 0.  For multivariate
factorization in any characteristic, the problem is reduced to the
univariate case first, then a multivariate Hensel-lifting is used to
lift the univariate factorization.

Note that there is no factorization of polynomials over algebraic
extensions of Q.
@item gcd
@ref{gcd}@*
computes greatest common divisors of univariate and multivariate polynomials.

For prime characteristic, a subresultant gcd is used.  In characteristic 0, a
modular algorithm is used for the univariate case.  For the multivariate case,
the EZGCD is used.

Note that there is no gcd calculation for polynomials over algebraic
extensions of Q.
@item resultant
@ref{resultant}@*
computes the resultant of two univariate polynomials using the subresultant
algorithm.

Multivariate polynomials are considered as univariate polynomials in the
main variable (which has to be specified by the user).
@item vandermonde
@ref{vandermonde}@*
interpolates a polynomial from its values at several points
@end table

@c ----------------------------------------------------------------------
@subheading Matrix computations
@table @code
@item bareiss
@ref{bareiss}@*
implements sparse Gauss-Bareiss method for elimination (matrix
triangularization) in arbitrary integral domains.
@item det
@ref{det}@*
computes the determinant of a square matrix.

For matrices with integer entries a modular algorithm is used.  For
other domains the Gauss-Bareiss method is used.
@item minor
@ref{minor}@*
computes all minors (=subdeterminants) of a given size for a matrix.
@end table

@c ----------------------------------------------------------------------
@subheading Numeric computations
@table @code
@item laguerre
@ref{laguerre}@*
computes all (complex) roots of a univariate polynomial
@item uressolve
@ref{uressolve}@*
find all roots of 0-dimensional ideal i with multivariate resultants
@end table

@c ----------------------------------------------------------------------
@subheading Controlling computations
@table @code
@item option
@ref{option}@*
allows setting of options for manipulating the behavior of computations
(such as reduction strategies) and for showing protocol information indicating
the progress of a computation.
@end table

@c ---------------------------------------------------------------------------
@node The SINGULAR language, Input and output, Implemented algorithms, General concepts
@section The SINGULAR language
@cindex The SINGULAR language

@sc{Singular} interprets commands given interactively on the command
line as well as given in the context of user-defined procedures.  In
fact, @sc{Singular} makes no distinction between these two cases.
Thus, @sc{Singular} offers a powerful programming language as well as
an easy-to-use command line interface without differences in syntax or
semantics.

In the following, the basic language concepts such as commands,
expressions, names, objects, etc., are discussed.  @xref{Procedures},
and @ref{Libraries},
for the concepts of procedures
and libraries.

In many aspects, the @sc{Singular} language is similar to the C
programming language.  For a description of some of the subtle
differences, see @ref{Major differences to the C programming language}.

@subsubheading Elements of the language

The major building blocks of the @sc{Singular} language  are
expressions, commands, and control structures.  The notion of expressions
in the @sc{Singular} and the C programming language are identical,
whereas the notion of commands and control structures only roughly
corresponds to the C statements.

@itemize @bullet

@item
An ``expression'' is a sequence of operators, functions, and operands
that specifies a computation.  An expression always results in a
value of a specific type.  @xref{Data types}, and its subsections (e.g.,
@ref{poly expressions}), for information on how to build expressions.

@item
A ``command'' is either a declaration, an assignment, a call to a
function without return value, or a print command.  For detailed
information, see @ref{General command syntax}.

@item
``Control structures'' determine the execution sequence of commands.
@sc{Singular} provides control structures for conditional execution
(@code{if} @dots{} @code{else}) and iteration (@code{for} and
@code{while}).  Commands may be grouped in pairs of @code{@{} @code{@}}
(curly brackets) to form blocks.  @xref{Control structures}, for
more information.
@end itemize

@subsubheading Other notational conventions
For user-defined functions, the notion of ``procedure'' and
``function'' are synonymous.

As already mentioned above, functions without return values are called
commands.  Furthermore, whenever convenient, the term ``command'' is
used for a function, even if it does return a value.

@menu
* General command syntax::
* Special characters::
* Names::
* Objects::
* Type conversion and casting::
* Flow control::
@end menu

@c ---------------------------------------------------------------------------
@node General command syntax, Special characters, The SINGULAR language, The SINGULAR language
@subsection General command syntax
@cindex General command syntax

In @sc{Singular} a command is either a declaration, an assignment, a
call to a function without return value, or a print command. The general
form of a command is described in the following subsections.

@subsubheading Declaration
@enumerate
@item type name @code{=} expression @code{;}
@* declares a variable with the given name of the given type and assigns
the expression as initial value to it.  Expression is an expression of
the specified type or one that can be converted to that type.
@xref{Type conversion and casting}.

@item type name_list @code{=} expression_list @code{;}
@* declares variables with the given names and assigns successively each
expression of expression_list to the corresponding name of
name_list.  Both lists must be of the same length.  Each expression in
expression_list is an expression of the specified type or one that can
be converted to that type.  @xref{Type conversion and casting}.

@item type name @code{;}
@* declares a variable with the given name of the given type and assigns
the default value of the specific type to it.
@end enumerate

@xref{Names}, for more information on declarations.  @xref{Data types},
for a description of all data types known to @sc{Singular}.

@smallexample
ring r;                   // the default ring
poly f,g = x^2+y^3,xy+z2; // the polynomials f=x^2+y^3 and g=x*y+z^2
ideal I = f,g;            // the ideal generated by f and g
matrix m[3][3];           // a 3 x 3 zero matrix
int i=2;                  // the integer i=2
@end smallexample

@subsubheading Assignment
@enumerate 4
@item
name @code{=} expression @code{;}
@* assigns expression to name.

@item
name_list @code{=} expression_list @code{;}
@* assigns successively each expression of expression_list to the
corresponding name of name_list. Both lists must be of the same
length.  This is not a simultaneous assignment.  Thus, @code{f, g = g, f;} does
not swap the values of @code{f} and @code{g}, but rather assigns
@code{g} to both @code{f} and @code{g}.
@end enumerate

There must be a type conversion of the type of expression to the type of
name. @xref{Type conversion and casting}.

An assignment itself does not yield a value. Hence, compound assignments
like @code{i = j = k;} are not allowed and result in an error.

@smallexample
f = x^2 + y^2 ;      // overwrites the old value of f
I = jacob(f);
f,g = I[1],x^2+y^2 ; // overwrites the old values of f and g
@end smallexample

@subsubheading Function without return value
@enumerate 6
@item
function_name [ @code{(} argument_list @code{)} ] @code{;}
@* calls function function_name with arguments argument_list.
@end enumerate

The function may have output (not to be confused with a return value of
type string). @xref{Functions}. Functions without a return value are
specified there to have a return type 'none'.

Some of these functions have to be called without parentheses, e.g.,
@code{help}, @code{LIB}.

@smallexample
@c computed example Function_without_return_value general.doc:2344 
  ring r;
  ideal i=x2+y2,x;
  i=std(i);
  degree(i);        // degree has no return value but prints output
@expansion{} 2
@c end example Function_without_return_value general.doc:2344
@end smallexample

@subsubheading Print command
@enumerate 7
@item
expression @code{;}
@* prints the value of an expression, for example, of a variable.
@end enumerate

Use the function @code{print} (or the procedure show from inout.lib)
to get a pretty output of various data
types, e.g., matrix or intmat. @xref{print}.

@smallexample
@c computed example Print_command general.doc:2364 
  int i=2;
  i;
@expansion{} 2
  intmat m[2][2]=1,7,10,0;
  print(m);
@expansion{}      1     7
@expansion{}     10     0
@c end example Print_command general.doc:2364
@end smallexample

@c ------------------------------------------------------------
@node Special characters, Names, General command syntax, The SINGULAR language
@subsection Special characters
@cindex Special characters
The following characters and operators have special meaning:
@table @asis
@item @code{=}
@cindex =
assignment
@item @code{(}, @code{)}
@cindex (
@cindex )
@cindex indexed names
in expressions, for indexed names and for argument lists
@item @code{[}, @code{]}
@cindex [
@cindex ]
access operator for strings, integer vectors, ideals, matrices,
polynomials, resolutions, and lists.  Used to build vectors of
polynomials.  Example: @code{s[3]}, @code{m[1,3]}, @code{i[1..3]},
@code{[f,g+x,0,0,1]}.
@item @code{+}
@cindex +
addition operator
@item @code{-}
@cindex -
subtraction operator
@item @code{*}
@cindex *
multiplication operator
@item @code{/}
@cindex /
division  operator.  @xref{Miscellaneous oddities}, for the difference
between the division operators @code{/} and @code{div}.
@item @code{%}
@cindex %
modulo operator
@item @code{^} or @code{**}
@cindex ^
@cindex **
exponentiation operator
@item @code{==}
@cindex ==
comparison operator equal
@item @code{!=} or @code{<>}
@cindex !=
@cindex <>
comparison operator not equal
@item @code{>=}
@cindex >=
comparison operator bigger or equal
@item @code{>}
@cindex >
comparison operator bigger
@item @code{<=}
@cindex <=
comparison operator smaller or equal
@item @code{<}
@cindex <
comparison operator smaller.  Also used for file input.  @xref{filecmd}.
@item @code{!}
@cindex !
boolean operator not
@item @code{&&}
@cindex &&
boolean operator and
@item @code{||}
@cindex ||
boolean operator or
@item @code{"}
@cindex "
delimiter for string constants
@item @code{`}
@cindex `
delimiter for name substitution
@item @code{?}
@cindex ?
synonym for @code{help}
@item @code{//}
@cindex //
comment delimiter.  Comment extends to end of line.
@item @code{/*}
@cindex //
comment delimiter.  Starts a comment which ends with @code{*/}.
@item @code{*/}
@cindex //
comment delimiter.  Ends a comment which starts with @code{/*}.
@item @code{;}
@cindex ;
statement separator
@item @code{,}
separator for expression lists and function arguments
@item @code{\}
@cindex \
escape character for @code{"} and @code{\} within strings
@item @code{..}
@cindex ..
interval specifier returning intvec.
E.g., @code{1..3} which is equivalent to the intvec @code{1, 2, 3}.
@item @code{_}
@cindex _
value of expression last displayed
@item @code{~}
@cindex ~
breakpoint in procedures
@item @code{#}
@cindex #
list of parameters in procedures without explicit parameter list
@item @code{$}
@cindex $
terminates @sc{Singular}
@end table

@c ------------------------------------------------------------
@node Names, Objects, Special characters, The SINGULAR language
@subsection Names
@cindex Names
@cindex Identifiers, syntax of

@sc{Singular} is a strongly typed language.  This means that all names
(= identifiers) have to be declared prior to their use.  For the general
syntax of a declaration, see the description of declaration commands
(@pxref{General command syntax}).

@xref{Data types}, for a description of @sc{Singular}'s data types.
@xref{typeof}, for a short overview of possible types.  To get information
on a name and the object named by it, the @code{type} command may be
used (@pxref{type}).

It is possible to redefine an already existing name if doing so does not
change its type. A redefinition first sets the variable to the default
value and then computes the expression. The difference between
redefining and overwriting a variable is shown in the following example:

@smallexample
@c computed example Names general.doc:2507 
  int i=3;
  i=i+1;        // overwriting
  i;
@expansion{} 4
  int i=i+1;    // redefinition
@expansion{} // ** redefining i **
  i;
@expansion{} 1
@c end example Names general.doc:2507
@end smallexample

User defined names should start with a letter and consist of letters and
digits only.  As an exception to this rule, the characters @code{@@},
and @code{_} may
be used as part of a name, too.  Capital and small letters are
distinguished.  Indexed names are built as a name followed by an
int_expression in parentheses.  A list of indexed names can be built as
a name followed by an intvec_expression in parentheses.

@smallexample
@c computed example Names_1 general.doc:2525 
  ring R;
  int n=3;
  ideal j(3);
  ideal j(n);     // is equivalent to the above
@expansion{} // ** redefining j(3) **
  ideal j(2)=x;
  j(2..3);
@expansion{} j(2)[1]=x j(3)[1]=0
@c end example Names_1 general.doc:2525
@end smallexample

Names may not coincide with reserved names (keywords).  Type
@code{reservedName();} to get a list of the reserved names.
@xref{reservedName}.  Names should not interfere with names of ring
variables or, more generally, with monomials.  @xref{Identifier
resolution}.
@* The command @code{listvar} provides a list of the names in use
(@pxref{listvar}).

The most recently printed expression is available
under the special name @code{_}, e.g.,
@smallexample
@c computed example Names_2 general.doc:2546 
  ring r;
  ideal i=x2+y3,y3+z4;
  std(i);
@expansion{} _[1]=y3+x2
@expansion{} _[2]=z4-x2
  ideal k=_;
  k*k+x;
@expansion{} _[1]=y6+2x2y3+x4
@expansion{} _[2]=y3z4+x2z4-x2y3-x4
@expansion{} _[3]=z8-2x2z4+x4
@expansion{} _[4]=x
  size(_[3]);
@expansion{} 3
@c end example Names_2 general.doc:2546
@end smallexample

A string_expression enclosed in @code{`}@dots{}@code{`} (back ticks)
evaluates to the value of the variable named by the string_expression.
This feature is referred to as name substitution.

@smallexample
@c computed example Names_3 general.doc:2561 
  int foo(1)=42;
  string bar="foo";
  `bar+"(1)"`;
@expansion{} 42
@c end example Names_3 general.doc:2561
@end smallexample

@c ------------------------------------------------------------
@node Objects, Type conversion and casting, Names, The SINGULAR language
@subsection Objects
@cindex Objects

Every object in @sc{Singular} has a type and a value.  In most cases it
has also a name and in some cases an attribute list.  The value of an
object may be examined simply by printing it with a print command:
object@code{;}.  The type of an object may be determined by means of the
@code{typeof} function, the attributes by means of the @code{attrib}
function (@ref{typeof}, @ref{attrib}):

@smallexample
@c computed example Objects general.doc:2581 
  ring r=0,x,dp;
  typeof(10);
@expansion{} int
  typeof(10000000000000000);
@expansion{} number
  typeof(r);
@expansion{} ring
  attrib(x);
@expansion{} no attributes
  attrib(std(ideal(x)));
@expansion{} attr:isSB, type int
@c end example Objects general.doc:2581
@end smallexample

Each object of type
@code{poly},
@code{ideal},
@code{vector},
@code{module},
@code{map},
@code{matrix},
@code{number}, or
@code{resolution}
belongs to a specific ring.  Also @code{list}, if at least one of the
objects contained in the list belongs to a ring.  These objects are local
to the ring.  Their names can be used for other objects in other rings.
Objects from one ring can be mapped to another ring using maps or with the
commands @code{fetch} or @code{imap}.  @xref{map}, @ref{fetch}, @ref{imap}.

All other types do not belong to a ring and can be accessed within every
ring and across rings.  They can be declared even if there is no active
basering.

@c ------------------------------------------------------------
@node Type conversion and casting, Flow control, Objects, The SINGULAR language
@subsection Type conversion and casting

@subsubheading Type conversion
@cindex Type conversion
Assignments convert the type of the right-hand side to the type of the
left-hand side of the assignment, if possible.  Operators and functions
which require certain types of operands can also implicitly convert the
type of an expression.  It is, for example, possible to multiply a
polynomial by an integer because the integer is automatically converted to
a polynomial.  Type conversions do not act transitively.  Possible
conversions are:


@c ------------------------------------------------
@c Do not delete the leading `@ ' for indentation of the whole table.  The
@c table is indented since regular @tables are indented by a small amount,
@c too.
@c ------------------------------------------------
@multitable @columnfractions .05 .18 .81
@item
@   1. @tab @code{int}  @tab @expansion{} @code{ideal}
@item
@   2. @tab @code{poly}  @tab @expansion{} @code{ideal}
@item
@   3. @tab @code{intvec}  @tab @expansion{} @code{intmat}
@item
@   4. @tab @code{int}  @tab @expansion{} @code{intvec}
@item
@   5. @tab @code{int}  @tab @expansion{} @code{intmat}
@item
@   6. @tab @code{string}  @tab @expansion{} @code{link}
@item
@   7. @tab @code{resolution} @tab @expansion{} @code{list}
@item
@   8. @tab @code{ideal}  @tab @expansion{} @code{matrix}
@item
@   9. @tab @code{int}  @tab @expansion{} @code{matrix}
@item
@  10. @tab @code{intmat}  @tab @expansion{} @code{matrix}
@item
@  11. @tab @code{intvec}  @tab @expansion{} @code{matrix}
@item
@  12. @tab @code{module}  @tab @expansion{} @code{matrix}
@item
@  13. @tab @code{number}  @tab @expansion{} @code{matrix}
@item
@  14. @tab @code{poly}  @tab @expansion{} @code{matrix}
@item
@  15. @tab @code{vector}  @tab @expansion{} @code{matrix}
@item
@  16. @tab @code{ideal}  @tab @expansion{} @code{module}
@item
@  17. @tab @code{matrix}  @tab @expansion{} @code{module}
@item
@  18. @tab @code{vector}  @tab @expansion{} @code{module}
@item
@  19. @tab @code{int}  @tab @expansion{} @code{number}
@item
@  20. @tab @code{int}  @tab @expansion{} @code{poly}
@item
@  21. @tab @code{number}  @tab @expansion{} @code{poly}
@item
@  22. @tab @code{string}  @tab @expansion{} @code{proc}
@item
@  23. @tab @code{list}  @tab @expansion{} @code{resolution}
@item
@  24. @tab @code{int}  @tab @expansion{} @code{vector}
  (i @expansion{} i*@code{gen(1)})
@item
@  25. @tab @code{poly}  @tab @expansion{} @code{vector}
  (p @expansion{} p*@code{gen(1)})
@end multitable

@subsubheading Type casting
@cindex Type casting
An expression can be casted to another type by using a type cast
expression:
@* type @code{(} expression @code{)}.

Possible type casts are:

@c ------------------------------------------------
@c Do not delete the leading `@ ' for indentation of the whole table.  The
@c table is indented since regular @tables are indented by a small amount,
@c too.
@c ------------------------------------------------
@multitable @columnfractions .05 .15 .83
@item
@    @tab to @tab from
@item
@    @tab  @code{ideal} @tab  expression lists of @code{int}, @code{number}, @code{poly}
@item
@    @tab  @code{ideal} @tab  @code{int}, @code{matrix}, @code{module}, @code{number}, @code{poly}, @code{vector}
@item
@    @tab  @code{int} @tab    @code{number}, @code{poly}
@item
@    @tab  @code{intvec} @tab expression lists of @code{int}, @code{intmat}
@item
@    @tab  @code{intmat} @tab @code{intvec} (@pxref{intmat type cast})
@item
@    @tab  @code{list} @tab   expression lists of any type
@item
@    @tab  @code{matrix} @tab @code{module}, @code{ideal},
@code{vector}, @code{matrix}.
@* There are two forms to convert something to a matrix: if @code{matrix(}
expression @code{)} is used then the size of the matrix is determined
by the size of expression.
@* But @code{matrix(} expression @code{,} m @code{,} n @code{)} may also be
used - the result is a
@tex
$ m \times n $
@end tex
m x n
matrix (@pxref{matrix type cast})
@item
@    @tab  @code{module} @tab expression lists of @code{int}, @code{number},
@code{poly}, @code{vector}
@item
@    @tab  @code{module} @tab @code{ideal}, @code{matrix}, @code{vector}
@item
@    @tab  @code{number} @tab @code{poly}
@item
@   @tab  @code{poly} @tab   @code{int}, @code{number}
@item
@   @tab  @code{string} @tab   any type (@pxref{string type cast})
@end multitable

@strong{Example:}
@smallexample
@c computed example Type_casting general.doc:2743 
  ring r=0,x,(c,dp);
  number(3x);
@expansion{} 0
  number(poly(3));
@expansion{} 3
  ideal i=1,2,3,4,5,6;
  print(matrix(i));
@expansion{} 1,2,3,4,5,6
  print(matrix(i,3,2));
@expansion{} 1,2,
@expansion{} 3,4,
@expansion{} 5,6 
  vector v=[1,2];
  print(matrix(v));
@expansion{} 1,
@expansion{} 2 
  module(matrix(i,3,2));
@expansion{} _[1]=[1,3,5]
@expansion{} _[2]=[2,4,6]
@c end example Type_casting general.doc:2743
@end smallexample


@c ------------------------------------------------------------
@node Flow control, ,Type conversion and casting, The SINGULAR language
@subsection Flow control
@cindex Flow control
@cindex block

A block is a sequence of commands surrounded by @{ and @}.
@smallexample
@{
   command;
   @dots{}
@}
@end smallexample
Blocks are used whenever @sc{Singular} is used as a structured programming
language. The @code{if} and @code{else} structures allow conditional
execution of blocks (see @ref{if}, @ref{else}). @code{for} and @code{while}
loops are available for repeated execution of blocks (see @ref{for},
@ref{while}).
In procedure definitions the main part and the example section are blocks
as well(see @ref{proc}).
@menu
* break::
* quit::
* keepring::
* export::
* if::
* else::
* for::
* while::
* proc::
* return::
* continue::
@end menu


@c ----------------------------------------------------------------------
@c ----------------------------------------------------------------------
@node Input and output, Procedures, The SINGULAR language, General concepts
@section Input and output
@cindex input
@cindex output

@sc{Singular}'s input and output (short, I/O) is realized using links.
Links are the communication channels of @sc{Singular}, i.e., something
@sc{Singular} can write to and read from.  In this section, a short
overview of the usage of links and of the different link types is given.

For loading of libraries, see @ref{LIB}. For executing program scripts,
see @ref{filecmd}.

@subheading Monitoring
A special form of I/O is monitoring.  When monitoring is enabled,
@sc{Singular} makes a typescript of everything printed on your terminal
to a file.  This is
useful to create a protocol of a @sc{Singular} session.  The
@code{monitor} command enables and disables this feature
(@pxref{monitor}).


@subheading How to use links
Recall that links are the communication channels of @sc{Singular}, i.e.,
something @sc{Singular} can write to and read from using the functions
@code{write} and @code{read}. There are furthermore
the functions @code{dump} and @code{getdump} which store resp.@:
retrieve the content of an entire @sc{Singular} session to, resp.@: from,
a link.  The @code{dump} and @code{getdump} commands are not available
for DBM links.

For more information, see @ref{write}, @ref{read}, @ref{dump},
@ref{getdump}.

@strong{Example:}
@smallexample
@c computed example How_to_use_links general.doc:2830 
  ring r; poly p = x+y;
  dump("MPfile:w test.mp");   // dump the session to the file test.mp
  kill r;                     // kill the basering
  listvar();
@expansion{} // LIB                  [0]  string standard.lib
  getdump("MPfile:r test.mp");// read the dump from the file
  listvar();
@expansion{} // r                    [0]  *ring
@expansion{} //      p                    [0]  poly
@expansion{} // LIB                  [0]  string standard.lib
@c end example How_to_use_links general.doc:2830
@end smallexample

Specifying a link can be as easy as specifying a filename as a string.
Except for MPtcp links, links even do not need to be explicitly opened
or closed before, resp.@: after, they are used.  To explicitly open or
close a link, the @code{open}, resp.@: @code{close}, commands may be
used (see @ref{open}, @ref{close}).

Links have various properties which can be queried using the
@code{status} function (@pxref{status}).

@strong{Example:}
@smallexample
@c computed example How_to_use_links_1 general.doc:2851 
  link l = "MPtcp:fork";
  l;
@expansion{} // type : MPtcp
@expansion{} // mode : fork
@expansion{} // name : 
@expansion{} // open : no
@expansion{} // read : not ready
@expansion{} // write: not ready
  open(l);
  status(l, "open");
@expansion{} yes
  close(l);
  status(l, "open");
@expansion{} no
@c end example How_to_use_links_1 general.doc:2851
@end smallexample

@subheading ASCII links
Data that can be converted to a string that can be written into files for
storage or communication with other programs. The data are written in
plain ASCII format. Reading from an ASCII link returns a string ---
conversion into other data is up to the user. This can be done, for
example, using the command @code{execute} (@pxref{execute}).

ASCII links should primarily be used for storing small amounts of data,
especially if it might become necessary to manually inspect or
manipulate the data.

@xref{ASCII links}, for more information.

@strong{Example:}
@smallexample
@c computed example ASCII_links general.doc:2876 
  // (over)write file test.ascii, link is specified as string
  write(":w test.ascii", "int i =", 3, ";");
  // reading simply returns the string
  read("test.ascii");
@expansion{} int i =
@expansion{} 3
@expansion{} ;
@expansion{} 
  // but now test.ascii is "executed"
  execute(read("test.ascii"));
  i;
@expansion{} 3
@c end example ASCII_links general.doc:2876
@end smallexample

@subheading MPfile links
Data is stored in the binary MP format.  Read and write access is very
fast compared to ASCII links.  All data (including such data that cannot
be converted to a string) can be written to an MPfile link.  Reading
from an MPfile link returns the written expressions (i.e., not a string,
in general).

MPfile links should primarily be used for storing large amounts of data
(like dumps of the content of an entire @sc{Singular} session), and if
the data to be stored cannot be easily converted from or to a string
(like rings, or maps).

MPfile links are implemented on Unix-like operating systems only.

@xref{MPfile links}, for more information.

@strong{Example:}
@smallexample
@c computed example MPfile_links general.doc:2905 
  ring r;
  // (over)write MPfile test.mp, link is specified as string
  write("MPfile:w test.mp", x+y);
  kill r;
  def p = read("MPfile:r test.mp");
  typeof(p); p;
@expansion{} poly
@expansion{} x+y
@c end example MPfile_links general.doc:2905
@end smallexample

@subheading MPtcp links
Data is communicated with other processes (e.g., @sc{Singular}
processes) which may run on the same computer or on different ones.  Data
exchange is accomplished using TCP/IP links in the binary MP format.
Reading from an MPtcp link returns the written expressions (i.e., not a
string, in general).

MPtcp links should primarily be used for communications with other
programs or for parallel computations (see, for example,
@ref{Parallelization with MPtcp links}).

MPtcp links are implemented on Unix-like operating systems only.

@xref{MPtcp links}, for more information.

@strong{Example:}
@smallexample
@c computed example MPtcp_links general.doc:2932 
  ring r;
  link l = "MPtcp:launch"; // declare a link explicitly
  open(l);  // needs an open, launches another SINGULAR as a server
  write(l, x+y);
  kill r;
  def p = read(l);
  typeof(p); p;
@expansion{} poly
@expansion{} x+y
  close(l); // shuts down SINGULAR server
@c end example MPtcp_links general.doc:2932
@end smallexample

@subheading DBM links
Data is stored in and accessed from a data base.  Writing is
accomplished by a key and a value and associates the value with the key
in the specified data base.  Reading is accomplished w.r.t.@: a key,
the value associated to it is returned.  Both the key and the value have to
be specified as strings.  Hence, DBM links may be used only for data
which may be converted to or from strings.

DBM links should primarily be used when data needs to be accessed not in a
sequential way (like with files) but in an associative way (like with
data bases).

@xref{DBM links}, for more information.

@strong{Example:}
@smallexample
@c computed example DBM_links general.doc:2960 
  ring r;
  // associate "x+y" with "mykey"
  write("DBM:w test.dbm", "mykey", string(x+y));
  // get from data base what is stored under "mykey"
  execute(read("DBM: test.dbm", "mykey"));
@expansion{} x+y
@c end example DBM_links general.doc:2960
@end smallexample


@c ---------------------------------------------------------------------------
@node Procedures, Libraries, Input and output, General concepts
@section Procedures
@cindex Procedures

Procedures contain sequences of commands of the @sc{Singular} language.
They are used to extend
the set of commands with user defined commands.  Procedures are defined
by either typing them on the command line or by loading them from a
so-called library file with the LIB command, see @ref{LIB}.  Procedures are
invoked like normal built-in commands, i.e., by typing their name
followed by the list of arguments in parentheses. The invocation then
executes the sequence of commands stored in the specified procedure. All
defined procedures can be displayed by the command @code{listvar(proc);}.

@menu
* Procedure definition::
* Names in procedures::
* Parameter list::
* Procedure commands::
@end menu
@c -------------------------------------------------
@node Procedure definition, Names in procedures, Procedures, Procedures
@subsection Procedure definition
@cindex Procedure definition
@cindex procedures, static
@cindex static procedures
@c ------------------------------------------------------------
@c   This piece of text exists also in the file types.doc,
@c   chapter "proc declaration".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
@table @strong
@item Syntax:
[@code{static}] @code{proc} proc_name [parameter_list]
@*["help_text"]
@*@code{@{}
@*
@tex
\quad
@end tex
   procedure_body
@*@code{@}}
@*[@code{example}
@*@code{@{}
@*
@tex
\quad
@end tex
   sequence_of_commands;
@*@code{@}}]
@item Purpose:
defines a new function, the @code{proc} proc_name, with the additional
information help_text, which is copied to the screen by
@code{help proc_name;} and the @code{example} section
which is executed by @code{example proc_name;}.
@* The help_text, the parameter_list, and the example section are optional.
The default for a parameter_list is @code{(list #)}, see @ref{Parameter list}.
The help and example sections are ignored if the procedure is defined
interactively, i.e., if it was not loaded from a file by a LIB command
(@ref{LIB}).
@* Specifying @code{static} in front of the proc-definition (in a library file)
makes this procedure local to the library, i.e., accessible only for the other
procedures in the same library, but not for the users. So there is no
reason anymore to define a procedure within another one (it just makes
debugging harder).
@end table

@subsubheading Example of an interactive procedure definition
@smallexample
@c computed example Example_of_an_interactive_procedure_definition general.doc:3045 
  proc milnor_number (poly p)
  @{
    ideal i= std(jacob(p));
    int m_nr=vdim(i);
    if (m_nr<0)
    @{
      "// not an isolated singularity";
    @}
    return(m_nr);         // the value of m_nr is returned
  @}
  ring r1=0,(x,y,z),ds;
  poly p=x^2+y^2+z^5;
  milnor_number(p);
@expansion{} 4
@c end example Example_of_an_interactive_procedure_definition general.doc:3045
@end smallexample

@subsubheading Example of a procedure definition in a library
First, the library definition:
@smallexample
@c begin included file sample.lib from general.doc:3065
// Example of a user accessible procedure
proc tab (int n)
"USAGE:    tab(n);  (n integer)
RETURNS:  string of n space tabs
EXAMPLE:  example tab; shows an example"
@{ return(internal_tab(n)); @}
example
@{
  "EXAMPLE:"; echo=2;
  for(int n=0; n<=4; n=n+1)
  @{ tab(4-n)+"*"+tab(n)+"+"+tab(n)+"*"; @}
@}

// Example of a static procedure
static proc internal_tab (int n)
@{ return(" "[1,n]); @}
@c end included file from general.doc:3065
@end smallexample

Now, we load the library and execute the procedures defined there:
@smallexample
@c computed example Example_of_a_procedure_definition_in_a_library general.doc:3070 
  LIB "sample.lib";        // load the library sample.lib
  example tab;             // show an example
@expansion{} // proc tab from lib sample.lib
@expansion{} EXAMPLE:
@expansion{}   for(int n=0; n<=4; n=n+1)
@expansion{}   @{ tab(4-n)+"*"+tab(n)+"+"+tab(n)+"*"; @}
@expansion{}     *+*
@expansion{}    * + *
@expansion{}   *  +  *
@expansion{}  *   +   *
@expansion{} *    +    *
@expansion{} 
  "*"+tab(3)+"*";          // use the procedure tab
@expansion{} *   *
  // the static procedure internal_tab is not accessible
  "*"+internal_tab(3)+"*";
@expansion{}    ? 'sample.lib::internal_tab()' is a local procedure and cannot be acce\
   ssed by an user.
@expansion{}    ? error occurred in line 5: `  "*"+internal_tab(3)+"*";`
  // show the help section for tab
  help tab;
@expansion{} // ** Could not get IdxFile. 
@expansion{} // ** Either set environment variable SINGULAR_IDX_FILE to IdxFile,
@expansion{} // ** or make sure that IdxFile is at /home/hannes/singular/2-0/doc/singu\
   lar.idx
@expansion{} // proc tab from lib sample.lib
@expansion{} proc tab (int n)
@expansion{} USAGE:    tab(n);  (n integer)
@expansion{} RETURNS:  string of n space tabs
@expansion{} EXAMPLE:  example tab; shows an example
@c end example Example_of_a_procedure_definition_in_a_library general.doc:3070
@end smallexample

@subsubheading Guidelines for the help text of a procedure
There are no enforced rules on the format of the help section of a
procedure.

Nevertheless, we recommend that the help text of a procedure should
contain information about the usage,
purpose, return values and generated objects. Particular assumptions or
limitations should be listed. It should also be mentioned if global
objects are generated or manipulated.

The help text of procedures contained in libraries of the
@sc{Singular} distribution
should furthermore comply with  certain rules as explained in
@ref{The help string of procedures}.

@c ---------------------------------------
@node Names in procedures, Parameter list, Procedure definition, Procedures
@subsection Names in procedures
@cindex Names in procedures
@cindex local names

All variables are local to the procedure they are defined in.
Locally defined variables cannot interfere with names in other
procedures and are automatically deleted after leaving
the procedure.

Internally, local variables are stored using the nesting level. A variable
is said to have nesting level 1, if it is local to a procedure that was
called interactively, nesting level 2, if it is local to a procedure that
was called by a procedure of nesting level 1 etc. @code{listvar()} also
displays the nesting level, nesting level 0 is used for global objects
(see @ref{listvar}). A ring may be 'moved up' by one nesting level
with @code{keepring} (see @ref{keepring}). All variables living in that
ring are moved together with that ring.

To keep local variables after leaving the procedure, they have to be
exported (i.e. made known) to some higher level by the @code{export}
command (@pxref{export}).

@strong{Example:}
@smallexample
@c computed example Names_in_procedures general.doc:3122 
proc xxx
@{
  int k=4;        //defines a local variable k
  int result=k+2;
  export(result);  //defines the global variable "result".
@}
xxx();
listvar(all);
@expansion{} // result               [0]  int 6
@expansion{} // LIB                  [0]  string standard.lib
@c end example Names_in_procedures general.doc:3122
@end smallexample
Note that the variable @code{result} became a global variable after the
execution of @code{xxx}.

@c ---------------------------------------
@node Parameter list, Procedure commands, Names in procedures, Procedures
@subsection Parameter list
@cindex Parameter list
@table @code
@item @strong{Syntax:}
@code{( )}
@*@code{(} parameter_definition @code{)}
@item @strong{Purpose:}
defines the number, type and names of the
arguments to a @code{proc}.
@*The parameter_list is optional.
The default for a parameter_list is @code{(list #)}
which means the arguments are referenced by @code{#[1], #[2]}, etc.
@item @strong{Example:}
@smallexample
proc x0
@{
    // can be called with
... // any number of arguments of any type: #[1], #[2],...
    // number of arguments: size(#)
@}

proc x1 ()
@{
... // can only be called without arguments
@}

proc x2 (ideal i, int j)
@{
... // can only be called with 2 arguments,
    // which can be converted to ideal resp. int
@}

proc x3 (i,j)
@{
... // can only be called with 2 arguments
    // of any type
    // (i,j) is the same as (def i,def j)
@}

proc x5 (i,list #)
@{
... // can only be called with at least 1 argument
    // number of arguments: size(#)+1
@}

@end smallexample
@item @strong{Note:}
@* The parameter_list may stretch across multiple lines.
@* A parameter may have any type (including the types @code{proc}
   and @code{ring}). If a parameter is of type ring, then it
   can only be specified by name, but not with a type, e.g.
@smallexample
proc x6 (r)
@{
... // this is correct even if the parameter is a ring
@}

proc x7 (ring r)
@{
... // this is NOT CORRECT
@}
@end smallexample
@end table

@c --------------------------------------- ----------
@node Procedure commands, , Parameter list, Procedures
@subsection Procedure commands
@cindex Procedure commands

Some commands only make sense inside a procedure, since they make
objects known to the nesting level from which the procedure was called
or to all nesting levels.

@c inserted refs from general.doc:3211
@menu
See
* export::
* keepring::
* return::
@end menu
@c end inserted refs from general.doc:3211

@c ----------------------------------------------------------------------
@node Libraries, Guidelines for writing a library, Procedures, General concepts
@section Libraries
@cindex Libraries

A library is a collection of @sc{Singular}
procedures in a file.
@*@sc{Singular} reads a library with the command
@code{LIB}. General information about the library is displayed by the command
@code{help libname_lib}. After loading the library, its procedures can be used
like the built-in @sc{Singular} functions.

To have the full functionality of a built-in function libraries have to
comply with the few syntax rules described below.

Furthermore, libraries which are to be included in the @sc{Singular}
distribution, have to comply with certain rules as explained in
@ref{Guidelines for writing a library}.

@menu
* Loading of a library::
* Format of a library::
@end menu

@c ---------------------------------------
@node Loading of a library, Format of a library,, Libraries
@subsection Loading of a library
@cindex Loading of a library
@cindex path
@cindex SearchPath
@cindex RootDir
@cindex BinDir
@cindex DefaultDir
@cindex SINGULARPATH

Libraries can be loaded with the @code{LIB} command:

@c ------------------------------------------------------------
@c   This piece of text exists also in the file reference.doc,
@c   chapter "LIB".
@c   chapter "load".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
@table @code
@item @strong{Syntax:}
@code{LIB} string_expression @code{;}
@item @strong{Type:}
none
@item @strong{Purpose:}
reads a library of procedures from a file. If the given filename does
not start with @kbd{.} or @kbd{/} and can not be located in the current
directory, each directory contained in the library
@code{SearchPath} is searched for file of this name.
@item @strong{Note on SearchPath:}
The the library @code{SearchPath} is constructed at @sc{Singular}
start-up time as follows:
@enumerate
@item
the directories contained in the environment variable
@code{SINGULARPATH} are appended

@item
the directories @code{$BinDir/LIB}, @code{$RootDir/LIB},
@code{$RootDir/../LIB}, @code{$DefaultDir/LIB}, @code{$DefaultDir/../LIB}
are appended, where
@itemize @bullet
@item @code{$BinDir}
is the value of the environment variable
@code{SINGULAR_BIN_DIR}, if set, or, if not set, the directory in which the
@sc{Singular} program
resides
@item @code{$RootDir}
is the value of the environment variable
@code{SINGULAR_ROOT_DIR}, if set, or, if not set, @code{$BinDir/../}.
@item @code{$DefaultDir}
is the value of the environment variable
@code{SINGULAR_DEFAULT_DIR}, if set, or @code{/usr/local/Singular/} on a
Unix platform, @code{\Singular\} on a Windows 95/98/NT platform, and
@code{::Singular:} on a Macintosh.
@end itemize

@item
all directories which do not exist are removed from the @code{SearchPath}.
@end enumerate

For setting environment variables see @ref{system}, or consult the manual of
your shell.

The library @code{SearchPath} can be examined  by starting up
@sc{Singular} with the option @code{-v}, or by issuing the command
@code{system("--version");}.

@item @strong{Note on standard.lib:}
Unless  @sc{Singular} is started with the @code{--no-stdlib} option, the
library @code{standard.lib} is automatically loaded at start-up time.

@end table

Only the names of the procedures in the library are loaded, the body of
the procedures is read during the first call of this procedure. This minimizes
memory consumption by unused procedures.  When @sc{Singular} is started
with the @code{-q} or @code{--quiet} option, no message about the
loading of a library is displayed.  More precisely, option @code{-q} (and
likewise @code{--quiet}) unsets option @code{loadLib} to inhibit
monitoring of library loading (@pxref{option}).

All loaded libraries are displayed by the @code{LIB;}
command:
@smallexample
@c computed example Loading_of_a_library general.doc:3327 
  option(loadLib);   // show loading of libraries;
                     // standard.lib is loaded
  LIB;
@expansion{} standard.lib
                     // the names of the procedures of inout.lib
  LIB "inout.lib";   // are now known to Singular
@expansion{} // ** loaded inout.lib (1.21.2.5,2002/06/12)
  LIB;
@expansion{} standard.lib,inout.lib
@c end example Loading_of_a_library general.doc:3327
@end smallexample

@c inserted refs from general.doc:3337
@menu
See
* Command line options::
* LIB::
* Procedures and libraries::
* SINGULAR libraries::
* proc::
* standard_lib::
* string::
* system::
@end menu
@c end inserted refs from general.doc:3337

@c ---------------------------------------
@node Format of a library,, Loading of a library, Libraries
@subsection Format of a library
@cindex Format of a library

A library file can contain comments, a category-, info- and version-string
definition, @code{LIB} commands, @code{proc} commands
and @code{proc} commands with @code{example} and @code{help} sections,
i.e., the following keywords are allowed:
@code{category},
@code{info},
@code{version},
@code{LIB},
@code{/* ... */},
@code{//},
@code{[static] proc}.
Anything else is not recognized by the parser of @sc{Singular} and leads
to an error message while loading the library.
If an error occurs, loading is aborted and an error message is displayed,
specifying the type of error and the line where it was detected.

The category-, info- and version-string are defined as follows:
@cindex  info in a library
@table @code
@item @strong{Syntax:}
@code{info} = string_constant @code{;}
@item @strong{Purpose:}
defines the general help for the library. This text is displayed on
@code{help libname_lib;}.
@item @strong{Example:}
@smallexample
info="
      This could be the general help of a library.
     Quotes must be escaped with a \ such as \"
";
@end smallexample
@item @strong{Note:}
In the info-string the characters \ and " must be preceded by a \ (escaped).
It is recommended that the info string is placed on the top of a
library file and contains general information about the library as well
as a listing of all procedures available to the users (with a one line
description of each procedure).

Although there is no enforced format of the info string of a library, we
recommend that you follow certain rules as explained in
@ref{The help string of a library}.
@end table

@cindex  version in a library
@table @code
@item @strong{Syntax:}
@code{version} = string_constant @code{;}
@item @strong{Purpose:}
defines the version number for the library. It is displayed when the
library is loaded.
@item @strong{Example:}
@smallexample
version="$ I@i{}@comment
@comment !! Do not erase the @comment at the end of the previous line !!
@comment !! It prevents cvs to substitute the id string                !!
d: sample.lib,v 1.2 1998/05/07 singular Exp $";
version="some version string";
@end smallexample
@item @strong{Note:}
It is common practice to simply define the version string to be
@code{"$ I}@comment
@comment !! Do not erase the @comment at the end of the previous line !!
@comment !! It prevents cvs to substitute the id string                !!
@code{d:$"} and let a version control system expand it.
@end table

@cindex  category in a library
@table @code
@item @strong{Syntax:}
@code{category} = string_constant @code{;}
@item @strong{Purpose:}
defines the category for the library.
@item @strong{Example:}
@smallexample
category="Utilities";
@end smallexample
@item @strong{Note:}
reserved for sorting the libraries into categories.
@end table

@c ---------------------------------------
@node Guidelines for writing a library, Debugging tools, Libraries, General concepts
@section Guidelines for writing a library
@cindex Guidelines for writing a library
@cindex library, Guidelines for writing

Although there are very few enforced rules on how libraries are written
(see @ref{Libraries}), it is recommended that the libraries comply with
the guidelines explained in this section, so that debugging and
understanding are made easier.

@strong{Note:} For libraries which are to be included in the @sc{Singular}
distribution, the following guidelines are mandatory.

@menu
* Procedures in a library::
* Documentation of a library::
* Typesetting of help strings::
* The help string of a library::
* The help string of procedures::
* template_lib::
@end menu

@c ---------------------------------------
@node Procedures in a library, Documentation of a library,,Guidelines for writing a library

@subsection Procedures in a library
@cindex Procedures in a library
@cindex library, procedures

In this section we list miscellaneous recommendations on how procedures
contained in a library should be implemented.
@enumerate
@item
The info- and version-string should appear at the beginning of the
library, before procedure definitions.

@item
The info-string should have the format as explained in @ref{The help
string of a library}.

@item
Each procedure which should not be accessible by users should be
declared @code{static}.

@item
Each procedure which is not declared @code{static} should have a
help and example section as explained in @ref{Procedure definition}.
@*Such procedures should furthermore carefully check any assumptions
made about their input (like the type of list elements), and, if
necessary, omit an error using the  function @ref{ERROR}.

@item
No procedures should be defined within the body of another procedure.

@item
If the value of
the reserved variable @code{printlevel} (@pxref{printlevel}) is greater
than 0 then interactive user-input, i.e., the usage of functions like
@code{pause("..")} or @code{read("");} (@pxref{read}), may be requested.

@item
If the value of
the reserved variable @code{printlevel} (@pxref{printlevel}) is 0
then interactive user-input, i.e., the usage of functions like
@code{pause("..")} or @code{read("");} (@pxref{read}), may @strong{not} be
requested. Instead, an error (using the function
@ref{ERROR}) should be reported together with the recommendation on
increasing the value of the reserved variable @code{printlevel}.

@item
It is often useful for a procedure to print out comments, either to
explain results or to display intermediate computations. However,
if this procedure is called by another procedure, such comments are
confusing and disturbing in most cases.

@sc{Singular} offers an elegant solution, which requires the usage of
the @sc{Singular} function @ref{dbprint} and the reserved variables
@ref{printlevel}, and @ref{voice} (@code{voice} counts the nesting of
procedures; It has the value 1 on the top level, 2 inside the first
procedure etc.; @code{printlevel} has the value 0 by default, but can be
set to any integer value by the user).

For example, if the following procedure @code{Test} is called
directly from the top level then @samp{comment1} is displayed (i.e.,
printed out) but not
@samp{comment2}; and nothing is displayed if  @code{Test} is called
from within any other procedure.
However, if @code{printlevel} is set to  a value k with k>0, then
@samp{comment1} (resp.@: @samp{comment2}) is displayed provided that
@code{Test} is called from other procedures, with a nesting level up to
k (resp.@: k-1).

Note furthermore, that the example part of a procedure
behaves in this respect like a procedure (i.e., the value of @code{voice}
is 1). Therefore, the command @code{printlevel=1;} is necessary for
@samp{comment1} to be displayed on @code{ example Test;}. However,
since printlevel is a global variable, it should be reset to the old
value at the end of the example part.

@smallexample
proc Test
"USAGE:   ...
         ...
EXAMPLE: example Test; shows an example
"
@{   ...
   int p = printlevel - voice + 3;
    ...
   dbprint(p,"comment1");
   dbprint(p-1,"comment2");
   // dbprint prints only if p > 0
    ...
@}
example
@{ "EXAMPLE:"; echo = 2;
   int p = printlevel;   //store old value of printlevel
   printlevel = 1;       //assign new value to printlevel
    ...
   Test();
   printlevel = p;       //reset printlevel to old value
@}
@end smallexample

@end enumerate
@c @end table

@c ---------------------------------------
@node Documentation of a library, Typesetting of help strings, Procedures in a library, Guidelines for writing a library

@subsection Documentation of a library
@cindex Documentation of a library
@cindex library, documentation

The typesetting language in which the @sc{Singular} documentation is
written is @code{texinfo}. Based on various tools, @code{info, dvi, ps,} and
@code{html} versions of the @code{texinfo} documentation are generated.


Starting with @sc{Singular} version 1-3, the @code{texinfo}
documentation of all libraries of the @sc{Singular} distribution is
generated automatically from their source code.

More precisely, for each library,
@itemize @minus
@item
the info string of the library is parsed and typeset
as explained in @ref{Typesetting of help strings}.

@item
the help string of each procedure listed in the @code{PROCEDURE:}
section of the library info string is parsed
and typeset as explained in @ref{Typesetting of help strings}.

@item
the example of each procedure listed in the @code{PROCEDURE:} section of
the library info string is computed and its output is
included into the documentation.
@end itemize

For a uniform look-and-feel of the library documentation, library
developers should
@itemize @minus
@item
follow the recommendation of
@ref{The help string of a library} and @ref{The help string of
procedures}.

@item
consult the source code of libraries like
@code{template.lib} (@pxref{template_lib})
for examples on how library documentations are
written.

@item
make sure that each procedure listed in the @code{PROCEDURE:}
section of the library info string has a help string and an example
section.

@item
not use interactive functions like
@code{pause("..")} or @code{read("");} (@pxref{read}) and should limit the
length of input lines to 60 characters in the example section of
procedures.

@item
carefully check the generated
documentation of their libraries in its various formats using the
@code{lib2doc} (@pxref{lib2doc}) utility.
@end itemize

@menu
* lib2doc::
@end menu

@node lib2doc,,,Documentation of a library
@subsubsection lib2doc
@cindex lib2doc


@code{lib2doc} is a utility to generate the stand-alone documentation for 
a @sc{Singular} library in various formats. 

The @code{lib2doc} utility should be used by developers of @sc{Singular}
libraries to check the generation of the documentation of their
libraries.

@code{lib2doc} can be downloaded from @*
@url{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/misc/lib2doc.tar.gz}


@strong{Important:} 
@*To use @code{lib2doc}, you need 
to have @code{perl} (version 5 or
higher), @code{texinfo} (version 3.12 or higher)  and @code{Singular}
and @code{libparse} (version 1-3-4 or higher) installed on your system.

To generate the documentation for a library, follow these steps:
@enumerate
@item
Unpack lib2doc.tar.gz
@smallexample
gzip -dc  lib2doc.tar.gz | tar -pxf -
@end smallexample
and 
@smallexample
cd lib2doc
@end smallexample

@item 
Edit the beginning of the file @code{Makefile}, filling in the values for
@code{SINGULAR} and @code{LIBPARSE}. Check also the values of @code{PERL} 
and @code{LATEX2HTML}.

@item 
Copy your library to the current directory:
@smallexample
cp <path-where-your-lib-is>/mylib.lib .
@end smallexample

@item 
Now you can run the following commands:
@table @code
@item make mylib.hlp
Generates the file @code{mylib.hlp} -- the info file for the documentation
of @code{mylib.lib}. This file can be viewed with
@smallexample
info -f mylib.hlp
@end smallexample
@item make mylib.dvi
Generates the file @code{mylib.dvi} -- the dvi file for the documentation
of @code{mylib.lib}. This file can be viewed with
@smallexample
xdvi mylib.dvi
@end smallexample
@item make mylib.ps
Generates the file @code{mylib.ps} -- the PostScript file for the documentation
of @code{mylib.lib}. This file can be viewed with (for example)
@smallexample
ghostview mylib.dvi
@end smallexample
@item make mylib.html
Generates the file @code{mylib.html} -- the HTML file for the documentation
of @code{mylib.lib}. This file can be viewed with (for example)
@smallexample
netscape mylib.html
@end smallexample
@item make clean
Deletes all generated files.
@end table


Note that you can safely ignore messages complaining about undefined
references.  

@end enumerate


@c ----------------------------------------
@node Typesetting of help strings, The help string of a library, Documentation of a library, Guidelines for writing a library
@subsection Typesetting of help strings
@cindex Typesetting of help strings
@cindex library, typesetting of help strings

The help strings of procedures and info strings of libraries which are
included in the
distribution of @sc{Singular} are parsed and automatically converted
into the texinfo format (the typesetting language in which the
documentation  of @sc{Singular} is written).

For optimal typesetting results, the guidelines for writing libraries
and procedures should be followed, and the following points should be
kept in mind:

@itemize @bullet
@item
If a help string starts with an @code{@@} sign, then no parsing is done,
and the help string is assumed to be already in the texinfo format.
@item
help strings are typeset within a @code{@@table @@asis} environment
(which is similar to a latex @code{description} environment).
@item
If a line starts with  only uppercase words and contains a colon, then
the text up
to the colon is taken to be the description-string of an item and the
text following the colon is taken to be the content of the item.
@item
If the description-string of an item matches
@table @asis
@item @code{EXAMPLE}
then this item and its content is ignored.
@item @code{SEE ALSO}
then the
content of the item is assumed to be comma-separated words which are
valid references to other texinfo nodes of the manual. (e.g., all
procedure and command names are also texinfo nodes).
@item  @code{KEYWORDS} (or, @code{KEYPHRASES})
then the content of the item is assumed to be a
semicolon-separated list of phrases which are taken as keys for the
index of the manual (N.B. the name of a procedure/library is
automatically added to the index keys).
@item @code{PROCEDURES}
then the
content of the item is assumed to be a summary description of the
procedures contained in the library. Separate texinfo nodes (subsections
in printed documents) are
@strong{only} created out of the help strings of such procedures which
appear in the summary description of a library.
@item @code{LIBRARY}
then the content of the item is assumed to be a one-line description of
a library. If this one-line description consist of only uppercase
characters, then it is typeset in all lowercase characters in the
manual (otherwise it is left as is).
@end table

@item
For the content of an item, the following texinfo markup elements
are recognized (and, their content not further manipulated):
@table @asis
@item @code{@@*}
to enforce a line-break.
@table @asis
@item Example:
@code{old line @@* new line}
@* @expansion{}
@* old line @* new line
@end table

@item @code{@@ref@{...@}}
References to other parts of the @sc{Singular} manual can be set using
one of the following @code{@@ref@{node@}} constructs. Notice that
@code{node} must be the name of a section of the @sc{Singular}
manual. In particular, it may be a name of a function, library or library
procedure.

@table @asis
@item @code{@@xref@{node@}}
for a reference to the node @code{node} at the beginning of a sentence.
@item @code{@@ref@{node@}}
for a reference to the node @code{node} at the end of a sentence.
@item @code{@@pxref@{node@}}
for a reference to the node @code{node} within parenthesis.

@item Example:
@code{@@xref@{Tropical Storms@}, for more info.}
@*@expansion{}*Note Hurricanes::, for more info.
@*@expansion{}See Section 3.1 [Hurricanes], page 24, for more info.

@code{For more information, see @@ref@{Hurricanes@}.}
@*@expansion{}For more information, see *Note Hurricanes::.
@*@expansion{}For more information, see Section 3.1 [Hurricanes], page 24.


@code{... storms cause flooding (@@pxref@{Hurricanes@}) ...}
@*@expansion{}... storms cause flooding (*Note Hurricanes::) ...
@*@expansion{}... storms cause flooding (see Section 3.1 [Hurricanes],
page 24)
@end table

@item @code{@@math@{..@}}
for typesetting of small (i.e., which do not go over
multiple lines) mathematical expressions  in LaTeX math-mode
syntax.
@table @asis
@item Example:
@code{@@math@{\alpha@}}
@*@expansion{}
@*
@math{\alpha}
@tex
$\alpha$
@end tex

@item Note:
Mathematical expressions inside @code{@@math@{..@}} may
not contain curly parenthesis and the "at" sign, i.e., may not contain
@code{@{,@},@@}.
@end table

@item @code{@@code@{..@}}
for typesetting of small (i.e., which do not go over
multiple lines) strings in typewriter font.
@table @asis
@item Example:
@code{@@code@{typewriter font@}}
@*@expansion{}
@*@code{typewriter font}
@item Note:
The string inside @code{@@code@{..@}} may
not contain curly parenthesis and the "at" sign, i.e., may not contain
@code{@{,@},@@}.
@end table

@item @code{@@example}
 @code{...}
@item @code{@@end example}
for pre-formatted text which is indented and typeset in typewriter
font.
@table @asis
@item Example:
@example
before example
@@example
in              example
notice extra identation and
escape of special characters like @@@{,@@@},@@@@
@@end example
after example
@end example
@expansion{}
@*before example
@example
in                example
notice extra identation  and
escape of special characters like @{,@},@@
@end example
after example
@item Note:
The characters @{,@},@@ have to be escaped by an @@ sign inside an
@@example environment.
@end table

@item @code{@@format}
 @code{...}
@item @code{@@end format}
for pre-formatted text which is not indented and typeset in normal
font.
@table @asis
@item Example:
@example
before format
@@format
in              format
no extra identation but still
escape of special characters like @@@{,@@@},@@@@
@@end format
after format
@end example
@expansion{}
@*before format
@format
in              format
no extra identation  but still
escape of special characters like @{,@},@@
@end format
after format
@item Note:
The characters @{,@},@@ have to be escaped by an @@ sign inside an
@@example environment.
@end table


@item @code{@@texinfo}
 @code{...}
@item @code{@@end texinfo}
for text which is written in pure texinfo.
@table @asis
@item Example:
@example
@@texinfo
Among others, within a texinfo environment
one can use the tex environment to typeset
more complex mathematical like
@@tex
$i_@{1,1@} $
@@tex
@@end texinfo
@end example
@*@expansion{}
@*Among others, within a texinfo environment one can use the tex environment
to typeset more complex mathematical like
@tex
$ i_{1,1} $
@end tex
@end table

@end table

Furthermore, a line-break is inserted in front of each line
whose previous line is shorter than 60
characters and does not contain any of the above described recognized
texinfo markup elements.
@end itemize

See also @ref{template_lib} for an examples of the typesetting rules
explained here.

@c ----------------------------------------
@node The help string of a library, The help string of procedures, Typesetting of help strings, Guidelines for writing a library
@subsection The help string of a library
@cindex help string of a library
@cindex library, help string
@cindex library, info string
@cindex info string of a library

The help (or, info) string of a library should have the following format:

@smallexample
info="
LIBRARY: <library_name> <one line description of the content>
AUTHOR:  <name, and email address of author>
[SEE ALSO: <comma-separated words of cross references>]
[KEYWORDS: <semicolon-separated phrases of index keys>]
PROCEDURES:
  <procedure1>;     <one line description of the purpose>
   .
   .
  <procedureN>;     <one line description of the purpose>
";
@end smallexample
Only such procedures should be listed in the @code{PROCEDURE} section
which are not @code{static} and which
have a help and example section.

The purpose of the one line procedure descriptions is not to give a short help
for the procedure, but to help the user decide what procedure might be
the right one for the job. Details can then be found in the help section
of each procedure. Therefore parameters may be omitted or abbreviated if
necessary. If this description consists of only upper-case characters,
then it will be typeset in all lowercase characters in the manual.

For more information, see @ref{Typesetting of help strings}. For an
example, see @ref{template_lib}.


@c ----------------------------------------
@node The help string of procedures, template_lib, The help string of a library, Guidelines for writing a library
@subsection The help string of procedures
@cindex help string of a procedure
@cindex procedures, help string

The help string of a procedure should have the following format:

@smallexample
USAGE:    <proc_name>(<parameters>);   <explanation of parameters>
[CREATE:  <description of created objects which are not returned>]
RETURN:   <description of the purpose and return value>
[NOTE:    <particular assumptions or limitations, details>]
[SEE ALSO: <comma-separated names of related procedures/cross references>]
[KEYWORDS: <semicolon-separated phrases of index keys>]
EXAMPLE:  example <proc_name>; shows an example
@end smallexample

Further arbitrary items (like @code{THEORY:}, or @code{BACKGROUND:}) are
recognized, as well, but should be used diligently.

Remember that help strings are formatted as explained in
@ref{Typesetting of help strings}. In particular, descriptions may
contain the texinfo markup elements @code{@@*, @@math@{..@},
@@code@{..@}, @@example, @@format, @@texinfo} to better control their
typesetting. See @ref{msum}, @ref{mdouble}, @ref{mtripple} for examples.

@c ----------------------------------------
@node template_lib,, The help string of procedures, Guidelines for writing a library
@subsection template_lib
@cindex template_lib
@cindex Template for writing a library
@cindex library, template

First, we show the source-code of a template library:
@smallexample
@c begin included file template.lib from general.doc:3933
////////////////////////////////////////////////////////////////////
// version string automatically expanded by CVS

version="Id: general.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   template.lib  A Template for a Singular Library
AUTHOR:    Olaf Bachmann, email: obachman@@mathematik.uni-kl.de

SEE ALSO:  standard_lib, Guidelines for writing a library,
           Typesetting of help strings

KEYWORDS: library, template.lib; template.lib; library, info string

PROCEDURES:
  mdouble(int)           return double of int argument
  mtripple(int)          return three times int argument
  msum([int,..,int])     sum of int arguments
";
////////////////////////////////////////////////////////////////////
proc mdouble(int i)
"USAGE:    mdouble(i); i int
RETURN:   int: i+i
NOTE:     Help string is in pure ASCII
          this line starts on a new line since previous line is short
          mdouble(i): no new line
SEE ALSO: msum, mtripple, Typesetting of help strings
KEYWORDS: procedure, ASCII help
EXAMPLE:  example mdouble; shows an example"
@{
  return (i + i);
@}
example
@{ "EXAMPLE:"; echo = 2;
  mdouble(0);
  mdouble(-1);
@}
////////////////////////////////////////////////////////////////////
proc mtripple(int i)
"@@c we do texinfo here
@@table @@asis
@@item @@strong@{Usage:@}
@@code@{mtripple(i)@}; @@code@{i@} int

@@item @@strong@{Return:@}
int: @@math@{i+i+i@}
@@item @@strong@{Note:@}
Help is in pure Texinfo
@@*This help string is written in texinfo, which enables you to use,
among others, the @@@@math command for mathematical typesetting (like
@@math@{\alpha, \beta@}).
@@*It also gives more control over the layout, but is, admittingly,
more cumbersome to write.
@@end table
@@c use @@c ref contstuct for references
@@cindex procedure, texinfo help
@@c ref
@@strong@{See also:@}
@@ref@{mdouble@}, @@ref@{msum@}, @@ref@{Typesetting of help strings@}
@@c ref
"
@{
  return (i + i + i);
@}
example
@{ "EXAMPLE:"; echo = 2;
  mtripple(0);
  mtripple(-1);
@}
////////////////////////////////////////////////////////////////////
proc msum(list #)
"USAGE:  msum([i_1,..,i_n]); @@code@{i_1,..,i_n@} def
RETURN:  Sum of int arguments
NOTE:    This help string is written in a mixture of ASCII and texinfo
         @@* Use a @@ref constructs for references (like @@pxref@{mtripple@})
         @@* Use @@code  for typewriter font (like @@code@{i_1@})
         @@* Use @@math  for simple math mode typesetting (like @@math@{i_1@}).
         @@* Note: No parenthesis like @} are allowed inside @@math and @@code
         @@* Use @@example for indented preformatted text typeset in typewriter
         font like
@@example
         this  --> that
@@end example
        Use @@format  for preformatted text typeset in normal font
@@format
         this --> that
@@end format
        Use @@texinfo for text in pure texinfo
@@texinfo
@@expansion@{@}
@@tex
$i_@{1,1@}$
@@end tex

@@end texinfo
        Notice that
        automatic linebreaking         is still in affect (like on this line).
SEE ALSO: mdouble, mtripple, Typesetting of help strings
KEYWORDS: procedure, ASCII/Texinfo help
EXAMPLE: example msum; shows an example"
@{
  if (size(#) == 0) @{ return (0);@}
  if (size(#) == 1) @{ return (#[1]);@}
  int i;
  def s = #[1];
  for (i=2; i<=size(#); i++)
  @{
    s = s + #[i];
  @}
  return (s);
@}
example
@{ "EXAMPLE:"; echo = 2;
  msum();
  msum(4);
  msum(1,2,3,4);
@}
@c end included file from general.doc:3933
@end smallexample

After typesetting, the library appears in the document as follows (with
one subsection for each procedure):

@c include of docu for template.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/template_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/template_lib.doc INSTEAD
@c library version: (1.10,2001/01/16)
@c library file: ../Singular/LIB/template.lib
@cindex template.lib
@cindex template_lib
@table @asis
@item @strong{Library:}
template.lib
@item @strong{Purpose:}
  A Template for a Singular Library
@item @strong{Author:}
Olaf Bachmann, email: obachman@@mathematik.uni-kl.de

@cindex library, template.lib
@cindex template.lib
@cindex library, info string
@end table

@strong{Procedures:}
@menu
* mdouble:: return double of int argument
* mtripple:: return three times int argument
* msum:: sum of int arguments
@end menu
@c inserted refs from d2t_singular/template_lib.doc:25
@menu
See also:
* Guidelines for writing a library::
* Typesetting of help strings::
* standard_lib::
@end menu
@c end inserted refs from d2t_singular/template_lib.doc:25

@c ---end content LibInfo---

@c ------------------- mdouble -------------
@node mdouble, mtripple,, template_lib
@subsubsection mdouble
@cindex mdouble
@c ---content mdouble---
Procedure from library @code{template.lib} (@pxref{template_lib}).

@table @asis
@item @strong{Usage:}
mdouble(i); i int

@item @strong{Return:}
int: i+i

@item @strong{Note:}
Help string is in pure ASCII
@*this line starts on a new line since previous line is short
mdouble(i): no new line

@cindex procedure, ASCII help
@end table
@strong{Example:}
@smallexample
@c computed example mdouble d2t_singular/template_lib.doc:54 
LIB "template.lib";
mdouble(0);
@expansion{} 0
mdouble(-1);
@expansion{} -2
@c end example mdouble d2t_singular/template_lib.doc:54
@end smallexample
@c inserted refs from d2t_singular/template_lib.doc:60
@menu
See also:
* Typesetting of help strings::
* msum::
* mtripple::
@end menu
@c end inserted refs from d2t_singular/template_lib.doc:60

@c ---end content mdouble---

@c ------------------- mtripple -------------
@node mtripple, msum, mdouble, template_lib
@subsubsection mtripple
@cindex mtripple
@c ---content mtripple---
Procedure from library @code{template.lib} (@pxref{template_lib}).

@c we do texinfo here
@table @asis
@item @strong{Usage:}
@code{mtripple(i)}; @code{i} int

@item @strong{Return:}
int: 
@math{i+i+i}
@tex
$i+i+i$
@end tex

@item @strong{Note:}
Help is in pure Texinfo
@*This help string is written in texinfo, which enables you to use,
among others, the @@math command for mathematical typesetting (like

@math{\alpha, \beta}
@tex
$\alpha, \beta$
@end tex
).
@*It also gives more control over the layout, but is, admittingly,
more cumbersome to write.
@end table
@c use @c ref contstuct for references
@cindex procedure, texinfo help
@c inserted refs from d2t_singular/template_lib.doc:90
@menu
@strong{See also:}
* Typesetting of help strings::
* mdouble::
* msum::
@end menu
@c end inserted refs from d2t_singular/template_lib.doc:90

@strong{Example:}
@smallexample
@c computed example mtripple d2t_singular/template_lib.doc:97 
LIB "template.lib";
mtripple(0);
@expansion{} 0
mtripple(-1);
@expansion{} -3
@c end example mtripple d2t_singular/template_lib.doc:97
@end smallexample
@c ---end content mtripple---

@c ------------------- msum -------------
@node msum,, mtripple, template_lib
@subsubsection msum
@cindex msum
@c ---content msum---
Procedure from library @code{template.lib} (@pxref{template_lib}).

@table @asis
@item @strong{Usage:}
msum([i_1,..,i_n]); @code{i_1,..,i_n} def

@item @strong{Return:}
Sum of int arguments

@item @strong{Note:}
This help string is written in a mixture of ASCII and texinfo
@* Use a @@ref constructs for references (like @pxref{mtripple})
@* Use @@code for typewriter font (like @code{i_1})
@* Use @@math for simple math mode typesetting (like 
@math{i_1}
@tex
$i_1$
@end tex
).
@* Note: No parenthesis like @} are allowed inside @@math and @@code
@* Use @@example for indented preformatted text typeset in typewriter
font like
@smallexample
         this  --> that
@end smallexample
Use @@format for preformatted text typeset in normal font
@format
         this --> that
@end format
Use @@texinfo for text in pure texinfo

@expansion{}
@tex
$i_{1,1}$
@end tex


Notice that
@*automatic linebreaking is still in affect (like on this line).

@cindex procedure, ASCII/Texinfo help
@end table
@strong{Example:}
@smallexample
@c computed example msum d2t_singular/template_lib.doc:149 
LIB "template.lib";
msum();
@expansion{} 0
msum(4);
@expansion{} 4
msum(1,2,3,4);
@expansion{} 10
@c end example msum d2t_singular/template_lib.doc:149
@end smallexample
@c inserted refs from d2t_singular/template_lib.doc:156
@menu
See also:
* Typesetting of help strings::
* mdouble::
* mtripple::
@end menu
@c end inserted refs from d2t_singular/template_lib.doc:156

@c ---end content msum---

@c ----------------------------------------------------------------------
@node Debugging tools,  , Guidelines for writing a library, General concepts
@section Debugging tools
@cindex Debugging tools

If @sc{Singular} does not come back to the prompt while calling a user
defined procedure, probably a bracket or a @code{"} is missing.  The
easiest way to leave the procedure is to type some brackets or @code{"}
and then @key{RETURN} .

@menu
* Tracing of procedures::
* Source code debugger::
* Break points::
* Printing of data::
* libparse::
@end menu

@c ---------------------------------------
@node Tracing of procedures,Source code debugger,Debugging tools,Debugging tools
@subsection Tracing of procedures
Setting the @code{TRACE} variable to 1 (resp.@: 3) results in a listing of
the called procedures (resp.@: together with line numbers).
If @code{TRACE} is set to 4, @code{Singular}
displays each line before its interpretation and waits for the @key{RETURN}
key being pressed.
@menu
* TRACE var::
@end menu

@strong{Example:}
@smallexample
@c computed example Tracing_of_procedures general.doc:3976 
  proc t1
  @{
    int i=2;
    while (i>0)
    @{ i=i-1; @}
  @}
  TRACE=3;
  t1();
@expansion{} 
@expansion{} entering t1 (level 0)
@expansion{} @{1@}@{2@}@{3@}@{4@}@{5@}@{4@}@{5@}@{6@}@{7@}@{4@}@{5@}@{6@}@{7@}@{4@}@{6@}@{7@}@{8@}
@expansion{} leaving  t1 (level 0)
@c end example Tracing_of_procedures general.doc:3976
@end smallexample

@c ---------------------------------------
@node Source code debugger, Break points, Tracing of procedures, Debugging tools
@subsection Source code debugger
@cindex debugging library code
@cindex source code debugger, sdb
@cindex debugger
@cindex sdb, source code debugger


The source code debugger (sdb) is an experimental feature, it's
interface may change in future versions of Singular.  @*To enable the
use of the source code debugger @sc{Singular} has to be started with the
option @code{-d} or @code{--sdb} (see @ref{Command line options}).


@subsubheading sdb commands
Each sdb command consist of one character which may be followed by
a parameter.
@table @asis
@item @code{b}
print backtrace of calling stack
@item @code{c}
continue
@item @code{e}
edit the current procedure and reload it (current call will be aborted)
@* only available on UNIX systems
@item @code{h},@code{?}
display help screen
@item @code{n}
execute current line, sdb break at next line
@item @code{p} <identifier>
display type and value of the variable given by <identifier>
@item @code{Q}
quit this Singular session
@item @code{q} <flags>
quit debugger, set debugger flags(0,1,2)
@* 0: continue, disable the debugger
@* 1: continue
@* 2: throw an error, return to toplevel
@end table


@subsubheading Syntactical errors in procedures
If @sc{Singular} was started with the command line option @code{-d} or
@code{--sdb} a syntactical error in a procedure will start the
source code debugger instead of returning to the top level with an
error message. The commands @code{q 1} and @code{q 2} are equivalent in this
case.

@subsubheading SDB breakpoints in procedures
@cindex SDB breakpoint
@cindex SDB debugger
Up to seven SDB breakpoints can be set.
To set a breakpoint at a procedure use
@code{breakpoint}. (See @ref{breakpoint}).
@*These breakpoints can be cleared with the command @code{d breakpoint_no}
from within the debugger or with
@code{breakpoint(} proc_name @code{,-1);}.


@c ---------------------------------------
@node Break points, Printing of data, Source code debugger, Debugging tools
@subsection Break points
A break point can be put into a proc by inserting the command @code{~}.
If @code{Singular} reaches a break point it asks for lines of commands
(line-length must be less than 80 characters)
from the user. It returns to normal execution if given an empty line.
See @ref{~}.


@strong{Example:}
@smallexample
proc t
@{
  int i=2;
  ~;
  return(i+1);
@}
t();
@expansion{} -- break point in t --
@expansion{} -- 0: called    from STDIN --
i;               // here local variables of the procedure can be accessed
@expansion{} 2
@expansion{} -- break point in t --

@expansion{} 3
@end smallexample
@sp 2

@c ---------------------------------------
@node Printing of data,libparse,Break points,Debugging tools
@subsection Printing of data
The procedure @code{dbprint} is useful for optional output of data:
it takes 2 arguments and prints the second argument, if the first
argument is positive; it does nothing otherwise.
@menu
* dbprint::
* voice::
@end menu

@c ---------------------------------------
@node libparse,,Printing of data,Debugging tools
@subsection libparse
@cindex libparse

@code{libparse} is a stand-alone program contained in the @sc{Singular}
distribution (at the place where the @sc{Singular} executable program
resides), which cannot be called inside of @sc{Singular}. It is a
debugging tool for libraries which performs exactly the same checks as
the @code{LIB} command in @sc{Singular}, but generates more output during
parsing.  @code{libparse} is useful if an error
occurs while loading the library, but the whole block around the line
specified seems to be correct. In these situations the real error might
be hundreds of lines earlier in the library.

@strong{Usage:}
@*@code{libparse [options] singular-library}
@*@strong{Options:}
@table @asis
@item @code{-d} Debuglevel
increases the amount of output during parsing, where Debuglevel is an integer
between 0 and 4. Default is 0.
@item @code{-s}
turns on reporting about violations of unenforced syntax rules
@end table

The following syntax checks are performed in any case:
@itemize @bullet
@item counting of pairs of brackets @{,@} , [,] and (,)
    (number of @{ has to match number of @}, same for [,] and (,) ).
@item counting of "
    ( number of " must be even ).
@item general library syntax
    ( only LIB, static, proc (with parameters, help, body and example)
and comments, i.e // and @code{/* ... */}, are allowed).
@end itemize
Its output lists all procedures that have been parsed successfully:

@smallexample
$ libparse sample.lib
Checking library 'sample.lib'
  Library         function      line,start-eod line,body-eob  line,example-eoe
Version:0.0.0;
g Sample               tab line    9,  149-165   13,  271-298   14,  300-402
l Sample      internal_tab line   24,  450-475   25,  476-496    0,    0-496
@end smallexample

where the following abbreviations are used:
@itemize @bullet
@item g: global procedure (default)
@item l: static procedure, i.e., local to the library.
@end itemize

each of the following is the position of the byte in the library.
@itemize @bullet
@item start: begin of 'proc'
@item eod: end of parameters
@item body: start of procedure body '@{'
@item eob:  end of procedure body '@}'
@item example: position of 'example'
@item eoe: end of example '@}'
@end itemize

Hence in the above example, the first procedure of the library
sample.lib is user-accessible and its name is tab. The procedure
starts in line 9, at character 149. The head of the procedure
ends at character 165, the body starts in line 13 at character 271
and ends at character 298. The example section extends from line 14
character 300 to character 402.

The following example shows the result of a missing close-bracket @} in
line 26 of the library @code{sample.lib}.

@smallexample
LIB "sample.lib";
@expansion{}    ? Library sample.lib: ERROR occurred: in line 26, 497.
@expansion{}    ? missing close bracket '@}' at end of library in line 26.
@expansion{}    ? Cannot load library,... aborting.
@expansion{}    ? error occurred in STDIN line 1: `LIB "sample.lib";`
@end smallexample

@c ----------------------------------------------------------------------------
@node Data types, Functions and system variables, General concepts, Top
@chapter Data types
@cindex Data types
@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from types.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT types.doc INSTEAD
@comment Id: types.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the type definitions

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).


@cindex expression list
This chapter explains all data types of @sc{Singular} in
alphabetical order. For every type, there is a description of the
declaration syntax as well as information about how to build expressions
of certain types.

The term expression list in @sc{Singular} refers to any comma separated
list of expressions.

For the general syntax of a declaration see @ref{General command syntax}.

@menu
* def::
* ideal::
* int::
* intmat::
* intvec::
* link::
* list::
* map::
* matrix::
* module::
* number::
* poly::
* proc::
* qring::
* resolution::
* ring::
* string::
* vector::
@end menu

@c ---------------------------------------
@node def, ideal, Data types, Data types
@section def
@cindex def
@cindex untyped definitions

Objects may be defined without a specific type: they get their
type from the first assignment to them.
E.g., @code{ideal i=x,y,z; def j=i^2;} defines the ideal @code{i^2}
with the name @code{j}.

@strong{Note:} Unlike other assignments a ring as an untyped object
is not a copy but another reference to the same (possibly unnamed) ring.
This means that entries in one of these rings appear also in the other ones.
The following defines a ring @code{s} which is just another reference (or name)
for the basering @code{r}.

@smallexample
@c reused example def types.doc:78 
  ring r=32003,(x,y,z),dp;
  poly f = x;
  def s=basering;
  setring s;
  nameof(basering);
@expansion{} s
  listvar();
@expansion{} // s                    [0]  *ring
@expansion{} //      f                    [0]  poly
@expansion{} // r                    [0]  ring
@expansion{} // LIB                  [0]  string standard.lib
  poly g = y;
  kill f;
  listvar(r);
@expansion{} // r                    [0]  ring
@expansion{} // g                    [0]  poly
  ring t=32003,(u,w),dp;
  def rt=r+t;
  rt;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    u w 
@expansion{} //        block   3 : ordering C
@c end example def types.doc:78
@end smallexample

This reference to a ring with def is useful if the basering
is not local to the procedure (so it cannot be accessed by its name) but one
needs a name for it (e.g., for a use with @code{setring} or @code{map}).
@code{setring r;} does not work in this case, because
@code{r} may not be local to the procedure.

@menu
* def declarations::
@end menu

@c ------------------------------
@node def declarations,  , def, def
@subsection def declarations
@cindex def declarations

@table @strong
@item Syntax:
@code{def} name @code{=} expression @code{;}

@item Purpose:
defines an object of the same type as the right-hand side.

@item Default:
none

@item Note:
This is useful if the right-hand side may be of
variable type as a consequence of a computation (e.g., ideal or module or
matrix). It may also be used in procedures to give the basering a name which
is local to the procedure.

@item Example:
@smallexample
@c reused example def_declarations types.doc:127 
  def i=2;
  typeof(i);
@expansion{} int
@c end example def_declarations types.doc:127
@end smallexample
@end table

@c inserted refs from types.doc:134
@menu
See
* typeof::
@end menu
@c end inserted refs from types.doc:134

@c ---------------------------------------
@node ideal, int, def, Data types
@section ideal
@cindex ideal

Ideals are represented as lists of polynomials which generate the ideal.
Like polynomials they
can only be defined or accessed with respect to a basering.

@strong{Note:} @code{size} counts only the non-zero generators of an ideal
whereas @code{ncols} counts all generators.
@menu
* ideal declarations::
* ideal expressions::
* ideal operations::
* ideal related functions::
@end menu

@c ---------------------------------------
@node ideal declarations, ideal expressions, ideal, ideal
@subsection ideal declarations
@cindex ideal declarations

@table @strong
@item Syntax:
@code{ideal} name @code{=} list_of_poly_and_ideal_expressions @code{;}
@*@code{ideal} name @code{=} ideal_expression @code{;}

@item Purpose:
defines an ideal.

@item Default:
0

@item Example:
@smallexample
@c reused example ideal_declarations types.doc:175 
  ring r=0,(x,y,z),dp;
  poly s1 = x2;
  poly s2 = y3;
  poly s3 = z;
  ideal i =  s1, s2-s1, 0,s2*s3, s3^4;
  i;
@expansion{} i[1]=x2
@expansion{} i[2]=y3-x2
@expansion{} i[3]=0
@expansion{} i[4]=y3z
@expansion{} i[5]=z4
  size(i);
@expansion{} 4
  ncols(i);
@expansion{} 5
@c end example ideal_declarations types.doc:175
@end smallexample
@end table

@c ------------------------------
@node ideal expressions, ideal operations, ideal declarations, ideal
@subsection ideal expressions
@cindex ideal expressions

An ideal expression is:
@enumerate
@item
an identifier of type ideal
@item
a function returning ideal
@item
ideal expressions combined by the arithmetic operations
@code{+} or @code{*}
@item
a power of an ideal expression (operator @code{^} or @code{**})
@*Note that the computation of the product @code{i*i} involves
all products of generators of @code{i} while @code{i^2} involves
only the different ones, and is therefore faster.
@item
a type cast to ideal
@end enumerate

@*@strong{Example:}
@smallexample
@c reused example ideal_expressions types.doc:213 
  ring r=0,(x,y,z),dp;
  ideal m = maxideal(1);
  m;
@expansion{} m[1]=x
@expansion{} m[2]=y
@expansion{} m[3]=z
  poly f = x2;
  poly g = y3;
  ideal i = x*y*z , f-g, g*(x-y) + f^4 ,0, 2x-z2y;
  ideal M = i + maxideal(10);
  timer =0;
  i = M*M;
  timer;
@expansion{} 0
  ncols(i);
@expansion{} 505
  timer =0;
  i = M^2;
  ncols(i);
@expansion{} 505
  timer;
@expansion{} 0
  i[ncols(i)];
@expansion{} x20
  vector v = [x,y-z,x2,y-x,x2yz2-y];
  ideal j = ideal(v);
@c end example ideal_expressions types.doc:213
@end smallexample

@c ------------------------------
@node ideal operations, ideal related functions, ideal expressions, ideal
@subsection ideal operations
@cindex ideal operations

@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)

@item @code{*}
multiplication (with ideal, poly, vector, module; simplification in case of
multiplication with ideal)

@item @code{^}
exponentiation (by a non-negative integer)

@item ideal_expression @code{[} intvec_expression @code{]}
are polynomial generators of the ideal, index 1 gives the first generator.
@end table

@strong{Note:} For simplification of an ideal, see also @ref{simplify}.

@*@strong{Example:}
@smallexample
@c reused example ideal_operations types.doc:259 
  ring r=0,(x,y,z),dp;
  ideal I = 0,x,0,1;
  I;
@expansion{} I[1]=0
@expansion{} I[2]=x
@expansion{} I[3]=0
@expansion{} I[4]=1
  I + 0;    // simplification
@expansion{} _[1]=1
  ideal J = I,0,x,x-z;;
  J;
@expansion{} J[1]=0
@expansion{} J[2]=x
@expansion{} J[3]=0
@expansion{} J[4]=1
@expansion{} J[5]=0
@expansion{} J[6]=x
@expansion{} J[7]=x-z
  I * J;   //  multiplication with simplification
@expansion{} _[1]=1
  I*x;
@expansion{} _[1]=0
@expansion{} _[2]=x2
@expansion{} _[3]=0
@expansion{} _[4]=x
  vector V = [x,y,z];
  print(V*I);
@expansion{} 0,x2,0,x,
@expansion{} 0,xy,0,y,
@expansion{} 0,xz,0,z 
  ideal m = maxideal(1);
  m^2;
@expansion{} _[1]=x2
@expansion{} _[2]=xy
@expansion{} _[3]=xz
@expansion{} _[4]=y2
@expansion{} _[5]=yz
@expansion{} _[6]=z2
  ideal II = I[2..4];
  II;
@expansion{} II[1]=x
@expansion{} II[2]=0
@expansion{} II[3]=1
@c end example ideal_operations types.doc:259
@end smallexample

@c ------------------------------
@node ideal related functions,  , ideal operations, ideal
@subsection ideal related functions
@cindex ideal related functions

@table @code
@item char_series
irreducible characteristic series (see @ref{char_series})
@item coeffs
matrix of coefficients (see @ref{coeffs})
@item contract
contraction by an ideal (see @ref{contract})
@item diff
partial derivative (see @ref{diff})
@item degree
multiplicity, dimension and codimension of the ideal of leading terms (see @ref{degree})
@item dim
Krull dimension of basering modulo the ideal of leading terms (see @ref{dim})
@item eliminate
elimination of variables (see @ref{eliminate})
@item facstd
factorizing Groebner basis algorithm (see @ref{facstd})
@item factorize
ideal of factors of a polynomial (see @ref{factorize})
@item fglm
Groebner basis computation from a Groebner basis w.r.t.@: a different
ordering (see @ref{fglm})
@item finduni
computation of univariate polynomials lying in a zero dimensional ideal
(see @ref{finduni})
@item groebner
Groebner basis computation (a wrapper around @code{std,stdhilb,stdfglm},...)
(see @ref{groebner})
@item highcorner
computes the smallest monomial not contained in the ideal.
The ideal has to be zero-dimensional.
(see @ref{highcorner})
@item homog
homogenization with respect to a variable (see @ref{homog})
@item hilb
Hilbert series of a standard basis (see @ref{hilb})
@item indepSet
sets of independent variables of an ideal (see @ref{indepSet})
@item interred
interreduction of an ideal (see @ref{interred})
@item intersect
ideal intersection (see @ref{intersect})
@item jacob
ideal of all partial derivatives resp.@: jacobian matrix (see @ref{jacob})
@item jet
Taylor series up to a given order (see @ref{jet})
@item kbase
vector space basis of basering modulo ideal of leading terms
(see @ref{kbase})
@item koszul
Koszul matrix (see @ref{koszul})
@item lead
leading terms of a set of generators (see @ref{lead})
@item lift
lift-matrix (see @ref{lift})
@item liftstd
standard basis and transformation matrix computation (see @ref{liftstd})
@item lres
free resolution for homogeneous ideals (see @ref{lres})
@item maxideal
power of the maximal ideal at 0 (see @ref{maxideal})
@item minbase
minimal generating set of a homogeneous ideal, resp.@: module, or an ideal, resp.@: module, in a local ring
(see @ref{minbase})
@item minor
set of minors of a matrix (see @ref{minor})
@item modulo
represents
@tex
$(h1+h2)/h1 \cong h2/(h1 \cap h2)$
@end tex
(h1+h2)/h1=h2/(h1 intersect h2)
(see @ref{modulo})
@item mres
minimal free resolution of an ideal resp.@: module w.r.t. a minimal set of generators of the given ideal resp.@: module
(see @ref{mres})
@item mstd
standard basis and minimal generating set of an ideal (see @ref{mstd})
@item mult
multiplicity, resp.@: degree, of the ideal of leading terms (see @ref{mult})
@item ncols
number of columns (see @ref{ncols})
@item preimage
preimage under a ring map (see @ref{preimage})
@item qhweight
quasihomogeneous weights of an ideal (see @ref{qhweight})
@item quotient
ideal quotient (see @ref{quotient})
@item reduce
normalform with respect to a standard basis (see @ref{reduce})
@item res
free resolution of an ideal resp.@: module but not changing the given ideal resp.@: module
(see @ref{res})
@item simplify
simplify a set of polynomials (see @ref{simplify})
@item size
number of non-zero generators (see @ref{size})
@item sortvec
permutation for sorting ideals resp@:. modules (see @ref{sortvec})
@item sres
free resolution of a standard basis (see @ref{sres})
@item std
standard basis computation (see @ref{std})
@item stdfglm
standard basis computation with fglm technique (see @ref{stdfglm})
@item stdhilb
Hilbert driven standard basis computation (see @ref{stdhilb}
@item subst
substitute a ring variable (see @ref{subst})
@item syz
computation of the first syzygy module (see @ref{syz})
@item vdim
vector space dimension of basering modulo ideal of leading terms
(see @ref{vdim})
@item weight
optimal weights (see @ref{weight})
@end table

@c ---------------------------------------
@node int, intmat, ideal, Data types
@section int
@cindex int

Variables of type int represent the machine integers and are, therefore,
limited  in their range (e.g., the range is between
-2147483647 and 2147483647 on 32-bit machines). They are mainly used
to count things (dimension, rank, etc.),
in loops (see @ref{for}), and
to represent boolean values
(FALSE is represented by 0, every other value means TRUE, see
@ref{boolean expressions}).

Integers consist of a sequence of digits, possibly preceded by a sign.
A space is considered as a separator, so it is not allowed between digits.
A sequence of digits outside the allowed range is converted to the type
@code{number} if possible.

@menu
* int declarations::
* int expressions::
* int operations::
* boolean expressions::
* boolean operations::
* int related functions::
@end menu

@c ---------------------------------------
@node int declarations, int expressions, int, int
@subsection int declarations
@cindex int declarations

@table @strong
@item Syntax:
@code{int} name @code{=} int_expression @code{;}

@item Purpose:
defines an integer variable.

@item Default:
0

@item Example:
@smallexample
@c reused example int_declarations types.doc:447 
  int i = 42;
  int j = i + 3; j;
@expansion{} 45
  i = i * 3 - j; i;
@expansion{} 81
  int k;   // assigning the default value 0 to k
  k;
@expansion{} 0
@c end example int_declarations types.doc:447
@end smallexample
@end table

@c ------------------------------
@node int expressions, int operations, int declarations, int
@subsection int expressions
@cindex int expressions

An int expression is:
@enumerate
@item
a sequence of digits (if the number represented by this sequence is too
large to fit into the range of integers it is automatically
converted to the type number, if a basering is defined)
@item
an identifier of type int
@item
a function returning int
@item
int expressions combined by the arithmetic operations
@code{+}, @code{-}, @code{*}, @code{div}, @code{/},
@code{%} (@code{mod}), or @code{^}
@item a boolean expression
@item
a type cast to int
@end enumerate

@strong{Note:}
Variables of type int represent the compiler integers  and are, therefore,
limited  in their range (see @ref{Limitations}). If this range is too small
the expression must be converted to the type number over a ring with
characteristic 0.

@*@strong{Example:}
@smallexample
@c reused example int_expressions types.doc:489 
12345678901; // too large
@expansion{}    ? `12345678901` greater than 2147483647(max. integer representation)
@expansion{}    ? error occurred in line 1: `12345678901; // too large`
typeof(_);
@expansion{} none
ring r=0,x,dp;
12345678901;
@expansion{} 12345678901
typeof(_);
@expansion{} number
// Note: 11*13*17*100*200*2000*503*1111*222222
// returns a machine integer:
11*13*17*100*200*2000*503*1111*222222;
@expansion{} // ** int overflow(*), result may be wrong
@expansion{} // ** int overflow(*), result may be wrong
@expansion{} // ** int overflow(*), result may be wrong
@expansion{} // ** int overflow(*), result may be wrong
@expansion{} -1875651584
// using the type cast number for a greater allowed range
number(11)*13*17*100*200*2000*503*1111*222222;
@expansion{} 12075748128684240000000
ring rp=32003,x,dp;
12345678901;
@expansion{} 9603
typeof(_);
@expansion{} number
intmat m[2][2] = 1,2,3,4;
m;
@expansion{} 1,2,
@expansion{} 3,4 
m[2,2];
@expansion{} 4
typeof(_);
@expansion{} int
det(m);
@expansion{} -2
m[1,1] + m[2,1] == trace(m);
@expansion{} 0
! 0;
@expansion{} 1
1 and 2;
@expansion{} 1
intvec v = 1,2,3;
def d =transpose(v)*v;    // scalarproduct gives an 1x1 intvec
typeof(d);
@expansion{} intvec
int i = d[1];             // access the first (the only) entry in the intvec
ring rr=31,(x,y,z),dp;
poly f = 1;
i = int(f);               // cast to int
// Integers may be converted to constant  polynomials by an assignment,
poly g=37;
// define the constant polynomial g equal to the image of
// the integer 37 in the actual coefficient field, here it equals 6
g;
@expansion{} 6
@c end example int_expressions types.doc:489
@end smallexample

@c inserted refs from types.doc:526
@menu
See
* Type conversion and casting::
* number::
@end menu
@c end inserted refs from types.doc:526

@c ------------------------------
@node int operations, int related functions, int expressions, int
@subsection int operations
@cindex int operations
@cindex mod
@cindex div

@c remark: the following table should have style @asis, since the
@c   commas below should not by set in style @code.
@table @asis
@item @code{++}
changes its operand to its successor, is itself no int expression
@item @code{--}
changes its operand to its predecessor, is itself no int expression
@item @code{+}
addition
@item @code{-}
negation or subtraction
@item @code{*}
multiplication
@item @code{/}
integer division (omitting the remainder), rounding toward 0
@item @code{div}
integer division (omitting the remainder >= 0)
@item @code{%}
integer modulo (the remainder of the division @code{/})
@item @code{mod}
integer modulo (the remainder of the division @code{div}), always non-negative
@item @code{^}, @code{**}
exponentiation (exponent must be non-negative)
@item @code{<}, @code{>}, @code{<=}, @code{>=}, @code{==}, @code{<>}
comparison
@end table

@strong{Note:} An assignment @code{j=i++;} or @code{j=i--;} is not allowed,
in particular it does not change
the value of @code{j}, see @ref{Limitations}.

@c @strong{Note:} @code{/} might no longer be available in the future.

@*@strong{Example:}
@smallexample
@c reused example int_operations types.doc:574 
  int i=1;
  int j;
  i++; i;  i--; i;
@expansion{} 2
@expansion{} 1
  // ++ and -- do not return a value as in C, can not assign
  j = i++;
@expansion{} // ** right side is not a datum, assignment ignored
  // the value of j is unchanged
  j; i;
@expansion{} 0
@expansion{} 2
  i+2, 2-i, 5^2;
@expansion{} 4 0 25
  5 div 2, 8%3;
@expansion{} 2 2
  -5 div 2, -5 / 2, -5 mod 2, -5 % 2;
@expansion{} -3 -2 1 -1
  1<2, 2<=2;
@expansion{} 1 1
@c end example int_operations types.doc:574
@end smallexample

@c ------------------------------
@node int related functions, boolean expressions,int operations, int
@subsection int related functions
@cindex int related functions

@table @code
@item char
characteristic of the coefficient field of a ring (see @ref{char})
@item deg
degree of a poly resp.@: vector (see @ref{deg})
@item det
determinant (see @ref{det})
@item dim
Krull dimension of basering modulo ideal of leading terms, resp.@:
dimension of module of leading terms (see @ref{dim})
@item extgcd
Bezout representation of gcd (see @ref{extgcd})
@item find
position of a substring in a string (see @ref{find})
@item gcd
greatest common divisor (see @ref{gcd})
@item koszul
Koszul matrix (see @ref{koszul})
@item memory
memory usage (see @ref{memory})
@item mult
multiplicity of an ideal, resp.@: module, of leading terms (see @ref{mult})
@item ncols
number of columns (see @ref{ncols})
@item npars
number of ring parameters (see @ref{npars})
@item nrows
number of rows of a matrix, resp.@:
the rank of the free module where the vector or module lives
(see @ref{nrows})
@item nvars
number of ring variables (see @ref{nvars})
@item ord
degree of the leading term of a poly resp.@: vector (see @ref{ord})
@item par
n-th parameter of the basering (see @ref{par})
@item pardeg
degree of a number considered as a polynomial in the ring parameters (see @ref{pardeg})
@item prime
the next lower prime (see @ref{prime})
@item random
a pseudo random integer between the given limits (see @ref{random})
@item regularity
regularity of a resolution (see @ref{regularity})
@item rvar
test, if the given expression or string is a ring variable (see @ref{rvar})
@item size
number of elements in an object (see @ref{size})
@item trace
trace of an integer matrix (see @ref{trace})
@item var
n-th ring variable of the basering (see @ref{var})
@item vdim
vector space dimension of basering modulo ideal of leading terms,
resp.@: of freemodule modulo module of leading terms (see @ref{vdim})
@end table

@c ------------------------------
@node boolean expressions, boolean operations, int related functions, int
@subsection boolean expressions
@cindex boolean expressions
@cindex ==
@cindex !=
@cindex <>
@cindex <=
@cindex >=

A boolean expression is really an int expression used in a logical context:

@c item
@*An int expression (<> 0 evaluates to @emph{TRUE} (represented by 1),
0 represents @emph{FALSE}).

The following is the list of available comparisons of objects of the same type.

@strong{Note:} There are no comparisons for ideals and modules, resolution
and maps.

@enumerate
@item
an integer comparison:
@smallexample
  i == j
  i != j    // or     i <> j
  i <= j
  i >= j
  i > j
  i < j
@end smallexample
@item
a number comparison:
@smallexample
  m == n
  m != n    // or     m <> n
  m < n
  m > n
  m <= n
  m >= n
@end smallexample
For numbers from Z/p or from field extensions not all operations are useful:
@* - 0 is always the smallest element,
@* - in Z/p the representatives in the range -(p-1)/2..(p-1)/2 when p>2 resp.
     0 and 1 for p=2 are used for comparisons,
@* - in field extensions the last two operations
(@code{>=,<=}) yield always TRUE (1) and
the @code{<} and @code{>} are equivalent to @code{!=}.
@item
a polynomial or vector comparison:
@smallexample
  f == g
  f != g    // or     f <> g
  f <= g    // comparing the leading term w.r.t. the monomial order
  f <  g
  f >= g
  f >  g
@end smallexample
@item
an intmat or matrix comparison:
@smallexample
  v == w
  v != w    // or     v <> w
@end smallexample
@item
an intvec or  string comparison:
@smallexample
  f == g
  f != g    // or     f <> g
  f <= g    // comparing lexicographically
  f >= g    // w.r.t. the order specified by ASCII
  f >  g
  f <  g
@end smallexample
@item
boolean expressions combined by boolean operations (@code{and},
@code{or}, @code{not})
@end enumerate

@strong{Note:}
@c ------------------------------------------------------------
@c   This piece of text exists also in the file singular.doc,
@c   chapter "Evaluation of logical expressions".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
All arguments of a logical expression are first evaluated and
then the value of the logical expression is determined. For example, the
logical expression @code{(a || b)} is evaluated by first evaluating
@code{a} @emph{and} @code{b}, even though the value of @code{b} has no
influence on the value of @code{(a || b)}, if @code{a} evaluates to
true.

Note that this evaluation is different from the left-to-right, conditional
evaluation of logical expressions (as found in most programming
languages). For example, in these other languages, the value of @code{(1
|| b)} is determined without ever evaluating @code{b}.

See @ref{Major differences to the C programming language}.

@c ------------------------------
@node boolean operations, , boolean expressions, int
@subsection boolean operations
@cindex boolean operations
@cindex and
@cindex &&
@cindex or
@cindex ||
@cindex not

@table @code
@item and
logical @code{and}, may also be written as @code{&&}

@item or
logical @code{or}, may also be written as @code{||}

@item not
logical @code{not}, may also be written as @code{!}
@end table

The precedence of the boolean operations is:

@enumerate
@item parentheses
@item comparisons
@item not
@item and
@item or
@end enumerate

@*@strong{Example:}
@smallexample
@c reused example boolean_operations types.doc:784 
  (1>2) and 3;
@expansion{} 0
  1 > 2 and 3;
@expansion{} 0
  ! 0 or 1;
@expansion{} 1
  !(0 or 1);
@expansion{} 0
@c end example boolean_operations types.doc:784
@end smallexample

@c ---------------------------------------
@node intmat, intvec, int, Data types
@section intmat
@cindex intmat

Integer matrices are matrices with integer entries. For the range of
integers see @ref{Limitations}. Integer matrices do not belong to a
ring, they may be defined without a basering being defined. An intmat
can be multiplied by and added to an int; in this case the int is
converted into an intmat of the right size with the integer on the
diagonal. The integer @code{1}, for example, is converted into the unit
matrix.

@menu
* intmat declarations::
* intmat expressions::
* intmat type cast::
* intmat operations::
* intmat related functions::
@end menu

@c ------------------------------
@node intmat declarations, intmat expressions, intmat, intmat
@subsection intmat declarations
@cindex intmat declarations

@table @strong
@item Syntax:
@code{intmat} name @code{=} intmat_expression @code{;}
@*@code{intmat} name @code{[} rows @code{] [} cols @code{] =} intmat_expression @code{;}
@*@code{intmat} name @code{[} rows @code{] [} cols @code{] =} list_of_int_and_intvec_and_intmat_expressions @code{;}
@*rows and cols must be positive int expressions.

@item Purpose:
defines an intmat variable.
@* Given a list of integers, the matrix is filled up with the first row
from the left to the right, then the second row and so on.
If the int_list contains less than rows*cols elements,
the matrix is filled up with zeros; if it contains more
elements, only the first rows*cols elements are used.

@item Default:
0 (1 x 1 matrix)

@item Example:
@smallexample
@c reused example intmat_declarations types.doc:838 
  intmat im[3][5]=1,3,5,7,8,9,10,11,12,13;
  im;
@expansion{} 1,3,5,7,8,
@expansion{} 9,10,11,12,13,
@expansion{} 0,0,0,0,0 
  im[3,2];
@expansion{} 0
  intmat m[2][3] = im[1..2,3..5];  // defines a submatrix
  m;
@expansion{} 5,7,8,
@expansion{} 11,12,13 
@c end example intmat_declarations types.doc:838
@end smallexample
@end table

@c ------------------------------
@node intmat expressions, intmat type cast, intmat declarations, intmat
@subsection intmat expressions
@cindex intmat expressions

An intmat expression is:
@enumerate
@item
an identifier of type intmat
@item
a function returning intmat
@item
intmat operations with int (@code{+}, @code{-}, @code{*}, @code{div}, @code{%})
@item
intmat operations (@code{+}, @code{-}, @code{*})
@item
a type cast to intmat (@pxref{intmat type cast})
@end enumerate

@*@strong{Example:}
@smallexample
@c reused example intmat_expressions types.doc:869 
  intmat Idm[2][2];
  Idm +1;          // add the unit intmat
@expansion{} 1,0,
@expansion{} 0,1 
  intmat m1[3][2] = _,1,-2;  // take entries from the last result
  m1;
@expansion{} 1,0,
@expansion{} 0,1,
@expansion{} 1,-2 
  intmat m2[2][3]=1,0,2,4,5,1;
  transpose(m2);
@expansion{} 1,4,
@expansion{} 0,5,
@expansion{} 2,1 
  intvec v1=1,2,4;
  intvec v2=5,7,8;
  m1=v1,v2;         // fill m1 with v1 and v2
  m1;
@expansion{} 1,2,
@expansion{} 4,5,
@expansion{} 7,8 
  trace(m1*m2);
@expansion{} 56
@c end example intmat_expressions types.doc:869
@end smallexample
@c inserted refs from types.doc:883
@menu
See
* Type conversion and casting::
* number::
@end menu
@c end inserted refs from types.doc:883

@c ------------------------------
@node intmat type cast,  intmat operations, intmat expressions, intmat
@subsection intmat type cast
@cindex intmat type cast
@table @code
@item @strong{Syntax:}
@code{intmat (} expression @code{)}
@*@code{intmat (} expression, int_n, int_m  @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
Converts expression to an intmat, where expression must be of type
intvec, or intmat. If
int_n and int_m are supplied, then they specify the dimension of the
intmat. Otherwise, the size (resp.@: dimensions) of the intmat
are determined  by the size (resp.@: dimensions) of the
expression.
@item @strong{Example:}
@smallexample
@c reused example intmat_type_cast types.doc:908 
  intmat(intvec(1));
@expansion{} 1 
  intmat(intvec(1), 1, 2);
@expansion{} 1,0 
  intmat(intvec(1,2,3,4), 2, 2);
@expansion{} 1,2,
@expansion{} 3,4 
  intmat(_, 2, 3);
@expansion{} 1,2,3,
@expansion{} 4,0,0 
  intmat(_, 2, 1);
@expansion{} 1,
@expansion{} 2 
@c end example intmat_type_cast types.doc:908
@end smallexample
@end table
@c inserted refs from types.doc:917
@menu
See
* Type conversion and casting::
* intmat::
* matrix type cast::
@end menu
@c end inserted refs from types.doc:917
@c ------------------------------
@node intmat operations, intmat related functions, intmat type cast, intmat
@subsection intmat operations
@cindex intmat operations

@table @asis
@item @code{+}
addition with intmat or int; the int is converted into a diagonal intmat

@item @code{-}
negation or subtraction with intmat or int; the int is converted into a
diagonal intmat

@item @code{*}
multiplication with intmat, intvec, or int; the int is converted into a
diagonal intmat

@item @code{div,/}
division of entries in the integers (omitting the remainder)
@item @code{%, mod}
entries modulo int (remainder of the division)
@item @code{<>}, @code{==}
comparison

@item intmat_expression @code{[} intvec_expression@code{,} intvec_expression @code{]}
is an intmat entry, where the first index indicates the row and the
second the column
@end table

@*@strong{Example:}
@smallexample
@c reused example intmat_operations types.doc:954 
  intmat m[2][4] = 1,0,2,4,0,1,-1,0,3,2,1,-2;
  m;
@expansion{} 1,0,2,4,
@expansion{} 0,1,-1,0 
  m[2,3];          // entry at row 2, col 3
@expansion{} -1
  size(m);         // number of entries
@expansion{} 8
  intvec v = 1,0,-1,2;
  m * v;
@expansion{} 7,1
  typeof(_);
@expansion{} intvec
  intmat m1[4][3] = 0,1,2,3,v,1;
  intmat m2 = m * m1;
  m2;             //  2 x 3 intmat
@expansion{} -2,5,4,
@expansion{} 4,-1,-1 
  m2*10;           // multiply each entry of m with 10;
@expansion{} -20,50,40,
@expansion{} 40,-10,-10 
  -m2;
@expansion{} 2,-5,-4,
@expansion{} -4,1,1 
  m2 % 2;
@expansion{} 0,1,0,
@expansion{} 0,1,1 
  m2 div 2;
@expansion{} -1,2,2,
@expansion{} 2,-1,-1 
  m2[2,1];          // entry at row 2, col 1
@expansion{} 4
  m1[2..3,2..3];   // submatrix
@expansion{} 1 0 2 1
  m2[nrows(m2),ncols(m2)];      // the last entry of intmat m2
@expansion{} -1
@c end example intmat_operations types.doc:954
@end smallexample

@c ------------------------------
@node intmat related functions,  , intmat operations, intmat
@subsection intmat related functions
@cindex intmat related functions

@table @code
@item betti
Betti numbers of a free resolution (see @ref{betti})
@item det
determinant (see @ref{det})
@item ncols
number of cols (see @ref{ncols})
@item nrows
number of rows (see @ref{nrows})
@item random
create a pseudo random intmat (see @ref{random})
@item size
total number of entries (see @ref{size})
@item transpose
transpose of an intmat (see @ref{transpose})
@item trace
trace of an intmat (see @ref{trace})
@end table

@c ---------------------------------------
@node intvec, link, intmat, Data types
@section intvec
@cindex intvec

Variables of type intvec are lists of integers.  For the range of
integers see @ref{Limitations}. They may be used for simulating
sets of integers (and other sets if the intvec is used as an index set
for other objects). Addition and subtraction of an
intvec with an int or an intvec is done element-wise.
@c @example
@c @c example
@c   intvec iv=1,2,5,7;
@c   iv;
@c   iv[3];
@c   iv[7]=1;
@c   iv;
@c @c example
@c @end example

@menu
* intvec declarations::
* intvec expressions::
* intvec operations::
* intvec related functions::
@end menu

@c ------------------------------
@node intvec declarations, intvec expressions, intvec, intvec
@subsection intvec declarations
@cindex intvec declarations

@table @strong
@item Syntax:
@code{intvec} name @code{=} intvec_expression @code{;}
@*@code{intvec} name @code{=} list_of_int_and_intvec_expressions @code{;}

@item Purpose:
defines an intvec variable.
@* An intvec consists of an ordered list of integers.

@item Default:
0

@item Example:
@smallexample
@c reused example intvec_declarations types.doc:1045 
  intvec iv=1,3,5,7,8;
  iv;
@expansion{} 1,3,5,7,8
  iv[4];
@expansion{} 7
  iv[3..size (iv)];
@expansion{} 5 7 8
@c end example intvec_declarations types.doc:1045
@end smallexample
@end table

@c ------------------------------
@node intvec expressions, intvec operations, intvec declarations, intvec
@subsection intvec expressions
@cindex intvec expressions

An intvec expression is:
@enumerate
@item
a range: int expression @code{..} int expression
@item
a function returning intvec
@item
intvec operations with int (@code{+}, @code{-}, @code{*}, @code{/}, @code{%})
@item
intvec operations (@code{+}, @code{-})
@item
intvec operation with intmat (@code{*})
@item
a type cast to intvec
@end enumerate

@*@strong{Example:}
@smallexample
@c reused example intvec_expressions types.doc:1077 
  intvec v=-1,2;
  intvec w=v,v;         // concatenation
  w;
@expansion{} -1,2,-1,2
  w = -2..2,v,1;
  w;
@expansion{} -2,-1,0,1,2,-1,2,1
  intmat m[3][2] = 0,1,2,-2,3,1;
  m*v;
@expansion{} 2,-6,-1
  typeof(_);
@expansion{} intvec
  v = intvec(m);
  v;
@expansion{} 0,1,2,-2,3,1
  ring r;
  poly f = x2z + 2xy-z;
  f;
@expansion{} x2z+2xy-z
  v = leadexp(f);
  v;
@expansion{} 2,0,1
@c end example intvec_expressions types.doc:1077
@end smallexample

@c ------------------------------
@node intvec operations, intvec related functions, intvec expressions, intvec
@subsection intvec operations
@cindex intvec operations

@table @asis
@item @code{+}
addition with intvec or int (component-wise)

@item @code{-}
negation or subtraction with intvec or int (component-wise)

@item @code{*}
multiplication with int (component-wise)

@item @code{/}, @code{div}
division by int (component-wise)

@item  @code{%, mod}
modulo (component-wise)

@item  @code{<>}, @code{==}, @code{<=}, @code{>=}, @code{>}, @code{<}
comparison (done lexicographically)

@item intvec_expression @code{[} int_expression @code{]}
is an element of the intvec; the first element has index one.
@end table

@*@strong{Example:}
@smallexample
@c reused example intvec_operations types.doc:1126 
  intvec iv =  1,3,5,7,8;
  iv+1;               // add 1 to each entry
@expansion{} 2,4,6,8,9
  iv*2;
@expansion{} 2,6,10,14,16
  iv;
@expansion{} 1,3,5,7,8
  iv-10;
@expansion{} -9,-7,-5,-3,-2
  iv=iv,0;
  iv;
@expansion{} 1,3,5,7,8,0
  iv div 2;
@expansion{} 0,1,2,3,4,0
  iv+iv;              // component-wise addition
@expansion{} 2,6,10,14,16,0
  iv[size(iv)-1];     // last-1 entry
@expansion{} 8
  intvec iw=2,3,4,0;
  iv==iw;             // lexicographic comparison
@expansion{} 0
  iv < iw;
@expansion{} 1
  iv != iw;
@expansion{} 1
  iv[2];
@expansion{} 3
  iw = 4,1,2;
  iv[iw];
@expansion{} 7 1 3
@c end example intvec_operations types.doc:1126
@end smallexample

@c ------------------------------
@node intvec related functions,  , intvec operations, intvec
@subsection intvec related functions
@cindex intvec related functions

@table @code
@item hilb
returns Hilbert series as intvec (see @ref{hilb})
@item indepSet
sets of independent variables of an ideal (see @ref{indepSet})
@item leadexp
the exponent vector of the leading monomial (see @ref{leadexp})
@item nrows
number of rows (see @ref{nrows})
@item qhweight
returns quasihomogeneous weights (see @ref{qhweight})
@item size
length of the intvec (see @ref{size})
@item sortvec
permutation for sorting ideals/modules (see @ref{sortvec})
@item transpose
transpose of an intvec, returns an intmat (see @ref{transpose})
@item weight
returns weights for the weighted ecart method (see @ref{weight})
@end table

@c ---------------------------------------
@node link, list, intvec, Data types
@section link
@cindex link

@c {{{ section link }}}
Links are the communication channels of @sc{Singular}, i.e.,
something @sc{Singular} can write to and/or read from. Currently,
@sc{Singular} supports four different link types:
@itemize @bullet
@item ASCII links (see
@ref{ASCII links})

@item MPfile links (see
@ref{MPfile links})

@item MPtcp links (see
@ref{MPtcp links})

@item DBM links (see
@ref{DBM links})
@end itemize

@menu
* link declarations::
* link expressions::
* link related functions::
* ASCII links::
* MP links::
* DBM links::
@end menu

@c ------------------------------
@node link declarations, link expressions, link, link
@subsection link declarations
@cindex link declarations

@table @strong
@item Syntax:
@code{link} name @code{=} string_expression @code{;}

@item Purpose:
defines a new communication link.

@item Default:
none

@item Example:
@smallexample
@c Tim: Let's only do the read here once, doing it twice without closing
@c it first might be confusing
@c reused example link_declarations types.doc:1224 
  link l=":w example.txt";
  int i=22;          // cf. ASCII links for explanation
  string s="An int follows:";
  write(l,s,i);
  l;
@expansion{} // type : ASCII
@expansion{} // mode : w
@expansion{} // name : example.txt
@expansion{} // open : yes
@expansion{} // read : not ready
@expansion{} // write: ready
  close(l);          //
  read(l);
@expansion{} An int follows:
@expansion{} 22
@expansion{} 
  close(l);
@c end example link_declarations types.doc:1224
@end smallexample
@end table

@c ------------------------------
@node link expressions, link related functions, link declarations, link
@subsection link expressions
@cindex link expressions

A link expression is:
@enumerate
@item
an identifier of type link
@item
a string describing the link
@end enumerate

A link is described by a string which consists of two parts: a property
string followed by a name string. The property string describes the type
of the link (@code{ASCII}, @code{MPfile}, @code{MPtcp} or @code{DBM})
and the mode of the link (e.g., open for read, write or append). The name
string describes the filename of the link, resp.@: a network connection
for MPtcp links.

For a detailed format description of the link describing string see:

@menu
* ASCII links::
* MPfile links::
* MPtcp links::
* DBM links::
@end menu

@c ------------------------------
@node link related functions, ASCII links, link expressions, link
@subsection link related functions
@cindex link related functions

@table @code
@item close
closes a link (see @ref{close})
@item dump
generates a dump of all variables and their values (see @ref{dump})
@item getdump
reads a dump (see @ref{getdump})
@item open
opens a link (see @ref{open})
@item read
reads from a link (see @ref{read})
@item status
gets the status of a link (see @ref{status})
@item write
writes to a link (see @ref{write})
@item kill
closes and kills a link (see @ref{kill})
@end table

@c ------------------------------
@node ASCII links, MP links, link related functions, link
@subsection ASCII links
@cindex ASCII links

Via ASCII links data that can be converted to a string can be written
into files for storage or communication with other programs. The data is
written in plain ASCII format. The output format of polynomials is done
w.r.t@:. the value of the global variable @code{short} (see @ref{short}).
Reading from an ASCII link returns a string --- conversion into other data
is up to the user. This can be done, for example,
using the command @code{execute}
(see @ref{execute}).

The ASCII link describing string has to be one of the following:

@enumerate
@item @code{"ASCII: "} + filename
@*the mode (read or append) is set by the first @code{read} or
@code{write} command.
@item @code{"ASCII:r "} + filename
@*opens the file for reading.
@item @code{"ASCII:w "} + filename
@*opens the file for overwriting.
@item @code{"ASCII:a "} + filename
@*opens the file for appending.
@end enumerate

There are the following default values:
@itemize @bullet
@item the type @code{ASCII} may be omitted since ASCII links are the
default links.

@item if non of @code{r}, @code{w}, or @code{a} is specified, the mode of
the link is set by the first @code{read} or @code{write} command on the
link. If the first command is @code{write}, the mode is set to @code{a}
(append mode).

@item if the filename is omitted, @code{read} reads from stdin and
@code{write} writes to stdout.
@end itemize

Using these default rules, the string @code{":r temp"} describes a link
which is equivalent to the link @code{"ASCII:r temp"}: an ASCII link to
the file @code{temp} which is opened for reading. The string
@code{"temp"} describes an ASCII link to the file @code{temp}, where the
mode is set by the first @code{read} or @code{write} command. See also
the example below.

Note that the filename may contain a path. On Microsoft Windows
(resp.@: MS-DOS) platforms, names of a drive can precede the filename, but
must be started with a @code{//} (as in @code{//c/temp/ex}. An ASCII
link can be used either for reading or for writing, but not for both at
the same time. A @code{close} command must be used before a change of
I/O direction. Types without a conversion to @code{string} cannot be
written.

@*@strong{Example:}
@smallexample
@c reused example ASCII_links types.doc:1364 
  ring r=32003,(x,y,z),dp;
  link l=":w example.txt";     // type is ASCII, mode is overwrite
  l;
@expansion{} // type : ASCII
@expansion{} // mode : w
@expansion{} // name : example.txt
@expansion{} // open : no
@expansion{} // read : not ready
@expansion{} // write: not ready
  status(l, "open", "yes");    // link is not yet opened
@expansion{} 0
  ideal i=x2,y2,z2;
  write (l,1,";",2,";","ideal i=",i,";");
  status(l, "open", "yes");    // now link is open
@expansion{} 1
  status(l, "mode");           // for writing
@expansion{} w
  close(l);                    // link is closed
  write("example.txt","int j=5;");// data is appended to file
  read("example.txt");         // data is returned as string
@expansion{} 1
@expansion{} ;
@expansion{} 2
@expansion{} ;
@expansion{} ideal i=
@expansion{} x2,y2,z2
@expansion{} ;
@expansion{} int j=5;
@expansion{} 
  execute(read(l));            // read string is executed
@expansion{} 1
@expansion{} 2
@expansion{} // ** redefining i **
  close(l);                    // link is closed
@c end example ASCII_links types.doc:1364
@c  // dump vars overwriting previous file content:
@c  dump(":w example.txt");
@end smallexample

@c ------------------------------
@node MP links, DBM links, ASCII links, link
@subsection MP links
@cindex MP links

MP (Multi Protocol) links give the possibility to store and communicate
data in the binary MP format: Read and write access is very fast
compared to ASCII links. MP links can be established using files (link
type is @code{MPfile}) or using TCP sockets (link type is
@code{MPtcp}). All data (including such data that cannot be converted
to a string) can be written to an MP link. For ring-dependent data, a
ring description is written together with the data. Reading from an MP
link returns an expression (not a string) which was evaluated after the
read operation. If the expression read from an MP link is not from the
same ring as the current ring, then a @code{read} changes the current
ring.

Currently, MP links are only available on Unix platforms and data is
written without attributes (which is likely to change in future
versions). For a general description of MP, see
@code{http://symbolicnet.mcs.kent.edu/areas/mp.html}.

@menu
* MPfile links::
* MPtcp links::
@end menu

@c -------------------------------------------------------------
@node MPfile links, MPtcp links, MP links, MP links
@subsubsection MPfile links
@cindex MPfile links

MPfile links provide the possibility to store data in a file using the
binary MP format. Read and write operations are very fast compared to
ASCII links. Therefore, for storing large amounts of data, MPfile links
should be used instead of ASCII links. Unlike ASCII links, data read
from MPfile links is returned as expressions one at a time, and not as a
string containing the entire content of the file. Furthermore, ring-dependent
data is stored together with a ring description. Therefore,
reading ring-dependent data might change the current ring.

The MPfile link describing string has to be one of the following:

@enumerate
@item @code{"MPfile: "} + filename
@*the mode (read or append) is set by the first @code{read} or
@code{write} command.
@item @code{"MPfile:r "} + filename
@*opens the file for reading.
@item @code{"MPfile:w "} + filename
@*opens the file for overwriting.
@item @code{"MPfile:a "} + filename
@*opens the file for appending.
@end enumerate

There are the following default values:
@itemize @bullet
@item if none of @code{r}, @code{w}, or @code{a} is specified, the mode of
the link is set by the first @code{read} or @code{write} command on the
link. If the first command is @code{write}, the mode is set to @code{a}
(append mode).
@c Tim: You and I were right here: It is indeed append. Olaf
@end itemize

Note that the filename may contain a path. An MPfile link can be used
either for reading or for writing, but not for both at the same time. A
@code{close} command must be used before a change of I/O direction.

@*@strong{Example:}
@smallexample
@c reused example MPfile_links types.doc:1453 
  ring r;
  link l="MPfile:w example.mp"; // type=MPfile, mode=overwrite
  l;
@expansion{} // type : MPfile
@expansion{} // mode : w
@expansion{} // name : example.mp
@expansion{} // open : no
@expansion{} // read : not ready
@expansion{} // write: not ready
  ideal i=x2,y2,z2;
  write (l,1, i, "hello world");// write three expressions
  write(l,4);                   // append one more expression
  close(l);                     // link is closed
  // open the file for reading now
  read(l);                      // only first expression is read
@expansion{} 1
  kill r;                       // no basering active now
  def i = read(l);              // second expression
  // notice that current ring was set, the name was assigned
  // automatically
  listvar(ring);
@expansion{} // mpsr_r0              [0]  *ring
  def s = read(l);              // third expression
  listvar();
@expansion{} // s                    [0]  string hello world
@expansion{} // mpsr_r0              [0]  *ring
@expansion{} //      i                    [0]  ideal, 3 generator(s)
@expansion{} // l                    [0]  link
@expansion{} // LIB                  [0]  string standard.lib
  close(l);                     // link is closed
  dump("MPfile:w example.mp");  // dump everything to example.mp
  kill i, s;                    // kill i and s
  getdump("MPfile: example.mp");// get previous dump
  listvar();                    // got all variables and values back
@expansion{} // mpsr_r0              [0]  *ring
@expansion{} //      i                    [0]  ideal, 3 generator(s)
@expansion{} // s                    [0]  string hello world
@expansion{} // l                    [0]  link
@expansion{} // LIB                  [0]  string standard.lib
@c end example MPfile_links types.doc:1453
@end smallexample

@c -------------------------------------------------------------
@node MPtcp links,  , MPfile links, MP links
@subsubsection MPtcp links
@cindex MPtcp links

MPtcp links give the possibility to exchange data in the binary MP
format between two processes which may run on the same or on different
computers. MPtcp links can be opened in four different modes:

@table @code
@item listen
@sc{Singular} acts as a server.

@item connect
@sc{Singular} acts as a client.

@item launch
@sc{Singular} acts as a client, launching an application as server.

@item fork
@sc{Singular} acts as a client, forking another @sc{Singular} as
server.
@end table

The MPtcp link describing string has to be
@itemize @bullet
@item listen mode:
@enumerate
@item @code{"MPtcp:listen --MPport "} + portnumber
@end enumerate
@sc{Singular} becomes a server and waits at the port for a
connect call.
@item connect mode:
@enumerate 2
@item @code{"MPtcp:connect --MPport "} + portnumber
@item @code{"MPtcp:connect --MPhost "} + hostname + @code{" --MPport "} +
portnumber
@end enumerate
@sc{Singular} becomes a client and connects to a server waiting at
the host and port.
@item launch mode:
@enumerate 4
@item @code{"MPtcp:launch"}
@item @code{"MPtcp:launch --MPrsh "} + rsh
@item @code{"MPtcp:launch --MPrsh "} + rsh  + @code{" --MPhost "} +
hostname
@item @code{"MPtcp:launch --MPrsh "} + rsh  + @code{" --MPhost "} +
hostname + @code{" --MPapplication "} + application
@end enumerate
@sc{Singular} becomes a client and starts (launches) the application
using the specified remote shell command (default is
@code{ssh}) on a (possibly) different host (default is @code{localhost}
which then acts as a server.
@item fork mode:
@enumerate 8
@item @code{"MPtcp:fork"}
@end enumerate
@sc{Singular} becomes a client and forks another @sc{Singular} on the
same host which acts as a server.
@end itemize

There are the following default values:
@itemize @bullet
@item if none of @code{listen}, @code{connect}, @code{launch} or
@code{fork} is specified, the default mode is set to @code{fork}.

@item if no remote shell (rsh) command is specified, then the command
@code{ssh} is used.

@item if no application is specified (in mode @code{launch}) the default
application is the value of @code{system("Singular") + "-bq"}.
(This evaluates to the absolute path of the @sc{Singular} currently running
with the option @code{"-bq"} appended.)

@item if no hostname is specified the local host is used as default host.
@end itemize

To open an MPtcp link in launch mode, the application to launch must
either be given with an absolute pathname, or must be in a directory
contained in the search path. The launched application acts as a server,
whereas the @sc{Singular} that actually opened the link acts as a
client. @sc{Singular} automatically appends the command line arguments
"@code{--MPmode connect --MPhost} hostname @code{--MPport} portnumber"
to the command line of the server application. Both hostname and
portnumber are substituted by the values from the link
specification. The client "listens" at the given port until the server
application does a connect call. If @sc{Singular} is used as server
application it has to be started with the command line option @code{-b}.
Since launching is done using a remote shell command, the host on which
the application should run must have an entry in the @code{.rhosts}
file. Even the local machine must have an entry if applications are to
be launched locally.

If the MPtcp link is opened in fork mode a child of the current
@sc{Singular} is forked. All variables and their values are inherited by
the child. The child acts as a server whereas the @sc{Singular} that
actually opened the link acts as a client.

To arrange the evaluation of an expression by a server, the expression
must be quoted using the command @code{quote} (see @ref{quote}), so that
a local evaluation is prevented. Otherwise, the expression is evaluated
first, and the result of the evaluation is written, instead of the
expression which is to be evaluated.

If @sc{Singular} is in server mode, the value of the variable
@code{mp_ll} is the MPtcp link connecting to the client and
@sc{Singular} is in an infinite read-eval-write loop until the
connection is closed from the client side (by closing its connecting
link). Reading and writing is done to the link @code{mp_ll}: After an
expression is read, it is evaluated and the result of the evaluation is
written back.  That is, for each expression which was written to the
server, there is exactly one expression written back. This might be an
"empty" expression, if the evaluation on the server side does not return
a value.

MPtcp links should explicitly be opened before being used. MPtcp links
are bidirectional, i.e., can be be used for both, writing and
reading. Reading from an MPtcp link blocks until data was written to
that link. The @code{status} command can be used to check whether there
is data to read.

@*@strong{Example:}
@smallexample
@c reused example MPtcp_links types.doc:1601 
  LIB "general.lib"; // needed for "killall" command
  link l="MPtcp:launch";
  open(l); l;        // l is ready for writing but not for reading
@expansion{} // type : MPtcp
@expansion{} // mode : launch
@expansion{} // name : 
@expansion{} // open : yes
@expansion{} // read : not ready
@expansion{} // write: ready

  ring r; ideal i=x2+y,xyz+z,x2+y2;

  write (l,quote(std(eval(i))));   // std(i) is computed on server
  def j = read(l);j; // result of computation on server is read
@expansion{} j[1]=z
@expansion{} j[2]=y2-y
@expansion{} j[3]=x2+y2

  write(l, quote(getdump(mp_ll))); // server reads dump
  dump(l);           //  dump is written to server (includes proc's)
  read(l);           // result of previous write-command is read
  killall("not", "link"); killall("proc"); // kills everything, but links
@expansion{} // ** killing the basering for level 0

  write(l, quote(dump(mp_ll)));    // server writes dump
  getdump(l);        // dump is read from server
  read(l);           // result of previous write-command is read

  close(l);          // server is shut down
  listvar(all);      // same state as we had before "killall()"
@expansion{} // mpsr_r0              [0]  ring
@expansion{} // r                    [0]  *ring
@expansion{} //      j                    [0]  ideal, 3 generator(s)
@expansion{} //      i                    [0]  ideal, 3 generator(s)
@expansion{} // l                    [0]  link

  l = "MPtcp:";      // fork link declaration
  open(l); l;        // Notice that name is "parent"
@expansion{} // type : MPtcp
@expansion{} // mode : fork
@expansion{} // name : parent
@expansion{} // open : yes
@expansion{} // read : not ready
@expansion{} // write: ready

  write(l, quote(status(mp_ll, "name")));
  read(l);           // and name of forked link is "child"
@expansion{} child
  write(l,quote(i)); // Child inherited vars and their values
  read(l);
@expansion{} _[1]=x2+y
@expansion{} _[2]=xyz+z
@expansion{} _[3]=x2+y2
  close(l);          // shut down forked child
@c end example MPtcp_links types.doc:1601
@end smallexample

@c ------------------------------
@node DBM links,  , MP links, link
@subsection DBM links
@cindex DBM links

DBM links provide access to data stored in a data base.
Each entry in the data base consists of a (key_string,
value_string) pair. Such a pair can be inserted with the command
@code{write(}link@code{,} key_string@code{,} value_string@code{)}.  By
calling @code{write(}link@code{,} key_string@code{)}, the entry with key
key_string is deleted from the data base. The value of an entry is
returned by the command @code{read(}link@code{,}
key_string@code{)}. With only one argument, @code{read(}link@code{)}
returns the next key in the data base. Using this feature a
data base can be scanned in order to access all entries of the data base.

If a data base with name @code{name} is opened for writing for the first
time, two files (@code{name.pag} and @code{name.dir}), which contain the
data base, are automatically created.

The DBM link describing string has to be one of the following:

@enumerate
@item @code{"DBM: "} + name
@*opens the data base for reading (default mode).

@item @code{"DBM:r "} + name
@*opens the data base for reading.

@item @code{"DBM:rw "} + name
@*opens the data base for reading and writing.
@end enumerate

Note that @code{name} must be given without the suffix @code{.pag} or
@code{.dir}. The name may contain an (absolute) path.

@*@strong{Example:}
@smallexample
@c reused example DBM_links types.doc:1672 
  link l="DBM:rw example";
  write(l,"1","abc");
  write(l,"3","XYZ");
  write(l,"2","ABC");
  l;
@expansion{} // type : DBM
@expansion{} // mode : rw
@expansion{} // name : example
@expansion{} // open : yes
@expansion{} // read : ready
@expansion{} // write: ready
  close(l);
  // read all keys (till empty string):
  read(l);
@expansion{} 1
  read(l);
@expansion{} 3
  read(l);
@expansion{} 2
  read(l);
@expansion{} 
  // read data corresponding to key "1"
  read(l,"1");
@expansion{} abc
  // read all data:
  read(l,read(l));
@expansion{} abc
  read(l,read(l));
@expansion{} XYZ
  read(l,read(l));
@expansion{} ABC
  // close
  close(l);
@c end example DBM_links types.doc:1672
@end smallexample

@c ---------------------------------------
@node list, map, link, Data types
@section list
@cindex list

Lists are arrays whose elements can be of any type (including ring and
qring). If one element belongs to a ring the whole list belongs to that
ring. This applies also to the special list @code{#}. The expression
@code{list()} is the empty list.

Note that a list stores the objects itself and not the names.  Hence, if
@code{L} is a list, @code{L[1]} for example has no name.  A name, say
@code{R}, can be created for @code{L[1]} by @code{def R=L[1];}. To store
also the name of an object, say @code{r}, it can be added to the list
with @code{nameof(r);}. Rings and qrings may be objects of a list.

@strong{Note}: Unlike other assignments a ring as an element of a list
is not a copy but another reference to the same ring.

@menu
* list declarations::
* list expressions::
* list operations::
* list related functions::
@end menu

@c ------------------------------
@node list declarations, list expressions, list, list
@subsection list declarations
@cindex list declarations

@table @strong
@item Syntax:
@code{list} name @code{=} expression_list@code{;}
@*@code{list} name @code{=} list_expression@code{;}

@item Purpose:
defines a list (of objects of possibly different types).

@item Default:
empty list

@item Example:
@smallexample
@c reused example list_declarations types.doc:1739 
  list l=1,"str";
  l[1];
@expansion{} 1
  l[2];
@expansion{} str
  ring r;
  listvar(r);
@expansion{} // r                    [0]  *ring
  ideal i = x^2, y^2 + z^3;
  l[3] = i;
  l;
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    str
@expansion{} [3]:
@expansion{}    _[1]=x2
@expansion{}    _[2]=z3+y2
  listvar(r);     // the list l belongs now to the ring r
@expansion{} // r                    [0]  *ring
@expansion{} // l                    [0]  list, size: 3
@expansion{} // i                    [0]  ideal, 2 generator(s)
@c end example list_declarations types.doc:1739
@end smallexample
@end table

@c ------------------------------
@node list expressions, list operations, list declarations, list
@subsection list expressions
@cindex list expressions

A list expression is:
@enumerate
@item
the empty list @code{list()}
@item
an identifier of type list
@item
a function returning list
@item
list expressions combined by the arithmetic operation @code{+}
@item
a type cast to list
@end enumerate

@c inserted refs from types.doc:1772
@menu
See 
* Type conversion and casting::
@end menu
@c end inserted refs from types.doc:1772

@*@strong{Example:}
@smallexample
@c reused example list_expressions types.doc:1778 
  list l = "hello",1;
  l;
@expansion{} [1]:
@expansion{}    hello
@expansion{} [2]:
@expansion{}    1
  l = list();
  l;
@expansion{} empty list
  ring r =0,x,dp;
  factorize((x+1)^2);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x+1
@expansion{} [2]:
@expansion{}    1,2
  list(1,2,3);
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    3
@c end example list_expressions types.doc:1778
@end smallexample

@c ------------------------------
@node list operations, list related functions, list expressions, list
@subsection list operations
@cindex list operations

@table @asis
@item @code{+}
concatenation
@item @code{delete}
deletes one element from list, returns new list
@item @code{insert}
inserts or appends a new element to list, returns a new list
@item list_expression @code{[} int_expression @code{]}
is a list entry; the index 1 gives the first element.
@end table

@*@strong{Example:}
@smallexample
@c reused example list_operations types.doc:1807 
  list l1 = 1,"hello",list(-1,1);
  list l2 = list(1,2,3);
  l1 + l2;          // one new list
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    hello
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       1
@expansion{} [4]:
@expansion{}    1
@expansion{} [5]:
@expansion{}    2
@expansion{} [6]:
@expansion{}    3
  list l3 =_;
  l1,l2;            // two lists
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    hello
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       1
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    3
  l2[2];
@expansion{} 2
@c end example list_operations types.doc:1807
@end smallexample

@c ------------------------------
@node list related functions,  , list operations, list
@subsection list related functions
@cindex list related functions

@table @code
@item bareiss
returns a list of a matrix (lower triangular) and
of an intvec (permutations of columns, see @ref{bareiss})
@item betti
Betti numbers of a resolution (see @ref{betti})
@item delete
deletes an element from a list (see @ref{delete})
@item facstd
factorizing Groebner basis algorithm (see @ref{facstd})
@item factorize
list of factors of a polynomial (see @ref{factorize})
@item insert
inserts or appends a new element to a list (see @ref{insert})
@item lres
free resolution (see @ref{lres})
@item minres
minimize a free resolution (see @ref{minres})
@item mres
minimal free resolution of an ideal, resp.@: module w.r.t.
a minimal set of generators of the first module (see @ref{mres})
@item names
list of all user-defined variable names (see @ref{names})
@item res
free resolution of an ideal, resp.@: module (see @ref{res})
@item size
number of entries (see @ref{size})
@item sres
free resolution of an ideal, resp.@: module, given by a standard base (see @ref{sres})
@end table


@c ---------------------------------------
@node map, matrix, list, Data types
@section map
@cindex map

Maps are ring maps from a preimage ring into the basering.

@strong{Note:}
@itemize @bullet
@item
the target of a map is @strong{ALWAYS} the actual basering
@item
the preimage ring is stored "by name", that means, maps can only be
used in such contexts, where the name of the preimage ring can be
resolved (i.e., there might be problems for rings/maps defined in
subprocedures). See also @ref{Identifier resolution}, @ref{Names in
procedures}.
@end itemize

Maps between rings with different coefficient fields are
possible and listed below.

Canonically realized are
@itemize @bullet
@item
@tex
$Q \rightarrow  Q(a, \ldots)$
@end tex
Q -> Q(a,..)

@item
@tex
$Q \rightarrow R$
@end tex
Q -> R

@item
@tex
$Q \rightarrow  C$
@end tex
Q -> C

@item
@tex
$Z/p \rightarrow  (Z/p)(a, \ldots)$
@end tex
Z/p ->(Z/p)(a,...)

@item
@tex
$Z/p \rightarrow  GF(p^n)$
@end tex
Z/p -> GF(p^n)

@item
@tex
$Z/p \rightarrow  R$
@end tex
Z/p -> R

@item
@tex
$R \rightarrow C$
@end tex
R -> C
@end itemize

Possible are furthermore
@itemize @bullet
@item
@tex
% This is quite a hack, but for now it works.
$Z/p \rightarrow Q,
\quad
[i]_p \mapsto i \in [-p/2, \, p/2]
\subseteq Z$
@end tex
Z/p -> Q : [i]_p -> i in [-p/2, p/2] in Z
@item
@tex
$Z/p \rightarrow Z/p^\prime,
\quad
[i]_p \mapsto i \in [-p/2, \, p/2] \subseteq Z, \;
i \mapsto [i]_{p^\prime} \in Z/p^\prime$
@end tex
Z/p -> Z/p' : [i]_p in Z/p -> i in [-p/2,p/2] in Z, i -> [i]_p' in Z/p'
@item
@tex
$C \rightarrow R, \quad$ the real part
@end tex
C -> R : the real part
@end itemize

Finally, in Singular we allow the mapping from rings
with coefficient field Q to rings whose ground fields
have finite characteristic:

@itemize @bullet
@item
@tex
$Q \rightarrow Z/p$
@end tex
Q -> Z/p

@item
@tex
$Q \rightarrow (Z/p)(a, \ldots)$
@end tex
Q -> (Z/p)(a,..)
@end itemize
In these cases the denominator and the numerator
of a number are mapped separately by the usual
map from Z to Z/p, and the image of the number
is built again afterwards by division. It is thus
not allowed to map numbers whose denominator is
divisible by the characteristic of the target
ground field, or objects containing such numbers.
We, therefore, strongly recommend using such
maps only to map objects with integer coefficients.


@menu
* map declarations::
* map expressions::
* map operations::
* fetch::
* imap::
* subst::
@end menu

@c ------------------------------
@node map declarations, map expressions, map, map
@subsection map declarations
@cindex map declarations

@table @strong
@item Syntax:
@code{map} name @code{=} preimage_ring_name @code{,} ideal_expression @code{;}
@*@code{map} name @code{=} preimage_ring_name @code{,} list_of_poly_and_ideal_expressions @code{;}
@*@code{map} name @code{=} map_expression @code{;}

@item Purpose:
defines a ring map from preimage_ring to basering.
@* Maps the variables of the preimage ring to the generators of the ideal.
If the ideal contains less elements than variables in the
preimage_ring the remaining variables are mapped to 0, if the ideal contains
more elements these are ignored.
The image ring is always the actual basering.
For the mapping of coefficients from different fields see @ref{map}.

@item Default:
none

@item Note:
There are standard mappings for maps which are close to the identity
map: @code{fetch} and @code{imap}.

The name of a map serves as the function which maps objects from the
preimage_ring into the basering.  These objects must be defined
by names (no evaluation in the preimage ring is possible).

@item Example:
@smallexample
@c reused example map_declarations types.doc:2044 
  ring r1=32003,(x,y,z),dp;
  ideal i=x,y,z;
  ring r2=32003,(a,b),dp;
  map f=r1,a,b,a+b;
  // maps from r1 to r2,
  // x -> a
  // y -> b
  // z -> a+b
  f(i);
@expansion{} _[1]=a
@expansion{} _[2]=b
@expansion{} _[3]=a+b
  // operations like f(i[1]) or f(i*i) are not allowed
  ideal i=f(i);
  // objects in different rings may have the same name
  map g   = r2,a2,b2;
  map phi = g(f);
  // composition of map f and g
  // maps from r1 to r2,
  // x -> a2
  // y -> b2
  // z -> a2+b2
  phi(i);
@expansion{} _[1]=a2
@expansion{} _[2]=b2
@expansion{} _[3]=a2+b2
@c end example map_declarations types.doc:2044
@end smallexample
@end table

@c inserted refs from types.doc:2069
@menu
See 
* fetch::
* ideal expressions::
* imap::
* map::
* ring::
@end menu
@c end inserted refs from types.doc:2069

@c ------------------------------
@node map expressions, map operations, map declarations, map
@subsection map expressions
@cindex map expressions

A map expression is:
@enumerate
@item
an identifier of type map
@item
a function returning map
@item
map expressions combined by composition using parentheses (@code{(}, @code{)})
@end enumerate

@c ------------------------------
@node map operations,  , map expressions, map
@subsection map operations

@cindex map operations

@table @asis
@item @code{( )}
composition of maps. If, for example, @code{f} and @code{g} are maps,
then @code{f(g)} is a map expression giving the composition of @code{f}
and @code{g}.

@item map_expression @code{[} int_expressions @code{]}
is a map entry (the image of the corresponding variable)
@end table

@*@strong{Example:}
@smallexample
@c reused example map_operations types.doc:2107 
  ring r=0,(x,y),dp;
  map f=r,y,x;    // the map f permutes the variables
  f;
@expansion{} f[1]=y
@expansion{} f[2]=x
  poly p=x+2y3;
  f(p);
@expansion{} 2x3+y
  map g=f(f);    // the map g defined as  f^2 is the identity
  g;
@expansion{} g[1]=x
@expansion{} g[2]=y
  g(p) == p;
@expansion{} 1
@c end example map_operations types.doc:2107
@end smallexample

@c ---------------------------------------
@node matrix, module, map, Data types
@section matrix
@cindex matrix

Objects of type matrix are matrices with polynomial entries.
Like polynomials they can
only be defined or accessed with respect to a basering. In order to
compute with matrices having integer or rational entries define a ring
with characteristic 0 and at least one variable.

A matrix can be multiplied by and added to a poly; in this case the
poly is converted into a matrix of the right size with the poly on the
diagonal.

If A is a matrix then the assignment @code{module M=A;} or @code{module
M=module(A);} creates a module generated by the columns of A.  Note that
the trailing zero columns of A may be deleted by module operations with
M.

@menu
* matrix declarations::
* matrix expressions::
* matrix type cast::
* matrix operations::
* matrix related functions::
@end menu

@c ------------------------------
@node matrix declarations, matrix expressions, matrix, matrix
@subsection matrix declarations
@cindex matrix declarations

@table @strong
@item Syntax:
@code{matrix} name@code{[}rows@code{][}cols@code{] =} list_of_poly_expressions @code{;}
@*@code{matrix} name = matrix_expression @code{;}

@item Purpose:
defines a matrix (of polynomials).

The given poly_list fills up the matrix beginning with the first row
from the left to the right, then the second row and so on.
If the poly_list contains less than rows*cols elements,
the matrix is filled up with zeros; if it contains more
elements, then only the first rows*cols elements are used.
If the right-hand side is a matrix expression
the matrix on the left-hand side gets the same size as the right-hand side,
otherwise the size is determined by the left-hand side.
If the size is omitted a 1x1 matrix is created.

@item Default:
0 (1 x 1 matrix)

@item Example:
@smallexample
@c reused example matrix_declarations types.doc:2175 
  int ro = 3;
  ring r = 32003,(x,y,z),dp;
  poly f=xyz;
  poly g=z*f;
  ideal i=f,g,g^2;
  matrix m[ro][3] = x3y4, 0, i, f ; // a 3 x 3 matrix
  m;
@expansion{} m[1,1]=x3y4
@expansion{} m[1,2]=0
@expansion{} m[1,3]=xyz
@expansion{} m[2,1]=xyz2
@expansion{} m[2,2]=x2y2z4
@expansion{} m[2,3]=xyz
@expansion{} m[3,1]=0
@expansion{} m[3,2]=0
@expansion{} m[3,3]=0
  print(m);
@expansion{} x3y4,0,     xyz,
@expansion{} xyz2,x2y2z4,xyz,
@expansion{} 0,   0,     0   
  matrix A;   // the 1 x 1 zero matrix
  matrix B[2][2] = m[1..2, 2..3]; //defines a submatrix
  print(B);
@expansion{} 0,     xyz,
@expansion{} x2y2z4,xyz 
  matrix C=m; // defines C as a 3 x 3 matrix equal to m
  print(C);
@expansion{} x3y4,0,     xyz,
@expansion{} xyz2,x2y2z4,xyz,
@expansion{} 0,   0,     0   
@c end example matrix_declarations types.doc:2175
@end smallexample
@end table

@c ------------------------------
@node matrix expressions, matrix type cast, matrix declarations, matrix
@subsection matrix expressions
@cindex matrix expressions

A matrix expression is:
@enumerate
@item
an identifier of type matrix
@item
a function returning matrix
@item
matrix expressions combined by the arithmetic operations
@code{+}, @code{-} or @code{*}
@item
a type cast to matrix (@pxref{matrix type cast})
@end enumerate

@*@strong{Example:}
@smallexample
@c reused example matrix_expressions types.doc:2213 
  ring r=0,(x,y),dp;
  poly f= x3y2 + 2x2y2 +2;
  matrix H = jacob(jacob(f));    // the Hessian of f
  matrix mc = coef(f,y);
  print(mc);
@expansion{} y2,    1,
@expansion{} x3+2x2,2 
  module MD = [x+y,1,x],[x+y,0,y];
  matrix M = MD;
  print(M);
@expansion{} x+y,x+y,
@expansion{} 1,  0,  
@expansion{} x,  y   
@c end example matrix_expressions types.doc:2213
@end smallexample

@c ------------------------------
@node matrix type cast,  matrix operations, matrix expressions, matrix
@subsection matrix type cast
@cindex matrix type cast
@table @code
@item @strong{Syntax:}
@code{matrix (} expression @code{)}
@*@code{matrix (} expression, int_n, int_m  @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
Converts expression to a matrix, where expression must be of type int,
intmat, intvec, number, poly, ideal, vector, module, or matrix. If
int_n and int_m are supplied, then they specify the dimension of the
matrix. Otherwise, the size (resp.@: dimensions) of the matrix
are determined  by the size (resp.@: dimensions) of the
expression.
@item @strong{Example:}
@smallexample
@c reused example matrix_type_cast types.doc:2244 
  ring r=32003,(x,y,z),dp;
  matrix(x);
@expansion{} _[1,1]=x
  matrix(x, 1, 2);
@expansion{} _[1,1]=x
@expansion{} _[1,2]=0
  matrix(intmat(intvec(1,2,3,4), 2, 2));
@expansion{} _[1,1]=1
@expansion{} _[1,2]=2
@expansion{} _[2,1]=3
@expansion{} _[2,2]=4
  matrix(_, 2, 3);
@expansion{} _[1,1]=1
@expansion{} _[1,2]=2
@expansion{} _[1,3]=0
@expansion{} _[2,1]=3
@expansion{} _[2,2]=4
@expansion{} _[2,3]=0
  matrix(_, 2, 1);
@expansion{} _[1,1]=1
@expansion{} _[2,1]=3
@c end example matrix_type_cast types.doc:2244
@end smallexample
@end table
@c inserted refs from types.doc:2254
@menu
See
* Type conversion and casting::
* intmat type cast::
* matrix::
@end menu
@c end inserted refs from types.doc:2254
@c ------------------------------
@node matrix operations, matrix related functions, matrix type cast, matrix
@subsection matrix operations
@cindex matrix operations

@table @asis
@item @code{+}
addition with matrix or poly; the poly is converted into a diagonal
matrix

@item @code{-}
negation or subtraction with matrix or poly; the poly is converted into
a diagonal matrix

@item @code{*}
multiplication with matrix or poly; the poly is converted into a
diagonal matrix

@item @code{/}
division by poly

@item @code{==}, @code{<>}, @code{!=}
comparison

@item matrix_expression @code{[} int_expression@code{,} int_expression @code{]}
is a matrix entry, where the first index indicates the row and the
second the column
@end table

@*@strong{Example:}
@smallexample
@c reused example matrix_operations types.doc:2291 
  ring r=32003,x,dp;
  matrix A[3][3] = 1,3,2,5,0,3,2,4,5; // define a matrix
  print(A); // nice printing of small matrices
@expansion{} 1,3,2,
@expansion{} 5,0,3,
@expansion{} 2,4,5 
  A[2,3];   // matrix entry
@expansion{} 3
  A[2,3] = A[2,3] + 1; // change entry
  A[2,1..3] = 1,2,3;   // change 2nd row
  print(A);
@expansion{} 1,3,2,
@expansion{} 1,2,3,
@expansion{} 2,4,5 
  matrix E[3][3]; E = E + 1;  // the unit matrix
  matrix B =x*E - A;
  print(B);
@expansion{} x-1,-3, -2,
@expansion{} -1, x-2,-3,
@expansion{} -2, -4, x-5
  det(B);        // the characteristic polynomial of A
@expansion{} x3-8x2-2x-1
  A*A*A - 8 * A*A - 2*A == E;  // Cayley-Hamilton
@expansion{} 1
  vector v =[x,-1,x2];
  A*v; // multiplication of matrix and vector
@expansion{} _[1,1]=2x2+x-3
@expansion{} _[2,1]=3x2+x-2
@expansion{} _[3,1]=5x2+2x-4
  matrix m[2][2]=1,2,3;
  print(m-transpose(m));
@expansion{} 0,-1,
@expansion{} 1,0  
@c end example matrix_operations types.doc:2291
@end smallexample

@c ------------------------------
@node matrix related functions,  , matrix operations, matrix
@subsection matrix related functions
@cindex matrix related functions

@table @code
@item bareiss
Gauss-Bareiss algorithm (see @ref{bareiss})
@item coef
matrix of coefficients and monomials (see @ref{coef})
@item coeffs
matrix of coefficients (see @ref{coeffs})
@item det
determinant (see @ref{det})
@item diff
partial derivative (see @ref{diff})
@item jacob
Jacobi matrix (see @ref{jacob})
@item koszul
Koszul matrix (see @ref{koszul})
@item lift
lift-matrix (see @ref{lift})
@item liftstd
standard basis and transformation matrix computation (see @ref{liftstd})
@item minor
set of minors of a matrix (see @ref{minor})
@item ncols
number of columns (see @ref{ncols})
@item nrows
number of rows (see @ref{nrows})
@item print
nice print format (see @ref{print})
@item size
number of matrix entries (see @ref{size})
@item subst
substitute a ring variable (see @ref{subst})
@item trace
trace of a matrix (see @ref{trace})
@item transpose
transpose a matrix (see @ref{transpose})
@item wedge
wedge product (see @ref{wedge})
@end table

See also the library @ref{matrix_lib}, which contains more
matrix-related functions.

@c @*@strong{Example:}
@c @example
@c @end example

@c ---------------------------------------
@node module, number, matrix, Data types
@section module
@cindex module

Modules are submodules of a free module over the basering with basis
@code{gen(1)}, @code{gen(2)}, @dots{} .
They are represented by lists of vectors which generate the submodule.
Like vectors they
can only be defined or accessed with respect to a basering.
If 
@math{M}
@tex
$M$
@end tex
 is a submodule of
R^n,
@tex
$R^n$,
@end tex

@math{R}
@tex
$R$
@end tex
 the basering, generated by vectors
v_1, @dots{}, v_k, then v_1, @dots{}, v_k
@tex
$v_1, \ldots, v_k$, then $v_1, \ldots, v_k$
@end tex
may be considered as the generators of relations of
R^n/M
@tex
$R^n/M$
@end tex
between the canonical generators @code{gen(1)},@dots{},@code{gen(n)}.
Hence any finitely generated 
@math{R}
@tex
$R$
@end tex
-module can be represented in @sc{Singular}
by its module of relations. The assignments
@code{module M=v1,...,vk; matrix A=M;}
create the presentation matrix of size
n x k
@tex
n$\times$k
@end tex
 for
R^n/M,
@tex
R$^n$/M,
@end tex
i.e., the columns of A are the vectors
v_1, @dots{}, v_k
@tex
$v_1, \ldots, v_k$
@end tex
which generate M (cf. @ref{Representation of mathematical objects}).

@menu
* module declarations::
* module expressions::
* module operations::
* module related functions::
@end menu

@c ------------------------------
@node module declarations, module expressions, module, module
@subsection module declarations
@cindex module declarations

@table @strong
@item Syntax:
@code{module} name @code{=} list_of_vector_expressions @code{;}
@*@code{module} name @code{=} module_expression @code{;}

@item Purpose:
defines a module.

@item Default:
[0]

@item Example:
@smallexample
@c reused example module_declarations types.doc:2445 
  ring r=0,(x,y,z),(c,dp);
  vector s1 = [x2,y3,z];
  vector s2 = [xy,1,0];
  vector s3 = [0,x2-y2,z];
  poly   f  = xyz;
  module m = s1, s2-s1,f*(s3-s1);
  m;
@expansion{} m[1]=[x2,y3,z]
@expansion{} m[2]=[-x2+xy,-y3+1,-z]
@expansion{} m[3]=[-x3yz,-xy4z+x3yz-xy3z]
  // show m in matrix format (columns generate m)
  print(m);
@expansion{} x2,-x2+xy,-x3yz,          
@expansion{} y3,-y3+1, -xy4z+x3yz-xy3z,
@expansion{} z, -z,    0               
@c end example module_declarations types.doc:2445
@end smallexample
@end table

@c ------------------------------
@node module expressions, module operations, module declarations, module
@subsection module expressions
@cindex module expressions

A module expression is:
@enumerate
@item
an identifier of type module
@item
a function returning module
@item
module expressions combined by the arithmetic operation @code{+}
@item
multiplication of a module expression with an ideal or a poly expression: @code{*}
@item
a type cast to module
@end enumerate

@c inserted refs from types.doc:2478
@menu
See
* Type conversion and casting::
* ideal::
* poly::
* vector::
@end menu
@c end inserted refs from types.doc:2478

@c @*@strong{Example:}
@c @example
@c @c example
@c @c example
@c @end example

@c ------------------------------
@node module operations, module related functions, module expressions, module
@subsection module operations
@cindex module operations

@table @asis
@item @code{+}
addition (concatenation of the generators and simplification)

@item @code{*}
multiplication with ideal or poly, but not `module` * `module`

@item module_expression @code{[} int_expression @code{,} int_expression @code{]}
is a module entry, where the first index indicates the row and
the second the column

@item module_expressions @code{[} int_expression @code{]}
is a vector, where the index indicates the column
@end table

@*@strong{Example:}
@smallexample
@c reused example module_operations types.doc:2514 
  ring r=0,(x,y,z),dp;
  module m=[x,y],[0,0,z];
  print(m*(x+y));
@expansion{} x2+xy,0,   
@expansion{} xy+y2,0,   
@expansion{} 0,    xz+yz
@c end example module_operations types.doc:2514
@end smallexample

@c ------------------------------
@node module related functions,  , module operations, module
@subsection module related functions
@cindex module related functions

@table @code
@item coeffs
matrix of coefficients (see @ref{coeffs})
@item degree
multiplicity, dimension and codimension of the module of leading terms (see @ref{degree})
@item diff
partial derivative (see @ref{diff})
@item dim
Krull dimension of free module over the basering modulo the module of leading terms (see @ref{dim})
@item eliminate
elimination of variables (see @ref{eliminate})
@item freemodule
the free module of given rank (see @ref{freemodule})
@item groebner
Groebner basis computation (a wrapper around @code{std,stdhilb,stdfglm},...)
(see @ref{groebner})
@item hilb
Hilbert function of a standard basis (see @ref{hilb})
@item homog
homogenization with respect to a variable (see @ref{homog})
@item interred
interreduction of a module (see @ref{interred})
@item intersect
module intersection (see @ref{intersect})
@item jet
Taylor series up to a given order (see @ref{jet})
@item kbase
vector space basis of free module over the basering modulo the module of
leading terms (see @ref{kbase})
@item lead
initial module (see @ref{lead})
@item lift
lift-matrix (see @ref{lift})
@item liftstd
standard basis and transformation matrix computation (see @ref{liftstd})
@item lres
free resolution (see @ref{lres})
@item minbase
minimal generating set of a homogeneous ideal, resp.@: module, or an ideal, resp.@: module,
over a local ring
@item modulo
represents
@tex
$(h1+h2)/h1=h2/(h1 \cap h2)$
@end tex
(h1+h2)/h1=h2/(h1 intersect h2)
(see @ref{modulo})
@item mres
minimal free resolution of an ideal resp.@: module w.r.t. a minimal set of generators of the given module
(see @ref{mres})
@item mult
multiplicity, resp.@: degree, of the module of leading terms (see @ref{mult})
@item ncols
number of columns (see @ref{ncols})
@item nrows
number of rows (see @ref{nrows})
@item print
nice print format (see @ref{print})
@item prune
minimize the embedding into a free module (see @ref{prune})
@item qhweight
quasihomogeneous weights of an ideal, resp.@: module (see @ref{qhweight})
@item quotient
module quotient (see @ref{quotient})
@item reduce
normalform with respect to a standard basis (see @ref{reduce})
@item res
free resolution of an ideal, resp.@: module, but not changing the given ideal, resp.@: module
(see @ref{res})
@item simplify
simplify a set of vectors (see @ref{simplify})
@item size
number of non-zero generators (see @ref{size})
@item sortvec
permutation for sorting ideals/modules (see @ref{sortvec})
@item sres
free resolution of a standard basis (see @ref{sres})
@item std
standard basis computation (see @ref{std}, @ref{liftstd})
@item subst
substitute a ring variable (see @ref{subst})
@item syz
computation of the first syzygy module (see @ref{syz})
@item vdim
vector space dimension of free module over the basering modulo module
of leading terms (see @ref{vdim})
@item weight
"optimal" weights (see @ref{weight})
@end table

@c @*@strong{Example:}
@c @example
@c @end example

@c ---------------------------------------
@node number, poly, module, Data types
@section number
@cindex number
@cindex coefficient field
@cindex ground field
@cindex field
@cindex galois field
@cindex finite field
@cindex parameter, as numbers

Numbers are elements from the coefficient field (or ground field).
They can only be defined or accessed with respect to a basering
which determines the coefficient field. See @ref{ring declarations} for
declarations of coefficient fields.

@strong{Warning:} Beware of the special meaning of the letter @code{e}
(immediately following a sequence of digits) if the field is real (or complex).
See @ref{number operations}, @ref{Miscellaneous oddities}.

@menu
* number declarations::
* number expressions::
* number operations::
* number related functions::
@end menu

@c ------------------------------
@node number declarations, number expressions, number, number
@subsection number declarations
@cindex number declarations

@table @strong
@item Syntax:
@code{number} name @code{=} number_expression @code{;}

@item Purpose:
defines a number.

@item Default:
0

@item Note:
Numbers may only be declared w.r.t. the coefficient field of the current
basering, i.e., a ring
has to be defined prior to any number declaration. See @ref{Rings and
orderings} for a list of the available coefficient fields.

@item Example:
@smallexample
@c reused example number_declarations types.doc:2677 
  // finite field Z/p, p<= 32003
  ring r = 32003,(x,y,z),dp;
  number n = 4/6;
  n;
@expansion{} -10667
  // finite field GF(p^n), p^n <= 32767
  // z is a primitive root of the minimal polynomial
  ring rg= (7^2,z),x,dp;
  number n = 4/9+z;
  n;
@expansion{} z11
  // the rational numbers
  ring r0 = 0,x,dp;
  number n = 4/6;
  n;
@expansion{} 2/3
  // algebraic extensions of Z/p or Q
  ring ra=(0,a),x,dp;
  minpoly=a^2+1;
  number n=a3+a2+2a-1;
  n;
@expansion{} (a-2)
  a^2;
@expansion{} -1
  // transcedental extensions of Z/p or Q
  ring rt=(0,a),x,dp;
  number n=a3+a2+2a-1;
  n;
@expansion{} (a3+a2+2a-1)
  a^2;
@expansion{} (a2)
  // machine floating point numbers, single precision
  ring R_0=real,x,dp;
  number n=4/6;
  n;
@expansion{} 6.667e-01
  n=0.25e+2;
  n;
@expansion{} 2.500e+01
  // floating point numbers, arbitrary prescribed precision
  ring R_1=(real,50),x,dp;
  number n=4.0/6;
  n;
@expansion{} 0.66666666666666666666666666666666666666666666666667
  n=0.25e+2;
  n;
@expansion{} 25
  // floating point complex numbers, arbitrary prescribed precision
  // the third parameter gives the name of the imaginary unit
  ring R_2=(complex,50,i),x,dp;
  number n=4.0/6;
  n;
@expansion{} 0.66666666666666666666666666666666666666666666666667
  n=0.25e+2*i+n;
  n;
@expansion{} (0.66666666666666666666666666666666666666666666666667+i*25)
@c end example number_declarations types.doc:2677
@end smallexample
@end table

@c ------------------------------
@node number expressions, number operations, number declarations, number
@subsection number expressions
@cindex number expressions

A number expression is:
@enumerate
@item
a rational number (there are NO spaces allowed inside a rational number,
see @ref{int expressions})
@item
a floating point number (if the coefficient field is @code{real}):
@*<digits>@code{.}<digits>@code{e}<sign><digits>
@item
an identifier of type number
@item
a function returning number
@item
an int expression (see @ref{Type conversion and casting})
@item
number expressions combined by the arithmetic operations
@code{+}, @code{-}, @code{*}, @code{/}, @code{^}, or @code{**}.
@item
a type cast to number
@end enumerate

@*@strong{Example:}
@smallexample
@c reused example number_expressions types.doc:2753 
  // the following expressions are in any ring int expressions
  2 / 3;
@expansion{} 0
  4/ 8;
@expansion{} 0
  2 /2;   // the notation of / for div might change in the future
@expansion{} 1
  ring r0=0,x,dp;
  2/3, 4/8, 2/2 ; // are numbers
@expansion{} 2/3 1/2 1

  poly f = 2x2 +1;
  leadcoef(f);
@expansion{} 2
  typeof(_);
@expansion{} number
  ring rr =real,x,dp;
  1.7e-2; 1.7e+2; // are valid (but  1.7e2 not), if the field is `real`
@expansion{} 1.700e-02
@expansion{} 1.700e+02
  ring rp = (31,t),x,dp;
  2/3, 4/8, 2/2 ; // are numbers
@expansion{} 11 -15 1
  poly g = (3t2 +1)*x2 +1;
  leadcoef(g);
@expansion{} (3t2+1)
  typeof(_);
@expansion{} number
  par(1);
@expansion{} (t)
  typeof(_);
@expansion{} number
@c end example number_expressions types.doc:2753
@end smallexample
@c inserted refs from types.doc:2775
@menu
See
* Type conversion and casting::
* ring::
@end menu
@c end inserted refs from types.doc:2775

@c ------------------------------
@node number operations, number related functions, number expressions, number
@subsection number operations
@cindex number operations
@cindex mod

@table @asis
@item @code{+}
addition
@item @code{-}
negation or subtraction
@item @code{*}
multiplication
@item @code{/}
division
@item @code{^}, @code{**}
power, exponentiation (by an integer)
@item @code{<=, >=, ==, <>}
comparison
@item @code{mod}
integer modulo (the remainder of the division @code{div}), always non-negative
@end table

@strong{Note:} quotient and exponentiation is only recognized as a
number expression if it is already a number, see @ref{Miscellaneous
oddities}.
@* For the behavior of comparison operators in rings with
ground field different from real or the rational numbers, see @ref{boolean
expressions}.

@*@strong{Example:}
@smallexample
@c reused example number_operations types.doc:2813 
  ring r=0,x,dp;
  number n = 1/2 +1/3;
  n;
@expansion{} 5/6
  n/2;
@expansion{} 5/12
  1/2/3;
@expansion{} 1/6
  1/2 * 1/3;
@expansion{} 1/6
  n = 2;
  n^-2;
@expansion{} 1/4
  // the following oddities appear here
  2/(2+3);
@expansion{} 0
  number(2)/(2+3);
@expansion{} 2/5
  2^-2; // for int's exponent must be non-negative
@expansion{}    ? exponent must be non-negative
@expansion{}    ? error occurred in line 12: `  2^-2; // for int's exponent must be no\
   n-negative`
  number(2)^-2;
@expansion{} 1/4
  3/4>=2/5;
@expansion{} 1
  2/6==1/3;
@expansion{} 1
@c end example number_operations types.doc:2813
@end smallexample

@c ------------------------------
@node number related functions,  , number operations, number
@subsection number related functions
@cindex number related functions

@table @code
@item cleardenom
cancel denominators of numbers in poly and divide it by its content
(see @ref{cleardenom})
@item impart
imaginary part of a complex number, 0 otherwise
(see @ref{impart}, @ref{repart})
@item numerator, denominator
return the numerator/denominator of a rational number
(see @ref{numerator}, @ref{denominator})
@item leadcoef
coefficient of the leading term (see @ref{leadcoef})
@item par
n-th parameter of the basering (see @ref{par})
@item pardeg
degree of a number in ring parameters (see @ref{pardeg})
@item parstr
string form of ring parameters (see @ref{parstr})
@item repart
real part of a complex number
(see @ref{impart}, @ref{repart})
@end table

@c ---------------------------------------

@c ---------------------------------------
@node poly, proc, number, Data types
@section poly
@cindex poly

Polynomials are the basic data for all main algorithms in
@code{@sc{Singular}}. They consist of finitely many terms
(coefficient*power product) which are combined by the usual polynomial
operations (see @ref{poly expressions}). Polynomials can only be defined
or accessed with respect to a basering which determines the coefficient
type, the names of the indeterminates and the monomial ordering.

@smallexample
@c reused example poly types.doc:2950 
  ring r=32003,(x,y,z),dp;
  poly f=x3+y5+z2;
@c end example poly types.doc:2950
@end smallexample

@menu
* poly declarations::
* poly expressions::
* poly operations::
* poly related functions::
@end menu

@c ------------------------------
@node poly declarations, poly expressions, poly, poly
@subsection poly declarations
@cindex poly declarations

@table @strong
@item Syntax:
@code{poly} name @code{=} poly_expression @code{;}

@item Purpose:
defines a polynomial.

@item Default:
0

@item Example:
@smallexample
@c reused example poly_declarations types.doc:2980 
  ring r = 32003,(x,y,z),dp;
  poly s1  = x3y2+151x5y+186xy6+169y9;
  poly s2  = 1*x^2*y^2*z^2+3z8;
  poly s3  = 5/4x4y2+4/5*x*y^5+2x2y2z3+y7+11x10;
  int a,b,c,t=37,5,4,1;
  poly f=3*x^a+x*y^(b+c)+t*x^a*y^b*z^c;
  f;
@expansion{} x37y5z4+3x37+xy9
  short = 0;
  f;
@expansion{} x^37*y^5*z^4+3*x^37+x*y^9
@c end example poly_declarations types.doc:2980
@end smallexample
@end table
@c inserted refs from types.doc:2993
@menu
See also:
* short::
@end menu
@c end inserted refs from types.doc:2993
@c ------------------------------
@node poly expressions, poly operations, poly declarations, poly
@subsection poly expressions
@cindex poly expressions

A poly expression is (optional parts in square brackets):
@enumerate
@item
a monomial (there are NO spaces allowed inside a monomial)
@smallexample
  [coefficient] ring_variable [ exponent] [ring_variable [exponent] @dots{}]
@end smallexample
monomials which contain an indexed ring variable
must be built from @code{ring_variable} and @code{coefficient}
with the operations @code{*} and @code{^}
@item
an identifier of type poly
@item
a function returning poly
@item
poly expressions combined by the arithmetic operations
@code{+}, @code{-}, @code{*}, @code{/}, or @code{^}
@item
an int expression (see @ref{Type conversion and casting})
@item
a type cast to poly
@end enumerate

@*@strong{Example:}
@smallexample
2x, x3, 2x2y3, xyz, 2xy2; //  are monomials
2*x, x^3, 2*x^2*y^3, x*y*z, 2*x*y^2; // are poly expressions
2*x(1); // is a valid poly expression, but not 2x(1) (a syntax error)
2*x^3;  // is a valid poly expression equal to 2x3 (a valid monomial)
        // but not equal to 2x^3 which will be interpreted as (2x)^3
        // since 2x is a monomial
@c reused example poly_expressions types.doc:3032 
  ring r=0,(x,y),dp;
  poly f = 10x2y3 +2x2y2-2xy+y -x+2;
  lead(f);
@expansion{} 10x2y3
  leadmonom(f);
@expansion{} x2y3
  simplify(f,1);     // normalize leading coefficient
@expansion{} x2y3+1/5x2y2-1/5xy-1/10x+1/10y+1/5
  poly g = 1/2x2 + 1/3y;
  cleardenom(g);
@expansion{} 3x2+2y
  int i = 102;
  poly(i);
@expansion{} 102
  typeof(_);
@expansion{} poly
@c end example poly_expressions types.doc:3032
@end smallexample

@c inserted refs from types.doc:3046
@menu
See 
* Type conversion and casting::
* ring::
@end menu
@c end inserted refs from types.doc:3046

@c ------------------------------
@node poly operations, poly related functions, poly expressions, poly
@subsection poly operations
@cindex poly operations

@table @asis
@item @code{+}
addition

@item @code{-}
negation or subtraction

@item @code{*}
multiplication

@item @code{/}
division by a polynomial, ignoring the rest

@item @code{^}, @code{**}
power by an integer

@item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
comparison (w.r.t. monomial ordering)

@item poly_expression @code{[} intvec_expression @code{]}
the monomial at the indicated place w.r.t.@: the monomial ordering
@end table

@*@strong{Example:}
@smallexample
@c reused example poly_operations types.doc:3080 
  ring R=0,(x,y),dp;
  poly f = x3y2 + 2x2y2 + xy - x + y + 1;
  f;
@expansion{} x3y2+2x2y2+xy-x+y+1
  f + x5 + 2;
@expansion{} x5+x3y2+2x2y2+xy-x+y+3
  f * x2;
@expansion{} x5y2+2x4y2+x3y-x3+x2y+x2
  (x+y)/x;
@expansion{} 1
  f/3x2;
@expansion{} 1/3xy2+2/3y2
  x5 > f;
@expansion{} 1
  x<=y;
@expansion{} 0
  x>y;
@expansion{} 1
  ring r=0,(x,y),ds;
  poly f = fetch(R,f);
  f;
@expansion{} 1-x+y+xy+2x2y2+x3y2
  x5 > f;
@expansion{} 0
  f[2..4];
@expansion{} -x+y+xy
  size(f);
@expansion{} 6
  f[size(f)+1]; f[-1];    // monomials out of range are 0
@expansion{} 0
@expansion{} 0
  intvec v = 6,1,3;
  f[v];          // the polynom built from the 1st, 3rd and 6th monomial of f
@expansion{} 1+y+x3y2
@c end example poly_operations types.doc:3080
@end smallexample

@c ------------------------------
@node poly related functions,  , poly operations, poly
@subsection poly related functions
@cindex poly related functions

@table @code
@item cleardenom
cancel denominators of numbers in poly and divide it by its content
(see @ref{cleardenom})
@item coef
matrix of coefficients and monomials (see @ref{coef})
@item coeffs
matrix of coefficients (see @ref{coeffs})
@item deg
degree (see @ref{deg})
@item det
determinant (see @ref{det})
@item diff
partial derivative (see @ref{diff})
@item extgcd
Bezout representation of gcd (see @ref{extgcd})
@item factorize
factorize polynomial (see @ref{factorize})
@item finduni
find univariate polynomials in a zero-dimensional ideal (see @ref{finduni})
@item gcd
greatest common divisor (see @ref{gcd})
@item homog
homogenization (see @ref{homog})
@item jacob
ideal, resp.@: matrix, of all partial derivatives (see @ref{jacob})
@item lead
leading term (see @ref{lead})
@item leadcoef
coefficient of the leading term (see @ref{leadcoef})
@item leadexp
the exponent vector of the leading monomial (see @ref{leadexp})
@item leadmonom
leading monomial (see @ref{leadmonom})
@item jet
monomials with degree smaller k+1 (see @ref{jet})
@item ord
degree of the leading monomial (see @ref{ord})
@item qhweight
quasihomogeneous weights (see @ref{qhweight})
@item reduce
normal form with respect to a standard base (see @ref{reduce})
@item rvar
test for ring variable (see @ref{rvar})
@item simplify
normalize a polynomial (see @ref{simplify})
@item size
number of monomials (see @ref{size})
@item subst
substitute a ring variable (see @ref{subst})
@item trace
trace of a matrix (see @ref{trace})
@item var
the indicated variable of the ring (see @ref{var})
@item varstr
variable in string form (see @ref{varstr})
@end table

@c @*@strong{Example:}
@c @example
@c @end example

@c ---------------------------------------
@node proc, qring, poly, Data types
@section proc
@cindex proc

Procedures are sequences of @sc{Singular} commands in a special
format. They are used to extend the set of @sc{Singular} commands with
user defined commands. Once a procedure is defined it can be used as
any other @sc{Singular} command. Procedures may be defined by either
typing them on the command line or by loading them from a file. For a
detailed description on the concept of procedures in @sc{Singular} see
@ref{Procedures}. A file containing procedure definitions which comply with
certain syntax rules is called a library. Such a file is loaded
using the command @code{LIB}. For more information on libraries see
@ref{Libraries}.

@menu
* proc declaration::
@end menu

@c ---------------------------------------
@node proc declaration,  , proc, proc
@subsection proc declaration
@cindex proc declaration

@c ------------------------------------------------------------
@c   This piece of text exists also in the file general.doc,
@c   chapter "Proc in a library".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
@table @strong
@item Syntax:
[@code{static}] @code{proc} proc_name [parameter_list]
@*["help_text"]
@*@code{@{}
@*
@tex
\quad
@end tex
   procedure_body
@*@code{@}}
@*[@code{example}
@*@code{@{}
@*
@tex
\quad
@end tex
   sequence_of_commands;
@*@code{@}}]
@*@code{proc} proc_name @code{=} proc_name @code{;}
@*@code{proc} proc_name @code{=} string_expression @code{;}
@item Purpose:
defines a new function, the @code{proc} proc_name, with the additional
information help_text, which is copied to the screen by
@code{help proc_name;} and the @code{example} section
which is executed by @code{example proc_name;}.
@* The help_text, the parameter_list, and the example section are optional.
The default for a parameter_list is @code{(list #)}, see @ref{Parameter list}.
The help and example sections are ignored if the procedure is defined
interactively, i.e., if it was not loaded from a file by a @ref{LIB} command.
@* Specifying @code{static} in front of the proc-definition is only possible
in a library file and makes this procedure local to the library,
i.e., accessible only for the other procedures in the same library,
but not for the users.

@item Example:
@smallexample
@c reused example proc_declaration types.doc:3237 
  proc milnor_number (poly p)
  @{
    ideal i= std(jacob(p));
    int m_nr=vdim(i);
    if (m_nr<0)
    @{
      "// not an isolated singularity";
    @}
    return(m_nr);         // the value of m_nr is returned
  @}
  ring r1=0,(x,y,z),ds;
  poly p=x^2+y^2+z^5;
  milnor_number(p);
@expansion{} 4
@c end example proc_declaration types.doc:3237
@end smallexample
@end table
@c inserted refs from types.doc:3254
@menu
See
* LIB::
* Libraries::
* Procedures::
@end menu
@c end inserted refs from types.doc:3254



@c ---------------------------------------
@node qring, resolution, proc, Data types
@section qring
@cindex qring

@sc{Singular} offers the opportunity to calculate in quotient rings
(factor rings), i.e., rings modulo an ideal.  The ideal has to be given
as a standard basis.  For a detailed description of the concept
of rings and quotient rings see @ref{Rings and orderings}.

@menu
* qring declaration::
@end menu

@c ---------------------------------------
@node qring declaration,  , qring, qring
@subsection qring declaration
@cindex qring declaration

@c ------------------------------------------------------------
@c   This piece of text exists also in the file general.doc,
@c   chapter "General syntax of a ring declaration".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
@table @strong
@item Syntax:
@code{qring} name @code{=} ideal_expression @code{;}
@item Default:
none
@item Purpose:
declares a quotient ring as the basering modulo ideal_expression.  Sets
it as current basering.
@item Example:
@smallexample
@c reused example qring_declaration types.doc:3297 
ring r=0,(x,y,z),dp;
ideal i=xy;
qring q=std(i);
basering;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} // quotient ring from ideal
@expansion{} _[1]=xy
@c end example qring_declaration types.doc:3297
@end smallexample
@end table

@c ---------------------------------------
@node resolution, ring, qring, Data types
@section resolution
@cindex resolution

The resolution type is intended as an intermediate representation which
internally retains additional information obtained during computation of
resolutions. It furthermore enables the use of partial results to
compute, for example, Betti numbers or minimal resolutions. Like ideals
and modules, a resolution can only be defined w.r.t.@: a basering.

@strong{Note:}
to access the elements of a resolution, it has to be assigned to a list,
which also completes computations and may therefore take time,
(resp.@: an access directly with the brackets @code{[ , ]} causes
implicitly a cast to a list).

@menu
* resolution declarations::
* resolution expressions::
* resolution related functions::
@end menu

@c ---------------------------------------
@node resolution declarations, resolution expressions, resolution, resolution
@subsection resolution declarations
@cindex resolution declarations

@table @strong
@item Syntax:
@code{resolution} name @code{=} resolution_expression @code{;}

@item Purpose:
defines a resolution.

@item Default:
none

@item Example:
@smallexample
@c reused example resolution_declarations types.doc:3346 
  ring R;
  ideal i=z2,x;
  resolution re=res(i,0);
  re;
@expansion{}  1      2      1      
@expansion{} R <--  R <--  R
@expansion{} 
@expansion{} 0      1      2      
@expansion{} resolution not minimized yet
@expansion{} 
  betti(re);
@expansion{} 1,1,0,
@expansion{} 0,1,1 
  list l = re;
  l;
@expansion{} [1]:
@expansion{}    _[1]=x
@expansion{}    _[2]=z2
@expansion{} [2]:
@expansion{}    _[1]=-z2*gen(1)+x*gen(2)
@expansion{} [3]:
@expansion{}    _[1]=0
@c end example resolution_declarations types.doc:3346
@end smallexample
@end table

@c ------------------------------
@node resolution expressions, resolution related functions, resolution declarations, resolution
@subsection resolution expressions
@cindex resolution expressions

A resolution expression is:
@enumerate
@item
an identifier of type resolution
@item
a function returning a resolution
@item
a type cast to resolution from a list of ideals, resp.@: modules..
@end enumerate

@c inserted refs from types.doc:3373
@menu
See 
* Type conversion and casting::
@end menu
@c end inserted refs from types.doc:3373

@c ------------------------------
@node resolution related functions,  , resolution expressions, resolution
@subsection resolution related functions
@cindex resolution related functions

@table @code
@item betti
Betti numbers of a resolution (see @ref{betti})
@item lres
free resolution (see @ref{lres})
@item minres
minimize a free resolution (see @ref{minres})
@item mres
minimal free resolution of an ideal, resp.@: module w.r.t. a minimal set of generators of
the given ideal, resp.@: module (see @ref{mres})
@item res
free resolution of an ideal, resp.@: module, but not changing the
given ideal, resp.@: module (see @ref{res})
@item sres
free resolution of a standard basis (see @ref{sres})
@end table

@c @*@strong{Example:}
@c @example
@c @end example

@c ---------------------------------------
@node ring, string, resolution, Data types
@section ring
@cindex ring

Rings are used to describe properties of polynomials, ideals etc.
Almost all computations in @sc{Singular} require a basering.
For a detailed description of the concept of rings see
@ref{Rings and orderings}.

@menu
* ring declarations::
* ring related functions::
* ring operations::
@end menu

@c ---------------------------------------
@node ring declarations, ring related functions, ring, ring
@subsection ring declarations
@cindex ring declarations

@table @strong
@item Syntax:
@code{ring} name @code{= (} coefficient_field @code{),}
  @code{(} names_of_ring_variables @code{),}
  @code{(} ordering @code{);}
@item Default:
@code{32003,(x,y,z),(dp,C);}
@item Purpose:
declares a ring and sets it as the actual basering.
@end table

The coefficient_field is given by one of the following:
@enumerate
@item
a non-negative int_expression less or equal 2147483629.
@item
an expression_list of an int_expression and one or more names.
@item
the name @code{real}
@item
an expression_list of the name @code{real} and an  int_expression.
@item
an expression_list of the name @code{complex}, an optional int_expression
and a name.
@end enumerate

For the definition of the 'coefficient_field', see @ref{Rings and orderings}.

'names_of_ring_variables' must be a list of names or indexed names.

'ordering' is a list of block orderings where each block ordering is either
@enumerate
@item
@code{lp}, @code{dp}, @code{Dp}, @code{ls}, @code{ds}, or @code{Ds}
optionally followed by a size parameter in parentheses.

@item
@code{wp}, @code{Wp}, @code{ws}, @code{Ws}, or @code{a} followed by a
weight vector given as an intvec_expression in parentheses.

@item
@code{M} followed by an intmat_expression in parentheses.

@item
@code{c} or @code{C}.
@end enumerate

For the definition of the orderings, see @ref{Term orderings},
@ref{Monomial orderings}.

If one of coefficient_field, names_of_ring_variables, and ordering
consists of only one entry, the parentheses around this entry may be
omitted.

@c ---------------------------------------
@node ring related functions, ring operations, ring declarations, ring
@subsection ring related functions
@cindex ring related functions

@table @code
@item charstr
description of the coefficient field of a ring (see @ref{charstr})
@item keepring
move ring to next upper level (see @ref{keepring})
@item npars
number of ring parameters (see @ref{npars})
@item nvars
number of ring variables (see @ref{nvars})
@item ordstr
monomial ordering of a ring (see @ref{ordstr})
@item parstr
names of all ring parameters or the
name of the n-th ring parameter (see @ref{parstr})
@item qring
quotient ring (see @ref{qring})
@item setring
set a new basering (see @ref{setring})
@item varstr
names of all ring variables or the
name of the n-th ring variable (see @ref{varstr})
@end table

@c ---------------------------------------
@node ring operations, , ring related functions, ring
@subsection ring operations
@cindex ring operations
@table @asis
@item @code{+}
construct a new ring 
@math{k[X,Y]}
@tex
$k[X,Y]$
@end tex
 from 
@math{k_1[X]}
@tex
$k_1[X]$
@end tex
  and 
@math{k_2[Y]}
@tex
$k_2[Y]$
@end tex
.
@end table

Concerning the ground fields 
@math{k_1}
@tex
$k_1$
@end tex
 and 
@math{k_2}
@tex
$k_2$
@end tex
 take the
following guide lines into consideration:
@itemize @bullet
@item Neither 
@math{k_1}
@tex
$k_1$
@end tex
 nor 
@math{k_2}
@tex
$k_2$
@end tex
 may be 
@math{R}
@tex
$R$
@end tex
 or 
@math{C}
@tex
$C$
@end tex
.
@item If the characteristic of 
@math{k_1}
@tex
$k_1$
@end tex
 and 
@math{k_2}
@tex
$k_2$
@end tex
 differs, then one of them must be 
@math{Q}
@tex
$Q$
@end tex
.
@item At most one of 
@math{k_1}
@tex
$k_1$
@end tex
 and 
@math{k_2}
@tex
$k_2$
@end tex
 may be have parameters.
@item If one of 
@math{k_1}
@tex
$k_1$
@end tex
 and 
@math{k_2}
@tex
$k_2$
@end tex
 is an algebraic extension of 
@math{Z/p}
@tex
$Z/p$
@end tex
 it may not be defined by a @code{charstr} of type @code{(p^n,a)}.
@end itemize


@strong{Example:}
@smallexample
@c reused example ring_operations types.doc:3527 
  ring R1=0,(x,y),dp;
  ring R2=32003,(a,b),dp;
  def R=R1+R2;
  R;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    a b 
@expansion{} //        block   3 : ordering C
@c end example ring_operations types.doc:3527
@end smallexample

@c inserted refs from types.doc:3535
@menu
See also:
* ring_lib::
@end menu
@c end inserted refs from types.doc:3535

@c ---------------------------------------
@node string, vector, ring, Data types
@section string
@cindex string
@cindex newline

Variables of type @code{string} are used for output (almost every type
can be "converted" to @code{string}) and for creating new
commands at runtime see @ref{execute}.  They are also return values of
certain interpreter related functions (see @ref{Functions}).  String
constants consist of a sequence of ANY characters (including newline!)
between a starting @code{"} and a closing @code{"}.  There is also a
string constant @code{newline}, which is the newline character.  The
@code{+} sign "adds" strings, @code{""} is the empty string (hence
strings form a semigroup). Strings may be used to comment the output of
a computation or to give it a nice format. Strings may also be used for
intermediate conversion of one type into another.

@smallexample
@c reused example string types.doc:3558 
  string s="Hi";
  string s1="a string with new line at the end"+newline;
  string s2="another string with new line at the end
  ";
  s;s1;s2;
@expansion{} Hi
@expansion{} a string with new line at the end
@expansion{} 
@expansion{} another string with new line at the end
@expansion{}   
  ring r; ideal i=std(ideal(x,y^3));
  "dimension of i =",dim(i),", multiplicity of i =",mult(i);
@expansion{} dimension of i = 1 , multiplicity of i = 3
  "dimension of i = "+string(dim(i))+", multiplicity of i = "+string(mult(i));
@expansion{} dimension of i = 1, multiplicity of i = 3
  "a"+"b","c";
@expansion{} ab c
@c end example string types.doc:3558
@end smallexample
A comma between two strings makes an expression list out of them
(such a list is printed with a separating blank in between),
while a @code{+} concatenates strings.

@menu
* string declarations::
* string expressions::
* string type cast::
* string operations::
* string related functions::
@end menu

@c ------------------------------
@node string declarations, string expressions, string, string
@subsection string declarations
@cindex string declarations

@table @strong
@item Syntax:
@code{string} name @code{=} string_expression @code{;}
@*@code{string} name @code{=} list_of_string_expressions @code{;}

@item Purpose:
defines a string variable.

@item Default:
"" (the empty string)

@item Example:
@smallexample
@c reused example string_declarations types.doc:3600 
  string s1="Now I know";
  string s2="how to encode a \" in a string...";
  string s=s1+" "+s2; // concatenation of 3 strings
  s;
@expansion{} Now I know how to encode a " in a string...
  s1,s2;   // 2 strings, separated by a blank in the output:
@expansion{} Now I know how to encode a " in a string...
@c end example string_declarations types.doc:3600
@end smallexample
@end table

@c ------------------------------
@node string expressions, string type cast, string declarations, string
@subsection string expressions
@cindex string expressions

A string expression is:
@enumerate
@item
a sequence of characters between two unescaped quotes (@code{"})
@item
an identifier of type string
@item
a function returning string
@item
a substring (using the bracket operator)
@item
a type cast to string (@pxref{string type cast})
@item
string expressions combined by the operation @code{+}.
@end enumerate

@*@strong{Example:}
@smallexample
@c  // a string constant
@c  "@dots{}";
@c  // a type cast from name
@c  string(name)
@c  // concatenation
@c  string_expression + string_expression
@c reused example string_expressions types.doc:3639 
// string_expression[start, length] : a substring
// (possibly filled up with blanks)
// the substring of s starting at position 2
// with a length of 4
string s="123456";
s[2,4];
@expansion{} 2345
"abcd"[2,2];
@expansion{} bc
// string_expression[position] : a character from a string
s[3];
@expansion{} 3
// string_expression[position..position] :
// a substring starting at the first position up to the second
// given position
s[2..4];
@expansion{} 2 3 4
// a function returning a string
typeof(s);
@expansion{} string
@c end example string_expressions types.doc:3639
@end smallexample

@c inserted refs from types.doc:3658
@menu
See 
* Type conversion and casting::
* string type cast::
@end menu
@c end inserted refs from types.doc:3658

@c ------------------------------
@node string type cast,  string operations, string expressions, string
@subsection string type cast
@cindex string type cast
@table @code
@item @strong{Syntax:}
@code{string (} expression [, expression_2, ... expression_n]@code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
Converts each expression to a string, where expression can be of any
type. The concatenated string of all concersions is returned.

@*The elements of intvec, intmat, ideal, module, matrix, and list, are
separated by a comma. No newlines are inserted.
@*Not defined elements of a list are omitted.
@*For link, the name of the link is used.
@*For map, the ideal defining the mapping is converted.

@item @strong{Note:}
When applied to a list, elements of type intvec, intmat, ideal, module,
matrix, and list become indistinguishable.

@item @strong{Example:}
@smallexample
@c reused example string_type_cast types.doc:3688 
  string("1+1=", 2);
@expansion{} 1+1=2
  string(intvec(1,2,3,4));
@expansion{} 1,2,3,4
  string(intmat(intvec(1,2,3,4), 2, 2));
@expansion{} 1,2,3,4 
  ring r;
  string(r);
@expansion{} (32003),(x,y,z),(dp(3),C)
  string(ideal(x,y));
@expansion{} x,y
  qring R = std(ideal(x,y));
  string(R);
@expansion{} (32003),(x,y,z),(dp(3),C)
  map phi = r, ideal(x,z);
  string(phi);
@expansion{} x,z
  list l;
  string(l);
@expansion{} 
  l[3] = 1;
  string(l); // notice that l[1],l[2] are omitted
@expansion{} 1
  l[2] = l;
  l;
@expansion{} [2]:
@expansion{}    [3]:
@expansion{}       1
@expansion{} [3]:
@expansion{}    1
  string(l); // notice that lists of list is flattened
@expansion{} 1,1
  l[1] = intvec(1,2,3);
  l;
@expansion{} [1]:
@expansion{}    1,2,3
@expansion{} [2]:
@expansion{}    [3]:
@expansion{}       1
@expansion{} [3]:
@expansion{}    1
  string(l); // notice that intvec elements are not distinguishable
@expansion{} 1,2,3,1,1
@c end example string_type_cast types.doc:3688
@end smallexample
@end table
@c inserted refs from types.doc:3712
@menu
See
* Type conversion and casting::
* print::
* string::
@end menu
@c end inserted refs from types.doc:3712

@c ------------------------------
@node string operations, string related functions, string type cast, string
@subsection string operations
@cindex string operations

@table @asis
@item @code{+}
concatenation

@item @code{<=}, @code{>=}, @code{==}, @code{<>}
comparison (lexicographical with respect to the ASCII encoding)

@item string_expression @code{[} int_expression @code{]}
is a character of the string; the index 1 gives the first character.

@item string_expression @code{[} int_expression@code{,} int_expression @code{]}
is a substring, where the first argument is the start index and the
second is the length of the substring, filled up with blanks if the
length exceeds the total size of the string

@item string_expression @code{[} intvec_expression @code{]}
is a expression list of characters from the string
@end table

@*@strong{Example:}
@smallexample
@c reused example string_operations types.doc:3745 
  string s="abcde";
  s[2];
@expansion{} b
  s[3,2];
@expansion{} cd
  ">>"+s[1,10]+"<<";
@expansion{} >>abcde     <<
  s[2]="BC"; s;
@expansion{} aBcde
  intvec v=1,3,5;
  s=s[v]; s;
@expansion{} ace
  s="123456"; s=s[3..5]; s;
@expansion{} 345
@c end example string_operations types.doc:3745
@end smallexample

@c ------------------------------
@node string related functions,  , string operations, string
@subsection string related functions
@cindex string related functions

@table @code
@item charstr
description of the coefficient field of a ring (see @ref{charstr})
@item execute
executing string as command (see @ref{execute})
@item find
position of a substring in a string (see @ref{find})
@item names
list of strings of all user-defined variable names (see @ref{names})
@item nameof
name of an object (see @ref{nameof})
@item option
lists all defined options (see @ref{option})
@item ordstr
monomial ordering of a ring (see @ref{ordstr})
@item parstr
names of all ring parameters or the
name of the n-th ring parameter (see @ref{parstr})
@item read
read a file (see @ref{read})
@item size
length of a string (see @ref{size})
@item sprintf
string formatting (see @ref{sprintf})
@item typeof
type of an object (see @ref{typeof})
@item varstr
names of all ring variables or the
name of the n-th ring variable (see @ref{varstr})
@end table

@c @*@strong{Example:}
@c @example
@c @end example

@c ---------------------------------------
@node vector,  , string, Data types
@section vector
@cindex vector

Vectors are elements of a free module over the basering with basis
@code{gen(1)}, @code{gen(2)}, @dots{} .
Each vector belongs to a free module of rank equal to the biggest index
of a generator with non-zero coefficient. Since generators with zero
coefficients need not be written any vector may be considered
also as an element of a free module of higher rank.
Like polynomials they
can only be defined or accessed with respect to the basering.
(E.g., if @code{f} and @code{g} are polynomials then
@code{f*gen(1)+g*gen(3)+gen(4)} may also be written as @code{[f,0,g,1]}
or as @code{[f,0,g,1,0]}.) Note that the elements of a vector have to be
surrounded by square brackets (@code{[}  , @code{]})
(cf. @ref{Representation of mathematical objects}).

@menu
* vector declarations::
* vector expressions::
* vector operations::
* vector related functions::
@end menu

@c ------------------------------
@node vector declarations, vector expressions, vector, vector
@subsection vector declarations
@cindex vector declarations

@table @strong
@item Syntax:
@code{vector} name @code{=} vector_expression @code{;}

@item Purpose:
defines a vector of polynomials (an element of a free module).

@item Default:
[0]

@item Example:
@smallexample
@c reused example vector_declarations types.doc:3840 
  ring r=0,(x,y,z),(c,dp);
  poly s1 = x2;
  poly s2 = y3;
  poly s3 = z;
  vector v = [s1, s2-s1, s3-s1]+ s1*gen(5);
  // v is a vector in the free module of rank 5
  v;
@expansion{} [x2,y3-x2,-x2+z,0,x2]
@c end example vector_declarations types.doc:3840
@end smallexample
@end table

@c ------------------------------
@node vector expressions, vector operations, vector declarations, vector
@subsection vector expressions
@cindex vector expressions

A vector expression is:
@enumerate
@item
an identifier of type vector
@item
a function returning vector
@item
a poly expression (via the canonical embedding @code{p} @expansion{} @code{p*gen(1)})
@item
vector expressions combined by the arithmetic operations @code{+} or
@code{-}
@item
a poly expression and a vector expression combined by the arithmetic
operation @code{*}
@item
a type cast to vector using the brackets @code{[} , @code{]}
@end enumerate

@*@strong{Example:}
@smallexample
@c reused example vector_expressions types.doc:3877 
  // ordering gives priority to components:
  ring rr=0,(x,y,z),(c,dp);
  vector v=[x2+y3,2,0,x*y]+gen(6)*x6;
  v;
@expansion{} [y3+x2,2,0,xy,0,x6]
  vector w=[z3-x,3y];
  v-w;
@expansion{} [y3-z3+x2+x,-3y+2,0,xy,0,x6]
  v*(z+x);
@expansion{} [xy3+y3z+x3+x2z,2x+2z,0,x2y+xyz,0,x7+x6z]
@c end example vector_expressions types.doc:3877
@end smallexample

@c inserted refs from types.doc:3888
@menu
See
* Type conversion and casting::
* ring::
@end menu
@c end inserted refs from types.doc:3888

@c ------------------------------
@node vector operations, vector related functions, vector expressions, vector
@subsection vector operations
@cindex vector operations

@table @asis
@item @code{+}
addition

@item @code{-}
negation or subtraction

@item @code{/}
division by a monomial, not divisible terms yield 0

@item @code{<}, @code{<=}, @code{>}, @code{>=}, @code{==}, @code{<>}
comparison of leading terms w.r.t. monomial ordering

@item vector_expression @code{[} int_expressions @code{]}
is a vector entry; the index 1 gives the first entry.
@end table

@*@strong{Example:}
@smallexample
@c reused example vector_operations types.doc:3918 
  ring R=0,(x,y),(c,dp);
  [x,y]-[1,x];
@expansion{} [x-1,-x+y]
  [1,2,x,4][3];
@expansion{} x
@c end example vector_operations types.doc:3918
@end smallexample


@c ------------------------------
@node vector related functions,  , vector operations, vector
@subsection vector related functions
@cindex vector related functions

@table @code
@item cleardenom
quotient of a vector by its content (see @ref{cleardenom})
@item coeffs
matrix of coefficients (see @ref{coeffs})
@item deg
degree (see @ref{deg})
@item diff
partial derivative (see @ref{diff})
@item gen
i-th generator (see @ref{gen})
@item homog
homogenization (see @ref{homog})
@item jet
k-jet: monomials with degree smaller k+1 (see @ref{jet})
@item lead
leading term (see @ref{lead})
@item leadcoef
leading coefficient (see @ref{leadcoef})
@item leadexp
the exponent vector of the leading monomial (see @ref{leadexp})
@item leadmonom
leading monomial (see @ref{leadmonom})
@item nrows
number of rows (see @ref{nrows})
@item ord
degree of the leading monomial (see @ref{ord})
@item reduce
normal form with respect to a standard base (see @ref{reduce})
@item simplify
normalize a vector (see @ref{simplify})
@item size
number of monomials (see @ref{size})
@item subst
substitute a ring variable (see @ref{subst})
@end table

@c @*@strong{Example:}
@c @example
@c @end example

@c ----------------------------------------------------------------------------
@node Functions and system variables, Tricks and pitfalls, Data types, Top
@chapter Functions and system variables
@cindex Commands
@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from reference.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT reference.doc INSTEAD
@comment Id: reference.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the reference part of the manual

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ifset' and `@end' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the conditionals).

@c ---------------------------------------
@menu
* Functions::
* Control structures::
* System variables::
@end menu

@c ---------------------------------------
@node Functions, Control structures, Functions and system variables, Functions and system variables
@section Functions
@cindex Functions

This section gives a complete reference of all functions, commands and
special variables of the @sc{Singular} kernel (i.e., all built-in
commands). @xref{standard_lib}, for those
functions from the @code{standard.lib} (this library is automatically
loaded at start-up time) which extend the functionality of the kernel
and are written
in the  @sc{Singular} programming language.

The general syntax of a function is
@format
                   [target =] function_name (<arguments>);
@end format
If no target is specified, the result is printed.
In some cases (e.g., @code{export}, @code{keepring}, @code{kill},
@code{setring}, @code{type}) the brackets are optional. For the commands
@code{help}, @code{break}, @code{quit}, @code{exit} and @code{LIB} no
brackets are allowed.

@*List of all supported kernel functions.
@menu
* attrib::
* bareiss::
* betti::
* char::
* char_series::
* charstr::
* cleardenom::
* close::
* coef::
* coeffs::
* contract::
* dbprint::
* defined::
* deg::
* degree::
* delete::
* det::
* diff::
* dim::
* division::
* dump::
* eliminate::
* eval::
* ERROR::
* example::
* execute::
* exit::
* extgcd::
* facstd::
* factorize::
* fetch::
* fglm::
* fglmquot::
* filecmd::
* find::
* finduni::
* fprintf::
* freemodule::
* gcd::
* gen::
* getdump::
* groebner::
* help::
* highcorner::
* hilb::
* homog::
* hres::
* imap::
* impart::
* indepSet::
* insert::
* interred::
* intersect::
* jacob::
* jet::
* kbase::
* kill::
* killattrib::
* koszul::
* laguerre::
* lead::
* leadcoef::
* leadexp::
* leadmonom::
* LIB::
* lift::
* liftstd::
* listvar::
* lres::
* maxideal::
* memory::
* minbase::
* minor::
* minres::
* modulo::
* monitor::
* mpresmat::
* mres::
* mstd::
* mult::
* nameof::
* names::
* ncols::
* npars::
* nres::
* nrows::
* nvars::
* open::
* option::
* ord::
* ordstr::
* par::
* pardeg::
* parstr::
* preimage::
* prime::
* print::
* printf::
* prune::
* qhweight::
* quot::
* quote::
* quotient::
* random::
* read::
* reduce::
* regularity::
* repart::
* res::
* reservedName::
* resultant::
* rvar::
* setring::
* simplex::
* simplify::
* size::
* sortvec::
* sprintf::
* sres::
* status::
* std::
* stdfglm::
* stdhilb::
* subst::
* system::
* syz::
* trace::
* transpose::
* type::
* typeof::
* uressolve::
* vandermonde::
* var::
* varstr::
* vdim::
* wedge::
* weight::
* write::
@end menu
@c ---------------------------------------
@node attrib, bareiss, Functions, Functions
@subsection attrib
@cindex attrib
@table @code
@item @strong{Syntax:}
@code{attrib (} name @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
displays the attribute list of the object called name.
@item @strong{Example:}
@smallexample
@c reused example attrib reference.doc:209 
  ring r=0,(x,y,z),dp;
  ideal I=std(maxideal(2));
  attrib(I);
@expansion{} attr:isSB, type int
@c end example attrib reference.doc:209
@end smallexample
@item @strong{Syntax:}
@code{attrib (} name @code{,} string_expression @code{)}
@item @strong{Type:}
any
@item @strong{Purpose:}
returns the value of the attribute string_expression of the
variable name. If the attribute is not defined for this variable,
@code{attrib} returns the empty string.
@item @strong{Example:}
@smallexample
@c reused example attrib_1 reference.doc:225 
  ring r=0,(x,y,z),dp;
  ideal I=std(maxideal(2));
  attrib(I,"isSB");
@expansion{} 1
  // although maxideal(2) is a standard basis,
  // SINGULAR does not know it:
  attrib(maxideal(2), "isSB");
@expansion{} 0
@c end example attrib_1 reference.doc:225
@end smallexample
@item @strong{Syntax:}
@code{attrib (} name@code{,} string_expression@code{,} expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
sets the attribute string_expression of the variable name
to the value expression.
@item @strong{Example:}
@smallexample
@c reused example attrib_2 reference.doc:243 
  ring r=0,(x,y,z),dp;
  ideal I=maxideal(2); // the attribute "isSB" is not set
  vdim(I);
@expansion{} // ** I is no standardbasis
@expansion{} 4
  attrib(I,"isSB",1);  // the standard basis attribute is set here
  vdim(I);
@expansion{} 4
@c end example attrib_2 reference.doc:243
@end smallexample
@item @strong{Remark:}
An attribute may be described by any string_expression. Some of these are
used by the kernel of @sc{Singular} and referred to as reserved attributes.
Non-reserved attributes may be used, however, in procedures and can
considerably speed up computations.
@sp 1
@item @strong{Reserved attributes:}
(not all are in use at the moment)
@table @code
@item isSB
the standard basis property is set by all commands computing a standard
basis like
@code{groebner}, @code{std}, @code{stdhilb} etc.; used by @code{lift}, @code{dim},
@code{degree}, @code{mult}, @code{hilb}, @code{vdim}, @code{kbase}
@item isHomog
the weight vector for homogeneous or quasihomogeneous ideals/modules
@item isCI
complete intersection property
@item isCM
Cohen-Macaulay property
@item rank
set the rank of a module (see @ref{nrows})
@item withSB
value of type ideal, resp.@: module, is std
@item withHilb
value of type intvec is hilb(_,1) (see @ref{hilb})
@item withRes
value of type list is a free resolution
@item withDim
value of type int is the dimension (see @ref{dim})
@item withMult
value of type int is the multiplicity (see @ref{mult})
@c @item @code{D}
@c object is an differential operator, if set to 1;
@c @*object is in a module, if set to 0
@c @*only valid in a dring (see @ref{dring}).
@end table
@end table
@c @c ref
@c See
@c @ref{Expressions};
@c @ref{killattrib}.
@c @c ref
@c ---------------------------------------
@node bareiss, betti, attrib, Functions
@subsection bareiss
@cindex bareiss

@table @code
@item @strong{Syntax:}
@code{bareiss (} module_expression @code{)}
@*@code{bareiss (} matrix_expression @code{)}
@*@code{bareiss (} module_expression@code{,} int_expression@code{,} int_expression @code{)}
@*@code{bareiss (} matrix_expression@code{,} int_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list of module and intvec
@item @strong{Purpose:}
applies the sparse Gauss-Bareiss algorithm (see @ref{References}, Lee and
Saunders) to a module (or with type conversion to a matrix) with an 'optimal'
pivot strategy. The vectors of the module are the columns of the matrix,
hence elimination takes place w.r.t.@: rows.
@* With only one parameter a complete elimination is done.
Result is a list: the first entry is a module with a minimal independent set
of vectors (as a matrix lower triangular),
the second entry an intvec with the permutation of the rows
w.r.t.@: the original matrix, that is, a k at position l indicates that
row l became row k.
@* The further parameters control the algorithm. @code{bareiss(M,i,j)}
does not consider the last i rows in the elimination procedure and stops
computing when the remaining number of vectors (columns) to reduce is at
most j.
@item @strong{Example:}
@smallexample
@c reused example bareiss reference.doc:324 
  ring r=0,(x,y,z),(c,dp);
  module mm;
  // ** generation of the module mm **
  int d=7;
  int b=2;
  int db=d-b;
  int i;
  for(i=d;i>0;i--)@{ mm[i]=3*x*gen(i); @}
  for(i=db;i;i--)@{ mm[i]=mm[i]+7*y*gen(i+b); @}
  for(i=d;i>db;i--)@{ mm[i]=mm[i]+7*y*gen(i-db); @}
  for(i=d;i>b;i--)@{ mm[i]=mm[i]+11*z*gen(i-b); @}
  for(i=b;i;i--)@{ mm[i]=mm[i]+11*z*gen(i+db); @}
  // ** the generating matrix of mm **
  print(mm);
@expansion{} 3x, 0,  11z,0,  0,  7y, 0,  
@expansion{} 0,  3x, 0,  11z,0,  0,  7y, 
@expansion{} 7y, 0,  3x, 0,  11z,0,  0,  
@expansion{} 0,  7y, 0,  3x, 0,  11z,0,  
@expansion{} 0,  0,  7y, 0,  3x, 0,  11z,
@expansion{} 11z,0,  0,  7y, 0,  3x, 0,  
@expansion{} 0,  11z,0,  0,  7y, 0,  3x  
  // complete elimination
  list ss=bareiss(mm);
  print(ss[1]);
@expansion{} 7y, 0,     0,     0,      0,        0,     0,    
@expansion{} 3x, -33xz, 0,     0,      0,        0,     0,    
@expansion{} 11z,-121z2,1331z3,0,      0,        0,     0,    
@expansion{} 0,  0,     0,     9317yz3,0,        0,     0,    
@expansion{} 0,  21xy,  _[5,3],14641z4,-43923xz4,0,     0,    
@expansion{} 0,  0,     0,     0,      65219y2z3,_[6,6],0,    
@expansion{} 0,  49y2,  _[7,3],3993xz3,_[7,5],   _[7,6],_[7,7]
  ss[2];
@expansion{} 2,7,5,1,4,3,6
  // elimination up to 3 vectors
  ss=bareiss(mm,0,3);
  print(ss[1]);
@expansion{} 7y, 0,     0,     0,      0,        0,        0,        
@expansion{} 3x, -33xz, 0,     0,      0,        0,        0,        
@expansion{} 11z,-121z2,1331z3,0,      0,        0,        0,        
@expansion{} 0,  0,     0,     9317yz3,0,        0,        0,        
@expansion{} 0,  0,     0,     0,      27951xyz3,102487yz4,65219y2z3,
@expansion{} 0,  21xy,  _[6,3],14641z4,_[6,5],   _[6,6],   -43923xz4,
@expansion{} 0,  49y2,  _[7,3],3993xz3,_[7,5],   _[7,6],   _[7,7]    
  ss[2];
@expansion{} 2,7,5,1,3,4,6
  // elimination without the last 3 rows
  ss=bareiss(mm,3,0);
  print(ss[1]);
@expansion{} 7y, 0,   0,      0,       0,     0,     0,       
@expansion{} 0,  77yz,0,      0,       0,     0,     0,       
@expansion{} 0,  0,   231xyz, 0,       0,     0,     0,       
@expansion{} 0,  0,   0,      1617xy2z,0,     0,     0,       
@expansion{} 11z,21xy,-1331z3,14641z4, _[5,5],_[5,6],_[5,7],  
@expansion{} 0,  0,   539y2z, _[6,4],  _[6,5],_[6,6],-3773y3z,
@expansion{} 3x, 49y2,-363xz2,3993xz3, _[7,5],_[7,6],_[7,7]   
  ss[2];
@expansion{} 2,3,4,1
@c end example bareiss reference.doc:324
@end smallexample
@end table
@c inserted refs from reference.doc:354
@menu
See
* det::
* matrix::
@end menu
@c end inserted refs from reference.doc:354
@c ---------------------------------------
@node betti, char, bareiss, Functions
@subsection betti
@cindex betti
@table @code
@item @strong{Syntax:}
@code{betti (} list_expression @code{)}
@*@code{betti (} resolution_expression @code{)}
@*@code{betti (} list_expression @code{,} int_expression @code{)}
@*@code{betti (} resolution_expression @code{,} int_expression @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
with 1 argument: computes the graded Betti numbers of a minimal resolution of
@tex
$R^n/M$, if $R$ denotes the basering and
$M$ a homogeneous submodule of $R^n$ and the argument represents a
resolution of
$R^n/M$.
@end tex
@tex
The entry d of the intmat at place (i,j) is the minimal number of
generators in degree i+j of the j-th syzygy module (= module of
relations) of $R^n/M$ (the 0th (resp.\ 1st) syzygy module of $R^n/M$ is
$R^n$ (resp.\ $M$)).
@end tex
R^n/M, if R denotes the basering and
M a homogeneous submodule of R^n and the argument represents a resolution of
R^n/M:
@*The entry d of the intmat at place (i,j) is the minimal number of
generators in degree i+j of the j-th syzygy module (= module of
relations) of R^n/M (the 0th (resp.@: 1st) syzygy module of R^n/M is R^n
(resp.@: M)).
The argument is considered to be the result of a res/sres/mres/nres/lres
command. This implies that a zero is only allowed (and counted) as a
generator in the first module.
@*For the computation betti uses only the initial monomials. This could lead
to confusing results for a non-homogeneous input.

The optional second argument is a switch for the minimization of the Betti
numbers. If it is 0 then the Betti numbers correspond exactly to the input -
otherwise the command is identical to the one-argument form.
@item @strong{Example:}
@smallexample
@c reused example betti reference.doc:408 
  ring r=32003,(a,b,c,d),dp;
  ideal j=bc-ad,b3-a2c,c3-bd2,ac2-b2d;
  list T=mres(j,0); // 0 forces a full resolution
  // a minimal set of generators for j:
  print(T[1]);
@expansion{} bc-ad,
@expansion{} c3-bd2,
@expansion{} ac2-b2d,
@expansion{} b3-a2c
  // second syzygy module of r/j which is the first
  // syzygy module of j (minimal generating set):
  print(T[2]);
@expansion{} bd,c2,ac,b2,
@expansion{} -a,-b,0, 0, 
@expansion{} c, d, -b,-a,
@expansion{} 0, 0, -d,-c 
  // the second syzygy module (minimal generating set):
  print(T[3]);
@expansion{} -b,
@expansion{} a, 
@expansion{} -c,
@expansion{} d  
  print(T[4]);
@expansion{} 0
  betti(T);
@expansion{} 1,0,0,0,
@expansion{} 0,1,0,0,
@expansion{} 0,3,4,1 
  // most useful for reading off the graded Betti numbers:
  print(betti(T),"betti");
@expansion{}            0     1     2     3
@expansion{} ------------------------------
@expansion{}     0:     1     -     -     -
@expansion{}     1:     -     1     -     -
@expansion{}     2:     -     3     4     1
@expansion{} ------------------------------
@expansion{} total:     1     4     4     1
@c end example betti reference.doc:408
@end smallexample
@end table

Hence
@itemize @bullet
@item the 0th syzygy module of r/j (which is r) has 1 generator in
degree 0 (which is 1),
@item the 1st syzygy module @code{T[1]} (which is j) has 4
generators (one in degree 2 and three in degree 3),
@item the 2nd syzygy
module @code{T[2]} has 4 generators (all in degree 4),
@item the 3rd syzygy module @code{T[3]} has
1 generator in degree 5,
@end itemize
where the generators are the columns of the
displayed matrix and degrees are assigned such that the corresponding maps
have degree 0:
@tex
$$
0 \longleftarrow r/j \longleftarrow r(1)
\buildrel{T[1]}\over{\longleftarrow} r(2) \oplus r^3(3)
\buildrel{T[2]}\over{\longleftarrow} r^4(4)
\buildrel{T[3]}\over{\longleftarrow} r(5)
\longleftarrow 0 \quad .
$$
@end tex
@*                     T[1]                T[2]           T[3]
@*0 <-- r/j <-- r(1) <------ r(2)+r^3(3) <------ r^4(4) <------ r(5) <-- 0 .

@c inserted refs from reference.doc:455
@menu
See
* Syzygies and resolutions::
* hres::
* lres::
* mres::
* print::
* res::
* resolution::
* sres::
@end menu
@c end inserted refs from reference.doc:455
@c ---------------------------------------
@node char, char_series, betti, Functions
@subsection char
@cindex char

@table @code
@item @strong{Syntax:}
@code{char (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the characteristic of the coefficient field of a ring.
@item @strong{Example:}
@smallexample
@c reused example char reference.doc:480 
  ring r=32003,(x,y),dp;
  char(r);
@expansion{} 32003
  ring s=0,(x,y),dp;
  char(s);
@expansion{} 0
  ring ra=(7,a),(x,y),dp;
  minpoly=a^3+a+1;
  char(ra);
@expansion{} 7
  ring rp=(49,a),(x,y),dp;
  char(rp);
@expansion{} 7
  ring rr=real,x,dp;
  char(rr);
@expansion{} 0
@c end example char reference.doc:480
@end smallexample
@end table
@c inserted refs from reference.doc:495
@menu
See
* charstr::
* ring::
@end menu
@c end inserted refs from reference.doc:495
@c ---------------------------------------
@node char_series, charstr, char, Functions
@subsection char_series
@cindex char_series

@table @code
@item @strong{Syntax:}
@code{char_series (} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
the rows of the matrix represent the irreducible characteristic series of the
ideal with respect to the current ordering of variables.
@*One application is the decomposition of the zero-set.
@item @strong{Example:}
@smallexample
@c reused example char_series reference.doc:516 
  ring r=32003,(x,y,z),dp;
  print(char_series(ideal(xyz,xz,y)));
@expansion{} y,z,
@expansion{} x,y 
@c end example char_series reference.doc:516
@end smallexample
@c @item @strong{Background:}
@c @tex
@c Let $>$ be the lexicographical ordering $x_1 < ... < x_n$ on $R=K[x_1,...,x_n]$.
@c For $f \in R$ let lvar(f) (the leading variable of f) be the largest
@c variable in lead(f) (the leading term of f with respect to $>$),
@c i.e., if $f=a_k(x_1,...,x_{k-1})x_k^s+...+a_0(x_1,...,x_{k-1})$ for some
@c $k \leq n$ then $lvar(f)=x_k$, moreover let $ini(f):=a_k(x_1,...,x_{k-1})$.
@c
@c A set $T=\{f_1,...,f_r\} \subset R$ is called triangular if $lvar(f_1)<...<lvar(f_r)$.
@c The pseudo remainder $r=prem(g,f)$ of $g$ with respect to $f$ is defined by
@c $ini(f)^a*g=q*f+r$ with the property $deg_{lvar(f)}(r)<deg_{lvar(f)}(f)$,
@c a minimal.
@c
@c (T,U) is called a triangular system, if T is a triangular set such that ini(T)
@c does not vanish on $Zero(T) \setminus Zero(U)
@c ( =:Zero(T\setminus U))$.
@c
@c T is called irreducible if for every i there are no $d_i$,$f_i'$,$f_i''$ with
@c the property:
@c $$   lvar(d_i)<lvar(f_i) $$
@c $$   lvar(f_i')=lvar(f_i'')=lvar(f_i)$$
@c $$   0 \not\in prem(\{ d_i, ini(f_i'), ini(f_i'')\},\{ f_1,...,f_(i-1)\})$$
@c such that $prem(d_i*f_i-f_i'*f_i'',\{f_1,...,f_(i-1)\})=0$.
@c
@c (T,U) is irreducible if T is irreducible.
@c
@c Let $G=\{g_1,...,g_s\}$ then there are irreducible triangular sets $T_1,...,T_l$
@c such that $Zero(G)=\bigcup(i=1..l: Zero(T_i\setminus I_i))$
@c where $I_i=\{ini(f), f \in T_i \}$.
@c @end tex
@c @ifinfo
@c Let > be the lexicographical ordering x_1 < ... < x_n on R=K[x_1,...,x_n].
@c For f in R let lvar(f) (the leading variable of f) be the largest
@c variable in lead(f) (the leading term of f with respect to >),
@c i.e., if f=a_k(x_1,...,x_(k-1))x_k^s+...+a_0(x_1,...,x_(k-1)) for some
@c k<=n then lvar(f)=x_k, moreover let ini(f):=a_k(x_1,...,x_(k-1)).
@c
@c A set T=@{f_1,...,f_r@} in R is called triangular if lvar(f_1)<...<lvar(f_r).
@c The pseudo remainder r=prem(g,f) of g with respect to f is defined by
@c ini(f)^a*g=q*f+r with the property deg_(lvar(f))(r)<deg_(lvar(f))(f),s
@c a minimal.
@c
@c (T,U) is called a triangular system, if T is a triangular set such that ini(T)
@c does not vanish on the zero-set of T \ zero-set of U
@c ( =:Zero(T\U)).
@c
@c T is called irreducible if for every i there are no d_i,f_i',f_i'' with
@c the property:
@c @*   lvar(d_i)<lvar(f_i)
@c @*   lvar(f_i')=lvar(f_i'')=lvar(f_i)
@c @*   0 not in prem(@{ d_i, ini(f_i'), ini(f_i'')@},@{ f_1,...,f_(i-1)@})
@c @*such that prem(d_i*f_i-f_i'*f_i'',@{f_1,...,f_(i-1)@})=0.
@c
@c (T,U) is irreducible if T is irreducible.
@c
@c Let G=@{g_1,...,g_s@} then there are irreducible triangular sets T_1,...,T_l
@c such that Zero(G)=Union(i=1..l: Zero(T_i\I_i))
@c where I_i=@{ini(f), f in T_i @}.
@c @end ifinfo
@c @item @strong{Example:}
@c @example
@c @c example
@c   ring R=0,(x,y,z,u),dp;
@c   ideal i=-3zu+y2-2x+2,
@c           -3x2u-4yz-6xz+2y2+3xy,
@c           -3z2u-xu+y2z+y;
@c   print(char_series(i));
@c @c example
@c @end example
@end table

@c inserted refs from reference.doc:592
@menu
See
* Characteristic sets::
@end menu
@c end inserted refs from reference.doc:592
@c ---------------------------------------
@node charstr, cleardenom, char_series, Functions
@subsection charstr
@cindex charstr

@table @code
@item @strong{Syntax:}
@code{charstr (} ring_name @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the description of the coefficient field of a ring.
@item @strong{Example:}
@smallexample
@c reused example charstr reference.doc:610 
  ring r=32003,(x,y),dp;
  charstr(r);
@expansion{} 32003
  ring s=0,(x,y),dp;
  charstr(s);
@expansion{} 0
  ring ra=(7,a),(x,y),dp;
  minpoly=a^3+a+1;
  charstr(ra);
@expansion{} 7,a
  ring rp=(49,a),(x,y),dp;
  charstr(rp);
@expansion{} 49,a
  ring rr=real,x,dp;
  charstr(rr);
@expansion{} real
@c end example charstr reference.doc:610
@end smallexample
@end table
@c inserted refs from reference.doc:625
@menu
See
* char::
* ordstr::
* ring::
* varstr::
@end menu
@c end inserted refs from reference.doc:625
@c ---------------------------------------
@node cleardenom, close, charstr, Functions
@subsection cleardenom
@cindex cleardenom

@table @code
@item @strong{Syntax:}
@code{cleardenom (} poly_expression @code{)}
@*@code{cleardenom (} vector_expression @code{)}
@item @strong{Type:}
same as the input type
@item @strong{Purpose:}
multiplies a polynomial, resp.@: vector, by a suitable constant to cancel
all denominators from its coefficients and then divide it by its content.
@item @strong{Example:}
@smallexample
@c reused example cleardenom reference.doc:648 
  ring r=0,(x,y,z),dp;
  poly f=(3x+6y)^5;
  f/5;
@expansion{} 243/5x5+486x4y+1944x3y2+3888x2y3+3888xy4+7776/5y5
  cleardenom(f/5);
@expansion{} x5+10x4y+40x3y2+80x2y3+80xy4+32y5
@c end example cleardenom reference.doc:648
@end smallexample
@end table
@c @c ref
@c See @ref{poly}.
@c @c ref
@c ---------------------------------------
@node close, coef, cleardenom, Functions
@subsection close
@cindex close
@table @code
@item @strong{Syntax:}
@code{close (} link_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
closes a link.
@item @strong{Example:}
@smallexample
link l="MPtcp:launch";
open(l); // start SINGULAR "server" on localhost in batchmode
close(l); // shut down SINGULAR server
@end smallexample
@end table
@c inserted refs from reference.doc:677
@menu
See
* link::
* open::
@end menu
@c end inserted refs from reference.doc:677
@c ---------------------------------------
@node coef, coeffs, close, Functions
@subsection coef
@cindex coef

@table @code
@item @strong{Syntax:}
@code{coef (} poly_expression@code{,} product_of_ringvars @code{)}
@item @strong{Type:}
matrix
@item @strong{Syntax:}
@code{coef (} vector_expression@code{,} product_of_ringvars@code{,} matrix_name@code{,} matrix_name @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
determines the monomials in f divisible by one of the ring variables of m
(where f is the first argument and m the second argument) and the coefficients
of these monomials as polynomials in the remaining variables.

First case:  returns a 2 x n matrix M, n being the number
of the determined monomials.
The first row consists of these monomials, the second row
of the corresponding coefficients of the monomials in f.
Thus, f = M[1,1]*M[2,1]+...+M[1,n]*M[2,n].

Second case: the second matrix (i.e., the 4th argument) contains the
monomials, the first matrix (i.e., the 3rd argument) the corresponding
coefficients of the monomials in the vector.

@item @strong{Note:}
coef considers only monomials which really occur in f (i.e., which are not 0),
while coeffs (see @ref{coeffs}) returns the coefficient 0 at the
appropriate place if a monomial is not present.

@item @strong{Example:}
@smallexample
@c reused example coef reference.doc:718 
  ring r=32003,(x,y,z),dp;
  poly f=x5+5x4y+10x2y3+y5;
  matrix m=coef(f,y);
  print(m);
@expansion{} y5,y3,  y,  1,
@expansion{} 1, 10x2,5x4,x5
  f=x20+xyz+xy+x2y+z3;
  print(coef(f,xy));
@expansion{} x20,x2y,xy, 1,
@expansion{} 1,  1,  z+1,z3
  vector v=[f,zy+77+xy];
  print(v);
@expansion{} [x20+x2y+xyz+z3+xy,xy+yz+77]
  matrix mc; matrix mm;
  coef(v,y,mc,mm);
  print(mc);
@expansion{} x2+xz+x,x20+z3,
@expansion{} x+z,    77     
  print(mm);
@expansion{} y,1,
@expansion{} y,1 
@c end example coef reference.doc:718
@end smallexample
@end table
@c inserted refs from reference.doc:734
@menu
See
* coeffs::
@end menu
@c end inserted refs from reference.doc:734
@c ---------------------------------------
@node coeffs, contract, coef, Functions
@subsection coeffs
@cindex coeffs

@table @code
@item @strong{Syntax:}
@code{coeffs (} poly_expression @code{,} ring_variable @code{)}
@*@code{coeffs (} ideal_expression@code{,} ring_variable @code{)}
@*@code{coeffs (} vector_expression@code{,} ring_variable @code{)}
@*@code{coeffs (} module_expression@code{,} ring_variable @code{)}
@*@code{coeffs (} poly_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (} ideal_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (} vector_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@*@code{coeffs (} module_expression@code{,} ring_variable@code{,} matrix_name @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
develops each polynomial of the first argument, say J,
as a univariate polynomial in the given ring_variable,
say z, and returns the coefficients as a k x d
matrix M,
where:
@format
    d-1 = maximum z-degree of all occurring polynomials
      k = 1 if J is a polynomial,
      k = number of generators  if J is an ideal.
@end format
If J is a vector or a module this procedure is repeated for each
component and the resulting matrices are appended.@*
The third argument is used to return the matrix T of coefficients
such that matrix(J) = T*M.
@tex
The third argument is used to return the matrix T of coefficients
such that {\tt matrix}(J) = T*M.
@end tex
@item @strong{Note:}
@code{coeffs} returns the coefficient 0 at the appropriate place if a monomial
is not present, while @code{coef} considers only monomials which really occur
in the given expression. @*
If
@tex
$M=(m_{ij})$
@end tex
M=(M[i,j])
then the j-th generator of an ideal J is equal to
@tex
$$J_j = z^0 \cdot m_{1j} + z^1 \cdot m_{2j} + ... + z^{d-1} \cdot m_{dj},$$
while for a module J the i-th component of the j-th generator is
equal to the entry [i,j] of {\tt matrix}(J), and we get
@end tex

@*
@format
   J[j] = z^0*M[1,j] + z^1*M[2,j] + ... + z^(d-1)*M[d,j],
@end format
@*while for a module J the i-th component of the j-th generator is
equal to the entry [i,j] of matrix(J), and we get
@tex
$$ J_{i,j} = z^0 \cdot m_{(i-1)d+1,j} + z^1 \cdot m_{(i-1)d+2,j} + ... +
z^{d-1} \cdot m_{id,j}.$$
@end tex

@*
@format
 J[i,j] = z^0*M[(i-1)*d+1,j] + z^1*M[(i-1)*d+2,j] + ...
                             + z^(d-1)*M[i*d,j].
@end format

@item @strong{Example:}
@smallexample
@c reused example coeffs reference.doc:817 
  ring r;
  poly f=(x+y)^3;
  matrix M=coeffs(f,y);
  print(M);
@expansion{} x3, 
@expansion{} 3x2,
@expansion{} 3x, 
@expansion{} 1   
  ideal i=f,xyz+z10y4;
  print(coeffs(i,y));
@expansion{} x3, 0, 
@expansion{} 3x2,xz,
@expansion{} 3x, 0, 
@expansion{} 1,  0, 
@expansion{} 0,  z10
@c end example coeffs reference.doc:817
@end smallexample
@item @strong{Syntax:}
@code{coeffs (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{coeffs (} module_expression@code{,} module_expression @code{)}
@*@code{coeffs (} ideal_expression@code{,} ideal_expression@code{,} product_of_ringvars @code{)}
@*@code{coeffs (} module_expression@code{,} module_expression@code{,} product_of_ringvars @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
let the first argument be M,
the second argument  be K (a set of monomials, resp.@: vectors with monomial
entries, in the variables appearing in P),
the third argument be the product P of variables to consider (if this
argument is not given, then the product of all ring variables is taken
as default argument).
@*M is supposed to consist of elements of (resp.@: have entries in)
a finitely generated module
over a ring in the variables not appearing in P. K should contain the
generators of M over this smaller ring.
Then @code{coeffs(M,K,P)} returns a matrix A of coefficients with K*A=M
such that the entries of A do not contain any variable from P.
@*If K does not contain all generators that are necessary to express
M, then K*A=M' where M' is the part of M that can be expressed.

@item @strong{Example:}
@smallexample
@c reused example coeffs_1 reference.doc:851 
  ring r=32003,(x,y,z),dp;
  ideal M=x2z+y3,xy;
  print(coeffs(M,ideal(x2,xy,y2),xy));
@expansion{} z,0,
@expansion{} 0,1,
@expansion{} 0,0 
  print(coeffs(M,ideal(x2,xy,y2)));
@expansion{} 0,0,
@expansion{} 0,1,
@expansion{} 0,0 
@c end example coeffs_1 reference.doc:851
@end smallexample
@end table
@c inserted refs from reference.doc:859
@menu
See
* coef::
* kbase::
@end menu
@c end inserted refs from reference.doc:859
@c ---------------------------------------
@node contract, dbprint, coeffs, Functions
@subsection contract
@cindex contract

@table @code
@item @strong{Syntax:}
@code{contract (} ideal_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
contracts each of the n elements of the second ideal J
by each of the m elements of the first ideal I,
producing a m x n matrix.
@*Contraction is defined on monomials by:
@*
@format
  contract(x^A,x^B) := x^(B-A) (if B>=A componentwise),
                    :=   0     (otherwise),
@end format
@tex
$${\rm contract}(x^A ,  x^B) := \cases{ x^{(B-A)}, &if $B\ge A$
componentwise\cr 0,&otherwise.\cr}$$
@end tex
where A and B are the multiexponents of the ring variables represented by
@tex
$x$.
@end tex
x.
@code{contract} is extended bilinearly to all polynomials.
@item @strong{Example:}
@smallexample
@c reused example contract reference.doc:900 
  ring r=0,(a,b,c,d),dp;
  ideal I=a2,a2+bc,abc;
  ideal J=a2-bc,abcd;
  print(contract(I,J));
@expansion{} 1,0, 
@expansion{} 0,ad,
@expansion{} 0,d  
@c end example contract reference.doc:900
@end smallexample
@end table
@c inserted refs from reference.doc:908
@menu
See
* diff::
@end menu
@c end inserted refs from reference.doc:908
@c ---------------------------------------
@node dbprint, defined, contract, Functions
@subsection dbprint
@cindex dbprint
@table @code
@item @strong{Syntax:}
@code{dbprint (} int_expression@code{,} expression_list @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
applies the print command to each expression in the expression_list if
int_expression is positive.
@code{dbprint} may also be used in procedures
in order to print results subject to certain
conditions.
@item @strong{Syntax:}
@code{dbprint (} expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
The print command is applied to the expression
if @code{printlevel>=voice}.
@item @strong{Note:}
@xref{Guidelines for writing a library}, for an example how this is used
for displaying comments while procedures are executed.
@item @strong{Example:}
@smallexample
@c reused example dbprint reference.doc:939 
  int debug=0;
  intvec i=1,2,3;
  dbprint(debug,i);
  debug=1;
  dbprint(debug,i);
@expansion{} 1,2,3
  voice;
@expansion{} 1
  printlevel;
@expansion{} 0
  dbprint(i);
@c end example dbprint reference.doc:939
@end smallexample
@end table
@c inserted refs from reference.doc:951
@menu
See
* Debugging tools::
* print::
* printlevel::
* voice::
@end menu
@c end inserted refs from reference.doc:951
@c ---------------------------------------
@node defined, deg, dbprint, Functions
@subsection defined
@cindex defined

@table @code
@item @strong{Syntax:}
@code{defined (} name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns a value <>0 (TRUE) if there is a user-defined object with this name,
and 0 (FALSE) otherwise.
@*A non-zero return value is the level where the object is defined (level
1 denotes the top level, level 2 the level of a first procedure, level 3
the level of a procedure called by a first procedure, etc.). For ring
variables, -1 is returned.
@item @strong{Note:}
A local object @code{m} may be identified by @code{if
(defined(m)==voice)}.
@item @strong{Example:}
@smallexample
@c reused example defined reference.doc:980 
  ring r=(0,t),(x,y),dp;
  matrix m[5][6]=x,y,1,2,0,x+y;
  defined(mm);
@expansion{} 0
  defined(r) and defined(m);
@expansion{} 1
  defined(m)==voice;   // m is defined in the current level
@expansion{} 1
  defined(x);
@expansion{} -1
  defined(z);
@expansion{} 0
  defined(t);
@expansion{} -1
  defined(42);
@expansion{} -1
@c end example defined reference.doc:980
@end smallexample
@end table
@c inserted refs from reference.doc:993
@menu
See
* rvar::
* voice::
@end menu
@c end inserted refs from reference.doc:993
@c ---------------------------------------
@node deg, degree, defined, Functions
@subsection deg
@cindex deg

@table @code
@item @strong{Syntax:}
@code{deg (} poly_expression @code{)}
@*@code{deg (} vector_expression @code{)}
@*@code{deg (} poly_expression @code{,} intvec_expression @code{)}
@*@code{deg (} vector_expression @code{,} intvec_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the maximal (weighted) degree of
the terms of a polynomial or a vector;
@*deg(0) is -1.
@*The optional second argument gives the weight vector,
the default weights of the base ring will be used otherwise.
@item @strong{Example:}
@smallexample
@c reused example deg reference.doc:1019 
  ring r=0,(x,y,z),lp;
  deg(0);
@expansion{} -1
  deg(x3+y4+xyz3);
@expansion{} 5
  ring rr=7,(x,y),wp(2,3);
  poly f=x2+y3;
  deg(f);
@expansion{} 9
  ring R=7,(x,y),ws(2,3);
  poly f=x2+y3;
  deg(f);
@expansion{} 9
  vector v=[x2,y];
  deg(v);
@expansion{} 4
@c end example deg reference.doc:1019
@end smallexample
@end table
@c inserted refs from reference.doc:1034
@menu
See
* jet::
* ord::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:1034
@c ---------------------------------------
@node degree, delete, deg, Functions
@subsection degree
@cindex degree
@table @code
@item @strong{Syntax:}
@code{degree (} ideal_expression @code{)}
@*@code{degree (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the (weighted) degree of the projective
variety, respectively sheaf over the projective variety, defined by the ideal,
respectively module, generated by the leading monomials of the input.  
This is equal to the
(weighted) degree of the projective variety, respectively
sheaf over the projective variety, defined by the ideal,
respectively module, if the 
input is a standard basis with respect to a (weighted) degree ordering. 
@item @strong{Example:}
@smallexample
ring r3=32003,(x,y,z,h),dp;
int a,b,c,t=11,10,3,1;
poly f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
  +x^(c-2)*y^c*(y2+t*x)^2;
ideal i=jacob(f);
i=homog(i,h);
ideal i0=std(i);
degree(i0);
@expansion{} 720 
@end smallexample
@end table
@c inserted refs from reference.doc:1073
@menu
See
* dim::
* ideal::
* mult::
* std::
* vdim::
@end menu
@c end inserted refs from reference.doc:1073
@c ---------------------------------------
@node delete, det, degree, Functions
@subsection delete
@cindex delete

@table @code
@item @strong{Syntax:}
@code{delete (} list_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
deletes the element with the given index from a list (the input is not changed).
@item @strong{Example:}
@smallexample
@c reused example delete reference.doc:1095 
  list l="a","b","c";
  list l1=delete(l,2);l1;
@expansion{} [1]:
@expansion{}    a
@expansion{} [2]:
@expansion{}    c
  l;
@expansion{} [1]:
@expansion{}    a
@expansion{} [2]:
@expansion{}    b
@expansion{} [3]:
@expansion{}    c
@c end example delete reference.doc:1095
@end smallexample
@end table
@c inserted refs from reference.doc:1102
@menu
See
* insert::
* list::
@end menu
@c end inserted refs from reference.doc:1102
@c ---------------------------------------
@node det, diff, delete, Functions
@subsection det
@cindex det

@table @code
@item @strong{Syntax:}
@code{det (} intmat_expression @code{)}
@*@code{det (} matrix_expression @code{)}
@*@code{det (} module_expression @code{)}
@item @strong{Type:}
int, resp.@: poly
@item @strong{Purpose:}
returns the determinant of a square matrix. A module is considered
as a matrix. The applied algorithms depend on type of input.
If the input is a module or matrix with symbolic entries the
Bareiss algorithm is used. In the other cases the chinese remainder
algorithm is used. For large sparse problems the input as a module
has advantages.
@item @strong{Example:}
@smallexample
@c reused example det reference.doc:1128 
  ring r=7,(x,y),wp(2,3);
  matrix m[3][3]=1,2,3,4,5,6,7,8,x;
  det(m);
@expansion{} -3x-1
@c end example det reference.doc:1128
@end smallexample
@end table
@c inserted refs from reference.doc:1135
@menu
See
* intmat::
* matrix::
* minor::
@end menu
@c end inserted refs from reference.doc:1135
@c ---------------------------------------
@node diff, dim, det, Functions
@subsection diff
@cindex diff

@table @code
@item @strong{Syntax:}
@code{diff (} poly_expression@code{,} ring_variable @code{)}
@*@code{diff (} vector_expression@code{,} ring_variable @code{)}
@*@code{diff (} ideal_expression@code{,} ring_variable @code{)}
@*@code{diff (} module_expression@code{,} ring_variable @code{)}
@*@code{diff (} matrix_expression@code{,} ring_variable @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Syntax:}
@code{diff (} ideal_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
computes the partial derivative of a polynomial object by a ring variable
(first forms)
@*respectively differentiates each polynomial (1..n) of the second ideal
by the differential operator corresponding to each polynomial (1..m) in the first
ideal, producing an m x n matrix.
@item @strong{Example:}
@smallexample
@c reused example diff reference.doc:1167 
  ring r=0,(x,y,z),dp;
  poly f=2x3y+3z5;
  diff(f,x);
@expansion{} 6x2y
  vector v=[f,y2+z];
  diff(v,z);
@expansion{} 15z4*gen(1)+gen(2)
  ideal j=x2-yz,xyz;
  ideal i=x2,x2+yz,xyz;
  // corresponds to differential operators
  // d2/dx2, d2/dx2+d2/dydz, d3/dxdydz:
  print(diff(i,j));
@expansion{} 2,0,
@expansion{} 1,x,
@expansion{} 0,1 
@c end example diff reference.doc:1167
@end smallexample
@end table
@c inserted refs from reference.doc:1181
@menu
See
* contract::
* ideal::
* jacob::
* matrix::
* module::
* poly::
* var::
* vector::
@end menu
@c end inserted refs from reference.doc:1181
@c ---------------------------------------
@node dim, division, diff, Functions
@subsection dim
@cindex dim

@table @code
@item @strong{Syntax:}
@code{dim (} ideal_expression @code{)}
@*@code{dim (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the dimension of the ideal, resp.@: module, generated by
the leading monomials of the given generators of the ideal, resp.@: module.
This is also the dimension of the ideal if it is represented by
a standard basis.
@item @strong{Note:}
The dimension of an ideal I means
the Krull dimension of the basering modulo I.
@*The dimension of a
module is the dimension of its annihilator ideal.
@item @strong{Example:}
@smallexample
@c reused example dim reference.doc:1215 
  ring r=32003,(x,y,z),dp;
  ideal I=x2-y,x3;
  dim(std(I));
@expansion{} 1
@c end example dim reference.doc:1215
@end smallexample
@end table
@c inserted refs from reference.doc:1222
@menu
See
* degree::
* ideal::
* mult::
* std::
* vdim::
@end menu
@c end inserted refs from reference.doc:1222
@c -------------------------------------------------
@node division, dump, dim, Functions
@subsection division
@cindex division
@table @code
@item @strong{Syntax:}
@code{division (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{division (} module_expression@code{,} module_expression @code{)}
@*@code{division (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{division (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{division (} ideal_expression@code{,} ideal_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{division (} module_expression@code{,} module_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
@code{division} computes a division with remainder.
For two ideals resp.@: modules @code{M} (first argument) and @code{N} (second argument), it returns a list @code{T,R,U} where @code{T} is a matrix, @code{R} is an ideal resp. a module, and @code{U} is a diagonal matrix of units such that @code{matrix(M)*U=matrix(N)*T+matrix(R)} is a standard representation for the normal form @code{R} of @code{M} with respect to a standard basis of @code{N}.
@code{division} uses different algorithms depending on whether @code{N} is represented by a standard basis.
For a polynomial basering, the matrix @code{U} is the identity matrix.
A matrix @code{T} as above is also computed by @code{lift}.
@*For additional arguments @code{n} (third argument) and @code{w} (fourth argument), @code{division} returns a list @code{T,R} as above such that @code{matrix(M)=matrix(N)*T+matrix(R)} is a standard representation for the normal form @code{R} of @code{M} with respect to @code{N} up to weighted degree @code{n} with respect to the weight vector @code{w}.
The weighted degree of @code{T} and @code{R} respect to @code{w} is at most @code{n}.
If the weight vector @code{w} is not given, @code{division} uses the standard weight vector @code{w=1,...,1}.
@item @strong{Example:}
@smallexample
@c reused example division reference.doc:1255 
ring R=0,(x,y),ds;
poly f=x5+x2y2+y5;
division(f,jacob(f));
@expansion{} [1]:
@expansion{}    _[1,1]=1/5x
@expansion{}    _[2,1]=3/10y
@expansion{} [2]:
@expansion{}    _[1]=-1/2y5
@expansion{} [3]:
@expansion{}    _[1,1]=1
division(f^2,jacob(f));
@expansion{} [1]:
@expansion{}    _[1,1]=1/20x6-9/80xy5-5/16x7y+5/8x2y6
@expansion{}    _[2,1]=1/8x2y3+1/5x5y+1/20y6-3/4x3y4-5/4x6y2-5/16xy7
@expansion{} [2]:
@expansion{}    _[1]=0
@expansion{} [3]:
@expansion{}    _[1,1]=1/4-25/16xy
division(ideal(f^2),jacob(f),10);
@expansion{} // ** _ is no standardbasis
@expansion{} [1]:
@expansion{}    _[1,1]=-75/8y9
@expansion{}    _[2,1]=1/2x2y3+x5y-1/4y6-3/2x3y4+15/4xy7+375/16x2y8
@expansion{} [2]:
@expansion{}    _[1]=x10+9/4y10
@c end example division reference.doc:1255
@end smallexample
@end table
@c inserted refs from reference.doc:1264
@menu
See
* ideal::
* lift::
* module::
@end menu
@c end inserted refs from reference.doc:1264
@c ---------------------------------------
@node dump, eliminate, division, Functions
@subsection dump
@cindex dump
@table @code
@item @strong{Syntax:}
@code{dump (} link_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
dumps (i.e., writes in one "message" or "block") the state of the @sc{Singular}
session (i.e., all defined variables and their values) to the specified
link (which must be either an ASCII or MP link) such that a
@code{getdump} can retrieve it later on.
@item @strong{Example:}
@smallexample
@c reused example dump reference.doc:1286 
  ring r;
  // write the whole session to the file dump.ascii
  // in ASCII format
  dump(":w dump.ascii");
  kill r;                  // kill the basering
  // reread the session from the file
  // redefining everything which was not explicitly killed before
  getdump("dump.ascii");
@expansion{} // ** redefining stdfglm **
@expansion{} // ** redefining stdhilb **
@expansion{} // ** redefining groebner **
@expansion{} // ** redefining res **
@expansion{} // ** redefining quot **
@expansion{} // ** redefining quot1 **
@expansion{} // ** redefining quotient0 **
@expansion{} // ** redefining quotient1 **
@expansion{} // ** redefining quotient2 **
@expansion{} // ** redefining quotient3 **
@expansion{} // ** redefining quotient5 **
@expansion{} // ** redefining quotient4 **
@expansion{} // ** redefining intersect1 **
@expansion{} // ** redefining sprintf **
@expansion{} // ** redefining printf **
@expansion{} // ** redefining fprintf **
  r;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@c end example dump reference.doc:1286
@end smallexample
@item @strong{Restrictions:}
For ASCII links, integer matrices contained in lists are  dumped as
integer list elements (and not as integer matrices), and lists of lists
are dumped as one flatted list. Furthermore, links
themselves are not dumped.
@end table
@c inserted refs from reference.doc:1304
@menu
See
* getdump::
* link::
* write::
@end menu
@c end inserted refs from reference.doc:1304
@c ---------------------------------------
@node eliminate, eval, dump, Functions
@subsection eliminate
@cindex eliminate

@table @code
@item @strong{Syntax:}
@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{)}
@*@code{eliminate (} ideal_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@*@code{eliminate (} module_expression@code{,} product_of_ring_variables@code{,} intvec_hilb @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
eliminates variables occurring as factors of the second argument from an
ideal, resp.@: module, by intersecting it with the subring not containing
these variables.
@*@code{eliminate} does not need a special ordering nor a standard basis as input.
@item @strong{Note:}
Since elimination is expensive, for homogeneous input it might be useful
first to compute the Hilbert function of the ideal (first
argument) with a fast ordering (e.g., @code{dp}). Then make use of it to speed
up the computation: a Hilbert-driven elimination uses the intvec
provided as the third argument.
@item @strong{Example:}
@smallexample
@c reused example eliminate reference.doc:1336 
  ring r=32003,(x,y,z),dp;
  ideal i=x2,xy,y5;
  eliminate(i,x);
@expansion{} _[1]=y5
  ring R=0,(x,y,t,s,z),dp;
  ideal i=x-t,y-t2,z-t3,s-x+y3;
  eliminate(i,ts);
@expansion{} _[1]=y2-xz
@expansion{} _[2]=xy-z
@expansion{} _[3]=x2-y
  intvec v=hilb(std(i),1);
  eliminate(i,ts,v);
@expansion{} _[1]=y2-xz
@expansion{} _[2]=xy-z
@expansion{} _[3]=x2-y
@c end example eliminate reference.doc:1336
@end smallexample
@end table
@c inserted refs from reference.doc:1348
@menu
See
* hilb::
* ideal::
* module::
* std::
@end menu
@c end inserted refs from reference.doc:1348
@c ---------------------------------------
@node eval, ERROR, eliminate, Functions
@subsection eval
@cindex eval
@table @code
@item @strong{Syntax:}
@code{eval (} expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
evaluates (quoted) expressions. Within a quoted expression, the
quote can be "undone" by an @code{eval} (i.e., each eval "undoes" the
effect of exactly one quote). Used only when receiving a quoted expression
from an MPfile link,
with @code{quote} and @code{write} to
prevent local evaluations  when writing to an MPtcp link.
@item @strong{Example:}
@smallexample
@c @c example unix_only
  link l="MPfile:w example.mp";
  ring r=0,(x,y,z),ds;
  ideal i=maxideal(3);
  ideal j=x7,x2,z;
  // compute i+j before writing, but not std
  // this writes 'std(ideal(x3,...,z))'
  write (l, quote(std(eval(i+j))));
  option(prot);
  close(l);
  // now read it in again and evaluate
  // read(l) forces to compute 'std(ideal(x3,...,z))'
  read(l);
  close(l);
@c @c example
@end smallexample
@end table
@c inserted refs from reference.doc:1390
@menu
See
* MPfile links::
* quote::
* write::
@end menu
@c end inserted refs from reference.doc:1390
@c ---------------------------------------
@node ERROR, example, eval, Functions
@subsection ERROR
@cindex ERROR
@table @code
@item @strong{Syntax:}
@code{ERROR (} string_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
Immediately interrupts the current computation, returns to the
top-level, and displays the argument @code{string_expression} as error
message.

@item @strong{Note:}
This should be used as an emergency, resp.@: failure, exit within procedures.

@item @strong{Example:}
@smallexample
@c reused example ERROR reference.doc:1415 
int i=1;
proc myError() @{ERROR("Need to leave now");i=2;@}
myError();
@expansion{}    ? Need to leave now
@expansion{}    ? error occurred in line 2: `ERROR("Need to leave now");i=2;`
@expansion{}    ? leaving ::myError
@expansion{}    skipping text from `;` error at token `)`
i;
@expansion{} 1
@c end example ERROR reference.doc:1415
@end smallexample
@end table
@c ---------------------------------------
@node example, execute, ERROR, Functions
@subsection example
@cindex example
@table @code
@item @strong{Syntax:}
@code{example} topic @code{;}
@item @strong{Purpose:}
computes an example for @code{topic}. Examples are available for all
@sc{Singular} kernel and library functions. Where available (e.g.,
within Emacs), use @code{<TAB>} completion for a list of all available
example @code{topic}s.
@item @strong{Example:}
@smallexample
example prime;
example intvec_declarations;
@end smallexample
@end table
@c inserted refs from reference.doc:1441
@menu
See also:
* help::
@end menu
@c end inserted refs from reference.doc:1441
@c ---------------------------------------
@node execute, exit, example, Functions
@subsection execute
@cindex execute
@table @code
@item @strong{Syntax:}
@code{execute (} string_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
executes a string containing a sequence of @sc{Singular} commands.
@item @strong{Note:}
The command @code{return} cannot appear in the string.
@* @code{execute} should be avoided in procedures
whenever possible, since it may give rise to name conflicts.  Moreover,
such procedures cannot be precompiled (a feature which @sc{Singular} will
provide in the future).
@item @strong{Example:}
@smallexample
@c reused example execute reference.doc:1463 
  ring r=32003,(x,y,z),dp;
  ideal i=x+y,z3+22y;
  write(":w save_i",i);
  ring r0=0,(x,y,z),Dp;
  string s="ideal k="+read("save_i")+";";
  s;
@expansion{} ideal k=x+y,z3+22y
@expansion{} ;
  execute(s); // define the ideal k
  k;
@expansion{} k[1]=x+y
@expansion{} k[2]=z3+22y
@c end example execute reference.doc:1463
@end smallexample
@end table
@c ---------------------------------------
@node exit, extgcd, execute, Functions
@subsection exit
@cindex exit
@table @code
@item @strong{Syntax:}
@code{exit;}
@item @strong{Purpose:}
exits (quits) @sc{Singular},
works also from inside a procedure or from an interrupt.
@end table
@c ---------------------------------------
@node extgcd, facstd, exit, Functions
@subsection extgcd
@cindex extgcd

@table @code
@item @strong{Syntax:}
@code{extgcd (} int_expression@code{,} int_expression @code{)}
@*@code{extgcd (} poly_expression@code{,} poly_expression @code{)}
@item @strong{Type:}
list of 3 objects of the same type as the type of the arguments
@item @strong{Purpose:}
computes extended gcd: the first element is the greatest common divisor
of the two arguments,
the second and third are factors such that if @code{list L=extgcd(a,b);}
then L[1]=a*L[2]+b*L[3].
@item @strong{Note:}
Polynomials must be univariate to apply @code{extgcd}.
@item @strong{Example:}
@smallexample
@c reused example extgcd reference.doc:1506 
  extgcd(24,10);
@expansion{} [1]:
@expansion{}    2
@expansion{} [2]:
@expansion{}    -2
@expansion{} [3]:
@expansion{}    5
  ring r=0,(x,y),lp;
  extgcd(x4-x6,(x2+x5)*(x2+x3));
@expansion{} [1]:
@expansion{}    2x5+2x4
@expansion{} [2]:
@expansion{}    x2+x+1
@expansion{} [3]:
@expansion{}    1
@c end example extgcd reference.doc:1506
@end smallexample
@end table
@c inserted refs from reference.doc:1513
@menu
See
* gcd::
* int::
* poly::
@end menu
@c end inserted refs from reference.doc:1513
@c ---------------------------------------
@node facstd, factorize, extgcd, Functions
@subsection facstd
@cindex facstd

@table @code
@item @strong{Syntax:}
@code{facstd (} ideal_expression @code{)}
@*@code{facstd (} ideal_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
list of ideals
@item @strong{Purpose:}
returns a list of ideals computed by the factorizing Groebner basis algorithm.
@*The intersection of these ideals has the same zero-set as the input,
i.e., the radical of the intersection coincides with the radical of the input
ideal.
In many (but not all!) cases this is already a decomposition of the radical
of the ideal. (Note however, that, in general, no inclusion between the
input and output ideals holds.)
@*The second, optional argument gives a list of polynomials which define
non-zero constraints. Hence, the intersection of the output ideals
has a zero-set which is the (closure of the) complement of the zero-set
of the second argument in the zero-set of the first argument.
@item @strong{Note:}
Not implemented for baserings over real ground fields, galois fields and
over algebraic extensions over the rational numbers (that is, only
implemented for ground fields for which @ref{factorize} is implemented).
@item @strong{Example:}
@smallexample
@c reused example facstd reference.doc:1548 
  ring r=32003,(x,y,z),(c,dp);
  ideal I=xyz,x2z;
  facstd(I);
@expansion{} [1]:
@expansion{}    _[1]=z
@expansion{} [2]:
@expansion{}    _[1]=x
  facstd(I,x);
@expansion{} [1]:
@expansion{}    _[1]=z
@c end example facstd reference.doc:1548
@end smallexample
@end table
@c inserted refs from reference.doc:1556
@menu
See
* ideal::
* ring::
* std::
@end menu
@c end inserted refs from reference.doc:1556
@c ---------------------------------------
@node factorize, fetch, facstd, Functions
@subsection factorize
@cindex factorize

@table @code
@item @strong{Syntax:}
@code{factorize (} poly_expression @code{)}
@*@code{factorize (} poly_expression@code{, 0 )}
@*@code{factorize (} poly_expression@code{, 2 )}
@item @strong{Type:}
list of ideal and intvec
@*
@item @strong{Syntax:}
@code{factorize (} poly_expression@code{, 1 )}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
computes the irreducible factors (as an ideal) of the polynomial
together with or without
the multiplicities (as an intvec) depending on the second argument:
@format
    0: returns factors and multiplicities, first factor is a constant.
       May also be written with only one argument.
    1: returns non-constant factors (no multiplicities).
    2: returns non-constant factors and multiplicities.
@end format
@item @strong{Note:}
Not implemented for the coefficient fields real and finite fields of
type @code{(p^n,a)}.
@item @strong{Example:}
@smallexample
@c reused example factorize reference.doc:1594 
  ring r=32003,(x,y,z),dp;
  factorize(9*(x-1)^2*(y+z));
@expansion{} [1]:
@expansion{}    _[1]=9
@expansion{}    _[2]=y+z
@expansion{}    _[3]=x-1
@expansion{} [2]:
@expansion{}    1,1,2
  factorize(9*(x-1)^2*(y+z),1);
@expansion{} _[1]=y+z
@expansion{} _[2]=x-1
  factorize(9*(x-1)^2*(y+z),2);
@expansion{} [1]:
@expansion{}    _[1]=y+z
@expansion{}    _[2]=x-1
@expansion{} [2]:
@expansion{}    1,2
@c end example factorize reference.doc:1594
@end smallexample
@end table
@c inserted refs from reference.doc:1602
@menu
See
* poly::
@end menu
@c end inserted refs from reference.doc:1602
@c ---------------------------------------
@node fetch, fglm, factorize, Functions
@subsection fetch
@cindex fetch

@table @code
@item @strong{Syntax:}
@code{fetch (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
maps objects between rings.
@code{fetch} is the identity map between rings and qrings,
the i-th variable of the source ring is mapped to the i-th
variable of the basering.  The coefficient fields must be compatible.
(See @ref{map} for a description of possible mapping between
different ground fields).
@*@code{fetch} offers a convenient way to change
variable names or orderings, or to map objects from a ring to a quotient
ring of that ring or vice versa.
@item @strong{Note:}
Compared with @code{imap}, @code{fetch} uses the position of the ring
variables, not their names.
@item @strong{Example:}
@smallexample
@c reused example fetch reference.doc:1632 
  ring r=0,(x,y,z),dp;
  ideal i=maxideal(2);
  ideal j=std(i);
  poly f=x+y2+z3;
  vector v=[f,1];
  qring q=j;
  poly f=fetch(r,f);
  f;
@expansion{} z3+y2+x
  vector v=fetch(r,v);
  v;
@expansion{} z3*gen(1)+y2*gen(1)+x*gen(1)+gen(2)
  ideal i=fetch(r,i);
  i;
@expansion{} i[1]=z2
@expansion{} i[2]=yz
@expansion{} i[3]=y2
@expansion{} i[4]=xz
@expansion{} i[5]=xy
@expansion{} i[6]=x2
  ring rr=0,(a,b,c),lp;
  poly f=fetch(q,f);
  f;
@expansion{} a+b2+c3
  vector v=fetch(r,v);
  v;
@expansion{} a*gen(1)+b2*gen(1)+c3*gen(1)+gen(2)
  ideal k=fetch(q,i);
  k;
@expansion{} k[1]=c2
@expansion{} k[2]=bc
@expansion{} k[3]=b2
@expansion{} k[4]=ac
@expansion{} k[5]=ab
@expansion{} k[6]=a2
@c end example fetch reference.doc:1632
@end smallexample
@end table
@c inserted refs from reference.doc:1655
@menu
See
* imap::
* map::
* qring::
* ring::
@end menu
@c end inserted refs from reference.doc:1655
@c ---------------------------------------
@node fglm, fglmquot, fetch, Functions
@subsection fglm
@cindex fglm

@table @code
@item @strong{Syntax:}
@code{fglm (} ring_name@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
computes for the given ideal in the given ring
a reduced Groebner basis in the current ring, by applying the so-called FGLM
(Faugere, Gianni, Lazard, Mora)  algorithm.
@*The main application is to compute a lexicographical Groebner basis
from a reduced Groebner basis with respect to a degree ordering. This
can be much faster than computing a lexicographical Groebner basis
directly.
@item @strong{Note:}
The ideal must be zero-dimensional and given as a reduced Groebner
basis in the given ring.
@*The only permissible differences between the given ring and the current ring
are the monomial ordering and a permutation of the variables,
resp.@: parameters.
@item @strong{Example:}
@smallexample
@c reused example fglm reference.doc:1688 
  ring r=0,(x,y,z),dp;
  ideal i=y3+x2, x2y+x2, x3-x2, z4-x2-y;
  option(redSB);   // force the computation of a reduced SB
  i=std(i);
  vdim(i);
@expansion{} 28
  ring s=0,(z,x,y),lp;
  ideal j=fglm(r,i);
  j;
@expansion{} j[1]=y4+y3
@expansion{} j[2]=xy3-y3
@expansion{} j[3]=x2+y3
@expansion{} j[4]=z4+y3-y
@c end example fglm reference.doc:1688
@end smallexample
@end table
@c inserted refs from reference.doc:1700
@menu
See
* fglmquot::
* option::
* qring::
* ring::
* std::
* stdfglm::
* vdim::
@end menu
@c end inserted refs from reference.doc:1700
@c ---------------------------------------
@node fglmquot, filecmd, fglm, Functions
@subsection fglmquot
@cindex fglmquot

@table @code
@item @strong{Syntax:}
@code{fglmquot (} ideal_expression@code{,} poly_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
computes a reduced Groebner basis of the ideal quotient @code{I:p} of
a zero-dimensional ideal @code{I} and a polynomial @code{p} using
FGLM-techniques.
@item @strong{Note:}
The ideal must be zero-dimensional and given as a reduced Groebner
basis in the given ring. The poly must be reduced with respect to the
ideal.
@item @strong{Example:}
@smallexample
@c reused example fglmquot reference.doc:1730 
  ring r=0,(x,y,z),lp;
  ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
  option(redSB);   // force the computation of a reduced SB
  i=std(i);
  poly p=reduce(x+yz2+z10,i);
  ideal j=fglmquot(i,p);
  j;
@expansion{} j[1]=z12
@expansion{} j[2]=yz4-z8
@expansion{} j[3]=y2+y-z8-z4
@expansion{} j[4]=x+y-z10-z6-z4
@c end example fglmquot reference.doc:1730
@end smallexample
@end table
@c inserted refs from reference.doc:1741
@menu
See
* fglm::
* option::
* quotient::
* ring::
* std::
* vdim::
@end menu
@c end inserted refs from reference.doc:1741
@c ---------------------------------------
@node filecmd, find, fglmquot, Functions
@subsection files, input from
@cindex filecmd
@cindex <
@table @code
@item @strong{Syntax:}
@code{< "}filename@code{"}
@item @strong{Type:}
none
@item @strong{Purpose:}
input comes from the file filename. Shorthand for
@code{execute(read(filename))}.
@item @strong{Example:}
@smallexample
< "example"; //read in the file example and execute it
@end smallexample
@end table
@c inserted refs from reference.doc:1768
@menu
See
* execute::
* read::
@end menu
@c end inserted refs from reference.doc:1768
@c ---------------------------------------
@node find, finduni, filecmd, Functions
@subsection find
@cindex find
@table @code
@item @strong{Syntax:}
@code{find (} string_expression@code{,} substring_expression @code{)}
@*@code{find (} string_expression@code{,} substring_expression@code{,} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the first position of the substring
in the string or 0 (if not found),
@*starts the search at the position given in the 3rd argument.
@item @strong{Example:}
@smallexample
@c reused example find reference.doc:1789 
  find("Aac","a");
@expansion{} 2
  find("abab","a"+"b");
@expansion{} 1
  find("abab","a"+"b",2);
@expansion{} 3
  find("abab","ab",3);
@expansion{} 3
  find("0123","abcd");
@expansion{} 0
@c end example find reference.doc:1789
@end smallexample
@end table
@c inserted refs from reference.doc:1798
@menu
See
* string::
@end menu
@c end inserted refs from reference.doc:1798
@c ---------------------------------------
@node finduni, fprintf, find, Functions
@subsection finduni
@cindex finduni
@table @code
@item @strong{Syntax:}
@code{finduni (} ideal_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns an ideal which is contained in the ideal_expression such that the i-th
generator is a univariate polynomial in the i-th ring variable.
@* The polynomials have minimal degree w.r.t.@: this property.
@item @strong{Note:}
The ideal must be zero-dimensional and given as a reduced Groebner basis in
the current ring.
@item @strong{Example:}
@smallexample
@c reused example finduni reference.doc:1820 
  ring  r=0,(x,y,z), dp;
  ideal i=y3+x2,x2y+x2,z4-x2-y;
  option(redSB);  // force computation of reduced basis
  i=std(i);
  ideal k=finduni(i);
  print(k);
@expansion{} x4-x2,
@expansion{} y4+y3,
@expansion{} z12
@c end example finduni reference.doc:1820
@end smallexample
@end table
@c inserted refs from reference.doc:1830
@menu
See
* option::
* ring::
* std::
* vdim::
@end menu
@c end inserted refs from reference.doc:1830

@c ---------------------------------------
@node fprintf, freemodule, finduni, Functions
@subsection fprintf
@cindex fprintf
@c start include of docu for standard.lib:fprintf
@c replaced @subsubsection by @sub
@c ---content fprintf---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{fprintf (} link_expression@code{,} string_expression @code{[,}
any_expressions@code{] )}

@item @strong{Return:}
none

@item @strong{Purpose:}
@code{fprintf(l,fmt,...);} performs output formatting.
The second argument is a format control string. Additional
arguments may be required, depending on the content of the
control string. A series of output characters is generated as
directed by the control string; these characters are
written to the link l.
The control string @code{fmt} is simply text to be copied, except
that the string may contain conversion specifications.@*
Do @code{help print;} for a listing of valid conversion
specifications. As an addition to the conversions of @code{print},
the @code{%n} and @code{%2} conversion specification does not
consume an additional argument, but simply generates a newline
character.

@item @strong{Note:}
If one of the additional arguments is a list, then it should be
enclosed once more into a @code{list()} command, since passing
a list as an argument flattens the list by one level.

@end table
@strong{Example:}
@smallexample
@c reused example fprintf d2t_singular/standard_lib.doc:393 
  ring r=0,(x,y,z),dp;
module m=[1,y],[0,x+z];
intmat M=betti(mres(m,0));
list l=r,m,M;
link li="";   // link to stdout
fprintf(li,"s:%s,l:%l",1,2);
@expansion{} s:1,l:int(2)
fprintf(li,"s:%s",l);
@expansion{} s:(0),(x,y,z),(dp(3),C)
fprintf(li,"s:%s",list(l));
@expansion{} s:(0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
fprintf(li,"2l:%2l",list(l));
@expansion{} 2l:list("(0),(x,y,z),(dp(3),C)",
@expansion{} module(y*gen(2)+gen(1),
@expansion{} x*gen(2)+z*gen(2)),
@expansion{} intmat(intvec(1,1 ),1,2))
@expansion{} 
fprintf(li,"%p",list(l));
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
fprintf(li,"%;",list(l));
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
fprintf(li,"%b",M);
@expansion{}            0     1
@expansion{} ------------------
@expansion{}     0:     1     1
@expansion{} ------------------
@expansion{} total:     1     1
@expansion{} 
@c end example fprintf d2t_singular/standard_lib.doc:393
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:408
@menu
See also:
* print::
* printf::
* sprintf::
* string::
@end menu
@c end inserted refs from d2t_singular/standard_lib.doc:408

@c ---end content fprintf---
@c generated lib proc docu for standard.lib:fprintf reference.doc:1842 
@c end include of docu for standard.lib:fprintf

@c ---------------------------------------
@node freemodule, gcd, fprintf, Functions
@subsection freemodule
@cindex freemodule

@table @code
@item @strong{Syntax:}
@code{freemodule (} int_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
creates the free module of rank n generated by
@code{gen(1)}, @dots{}, @code{gen(n)}.
@item @strong{Example:}
@smallexample
@c reused example freemodule reference.doc:1859 
  ring r=32003,(x,y),(c,dp);
  freemodule(3);
@expansion{} _[1]=[1]
@expansion{} _[2]=[0,1]
@expansion{} _[3]=[0,0,1]
  matrix m=freemodule(3); // generates the 3x3 unit matrix
  print(m);
@expansion{} 1,0,0,
@expansion{} 0,1,0,
@expansion{} 0,0,1 
@c end example freemodule reference.doc:1859
@end smallexample
@end table
@c inserted refs from reference.doc:1867
@menu
See
* gen::
* module::
@end menu
@c end inserted refs from reference.doc:1867
@c ---------------------------------------
@node gcd, gen, freemodule, Functions
@subsection gcd
@cindex gcd

@table @code
@item @strong{Syntax:}
@code{gcd (} int_expression@code{,} int_expression @code{)}
@*@code{gcd (} number_expression@code{,} number_expression @code{)}
@*@code{gcd (} poly_expression@code{,} poly_expression @code{)}
@item @strong{Type:}
the same as the type of the arguments
@item @strong{Purpose:}
computes the greatest common divisor.
@item @strong{Note:}
Not implemented for the coefficient fields real and finite fields of
type @code{(p^n,a)}.
@*The gcd of two numbers is their gcd as integer numbers or polynomials,
otherwise it is not defined.
@item @strong{Example:}
@smallexample
@c reused example gcd reference.doc:1893 
  gcd(2,3);
@expansion{} 1
  ring r=0,(x,y,z),lp;
  gcd(3x2*(x+y),9x*(y2-x2));
@expansion{} x2+xy
  gcd(number(6472674604870),number(878646537247372));
@expansion{} 2
@c end example gcd reference.doc:1893
@end smallexample
@end table
@c inserted refs from reference.doc:1901
@menu
See
* extgcd::
* int::
* number::
* poly::
@end menu
@c end inserted refs from reference.doc:1901
@c ----------------------------------------
@node gen, getdump, gcd, Functions
@subsection gen
@cindex gen

@table @code
@item @strong{Syntax:}
@code{gen (} int_expression @code{)}
@item @strong{Type:}
vector
@item @strong{Purpose:}
returns the i-th free generator of a free module.
@item @strong{Example:}
@smallexample
@c reused example gen reference.doc:1922 
  ring r=32003,(x,y,z),(c,dp);
  gen(3);
@expansion{} [0,0,1]
  vector v=gen(5);
  poly f=xyz;
  v=v+f*gen(4); v;
@expansion{} [0,0,0,xyz,1]
  ring rr=32003,(x,y,z),dp;
  fetch(r,v);
@expansion{} xyz*gen(4)+gen(5)
@c end example gen reference.doc:1922
@end smallexample
@end table
@c inserted refs from reference.doc:1933
@menu
See
* freemodule::
* int::
* vector::
@end menu
@c end inserted refs from reference.doc:1933
@c ---------------------------------------
@node getdump, groebner, gen, Functions
@subsection getdump
@cindex getdump
@table @code
@item @strong{Syntax:}
@code{getdump (} link_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
reads the content of the entire file, resp.@: link, and restores all variables
from it. For ASCII links, @code{getdump} is equivalent to an
@code{execute(read(} link @code{))} command. For MP links,
@code{getdump} should only be used on data which were previously
@code{dump}'ed.
@item @strong{Example:}
@smallexample
@c reused example getdump reference.doc:1956 
  int i=3;
  dump(":w example.txt");
  kill i;
  option(noredefine);
  getdump("example.txt");
  i;
@expansion{} 3
@c end example getdump reference.doc:1956
@end smallexample
@item @strong{Restrictions:}
@code{getdump} is not supported for DBM links, or for a link connecting
to @code{stdin} (standard input).
@end table
@c inserted refs from reference.doc:1969
@menu
See
* dump::
* link::
* read::
@end menu
@c end inserted refs from reference.doc:1969
@c ---------------------------------------
@node groebner, help, getdump, Functions
@subsection groebner
@cindex groebner
@c start include of docu for standard.lib:groebner
@c replaced @subsubsection by @sub
@c ---content groebner---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{groebner (} ideal_expression @code{)} @*
@code{groebner (} module_expression @code{)} @*
@code{groebner (} ideal_expression@code{,} int_expression @code{)} @*
@code{groebner (} module_expression@code{,} int_expression @code{)}

@item @strong{Type:}
type of the first argument

@item @strong{Purpose:}
computes the standard basis of the first argument @code{I}
(ideal or module), by a heuristically chosen method: if the
ordering of the current ring is a local ordering, or if it is a
non-block ordering and the current ring has no parameters, then
@code{std(I)} is returned. Otherwise, @code{I} is mapped into a
ring with no parameters and ordering dp, where its Hilbert series
is computed. This is followed by a Hilbert-series based std
computation in the original ring.

@item @strong{Note:}
If a 2nd argument @code{wait} is given, then the computation proceeds
at most @code{wait} seconds. That is, if no result could be computed in
@code{wait} seconds, then the computation is interrupted, 0 is returned,
a warning message is displayed, and the global variable
@code{groebner_error} is defined.

@cindex time limit on computations
@cindex MP, groebner basis computations
@end table
@strong{Example:}
@smallexample
@c reused example groebner d2t_singular/standard_lib.doc:149 
  ring r=0,(a,b,c,d),lp;
option(prot);
ideal i=a+b+c+d,ab+ad+bc+cd,abc+abd+acd+bcd,abcd-1; // cyclic 4
groebner(i);
@expansion{} std in (0),(a,b,c,d,@@t),(dp,C)
@expansion{} [63:1]1(3)s2(2)s3s4-s5ss6-s7--
@expansion{} product criterion:8 chain criterion:5
@expansion{} std with hilb in  (0),(a,b,c,d,@@t),(lp(4),C)
@expansion{} [63:1]1(3)s2(2)s3s4-s5ss6shhhh8shh
@expansion{} product criterion:9 chain criterion:8
@expansion{} hilbert series criterion:6
@expansion{} dehomogenization
@expansion{} imap to original ring
@expansion{} simplification
@expansion{} _[1]=c2d6-c2d2-d4+1
@expansion{} _[2]=c3d2+c2d3-c-d
@expansion{} _[3]=bd4-b+d5-d
@expansion{} _[4]=bc-bd5+c2d4+cd-d6-d2
@expansion{} _[5]=b2+2bd+d2
@expansion{} _[6]=a+b+c+d
ring rp=(0,a,b),(c,d), lp;
ideal i=imap(r,i);
ideal j=groebner(i);
@expansion{} std in 0,(c,d,a,b,@@t),(dp,C)
@expansion{} [63:1]1(3)s2(2)s3s4-s5ss6-s7--
@expansion{} product criterion:8 chain criterion:5
@expansion{} std with hilb in  (0),(c,d,a,b,@@t),(lp(2),C, dp(3))
@expansion{} [63:3]1(3)s2(2)s3s4-s5ss6shhhh8shh
@expansion{} product criterion:9 chain criterion:8
@expansion{} hilbert series criterion:6
@expansion{} dehomogenization
@expansion{} imap to original ring
@expansion{} simplification
option(noprot);
j; simplify(j,1); std(i);
@expansion{} j[1]=(a3b2+a2b3-a-b)
@expansion{} _[1]=1
@expansion{} _[1]=1
if (system("with","MP")) @{groebner(i,0);@}
@expansion{} // ** groebner did not finish
@expansion{} _[1]=0
defined(groebner_error);
@expansion{} 1
@c end example groebner d2t_singular/standard_lib.doc:149
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:163
@menu
See also:
* std::
* stdfglm::
* stdhilb::
@end menu
@c end inserted refs from d2t_singular/standard_lib.doc:163

@c ---end content groebner---
@c generated lib proc docu for standard.lib:groebner reference.doc:1979 
@c end include of docu for standard.lib:groebner

@c @table @code
@c @item @strong{Syntax:}
@c @code{groebner (} ideal_expression @code{)}
@c @*@code{groebner (} module_expression @code{)}
@c @item @strong{Type:}
@c ideal or module
@c @item @strong{Purpose:}
@c returns a standard basis of an ideal or module with respect to the
@c monomial ordering of the basering using a heuristically chosen method.
@c @item @strong{Example:}
@c @example
@c @c example
@c   ring r=0,(a,b,c,d),lp;
@c   ideal i=a+b+c+d,ab+ad+bc+cd,abc+abd+acd+bcd,abcd-1;
@c   groebner(i);
@c @c example
@c @end example
@c @end table
@c @c ref
@c See
@c @ref{std};
@c @ref{stdfglm};
@c @ref{stdhilb}.
@c @c ref
@c ---------------------------------------
@node help, highcorner, groebner, Functions
@subsection help
@cindex help
@table @code
@item @strong{Syntax:}
@code{help;}
@*@code{help} topic @code{;}
@item @strong{Type:}
none
@item @strong{Purpose:}
displays online help information for @code{topic} using the currently
set help browser. If no @code{topic} is given, the title page of the
manual is displayed.

@item @strong{Note:}
@itemize @bullet
@cindex ?
@item
@code{?} may be used instead of @code{help}.

@item
@code{topic} can be an index entry of the @sc{Singular} manual or the
name of a (loaded) procedure which has a help section.
@item
@code{topic} may contain wildcard characters (i.e.,
@code{*} characters).
@item
If a (possibly "wildcarded") @code{topic} cannot be found (or
uniquely matched) a warning is displayed and no help information is
provided.
@item
If @code{topic} is the name of a (loaded) procedure whose help
section has changed w.r.t.@: the help available in the manual then,
instead of displaying the respective help section of the manual in the
help browser, the "newer" help section of the procedure is simply
printed to the terminal.

@item
The browser in which the help information is displayed can be either set
with the command-line option @code{--browser=<browser>} (@pxref{Command
line options}), or with the command @code{system("--browser",
"<browser>")}. Use the command @code{system("browsers");} for a list of
all available browsers. @xref{The online help system}, for more details
about help browsers.

@end itemize

@item @strong{Example:}
@smallexample
help;      // display title page of manual
help ring; // display help for 'ring'
?ringe;    // equivalent to 'help ringe;'
@expansion{} // ** No help for topic 'ringe' (not even for '*ringe*')
@expansion{} // ** Try '?;'       for general help
@expansion{} // ** or  '?Index;'  for all available help topics
?ring*;
@expansion{} //  ** No unique help for 'ring*'
@expansion{} //  ** Try one of
@expansion{} ?Rings and orderings; ?Rings and standard bases; ?ring;
@expansion{} ?ring declarations; ?ring operations; ?ring related functions;
@expansion{} ?ring.lib; ?ring_lib; ?ringtensor; ?ringweights;
help Rings and orderings;
help standard.lib;  // displays help for library 'standard.lib'
@end smallexample
@end table

@c inserted refs from reference.doc:2072
@menu
See
* Command line options::
* Format of a library::
* Procedure definition::
* The online help system::
* system::
@end menu
@c end inserted refs from reference.doc:2072
@c ---------------------------------------
@node highcorner, hilb, help, Functions
@subsection highcorner
@cindex highcorner
@table @code
@item @strong{Syntax:}
@code{highcorner (} ideal_expression @code{)}
@*@code{highcorner (} module_expression @code{)}
@item @strong{Type:}
poly, resp.@: vector
@item @strong{Purpose:}
returns the smallest monomial not contained in
the ideal, resp.@: module, generated by the initial terms of the given
generators. If the generators are a standard basis,
this is also the smallest monomial not contained in the ideal, resp.@: module.
@*If the ideal, resp.@: module, is not zero-dimensional, 0 is returned.
@item @strong{Note:}
Let the ideal I be given by a standard basis. Then
@code{highcorner(I)} returns 0 iff @code{dim(I)>0} or @code{dim(I)=-1}.
Otherwise it returns the smallest monomial m not in I which has the following
properties (with
x(i)
@tex
$x_i$
@end tex
the variables of the basering):
@itemize @bullet
@item
if
x(i)>1 then x(i)
@tex
$x_i>1$ then $x_i$
@end tex
does not divide m (e.g., m=1 if the ordering is global)
@item
given any set of generators
f_1,...f_k of I, let f_i' be obtained from
f_i by deleting the terms divisible by x(i)*m for all i with x(i)<1.
Then f_1',...,f_k' generate I.
@tex
$f_1,\dots,f_k$ of I, let $f'_i$ be obtained from
$f_i$ by deleting the terms divisible by $x_i\cdot m$ for all i with $x_i<1$.
Then $f'_1,\dots,f'_k$ generate I.
@end tex
@end itemize
@item @strong{Example:}
@smallexample
@c reused example highcorner reference.doc:2133 
ring r=0,(x,y),ds;
ideal i=x3,x2y,y3;
highcorner(std(i));
@expansion{} xy2
highcorner(std(ideal(1)));
@expansion{} 0
@c end example highcorner reference.doc:2133
@end smallexample
@end table
@c inserted refs from reference.doc:2141
@menu
See
* dim::
* std::
* vdim::
@end menu
@c end inserted refs from reference.doc:2141
@c ---------------------------------------
@node hilb, homog, highcorner, Functions
@subsection hilb
@cindex hilb
@table @code
@item @strong{Syntax:}
@code{hilb (} ideal_expression @code{)}
@*@code{hilb (} module_expression @code{)}
@*@code{hilb (} ideal_expression@code{,} int_expression @code{)}
@*@code{hilb (} module_expression@code{,} int_expression @code{)}
@*@code{hilb (} ideal_expression@code{,} int_expression @code{,} intvec_expression @code{)}
@*@code{hilb (} module_expression@code{,} int_expression @code{,} intvec_expression @code{)}
@item @strong{Type:}
none (if called with one argument)
@*intvec (if called with two or three arguments)
@item @strong{Purpose:}
computes the (weighted) Hilbert series of the ideal, resp.@: module,
defined by the leading terms of the generators of the given ideal, resp.@: module.@*
If @code{hilb} is called with one argument, then the 1st and 2nd Hilbert series
together with some additional information are displayed.@*
If @code{hilb} is called with two arguments, then the n-th Hilbert series is returned
as an intvec, where n=1,2 is the second argument.@*
If a weight vector w is a given as 3rd argument, then the Hilbert series is computed
w.r.t.@: these weights w (by default all weights are set to 1).
@item @strong{Caution:}
The last entry of the returned intvec is not part of the actual Hilbert series,
but is used in the Hilbert driven standard basis computation (see @ref{stdhilb}).
@item @strong{Note:}
If the input is homogeneous w.r.t.@: the weights and a standard basis, the result is
the (weighted) Hilbert series of the original ideal, resp.@: module.@*
@item @strong{Example:}
@smallexample
@c reused example hilb reference.doc:2179 
  ring R=32003,(x,y,z),dp;
  ideal i=x2,y2,z2;
  ideal s=std(i);
  hilb(s);
@expansion{} //         1 t^0
@expansion{} //        -3 t^2
@expansion{} //         3 t^4
@expansion{} //        -1 t^6
@expansion{} 
@expansion{} //         1 t^0
@expansion{} //         3 t^1
@expansion{} //         3 t^2
@expansion{} //         1 t^3
@expansion{} // dimension (affine)  = 0
@expansion{} // degree      = 8
  hilb(s,1);
@expansion{} 1,0,-3,0,3,0,-1,0
  hilb(s,2);
@expansion{} 1,3,3,1,0
  intvec w=2,2,2;
  hilb(s,1,w);
@expansion{} 1,0,0,0,-3,0,0,0,3,0,0,0,-1,0
@c end example hilb reference.doc:2179
@end smallexample
@end table
@c inserted refs from reference.doc:2191
@menu
See
* Hilbert function::
* ideal::
* intvec::
* module::
* std::
* stdhilb::
@end menu
@c end inserted refs from reference.doc:2191
@c ---------------------------------------
@node homog, hres, hilb, Functions
@subsection homog
@cindex homog

@table @code
@item @strong{Syntax:}
@code{homog (} ideal_expression @code{)}
@*@code{homog (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
tests for homogeneity: returns 1 for homogeneous input, 0 otherwise.
@item @strong{Syntax:}
@*@code{homog (} polynomial_expression@code{,} ring_variable @code{)}
@*@code{homog (} vector_expression@code{,} ring_variable @code{)}
@*@code{homog (} ideal_expression@code{,} ring_variable @code{)}
@*@code{homog (} module_expression@code{,} ring_variable @code{)}
@item @strong{Type:}
same as first argument
@item @strong{Purpose:}
homogenizes polynomials, vectors, ideals, or modules by multiplying
each monomial with a suitable power of the given ring variable (which must have
weight 1).
@item @strong{Example:}
@smallexample
@c reused example homog reference.doc:2226 
  ring r=32003,(x,y,z),ds;
  poly s1=x3y2+x5y+3y9;
  poly s2=x2y2z2+3z8;
  poly s3=5x4y2+4xy5+2x2y2z3+y7+11x10;
  ideal i=s1,s2,s3;
  homog(s2,z);
@expansion{} x2y2z4+3z8
  homog(i,z);
@expansion{} _[1]=3y9+x5yz3+x3y2z4
@expansion{} _[2]=x2y2z4+3z8
@expansion{} _[3]=11x10+y7z3+5x4y2z4+4xy5z4+2x2y2z6
  homog(i);
@expansion{} 0
  homog(homog(i,z));
@expansion{} 1
@c end example homog reference.doc:2226
@end smallexample
@end table
@c inserted refs from reference.doc:2239
@menu
See
* ideal::
* module::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:2239
@c ---------------------------------------
@node hres, imap, homog, Functions
@subsection hres
@cindex hres
@cindex resolution, hilbert-driven
@table @code
@item @strong{Syntax:}
@code{hres (} ideal_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal using the Hilbert-driven
algorithm.

More precisely, let R be the basering and I be the given ideal.
Then @code{hres} computes a minimal free resolution of R/I
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> R --> R/I --> 0.
@end format
@tex
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} R\longrightarrow R/I
\longrightarrow 0.$$
@end tex
If the int_expression k is not zero then the computation stops after
k steps and returns a list of modules
@tex
$M_i={\tt module} (A_i)$, i=1..k.
@end tex
Mi=module(Ai), i=1...k.

@code{list L=hres(I,0);} returns a list L of n modules (where n is the
number of variables of the basering) such that
@tex
${\tt L[i]}=M_i$
@end tex
L[i]=M_i
in the above notation.
@item @strong{Note:}
The ideal_expression has to be homogeneous.
@* Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@smallexample
@c reused example hres reference.doc:2297 
  ring r=0,(x,y,z),dp;
  ideal I=xz,yz,x3-y3;
  def L=hres(I,0);
  print(betti(L),"betti");
@expansion{}            0     1     2
@expansion{} ------------------------
@expansion{}     0:     1     -     -
@expansion{}     1:     -     2     1
@expansion{}     2:     -     1     1
@expansion{} ------------------------
@expansion{} total:     1     3     2
  L[2];     // the first syzygy module of r/I
@expansion{} _[1]=-x*gen(1)+y*gen(2)
@expansion{} _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)
@c end example hres reference.doc:2297
@end smallexample
@end table
@c inserted refs from reference.doc:2306
@menu
See
* betti::
* ideal::
* int::
* lres::
* minres::
* module::
* mres::
* res::
* sres::
@end menu
@c end inserted refs from reference.doc:2306
@c ---------------------------------------
@node imap, impart, hres, Functions
@subsection imap
@cindex imap

@table @code
@item @strong{Syntax:}
@code{imap (} ring_name@code{,} name @code{)}
@item @strong{Type:}
number, poly, vector, ideal, module, matrix or list
(the same type as the second argument)
@item @strong{Purpose:}
identity map on common subrings.  @code{imap} is the map between rings
and qrings with compatible ground fields which is the identity on
variables and parameters of the same name and 0 otherwise.
(See @ref{map} for a description of possible mapping between
different ground fields).
Useful for mapping from a homogenized ring to the original ring or
for mappings from/to rings with/without parameters. Compared with
@code{fetch}, @code{imap} uses the names of variables and parameters.
Unlike @code{map} and @code{fetch} @code{imap} can map parameters to variables.
@item @strong{Example:}
@smallexample
@c reused example imap reference.doc:2341 
  ring r=0,(x,y,z,a,b,c),dp;
  ideal i=xy2z3a4b5+1,homog(xy2z3a4b5+1,c); i;
@expansion{} i[1]=xy2z3a4b5+1
@expansion{} i[2]=xy2z3a4b5+c15
  ring r1=0,(a,b,x,y,z),lp;
  ideal j=imap(r,i); j;
@expansion{} j[1]=a4b5xy2z3+1
@expansion{} j[2]=a4b5xy2z3
  ring r2=(0,a,b),(x,y,z),ls;
  ideal j=imap(r,i); j;
@expansion{} j[1]=1+(a4b5)*xy2z3
@expansion{} j[2]=(a4b5)*xy2z3
@c end example imap reference.doc:2341
@end smallexample
@end table
@c inserted refs from reference.doc:2351
@menu
See
* fetch::
* homog::
* map::
* qring::
* ring::
@end menu
@c end inserted refs from reference.doc:2351
@c ---------------------------------------
@node impart, indepSet, imap, Functions
@subsection impart
@cindex impart

@table @code
@item @strong{Syntax:}
@code{impart (} number_expression @code{)}
@item @strong{Type:}
number
@item @strong{Purpose:}
returns the imaginary part of a number in a complex ground field,
@*returns 0 otherwise.
@item @strong{Example:}
@smallexample
@c reused example impart reference.doc:2374 
  ring r=(complex,i),x,dp;
  impart(1+2*i);
@expansion{} 2
@c end example impart reference.doc:2374
@end smallexample
@end table
@c inserted refs from reference.doc:2380
@menu
See
* repart::
@end menu
@c end inserted refs from reference.doc:2380
@c ---------------------------------------
@node indepSet, insert, impart, Functions
@subsection indepSet
@cindex indepSet

@table @code
@item @strong{Syntax:}
@code{indepSet (} ideal_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
computes a maximal set U of independent variables of the ideal given by
a standard basis.  If @code{v} is the result then @code{v[i]} is 1 if and
only if the i-th variable of the ring, @code{x(i)}, is an independent
variable.  Hence, the set U consisting of all variables @code{x(i)} with
@code{v[i]=1} is a maximal independent set.

@c Indeed we compute a maximal strongly independent set U,
@c where no power of a variable from U occurs as a leading term ofs
@c a standard basis of the ideal.

@item @strong{Note:}
U is a set of independent variables for I if and only if
@tex
$I \cap K[U]=(0)$,
@end tex
I intersect K[U]=(0),
i.e., eliminating the remaining variables gives (0).
U is maximal if dim(I)=#U.
@item @strong{Syntax:}
@code{indepSet (} ideal_expression, int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
computes a list of all maximal independent sets of the leading ideal
(if the flag is 0), resp.@: of all those sets of independent variables
of the leading ideal which cannot be enlarged.
@item @strong{Example:}
@smallexample
@c reused example indepSet reference.doc:2425 
  ring r=32003,(x,y,u,v,w),dp;
  ideal I=xyw,yvw,uyw,xv;
  attrib(I,"isSB",1);
  indepSet(I);
@expansion{} 1,1,1,0,0
  eliminate(I,vw);
@expansion{} _[1]=0
  indepSet(I,0);
@expansion{} [1]:
@expansion{}    1,1,1,0,0
@expansion{} [2]:
@expansion{}    0,1,1,1,0
@expansion{} [3]:
@expansion{}    1,0,1,0,1
@expansion{} [4]:
@expansion{}    0,0,1,1,1
  indepSet(I,1);
@expansion{} [1]:
@expansion{}    1,1,1,0,0
@expansion{} [2]:
@expansion{}    0,1,1,1,0
@expansion{} [3]:
@expansion{}    1,0,1,0,1
@expansion{} [4]:
@expansion{}    0,0,1,1,1
@expansion{} [5]:
@expansion{}    0,1,0,0,1
  eliminate(I,xuv);
@expansion{} _[1]=0
@c end example indepSet reference.doc:2425
@end smallexample
@end table
@c inserted refs from reference.doc:2437
@menu
See
* ideal::
* std::
@end menu
@c end inserted refs from reference.doc:2437
@c ---------------------------------------
@node insert, interred, indepSet, Functions
@subsection insert
@cindex insert

@table @code
@item @strong{Syntax:}
@code{insert (} list_expression@code{,} expression @code{)}
@*@code{insert (} list_expression@code{,} expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
inserts a new element (expression) into a list at the beginning, or (if
called with 3 arguments) after the given position (the input is not changed).
@item @strong{Example:}
@smallexample
@c reused example insert reference.doc:2458 
  list L=1,2;
  insert(L,4,2);
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    4
  insert(L,4);
@expansion{} [1]:
@expansion{}    4
@expansion{} [2]:
@expansion{}    1
@expansion{} [3]:
@expansion{}    2
@c end example insert reference.doc:2458
@end smallexample
@end table
@c inserted refs from reference.doc:2465
@menu
See
* delete::
* list::
@end menu
@c end inserted refs from reference.doc:2465
@c ---------------------------------------
@node interred, intersect, insert, Functions
@subsection interred
@cindex interred
@table @code
@item @strong{Syntax:}
@code{interred (} ideal_expression @code{)}
@*@code{interred (} module_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
interreduces a set of polynomials/vectors.
@*
input: f_1,@dots{},f_n
@tex
input: $f_1,\dots,f_n$
@end tex
@*
output: g_1,@dots{},g_s with s<=n and the properties

@*
@tex
output: $g_1,\dots,g_s$ with $s \leq n$ and the properties
@end tex
@itemize @bullet
@item
(f_1,@dots{},f_n) = (g_1,@dots{},g_s)
@tex
$(f_1,\dots,f_n) = (g_1,\dots,g_s)$
@end tex
@item
L(g_i)<>L(g_j) for all i<>j
@tex
$L(g_i)\neq L(g_j)$ for all $i\neq j$
@end tex
@item
in the case of a global ordering (polynomial ring):
@*
L(g_i)
@tex
$L(g_i)$
@end tex
 does not divide m for all monomials m of
@{g_1,@dots{},g_(i-1),g_(i+1),@dots{},g_s@}
@tex
$\{g_1,\dots,g_{i-1},g_{i+1},\dots,g_s\}$
@end tex
@item
in the case of a local or mixed ordering (localization of polynomial ring):
@* if
L(g_i) | L(g_j) for any i<>j,
@tex
$L(g_i) | L(g_j)$ for any $i \neq j$,
@end tex
then
ecart(g_i) > ecart(g_j)
@tex
$ecart(g_i) > ecart(g_j)$
@end tex
@end itemize
@tex
Here, $L(g)$ denotes the leading term of $g$ and
$ecart(g):=deg(g)-deg(L(g))$.
@end tex

@*
Here, L(g) denotes the leading term of g and ecart(g) := deg(g)-deg(L(g)).
@item @strong{Example:}
@smallexample
@c reused example interred reference.doc:2557 
  ring r=0,(x,y,z),dp;
  ideal i=x2+z,z,2z;
  interred(i);
@expansion{} _[1]=z
@expansion{} _[2]=x2
  ring R=0,(x,y,z),ds;
  ideal i=zx+y3,z+y3,z+xy;
  interred(i);
@expansion{} _[1]=z+xy
@expansion{} _[2]=xy-y3
@expansion{} _[3]=x2y-y3
@c end example interred reference.doc:2557
@end smallexample
@end table
@c inserted refs from reference.doc:2567
@menu
See
* ideal::
* module::
* std::
@end menu
@c end inserted refs from reference.doc:2567
@c ---------------------------------------
@node intersect, jacob, interred, Functions
@subsection intersect
@cindex intersect
@table @code
@item @strong{Syntax:}
@code{intersect (} expression_list of ideal_expression @code{)}
@*@code{intersect (} expression_list of module_expression @code{)}
@item @strong{Type:}
ideal, resp.@: module
@item @strong{Purpose:}
computes the intersection of ideals, resp.@: modules.
@item @strong{Note:}
If the option @code{returnSB} is enabled then the result is a standard basis.
@item @strong{Example:}
@smallexample
@c reused example intersect reference.doc:2589 
  ring R=0,(x,y),dp;
  ideal i=x;
  ideal j=y;
  intersect(i,j);
@expansion{} _[1]=xy
  ring r=181,(x,y,z),(c,ls);
  ideal id1=maxideal(3);
  ideal id2=x2+xyz,y2-z3y,z3+y5xz;
  ideal id3=intersect(id1,id2,ideal(x,y));
  id3;
@expansion{} id3[1]=yz3+xy6z
@expansion{} id3[2]=yz4-y2z
@expansion{} id3[3]=y2z3-y3
@expansion{} id3[4]=xz3+x2y5z
@expansion{} id3[5]=xyz2+x2z
@expansion{} id3[6]=xyz3-xy2
@expansion{} id3[7]=xy2z+x2y
@expansion{} id3[8]=x2yz+x3
@c end example intersect reference.doc:2589
@end smallexample
@end table
@c inserted refs from reference.doc:2602
@menu
See
* ideal::
* module::
* option::
@end menu
@c end inserted refs from reference.doc:2602
@c ---------------------------------------
@node jacob, jet, intersect, Functions
@subsection jacob
@cindex jacob
@table @code
@item @strong{Syntax:}
@code{jacob (} poly_expression @code{)}
@*@code{jacob (} ideal_expression @code{)}
@item @strong{Type:}
ideal, if the input is a polynomial
@* matrix, if the input is an ideal
@item @strong{Purpose:}
computes the Jacobi ideal, resp.@: Jacobi matrix, generated by all
partial derivatives of the input.
@item @strong{Example:}
@smallexample
@c reused example jacob reference.doc:2624 
  ring R;
  poly f=x2+y3+z5;
  jacob(f);
@expansion{} _[1]=2x
@expansion{} _[2]=3y2
@expansion{} _[3]=5z4
  ideal i=jacob(f);
  print(jacob(i));
@expansion{} 2,0, 0,  
@expansion{} 0,6y,0,  
@expansion{} 0,0, 20z3
@c end example jacob reference.doc:2624
@end smallexample
@end table
@c inserted refs from reference.doc:2633
@menu
See
* diff::
* ideal::
* module::
* nvars::
@end menu
@c end inserted refs from reference.doc:2633
@c ---------------------------------------
@node jet, kbase, jacob, Functions
@subsection jet
@cindex jet
@table @code
@item @strong{Syntax:}
@code{jet (} poly_expression@code{,} int_expression @code{)}
@*@code{jet (} vector_expression@code{,} int_expression @code{)}
@*@code{jet (} ideal_expression@code{,} int_expression @code{)}
@*@code{jet (} module_expression@code{,} int_expression @code{)}
@*@code{jet (} poly_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} vector_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} ideal_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} module_expression@code{,} int_expression@code{,} intvec_expression @code{)}
@*@code{jet (} poly_expression@code{,} int_expression@code{,} poly_expression @code{)}
@*@code{jet (} vector_expression@code{,} int_expression@code{,} poly_expression @code{)}
@*@code{jet (} ideal_expression@code{,} int_expression@code{,} matrix_expression @code{)}
@*@code{jet (} module_expression@code{,} int_expression@code{,} matrix_expression @code{)}
@item @strong{Type:}
the same as the type of the first argument
@item @strong{Purpose:}
deletes from the first argument all terms of degree bigger than the second argument.
@*If a third argument @code{w} of type intvec is given, the degree is replaced by the weighted degree defined by @code{w}.
@*If a third argument @code{u} of type poly or matrix is given, the first argument @code{p} is replaced by @code{p/u}.
@item @strong{Example:}
@smallexample
@c reused example jet reference.doc:2666 
  ring r=32003,(x,y,z),(c,dp);
  jet(1+x+x2+x3+x4,3);
@expansion{} x3+x2+x+1
  poly f=1+x+x2+xz+y2+x3+y3+x2y2+z4;
  jet(f,3);
@expansion{} x3+y3+x2+y2+xz+x+1
  intvec iv=2,1,1;
  jet(f,3,iv);
@expansion{} y3+y2+xz+x+1
  // the part of f with (total) degree >3:
  f-jet(f,3);
@expansion{} x2y2+z4
  // the homogeneous part of f of degree 2:
  jet(f,2)-jet(f,1);
@expansion{} x2+y2+xz
  // the part of maximal degree:
  jet(f,deg(f))-jet(f,deg(f)-1);
@expansion{} x2y2+z4
  // the absolute term of f:
  jet(f,0);
@expansion{} 1
  // now for other types:
  ideal i=f,x,f*f;
  jet(i,2);
@expansion{} _[1]=x2+y2+xz+x+1
@expansion{} _[2]=x
@expansion{} _[3]=3x2+2y2+2xz+2x+1
  vector v=[f,1,x];
  jet(v,1);
@expansion{} [x+1,1,x]
  jet(v,0);
@expansion{} [1,1]
  v=[f,1,0];
  module m=v,v,[1,x2,z3,0,1];
  jet(m,2);
@expansion{} _[1]=[x2+y2+xz+x+1,1]
@expansion{} _[2]=[x2+y2+xz+x+1,1]
@expansion{} _[3]=[1,x2,0,0,1]
@c end example jet reference.doc:2666
@end smallexample
@end table
@c inserted refs from reference.doc:2693
@menu
See
* deg::
* ideal::
* int::
* intvec::
* module::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:2693
@c ---------------------------------------
@node kbase, kill, jet, Functions
@subsection kbase
@cindex kbase
@table @code
@item @strong{Syntax:}
@code{kbase (} ideal_expression @code{)}
@*@code{kbase (} module_expression @code{)}
@*@code{kbase (} ideal_expression@code{,} int_expression@code{)}
@*@code{kbase (} module_expression@code{,} int_expression@code{)}
@item @strong{Type:}
the same as the input type of the first argument
@item @strong{Purpose:}
with one argument:
computes a vector space basis (consisting of monomials)
of the quotient ring by the ideal,
resp.@: of a free module by the module, in case it is finite dimensional
and if the input is a standard basis with respect to the ring ordering.
If the input is not a standard basis, the leading terms of the input are
used and the result may have no meaning.
@*With two arguments: computes the part of a vector space basis of the
respective quotient with degree of the monomials equal to the
second argument. Here, the quotient does not need to be finite dimensional.
@item @strong{Example:}
@smallexample
@c reused example kbase reference.doc:2728 
  ring r=32003,(x,y,z),ds;
  ideal i=x2,y2,z;
  kbase(std(i));
@expansion{} _[1]=xy
@expansion{} _[2]=y
@expansion{} _[3]=x
@expansion{} _[4]=1
  i=x2,y3,xyz;  // quotient not finite dimensional
  kbase(std(i),2);
@expansion{} _[1]=z2
@expansion{} _[2]=yz
@expansion{} _[3]=xz
@expansion{} _[4]=y2
@expansion{} _[5]=xy
@c end example kbase reference.doc:2728
@end smallexample
@end table
@c inserted refs from reference.doc:2737
@menu
See
* ideal::
* module::
* vdim::
@end menu
@c end inserted refs from reference.doc:2737
@c ---------------------------------------
@node kill, killattrib, kbase, Functions
@subsection kill
@cindex kill
@table @code
@item @strong{Syntax:}
@code{kill (} name @code{)}
@*@code{kill (} list_of_names @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
deletes objects.
@item @strong{Example:}
@smallexample
@c reused example kill reference.doc:2757 
  int i=3;
  ring r=0,x,dp;
  poly p;
  listvar();
@expansion{} // r                    [0]  *ring
@expansion{} //      p                    [0]  poly
@expansion{} // i                    [0]  int 3
@expansion{} // LIB                  [0]  string standard.lib
  kill(i,r);
  // the variable `i` does not exist any more
  i;
@expansion{}    ? `i` is undefined
@expansion{}    ? error occurred in line 7: `  i;`
  listvar();
@expansion{} // LIB                  [0]  string standard.lib
@c end example kill reference.doc:2757
@end smallexample
@end table
@c inserted refs from reference.doc:2769
@menu
See
* defined::
* general_lib::
* names::
@end menu
@c end inserted refs from reference.doc:2769
@c ---------------------------------------
@node killattrib, koszul, kill, Functions
@subsection killattrib
@cindex killattrib
@table @code
@item @strong{Syntax:}
@code{killattrib (} name@code{,} string_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
deletes the attribute given as the second argument.
@item @strong{Example:}
@smallexample
@c reused example killattrib reference.doc:2788 
  ring r=32003,(x,y),lp;
  ideal i=maxideal(1);
  attrib(i,"isSB",1);
  attrib(i);
@expansion{} attr:isSB, type int
  killattrib(i,"isSB");
  attrib(i);
@expansion{} no attributes
@c end example killattrib reference.doc:2788
@end smallexample
@end table
@c inserted refs from reference.doc:2798
@menu
See
* attrib::
* option::
@end menu
@c end inserted refs from reference.doc:2798
@c ---------------------------------------
@node koszul, laguerre, killattrib, Functions
@subsection koszul
@cindex koszul
@table @code
@item @strong{Syntax:}
@code{koszul (} int_expression@code{,} int_expression @code{)}
@*@code{koszul (} int_expression@code{,} ideal_expression @code{)}
@*@code{koszul (} int_expression@code{,} int_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
@code{koszul(d,n)} computes a matrix of the Koszul relations of degree d of
the first n ring variables.

@code{koszul(d,id)} computes a matrix of the Koszul relations of degree d of
the generators of the ideal @code{id}.

@code{koszul(d,n,id)} computes a matrix of the Koszul relations of degree d of
the first n generators of the ideal @code{id}.

@item @strong{Note:}
@code{koszul(1,id),koszul(2,id),...} form a complex, that is, the product
of the matrices @code{koszul(i,id)} and @code{koszul(i+1,id)} equals zero.
@item @strong{Example:}
@smallexample
@c reused example koszul reference.doc:2829 
  ring r=32003,(x,y,z),dp;
  print(koszul(2,3));
@expansion{} -y,-z,0, 
@expansion{} x, 0, -z,
@expansion{} 0, x, y  
  ideal I=xz2+yz2+z3,xyz+y2z+yz2,xy2+y3+y2z;
  print(koszul(1,I));
@expansion{} xz2+yz2+z3,xyz+y2z+yz2,xy2+y3+y2z
  print(koszul(2,I));
@expansion{} -xyz-y2z-yz2,-xy2-y3-y2z,0,          
@expansion{} xz2+yz2+z3,  0,          -xy2-y3-y2z,
@expansion{} 0,           xz2+yz2+z3, xyz+y2z+yz2 
  print(koszul(2,I)*koszul(3,I));
@expansion{} 0,
@expansion{} 0,
@expansion{} 0 
@c end example koszul reference.doc:2829
@end smallexample
@end table
@c inserted refs from reference.doc:2839
@menu
See
* int::
* matrix::
@end menu
@c end inserted refs from reference.doc:2839
@c ---------------------------------------
@node laguerre, lead, koszul, Functions
@subsection laguerre
@cindex laguerre
@table @code
@item @strong{Syntax:}
@code{laguerre (} poly_expression@code{,} int_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
computes all complex roots of a univariate polynomial using Laguerre's
algorithm. The second argument defines the precision of the fractional part
if the ground field is the field of rational numbers, otherwise it will be
ignored. The third argument (can be 0, 1 or 2) gives the number of extra runs
for Laguerre's algorithm (with corrupted roots), leading to better results.
@item @strong{Note:}
If the ground field is the field of complex numbers, the elements of the
list are of type number, otherwise of type string.
@item @strong{Example:}
@smallexample
@c reused example laguerre reference.doc:2864 
ring rs1=0,(x,y),lp;
poly f=15x5+x3+x2-10;
laguerre(f,10,2);
@expansion{} [1]:
@expansion{}    (0.2930464644-I*0.9003002396)
@expansion{} [2]:
@expansion{}    (0.2930464644+I*0.9003002396)
@expansion{} [3]:
@expansion{}    (-0.7392783383-I*0.5355190078)
@expansion{} [4]:
@expansion{}    (-0.7392783383+I*0.5355190078)
@expansion{} [5]:
@expansion{}    0.8924637479
@c end example laguerre reference.doc:2864
@end smallexample
@end table
@c @c ref
@c @c ref
@c -------------------------------------------------
@node lead, leadcoef, laguerre, Functions
@subsection lead
@cindex lead
@table @code
@item @strong{Syntax:}
@code{lead (} poly_expression @code{)}
@*@code{lead (} vector_expression @code{)}
@*@code{lead (} ideal_expression @code{)}
@*@code{lead (} module_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
returns the leading (or initial) term(s) of a polynomial, a vector,
resp.@: of the generators of an ideal or module with respect
to the monomial ordering.
@cindex IN
@item @strong{Note:}
@code{IN} may be used instead of @code{lead}.
@item @strong{Example:}
@smallexample
@c reused example lead reference.doc:2894 
  ring r=32003,(x,y,z),(c,ds);
  poly f=2x2+3y+4z3;
  vector v=[2x10,f];
  ideal i=f,z;
  module m=v,[0,0,2+x];
  lead(f);
@expansion{} 3y
  lead(v);
@expansion{} [2x10]
  lead(i);
@expansion{} _[1]=3y
@expansion{} _[2]=z
  lead(m);
@expansion{} _[1]=[2x10]
@expansion{} _[2]=[0,0,2]
  lead(0);
@expansion{} 0
@c end example lead reference.doc:2894
@end smallexample
@end table
@c inserted refs from reference.doc:2908
@menu
See
* ideal::
* leadcoef::
* leadexp::
* leadmonom::
* module::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:2908
@c -------------------------------------------------
@node leadcoef, leadexp, lead, Functions
@subsection leadcoef
@cindex leadcoef
@table @code
@item @strong{Syntax:}
@code{leadcoef (} poly_expression @code{)}
@*@code{leadcoef (} vector_expression @code{)}
@item @strong{Type:}
number
@item @strong{Purpose:}
returns the leading (or initial) coefficient of a polynomial or a vector
with respect to the monomial ordering.
@item @strong{Example:}
@smallexample
@c reused example leadcoef reference.doc:2933 
  ring r=32003,(x,y,z),(c,ds);
  poly f=x2+y+z3;
  vector v=[2*x^10,f];
  leadcoef(f);
@expansion{} 1
  leadcoef(v);
@expansion{} 2
  leadcoef(0);
@expansion{} 0
@c end example leadcoef reference.doc:2933
@end smallexample
@end table
@c inserted refs from reference.doc:2943
@menu
See
* lead::
* leadexp::
* leadmonom::
* number::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:2943
@c -------------------------------------------------
@node leadexp, leadmonom, leadcoef, Functions
@subsection leadexp
@cindex leadexp
@table @code
@item @strong{Syntax:}
@code{leadexp (} poly_expression @code{)}
@*@code{leadexp (} vector_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
returns the exponent vector of the leading monomial of a polynomial or a vector.
In the case of a vector the last component is the index in the vector.
@item @strong{Example:}
@smallexample
@c reused example leadexp reference.doc:2967 
  ring r=32003,(x,y,z),(c,ds);
  poly f=x2+y+z3;
  vector v=[2*x^10,f];
  leadexp(f);
@expansion{} 0,1,0
  leadexp(v);
@expansion{} 10,0,0,1
  leadexp(0);
@expansion{} 0,0,0
@c end example leadexp reference.doc:2967
@end smallexample
@end table
@c inserted refs from reference.doc:2977
@menu
See
* intvec::
* lead::
* leadcoef::
* leadmonom::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:2977
@c -------------------------------------------------
@node leadmonom, LIB, leadexp, Functions
@subsection leadmonom
@cindex leadmonom
@table @code
@item @strong{Syntax:}
@code{leadmonom (} poly_expression @code{)}
@*@code{leadmonom (} vector_expression @code{)}
@item @strong{Type:}
the same as the input type
@item @strong{Purpose:}
returns the leading monomial of a polynomial or a vector as a polynomial
or vector whose coefficient is one.
@item @strong{Example:}
@smallexample
@c reused example leadmonom reference.doc:3001 
  ring r=32003,(x,y,z),(c,ds);
  poly f=2x2+3y+4z3;
  vector v=[2x10,f];
  leadmonom(f);
@expansion{} y
  leadmonom(v);
@expansion{} [x10]
  leadmonom(0);
@expansion{} 0
@c end example leadmonom reference.doc:3001
@end smallexample
@end table

@c inserted refs from reference.doc:3012
@menu
See
* intvec::
* lead::
* leadcoef::
* leadexp::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:3012
@c ---------------------------------------
@node LIB, lift, leadmonom, Functions
@subsection LIB
@cindex LIB
@table @code
@item @strong{Syntax:}
@code{LIB} string_expression@code{;}
@item @strong{Type:}
none
@item @strong{Purpose:}
reads a library of procedures from a file. If the given filename does
not start with @kbd{.} or @kbd{/} and cannot be located in the current
directory, each directory contained in the library
@code{SearchPath} is searched for file of this name.
@xref{Loading of a library}, for more info on @code{SearchPath}.

@item @strong{Note on standard.lib:}
Unless  @sc{Singular} is started with the @code{--no-stdlib} option, the
library @code{standard.lib} is automatically loaded at start-up time.

@item @strong{Syntax:}
@code{LIB;}
@item @strong{Type:}
string
@item @strong{Purpose:}
shows all loaded libraries written in Singular.


@item @strong{Example:}
@smallexample
@c reused example LIB reference.doc:3058 
  option(loadLib); // show loading of libraries
  LIB;             // standard.lib is loaded
@expansion{} standard.lib

                   // the names of the procedures of inout.lib
  LIB "inout.lib"; // are now known to Singular
@expansion{} // ** loaded inout.lib (1.21.2.5,2002/06/12)
  LIB;
@expansion{} standard.lib,inout.lib
@c end example LIB reference.doc:3058
@end smallexample
@end table
@c inserted refs from reference.doc:3084
@menu
See
* Command line options::
* Loading of a library::
* Procedures and libraries::
* SINGULAR libraries::
* proc::
* standard_lib::
* string::
* system::
@end menu
@c end inserted refs from reference.doc:3084
@c -------------------------------------------------
@node lift, liftstd, LIB, Functions
@subsection lift
@cindex lift
@table @code
@item @strong{Syntax:}
@code{lift (} ideal_expression@code{,} subideal_expression @code{)}
@*@code{lift (} module_expression@code{,} submodule_expression @code{)}
@*@code{lift (} ideal_expression@code{,} subideal_expression@code{,} matrix_name @code{)}
@*@code{lift (} module_expression@code{,} submodule_expression@code{,} matrix_name @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
computes the transformation matrix which expresses the generators of a
submodule in terms of the generators of a module.  Uses different
algorithms for modules which are, resp.@: are not, represented by a
standard basis.
@* More precisely, if  @code{m} is the
module (or ideal), @code{sm} the submodule (or ideal),
and @code{T} the transformation matrix returned by
lift, then @code{matrix(sm)*U = matrix(m)*T}
and @code{module(sm*U) = module(matrix(m)*T)}
(resp.@: @code{ideal(sm*U) = ideal(matrix(m)*T)}),
where @code{U} is a diagonal matrix of units.
@*@code{U} is always the unity matrix if the basering is a polynomial ring
(not power series ring). @code{U} is stored in the optional third argument.
@item @strong{Note:}
Gives a warning if @code{sm} is not a submodule.
@item @strong{Example:}
@smallexample
@c reused example lift reference.doc:3126 
  ring r=32003,(x,y,z),(dp,C);
  ideal m=3x2+yz,7y6+2x2y+5xz;
  poly f=y7+x3+xyz+z2;
  ideal i=jacob(f);
  matrix T=lift(i,m);
  matrix(m)-matrix(i)*T;
@expansion{} _[1,1]=0
@expansion{} _[1,2]=0
@c end example lift reference.doc:3126
@end smallexample
@end table
@c inserted refs from reference.doc:3136
@menu
See
* division::
* ideal::
* module::
@end menu
@c end inserted refs from reference.doc:3136
@c -----------------------------------------
@node liftstd, listvar, lift, Functions
@subsection liftstd
@cindex liftstd
@table @code
@item @strong{Syntax:}
@code{liftstd (} ideal_expression@code{,} matrix_name @code{)}
@*@code{liftstd (} module_expression@code{,} matrix_name @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a standard basis of an ideal or module and the transformation
matrix from the given ideal, resp.@: module, to the standard basis.
@*That is, if @code{m} is the ideal or module, @code{sm} the standard
basis returned by @code{liftstd}, and @code{T} the transformation matrix
then @code{matrix(sm)=matrix(m)*T} and @code{sm=ideal(matrix(m)*T)},
resp.@: @code{sm=module(matrix(m)*T)}.
@item @strong{Example:}
@smallexample
@c reused example liftstd reference.doc:3161 
  ring R=0,(x,y,z),dp;
  poly f=x3+y7+z2+xyz;
  ideal i=jacob(f);
  matrix T;
  ideal sm=liftstd(i,T);
  sm;
@expansion{} sm[1]=xy+2z
@expansion{} sm[2]=3x2+yz
@expansion{} sm[3]=yz2+3048192z3
@expansion{} sm[4]=3024xz2-yz2
@expansion{} sm[5]=y2z-6xz
@expansion{} sm[6]=3097158156288z4+2016z3
@expansion{} sm[7]=7y6+xz
  print(T);
@expansion{} 0,1,T[1,3],   T[1,4],y,  T[1,6],0,
@expansion{} 0,0,-3x+3024z,3x,    0,  T[2,6],1,
@expansion{} 1,0,T[3,3],   T[3,4],-3x,T[3,6],0 
  matrix(sm)-matrix(i)*T;
@expansion{} _[1,1]=0
@expansion{} _[1,2]=0
@expansion{} _[1,3]=0
@expansion{} _[1,4]=0
@expansion{} _[1,5]=0
@expansion{} _[1,6]=0
@expansion{} _[1,7]=0
@c end example liftstd reference.doc:3161
@end smallexample
@end table
@c inserted refs from reference.doc:3173
@menu
See
* ideal::
* matrix::
* option::
* ring::
* std::
@end menu
@c end inserted refs from reference.doc:3173
@c ---------------------------------------
@node listvar, lres, liftstd, Functions
@subsection listvar
@cindex listvar
@table @code
@item @strong{Syntax:}
@code{listvar (} [package] @code{)}
@*@code{listvar (} [package@code{,}] type @code{)}
@*@code{listvar (} [package@code{,}] ring_name @code{)}
@*@code{listvar (} [package@code{,}] name @code{)}
@*@code{listvar (} [package@code{,}] @code{all )}
@item @strong{Type:}
none
@item @strong{Purpose:}
lists all (user-)defined names in the current namespace:
@itemize @bullet
@item @code{listvar()}: all currently visible names except procedures,
@item @code{listvar(}type@code{)}: all currently visible names of the given
type,
@item @code{listvar(}ring_name@code{)}: all names which belong to the given
ring,
@item @code{listvar(}name@code{)}: the object with the given name,
@item @code{listvar(all)}: all names except procedures.
@end itemize
The current basering is marked with a @code{*}.  The nesting level of
variables in procedures is shown in square brackets.

@item @strong{Example:}
@smallexample
@c reused example listvar_1 reference.doc:3243 
  proc t1 @{ @}
  proc t2 @{ @}
  ring s;
  poly ss;
  ring r;
  poly f=x+y+z;
  int i=7;
  ideal I=f,x,y;
  listvar(all);
@expansion{} // i                    [0]  int 7
@expansion{} // r                    [0]  *ring
@expansion{} //      I                    [0]  ideal, 3 generator(s)
@expansion{} //      f                    [0]  poly
@expansion{} // s                    [0]  ring
@expansion{} //      ss                   [0]  poly
@expansion{} // LIB                  [0]  string standard.lib
  listvar();
@expansion{} // i                    [0]  int 7
@expansion{} // r                    [0]  *ring
@expansion{} //      I                    [0]  ideal, 3 generator(s)
@expansion{} //      f                    [0]  poly
@expansion{} // s                    [0]  ring
@expansion{} // LIB                  [0]  string standard.lib
  listvar(r);
@expansion{} // r                    [0]  *ring
@expansion{} // I                    [0]  ideal, 3 generator(s)
@expansion{} // f                    [0]  poly
  listvar(t1);
@expansion{} // t1                   [0]  proc
  listvar(proc);
@expansion{} // t2                   [0]  proc
@expansion{} // t1                   [0]  proc
@expansion{} // fprintf              [0]  proc from standard.lib
@expansion{} // printf               [0]  proc from standard.lib
@expansion{} // sprintf              [0]  proc from standard.lib
@expansion{} // intersect1           [0]  proc from standard.lib (static)
@expansion{} // quotient4            [0]  proc from standard.lib
@expansion{} // quotient5            [0]  proc from standard.lib
@expansion{} // quotient3            [0]  proc from standard.lib
@expansion{} // quotient2            [0]  proc from standard.lib
@expansion{} // quotient1            [0]  proc from standard.lib
@expansion{} // quotient0            [0]  proc from standard.lib (static)
@expansion{} // quot1                [0]  proc from standard.lib (static)
@expansion{} // quot                 [0]  proc from standard.lib
@expansion{} // res                  [0]  proc from standard.lib
@expansion{} // groebner             [0]  proc from standard.lib
@expansion{} // stdhilb              [0]  proc from standard.lib
@expansion{} // stdfglm              [0]  proc from standard.lib
@c end example listvar_1 reference.doc:3243
@end smallexample
@end table
@c inserted refs from reference.doc:3274
@menu
See
* Names::
* Names in procedures::
* defined::
* names::
* type::
@end menu
@c end inserted refs from reference.doc:3274
@c ---------------------------------------
@node lres, maxideal, listvar, Functions
@subsection lres
@cindex lres
@cindex resolution, La Scala's method

@table @code
@item @strong{Syntax:}
@code{lres (} ideal_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal using La Scala's algorithm.

More precisely, let R be the basering and I be the given ideal.
Then @code{lres} computes a minimal free resolution of R/I
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> R --> R/I --> 0.
@end format
@tex
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} R\longrightarrow R/I
\longrightarrow 0.$$
@end tex
If the int_expression k is not zero then the computation stops after
k steps and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
Mi=module(Ai), i=1..k.

@code{list L=lres(I,0);} returns a list L of n modules (where n is the
number of variables of the basering) such that
@tex
${\tt L[i]}=M_i$
@end tex
L[i]=M_i
in the above notation.
@item @strong{Note:}
The ideal_expression has to be homogeneous.
@*Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@smallexample
@c reused example lres reference.doc:3334 
  ring r=0,(x,y,z),dp;
  ideal I=xz,yz,x3-y3;
  def L=lres(I,0);
  print(betti(L),"betti");
@expansion{}            0     1     2
@expansion{} ------------------------
@expansion{}     0:     1     -     -
@expansion{}     1:     -     2     1
@expansion{}     2:     -     1     1
@expansion{} ------------------------
@expansion{} total:     1     3     2
  L[2];     // the first syzygy module of r/I
@expansion{} _[1]=-x*gen(1)+y*gen(2)
@expansion{} _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)
@c end example lres reference.doc:3334
@end smallexample
@end table
@c inserted refs from reference.doc:3343
@menu
See
* betti::
* hres::
* ideal::
* int::
* minres::
* module::
* mres::
* res::
* sres::
@end menu
@c end inserted refs from reference.doc:3343
@c ---------------------------------------
@node maxideal, memory, lres, Functions
@subsection maxideal
@cindex maxideal
@table @code
@item @strong{Syntax:}
@code{maxideal (} int_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the power given by int_expression of the maximal ideal
generated by all ring variables (@code{maxideal(i)=1} for @code{i<=0}).
@item @strong{Example:}
@smallexample
@c reused example maxideal reference.doc:3369 
  ring r=32003,(x,y,z),dp;
  maxideal(2);
@expansion{} _[1]=z2
@expansion{} _[2]=yz
@expansion{} _[3]=y2
@expansion{} _[4]=xz
@expansion{} _[5]=xy
@expansion{} _[6]=x2
@c end example maxideal reference.doc:3369
@end smallexample
@end table
@c inserted refs from reference.doc:3375
@menu
See
* ideal::
* ring::
@end menu
@c end inserted refs from reference.doc:3375
@c ---------------------------------------
@node  memory, minbase, maxideal, Functions
@subsection memory
@cindex memory
@cindex memory managment
@table @code
@item @strong{Syntax:}
@code{memory (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns statistics concerning the memory management:
@itemize @bullet
@item @code{memory(0)} is the number of active (used) bytes,
@item @code{memory(1)} is the number of bytes allocated from the
operating system,
@item @code{memory(2)} is the maximal number of bytes ever allocated from the
operating system during the current @sc{Singular} session.
@end itemize
@item @strong{Note:}
To monitor the memory usage during ongoing computations the option
@code{mem} should be set (using the command @code{option(mem);}, see
also @ref{option}).
@item @strong{Example:}
@smallexample
@c reused example memory reference.doc:3405 
  ring r=0,(x(1..500)),dp;
  poly p=(x(1)+x(500))^50;
  proc ReportMemoryUsage()
  @{  "Memory currently used by SINGULAR     :",memory(0),"Byte (",
     memory(0)/1023, "KByte)" +newline+
     "Memory currently allocated from system:",memory(1), "Byte (",
     memory(1)/1023, "KByte)";
     "Maximal memory allocated from system  :",memory(2), "Byte (",
     memory(2)/1023, "KByte)";
  @}
  ReportMemoryUsage();
@expansion{} Memory currently used by SINGULAR     : 206940 Byte ( 202 KByte)
@expansion{} Memory currently allocated from system: 669128 Byte ( 654 KByte)
@expansion{} Maximal memory allocated from system  : 669128 Byte ( 654 KByte)
  kill p;
  ReportMemoryUsage(); // less memory used: p killed
@expansion{} Memory currently used by SINGULAR     : 153704 Byte ( 150 KByte)
@expansion{} Memory currently allocated from system: 669128 Byte ( 654 KByte)
@expansion{} Maximal memory allocated from system  : 669128 Byte ( 654 KByte)
  kill r;
  ReportMemoryUsage(); // even less memory: r killed
@expansion{} Memory currently used by SINGULAR     : 143124 Byte ( 139 KByte)
@expansion{} Memory currently allocated from system: 669128 Byte ( 654 KByte)
@expansion{} Maximal memory allocated from system  : 669128 Byte ( 654 KByte)
@c end example memory reference.doc:3405
@end smallexample
@end table
@c inserted refs from reference.doc:3424
@menu
See
* option::
* system::
@end menu
@c end inserted refs from reference.doc:3424
@c ---------------------------------------
@node minbase, minor, memory, Functions
@subsection minbase
@cindex minbase
@table @code
@item @strong{Syntax:}
@code{minbase (} ideal_expression @code{)}
@*@code{minbase (} module_expression @code{)}
@item @strong{Type:}
the same as the type of the argument
@item @strong{Purpose:}
returns a minimal set of generators of an ideal, resp.@: module, if the
input is
either homogeneous or if the ordering is local.
@item @strong{Example:}
@smallexample
@c reused example minbase reference.doc:3445 
  ring r=181,(x,y,z),(c,ls);
  ideal id2=x2+xyz,y2-z3y,z3+y5xz;
  ideal id4=maxideal(3)+id2;
  size(id4);
@expansion{} 13
  minbase(id4);
@expansion{} _[1]=x2
@expansion{} _[2]=xyz+x2
@expansion{} _[3]=xz2
@expansion{} _[4]=y2
@expansion{} _[5]=yz2
@expansion{} _[6]=z3
@c end example minbase reference.doc:3445
@end smallexample
@end table
@c inserted refs from reference.doc:3454
@menu
See
* mstd::
@end menu
@c end inserted refs from reference.doc:3454
@c ---------------------------------------
@node minor, minres, minbase, Functions
@subsection minor
@cindex minor
@table @code
@item @strong{Syntax:}
@code{minor (} matrix_expression@code{,} int_expression @code{)}
@*@code{minor (} matrix_expression@code{,} int_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the set of all minors (=subdeterminants) of the given size of a matrix.
The optional third argument must be a standard basis.
If a third argument is given, the computations will be performed modulo that
ideal.
@item @strong{Example:}
@smallexample
@c reused example minor reference.doc:3475 
  ring r=0,(x(1..5)),ds;
  matrix m[2][4]=x(1..4),x(2..5);
  print(m);
@expansion{} x(1),x(2),x(3),x(4),
@expansion{} x(2),x(3),x(4),x(5) 
  ideal j=minor(m,2);
  j;
@expansion{} j[1]=-x(4)^2+x(3)*x(5)
@expansion{} j[2]=-x(3)*x(4)+x(2)*x(5)
@expansion{} j[3]=-x(2)*x(4)+x(1)*x(5)
@expansion{} j[4]=x(3)^2-x(2)*x(4)
@expansion{} j[5]=x(2)*x(3)-x(1)*x(4)
@expansion{} j[6]=-x(2)^2+x(1)*x(3)
  minor(m,2,std(ideal(x(1))));
@expansion{} _[1]=-x(4)^2+x(3)*x(5)
@expansion{} _[2]=-x(3)*x(4)+x(2)*x(5)
@expansion{} _[3]=-x(2)*x(4)
@expansion{} _[4]=x(3)^2-x(2)*x(4)
@expansion{} _[5]=x(2)*x(3)
@expansion{} _[6]=-x(2)^2
@c end example minor reference.doc:3475
@end smallexample
@end table
@c inserted refs from reference.doc:3485
@menu
See
* det::
@end menu
@c end inserted refs from reference.doc:3485
@c ---------------------------------------
@node  minres, modulo, minor, Functions
@subsection minres
@cindex minres
@table @code
@item @strong{Syntax:}
@code{minres (} list_expression @code{)}
@item @strong{Type:}
list
@item @strong{Syntax:}
@code{minres (} resolution_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
minimizes a free resolution of an ideal or module
given by the list_expression, resp.@: resolution_expression.
@item @strong{Example:}
@smallexample
@c reused example minres reference.doc:3507 
  ring r1=32003,(x,y),dp;
  ideal i=x5+xy4,x3+x2y+xy2+y3;
  resolution rs=lres(i,0);
  rs;
@expansion{}   1       2       1       
@expansion{} r1 <--  r1 <--  r1
@expansion{} 
@expansion{} 0       1       2       
@expansion{} resolution not minimized yet
@expansion{} 
  list(rs);
@expansion{} [1]:
@expansion{}    _[1]=x3+x2y+xy2+y3
@expansion{}    _[2]=xy4
@expansion{}    _[3]=y7
@expansion{} [2]:
@expansion{}    _[1]=-y4*gen(1)+x2*gen(2)+xy*gen(2)+y2*gen(2)+gen(3)
@expansion{}    _[2]=-y3*gen(2)+x*gen(3)
  minres(rs);
@expansion{}   1       2       1       
@expansion{} r1 <--  r1 <--  r1
@expansion{} 
@expansion{} 0       1       2       
@expansion{} 
  list(rs);
@expansion{} [1]:
@expansion{}    _[1]=x3+x2y+xy2+y3
@expansion{}    _[2]=xy4
@expansion{} [2]:
@expansion{}    _[1]=xy4*gen(1)-x3*gen(2)-x2y*gen(2)-xy2*gen(2)-y3*gen(2)
@c end example minres reference.doc:3507
@end smallexample
@end table
@c inserted refs from reference.doc:3518
@menu
See
* mres::
* res::
* sres::
@end menu
@c end inserted refs from reference.doc:3518
@c --------------------------------------
@node modulo, monitor, minres, Functions
@subsection modulo
@cindex modulo
@table @code
@item @strong{Syntax:}
@code{modulo (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{modulo (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
@code{modulo(h1,h2)}
represents h1/(h1 intersect h2) (isomorphic to (h1+h2)/h2)
@tex
represents $h_1/(h_1 \cap h_2) \cong (h_1+h_2)/h_2$
@end tex
where
@tex
$h_1$ and $h_2$
@end tex
h1 and h2
are considered as submodules of the same free module
@tex
$R^l$
@end tex
R^l
(l=1 for ideals). Let
@tex
$H_1$, resp.\ $H_2$,
@end tex
H1 and H2
be the matrices of size l x k, resp.@: l x m, having the columns of
@tex
be the matrices of size $l \times k$, resp.\ $l \times m$, having the
generators of $h_1$, resp.\ $h_2$,
@end tex
h1, resp.@: h2,
as columns.
@c @*
@c @tex
@c $R^k \buildrel{H_1}\over{\rightarrow} R^l
@c \buildrel{H_2}\over{\leftarrow} R^m$
@c @end tex
@c @ifinfo
@c @smallexample
@c      H1         H2
@c R^k ----> R^l <---- R^m
@c @end smallexample
@c @end ifinfo
Then
@tex
$h_1/(h_1 \cap h_2) \cong R^k / ker(\overline{H_1})$
@end tex
@format
                                                    __
      h1/(h1 intersect h2) is isomorphic to R^k/ker(H1)

@*
@end format
where
@tex
$\overline{H_1}: R^k \rightarrow R^l/Im(H_2)=R^l/h_2$
is the induced map.
@end tex
@format
         __
         H1: R^k ----> R^l/Im(H2)=R^l/h2 is the induced map.

@*
@end format
@*@code{modulo(h1,h2)} returns generators of
the kernel of this induced map.
@item @strong{Example:}
@smallexample
@c reused example modulo reference.doc:3612 
  ring r;
  ideal h1=x,y,z;
  ideal h2=x;
  module m=modulo(h1,h2);
  print(m);
@expansion{} 1,0, 0,0,
@expansion{} 0,-z,x,0,
@expansion{} 0,y, 0,x 
@c end example modulo reference.doc:3612
@end smallexample
@end table
@c inserted refs from reference.doc:3621
@menu
See
* syz::
@end menu
@c end inserted refs from reference.doc:3621
@c ---------------------------------------
@node monitor, mpresmat, modulo, Functions
@subsection monitor
@cindex monitor
@table @code
@item @strong{Syntax:}
@code{monitor (} string_expression @code{)}
@*@code{monitor (} string_expression@code{,} string_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
controls the recording of all user input and/or program output into a file.
The second argument describes what to log: @code{"i"} means input,
@code{"o"} means output, @code{"io"} for both.
@*The default for the second argument is @code{"i"}.
@*Each @code{monitor} command closes a previous monitor file
and opens the file given by the first string expression.
@*@code{monitor ("")} turns off recording.
@item @strong{Example:}
@smallexample
  monitor("doe.tmp","io"); // log input and output to doe.tmp
  ring r;
  poly f=x+y+z;
  int i=7;
  ideal I=f,x,y;
  monitor("");             // stop logging
@end smallexample
@end table
@c ---------------------------------------
@node mpresmat, mres, monitor, Functions
@subsection mpresmat
@cindex mpresmat
@table @code
@item @strong{Syntax:}
@code{mpresmat (} ideal_expression@code{,} int_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the multipolynomial resultant matrix of the input system.
Uses the sparse resultant matrix method of Gelfand, Kapranov and Zelevinsky
(second parameter = 0) or the resultant matrix method of Macaulay
(second parameter = 1).
@item @strong{Note:}
When using the resultant matrix method of Macaulay the input system must be
homogeneous. The number of elements in the input system must be the number of
variables in the basering plus one.
@item @strong{Example:}
@smallexample
@c reused example mpresmat reference.doc:3675 
  ring rsq=(0,s,t,u),(x,y),lp;
  ideal i=s+tx+uy,x2+y2-10,x2+xy+2y2-16;
  module m=mpresmat(i,0);
  print(m);
@expansion{} -16,0,  -10,0,  (s),0,  0,  0,  0,  0,  
@expansion{} 0,  -16,0,  -10,(u),(s),0,  0,  0,  0,  
@expansion{} 2,  0,  1,  0,  0,  (u),0,  0,  0,  0,  
@expansion{} 0,  2,  0,  1,  0,  0,  0,  0,  0,  0,  
@expansion{} 0,  0,  0,  0,  (t),0,  -10,(s),0,  -16,
@expansion{} 1,  0,  0,  0,  0,  (t),0,  (u),(s),0,  
@expansion{} 0,  1,  0,  0,  0,  0,  1,  0,  (u),2,  
@expansion{} 1,  0,  1,  0,  0,  0,  0,  (t),0,  0,  
@expansion{} 0,  1,  0,  1,  0,  0,  0,  0,  (t),1,  
@expansion{} 0,  0,  0,  0,  0,  0,  1,  0,  0,  1   
@c end example mpresmat reference.doc:3675
@end smallexample
@end table
@c inserted refs from reference.doc:3683
@menu
See
* uressolve::
@end menu
@c end inserted refs from reference.doc:3683
@c ---------------------------------------
@node  mres, mstd, mpresmat, Functions
@subsection mres
@cindex mres
@table @code
@item @strong{Syntax:}
@code{mres (} ideal_expression@code{,} int_expression @code{)}
@*@code{mres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a minimal free resolution of an ideal or module M with the
standard basis method. More precisely, let A=@code{matrix}(M), then @code{mres}
computes a free resolution of
coker(A)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@tex
$coker(A)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M
\longrightarrow 0,$$
@end tex
where the columns of the matrix
@tex
$A_1$
@end tex
A1
are a minimal set of generators
of M if the basering is local or if M is homogeneous.
If the int expression k is not zero then the computation stops after k steps
and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1...k.
@end tex
Mi=module(Ai), i=1...k.
@*@code{mres(M,0)} returns a resolution consisting of at most n+2 modules,
where n is the number of variables of the basering.
Let @code{list L=mres(M,0);}
 then @code{L[1]} consists of a minimal set of generators of the input, @code{L[2]}
consists of a minimal set of generators for the first syzygy module of
@code{L[1]}, etc., until @code{L[p+1]}, such that
L[i]<>0 for i<=p,
@tex
${\tt L[i]}\neq 0$ for $i \le p$,
@end tex
 but @code{L[p+1]}, the first syzygy module of @code{L[p]},
is 0 (if the basering is not a qring).
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@smallexample
@c reused example mres reference.doc:3750 
  ring r=31991,(t,x,y,z,w),ls;
  ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
          t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  resolution L=mres(M,0);
  L;
@expansion{}  1      4      15      18      7      1      
@expansion{} r <--  r <--  r <--   r <--   r <--  r
@expansion{} 
@expansion{} 0      1      2       3       4      5      
@expansion{} 
  // projective dimension of M is 5
@c end example mres reference.doc:3750
@end smallexample
@end table
@c inserted refs from reference.doc:3760
@menu
See
* hres::
* ideal::
* lres::
* module::
* res::
* sres::
@end menu
@c end inserted refs from reference.doc:3760
@c ---------------------------------------
@node  mstd, mult, mres, Functions
@subsection mstd
@cindex mstd
@table @code
@item @strong{Syntax:}
@code{mstd (} ideal_expression @code{)}
@*@code{mstd (} module_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
returns a list whose first entry is a standard basis for the ideal, resp.@:
module. If the monomial ordering is global, then the second entry is both
a generating set for the
ideal, resp.@: module, and a subset of the standard basis.
If, additionally, the input is homogeneous then the second entry is a
minimal generating set for the ideal, resp.@: module.
@item @strong{Example:}
@smallexample
@c reused example mstd reference.doc:3788 
  ring r=0,(x,y,z,t),dp;
  poly f=x3+y4+z6+xyz;
  ideal j=jacob(f),f;
  j=homog(j,t);j;
@expansion{} j[1]=3x2+yz
@expansion{} j[2]=4y3+xzt
@expansion{} j[3]=6z5+xyt3
@expansion{} j[4]=0
@expansion{} j[5]=z6+y4t2+x3t3+xyzt3
  mstd(j);
@expansion{} [1]:
@expansion{}    _[1]=3x2+yz
@expansion{}    _[2]=4y3+xzt
@expansion{}    _[3]=6z5+xyt3
@expansion{}    _[4]=xyzt3
@expansion{}    _[5]=y2z2t3
@expansion{}    _[6]=yz3t4
@expansion{}    _[7]=xz3t4
@expansion{}    _[8]=yz2t7
@expansion{}    _[9]=xz2t7
@expansion{}    _[10]=y2zt7
@expansion{}    _[11]=xy2t7
@expansion{} [2]:
@expansion{}    _[1]=3x2+yz
@expansion{}    _[2]=4y3+xzt
@expansion{}    _[3]=6z5+xyt3
@expansion{}    _[4]=xyzt3
@c end example mstd reference.doc:3788
@end smallexample
@end table
@c inserted refs from reference.doc:3797
@menu
See
* ideal::
* minbase::
* module::
* std::
@end menu
@c end inserted refs from reference.doc:3797
@c ---------------------------------------
@node mult, nameof, mstd, Functions
@subsection mult
@cindex mult
@table @code
@item @strong{Syntax:}
@code{mult (} ideal_expression @code{)}
@*@code{mult (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the degree of the monomial ideal, resp.@: module, generated by
the leading monomials of the input.
@*If the input is a standard basis of a homogeneous ideal
then it returns the degree of this ideal.
@*If the input is a standard basis of an ideal in a (local)
ring with respect to a local degree ordering
then it returns the multiplicity of the ideal (in the sense of Samuel,
with respect to the maximal ideal).
@item @strong{Example:}
@smallexample
@c reused example mult reference.doc:3825 
  ring r=32003,(x,y),ds;
  poly f=(x3+y5)^2+x2y7;
  ideal i=std(jacob(f));
  mult(i);
@expansion{} 46
  mult(std(f));
@expansion{} 6
@c end example mult reference.doc:3825
@end smallexample
@end table
@c inserted refs from reference.doc:3834
@menu
See
* degree::
* dim::
* ideal::
* std::
* vdim::
@end menu
@c end inserted refs from reference.doc:3834
@c ---------------------------------------
@node nameof, names, mult, Functions
@subsection nameof
@cindex nameof
@table @code
@item @strong{Syntax:}
@code{nameof (} expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the name of an expression as string.
@item @strong{Example:}
@smallexample
@c reused example nameof reference.doc:3855 
  int i=9;
  string s=nameof(i);
  s;
@expansion{} i
  nameof(s);
@expansion{} s
  nameof(i+1); //returns the empty string:
@expansion{} 
  nameof(basering);
@expansion{} basering
  basering;
@expansion{}    ? `basering` is undefined
@expansion{}    ? error occurred in line 7: `  basering;`
  ring r;
  nameof(basering);
@expansion{} r
@c end example nameof reference.doc:3855
@end smallexample
@end table
@c inserted refs from reference.doc:3868
@menu
See
* names::
* reservedName::
* typeof::
@end menu
@c end inserted refs from reference.doc:3868
@c ---------------------------------------
@node names, ncols, nameof, Functions
@subsection names
@cindex names
@table @code
@item @strong{Syntax:}
@code{names ( )}
@*@code{names (} ring_name @code{)}
@item @strong{Type:}
list of strings
@item @strong{Purpose:}
returns the names of all user-defined variables which are ring independent
(this includes the names of  procedures) or, in the second case, which
belong to the given ring.

@item @strong{Example:}
@smallexample
@c reused example names_1 reference.doc:3916 
  int i=9;
  ring r;
  poly f;
  poly g;
  setring r;
  names();
@expansion{} [1]:
@expansion{}    r
@expansion{} [2]:
@expansion{}    i
@expansion{} [3]:
@expansion{}    fprintf
@expansion{} [4]:
@expansion{}    printf
@expansion{} [5]:
@expansion{}    sprintf
@expansion{} [6]:
@expansion{}    intersect1
@expansion{} [7]:
@expansion{}    quotient4
@expansion{} [8]:
@expansion{}    quotient5
@expansion{} [9]:
@expansion{}    quotient3
@expansion{} [10]:
@expansion{}    quotient2
@expansion{} [11]:
@expansion{}    quotient1
@expansion{} [12]:
@expansion{}    quotient0
@expansion{} [13]:
@expansion{}    quot1
@expansion{} [14]:
@expansion{}    quot
@expansion{} [15]:
@expansion{}    res
@expansion{} [16]:
@expansion{}    groebner
@expansion{} [17]:
@expansion{}    stdhilb
@expansion{} [18]:
@expansion{}    stdfglm
@expansion{} [19]:
@expansion{}    LIB
  names(r);
@expansion{} [1]:
@expansion{}    g
@expansion{} [2]:
@expansion{}    f
@c end example names_1 reference.doc:3916
@end smallexample
@end table
@c inserted refs from reference.doc:3928
@menu
See
* nameof::
* reservedName::
@end menu
@c end inserted refs from reference.doc:3928
@c ---------------------------------------
@node ncols, npars, names, Functions
@subsection ncols
@cindex ncols
@table @code
@item @strong{Syntax:}
@code{ncols (} matrix_expression @code{)}
@*@code{ncols (} intmat_expression @code{)}
@*@code{ncols (} ideal_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of columns of a matrix or an intmat or the number of
given generators of the ideal, including zeros.
@item @strong{Note:}
@code{size(}ideal@code{)} counts the number of generators
which are different from zero. (Use @code{nrows} to get the number of rows
of a given matrix or intmat.)
@item @strong{Example:}
@smallexample
@c reused example ncols reference.doc:3953 
  ring r;
  matrix m[5][6];
  ncols(m);
@expansion{} 6
  ideal i=x,0,y;
  ncols(i);
@expansion{} 3
  size(i);
@expansion{} 2
@c end example ncols reference.doc:3953
@end smallexample
@end table
@c inserted refs from reference.doc:3963
@menu
See
* matrix::
* nrows::
* size::
@end menu
@c end inserted refs from reference.doc:3963
@c ---------------------------------------
@node npars, nres, ncols, Functions
@subsection npars
@cindex npars
@table @code
@item @strong{Syntax:}
@code{npars (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of parameters of a ring.
@item @strong{Example:}
@smallexample
@c reused example npars reference.doc:3982 
  ring r=(23,t,v),(x,a(1..7)),lp;
  // the parameters are t,v
  npars(r);
@expansion{} 2
@c end example npars reference.doc:3982
@end smallexample
@end table
@c inserted refs from reference.doc:3989
@menu
See
* par::
* parstr::
* ring::
@end menu
@c end inserted refs from reference.doc:3989
@c ---------------------------------------
@node  nres, nrows, npars, Functions
@subsection nres
@cindex nres
@table @code
@item @strong{Syntax:}
@code{nres (} ideal_expression@code{,} int_expression @code{)}
@*@code{nres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module M which is minimized from
the second module on (by the standard basis method).

More precisely, let
@tex
$A_1$=matrix(M),
@end tex
A1=matrix(M),
then @code{nres} computes a free resolution of
coker(A1)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@tex
$coker(A_1)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M\longrightarrow 0,$$
@end tex
@*where the columns of the matrix
@tex
$A_1$
@end tex
A1
are the given set of generators of M.
If the int expression k is not zero then the computation stops after k steps
and returns a list of modules
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
Mi=module(Ai), i=1..k.
@*@code{nres(M,0)} returns a list of n modules where n is the number of
variables of the basering.
Let @code{list L=nres(M,0);} then @code{L[1]=M} is identical to the input,
@code{L[2]} is a minimal set of generators for the first syzygy
module of  @code{L[1]}, etc.
(L[i]=M_i
@tex
(${\tt L[i]}=M_i$
@end tex
in the notations from above).
@item @strong{Example:}
@smallexample
@c reused example nres reference.doc:4058 
  ring r=31991,(t,x,y,z,w),ls;
  ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
          t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  resolution L=nres(M,0);
  L;
@expansion{}  1      4      15      18      7      1      
@expansion{} r <--  r <--  r <--   r <--   r <--  r
@expansion{} 
@expansion{} 0      1      2       3       4      5      
@expansion{} resolution not minimized yet
@expansion{} 
@c end example nres reference.doc:4058
@end smallexample
@end table
@c inserted refs from reference.doc:4067
@menu
See
* hres::
* ideal::
* lres::
* module::
* mres::
* res::
* resolution::
* sres::
@end menu
@c end inserted refs from reference.doc:4067
@c ---------------------------------------
@node nrows, nvars, nres, Functions
@subsection nrows
@cindex nrows
@table @code
@item @strong{Syntax:}
@code{nrows (} matrix_expression @code{)}
@*@code{nrows (} intmat_expression @code{)}
@*@code{nrows (} intvec_expression @code{)}
@*@code{nrows (} module_expression @code{)}
@*@code{nrows (} vector_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of rows of a matrix, an intmat or an intvec, resp.@:
the minimal rank of a free module in which the given module or
vector lives (the index of the last non-zero component).
@item @strong{Note:}
Use @code{ncols} to get the number of columns of a given matrix or intmat.
@item @strong{Example:}
@smallexample
@c reused example nrows reference.doc:4099 
  ring R;
  matrix M[2][3];
  nrows(M);
@expansion{} 2
  nrows(freemodule(4));
@expansion{} 4
  module m=[0,0,1];
  nrows(m);
@expansion{} 3
  nrows([0,x,0]);
@expansion{} 2
@c end example nrows reference.doc:4099
@end smallexample
@end table
@c inserted refs from reference.doc:4110
@menu
See
* gen::
* matrix::
* module::
* ncols::
* vector::
@end menu
@c end inserted refs from reference.doc:4110
@c ---------------------------------------
@node nvars, open, nrows, Functions
@subsection nvars
@cindex nvars
@table @code
@item @strong{Syntax:}
@code{nvars (} ring_name @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of variables of a ring.
@item @strong{Example:}
@smallexample
@c reused example nvars reference.doc:4131 
  ring r=(23,t,v),(x,a(1..7)),ls;
  // the variables are x,a(1),...,a(7)
  nvars(r);
@expansion{} 8
@c end example nvars reference.doc:4131
@end smallexample
@end table
@c inserted refs from reference.doc:4138
@menu
See
* npars::
* ring::
* var::
* varstr::
@end menu
@c end inserted refs from reference.doc:4138
@c ---------------------------------------
@node open, option, nvars, Functions
@subsection open
@cindex open
@table @code
@item @strong{Syntax:}
@code{open (} link_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
opens a link.
@item @strong{Example:}
@smallexample
link l="MPtcp:launch";
open(l);  // start SINGULAR "server" on localhost in batchmode
close(l); // shut down SINGULAR server
@end smallexample
@end table
@c inserted refs from reference.doc:4163
@menu
See
* close::
* link::
@end menu
@c end inserted refs from reference.doc:4163
@c ---------------------------------------
@node option, ord, open, Functions
@subsection option
@cindex option
@table @code
@item @strong{Syntax:}
@code{option ()}
@item @strong{Type:}
string
@item @strong{Purpose:}
lists all defined options.
@*
@item @strong{Syntax:}
@code{option (} option_name @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
sets an option.
@item @strong{Note:}
To disable an option, use the prefix @code{no}.
@*
@item @strong{Syntax:}
@code{option ( get )}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
dumps the state of all options to an intvec.
@*
@item @strong{Syntax:}
@code{option ( set,} intvec_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
restores the state of all options from an intvec (produced by
@code{option(get)}).
@sp 1
@item @strong{Values:}
The following options are used to manipulate the behavior of
computations and act like boolean switches. Use the prefix @code{no} to
disable an option. Notice that some options are ring dependent and reset
to their default values on a change of the current basering.
@table @asis
@item @code{none}
@c ---------
@cindex none, option
turns off all options (including the @code{prompt} option).
@c ---------
@item @code{returnSB}
@cindex returnSB, option
the functions @code{syz}, @code{intersect}, @code{quotient},
@code{modulo} return a standard base instead of a generating set if
@code{returnSB} is set. This option should not be used for @code{lift}.
@c ---------
@item @code{fastHC}
@cindex fastHC, option
tries to the find the highest corner of the staircase (HC) as fast as
possible during a standard basis computation (only used for local
orderings).
@c ---------
@c @item @code{interrupt}
@c allows fast interruption of standard basis computation
@c ---------
@item @code{intStrategy}
@cindex intStrategy, option
avoids division of coefficients during standard basis
computations. This option is ring dependent. By default, it is set for
rings with characteristic 0 and not set for all other rings.
@c ---------
@item @code{oldStd}
@cindex oldStd, option
uses a more lazy approach in std computations,
which was used in Singular version before 2-0
(and which may lead to faster or slower computations, depending on the example)
@item @code{minRes}
@cindex minRes, option
special (additional) minimizing during computations (@code{res}, @code{mres}),
@*assumes homogeneous case and degree-compatible ordering.
@c ---------
@item @code{notRegularity}
@cindex notRegularity, option
disables the regularity bound for @code{res} and @code{mres} (see
@ref{regularity}).
@c ---------
@item @code{notSugar}
@cindex notSugar, option
disables the sugar strategy during standard basis computation.
@anchor{option(prot)}
@c ---------
@item @code{notBuckets}
@cindex notBuckets, option
disables the bucket representation of polynomials during standard basis
computations. This option usually decreases the memory usage but
increases the computation time. It should only be set for
memory-critical standard basis computations.
@c ---------
@item @code{prot}
@cindex prot, option
@cindex protocoll of computations
@cindex progress watch
shows protocol information indicating the
progress during the following computations:
@code{facstd},
@code{fglm},
@code{groebner},
@code{lres},
@code{mres},
@code{minres},
@code{mstd},
@code{res},
@code{sres},
@code{std},
@code{stdfglm},
@code{stdhilb},
@code{syz}.
See below for more details.
@c ---------
@item @code{redSB}
@cindex redSB, option
@cindex reduced standard basis
computes a reduced standard basis in any standard basis computation.
@c ---------
@item @code{redTail}
@cindex redTail, option
reduction of the tails of polynomials during standard basis
computations. This option is ring dependent. By default, it is set for
rings with global degree orderings and not set for all other rings.
@c ---------
@item @code{redThrough}
@cindex redThrough, option
for inhomogeneous input, polynomial reductions during standard basis
computations are never postponed, but always finished through. This option
is ring   dependent. By default, it is set for rings with global degree
orderings and not set for all other rings.
@c ---------
@item @code{sugarCrit}
@cindex sugarCrit, option
uses criteria similar to the homogeneous case to keep more useless pairs.
@c ---------
@item @code{weightM}
@cindex weightM, option
automatically computes suitable weights for the weighted ecart and the
weighted sugar method.
@end table
@*
The following options, which also control computations, are special,
since they are not manipulated by the @code{option} command but by a
direct assignment of a value. Reset the option by assigning the value 0;
the command @code{option(none)} will not reset them! If there is a
non-zero value assigned, the command @code{option()} prints the option.
@table @asis
@item @code{multBound}
a multiplicity bound is set (see @ref{multBound}).
@item @code{degBound}
a degree bound is set (see @ref{degBound}).
@end table
@*
The last set of options controls the output of @sc{Singular}:
@table @asis
@item @code{Imap}
@cindex Imap, option
shows the mapping of variables with the fetch and imap commands.
@item @code{loadLib}
@cindex loadLib, option
shows loading of libraries (set by default).
@item @code{debugLib}
@cindex debugLib, option
warns about syntax errors during loading of libraries.
@item @code{loadProc}
@cindex loadProc, option
shows loading of procedures from libraries.
@item @code{mem}
@cindex mem, option
shows memory usage in square brackets (see @ref{memory}).
@item @code{prompt}
@cindex prompt, option
shows prompt (@code{>}, resp.@: @code{.}) if ready for input (default).
@item @code{reading}
@cindex reading, option
shows the number of characters read from a file.
@item @code{redefine}
@cindex redefine, option
warns about variable redefinitions (set by default).
@item @code{usage}
@cindex usage, option
shows correct usage in error messages (set by default).
@end table
@item @strong{Example:}
@smallexample
@c reused example option reference.doc:4356 
  option(prot);
  option();
@expansion{} //options: prot redefine usage prompt
  option(notSugar);
  option();
@expansion{} //options: prot notSugar redefine usage prompt
  option(noprot);
  option();
@expansion{} //options: notSugar redefine usage prompt
  option(none);
  option();
@expansion{} //options: none
  ring r=0,x,dp;
  degBound=22;
  option();
@expansion{} //options: degBound redTail redThrough intStrategy
  intvec i=option(get);
  option(none);
  option(set,i);
  option();
@expansion{} //options: degBound redTail redThrough intStrategy
@c end example option reference.doc:4356
@end smallexample
@end table

@*The output reported on @code{option(prot)} has the following meaning:
@multitable @columnfractions .01 .14 .11 .65

@item @tab @code{facstd}
@tab @code{F} @tab found a new factor
@item @tab @tab @tab all other characters: like the output of @code{std} and @code{reduce}
@item @tab @tab @tab
@item @tab @code{fglm}
@tab @code{.} @tab basis monomial found
@item @tab @tab @code{+} @tab edge monomial found
@item @tab @tab @code{-} @tab border monomial found
@item @tab @tab @tab
@item @tab @code{groebner} @tab @tab all characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{lres}
@tab @code{.} @tab minimal syzygy found
@item @tab @tab @code{n} @tab slanted degree, i.e., row of Betti matrix
@item @tab @tab @code{(mn)} @tab calculate in module n
@item @tab @tab @code{g} @tab pair found giving reductum and syzygy
@item @tab @tab @tab
@item @tab @code{mres}
@tab @code{[d]}
@tab computations of the d-th syzygy module
@item @tab @tab @tab all other characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{minres}
@tab @code{[d]}
@tab minimizing of the d-th syzygy module
@item @tab @tab @tab
@item @tab @code{mstd} @tab @tab all characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{reduce}
@tab @code{r} @tab reduced a leading term
@item @tab @tab @code{t} @tab reduced a non-leading term
@item @tab @code{res}
@tab @code{[d]}
@tab computations of the d-th syzygy module
@item @tab @tab @tab all other characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{sres}
@tab @code{.} @tab syzygy found
@item @tab @tab @code{(n)} @tab n elements remaining
@item @tab @tab @code{[n]} @tab finished module n
@item @tab @tab @tab
@item @tab @code{std}
@tab @code{[m:n]}
@tab internal ring change to poly representation with exponent bound
m and n words in exponent vector
@item @tab @tab @code{s} @tab found a new element of the standard basis
@item @tab @tab @code{-} @tab reduced a pair/S-polynomial to 0
@item @tab @tab @code{.} @tab postponed a reduction of a pair/S-polynomial
@item @tab @tab @code{h} @tab used Hilbert series criterion
@item @tab @tab @code{H(d)} @tab found a 'highest corner' of degree d, no need to consider higher degrees
@item @tab @tab @code{(n)} @tab n critical pairs are still to be reduced
@item @tab @tab @code{(S:n)} @tab doing complete reduction of n elements
@item @tab @tab @code{d} @tab the degree of the leading terms is currently d
@item @tab @tab @tab
@item @tab @code{stdfglm} @tab @tab all characters in first part: like the output of @code{std}
@item @tab @tab @tab all characters in second part: like the output of @code{fglm}
@item @tab @tab @tab
@item @tab @code{stdhilb} @tab @tab all characters: like the output of @code{std}
@item @tab @tab @tab
@item @tab @code{syz} @tab @tab all characters: like the output of @code{std}
@end multitable


@c inserted refs from reference.doc:4442
@menu
See
* degBound::
* multBound::
* std::
@end menu
@c end inserted refs from reference.doc:4442
@c ---------------------------------------
@node ord, ordstr, option, Functions
@subsection ord
@cindex ord
@table @code
@item @strong{Syntax:}
@code{ord (} poly_expression @code{)}
@*@code{ord (} vector_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the (weighted) degree of
the initial term of a polynomial or a vector;
the weights are the weights used for the first block of the ring ordering.
@item @strong{Note:}
@code{ord(0)} is @code{-1}.
@item @strong{Example:}
@smallexample
@c reused example ord reference.doc:4466 
  ring r=7,(x,y),wp(2,3);
  ord(0);
@expansion{} -1
  poly f=x2+y3;  // weight on y is 3
  ord(f);
@expansion{} 9
  ring R=7,(x,y),ws(2,3);
  poly f=x2+y3;
  ord(f);
@expansion{} 4
  vector v=[x2,y];
  ord(v);
@expansion{} 3
@c end example ord reference.doc:4466
@end smallexample
@end table
@c inserted refs from reference.doc:4479
@menu
See
* deg::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:4479
@c ---------------------------------------
@node ordstr, par, ord, Functions
@subsection ordstr
@cindex ordstr
@table @code
@item @strong{Syntax:}
@code{ordstr (} ring_name @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the description of the monomial ordering of the ring.
@item @strong{Example:}
@smallexample
@c reused example ordstr reference.doc:4498 
  ring r=7,(x,y),wp(2,3);
  ordstr(r);
@expansion{} wp(2,3),C
@c end example ordstr reference.doc:4498
@end smallexample
@end table
@c inserted refs from reference.doc:4504
@menu
See
* charstr::
* parstr::
* ring::
* varstr::
@end menu
@c end inserted refs from reference.doc:4504
@c ---------------------------------------
@node par, pardeg, ordstr, Functions
@subsection par
@cindex par
@table @code
@item @strong{Syntax:}
@code{par (} int_expression @code{)}
@item @strong{Type:}
number
@item @strong{Purpose:}
@code{par(n);} returns the n-th parameter of the basering.
@item @strong{Note:}
This command should only be used if the basering has at least one parameter.
@item @strong{Example:}
@smallexample
@c reused example par reference.doc:4526 
  ring r=(0,a,b,c),(x,y,z),dp;
  char(r);  // char to get the characteristic
@expansion{} 0
  par(2);   // par to get the n-th parameter
@expansion{} (b)
@c end example par reference.doc:4526
@end smallexample
@end table
@c inserted refs from reference.doc:4533
@menu
See
* char::
* npars::
* parstr::
* ring::
* var::
@end menu
@c end inserted refs from reference.doc:4533
@c ---------------------------------------
@node pardeg, parstr, par, Functions
@subsection pardeg
@cindex pardeg
@table @code
@item @strong{Syntax:}
@code{pardeg (} number_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the degree of a number considered as a polynomial in the ring parameters.
@item @strong{Example:}
@smallexample
@c reused example pardeg reference.doc:4554 
  ring r=(0,a,b,c),(x,y,z),dp;
  pardeg(a^2*b);
@expansion{} 3
@c end example pardeg reference.doc:4554
@end smallexample
@end table
@c inserted refs from reference.doc:4560
@menu
See
* deg::
* number::
* ring::
* var::
@end menu
@c end inserted refs from reference.doc:4560
@c ---------------------------------------
@node parstr, preimage, pardeg, Functions
@subsection parstr
@cindex parstr
@table @code
@item @strong{Syntax:}
@code{parstr (} ring_name @code{)}
@*@code{parstr (} int_expression @code{)}
@*@code{parstr (} ring_name@code{,} int_expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the list of parameters of the ring as a string
or the name of the n-th parameter where n is given by the int_expression.
@*If the ring_name is omitted, the basering is used, thus
@code{parstr(n)} is equivalent to @code{parstr(basering,n)}.
@item @strong{Example:}
@smallexample
@c reused example parstr reference.doc:4585 
  ring r=(7,a,b,c),(x,y),wp(2,3);
  parstr(r);
@expansion{} a,b,c
  parstr(2);
@expansion{} b
  parstr(r,3);
@expansion{} c
@c end example parstr reference.doc:4585
@end smallexample
@end table
@c inserted refs from reference.doc:4593
@menu
See
* charstr::
* npars::
* ordstr::
* par::
* ring::
* varstr::
@end menu
@c end inserted refs from reference.doc:4593
@c ---------------------------------------
@node preimage, prime, parstr, Functions
@subsection preimage
@cindex preimage
@cindex kernel

@table @code
@item @strong{Syntax:}
@code{preimage (} ring_name@code{,} map_name@code{,} ideal_name @code{)}
@*@code{preimage (} ring_name@code{,} ideal_expression@code{,} ideal_name @code{)}
@item @strong{Type:}
ideal
@item @strong{Purpose:}
returns the preimage of an ideal under a given map.
@*
The second argument has to be a map from the basering to the given ring
(or an ideal defining such a map),
and the ideal has to be an ideal in the given ring.
@item @strong{Note:}
To compute the kernel of a map, the preimage of zero has to be determined.
Hence there is no special command for computing the kernel of a map in
@sc{Singular}.
@item @strong{Example:}
@smallexample
@c reused example preimage reference.doc:4626 
  ring r1=32003,(x,y,z,w),lp;
  ring r=32003,(x,y,z),dp;
  ideal i=x,y,z;
  ideal i1=x,y;
  ideal i0=0;
  map f=r1,i;
  setring r1;
  ideal i1=preimage(r,f,i1);
  i1;
@expansion{} i1[1]=w
@expansion{} i1[2]=y
@expansion{} i1[3]=x
  // the kernel of f
  preimage(r,f,i0);
@expansion{} _[1]=w
@c end example preimage reference.doc:4626
@end smallexample
@end table
@c inserted refs from reference.doc:4641
@menu
See
* ideal::
* map::
* ring::
@end menu
@c end inserted refs from reference.doc:4641
@c ---------------------------------------
@node prime, print, preimage, Functions
@subsection prime
@cindex prime
@table @code
@item @strong{Syntax:}
@code{prime (} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the largest prime less then 32004 smaller or equal to the argument;
@*returns 2 for all arguments smaller than 3.
@item @strong{Example:}
@smallexample
@c reused example prime reference.doc:4661 
  prime(32004);
@expansion{} 32003
  prime(0);
@expansion{} 2
  prime(-1);
@expansion{} 2
@c end example prime reference.doc:4661
@end smallexample
@end table
@c inserted refs from reference.doc:4668
@menu
See
* general_lib::
* int::
@end menu
@c end inserted refs from reference.doc:4668
@c ---------------------------------------
@node print, printf, prime, Functions
@subsection print
@cindex print
@table @code
@item @strong{Syntax:}
@code{print (} expression @code{)}
@*@code{print (} expression@code{, "betti" )}
@*@code{print (} expression@code{,} format_string @code{)}
@item @strong{Type:}
none (for the first two calling sequences), resp.@:
@*string (for the last calling sequence)
@item @strong{Purpose:}
The first form prints the expression to the terminal and has no return
value. Use the format string @code{%p} to print into a string (see
below).
@*The second form prints the graded Betti numbers from a matrix. See
the description of the format string @code{"betti"} below for more
details.
@*The last form returns the printed output as a string. The format
string determines which format to use to generate the string.

The following format strings are supported:
@table @code
@item "betti"
The Betti numbers are printed in a matrix-like format where the entry
@tex
$d$ in row $i$ and column $j$
@end tex
d in row i and column j
is the minimal number of generators in
degree
@tex
$i+j$ of the $j$-th
@end tex
i+j of the j-th
 syzygy module of
@tex
$R^n/M$ (the 0th and 1st syzygy module of $R^n/M$ is $R^n$ and $M$, resp.).
@end tex
R^n/M (the 0th and 1st syzygy module of R^n/M are R^n and M, resp.).
@item "%s"
returns @code{string(} expression @code{)}
@item "%2s"
similar to @code{"%s"}, except that newlines are inserted after every
comma and at the end
@item "%l"
similar to @code{"%s"}, except that each object is embraced by its type
such that it can be directly used for "cutting and pasting"
@item "%2l"
similar to @code{"%l"}, except that newlines are inserted after every
comma and at the end
@item "%;"
returns the string equivalent to typing @code{expression;}
@item "%t"
returns the string equivalent to typing @code{type expression;}
@item "%p"
returns the string equivalent to typing @code{print(expression);}
@item "%b"
returns the string equivalent to typing @code{print(expression, "betti");}
@end table
@item @strong{Example:}
@smallexample
@c reused example print reference.doc:4742 
  ring r=0,(x,y,z),dp;
  module m=[1,y],[0,x+z];
  m;
@expansion{} m[1]=y*gen(2)+gen(1)
@expansion{} m[2]=x*gen(2)+z*gen(2)
  print(m);  // the columns generate m
@expansion{} 1,0, 
@expansion{} y,x+z
  string s=print(m,"%s"); s;
@expansion{} y*gen(2)+gen(1),x*gen(2)+z*gen(2)
  s=print(m,"%2s"); s;
@expansion{} y*gen(2)+gen(1),
@expansion{} x*gen(2)+z*gen(2)
@expansion{} 
  s=print(m,"%l"); s;
@expansion{} module(y*gen(2)+gen(1),x*gen(2)+z*gen(2))
  s=print(m,"%;"); s;
@expansion{} m[1]=y*gen(2)+gen(1)
@expansion{} m[2]=x*gen(2)+z*gen(2)
@expansion{} 
  s=print(m,"%t"); s;
@expansion{} // m                    [0]  module, rk 2, 2 generator(s)
@expansion{} m[1]=y*gen(2)+gen(1)
@expansion{} m[2]=x*gen(2)+z*gen(2)
  s=print(m,"%p"); s;
@expansion{} 1,0, 
@expansion{} y,x+z
@expansion{} 
  intmat M=betti(mres(m,0));
  print(M,"betti");
@expansion{}            0     1
@expansion{} ------------------
@expansion{}     0:     1     1
@expansion{} ------------------
@expansion{} total:     1     1
  list l=r,M;
  s=print(l,"%s"); s;
@expansion{} (0),(x,y,z),(dp(3),C),1,1 
  s=print(l,"%2s"); s;
@expansion{} (0),(x,y,z),(dp(3),C),
@expansion{} 1,1 
@expansion{} 
  s=print(l,"%l"); s;
@expansion{} list("(0),(x,y,z),(dp(3),C)",intmat(intvec(1,1 ),1,2))
@c end example print reference.doc:4742
@end smallexample
@end table
@c inserted refs from reference.doc:4762
@menu
See
* Type conversion and casting::
* betti::
* dbprint::
* fprintf::
* printf::
* short::
* sprintf::
* string type cast::
* type::
@end menu
@c end inserted refs from reference.doc:4762

@c ---------------------------------------
@node printf, prune, print, Functions
@subsection printf
@cindex printf
@c start include of docu for standard.lib:printf
@c replaced @subsubsection by @sub
@c ---content printf---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{printf (} string_expression @code{[,} any_expressions@code{] )}

@item @strong{Return:}
none

@item @strong{Purpose:}
@code{printf(fmt,...);} performs output formatting. The first
argument is a format control string. Additional arguments may be
required, depending on the content of the control string. A series
of output characters is generated as directed by the control string;
these characters are displayed (i.e., printed to standard out). @*
The control string @code{fmt} is simply text to be copied, except
that the string may contain conversion specifications. @*
Do @code{help print;} for a listing of valid conversion
specifications. As an addition to the conversions of @code{print},
the @code{%n} and @code{%2} conversion specification does not
consume an additional argument, but simply generates a newline
character.

@item @strong{Note:}
If one of the additional arguments is a list, then it should be
enclosed once more into a @code{list()} command, since passing a
list as an argument flattens the list by one level.

@end table
@strong{Example:}
@smallexample
@c reused example printf d2t_singular/standard_lib.doc:450 
  ring r=0,(x,y,z),dp;
module m=[1,y],[0,x+z];
intmat M=betti(mres(m,0));
list l=r,m,M;
printf("s:%s,l:%l",1,2);
@expansion{} s:1,l:int(2)
printf("s:%s",l);
@expansion{} s:(0),(x,y,z),(dp(3),C)
printf("s:%s",list(l));
@expansion{} s:(0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
printf("2l:%2l",list(l));
@expansion{} 2l:list("(0),(x,y,z),(dp(3),C)",
@expansion{} module(y*gen(2)+gen(1),
@expansion{} x*gen(2)+z*gen(2)),
@expansion{} intmat(intvec(1,1 ),1,2))
@expansion{} 
printf("%p",list(l));
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
printf("%;",list(l));
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
printf("%b",M);
@expansion{}            0     1
@expansion{} ------------------
@expansion{}     0:     1     1
@expansion{} ------------------
@expansion{} total:     1     1
@expansion{} 
@c end example printf d2t_singular/standard_lib.doc:450
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:464
@menu
See also:
* fprintf::
* print::
* sprintf::
* string::
@end menu
@c end inserted refs from d2t_singular/standard_lib.doc:464

@c ---end content printf---
@c generated lib proc docu for standard.lib:printf reference.doc:4779 
@c end include of docu for standard.lib:printf

@c ---------------------------------------
@node prune, qhweight, printf, Functions
@subsection prune
@cindex prune
@table @code
@item @strong{Syntax:}
@code{prune (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
returns the module minimally embedded in a free module such that the
corresponding factor modules are isomorphic.
@item @strong{Example:}
@smallexample
@c reused example prune reference.doc:4795 
  ring r=0,(x,y,z),dp;
  module m=gen(1),gen(3),[x,y,0,z],[x+y,0,0,0,1];
  print(m);
@expansion{} 1,0,x,x+y,
@expansion{} 0,0,y,0,  
@expansion{} 0,1,0,0,  
@expansion{} 0,0,z,0,  
@expansion{} 0,0,0,1   
  print(prune(m));
@expansion{} y,
@expansion{} z 
@c end example prune reference.doc:4795
@end smallexample
@end table
@c inserted refs from reference.doc:4803
@menu
See
* module::
@end menu
@c end inserted refs from reference.doc:4803
@c ---------------------------------------
@node qhweight, quot, prune, Functions
@subsection qhweight
@cindex qhweight
@table @code
@item @strong{Syntax:}
@code{qhweight (} ideal_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
computes the weight vector of the variables for a quasihomogeneous ideal.
If the input is not weighted homogeneous, an intvec of zeros is returned.
@item @strong{Example:}
@smallexample
@c reused example qhweight reference.doc:4821 
  ring h1=32003,(t,x,y,z),dp;
  ideal i=x4+y3+z2;
  qhweight(i);
@expansion{} 0,3,4,6
@c end example qhweight reference.doc:4821
@end smallexample
@end table
@c inserted refs from reference.doc:4828
@menu
See
* ideal::
* intvec::
* weight::
@end menu
@c end inserted refs from reference.doc:4828

@c ---------------------------------------
@node quot, quote, qhweight, Functions
@subsection quot
@cindex quot
@c start include of docu for standard.lib:quot
@c replaced @subsubsection by @sub
@c ---content quot---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{quot (} module_expression@code{,} module_expression @code{)}
@*@code{quot (} module_expression@code{,} module_expression@code{,}
int_expression @code{)}
@*@code{quot (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{quot (} ideal_expression@code{,} ideal_expression@code{,}
int_expression @code{)}

@item @strong{Type:}
ideal

@item @strong{Syntax:}
@code{quot (} module_expression@code{,} ideal_expression @code{)}

@item @strong{Type:}
module

@item @strong{Purpose:}
computes the quotient of the 1st and the 2nd argument.
If a 3rd argument 'n' is given the n-th method is used
(n=1...5).

@end table
@strong{Example:}
@smallexample
@c reused example quot d2t_singular/standard_lib.doc:202 
  ring r=181,(x,y,z),(c,ls);
ideal id1=maxideal(4);
ideal id2=x2+xyz,y2-z3y,z3+y5xz;
option(prot);
ideal id3=quotient(id1,id2);
@expansion{} [1023:1]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
@expansion{} product criterion:12 chain criterion:0
@expansion{} @{3@}[1023:3]8(2)s(4)s(5)s9s.s.s.s.s.s
@expansion{} product criterion:0 chain criterion:39
id3;
@expansion{} id3[1]=z2
@expansion{} id3[2]=yz
@expansion{} id3[3]=y2
@expansion{} id3[4]=xz
@expansion{} id3[5]=xy
@expansion{} id3[6]=x2
ideal id4=quot(id1,id2,1);
@expansion{} [1023:2]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:0
@expansion{} (S:3)rtrtrt
@expansion{} @{1@}[1023:3]4(2)s(4)s(5)s5s.s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:39
@expansion{} @{1@}[1023:3]4(5)s(4)s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:9
@expansion{} [255:3]3(11)s(10)sss(9)s(10)s(8)ss(7)s(8)s(6)s(7)s4(5)-----
@expansion{} product criterion:12 chain criterion:9
@expansion{} @{1@}[1023:3]4(2)sss
@expansion{} product criterion:0 chain criterion:12
@expansion{} [255:3]2(8)s(7)s(6)s3(5)ssssss4-----
@expansion{} product criterion:15 chain criterion:3
id4;
@expansion{} id4[1]=z2
@expansion{} id4[2]=yz
@expansion{} id4[3]=xz
@expansion{} id4[4]=y2
@expansion{} id4[5]=xy
@expansion{} id4[6]=x2
ideal id5=quot(id1,id2,2);
@expansion{} [1023:2]4(14)s(13)s(12)s(11)s(10)s(9)s(8)s(7)s(6)s(5)s(4)s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:0
@expansion{} (S:3)rtrtrt
@expansion{} @{1@}[1023:3]4(2)sss
@expansion{} product criterion:0 chain criterion:12
@expansion{} @{1@}[1023:3]4(5)s(4)s(3)s(2)sss
@expansion{} product criterion:0 chain criterion:9
@expansion{} [255:3]2(8)s(7)s(6)s3(5)s(4)s(3)s(2)sss
@expansion{} product criterion:15 chain criterion:0
id5;
@expansion{} id5[1]=z2
@expansion{} id5[2]=yz
@expansion{} id5[3]=xz
@expansion{} id5[4]=y2
@expansion{} id5[5]=xy
@expansion{} id5[6]=x2
@c end example quot d2t_singular/standard_lib.doc:202
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:215
@menu
See also:
* quotient::
@end menu
@c end inserted refs from d2t_singular/standard_lib.doc:215

@c ---end content quot---
@c generated lib proc docu for standard.lib:quot reference.doc:4839 
@c end include of docu for standard.lib:quot


@c ---------------------------------------
@node quote, quotient, quot, Functions
@subsection quote
@cindex quote
@table @code
@item @strong{Syntax:}
@code{quote (} expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
prevents expressions from evaluation. Used only in connections with write to
MPfile links, prevents evaluation of an expression before sending it to an other
@sc{Singular} process.
Within a quoted expression, the
quote can be "undone" by an @code{eval} (i.e., each eval "undoes" the
effect of exactly one quote).
@item @strong{Example:}
@smallexample
@c reused example quote reference.doc:4860 
  link l="MPfile:w example.mp";
  ring r=0,(x,y,z),ds;
  ideal i=maxideal(3);
  ideal j=x7,x2,z;
  option(prot);
  // compute i+j before writing, but not std
  write (l, quote(std(eval(i+j))));
  close(l);
  // now read it in again and evaluate:
  read(l);
@expansion{} [1023:1]1(12)s2(11)s3(10)--s(7)s(6)-----7-
@expansion{} product criterion:4 chain criterion:0
@expansion{} _[1]=z
@expansion{} _[2]=x2
@expansion{} _[3]=xy2
@expansion{} _[4]=y3
  close(l);
@c end example quote reference.doc:4860
@end smallexample
@end table
@c inserted refs from reference.doc:4875
@menu
See
* MPfile links::
* eval::
* write::
@end menu
@c end inserted refs from reference.doc:4875
@c ---------------------------------------
@node quotient, random, quote, Functions
@subsection quotient
@cindex quotient
@table @code
@item @strong{Syntax:}
@code{quotient (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{quotient (} module_expression@code{,} module_expression @code{)}
@item @strong{Type:}
ideal
@item @strong{Syntax:}
@code{quotient (} module_expression@code{,} ideal_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the ideal quotient, resp.@: module quotient. Let @code{R} be the
basering, @code{I,J} ideals and @code{M} a module in
R^n.
@tex
${\tt R}^n$.
@end tex
Then
@itemize
@item
@code{quotient(I,J)}=
@{a in R | aJ in I @}
@tex
$\{a \in R \mid aJ \subset I\}$,
@end tex
@item
@code{quotient(M,J)}=
@{b in R | bJ in M @}.
@tex
$\{b \in R^n \mid bJ \subset M\}$.
@end tex
@end itemize
@item @strong{Example:}
@smallexample
@c reused example quotient reference.doc:4925 
ring r=181,(x,y,z),(c,ls);
ideal id1=maxideal(3);
ideal id2=x2+xyz,y2-z3y,z3+y5xz;
ideal id6=quotient(id1,id2);
id6;
@expansion{} id6[1]=z
@expansion{} id6[2]=y
@expansion{} id6[3]=x
quotient(id2,id1);
@expansion{} _[1]=z2
@expansion{} _[2]=yz
@expansion{} _[3]=y2
@expansion{} _[4]=xz
@expansion{} _[5]=xy
@expansion{} _[6]=x2
module m=x*freemodule(3),y*freemodule(2);
ideal id3=x,y;
quotient(m,id3);
@expansion{} _[1]=[1]
@expansion{} _[2]=[0,1]
@expansion{} _[3]=[0,0,x]
@c end example quotient reference.doc:4925
@end smallexample
@end table
@c inserted refs from reference.doc:4938
@menu
See
* fglmquot::
* ideal::
* module::
@end menu
@c end inserted refs from reference.doc:4938
@c ---------------------------------------
@node random, read, quotient, Functions
@subsection random
@cindex random
@table @code
@item @strong{Syntax:}
@code{random (} int_expression@code{,} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns a random integer between the integer given by the first
int_expression and the one given by the second int_expression.
@*
@item @strong{Syntax:}
@code{random (} int_expression@code{,} int_expression@code{,} int_expression @code{)}
@item @strong{Type:}
intmat
@item @strong{Purpose:}
returns a random intmat where the size is given by the second (number of
rows) and third argument (number of columns). The absolute value of the
entries of the matrix is smaller than or equal to the integer given as
the first argument.
@item @strong{Note:}
The random generator can be set to a start value with
the function @code{system}, resp.@: by a command line option.
@item @strong{Example:}
@smallexample
@c reused example random reference.doc:4971 
  random(1,1000);
@expansion{} 35
  random(1,2,3);
@expansion{} 0,0,0,
@expansion{} 1,1,-1 
  system("random",210);  // start random generator with 210
  random(-1000,1000);
@expansion{} 707
  random(-1000,1000);
@expansion{} 284
  system("random",210);
  random(-1000,1000);    // the same random values again
@expansion{} 707
@c end example random reference.doc:4971
@end smallexample
@end table
@c inserted refs from reference.doc:4982
@menu
See
* Command line options::
* int::
* intmat::
* system::
@end menu
@c end inserted refs from reference.doc:4982
@c ---------------------------------------
@node read, reduce, random, Functions
@subsection read
@cindex read
@table @code
@item @strong{Syntax:}
@code{read (} link_expression @code{)}
@*for DBM links:
@*@code{read (} link_expression @code{)}
@*@code{read (} link_expression@code{,} string_expression @code{)}
@item @strong{Type:}
any
@item @strong{Purpose:}
reads data from a link.
@*For ASCII links, the content of the entire
file is returned as one string. If the ASCII link is the empty string,
@code{read} reads from standard input.
@*For MP links, one expression is read
from the link and returned after evaluation.
@*For MPtcp links the @code{read} command blocks as long as there is no
data to be read from the link. The @code{status} command can be used to
check whether or not there is data to be read.
@*For DBM links, a @code{read} with one argument returns the value of
the next entry in the data base, and a @code{read} with two arguments
returns the value to the key given as the second argument from the data
base.
@item @strong{Example:}
@smallexample
@c reused example read reference.doc:5017 
  ring r=32003,(x,y,z),dp;
  ideal i=x+y,z3+22y;
  // write the ideal i to the file save_i
  write(":w save_i",i);
  ring r0=0,(x,y,z),Dp;
  // create an ideal k equal to the content
  // of the file save_i
  string s="ideal k="+read("save_i")+";";
  execute(s);
  k;
@expansion{} k[1]=x+y
@expansion{} k[2]=z3+22y
@c end example read reference.doc:5017
@end smallexample
@end table
@c inserted refs from reference.doc:5031
@menu
See
* execute::
* getdump::
* link::
* status::
* write::
@end menu
@c end inserted refs from reference.doc:5031
@c ---------------------------------------
@node reduce, regularity, read, Functions
@subsection reduce
@cindex reduce
@cindex NF
@table @code
@item @strong{Syntax:}
@code{reduce (} poly_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} poly_expression@code{,} ideal_expression@code{,} poly_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} vector_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} vector_expression@code{,} module_expression@code{,} poly_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} ideal_expression@code{,} ideal_expression@code{,} matrix_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression @code{)}
@*@code{reduce (} module_expression@code{,} ideal_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} int_expression @code{)}
@*@code{reduce (} module_expression@code{,} module_expression@code{,} matrix_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
reduces a polynomial, vector, ideal  or module to its normal form with respect to an ideal or module represented by a standard basis.
Returns 0 if and only if the polynomial (resp.@: vector, ideal, module)
is an element (resp.@: subideal, submodule) of the ideal (resp.@: module).
The result may have no meaning if the second argument is not a standard basis.
@*The third (optional) argument 1 of type int forces a reduction which considers only the leading term and does no tail reduction.
@*If a third argument @code{u} of type poly or matrix is given, the first argument @code{p} is replaced by @code{p/u}.
This works only for zero dimensional ideals (resp.@: modules) in the second argument and gives, even in a local ring, a reduced normal form which is the projection to the quotient by the ideal (resp.@: module).
@item @strong{Note:}
The commands @code{reduce} and @code{NF} are synonymous.
@item @strong{Example:}
@smallexample
@c reused example reduce reference.doc:5076 
  ring r1 = 0,(z,y,x),ds;
  poly s1=2x5y+7x2y4+3x2yz3;
  poly s2=1x2y2z2+3z8;
  poly s3=4xy5+2x2y2z3+11x10;
  ideal i=s1,s2,s3;
  ideal j=std(i);
  reduce(3z3yx2+7y4x2+yx5+z12y2x2,j);
@expansion{} -yx5+2401/81y14x2+2744/81y11x5+392/27y8x8+224/81y5x11+16/81y2x14
  reduce(3z3yx2+7y4x2+yx5+z12y2x2,j,1);
@expansion{} -yx5+z12y2x2
@c end example reduce reference.doc:5076
@end smallexample
@end table
@c inserted refs from reference.doc:5088
@menu
See
* ideal::
* module::
* std::
* vector::
@end menu
@c end inserted refs from reference.doc:5088
@c ---------------------------------------
@node regularity, repart, reduce, Functions
@subsection regularity
@cindex regularity
@table @code
@item @strong{Syntax:}
@code{regularity (} list_expression @code{)}
@*@code{regularity (} resolution_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the regularity of a homogeneous ideal, resp.@: module, from a
minimal resolution given by the list expression.
@*
Let
@format
       K[X]e(a,n) ---> ... ---> (+) K[X]e(a,0) ---> I ---> 0
@end format
be a minimal resolution with homogeneous maps of degree 0.
The regularity is the smallest number s with the property @*
deg(e(a,i)) <= s+i for all i.
@tex
\noindent
Let $0 \rightarrow\ \bigoplus_a K[x]e_{a,n}\ \rightarrow\ \dots
  \rightarrow\ \bigoplus_a K[x]e_{a,0}\ \rightarrow\
  I\ \rightarrow\ 0$
be a minimal resolution of I considered with homogeneous maps of degree 0.
The regularity is the smallest number $s$ with the property deg($e_{a,i})
 \leq s+i$ for all $i$.
@end tex
@item @strong{Note:}
If applied to a non minimal resolution only an upper bound is returned.
@*If the input to the commands @code{res} and @code{mres} is homogeneous
the regularity is computed and used as a degree bound during
the computation unless @code{option(notRegularity);} is given.
@item @strong{Example:}
@smallexample
@c reused example regularity reference.doc:5134 
  ring rh3=32003,(w,x,y,z),(dp,C);
  poly f=x11+y10+z9+x5y2+x2y2z3+xy3*(y2+x)^2;
  ideal j=homog(jacob(f),w);
  def jr=res(j,0);
  regularity(jr);
@expansion{} 25
  // example for upper bound behavior:
  list jj=jr;
  regularity(jj);
@expansion{} 25
  jj=nres(j,0);
  regularity(jj);
@expansion{} 27
  jj=minres(jj);
  regularity(jj);
@expansion{} 25
@c end example regularity reference.doc:5134
@end smallexample
@end table
@c inserted refs from reference.doc:5150
@menu
See
* list::
* minres::
* mres::
* option::
* res::
* resolution::
* sres::
@end menu
@c end inserted refs from reference.doc:5150
@c ---------------------------------------
@node repart, res, regularity, Functions
@subsection repart
@cindex repart

@table @code
@item @strong{Syntax:}
@code{repart (} number_expression @code{)}
@item @strong{Type:}
number
@item @strong{Purpose:}
returns the real part of a number from a complex ground field,
@*returns its argument otherwise.
@item @strong{Example:}
@smallexample
@c reused example repart reference.doc:5175 
  ring r=(complex,i),x,dp;
  repart(1+2*i);
@expansion{} 1
@c end example repart reference.doc:5175
@end smallexample
@end table
@c inserted refs from reference.doc:5181
@menu
See
* impart::
@end menu
@c end inserted refs from reference.doc:5181
@c ---------------------------------------
@node  res, reservedName, repart, Functions
@subsection res
@cindex res
@c start include of docu for standard.lib:res
@c replaced @subsubsection by @sub
@c ---content res---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@c we do texinfo here:
@cindex resolution, computation of
@table @code
@item @strong{Syntax:}
@code{res (} ideal_expression@code{,} int_expression @code{[,} any_expression @code{])}
@*@code{res (} module_expression@code{,} int_expression @code{[,} any_expression @code{])}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a (possibly minimal) free resolution of an ideal or module using
a heuristically chosen method.
@* The second (int) argument (say, @code{k}) specifies the length of
the resolution. If it is not positive then @code{k} is assumed to be the
number of variables of the basering.
@* If a third argument is given, the returned resolution is minimized.

Depending on the input, the returned resolution is computed using the
following methods:
@table @asis
@item @strong{quotient rings:}
@code{nres} (classical method using syzygies) , see @ref{nres}.

@item @strong{homogeneous ideals and k=0:}
@code{lres} (La'Scala's method), see @ref{lres}.

@item @strong{not minimized resolution and (homogeneous input with k not 0, or local rings):}
@code{sres} (Schreyer's method), see @ref{sres}.

@item @strong{all other inputs:}
@code{mres} (classical method), see @ref{mres}.
@end table
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@end table
@c inserted refs from d2t_singular/standard_lib.doc:263
@menu
See also
* betti::
* hres::
* ideal::
* lres::
* minres::
* module::
* mres::
* nres::
* resolution::
* sres::
@end menu
@c end inserted refs from d2t_singular/standard_lib.doc:263

@strong{Example:}
@smallexample
@c reused example res d2t_singular/standard_lib.doc:279 
  ring r=0,(x,y,z),dp;
ideal i=xz,yz,x3-y3;
def l=res(i,0); // homogeneous ideal: uses lres
l;
@expansion{}  1      3      2      
@expansion{} r <--  r <--  r
@expansion{} 
@expansion{} 0      1      2      
@expansion{} resolution not minimized yet
@expansion{} 
print(betti(l), "betti"); // input to betti may be of type resolution
@expansion{}            0     1     2
@expansion{} ------------------------
@expansion{}     0:     1     -     -
@expansion{}     1:     -     2     1
@expansion{}     2:     -     1     1
@expansion{} ------------------------
@expansion{} total:     1     3     2
l[2];         // element access may take some time
@expansion{} _[1]=-x*gen(1)+y*gen(2)
@expansion{} _[2]=-x2*gen(2)+y2*gen(1)+z*gen(3)
i=i,x+1;
l=res(i,0);   // inhomogeneous ideal: uses mres
l;
@expansion{}  1      3      3      1      
@expansion{} r <--  r <--  r <--  r
@expansion{} 
@expansion{} 0      1      2      3      
@expansion{} resolution not minimized yet
@expansion{} 
ring rs=0,(x,y,z),ds;
ideal i=imap(r,i);
def l=res(i,0); // local ring not minimized: uses sres
l;
@expansion{}   1       1       
@expansion{} rs <--  rs
@expansion{} 
@expansion{} 0       1       
@expansion{} resolution not minimized yet
@expansion{} 
res(i,0,0);     // local ring and minimized: uses mres
@expansion{}   1       1       
@expansion{} rs <--  rs
@expansion{} 
@expansion{} 0       1       
@expansion{} 
@c end example res d2t_singular/standard_lib.doc:279
@end smallexample
@c ---end content res---
@c generated lib proc docu for standard.lib:res reference.doc:5189 
@c end include of docu for standard.lib:res

@c ---------------------------------------
@node reservedName, resultant, res, Functions
@subsection reservedName
@cindex reservedName
@table @code
@item @strong{Syntax:}
@code{reservedName ()}
@item @strong{Type:}
none
@item @strong{Syntax:}
@code{reservedName (} string_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
prints a list of all reserved identifiers (first form) or tests
whether the string is a reserved identifier (second form).
@item @strong{Example:}
@smallexample
reservedName();
@expansion{} ... // output skipped
@c reused example reservedName reference.doc:5211 
  reservedName("ring");
@expansion{} 1
  reservedName("xyz");
@expansion{} 0
@c end example reservedName reference.doc:5211
@end smallexample
@end table
@c inserted refs from reference.doc:5217
@menu
See
* names::
* string::
@end menu
@c end inserted refs from reference.doc:5217
@c ---------------------------------------
@node  resultant, rvar, reservedName, Functions
@subsection resultant
@cindex resultant
@table @code
@item @strong{Syntax:}
@code{resultant (} poly_expression@code{,} poly_expression@code{,} ring_variable @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
computes the resultant of the first and second argument with respect
to the variable given as the third argument.
@item @strong{Example:}
@smallexample
@c reused example resultant reference.doc:5236 
  ring r=32003,(x,y,z),dp;
  poly f=3*(x+2)^3+y;
  poly g=x+y+z;
  resultant(f,g,x);
@expansion{} 3y3+9y2z+9yz2+3z3-18y2-36yz-18z2+35y+36z-24
@c end example resultant reference.doc:5236
@end smallexample
@end table
@c inserted refs from reference.doc:5244
@menu
See
* poly::
* ring::
@end menu
@c end inserted refs from reference.doc:5244
@c ---------------------------------------
@node rvar, setring, resultant, Functions
@subsection rvar
@cindex rvar
@table @code
@item @strong{Syntax:}
@code{rvar (} name @code{)}
@*@code{rvar (} poly_expression @code{)}
@*@code{rvar (} string_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the number of the variable if the name is a ring variable of the
basering or if the string is the name of a ring variable of the
basering; returns 0 if not. Hence the return value of @code{rvar} can
also be used in a boolean context to check whether the variable exists.
@item @strong{Example:}
@smallexample
@c reused example rvar reference.doc:5267 
  ring r=29,(x,y,z),lp;
  rvar(x);
@expansion{} 1
  rvar(r);
@expansion{} 0
  rvar(y);
@expansion{} 2
  rvar(var(3));
@expansion{} 3
  rvar("x");
@expansion{} 1
@c end example rvar reference.doc:5267
@end smallexample
@end table
@c inserted refs from reference.doc:5277
@menu
See
* defined::
* ring::
* var::
* varstr::
@end menu
@c end inserted refs from reference.doc:5277
@c ---------------------------------------
@node setring, simplex, rvar, Functions
@subsection setring
@cindex setring
@table @code
@item @strong{Syntax:}
@code{setring} ring_name
@item @strong{Type:}
none
@item @strong{Purpose:}
changes the basering to another (already defined) ring.
@item @strong{Example:}
@smallexample
@c reused example setring reference.doc:5297 
  ring r1=0,(x,y),lp;
  // the basering is r1
  ring r2=32003,(a(1..8)),ds;
  // the basering is r2
  setring r1;
  // the basering is again r1
  nameof(basering);
@expansion{} r1
  listvar();
@expansion{} // r2                   [0]  ring
@expansion{} // r1                   [0]  *ring
@expansion{} // LIB                  [0]  string standard.lib
@c end example setring reference.doc:5297
@end smallexample
@item @strong{Use in procedures:}
All changes of the basering by a definition of a new ring or a
@code{setring} command in a procedure are local to this procedure.  Use
@code{keepring} to move a ring, which is local to a procedure, up by one
nesting level.

@end table
@c inserted refs from reference.doc:5315
@menu
See
* keepring::
* qring::
* ring::
@end menu
@c end inserted refs from reference.doc:5315
@c ---------------------------------------
@node simplex, simplify, setring, Functions
@subsection simplex
@cindex simplex
@table @code
@item @strong{Syntax:}
@code{simplex (} matrix_expression@code{,} int_expression@code{,} 
int_expression@code{,} int_expression@code{,} int_expression@code{,} 
int_expression@code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
perform the simplex algorithm for the tableau given by the input, e.g.
M,m,n,m1,m2,m3: 

@table @asis
@item  M matrix of numbers : 
     first row describing the objective function (maximize problem), 
     the remaining rows describing constraints; 
@item  m,n,m1,m2,m3 int :
     n = number of variables; 
     m = total number of constraints; 
     m1 = number of <=constraints (rows 2 ... m1+1 of M); 
     m2 = number of >=constraints (rows m1+2 ... m1+m2+1 of M); 
     m3 = number of == constraints.
@end table 

The following assumptions are made: 
@table @asis
@item   * ground field is of type @code{(real,N)}, N>=4; 
@item   * the matrix M is of size m x n; 
@item   * m=m1+m2+m3;
@item   * the entries M[2,1] ,..., M[m+1,1] are non-negative;
@item   * the variables x(i) are non-negative;
@item   * a row  b, a(1) ,..., a(n)  corresponds to  b+a(1)x(1)+...+a(n)x(n);
@item   * for a <=, >=, or == constraint: add "in mind" >=0, <=0, or ==0.
@end table   

The output is a list L with 
@table @asis
@item * L[1] = matrix
@item * L[2] = int: 
    0 = finite solution found;  1 = unbounded;  -1 = no solution;  
   -2 = error occured;
@item * L[3] = intvec :  
   L[3][k] = number of variable which corresponds to row k+1 of L[1];             
@item * L[4] = intvec :  
   L[4][j] = number of variable which is represented by column j+1 of L[1] 
   ("non-basis variable");
@item * L[5] = int :  
   number of constraints (= m);
@item * L[6] = int :  
   number of variables (= n).
@end table

The solution can be read from the first column of L[1] as is done by the 
procedure @ref{simplexOut} in @code{solve.lib}. 

@item @strong{Example:}
@smallexample
@c reused example simplex reference.doc:5381 
    ring r = (real,10),(x),lp;

    // consider the max. problem:
    //
    //    maximize  x(1) + x(2) + 3*x(3) - 0.5*x(4)
    //
    //  with constraints:   x(1) +          2*x(3)          <= 740
    //                             2*x(2)          - 7*x(4) <=   0
    //                               x(2) -   x(3) + 2*x(4) >=   0.5
    //                      x(1) +   x(2) +   x(3) +   x(4)  =   9
    //
    matrix sm[5][5]=(  0, 1, 1, 3,-0.5,
                     740,-1, 0,-2, 0,
                       0, 0,-2, 0, 7,
                     0.5, 0,-1, 1,-2,
                       9,-1,-1,-1,-1);

    int n = 4;  // number of constraints
    int m = 4;  // number of variables
    int m1= 2;  // number of <= constraints
    int m2= 1;  // number of >= constraints
    int m3= 1;  // number of == constraints
    simplex(sm, n, m, m1, m2, m3);
@expansion{} [1]:
@expansion{}    _[1,1]=17.025
@expansion{}    _[1,2]=-0.95
@expansion{}    _[1,3]=-0.05
@expansion{}    _[1,4]=1.95
@expansion{}    _[1,5]=-1.05
@expansion{}    _[2,1]=730.55
@expansion{}    _[2,2]=0.1
@expansion{}    _[2,3]=-0.1
@expansion{}    _[2,4]=-1.1
@expansion{}    _[2,5]=0.9
@expansion{}    _[3,1]=3.325
@expansion{}    _[3,2]=-0.35
@expansion{}    _[3,3]=-0.15
@expansion{}    _[3,4]=0.35
@expansion{}    _[3,5]=0.35
@expansion{}    _[4,1]=0.95
@expansion{}    _[4,2]=-0.1
@expansion{}    _[4,3]=0.1
@expansion{}    _[4,4]=0.1
@expansion{}    _[4,5]=0.1
@expansion{}    _[5,1]=4.725
@expansion{}    _[5,2]=-0.55
@expansion{}    _[5,3]=0.05
@expansion{}    _[5,4]=0.55
@expansion{}    _[5,5]=-0.45
@expansion{} [2]:
@expansion{}    0
@expansion{} [3]:
@expansion{}    5,2,4,3
@expansion{} [4]:
@expansion{}    1,6,8,7
@expansion{} [5]:
@expansion{}    4
@expansion{} [6]:
@expansion{}    4
@c end example simplex reference.doc:5381
@end smallexample
@end table
@c inserted refs from reference.doc:5408
@menu
See
* simplexOut::
@end menu
@c end inserted refs from reference.doc:5408
@c ---------------------------------------
@node simplify, size, simplex, Functions
@subsection simplify
@cindex simplify
@table @code
@item @strong{Syntax:}
@code{simplify (} poly_expression@code{,} int_expression @code{)}
@*@code{simplify (} vector_expression@code{,} int_expression @code{)}
@*@code{simplify (} ideal_expression@code{,} int_expression @code{)}
@*@code{simplify (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
the type of the first argument
@item @strong{Purpose:}
returns the "simplified" first argument depending on the simplification rule
given as the second argument.
The simplification rules are the sum of the following
functions:
@table @code
@item 1
normalize (make leading coefficients 1).
@item 2
erase zero generators/columns.
@item 4
keep only the first one of identical generators/columns.
@item 8
keep only the first one of generators/columns which differ only by a factor
in the ground field.
@item 16
keep only those generators/columns whose leading monomials
differ.
@item 32
keep only those generators/columns whose leading monomials are
not divisible by other ones.
@end table
@item @strong{Example:}
@smallexample
@c reused example simplify reference.doc:5448 
ring r=0,(x,y,z),(c,dp);
ideal i=0,2x,2x,4x,3x+y,5x2;
simplify(i,1);
@expansion{} _[1]=0
@expansion{} _[2]=x
@expansion{} _[3]=x
@expansion{} _[4]=x
@expansion{} _[5]=x+1/3y
@expansion{} _[6]=x2
simplify(i,2);
@expansion{} _[1]=2x
@expansion{} _[2]=2x
@expansion{} _[3]=4x
@expansion{} _[4]=3x+y
@expansion{} _[5]=5x2
simplify(i,4);
@expansion{} _[1]=0
@expansion{} _[2]=2x
@expansion{} _[3]=4x
@expansion{} _[4]=3x+y
@expansion{} _[5]=5x2
simplify(i,8);
@expansion{} _[1]=0
@expansion{} _[2]=2x
@expansion{} _[3]=3x+y
@expansion{} _[4]=5x2
simplify(i,16);
@expansion{} _[1]=0
@expansion{} _[2]=2x
@expansion{} _[3]=5x2
simplify(i,32);
@expansion{} _[1]=0
@expansion{} _[2]=2x
simplify(i,32+2+1);
@expansion{} _[1]=x
matrix A[2][3]=x,0,2x,y,0,2y;
simplify(A,2+8); // by automatic conversion to module
@expansion{} _[1]=[x,y]
@c end example simplify reference.doc:5448
@end smallexample
@end table
@c inserted refs from reference.doc:5463
@menu
See
* ideal::
* module::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:5463
@c ---------------------------------------
@node size, sortvec, simplify, Functions
@subsection size
@cindex size
@table @code
@item @strong{Syntax:}
@code{size (} string_expression @code{)}
@*@code{size (} intvec_expression @code{)}
@*@code{size (} intmat_expression @code{)}
@*@code{size (} poly_expression @code{)}
@*@code{size (} vector_expression @code{)}
@*@code{size (} ideal_expression @code{)}
@*@code{size (} module_expression @code{)}
@*@code{size (} matrix_expression @code{)}
@*@code{size (} list_expression @code{)}
@*@code{size (} resolution_expression @code{)}
@*@code{size (} ring_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
depends on the type of argument:
@table @asis
@item ideal or module
returns the number of (non-zero) generators.
@item string, intvec, list or resolution
returns the length, i.e., the number of characters, entries or elements.
@item poly or vector
returns the number of monomials.
@item matrix or intmat
returns the number of entries (rows*columns).
@item ring
returns the number of elements in the ground field
(for Z/p and algebraic extensions) or -1
@end table
@item @strong{Example:}
@smallexample
@c reused example size reference.doc:5506 
  string s="hello";
  size(s);
@expansion{} 5
  intvec iv=1,2;
  size(iv);
@expansion{} 2
  ring r=0,(x,y,z),lp;
  poly f=x+y+z;
  size(f);
@expansion{} 3
  vector v=[x+y,0,0,1];
  size(v);
@expansion{} 3
  ideal i=f,y;
  size(i);
@expansion{} 2
  module m=v,[0,1],[0,0,1],2*v;
  size(m);
@expansion{} 4
  matrix mm[2][2];
  size(mm);
@expansion{} 4
  ring r1=(2,a),x,dp;
  minpoly=a4+a+1;
  size(r1);
@expansion{} 8
@c end example size reference.doc:5506
@end smallexample
@end table
@c inserted refs from reference.doc:5528
@menu
See
* ideal::
* intmat::
* intvec::
* module::
* ncols::
* nrows::
* poly::
* string::
* vector::
@end menu
@c end inserted refs from reference.doc:5528
@c ---------------------------------------
@node sortvec, sprintf, size, Functions
@subsection sortvec
@cindex sortvec
@table @code
@item @strong{Syntax:}
@code{sortvec (} ideal_expression @code{)}
@*@code{sortvec (} module_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
@tex
computes the permutation {\tt v}
which orders the ideal, resp.\ module, {\tt I} by its initial terms,
starting with the smallest, that is, {\tt I(v[i]) < I(v[i+1])} for all
{\tt i}.
@end tex
computes the permutation v
which orders the ideal, resp.@: module, I by its initial terms,
starting with the smallest, that is,
@*I(v[i]) < I(v[i+1]) for all i.
@item @strong{Example:}
@smallexample
@c reused example sortvec reference.doc:5565 
  ring r=0,(x,y,z),dp;
  ideal I=y,z,x,x3,xz;
  sortvec(I);
@expansion{} 2,1,3,5,4
@c end example sortvec reference.doc:5565
@end smallexample
@end table
@c inserted refs from reference.doc:5572
@menu
See
* general_lib::
@end menu
@c end inserted refs from reference.doc:5572
@c ---------------------------------------
@node sprintf, sres, sortvec, Functions
@subsection sprintf
@cindex sprintf
@c start include of docu for standard.lib:sprintf
@c replaced @subsubsection by @sub
@c ---content sprintf---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{sprintf (} string_expression @code{[,} any_expressions
@code{] )}

@item @strong{Return:}
string

@item @strong{Purpose:}
@code{sprintf(fmt,...);} performs output formatting. The first
argument is a format control string. Additional arguments may be
required, depending on the content of the control string. A series
of output characters is generated as directed by the control string;
these characters are returned as a string. @*
The control string @code{fmt} is simply text to be copied,
except that the string may contain conversion specifications.@*
Do @code{help print;} for a listing of valid conversion
specifications. As an addition to the conversions of @code{print},
the @code{%n} and @code{%2} conversion specification does not
consume an additional argument, but simply generates a newline
character.

@item @strong{Note:}
If one of the additional arguments is a list, then it should be
enclosed once more into a @code{list()} command, since passing a list
as an argument flattens the list by one level.

@end table
@strong{Example:}
@smallexample
@c reused example sprintf d2t_singular/standard_lib.doc:335 
  ring r=0,(x,y,z),dp;
module m=[1,y],[0,x+z];
intmat M=betti(mres(m,0));
list l = r, m, M;
string s = sprintf("s:%s,%n l:%l", 1, 2); s;
@expansion{} s:1,
@expansion{}  l:int(2)
s = sprintf("s:%n%s", l); s;
@expansion{} s:
@expansion{} (0),(x,y,z),(dp(3),C)
s = sprintf("s:%2%s", list(l)); s;
@expansion{} s:
@expansion{} (0),(x,y,z),(dp(3),C),y*gen(2)+gen(1),x*gen(2)+z*gen(2),1,1 
s = sprintf("2l:%n%2l", list(l)); s;
@expansion{} 2l:
@expansion{} list("(0),(x,y,z),(dp(3),C)",
@expansion{} module(y*gen(2)+gen(1),
@expansion{} x*gen(2)+z*gen(2)),
@expansion{} intmat(intvec(1,1 ),1,2))
@expansion{} 
s = sprintf("%p", list(l)); s;
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
s = sprintf("%;", list(l)); s;
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
@expansion{} [2]:
@expansion{}    _[1]=y*gen(2)+gen(1)
@expansion{}    _[2]=x*gen(2)+z*gen(2)
@expansion{} [3]:
@expansion{}    1,1 
@expansion{} 
s = sprintf("%b", M); s;
@expansion{}            0     1
@expansion{} ------------------
@expansion{}     0:     1     1
@expansion{} ------------------
@expansion{} total:     1     1
@expansion{} 
@c end example sprintf d2t_singular/standard_lib.doc:335
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:349
@menu
See also:
* fprintf::
* print::
* printf::
* string::
@end menu
@c end inserted refs from d2t_singular/standard_lib.doc:349

@c ---end content sprintf---
@c generated lib proc docu for standard.lib:sprintf reference.doc:5580 
@c end include of docu for standard.lib:sprintf

@c ---------------------------------------
@node sres, status, sprintf, Functions
@subsection sres
@cindex sres
@table @code
@item @strong{Syntax:}
@code{sres (} ideal_expression@code{,} int_expression @code{)}
@*@code{sres (} module_expression@code{,} int_expression @code{)}
@item @strong{Type:}
resolution
@item @strong{Purpose:}
computes a free resolution of an ideal or module with Schreyer's
method. The ideal, resp.@: module, has to be a standard basis.
More precisely, let M be given by a standard basis and
@tex
$A_1={\tt matrix}(M)$.
@end tex
A1=matrix(M).
Then @code{sres}
computes a free resolution of
coker(A1)=F0/M
@format
                    A2       A1
      ... ----> F2 ----> F1 ----> F0 --> F0/M --> 0.
@end format
@tex
$coker(A_1)=F_0/M$
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1 \buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow F_0/M\longrightarrow 0.$$
@end tex
If the int expression k is not zero then the computation stops after k steps
and returns a list of modules (given by standard bases)
@tex
$M_i={\tt module}(A_i)$, i=1..k.
@end tex
Mi=module(Ai), i=1..k.
@*@code{sres(M,0)}
returns a list of n modules where n is the number of variables of the basering.

Even if @code{sres} does not compute a minimal resolution, the @code{betti}
command gives the true betti numbers! In many cases of interest
@code{sres} is much faster than any other known method.
Let @code{list L=sres(M,0);} then @code{L[1]=M} is identical to the input,
@code{L[2]} is a standard basis with respect to the Schreyer ordering of
the first syzygy
module of @code{L[1]}, etc.
(L[i]=M_i
@tex
(${\tt L[i]}=M_i$
@end tex
 in the notations from above.)
@item @strong{Note:}
Accessing single elements of a resolution may require that some partial
computations have to be finished and may therefore take some time.
@item @strong{Example:}
@smallexample
@c reused example sres reference.doc:5645 
  ring r=31991,(t,x,y,z,w),ls;
  ideal M=t2x2+tx2y+x2yz,t2y2+ty2z+y2zw,
          t2z2+tz2w+xz2w,t2w2+txw2+xyw2;
  M=std(M);
  resolution L=sres(M,0);
  L;
@expansion{}  1      35      141      209      141      43      4      
@expansion{} r <--  r <--   r <--    r <--    r <--    r <--   r
@expansion{} 
@expansion{} 0      1       2        3        4        5       6      
@expansion{} resolution not minimized yet
@expansion{} 
  print(betti(L),"betti");
@expansion{}            0     1     2     3     4     5
@expansion{} ------------------------------------------
@expansion{}     0:     1     -     -     -     -     -
@expansion{}     1:     -     -     -     -     -     -
@expansion{}     2:     -     -     -     -     -     -
@expansion{}     3:     -     4     -     -     -     -
@expansion{}     4:     -     -     -     -     -     -
@expansion{}     5:     -     -     -     -     -     -
@expansion{}     6:     -     -     6     -     -     -
@expansion{}     7:     -     -     9    16     2     -
@expansion{}     8:     -     -     -     2     5     1
@expansion{} ------------------------------------------
@expansion{} total:     1     4    15    18     7     1
@c end example sres reference.doc:5645
@end smallexample
@end table
@c inserted refs from reference.doc:5656
@menu
See
* betti::
* hres::
* ideal::
* int::
* lres::
* minres::
* module::
* mres::
* res::
* syz::
@end menu
@c end inserted refs from reference.doc:5656
@c ---------------------------------------
@node status, std, sres, Functions
@subsection status
@cindex status
@cindex sleep
@cindex suspend
@table @code
@item @strong{Syntax:}
@code{status (} link_expression@code{,} string_expression @code{)}
@item @strong{Type:}
string
@item @strong{Syntax:}
@code{status (} link_expression@code{,} string_expression@code{,} string_expression @code{)}
@*@code{status (} link_expression@code{,} string_expression@code{,} string_expression@code{,} int_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
returns the status of the link as asked for by the second argument.  If
a third argument is given, the result of the comparison to the status
string is returned: @code{(status(l,s1)==s2)} is equivalent to
@code{status(l,s1,s2)}.  If a fourth integer argument (say, @code{i}) is
given and if @code{status(l,s1,s2)} yields @code{0}, then the execution
of the current process is suspended (the process is put to ``sleep'')
for approximately@: @code{i} microseconds, and afterwards the result of another
call to @code{status(l,s1,s2)} is returned. The latter is useful for
``polling'' the @code{read} status of MPtcp links such that busy
loops are avoided (see @ref{Parallelization with MPtcp links} for an
example).  Note that on some systems, the minimum time for a process to
be put to sleep is one second.
@*The following string expressions are allowed:
@table @code
@item @code{"name"}
the name string given by the definition of the link (usually the filename)
@item @code{"type"}
returns @code{"ASCII"}, @code{"MPfile"}, @code{"MPtcp"} or @code{"DBM"}
@item @code{"open"}
returns @code{"yes"} or @code{"no"}
@item @code{"openread"}
returns @code{"yes"} or @code{"no"}
@item @code{"openwrite"}
returns @code{"yes"} or @code{"no"}
@item @code{"read"}
returns @code{"ready"} or @code{"not ready"}
@item @code{"write"}
returns @code{"ready"} or @code{"not ready"}
@item @code{"mode"}
returns (depending on the type of the link and its status)
@code{"","w","a","r"} or @code{"rw"}
@end table
@item @strong{Example:}
@smallexample
@c reused example status reference.doc:5720 
  link l=":w example.txt";
  status(l,"write");
@expansion{} not ready
  open(l);
  status(l,"write","ready");
@expansion{} 1
  close(l);
@c end example status reference.doc:5720
@end smallexample
@end table
@c inserted refs from reference.doc:5729
@menu
See
* link::
* open::
* read::
* write::
@end menu
@c end inserted refs from reference.doc:5729
@c ---------------------------------------
@node std, stdfglm, status, Functions
@subsection std
@cindex std
@table @code
@item @strong{Syntax:}
@code{std (} ideal_expression@code{)}
@*@code{std (} module_expression@code{)}
@*@code{std (} ideal_expression@code{,} intvec_expression @code{)}
@*@code{std (} module_expression@code{,} intvec_expression @code{)}
@*@code{std (} ideal_expression@code{,} intvec_expression@code{,} intvec_expression @code{)}
@*@code{std (} module_expression@code{,} intvec_expression@code{,} intvec_expression @code{)}
@*@code{std (} ideal_expression@code{,} poly_expression @code{)}
@*@code{std (} module_expression@code{,} vector_expression @code{)}
@item @strong{Type:}
ideal or module
@item @strong{Purpose:}
returns a standard basis of an ideal or module with respect to the
monomial ordering of the basering.
A standard basis is a set of generators such that
the leading terms generate the leading ideal, resp.@: module.
@*Use an optional
second argument of type intvec as Hilbert series
(result of @code{hilb(i,1)}, see @ref{hilb}),
if the ideal, resp.@: module, is homogeneous
(Hilbert driven standard basis computation, @ref{stdhilb}).
If the ideal is quasihomogeneous with some weights w and if the Hilbert series
is computed w.r.t.@: to these weights, then use w as third argument.
@*Use an optional second argument of type poly, resp.@: vector,
to construct the standard basis from an already computed one (given as the
first argument) and one additional generator (the second argument).
@item @strong{Note:}
The
standard basis is computed with a (more or less) straight-forward
implementation of the classical
Buchberger (resp.@: Mora) algorithm. For global orderings, use the
@code{groebner} command instead (@pxref{groebner}), which heuristically
chooses the "best" algorithm to compute a Groebner basis.
@*To view the progress of long running computations, use
@code{option(prot)} (see @ref{option(prot)}).

@item @strong{Example:}
@smallexample
@c reused example std reference.doc:5779 
  // local computation
  ring r=32003,(x,y,z),ds;
  poly s1=1x2y+151xyz10+169y21;
  poly s2=1xz14+6x2y4+3z24;
  poly s3=5y10z10x+2y20z10+y10z20+11x3;
  ideal i=s1,s2,s3;
  ideal j=std(i);
  degree(j);
@expansion{} 0
  // Hilbert driven elimination (standard)
  ring rhom=32003,(x,y,z,h),dp;
  ideal i=homog(imap(r,i),h);
  ideal j=std(i);
  intvec iv=hilb(j,1);
  ring rlex=32003,(x,y,z,h),lp;
  ideal i=fetch(rhom,i);
  ideal j=std(i,iv);
  j=subst(j,h,1);
  j[1];
@expansion{} z64
  // Hilbert driven elimination (ideal is quasihomogeneous)
  intvec w=10,1,1;
  ring whom=32003,(x,y,z),wp(w);
  ideal i=fetch(r,i);
  ideal j=std(i);
  intvec iw=hilb(j,1,w);
  ring wlex=32003,(x,y,z),lp;
  ideal i=fetch(whom,i);
  ideal j=std(i,iw,w);
  j[1];
@expansion{} z64
@c end example std reference.doc:5779
@end smallexample
@end table
@c inserted refs from reference.doc:5811
@menu
See
* facstd::
* fglm::
* groebner::
* ideal::
* mstd::
* option::
* ring::
* stdfglm::
* stdhilb::
@end menu
@c end inserted refs from reference.doc:5811

@c ---------------------------------------
@node stdfglm, stdhilb, std, Functions
@subsection stdfglm
@cindex stdfglm
@c start include of docu for standard.lib:stdfglm
@c replaced @subsubsection by @sub
@c ---content stdfglm---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{stdfglm (} ideal_expression @code{)} @*
@code{stdfglm (} ideal_expression@code{,} string_expression @code{)}

@item @strong{Type:}
ideal

@item @strong{Purpose:}
computes the standard basis of the ideal in the basering
via @code{fglm} (from the ordering given as the second argument
to the ordering of the basering).@*
If no second argument is given, "dp" is used.

@cindex fglm
@end table
@strong{Example:}
@smallexample
@c reused example stdfglm d2t_singular/standard_lib.doc:52 
   ring r=0,(x,y,z),lp;
ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
ideal i1=stdfglm(i);         //uses fglm from "dp" to "lp"
i1;
@expansion{} i1[1]=z12
@expansion{} i1[2]=yz4-z8
@expansion{} i1[3]=y2+y-z8-z4
@expansion{} i1[4]=xy-xz4-y+z4
@expansion{} i1[5]=x2+y-z4
ideal i2=stdfglm(i,"Dp");    //uses fglm from "Dp" to "lp"
i2;
@expansion{} i2[1]=z12
@expansion{} i2[2]=yz4-z8
@expansion{} i2[3]=y2+y-z8-z4
@expansion{} i2[4]=xy-xz4-y+z4
@expansion{} i2[5]=x2+y-z4
@c end example stdfglm d2t_singular/standard_lib.doc:52
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:61
@menu
See also:
* fglm::
* groebner::
* std::
* stdhilb::
@end menu
@c end inserted refs from d2t_singular/standard_lib.doc:61

@c ---end content stdfglm---
@c generated lib proc docu for standard.lib:stdfglm reference.doc:5828 
@c end include of docu for standard.lib:stdfglm

@c ---------------------------------------
@node stdhilb, subst, stdfglm, Functions
@subsection stdhilb
@cindex stdhilb
@c start include of docu for standard.lib:stdhilb
@c replaced @subsubsection by @sub
@c ---content stdhilb---
Procedure from library @code{standard.lib} (@pxref{standard_lib}).

@table @asis
@item @strong{Syntax:}
@code{stdhilb (} ideal_expression @code{)} @*
@code{stdhilb (} ideal_expression@code{,} intvec_expression @code{)}

@item @strong{Type:}
ideal

@item @strong{Purpose:}
computes the standard basis of the homogeneous ideal in the basering,
via a Hilbert driven standard basis computation.@*
An optional second argument will be used as 1st Hilbert function.

@item @strong{Assume:}
The optional second argument is the first Hilbert series as computed
by @code{hilb}.

@cindex Hilbert function
@end table
@strong{Example:}
@smallexample
@c reused example stdhilb d2t_singular/standard_lib.doc:95 
   ring  r=0,(x,y,z),dp;
ideal i=y3+x2,x2y+x2,x3-x2,z4-x2-y;
ideal i1=stdhilb(i); i1;
@expansion{} i1[1]=y3+x2
@expansion{} i1[2]=x2y+x2
@expansion{} i1[3]=x3-x2
@expansion{} i1[4]=z4-x2-y
// the latter computation is equivalent to:
intvec v=hilb(i,1);
@expansion{} // ** i is no standardbasis
ideal i2=stdhilb(i,v); i2;
@expansion{} i2[1]=y3+x2
@expansion{} i2[2]=x2y+x2
@expansion{} i2[3]=x3-x2
@expansion{} i2[4]=z4-x2-y
@c end example stdhilb d2t_singular/standard_lib.doc:95
@end smallexample
@c inserted refs from d2t_singular/standard_lib.doc:104
@menu
See also:
* groebner::
* std::
* stdfglm::
@end menu
@c end inserted refs from d2t_singular/standard_lib.doc:104

@c ---end content stdhilb---
@c generated lib proc docu for standard.lib:stdhilb reference.doc:5834 
@c end include of docu for standard.lib:stdhilb

@c ---------------------------------------
@node subst, system, stdhilb, Functions
@subsection subst
@cindex subst
@table @code
@item @strong{Syntax:}
@code{subst (} poly_expression@code{,} ring_variable@code{,} poly_expression @code{)}
@*@code{subst (} vector_expression@code{,} ring_variable@code{,} poly_expression @code{)}
@*@code{subst (} ideal_expression@code{,} ring_variable@code{,} poly_expression @code{)}
@*@code{subst (} module_expression@code{,} ring_variable@code{,} poly_expression @code{)}
@item @strong{Type:}
poly, vector, ideal or module (corresponding to the first argument)
@item @strong{Purpose:}
substitutes a ring variable by a polynomial.
@item @strong{Example:}
@smallexample
@c reused example subst reference.doc:5852 
  ring r=0,(x,y,z),dp;
  poly f=x2+y2+z2+x+y+z;
  subst(f,x,3/2);
@expansion{} y2+z2+y+z+15/4
  int a=1;
  subst(f,y,a);
@expansion{} x2+z2+x+z+2
  subst(f,y,z);
@expansion{} x2+2z2+x+2z
  subst(f,y,z+1);
@expansion{} x2+2z2+x+4z+2
@c end example subst reference.doc:5852
@end smallexample
@end table
@c inserted refs from reference.doc:5863
@menu
See
* ideal::
* map::
* module::
* poly::
* vector::
@end menu
@c end inserted refs from reference.doc:5863
@c ---------------------------------------
@node  system, syz, subst, Functions
@subsection system
@cindex system
@table @code
@item @strong{Syntax:}
@code{system (} string_expression @code{)}
@*@code{system (} string_expression@code{,} expression @code{)}
@item @strong{Type:}
depends on the desired function, may be none
@item @strong{Purpose:}
interface to internal data and the operating system. The
string_expression determines the command to execute. Some commands
require an additional argument (second form) where the type of the
argument depends on the command. See below for a list of all possible
commands.
@item @strong{Note:}
Not all functions work on every platform.
@item @strong{Functions:}
@table @asis
@item @code{system("sh"}, string_expression @code{)}
@cindex sh
@cindex system, sh
shell escape, returns the return code of the shell as int. The string is
sent literally to the shell.
@item @code{system("pid")}
@cindex pid
@cindex system, pid
returns the process number as int (for creating unique names).
@item @code{system("uname")}
@cindex uname
@cindex system, uname
@cindex hardware platform
returns a string identifying the architecture for which @sc{Singular}
was compiled.
@item @code{system("getenv",} string_expression@code{)}
@cindex getenv
@cindex system, getenv
returns the value of the shell environment variable given as the second
argument. The return type is string.
@item @code{system("setenv",}string_expression, string_expression@code{)}
@cindex setenv
@cindex system, setenv
sets the shell environment variable given as the second argument to the
value given as the third argument. Returns the third argument. Might not
be available on all platforms.
@item @code{system("tty")}
@cindex tty
@cindex system, tty
resets the terminal.
@item @code{system("version")}
@cindex version
@cindex system, version
returns the version number of  @sc{Singular} as int.
@item @code{system("contributors")}
@cindex contributors
@cindex system, contributors
returns names of people who contributed to the @sc{Singular} kernel as string.
@item @code{system("gen")}
@c gen is reserved id: @cindex gen
@cindex system, gen
returns the generating element of the multiplicative
group of (Z/p)\@{0@} (as int) where p is the characteristic of the
basering.
@item @code{system("nblocks")}
@item @code{system("nblocks",} ring_name @code{)}
@cindex nblocks
@cindex system, nblocks
returns the number of blocks of the given ring, or the number of parameters
of the current basering, if no second argument is given. The return type
is int.
@item @code{system("Singular")}
@cindex Singular
@cindex system, Singular
returns the absolute (path) name of the running @sc{Singular} as string.
@item @code{system("}--@code{")}
@cindex system, --
@cindex command-line options, print all values of
prints the values of all options.
@item @code{system("}--long_option_name@code{")}
@cindex command-line option, value of
@cindex system, --long_option_name
returns the value of the (command-line) option long_option_name. The
type of the returned value is either string or int.
@xref{Command line options}, for more info.
@item @code{system("}--long_option_name@code{",} expression@code{)}
@cindex command-line option, setting value of
@cindex system, --long_option_name=value
@cindex random number generator, seed
@cindex browsers, setting the
@cindex browser, setting the
@cindex help browsers, setting the
@cindex timer resolution, setting the
@cindex minimal display time, setting the
sets the value of the (command-line) option long_option_name to the
value given by the expression. Type of the expression must be string, or
int.  @xref{Command line options}, for more info. Among others,
this can be used for setting the seed of the random number generator,
the used help browser, the minimal display time, or the timer
resolution.
@item @code{system("browsers");}
@cindex system, browsers
returns a string about available help browsers.
@xref{The online help system}.
@end table
@item @strong{Example:}
@smallexample
// a listing of the current directory:
system("sh","ls");
// execute a shell, return to SINGULAR with exit:
system("sh","sh");
string unique_name="/tmp/xx"+string(system("pid"));
unique_name;
@expansion{} /tmp/xx4711
system("uname")
@expansion{} ix86-Linux
system("getenv","PATH");
@expansion{} /bin:/usr/bin:/usr/local/bin
system("Singular");
@expansion{} /usr/local/bin/Singular
// report value of all options
system("--");
@expansion{} // --batch           0
@expansion{} // --execute
@expansion{} // --sdb             0
@expansion{} // --echo            0
@expansion{} // --help            0
@expansion{} // --quiet           0
@expansion{} // --random          937848971
@expansion{} // --no-tty          0
@expansion{} // --user-option
@expansion{} // --version         0
@expansion{} // --allow-net       0
@expansion{} // --browser
@expansion{} // --emacs           0
@expansion{} // --no-stdlib       0
@expansion{} // --no-rc           0
@expansion{} // --no-warn         0
@expansion{} // --no-out          0
@expansion{} // --min-time        "0.5"
@expansion{} // --mp-port
@expansion{} // --mp-host
@expansion{} // --ticks-per-sec   1
@expansion{} // --mp-transp
@expansion{} // --mp-mode
// set minimal display time to 0.02 seconds
system("--min-time", "0.02");
// set timer resolution to 0.01 seconds
system("--ticks-per-sec", 100);
// re-seed random number generator
system("--random", 12345678);
// allow netscape to access HTML pages from the net
system("--allow-net", 1);
// and set help browser to netscape
system("--browser", "netscape");
@end smallexample
@end table
@c -------------------------------------------------
@node syz, trace, system, Functions
@subsection syz
@cindex syz
@table @code
@item @strong{Syntax:}
@code{syz (} ideal_expression @code{)}
@*@code{syz (} module_expression @code{)}
@item @strong{Type:}
module
@item @strong{Purpose:}
computes the first syzygy (i.e., the module of relations of the given
generators) of the ideal, resp.@: module.
@item @strong{Example:}
@smallexample
@c reused example syz reference.doc:6043 
  ring R=0,(x,y),(c,dp);
  ideal i=x,y;
  syz(i);
@expansion{} _[1]=[y,-x]
@c end example syz reference.doc:6043
@end smallexample
@end table
@c inserted refs from reference.doc:6050
@menu
See
* hres::
* ideal::
* lres::
* module::
* mres::
* nres::
* res::
* sres::
@end menu
@c end inserted refs from reference.doc:6050
@c ---------------------------------------
@node trace, transpose, syz, Functions
@subsection trace
@cindex trace
@table @code
@item @strong{Syntax:}
@code{trace (} intmat_expression @code{)}
@*@code{trace (} matrix_expression @code{)}
@item @strong{Type:}
int, if the argument is an intmat, resp.@: @*
poly, if the argument is a matrix
@item @strong{Purpose:}
returns the trace of an intmat, resp.@: matrix.
@item @strong{Example:}
@smallexample
@c reused example trace reference.doc:6076 
  intmat m[2][2]=1,2,3,4;
  print(m);
@expansion{}      1     2
@expansion{}      3     4
  trace(m);
@expansion{} 5
@c end example trace reference.doc:6076
@end smallexample
@end table
@c inserted refs from reference.doc:6083
@menu
See
* intmat::
* matrix::
@end menu
@c end inserted refs from reference.doc:6083
@c ---------------------------------------
@node transpose, type, trace, Functions
@subsection transpose
@cindex transpose
@table @code
@item @strong{Syntax:}
@code{transpose (} intmat_expression @code{)}
@*@code{transpose (} matrix_expression @code{)}
@*@code{transpose (} module_expression @code{)}
@item @strong{Type:}
intmat, matrix, or module, corresponding to the argument
@item @strong{Purpose:}
transposes a matrix.
@item @strong{Example:}
@smallexample
@c reused example transpose reference.doc:6103 
  ring R=0,x,dp;
  matrix m[2][3]=1,2,3,4,5,6;
  print(m);
@expansion{} 1,2,3,
@expansion{} 4,5,6 
  print(transpose(m));
@expansion{} 1,4,
@expansion{} 2,5,
@expansion{} 3,6 
@c end example transpose reference.doc:6103
@end smallexample
@end table
@c inserted refs from reference.doc:6111
@menu
See
* intmat::
* matrix::
* module::
@end menu
@c end inserted refs from reference.doc:6111
@c ---------------------------------------
@node type, typeof, transpose, Functions
@subsection type
@cindex type
@table @code
@item @strong{Syntax:}
@code{type } name @code{;} @*
@code{type (} name @code{);}
@item @strong{Type:}
none
@item @strong{Purpose:}
prints the name, level, type and value of a variable. To display the
value of an expression, it is sufficient to type the expression followed
by @code{;}.
@item @strong{Example:}
@smallexample
@c reused example type reference.doc:6133 
  int i=3;
  i;
@expansion{} 3
  type(i);
@expansion{} // i                    [0]  int 3
@c end example type reference.doc:6133
@end smallexample
@end table
@c inserted refs from reference.doc:6140
@menu
See
* Data types::
* listvar::
* print::
@end menu
@c end inserted refs from reference.doc:6140
@c ---------------------------------------
@node typeof, uressolve, type, Functions
@subsection typeof
@cindex typeof
@table @code
@item @strong{Syntax:}
@code{typeof (} expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the type of an expression as string.

Returns the type of the first list element if the expression is an
expression list.

Possible types are:
@code{"ideal"},
@code{"int"},
@code{"intmat"},
@code{"intvec"},
@code{"list"},
@code{"map"},
@code{"matrix"},
@code{"module"},
@code{"number"},
@code{"none"},
@code{"poly"},
@code{"proc"},
@code{"qring"},
@code{"resolution"},
@code{"ring"},
@code{"string"},
@code{"vector"}.

For internal use only is the type
@c @code{"package"},
@code{"?unknown type?"}.
@item @strong{Example:}
@smallexample
@c reused example typeof reference.doc:6185 
  int i=9; i;
@expansion{} 9
  typeof(_);
@expansion{} int
  print(i);
@expansion{} 9
  typeof(_);
@expansion{} none
  type i;
@expansion{} // i                    [0]  int 9
  typeof(_);
@expansion{} string
  string s=typeof(i);
  s;
@expansion{} int
  typeof(s);
@expansion{} string
  proc p() @{  "hello"; return();@}
  p();
@expansion{} hello
  typeof(_);
@expansion{} none
@c end example typeof reference.doc:6185
@end smallexample
@end table
@c inserted refs from reference.doc:6201
@menu
See
* Data types::
* type::
@end menu
@c end inserted refs from reference.doc:6201
@c ---------------------------------------
@node uressolve, vandermonde, typeof, Functions
@subsection uressolve
@cindex uressolve
@table @code
@item @strong{Syntax:}
@code{uressolve (} ideal_expression@code{,} int_expression@code{,} int_expression@code{,} int_expression @code{)}
@item @strong{Type:}
list
@item @strong{Purpose:}
computes all complex roots of a zerodimensional ideal. @*
Makes either use of the multipolynomial resultant of Macaulay (second argument
= 1), which works only for homogeneous ideals, or uses the sparse resultant
of Gelfand, Kapranov and Zelevinsky (second argument = 0). @*
The sparse resultant algorithm uses a mixed polyhedral subdivision of the
Minkowsky sum of the Newton polytopes in order to construct the sparse
resultant matrix. Its determinant is a nonzero multiple of the sparse
resultant. The u-resultant of B.L.@: van der Waerden and Laguerre's algorithm
are used to determine the complex roots. @*
The third argument defines the precision of the fractional part if the ground
field is the field of rational numbers, otherwise it will be ignored. @*
The fourth argument (can be 0, 1 or 2) gives the number of extra runs of
Laguerre's algorithm (with corrupted roots), leading to better results.
@item @strong{Note:}
If the ground field is the field of complex numbers, the elements of the list
are of type number, otherwise of type string.
@item @strong{Example:}
@smallexample
@c reused example uressolve reference.doc:6234 
ring rsc=(real,20,I),(x,y),lp;
ideal i=(2+3*I)*x2+(0.35+I*45.0e-2)*y2-8,x2+xy+(42.7)*y2;
list l=uressolve(i,0,0,2);
l[1];
@expansion{} [1]:
@expansion{}    (-1.315392899374542198+I*0.70468233142752928117)
@expansion{} [2]:
@expansion{}    (0.12292646536251281054+I*0.19245727404407015049)
subst(subst(i[1],x,l[1][1]),y,l[1][2]);
@expansion{} 0
@c end example uressolve reference.doc:6234
@end smallexample
@end table
@c inserted refs from reference.doc:6243
@menu
See
* laguerre::
* mpresmat::
@end menu
@c end inserted refs from reference.doc:6243
@c ---------------------------------------
@node vandermonde, var, uressolve, Functions
@subsection vandermonde
@cindex vandermonde
@table @code
@item @strong{Syntax:}
@code{vandermonde (} ideal_expression@code{,} ideal_expression@code{,}
int_expression @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
@code{vandermonde(p,v,d)} computes the (unique) polynomial of degree
d with prescribed values v[1],...,v[N] at the points
p^0,...,p^(N-1), N=(d+1)^n, n the number of ring
variables.
@*The returned polynomial is sum_a c[a]*x1^a1*@dots{}*xn^an,
where the coefficients c[a] are the solution of the (transposed)
Vandermonde system of linear equations
@format
   sum_(|a|<=d) c_[a] * p[1]^(k*a1) *..* p[n]^(k*an) = v[k+1],
k=1,@dots{},N.
@end format
@tex
{\tt vandermonde(p,v,d)} computes the (unique) polynomial of degree
@code{d} with prescribed values {\tt v[1],...,v[N]} at the points
{\tt p}$^0,\dots,$ {\tt p}$^{N-1}$, {\tt N=(d+1)}$^n$, $n$ the
number of ring variables.

The returned polynomial is $\sum
c_{\alpha_1\ldots\alpha_n}\cdot x_1^{\alpha_1} \cdot \dots \cdot
x_n^{\alpha_n}$, where the coefficients
$c_{\alpha_1\ldots\alpha_n}$ are the solution of the (transposed)
Vandermonde system of linear equations
$$ \sum_{\alpha_1+\ldots+\alpha_n\leq d} c_{\alpha_1\ldots\alpha_n} \cdot
{\tt p}_1^{(k-1)\alpha_1}\cdot\dots\cdot {\tt p}_n^{(k-1)\alpha_n} =
{\tt v}[k], \quad  k=1,\dots,{\tt N}.$$
@end tex
@item @strong{Note:}
the ground field has to be the field of rational
numbers. Moreover, ncols(p)==n, the number of variables in the
basering, and all the given generators have to be numbers different from
0,1 or -1. Finally, ncols(v)==(d+1)^n, and all given generators have
to be numbers.
@tex
the ground field has to be the field of rational
numbers. Moreover, {\tt ncols(p)==}$n$, the number of variables in the
basering, and all the given generators have to be numbers different from
0,1 or -1. Finally, {\tt ncols(v)==(d+1)$^n$}, and all given generators have
to be numbers.
@end tex
@item @strong{Example:}
@smallexample
@c reused example vandermonde reference.doc:6304 
ring r=0,(x,y),dp;
// determine f with deg(f)=2 and with given values v of f
// at 9 points: (2,3)^0=(1,1),...,(2,3)^8=(2^8,3^8)
// valuation point: (2,3)
ideal p=2,3;
ideal v=1,2,3,4,5,6,7,8,9;
poly ip=vandermonde(p,v,2);
ip[1..5];  //  the 5 first terms of ip:
@expansion{} -1/9797760x2y2-595/85536x2y+55/396576xy2+935/384x2-1309/3240xy
// compute value of ip at the point 2^8,3^8, result must be 9
subst(subst(ip,x,2^8),y,3^8);
@expansion{} 9
@c end example vandermonde reference.doc:6304
@end smallexample
@end table
@c inserted refs from reference.doc:6318
@menu
See also:
@end menu
@c end inserted refs from reference.doc:6318
@c ---------------------------------------
@node var, varstr, vandermonde, Functions
@subsection var
@cindex var
@table @code
@item @strong{Syntax:}
@code{var (} int_expression @code{)}
@item @strong{Type:}
poly
@item @strong{Purpose:}
@code{var(n)} returns the n-th ring variable.
@item @strong{Example:}
@smallexample
@c reused example var reference.doc:6333 
  ring r=0,(x,y,z),dp;
  var(2);
@expansion{} y
@c end example var reference.doc:6333
@end smallexample
@end table
@c inserted refs from reference.doc:6339
@menu
See
* int::
* nvars::
* ring::
* varstr::
@end menu
@c end inserted refs from reference.doc:6339
@c ---------------------------------------
@node varstr, vdim, var, Functions
@subsection varstr
@cindex varstr
@table @code
@item @strong{Syntax:}
@code{varstr (} ring_name @code{)}
@*@code{varstr (} int_expression @code{)}
@*@code{varstr (} ring_name@code{,} int_expression @code{)}
@item @strong{Type:}
string
@item @strong{Purpose:}
returns the list of the names of the ring variables as a string
or the name of the n-th ring variable, where n is given by the
int_expression.
@*If the ring name is omitted, the basering is used, thus
@code{varstr(n)} is equivalent to @code{varstr(basering,n)}.
@item @strong{Example:}
@smallexample
@c reused example varstr reference.doc:6365 
  ring r=0,(x,y,z),dp;
  varstr(r);
@expansion{} x,y,z
  varstr(r,1);
@expansion{} x
  varstr(2);
@expansion{} y
@c end example varstr reference.doc:6365
@end smallexample
@end table
@c inserted refs from reference.doc:6373
@menu
See
* charstr::
* int::
* nvars::
* ordstr::
* parstr::
* ring::
* var::
@end menu
@c end inserted refs from reference.doc:6373
@c ---------------------------------------
@node vdim, wedge, varstr, Functions
@subsection vdim
@cindex vdim
@table @code
@item @strong{Syntax:}
@code{vdim (} ideal_expression @code{)}
@*@code{vdim (} module_expression @code{)}
@item @strong{Type:}
int
@item @strong{Purpose:}
computes the vector space dimension of the ring, resp.@: free module,
modulo the ideal, resp.@: module,
generated by the initial terms of the given generators.
If the generators form a standard basis,
this is the same as the vector space dimension of the ring, resp.@:
free module, modulo the ideal, resp.@: module.
@*If the ideal, resp.@: module, is not zero-dimensional, -1 is returned.
@item @strong{Example:}
@smallexample
@c reused example vdim reference.doc:6403 
  ring r=0,(x,y),ds;
  ideal i=x2+y2,x2-y2;
  ideal j=std(i);
  vdim(j);
@expansion{} 4
@c end example vdim reference.doc:6403
@end smallexample
@end table
@c inserted refs from reference.doc:6411
@menu
See
* degree::
* dim::
* ideal::
* kbase::
* mult::
* std::
@end menu
@c end inserted refs from reference.doc:6411
@c ---------------------------------------
@node wedge, weight, vdim, Functions
@subsection wedge
@cindex wedge
@table @code
@item @strong{Syntax:}
@code{wedge (} matrix_expression@code{,} int_expression @code{)}
@item @strong{Type:}
matrix
@item @strong{Purpose:}
@code{wedge(M,n)} computes the @code{n}-th exterior power of the matrix
@code{M}.
@item @strong{Example:}
@smallexample
@c reused example wedge reference.doc:6434 
  ring r;
  matrix m[2][3]=x,y,y,z,z,x;
  print(m);
@expansion{} x,y,y,
@expansion{} z,z,x 
  print(wedge(m,2));
@expansion{} xz-yz,-x2+yz,xy-yz
@c end example wedge reference.doc:6434
@end smallexample
@end table
@c inserted refs from reference.doc:6442
@menu
See
* int::
* matrix::
* minor::
@end menu
@c end inserted refs from reference.doc:6442
@c ---------------------------------------
@node weight, write, wedge, Functions
@subsection weight
@cindex weight
@table @code
@item @strong{Syntax:}
@code{weight (} ideal_expression @code{)}
@*@code{weight (} module_expression @code{)}
@item @strong{Type:}
intvec
@item @strong{Purpose:}
computes an "optimal" weight vector for an ideal, resp.@: module,
which may be used as weight vector for the variables in order to speed
up the standard basis algorithm. If the input is weighted homogeneous,
a weight vector for which the input is weighted homogeneous is found.
@item @strong{Example:}
@smallexample
@c reused example weight reference.doc:6465 
  ring h1=32003,(t,x,y,z),dp;
  ideal i=
  9x8+y7t3z4+5x4y2t2+2xy2z3t2,
  9y8+7xy6t+2x5y4t2+2x2yz3t2,
  9z8+3x2y3z2t4;
  intvec e=weight(i);
  e;
@expansion{} 5,7,5,7
  ring r=32003,(a,b,c,d),wp(e);
  map f=h1,a,b,c,d;
  ideal i0=std(f(i));
@c end example weight reference.doc:6465
@end smallexample
@end table
@c inserted refs from reference.doc:6479
@menu
See
* ideal::
* intvec::
* qhweight::
@end menu
@c end inserted refs from reference.doc:6479
@c ---------------------------------------
@node  write,  , weight, Functions
@subsection write
@cindex write
@table @code
@item @strong{Syntax:}
@code{write (} link_expression@code{,} expression_list @code{)}
@*for DBM links:
@*@code{write (} link@code{,} string_expression@code{,} string_expression @code{)}
@*@code{write (} link@code{,} string_expression @code{)}
@item @strong{Type:}
none
@item @strong{Purpose:}
writes data to a link.
@*If the link is of type @code{ASCII}, all expressions are converted to
strings  (and separated by a newline character) before they are
written. As a consequence, only such values which can be converted to a
string can be written to an  @code{ASCII} link.
@*For MP links,
ring-dependent expressions are written together with a ring
description. To prevent an evaluation of the expression before it is
written, the @code{quote} command (possibly together with @code{eval})
can be used. A @code{write} blocks (i.e., does not return to the prompt),
as long as a MPtcp link is not ready for writing.
@*For DBM links, @code{write} with three arguments inserts the first
string as key and the second string as value into the dbm data
base.
@*Called with two arguments, it deletes the entry with the key
specified by the string from the data base.
@item @strong{Example:}
@smallexample
// write the values of the variables f and i as strings into
// the file "outfile" (overwrite it, if it exists)
write(":w outfile",f,i);

// now append the string "that was f,i" (without the quotes)
// at the end of the file "outfile"
write(":a outfile","that was f,i");
// alternatively, links could be used:
link l=":a outfile"; l;
// type : ASCII
// mode : a
// name : outfile
// open : no
// read : not ready
// write: not ready
write(l," that was f,i");
// saving and retrieving data (ASCII format):
ring r=32003,(x,y,z),dp;
ideal i=x+y,z3+22y;
write(":w save_i",i);// this writes x+y,z3+22y to the file save_i
ring r=32003,(x,y,z),dp;
string s=read("save_i");   //creates the string x+y,z3+22y
execute("ideal k="+s+";"); // this defines an ideal k which
                           // is equal to i.
// for large objects, the MP format and MPfile links are better:
write("MPfile:w save_i.mp",i);
def j=read("MPfile:r save_i.mp");
@end smallexample
@end table
@c inserted refs from reference.doc:6545
@menu
See
* Data types::
* dump::
* eval::
* link::
* print::
* printf::
* quote::
* read::
* short::
@end menu
@c end inserted refs from reference.doc:6545


@c ---------------------------------------
@node Control structures, System variables, Functions, Functions and system variables
@section Control structures
@cindex Control structures
@cindex block
@*List of all supported control structures.
@menu
* break::
* breakpoint::
* continue::
* else::
* export::
* for::
* if::
* keepring::
* quit::
* return::
* while::
* ~::
@end menu

A sequence of commands surrounded by curly brackets (@code{@{} and
@code{@}}) is a so called block. Blocks are used in @sc{Singular} in
order to define procedures and to collect commands belonging to
@code{if}, @code{else}, @code{for} and @code{while} statements and to the
@code{example} part in libraries. Even if
the sequence of statements consists of only a single command it has to be
surrounded by curly brackets!
Variables which are defined inside a block
are not local to that block. Note that there is no ending semicolon at
the end of the block.
@table @code
@item @strong{Example:}
@smallexample
if ( i>j )
@{
  // This is the block
  int temp;
  temp=i;
  i=j;
  j=temp;
  kill temp;
@}
@end smallexample
@end table

@c ---------------------------------------
@node break, breakpoint, Control structures, Control structures
@subsection break
@cindex break
@table @code
@item @strong{Syntax:}
@code{break;}
@item @strong{Purpose:}
leaves the innermost @code{for} or @code{while} block.
@item @strong{Example:}
@smallexample
while (1)
@{
  @dots{}
  if ( @dots{} )
  @{
    break; // leave the while block
  @}
@}
@end smallexample
@end table
@c inserted refs from reference.doc:6634
@menu
See
* Control structures::
* for::
* while::
@end menu
@c end inserted refs from reference.doc:6634
@c ---------------------------------------
@node breakpoint, continue, break, Control structures
@subsection breakpoint
@cindex breakpoint
@table @code
@item @strong{Syntax:}
@code{breakpoint(} proc_name @code{);}
@*@code{breakpoint(} proc_name@code{,} line_no @code{);}
@item @strong{Purpose:}
sets a breakpoint at the beginning of the specified procedure or
at the given line.
@strong{Note:} Line number 1 is the first line of a library (for
procedures from libraries), resp.@: the line with the @code{@{}.
@*A line number of -1 removes all breakpoint from that procedure.
@item @strong{Example:}
@smallexample
@c reused example breakpoint reference.doc:6656 
breakpoint(groebner);
@expansion{} breakpoint 1, at line 163 in groebner
breakpoint(groebner, 176);
@expansion{} breakpoint 2, at line 176 in groebner
breakpoint(groebner, -1);
@expansion{} breakpoints in groebner deleted(0x6)
@c end example breakpoint reference.doc:6656
@end smallexample
@end table
@c inserted refs from reference.doc:6663
@menu
See
* Source code debugger::
* ~::
@end menu
@c end inserted refs from reference.doc:6663
@c ---------------------------------------
@node continue, else, breakpoint, Control structures
@subsection continue
@cindex continue
@table @code
@item @strong{Syntax:}
@code{continue;}
@item @strong{Purpose:}
skips the rest of the innermost @code{for} or @code{while} loop und jumps
to the beginning of the block. This command is only valid inside a
@code{for} or a @code{while} construction.
@item @strong{Note:}
Unlike the C-construct it @strong{does not execute the increment statement}.
The command @code{continue} is mainly for internal use.
@item @strong{Example:}
@smallexample
for (int i = 1 ; i<=10; i=i+1)
@{
   @dots{}
   if (i==3) @{ i=8;continue; @}
     // skip the rest if i is 3 and
     // continue with the next i: 8
   i;
@}
@expansion{} 1
@expansion{} 2
@expansion{} 8
@expansion{} 9
@expansion{} 10
@end smallexample
@end table
@c inserted refs from reference.doc:6699
@menu
See
* Control structures::
* for::
* while::
@end menu
@c end inserted refs from reference.doc:6699
@c ---------------------------------------
@node else, export, continue, Control structures
@subsection else
@table @code
@item @strong{Syntax:}
@code{if (} boolean_expression @code{)} true_block @code{else} false_block
@item @strong{Purpose:}
executes false_block if the boolean_expression of the @code{if} statement
is false. This command is only valid in combination with an @code{if}
command.
@item @strong{Example:}
@smallexample
int i=3;
if (i > 5)
@{
  "i is bigger than 5";
@}
else
@{
  "i is smaller than 6";
@}
@expansion{} i is smaller than 6
@end smallexample
@end table
@c inserted refs from reference.doc:6729
@menu
See
* Control structures::
* boolean expressions::
* if::
@end menu
@c end inserted refs from reference.doc:6729
@c ---------------------------------------
@node export, for, else, Control structures
@subsection export
@cindex export
@table @code
@item @strong{Syntax:}
@code{export} name @code{;}
@*@code{export} list_of_names @code{;}
@item @strong{Purpose:}
converts a local variable of a procedure to a global one.
@item @strong{Note:}
Objects defined in a ring are not automatically exported
when exporting the ring (use @code{keepring} instead).
@item @strong{Example:}
@smallexample
proc p1
@{
  int i,j;
  export(i);
  intmat m;
  listvar();
  export(m);
@}
p1();
@expansion{} // m                    [1]  intmat 1 x 1
@expansion{} // j                    [1]  int 0
@expansion{} // i                    [0]  int 0
listvar();
@expansion{} // m                    [0]  intmat 1 x 1
@expansion{} // i                    [0]  int 0
@end smallexample
@end table

@c inserted refs from reference.doc:6780
@menu
See
* keepring::
@end menu
@c end inserted refs from reference.doc:6780
@c ---------------------------------------
@c ---------------------------------------
@node for, if, export, Control structures
@subsection for
@cindex for
@table @code
@item @strong{Syntax:}
@code{for (} init_command@code{;}
boolean_expression@code{;}
iterate_commands@code{)} block
@item @strong{Purpose:}
repetitive, conditional execution of a command block.
@*The command init_command is executed first. Then boolean_expression is
evaluated. If its value is TRUE the block is executed, otherwise the
@code{for} statement is complete. After each execution of the block, the
command iterate_command is executed and boolean_expression is
evaluated. This is repeated until boolean_expression evaluates to FALSE.
@*The command @code{break;} leaves the innermost @code{for} construct.
@item @strong{Example:}
@smallexample
// sum of 1 to 10:
int s=0;
for (int i=1; i<=10; i=i+1)
@{
   s=s+i;
@}
s;
@expansion{} 55
@end smallexample
@end table
@c inserted refs from reference.doc:7004
@menu
See
* Control structures::
* boolean expressions::
* break::
* continue::
* if::
* while::
@end menu
@c end inserted refs from reference.doc:7004
@c ---------------------------------------
@node if, keepring, for, Control structures
@subsection if
@cindex if
@cindex else
@table @code
@item @strong{Syntax:}
@code{if (} boolean_expression @code{)} true_block
@*@code{if (} boolean_expression @code{)} true_block @code{else} false_block
@item @strong{Purpose:}
executes true_block if the boolean condition is true. If the @code{if}
statement is followed by an @code{else} statement and the boolean
condition is false, then false_block is executed.
@item @strong{Example:}
@smallexample
int i = 9;
matrix m[i][i];
if (i > 5 and typeof(m) == "matrix")
@{
  m[i][i] = i;
@}
@end smallexample
@end table
@c inserted refs from reference.doc:7036
@menu
See
* Control structures::
* boolean expressions::
* break::
* else::
@end menu
@c end inserted refs from reference.doc:7036
@c ---------------------------------------
@node keepring, quit, if, Control structures
@subsection keepring
@cindex keepring
@table @code
@item @strong{Syntax:}
@code{keepring} name @code{;}
@item @strong{Purpose:}
moves the specified ring to the next (upper) level. This command can only
be used inside of procedures and it should be the last command before the
@code{return} statement. There it provides the possibility to keep
a ring which is local to the procedure (and its objects) accessible after
the procedure ended without making the ring global.
@item @strong{Example:}
@smallexample
proc P1
@{
  ring r=0,x,dp;
  keepring r;
@}
proc P2
@{
  "inside P2: " + nameof(basering);
  P1();
  "inside P2, after call of P1: " + nameof(basering);
@}
ring r1= 0,y,dp;
P2();
@expansion{} inside P2: r1
@expansion{} inside P2, after call of P1: r
"at top level: " + nameof(basering);
@expansion{} at top level: r1
@end smallexample
@end table
@c inserted refs from reference.doc:7077
@menu
See
* ring::
@end menu
@c end inserted refs from reference.doc:7077
@c ---------------------------------------
@node quit, return, keepring, Control structures
@subsection quit
@cindex quit
@cindex exit
@table @code
@item @strong{Syntax:}
@code{quit;}
@item @strong{Purpose:}
quits @sc{Singular};
works also from inside a procedure. The commands @code{quit} and
@code{exit} are synonymous.
@item @strong{Example:}
@smallexample
  quit;
@end smallexample
@end table
@c ---------------------------------------
@node return, while, quit, Control structures
@subsection return
@cindex return
@table @code
@item @strong{Syntax:}
@code{return (} expression_list @code{);}
@*@code{return ();}
@item @strong{Type:}
any
@item @strong{Purpose:}
returns the result(s) of a procedure and can only be used inside a
procedure. Note that the brackets are required even if no return value
is given.
@item @strong{Example:}
@smallexample
proc p2
@{
  int i,j;
  for(i=1;i<=10;i++)
  @{
    j=j+i;
  @}
  return(j);
@}
// can also return an expression list, i.e., more than one value
proc tworeturn ()
@{ return (1,2); @}
int i,j = tworeturn();
// return type may even depend on the input
proc type_return (int i)
@{
  if (i > 0) @{return (i);@}
  else @{return (list(i));@}
@}
// then we need def type (or list) to collect value
def t1 = type_return(1);
def t2 = type_return(-1);
@end smallexample
@end table
@c inserted refs from reference.doc:7138
@menu
See
* Data types::
* proc::
@end menu
@c end inserted refs from reference.doc:7138
@c ---------------------------------------
@node while, ~ , return, Control structures
@subsection while
@cindex while
@table @code
@item @strong{Syntax:}
@code{while (}boolean_expression@code{)} block
@item @strong{Purpose:}
repetitive, conditional execution of block.
@*The boolean_expression is evaluated and if its value is TRUE, the
block gets executed. This is repeated until boolean_expression evaluates
to FALSE.  The command @code{break} leaves the innermost @code{while}
construction.
@item @strong{Example:}
@smallexample
int i = 9;
while (i>0)
@{
   // @dots{} // do something for i=9, 8, ..., 1
   i = i - 1;
@}
while (1)
@{
   // @dots{}   // do something forever
   if (i == -5) // but leave the loop if i is -5
   @{
     break;
   @}
@}
@end smallexample
@end table
@c inserted refs from reference.doc:7174
@menu
See
* Control structures::
* boolean expressions::
* break::
@end menu
@c end inserted refs from reference.doc:7174

@c ---------------------------------------
@node ~, , while, Control structures
@subsection ~ (break point)
@cindex ~
@cindex break point
@table @code
@item @strong{Syntax:}
@code{~;}
@item @strong{Purpose:}
sets a break point. Whenever @sc{Singular} reaches the command @code{~;}
in a sequence of commands it prompts for input. The user may now input
lines of @sc{Singular} commands. The line length cannot exceed 80
characters.
@sc{Singular} proceeds with the execution of the command following @code{~;}
as soon as it receives an empty line.
@item @strong{Example:}
@smallexample
proc t
@{
  int i=2;
  ~;
  return(i+1);
@}
t();
@expansion{} -- break point in t --
@expansion{} -- 0: called    from STDIN --
// here local variables of the procedure can be accessed
i;
@expansion{} 2
@expansion{} -- break point in t --

@expansion{} 3
@end smallexample
@end table
@c inserted refs from reference.doc:7215
@menu
See
* Break points::
@end menu
@c end inserted refs from reference.doc:7215

@c ---------------------------------------
@node System variables,  , Control structures, Functions and system variables
@section System variables
@cindex System variables
@*List of all system variables.
@menu
* degBound::
* echo::
* minpoly::
* multBound::
* noether::
* printlevel::
* short::
* timer::
* TRACE var::
* rtimer::
* voice::
@end menu
@c ---------------------------------------
@c @node alternating, degBound, System variables, System variables
@c @subsection alternating
@c @cindex alternating
@c @table @code
@c @item @strong{Syntax:}
@c @code{alternating =} int_expression@code{;}
@c @*int_variable @code{= alternating;}
@c @item @strong{Purpose:}
@c describes the position of the first alternating variable in the current
@c basering, thus creating the tensor
@c product of a polynomial ring with an exterior algebra.
@c @*Remark: Setting @code{alternating=1;} defines the exterior algebra.
@c @item @strong{Note:}
@c These algebras are only available in those versions of
@c @sc{Singular} which are compiled with the SRING option.
@c The SRING version is
@c significantly slower for usual (commutative) ring operations.
@c @item @strong{Example:}
@c @example
@c   // define the exterior algebra in 3 variables x, y, z
@c   ring r=0,(x,y,z),dp;
@c   alternating=1;
@c   y*x;
@c   @expansion{} -1*xy
@c @end example
@c @end table
@c @c ref
@c See
@c @ref{ring};
@c @ref{int expressions}.
@c @c ref
@c @c -----------------------------------------------------
@node degBound, echo, System variables, System variables
@subsection degBound
@cindex degBound
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
The standard basis computation is stopped if the total
(weighted) degree
exceeds @code{degBound}.
@* @code{degBound} should not be used for a global ordering with inhomogeneous
input.
@*Reset this bound by setting @code{degBound} to 0.
@item @strong{Example:}
@smallexample
degBound = 7;
option();
@expansion{} //options for 'std'-command: degBound
ideal j=std(i);
degBound;
@expansion{} 7
degBound = 0; //resets degree bound to infinity
@end smallexample
@end table
@c inserted refs from reference.doc:7297
@menu
See
* deg::
* int::
* option::
* std::
@end menu
@c end inserted refs from reference.doc:7297
@c -----------------------------------------------------
@node echo, minpoly, degBound, System variables
@subsection echo
@cindex echo
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
input is echoed if @code{echo} >= @code{voice}.
@*@code{echo} is a local setting for a procedure and defaulted to 0.
@*@code{echo} does not affect the output of commands.
@item @strong{Example:}
@c this example cannot be a computed one - echo interferes with -e
@smallexample
echo = 1;
int i = echo;
@expansion{} int i = echo;
@end smallexample
@end table
@c inserted refs from reference.doc:7323
@menu
See
* int::
* voice::
@end menu
@c end inserted refs from reference.doc:7323
@c -----------------------------------------------------
@node minpoly, multBound, echo, System variables
@subsection minpoly
@cindex minpoly
@table @code
@item @strong{Type:}
number
@item @strong{Purpose:}
describes the coefficient field of the current basering as
an algebraic extension with the minimal polynomial equal to @code{minpoly}.
Setting the @code{minpoly} should be the first command after
defining the ring.
@item @strong{Note:}
The minimal polynomial has to be specified in the syntax of a polynomial.
Its variable is not one of the ring variables, but the algebraic element
which is being adjoined to the field.
Algebraic extensions in @sc{singular} are only possible over the rational
numbers or over Z/p, p a prime number.
@c @*@strong{Warning:}
@*@sc{Singular} does not check whether the given
polynomial is irreducible! It can be checked in advance with the
function @code{factorize} (@pxref{factorize}).
@item @strong{Example:}
@smallexample
@c reused example minpoly reference.doc:7352 
  //(Q[i]/(i^2+1))[x,y,z]:
  ring Cxyz=(0,i),(x,y,z),dp;
  minpoly=i^2+1;
  i2;  //this is a number, not a poly
@expansion{} -1
@c end example minpoly reference.doc:7352
@end smallexample
@end table
@c inserted refs from reference.doc:7360
@menu
See
* factorize::
* ring::
@end menu
@c end inserted refs from reference.doc:7360
@c -----------------------------------------------------
@node multBound, noether, minpoly, System variables
@subsection multBound
@cindex multBound
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
The standard basis computation is stopped if the ideal is
zero-dimensional in a ring with local ordering
and its multiplicity (@code{mult}) is lower than @code{multBound}.
@*Reset this bound by setting @code{multBound} to 0.
@item @strong{Example:}
@smallexample
multBound = 20;
option();
@expansion{}    //options for 'std'-command: multBound
ideal j=std(i);
multBound;
@expansion{} 20
multBound = 0;  //disables multBound
@end smallexample
@end table
@c inserted refs from reference.doc:7388
@menu
See
* int::
* mult::
* option::
* std::
@end menu
@c end inserted refs from reference.doc:7388
@c -----------------------------------------------------
@node noether, printlevel, multBound, System variables
@subsection noether
@cindex noether
@table @code
@item @strong{Type:}
poly
@item @strong{Purpose:}
The standard basis computation in local rings
cuts off  all monomials above
(in the sense of the monomial ordering)
the monomial @code{noether} during the computation.
@*Reset @code{noether} by setting @code{noether} to 0.
@item @strong{Example:}
@smallexample
@c reused example noether reference.doc:7410 
  ring R=32003,(x,y,z),ds;
  ideal i=x2+y12,y13;
  std(i);
@expansion{} _[1]=x2+y12
@expansion{} _[2]=y13
  noether=x11;
  std(i);
@expansion{} _[1]=x2
  noether=0; //disables noether
@c end example noether reference.doc:7410
@end smallexample
@end table
@c inserted refs from reference.doc:7420
@menu
See
* poly::
* std::
@end menu
@c end inserted refs from reference.doc:7420
@c -----------------------------------------------------
@node printlevel, short, noether, System variables
@subsection printlevel
@cindex printlevel
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
sets the debug level for @code{dbprint}.
If @code{printlevel} >= @code{voice} then @code{dbprint} is equivalent to
@code{print}, otherwise nothing is printed.
@item @strong{Note:}
@xref{Procedures in a library}, for a small example about how this
is used for the display of comments while procedures are executed.
@item @strong{Example:}
@smallexample
@c reused example printlevel reference.doc:7441 
  voice;
@expansion{} 1
  printlevel=0;
  dbprint(1);
  printlevel=voice;
  dbprint(1);
@expansion{} 1
@c end example printlevel reference.doc:7441
@end smallexample
@end table
@c inserted refs from reference.doc:7450
@menu
See
* dbprint::
* int::
* voice::
@end menu
@c end inserted refs from reference.doc:7450
@c -----------------------------------------------------
@node short, timer, printlevel, System variables
@subsection short
@cindex short
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
the output of monomials is done in the short manner,
if @code{short} is non-zero. A C-like notion is used, if short is zero.
Both notations may be used as input.
@*The default depends on the names of the ring variables
(0 if there are names of variables longer than 1 character, 1 otherwise). Every
change of the basering sets @code{short} to the previous value for
that ring. In other words, the value of the variable @code{short} is
"ring-local".
@item @strong{Example:}
@smallexample
@c reused example short reference.doc:7474 
  ring r=23,x,dp;
  int save=short;
  short=1;
  2x2,x2;
@expansion{} 2x2 x2
  short=0;
  2x2,x2;
@expansion{} 2*x^2 x^2
  short=save;  //resets short to the previous value
@c end example short reference.doc:7474
@end smallexample
@end table
@c inserted refs from reference.doc:7485
@menu
See
* int::
@end menu
@c end inserted refs from reference.doc:7485
@c -----------------------------------------------------
@node timer, TRACE var, short, System variables
@subsection timer
@cindex timer
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
@enumerate
@item
the CPU time (i.e, user and system time) used for each command is
printed if timer >0 , if this
time is bigger than a (customizable) minimal time and
if @code{printlevel+1 >= voice} (which is by default true on the
@sc{Singular} top level, but not true while procedures are executed).

@item
yields the used CPU time since the start-up of @sc{Singular} in a
(customizable) resolution.
@end enumerate

The default setting of @code{timer} is 0, the default minimal time is
0.5 seconds, and the default timer resolution is 1 (i.e., the default unit
of time is one second). The minimal time and timer resolution
can be set using the command line options @code{--min-time} and
@code{--ticks-per-sec} and can be checked using
@code{system("--min-time")} and @code{system("--ticks-per-sec")}.

How to use @code{timer} in order to measure the time for a sequence of
commands, see example below.

@item @strong{Note for Windows95/98:}
The value of the @code{timer} cannot be used (resp.@: trusted) when
@sc{Singular} is run under Windows95/98 (this is due to the shortcomings
of the Windows95/98 operating system). Use @ref{rtimer}, instead.

@item @strong{Example:}
@smallexample
@c reused example timer reference.doc:7527 
  timer=1; // The time of each command is printed
  int t=timer; // initialize t by timer
  ring r=0,(x,y,z),dp;
  poly p=(x+2y+3z+4xy+5xz+6yz)^20;
  // timer as int_expression:
  t=timer-t;
  t;  // yields the time in ticks-per-sec (default 1)
@expansion{} 0
      // since t was initialized by timer
  int tps=system("--ticks-per-sec");
  t/tps; // yields the time in seconds truncated to int
@expansion{} 0
@c end example timer reference.doc:7527
@end smallexample
@end table
@c inserted refs from reference.doc:7541
@menu
See
* Command line options::
* printlevel::
* rtimer::
* system::
* voice::
@end menu
@c end inserted refs from reference.doc:7541
@c ---------------------------------------
@node TRACE var, rtimer, timer, System variables
@subsection TRACE
@cindex TRACE

@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
sets level of debugging.
@table @asis
@item @code{TRACE=0}
no debugging messages are printed.
@item @code{TRACE=1}
messages about entering and leaving of procedures are displayed.
@item @code{TRACE=3}
messages about entering and leaving of procedures together with
line numbers are displayed.
@item @code{TRACE=4}
each line is echoed and the interpretation of commands
in this line is suspended until the user presses @code{RETURN}.
@end table
@*@code{TRACE} is defaulted to 0.
@*@code{TRACE} does not affect the output of commands.
@item @strong{Example:}
@smallexample
@c reused example TRACE reference.doc:7575 
  TRACE=1;
  LIB "general.lib";
  sum(1..100);
@expansion{} entering sum (level 0)
@expansion{} leaving  sum (level 0)
@expansion{} 5050
@c end example TRACE reference.doc:7575
@end smallexample
@end table
@c inserted refs from reference.doc:7582
@menu
See
* int::
@end menu
@c end inserted refs from reference.doc:7582
@c ---------------------------------------
@node rtimer, voice, TRACE var, System variables
@subsection rtimer
@cindex timer
@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
identical to @code{timer} (@pxref{timer}), except that real times (i.e.,
wall-clock) times are reported, instead of CPU times. This can be
trusted on all operating systems (including Windows95/98).

@end table
@c ---------------------------------------
@node voice,, rtimer, System variables
@subsection voice
@cindex voice

@table @code
@item @strong{Type:}
int
@item @strong{Purpose:}
shows the nesting level of procedures.
@item @strong{Note:}
@xref{Guidelines for writing a library}, for an small example how this is used
for the display of comments while procedures are executed.
@item @strong{Example:}
@smallexample
@c reused example voice reference.doc:7614 
  voice;
@expansion{} 1
@c end example voice reference.doc:7614
proc p
@{
  voice;
@};
p();
@expansion{} 2
@end smallexample
@end table
@c inserted refs from reference.doc:7625
@menu
See
* dbprint::
* listvar::
* printlevel::
@end menu
@c end inserted refs from reference.doc:7625
@c ---------------------------------------

@c ----------------------------------------------------------------------------
@node Tricks and pitfalls, Examples, Functions and system variables, Top
@chapter Tricks and pitfalls
@cindex Tricks and pitfalls
@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from tricks.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT tricks.doc INSTEAD
@comment Id: tricks.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the "Tricks and pittfals" sections

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').

@menu
* Limitations::
* Major differences to the C programming language::
* Miscellaneous oddities::
* Identifier resolution::
@end menu

@c -------------------------------------------------------------------------
@node Limitations,Major differences to the C programming language,,Tricks and pitfalls
@section Limitations
@cindex Limitations

@sc{Singular} has the following limitations:
@itemize @bullet
@item
the characteristic of a prime field must be less than 2147483629 
@item
the (weighted) degree of a monomial must be smaller than the largest @code{long},
usually 2147483648
@item
the exponent of a ring variable must be smaller than 32768
unless the ring ordering start with the pseudo ordering 
@code{L(} max_exponent @code{)}
@item
the rank of any free module must be smaller than the largest @code{long},
usually 2147483648
@item
the number of parameters must be smaller than 32768
@item
the number of ring variables must be smaller than 32768
@item
the precision of long floating point numbers (for ground field @code{real})
must be smaller than 32768
@item
integers (of type @code{int}) have the limited range
from -2147483647 to 2147483647
@item
floating point numbers (type @code{number} from field @code{real}) have
a limited range which is machine dependent. A typical range is -1.0e-38
to 1.0e+38.  The string representation of overflow and underflow is
machine dependent, as well. For example "@code{Inf}" on Linux, or 
"@code{+.+00e+00}" on HPUX.
@c @item
@c a token (in the input) must have 16383 characters or less.
@c @*(Tokens are strings, blocks of statements, numbers)
@c @*This does not apply to proc in libraries but to blocks
@c within a procedure
@item
the length of an identifier is unlimited but @code{listvar}
displays only the first 20 characters
@c @item
@c the interpretation of text between a closing @code{@}} and the end of
@c the line is undefined. (Therefore do not put anything but spaces between
@c @code{@}} and the end of the line.)
@item
statements may not contain more than 10000 tokens
@item
@cindex German Umlaute
@cindex non-english special characters
@cindex special characters, non-english
All input to Singular must be 7-bit clean, i.e. special characters like the
the German Umlaute (@"a, @"o, etc.), or the French accent characters may 
neither appear as input to @sc{Singular}, nor in libraries or procedure
definitions.
@end itemize

@c -------------------------------------------------------------------------
@node Major differences to the C programming language,Miscellaneous oddities,Limitations,Tricks and pitfalls
@section Major differences to the C programming language
@cindex C programming language

Although many constructs from @sc{Singular}'s programming language are similar
to those from the C programming language, there are some subtle
differences. Most notably:

@menu
* No rvalue of increments and assignments::
* Evaluation of logical expressions::
* No case or switch statement::
* Usage of commas::
* Usage of brackets::
* Behavior of continue::
* Return type of procedures::
@end menu
@c ---------------------------------------
@node No rvalue of increments and assignments, Evaluation of logical expressions,,Major differences to the C programming language
@subsection No rvalue of increments and assignments
@cindex rvalue

The increment operator @code{++} (resp.@: decrement operator @code{--})
has no rvalue, i.e., cannot be used on the right-hand sides of
assignments.  So, instead of

@smallexample
j = i++;  // WRONG!!!
@end smallexample

@noindent (which results in an error), it must be written

@smallexample
i++; j = i;
@end smallexample

Likewise, an assignment expression does not have a result.  Therefore,
compound assignments like @code{i = j = k;} are not allowed and result
in an error.

@c ---------------------------------------
@node Evaluation of logical expressions, No case or switch statement, No rvalue of increments and assignments, Major differences to the C programming language
@subsection Evaluation of logical expressions
@cindex Evaluation of logical expressions
@cindex and
@cindex or

@c ------------------------------------------------------------
@c   This piece of text partially exists also in the file types.doc,
@c   chapter "boolean expressions".
@c   If you change something here, change it there, too!
@c ------------------------------------------------------------
@strong{All} arguments of a logical expression are first evaluated and
then the value of the logical expression is determined. For example, the
logical expressions @code{(a || b)} is evaluated by first evaluating
@code{a} @emph{and} @code{b}, even though the value of @code{b} has no
influence on the value of @code{(a || b)}, if @code{a} evaluates to
true. 

Note, that this evaluation is different from the left-to-right,
conditional evaluation of logical expressions (as found in most
programming languages). For example, in these other languages, the value
of @code{(1 || b)} is determined without ever evaluating @code{b}.  This
causes some problems with boolean tests on variables, which might not be
defined at evaluation time. For example, the following results in an
error, if the variable @code{i} is undefined:

@smallexample
if (defined(i) && i > 0) @{@} // WRONG!!!
@end smallexample

This must be written instead as:

@smallexample
if (defined(i))
@{
  if (i > 0) @{@}
@}
@end smallexample
@c ------------------------------------------------------------
@c end of duplicate text
@c ------------------------------------------------------------

However, there are several short work-arounds for this problem:
@enumerate
@item
If a variable (say, @code{i}) is only to be used as a boolean flag, then
define (value is TRUE) and undefine (value is FALSE) @code{i} instead of
assigning a value. Using this scheme, it is sufficient to simply write

@smallexample
if (defined(i))
@end smallexample

in order to check whether @code{i} is TRUE. Use the command @code{kill}
to undefine a variable, i.e.@: to assign it a FALSE value (@pxref{kill}).
@item
If a variable  can have more than two values, then
define it, if necessary, before it is used for the first time.
For example, if the following is used within a procedure

@smallexample
if (! defined(DEBUG)) @{ int DEBUG = 1;@}
@dots{}
if (DEBUG == 3)  @{@dots{}@}
if (DEBUG == 2)  @{@dots{}@}
@dots{}
@end smallexample

then a user of this procedure does not need to care about the existence
of the @code{DEBUG} variable -- this remains hidden from the
user. However, if @code{DEBUG} exists globally, then its local default
value is overwritten by its global one.
@end enumerate

@c ---------------------------------------
@node No case or switch statement,  Usage of commas, Evaluation of logical expressions, Major differences to the C programming language
@subsection No case or switch statement
@cindex case
@cindex switch

@sc{Singular} does not offer a @code{case} (or @code{switch})
statement. However, it can be imitated in the following way:

@smallexample
while (1)
@{
   if (choice == choice_1) @{ @dots{}; break;@}
   @dots{}
   if (choice == choice_n) @{ @dots{}; break;@}
   // default case
   @dots{}; break;
@}
@end smallexample

@c ---------------------------------------
@node Usage of commas, Usage of brackets, No case or switch statement, Major differences to the C programming language
@subsection Usage of commas
@cindex comma

In @sc{Singular}, a comma separates list elements and the value of a comma
expression is a list.
Hence, commas can not be used to combine several expressions into
a single expression. For example, instead of writing

@smallexample
for (i=1, j=5; i<5 || j<10; i++, j++) @{@dots{}@} // WRONG!!!!!!
@end smallexample

@noindent one has to write

@smallexample
for (i,j = 1,5; i<5 || j<10; i++, j++) @{@dots{}@}
@end smallexample

@c ---------------------------------------
@node Usage of brackets, Behavior of continue, Usage of commas, Major differences to the C programming language
@subsection Usage of brackets
@cindex bracket

In @sc{Singular}, curly brackets (@code{@{} @code{@}}) @strong{must
always} be used to enclose the statement body following such constructs
like @code{if}, @code{else}, @code{for}, or @code{while}, even if this
block consists of only a single statement. Similarly, in the return
statement of a procedure, parentheses (@code{(} @code{)}) @strong{must
always} be used to enclose the return value.  Even if there is no value
to return, parentheses have to be used after a return statement
(i.e., @code{return();}).  For example,

@smallexample
if (i == 1) return i;    // WRONG!!!!!
@end smallexample

@noindent results in an error. Instead, it must be written as

@smallexample
if (i == 1) @{ return (i); @}
@end smallexample

@c ---------------------------------------
@node  Behavior of continue, Return type of procedures, Usage of brackets, Major differences to the C programming language
@subsection Behavior of continue
@cindex continue
@sc{Singular}'s @code{continue} construct is only valid inside the body
of a @code{for} or @code{while} construct. It skips the rest of the
loop-body and jumps to the beginning of the block. Unlike the
C-construct @sc{Singular}'s @code{continue} @strong{does not execute the
increment statement}. For example,

@smallexample
for (int i = 1 ; i<=10; i=i+1)
@{
   @dots{}
   if (i==3) @{ i=8;continue; @}
     // skip the rest if i is 3 and
     // continue with the next i: 8
   i;
@}
@expansion{} 1
@expansion{} 2
@expansion{} 8
@expansion{} 9
@expansion{} 10
@end smallexample
@c ---------------------------------------
@node Return type of procedures,,Behavior of continue, Major differences to the C programming language
@subsection Return type of procedures
@cindex return type of procedures

Although the @sc{Singular} language is a strongly typed programming
language, the type of the
return value of a procedure does not need to be specified. As a
consequence, the return type of a procedure may vary, i.e., may, for
example, depend on the input. However, the return value
of such a procedure may then only be assigned to a variable of type
@code{def}.

@smallexample
@c reused example Return_type_of_procedures tricks.doc:308 
proc type_return (int i)
@{
  if (i > 0) @{return (i);@}
  else @{return (list(i));@}
@}
def t1 = type_return(1);
def t2 = type_return(-1);
typeof(t1); typeof(t2);
@expansion{} int
@expansion{} list
@c end example Return_type_of_procedures tricks.doc:308
@end smallexample

Furthermore, it is mandatory to assign the return value of a procedure
to a variable of type @code{def}, if a procedure changes the current
ring using the @code{keepring} command (@pxref{keepring}) and returns a
ring-dependent value (like a polynomial or module).

@smallexample
@c reused example Return_type_of_procedures_1 tricks.doc:326 
proc def_return
@{
  ring r=0,(x,y),dp;
  poly p = x;
  keepring r;
  return (x);
@}
def p = def_return();
// poly p = def_return(); would be WRONG!!!
typeof(p);
@expansion{} poly
@c end example Return_type_of_procedures_1 tricks.doc:326
@end smallexample

On the other hand, more than one value can be returned by a single
@code{return} statement. For example,

@smallexample
proc tworeturn () @{ return (1,2); @}
int i,j = tworeturn();
@end smallexample


@c -------------------------------------------------------------------------
@node Miscellaneous oddities, Identifier resolution, Major differences to the C programming language, Tricks and pitfalls
@section Miscellaneous oddities

@enumerate
@item integer division
@cindex integer division
@cindex div

If two numerical constants (i.e., two sequences of digits) are divided
using the @code{/} operator, the surrounding whitespace determines
which division to use: if there is no space between the constants and
the @code{/} operator (e.g., "3/2"), both numerical constants are
treated as of type @code{number} and the current ring division is
used. If there is at least one space surrounding the @code{/} operator
(e.g., "3 / 2"), both numerical constants are treated as of type
@code{int} and an integer division is performed. To avoid confusion, use
the @code{div} operator instead of @code{/} for integer division and an
explicit type cast to @code{number} for ring division. Note, that this
problem does only occur for divisions of numerical constants.
@smallexample
@c reused example Miscellaneous_oddities tricks.doc:370 
  ring r=32002,x,dp;
  3/2;    // ring division
@expansion{} -15994
  3 / 2;  // integer division
@expansion{} 1
  3 div 2;
@expansion{} 1
  number(3) / number(2);
@expansion{} -15994
  number a=3;
  number b=2;
  a/b;
@expansion{} -15994
  int c=3;
  int d=2;
  c / d;
@expansion{} 1
@c end example Miscellaneous_oddities tricks.doc:370
@end smallexample


@item monomials and precedence
@cindex monomials and precedence

The computation of a monomial has precedence over all operators:
@smallexample
@c reused example Miscellaneous_oddities_1 tricks.doc:391 
  ring r=0,(x,y),dp;
  2xy^2 == (2*x*y)^2;
@expansion{} 1
  2xy^2 == 2x*y^2;
@expansion{} 0
  2x*y^2 == 2*x * (y^2);
@expansion{} 1
@c end example Miscellaneous_oddities_1 tricks.doc:391
@end smallexample

@item meaning of @code{mult}
@cindex mult
@cindex degree

For an arbitrary ideal or module @code{i}, @code{mult(i)} returns the
multiplicity of the ideal generated by the leading monomials of the
given generators of @code{i}, hence depends on the monomial ordering!

A standard mistake is to interpret @code{degree(i)} or @code{mult(i)}
for an inhomogeneous ideal @code{i} as the degree of the homogenization
or as something like the 'degree of the affine part'. For the ordering
@code{dp} (degree reverse lexicographical) the converse is true: if
@code{i} is given by a standard basis, @code{mult(i)} is the degree of
the homogeneous ideal obtained by homogenization of @code{i} and then
putting the homogenizing variable to 0, hence it is the degree of the
part at infinity (this can also be checked by looking at the initial
ideal).

@item size of ideals
@cindex ideals
@cindex size

@code{size} counts the non-zero entries of an ideal or module. Use
@code{ncols} to determine the actual number of entries in the ideal or module.

@item computations in @code{qring}
@cindex qring

In order to speed up computations in quotient rings, @sc{Singular}
usually does not reduce polynomials w.r.t.@: the quotient ideal; rather
the given representative is used as long as possible during
computations. If it is necessary, reduction is done during standard base
computations. To reduce a polynomial @code{f} by hand w.r.t.@: the
current quotient ideal use the command @code{reduce(f,std(0))}
(@pxref{reduce}).

@item substring selection
@cindex string

To extract substrings from a @code{string}, square brackets are used,
enclosing either two comma-separated @code{int}s or an
@code{intvec}. Although two comma-separated @code{int}s represent an
@code{intvec}, they mean different things in substring access. Square
brackets enclosing two @code{int}s (e.g.@: @code{s[2,6]}) return a
substring where the first integer denotes the starting position and the
second integer denotes the length of the substring. The result is
returned as a @code{string}. Square brackets enclosing an @code{intvec}
(e.g.@: @code{s[intvec(2,6)]}) return the characters of the string at the
position given by the values of the @code{intvec}. The result is
returned as an expression list of strings. 
@c  Note, that this problem does
@c  not occur for square brackets enclosing a single @code{int} or more than
@c  two @code{int}s. Those always return an expression list of strings.

@smallexample
@c reused example Miscellaneous_oddities_2 tricks.doc:454 
  string s = "one-word";
  s[2,6];     // a substring starting at the second char
@expansion{} ne-wor
  size(_);
@expansion{} 6
  intvec v = 2,6;
  s[v];      // the second and the sixth char
@expansion{} n o
  string st = s[v];  // stick together by an assignment
  st;
@expansion{} no
  size(_);
@expansion{} 2
  v = 2,6,8;
  s[v];
@expansion{} n o d
@c end example Miscellaneous_oddities_2 tricks.doc:454
@end smallexample


@end enumerate

@c ----------------------------------------------
@node Identifier resolution,, Miscellaneous oddities, Tricks and pitfalls
@section Identifier resolution
@cindex identifier

In @sc{Singular}, an identifier (i.e., a "word") is resolved in the
following way and order: It is checked for
@enumerate
@item
a reserved name (like @code{ring}, @code{std}, @dots{}),
@item
a local  variable (w.r.t. a procedure),
@item
a local ring variable (w.r.t. the current basering locally set in a procedure),
@item
a global variable,
@item
a global ring variable (w.r.t. the current basering)
@item
a monomial consisting of local ring variables written without operators,
@item
a monomial consisting of global ring variables written without operators.
@end enumerate

Consequently, it is allowed to have general variables with the same name
as ring  variables. However, the above identifier resolution order must
be kept in mind. Otherwise, surprising results may come up.

@smallexample
@c reused example Identifier_resolution tricks.doc:517 
ring r=0,(x,y),dp;
int x;
x*y; // resolved product int*poly, i.e., 0*y
@expansion{} 0
xy; // "xy" is one identifier and resolved to monomial xy
@expansion{} xy
@c end example Identifier_resolution tricks.doc:517
@end smallexample

For these reasons, we strongly recommend not to use variables which
have the same name(s) as ring variables.

Moreover, we strongly recommend not to use ring variables whose name is
fully contained in (i.e., is a substring of) another name of a ring
variable. Otherwise, effects like the following might occur:


@smallexample
@c reused example Identifier_resolution_1 tricks.doc:534 
ring r=0,(x, x1),dp; // name x is substring of name x1 !!!!!!!!!
x;x1;   // resolved poly x
@expansion{} x
@expansion{} x1
short=0; 2x1; // resolved to monomial 2*x^1 !!!!!!
@expansion{} 2*x
2*x1; // resolved to product 2 times x1
@expansion{} 2*x1
@c end example Identifier_resolution_1 tricks.doc:534
@end smallexample

@c ----------------------------------------------------------------------------
@node Examples, Polynomial data, Tricks and pitfalls, Top
@appendix Examples
@cindex Examples
@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from examples.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT examples.doc INSTEAD
@comment Id: examples.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the examples

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').

The following topics are treated:

@menu
* Milnor and Tjurina::
* Procedures and LIB::
* Critical points::
* Saturation::
* Long coefficients::
* Parameters::
* T1 and T2::
* Deformations::
* Finite fields::
* Elimination::
* Free resolution::
* Computation of Ext::
* Polar curves::
* Depth::
* Formatting output::
* Cyclic roots::
* G_a -Invariants::
* Invariants of a finite group::
* Factorization::
* Puiseux pairs::
* Primary decomposition::
* Normalization::
* Branches of an Isolated Space Curve Singularity::
* Kernel of module homomorphisms::
* Algebraic dependence::
* Classification::
* Fast lexicographical GB::
* Parallelization with MPtcp links::
@end menu


@c ----------------------------------------------------------------------------
@c @node Start SINGULAR, Milnor and Tjurina,Examples, Examples
@c @section Start SINGULAR
@c @cindex Start SINGULAR

@c Call @sc{Singular} by typing @code{Singular} [return]

@c To use the online help type for instance:
@c    @code{help;} @code{help command;} @code{help General syntax;} @code{help ring;}...
@c Please note:  EVERY COMMAND MUST END WITH A SEMICOLON ";"

@c To leave @sc{Singular}, type one of the:
@c    @code{quit;} @code{exit;} @code{$}

@c The two characters @code{//} make the rest of the line a comment.

@c ----------------------------------------------------------------------------
@node Milnor and Tjurina, Procedures and LIB, Examples, Examples
@section Milnor and Tjurina
@cindex Milnor
@cindex Tjurina

The Milnor number, resp.@: the Tjurina number, of a power
series f in
@tex
$K[[x_1,\ldots,x_n]]$
@end tex
K[[x1,...,xn]]
is
@*      milnor(f) = dim_K(K[[x1,...,xn]]/jacob(f))
@*resp.@:
@*      tjurina(f) = dim_K(K[[x1,...,xn]]/((f)+jacob(f)))
@*where
@tex
$$
\hbox{milnor}(f) = \hbox{dim}_K(K[[x_1,\ldots,x_n]]/\hbox{jacob}(f)),
$$
respectively
$$
\hbox{tjurina}(f) = \hbox{dim}_K(K[[x_1,\ldots,x_n]]/((f)+\hbox{jacob}(f)))
$$
where
@end tex
@code{jacob(f)} is the ideal generated by the partials
of @code{f}. @code{tjurina(f)} is finite, if and only if @code{f} has an
isolated singularity. The same holds for @code{milnor(f)} if
K has characteristic 0.
@sc{Singular} displays -1 if the dimension is infinite.

@sc{Singular} cannot compute with infinite power series. But it can
work in
@tex
$\hbox{Loc}_{(x)}K[x_1,\ldots,x_n]$,
@end tex
Loc_(x)K[x1,...,xn],
the localization of
@tex
$K[x_1,\ldots,x_n]$
@end tex
K[x1,...,xn]
at the maximal ideal
@tex
$(x_1,\ldots,x_n)$.
@end tex
(x1,...,xn).
To do this one has to define an
s-ordering like ds, Ds, ls, ws, Ws or an appropriate matrix
ordering (look at the manual to get information about the possible
monomial orderings in @sc{Singular}, or type @code{help Monomial orderings;}
to get a menu of possible orderings. For further help type, e.g.,
@code{help local orderings;}).
See @ref{Monomial orderings}.

We shall show in the example below how to realize the following:
@itemize @bullet
@item
set option @code{prot} to have a short protocol during standard basis
computation
@item
define the ring @code{r1} with char 32003, variables @code{x,y,z}, monomial
  ordering @code{ds}, series ring (i.e., K[x,y,z] localized at (x,y,z))
@item
list the information about @code{r1} by typing its name
@item
define the integers @code{a,b,c,t}
@item
define a polynomial @code{f} (depending on @code{a,b,c,t}) and display it
@item
define the jacobian ideal @code{i} of @code{f}
@item
compute a standard basis of @code{i}
@item
compute the Milnor number (=250) with @code{vdim} and create and display
  a string in order to comment the result
  (text between quotes "  "; is a 'string')
@item
compute a standard basis of @code{i+(f)}
@item
compute the Tjurina number (=195) with @code{vdim}
@item
then compute the Milnor number (=248) and the Tjurina number
(=195) for @code{t}=1
@item
reset the option to @code{noprot}
@end itemize

@smallexample
@c computed example Milnor_and_Tjurina examples.doc:196 
  option(prot);
  ring r1 = 32003,(x,y,z),ds;
  r1;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering ds
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
  int a,b,c,t=11,5,3,0;
  poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
           x^(c-2)*y^c*(y^2+t*x)^2;
  f;
@expansion{} y5+x5y2+x2y2z3+xy7+z9+x11
  ideal i=jacob(f);
  i;
@expansion{} i[1]=5x4y2+2xy2z3+y7+11x10
@expansion{} i[2]=5y4+2x5y+2x2yz3+7xy6
@expansion{} i[3]=3x2y2z2+9z8
  ideal j=std(i);
@expansion{} [1023:2]7(2)s8s10s11s12s(3)s13(4)s(5)s14(6)s(7)15--.s(6)-16.-.s(5)17.s(7)\
   s--s18(6).--19-..sH(24)20(3)...21....22....23.--24-
@expansion{} product criterion:10 chain criterion:69
  "The Milnor number of f(11,5,3) for t=0 is", vdim(j);
@expansion{} The Milnor number of f(11,5,3) for t=0 is 250
  j=i+f;    // overwrite j
  j=std(j);
@expansion{} [1023:2]7(3)s8(2)s10s11(3)ss12(4)s(5)s13(6)s(8)s14(9).s(10).15--sH(23)(8)\
   ...16......17.......sH(21)(9)sH(20)16(10).17...........18.......19..----.\
   .sH(19)
@expansion{} product criterion:10 chain criterion:53
  vdim(j);  // compute the Tjurina number for t=0
@expansion{} 195
  t=1;
  f=x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3
    +x^(c-2)*y^c*(y^2+t*x)^2;
  ideal i1=jacob(f);
  ideal j1=std(i1);
@expansion{} [1023:2]7(2)s8s10s11s12s13(3)ss(4)s14(5)s(6)s15(7).....s(8)16.s...s(9)..1\
   7............s18(10).....s(11)..-.19.......sH(24)(10).....20...........21\
   ..........22.............................23..............................\
   .24.----------.25.26
@expansion{} product criterion:11 chain criterion:83
  "The Milnor number of f(11,5,3) for t=1:",vdim(j1);
@expansion{} The Milnor number of f(11,5,3) for t=1: 248
  vdim(std(j1+f));   // compute the Tjurina number for t=1
@expansion{} [1023:2]7(16)s8(15)s10s11ss(16)-12.s-s13s(17)s(18)s(19)-s(18).-14-s(17)-s\
   (16)ss(17)s15(18)..-s...--.16....-.......s(16).sH(23)s(18)...17..........\
   18.........sH(20)17(17)....................18..........19..---....-.-....\
   .....20.-----...s17(9).........18..............19..-.......20.-......21..\
   .......sH(19)16(5).....18......19.-----
@expansion{} product criterion:15 chain criterion:174
@expansion{} 195
  option(noprot);
@c end example Milnor_and_Tjurina examples.doc:196
@end smallexample

@c ----------------------------------------------------------------------------
@node Procedures and LIB, Critical points, Milnor and Tjurina, Examples
@section Procedures and LIB
@cindex Procedures and LIB

The computation of the Milnor number (for an arbitrary isolated complete
intersection singularity ICIS) and the Tjurina number (for an arbitrary
isolated singularity) can be done by using procedures from the library
@code{sing.lib}. For a hypersurface singularity it is very easy to write a
procedure which computes the Milnor number and the Tjurina number.

We shall demonstrate:
@itemize @bullet
@item
load the library @code{sing.lib}
@c item
@c disable the protocol option
@item
define a local ring in 2 variables and characteristic 0
@item
define a plane curve singularity
@item
compute Milnor number and Tjurina number by using the procedures
@code{milnor} and @code{tjurina}
@item
write your own procedures:
(A procedure has a list of input parameters and of return values, both
lists may be empty.)
  @itemize @minus
  @item
  the procedure @code{mil} which must be called with one parameter, a
  polynomial.
  The name g is local to the procedure and is killed automatically.
  @code{mil} returns the Milnor number (and displays a comment).
  @item
  the procedure @code{tjur} where the parameters are not specified. They
  are referred
  to by @code{#[1]} for the 1st, @code{#[2]} for the 2nd parameter, etc.
  @code{tjur} returns the Tjurina number (and displays a comment).
  @item
  the procedure @code{milrina} which returns a list consisting of two
  integers,
  the Milnor and the Tjurina number.
  @end itemize
@end itemize

@smallexample
LIB "sing.lib";
// you should get the information that sing.lib has been loaded
// together with some other libraries which are needed by sing.lib
ring r = 0,(x,y),ds;
poly f = x7+y7+(x-y)^2*x2y2;
milnor(f);
@expansion{} 28
tjurina(f);
@expansion{} 24

proc mil (poly g)
@{
   "Milnor number:";
   return(vdim(std(jacob(g))));
@}
mil(f);
@expansion{} Milnor number:
@expansion{} 28

proc tjur
@{
   "Tjurina number:";
   return(vdim(std(jacob(#[1])+#[1])));
@}
tjur(f);
@expansion{} Tjurina number:
@expansion{} 24

proc milrina (poly f)
@{
   ideal j=jacob(f);
   list L=vdim(std(j)),vdim(std(j+f));
   return(L);
@}
milrina(f);     // a list containing Milnor and Tjurina number
@expansion{} [1]:
@expansion{}    28
@expansion{} [2]:
@expansion{}    24
milrina(f)[2];  // the second element of the list
@expansion{} 24
@end smallexample

@c ----------------------------------------------------------------------------
@node Critical points, Saturation, Procedures and LIB, Examples
@section Critical points
@cindex Critical points

The same computation which computes the Milnor, resp.@: the Tjurina,
number, but with ordering @code{dp} instead of @code{ds} (i.e., in
@tex
$K[x_1,\ldots,x_n]$
@end tex
K[x1,...,xn]
instead of
@tex
$\hbox{Loc}_{(x)}K[x_1,\ldots,x_n])$
@end tex
Loc_(x)K[x1,...,xn])
gives:
@itemize @bullet
@item
the number of critical points of @code{f} in the affine plane
(counted with multiplicities)
@item
the number of singular points of @code{f} on the affine plane curve @code{f}=0
(counted with multiplicities).
@end itemize

We start with the ring @code{r1} from section @ref{Milnor and Tjurina} and its elements.

The following will be realized below:
@itemize @bullet
@item
reset the protocol option and activate the timer
@item
define the ring @code{r2} with char 32003, variables @code{x,y,z} and monomial
  ordering @code{dp} (= degrevlex) (i.e., the polynomial ring = K[x,y,z]).
@item
Note that polynomials, ideals, matrices (of polys), vectors,
  modules belong to a ring, hence we have to define @code{f} and @code{jacob(f)}
  again in @code{r2}. Since these objects are local to a ring, we may use
  the same names.
  Instead of defining @code{f} again we map it from ring @code{r1} to @code{r2}
  by using the @code{imap} command
  (@code{imap} is a convenient way to map variables
  from some ring identically to variables with the same name in the
  basering, even if the ground field is different. Compare with @code{fetch}
  which works for almost identical rings,
  e.g., if the rings differ only by the ordering or by the names of the
  variables and which may be used to rename variables).
  Integers and strings, however, do not belong to any ring. Once
  defined they are globally known.
@item
The result of the computation here (together with the previous one in
 @ref{Milnor and Tjurina}) shows that (for @code{t}=0)
@tex
$\hbox{dim}_K(\hbox{Loc}_{(x,y,z)}K[x,y,z]/\hbox{jacob}(f))$
@end tex
  dim_K(Loc_(x,y,z)K[x,y,z]/jacob(f))
= 250 (previously computed) while
@tex
$\hbox{dim}_K(K[x,y,z]/\hbox{jacob}(f))$
@end tex
  dim_K(K[x,y,z]/jacob(f))
= 536. Hence @code{f} has 286 critical points,
  counted with multiplicity, outside the origin.
  Moreover, since
@tex
$\hbox{dim}_K(\hbox{Loc}_{(x,y,z)}K[x,y,z]/(\hbox{jacob}(f)+(f)))$
@end tex
dim_K(Loc_(x,y,z)K[x,y,z]/(jacob(f)+(f)))
= 195 =
@tex
$\hbox{dim}_K(K[x,y,z]/(\hbox{jacob}(f)+(f)))$,
@end tex
dim_K(K[x,y,z]/(jacob(f)+(f))),
the affine surface @code{f}=0 is smooth outside the origin.
@end itemize

@smallexample
@c computed example Critical_points examples.doc:402 
  ring r1 = 32003,(x,y,z),ds;
  int a,b,c,t=11,5,3,0;
  poly f = x^a+y^b+z^(3*c)+x^(c+2)*y^(c-1)+x^(c-1)*y^(c-1)*z3+
           x^(c-2)*y^c*(y^2+t*x)^2;
  option(noprot);
  timer=1;
  ring r2 = 32003,(x,y,z),dp;
  poly f=imap(r1,f);
  ideal j=jacob(f);
  vdim(std(j));
@expansion{} 536
  vdim(std(j+f));
@expansion{} 195
  timer=0;  // reset timer
@c end example Critical_points examples.doc:402
@end smallexample

@c ----------------------------------------------------------------------------
@node Saturation, Long coefficients, Critical points, Examples
@section Saturation
@cindex Saturation

Since in the example above, the ideal 
@math{j+(f)}
@tex
$j+(f)$
@end tex
 has the same @code{vdim}
in the polynomial ring and in the localization at 0 (each 195),

@math{f=0}
@tex
$f=0$
@end tex
 is smooth outside 0.
Hence 
@math{j+(f)}
@tex
$j+(f)$
@end tex
 contains some power of the maximal ideal 
@math{m}
@tex
$m$
@end tex
. We shall
check this in a different manner:
For any two ideals 
@math{i, j}
@tex
$i, j$
@end tex
 in the basering 
@math{R}
@tex
$R$
@end tex
 let
@tex
$$
\hbox{sat}(i,j)=\{x\in R\;|\; \exists\;n\hbox{ s.t. }
x\cdot(j^n)\subseteq i\}
= \bigcup_{n=1}^\infty i:j^n$$
@end tex
@*sat(i,j) = @{x in @math{R} | there is an n s.t. x*(j^n) contained in i@}
@*         = union_(n=1...) of i:j^n,
@*denote the saturation of 
@math{i}
@tex
$i$
@end tex
 with respect to 
@math{j}
@tex
$j$
@end tex
. This defines,
geometrically, the closure of the complement of V(
@math{j}
@tex
$j$
@end tex
) in V(
@math{i}
@tex
$i$
@end tex
)
(V(
@math{i}
@tex
$i$
@end tex
) denotes the variety defined by 
@math{i}
@tex
$i$
@end tex
).
In our case, 
@math{sat(j+(f),m)}
@tex
$sat(j+(f),m)$
@end tex
 must be the whole ring, hence
generated by 1.

The saturation is computed by the procedure @code{sat} in
@code{elim.lib} by computing iterated ideal quotients with the maximal
ideal.  @code{sat} returns a list of two elements: the saturated ideal
and the number of iterations.  (Note that @code{maxideal(n)} denotes the
n-th power of the maximal ideal).

@smallexample
@c computed example Saturation examples.doc:457 
  LIB "elim.lib";         // loading library elim.lib
  // you should get the information that elim.lib has been loaded
  // together with some other libraries which are needed by it
  option(noprot);         // no protocol
  ring r2 = 32003,(x,y,z),dp;
  poly f = x^11+y^5+z^(3*3)+x^(3+2)*y^(3-1)+x^(3-1)*y^(3-1)*z3+
    x^(3-2)*y^3*(y^2)^2;
  ideal j=jacob(f);
  sat(j+f,maxideal(1));
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{} [2]:
@expansion{}    17
  // list the variables defined so far:
  listvar();
@expansion{} // r2                   [0]  *ring
@expansion{} //      j                    [0]  ideal, 3 generator(s)
@expansion{} //      f                    [0]  poly
@expansion{} // LIB                  [0]  string standard.lib,elim.li..., 83 char(s)
@c end example Saturation examples.doc:457
@end smallexample

@c ----------------------------------------------------------------------------
@node Long coefficients, Parameters, Saturation, Examples
@section Long coefficients
@cindex Long coefficients

The following innocent example produces in its standard basis
extremely long coefficients in char 0 for the lexicographical
ordering.
But a very small deformation does not (the undeformed
example is degenerate with respect to the Newton boundary).
This example demonstrates that it might be wise, for complicated
examples, to do the calculation first in positive char (e.g., 32003).
It has been shown, that in complicated examples, more than 95 percent of
the time needed for a standard basis computation is used in the
computation of the coefficients (in char 0).
The representation of long integers with real is demonstrated.

@smallexample
@c computed example Long_coefficients examples.doc:491 
timer = 1;                              // activate the timer
option(prot);
ring R0 = 0,(x,y),lp;
poly f = x5+y11+xy9+x3y9;
ideal i = jacob(f);
ideal i1 = i,i[1]*i[2];                 // undeformed ideal
ideal i2 = i,i[1]*i[2]+1/1000000*x5y8;  // deformation of i1
i1; i2;
@expansion{} i1[1]=5x4+3x2y9+y9
@expansion{} i1[2]=9x3y8+9xy8+11y10
@expansion{} i1[3]=45x7y8+27x5y17+45x5y8+55x4y10+36x3y17+33x2y19+9xy17+11y19
@expansion{} i2[1]=5x4+3x2y9+y9
@expansion{} i2[2]=9x3y8+9xy8+11y10
@expansion{} i2[3]=45x7y8+27x5y17+45000001/1000000x5y8+55x4y10+36x3y17+33x2y19+9xy17+1\
   1y19
ideal j = std(i1);
@expansion{} [65535:1]11(2)ss19s20s21s22(3)-23-s27s28s29s30s31s32s33s34s35s36s37s38s39\
   s40s70-
@expansion{} product criterion:1 chain criterion:30
j;
@expansion{} j[1]=264627y39+26244y35-1323135y30-131220y26+1715175y21+164025y17+1830125\
   y16
@expansion{} j[2]=12103947791971846719838321886393392913750065060875xy8-28639152114168\
   3198701331939250003266767738632875y38-31954402206909026926764622877573565\
   78554430672591y37+57436621420822663849721381265738895282846320y36+1657764\
   214948799497573918210031067353932439400y35+213018481589308191195677223898\
   98682697001205500y34+1822194158663066565585991976961565719648069806148y33\
   -4701709279892816135156972313196394005220175y32-1351872269688192267600786\
   97600850686824231975y31-3873063305929810816961516976025038053001141375y30\
   +1325886675843874047990382005421144061861290080000y29+1597720195476063141\
   9467945895542406089526966887310y28-26270181336309092660633348002625330426\
   7126525y27-7586082690893335269027136248944859544727953125y26-867853074106\
   49464602285843351672148965395945625y25-5545808143273594102173252331151835\
   700278863924745y24+19075563013460437364679153779038394895638325y23+548562\
   322715501761058348996776922561074021125y22+157465452677648386073957464715\
   68100780933983125y21-1414279129721176222978654235817359505555191156250y20\
   -20711190069445893615213399650035715378169943423125y19+272942733337472665\
   573418092977905322984009750y18+789065115845334505801847294677413365720955\
   3750y17+63554897038491686787729656061044724651089803125y16-22099251729923\
   906699732244761028266074350255961625y14+147937139679655904353579489722585\
   91339027857296625y10
@expansion{} j[3]=5x4+3x2y9+y9
// Compute average coefficient length (=51) by
//   - converting j[2] to a string in order to compute the number
//   of characters
//   - divide this by the number of monomials:
size(string(j[2]))/size(j[2]);
@expansion{} 51
vdim(j);
@expansion{} 63
// For a better representation normalize the long coefficients
// of the polynomial j[2] and map it  to real:
poly p=(1/12103947791971846719838321886393392913750065060875)*j[2];
ring R1=real,(x,y),lp;
short=0; // force the long output format
poly p=imap(R0,p);
p;
@expansion{} x*y^8-2.366e-02*y^38-2.640e-01*y^37+4.745e-06*y^36+1.370e-04*y^35+1.760e-\
   03*y^34+1.505e-01*y^33+3.884e-07*y^32-1.117e-05*y^31-3.200e-04*y^30+1.095\
   e-01*y^29+1.320e+00*y^28-2.170e-05*y^27-6.267e-04*y^26-7.170e-03*y^25-4.5\
   82e-01*y^24+1.576e-06*y^23+4.532e-05*y^22+1.301e-03*y^21-1.168e-01*y^20-1\
   .711e+00*y^19+2.255e-05*y^18+6.519e-04*y^17+5.251e-03*y^16-1.826e+00*y^14\
   +1.222e+00*y^10
// Compute a standard basis for the deformed ideal:
setring R0;
j = std(i2);
@expansion{} [65535:1]11(2)ss19s20s21s22(3)-s23(2)s27.28.s29(3)s30.s31ss32sss33sss34ss\
   35--38-
@expansion{} product criterion:11 chain criterion:21
j;
@expansion{} j[1]=y16
@expansion{} j[2]=65610xy8+17393508y27+7223337y23+545292y19+6442040y18-119790y14+80190\
   y10
@expansion{} j[3]=5x4+3x2y9+y9
vdim(j);
@expansion{} 40
@c end example Long_coefficients examples.doc:491
@end smallexample
@c ----------------------------------------------------------------------------
@node Parameters, T1 and T2, Long coefficients, Examples
@section Parameters
@cindex Parameters

Let us deform the above ideal now by introducing a parameter t
and compute over the ground field Q(t).
We compute the dimension at the generic point,
i.e.,
@tex
$dim_{Q(t)}Q(t)[x,y]/j$.
@end tex
dim_Q(t) Q(t)[x,y]/j.
(This gives the
same result as for the deformed ideal above. Hence, the above small
deformation was "generic".)

For almost all
@tex
$a \in Q$
@end tex
a in Q
this is the same as
@tex
$dim_Q Q[x,y]/j_0$,
@end tex
dim_Q Q[x,y]/j0,
where
@tex
$j_0=j|_{t=a}$.
@end tex
j_0=j_t=a

@smallexample
@c computed example Parameters examples.doc:579 
  ring Rt = (0,t),(x,y),lp;
  Rt;
@expansion{} //   characteristic : 0
@expansion{} //   1 parameter    : t 
@expansion{} //   minpoly        : 0
@expansion{} //   number of vars : 2
@expansion{} //        block   1 : ordering lp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering C
  poly f = x5+y11+xy9+x3y9;
  ideal i = jacob(f);
  ideal j = i,i[1]*i[2]+t*x5y8;  // deformed ideal, parameter t
  vdim(std(j));
@expansion{} 40
  ring R=0,(x,y),lp;
  ideal i=imap(Rt,i);
  int a=random(1,30000);
  ideal j=i,i[1]*i[2]+a*x5y8;  // deformed ideal, fixed integer a
  vdim(std(j));
@expansion{} 40
@c end example Parameters examples.doc:579
@end smallexample

@c ----------------------------------------------------------------------------
@node T1 and T2, Deformations, Parameters, Examples
@section T1 and T2
@cindex T1
@cindex T2


@math{T^1}
@tex
$T^1$
@end tex
, resp.@: 
@math{T^2}
@tex
$T^2$
@end tex
, of an ideal 
@math{j}
@tex
$j$
@end tex
 usually denote the modules of
infinitesimal deformations, resp.@: of obstructions.
In @sc{Singular} there are procedures @code{T_1} and @code{T_2} in
@code{sing.lib} such that
@code{T_1(j)} and @code{T_2(j)} compute a standard basis of
a presentation of these modules.
If T_1 and T_2 are finite dimensional K-vector spaces (e.g., for isolated
singularities), a basis can be computed by applying
@code{kbase(T_1(j));}, resp.@: @code{kbase(T_2(j));}, the dimensions by
applying @code{vdim}.
For a complete intersection j the procedure @code{Tjurina} also
computes T_1, but faster (T_2=0 in this case).
For a non complete intersection, it is faster to use the procedure @code{T_12}
instead of @code{T_1} and @code{T_2}.
Type @code{help T_1;} (or @code{help T_2;} or @code{help T_12;}) to obtain
more detailed information about these procedures.

We give three examples, the first being a hypersurface, the second a complete
intersection, the third no complete intersection:
@itemize @bullet
@item
load @code{sing.lib}
@item
check whether the ideal j is a complete intersection. It is, if
     number of variables = dimension + minimal number of generators
@item
compute the Tjurina number
@item
compute a vector space basis (kbase) of T_1
@item
compute the Hilbert function of T_1
@item
create a polynomial encoding the Hilbert series
@item
compute the dimension of T_2
@end itemize

@smallexample
@c computed example T1_and_T2 examples.doc:639 
  LIB "sing.lib";
  ring R=32003,(x,y,z),ds;
  // ---------------------------------------
  // hypersurface case (from series T[p,q,r]):
  int p,q,r = 3,3,4;
  poly f = x^p+y^q+z^r+xyz;
  tjurina(f);
@expansion{} 8
  // Tjurina number = 8
  kbase(Tjurina(f));
@expansion{} // Tjurina number = 8
@expansion{} _[1]=z3
@expansion{} _[2]=z2
@expansion{} _[3]=yz
@expansion{} _[4]=xz
@expansion{} _[5]=z
@expansion{} _[6]=y
@expansion{} _[7]=x
@expansion{} _[8]=1
  // ---------------------------------------
  // complete intersection case (from series P[k,l]):
  int k,l =3,2;
  ideal j=xy,x^k+y^l+z2;
  dim(std(j));          // Krull dimension
@expansion{} 1
  size(minbase(j));     // minimal number of generators
@expansion{} 2
  tjurina(j);           // Tjurina number
@expansion{} 6
  module T=Tjurina(j);
@expansion{} // Tjurina number = 6
  kbase(T);             // a sparse output of the k-basis of T_1
@expansion{} _[1]=z*gen(1)
@expansion{} _[2]=gen(1)
@expansion{} _[3]=y*gen(2)
@expansion{} _[4]=x2*gen(2)
@expansion{} _[5]=x*gen(2)
@expansion{} _[6]=gen(2)
  print(kbase(T));      // columns of matrix are a k-basis of T_1
@expansion{} z,1,0,0, 0,0,
@expansion{} 0,0,y,x2,x,1 
  // ---------------------------------------
  // general case (cone over rational normal curve of degree 4):
  ring r1=0,(x,y,z,u,v),ds;
  matrix m[2][4]=x,y,z,u,y,z,u,v;
  ideal i=minor(m,2);   // 2x2 minors of matrix m
  module M=T_1(i);       // a presentation matrix of T_1
@expansion{} // dim T_1 = 4
  vdim(M);              // Tjurina number
@expansion{} 4
  hilb(M);              // display of both Hilbert series
@expansion{} //         4 t^0
@expansion{} //       -20 t^1
@expansion{} //        40 t^2
@expansion{} //       -40 t^3
@expansion{} //        20 t^4
@expansion{} //        -4 t^5
@expansion{} 
@expansion{} //         4 t^0
@expansion{} // dimension (local)   = 0
@expansion{} // multiplicity = 4
  intvec v1=hilb(M,1);  // first Hilbert series as intvec
  intvec v2=hilb(M,2);  // second Hilbert series as intvec
  v1;
@expansion{} 4,-20,40,-40,20,-4,0
  v2;
@expansion{} 4,0
  v1[3];                // 3rd coefficient of the 1st Hilbert series
@expansion{} 40
  module N=T_2(i);
@expansion{} // dim T_2 = 3
@c end example T1_and_T2 examples.doc:639
@end smallexample
@smallexample
// In some cases it might be useful to have a polynomial in some ring
// encoding the Hilbert series. This polynomial can then be
// differentiated, evaluated etc. It can be done as follows:
ring H = 0,t,ls;
poly h1;
int ii;
for (ii=1; ii<=size(v1); ii=ii+1)
@{
   h1=h1+v1[ii]*t^(ii-1);
@}
h1;                   // 1st Hilbert series
@expansion{} 4-20t+40t2-40t3+20t4-4t5
diff(h1,t);           // differentiate  h1
@expansion{} -20+80t-120t2+80t3-20t4
subst(h1,t,1);        // substitute t by 1
@expansion{} 0

// The procedures T_1, T_2, T_12 may be called with two arguments and then
// they return a list with more information (type help T_1; etc.)
// e.g., T_12(i,<any>); returns a list with 9 nonempty objects where
// _[1] = std basis of T_1-module, _[2] = std basis of T_2-module,
// _[3]= vdim of T_1, _[4]= vdim of T_2
setring r1;           // make r1 again the basering
list L = T_12(i,1);
@expansion{} // dim T_1  =  4
@expansion{} // dim T_2  =  3
kbase(L[1]);          // kbase of T_1
@expansion{} _[1]=1*gen(2)
@expansion{} _[2]=1*gen(3)
@expansion{} _[3]=1*gen(6)
@expansion{} _[4]=1*gen(7)
kbase(L[2]);          // kbase of T_2
@expansion{} _[1]=1*gen(6)
@expansion{} _[2]=1*gen(8)
@expansion{} _[3]=1*gen(9)
L[3];                 // vdim of T_1
@expansion{} 4
L[4];                 // vdim of T_2
@expansion{} 3
@end smallexample
@c killall();            // a procedure from general.lib
@c @expansion{} // ** killing the basering for level 0
@c ----------------------------------------------------------------------------
@node Deformations, Finite fields, T1 and T2, Examples
@section Deformations
@cindex Deformations

@itemize @bullet
@item
The libraries @code{sing.lib}, resp.@: @code{deform.lib}, contain procedures
to compute total and base space of the
miniversal (= semiuniversal) deformation of an
isolated complete intersection singularity, resp.@: arbitrary isolated
singularity.
@item
The procedure @code{deform} in @code{sing.lib} returns a matrix whose columns
@code{h_1,..., h_r}
@tex
$h_1,\ldots,h_r$
@end tex
represent all 1st order deformations. More precisely, if
I in R is the ideal generated by @code{f_1,...,f_s}, then any infinitesimal
deformation of R/I over K[e]/(e^2) is given by @code{f+eg},
where f=(f_1,...,f_s), g a K-linear combination of the h_i.
@tex
$I \subset R$ is the ideal generated by $f_1,...,f_s$, then any infinitesimal
deformation of $R/I$ over $K[\varepsilon]/(\varepsilon^2)$ is given
by $f+\varepsilon g$,
where $f=(f_1,...,f_s)$, $g$ a $K$-linear combination of the $h_i$.
@end tex

@item
The procedure @code{versal} in @code{deform.lib} computes a formal
miniversal deformation up to a certain order which can be
prescribed by the user. For a complete intersection the 1st order
part is already miniversal.
@item
The procedure @code{versal} extends the basering to a new ring with
additional deformation parameters which contains the equations for the
miniversal base space and the miniversal total space.
@item
There are default names for the objects created, but the user may also
choose his own names.
@item
If the user sets @code{printlevel=2;} before running @code{versal}, some
intermediate results are shown. This is useful since @code{versal}
is already complicated and might run for some time on more
complicated examples. (type @code{help versal;})
@end itemize

We compute for the same examples as in the preceding section
the miniversal deformations:

@smallexample
@c computed example Deformations examples.doc:787 
  LIB "deform.lib";
  ring R=32003,(x,y,z),ds;
  //----------------------------------------------------
  // hypersurface case (from series T[p,q,r]):
  int p,q,r = 3,3,4;
  poly f = x^p+y^q+z^r+xyz;
  print(deform(f));
@expansion{} z3,z2,yz,xz,z,y,x,1
  // the miniversal deformation of f=0 is the projection from the
  // miniversal total space to the miniversal base space:
  // @{ (A,B,C,D,E,F,G,H,x,y,z) | x3+y3+xyz+z4+A+Bx+Cxz+Dy+Eyz+Fz+Gz2+Hz3 =0 @}
  //  --> @{ (A,B,C,D,E,F,G,H) @}
  //----------------------------------------------------
  // complete intersection case (from series P[k,l]):
  int k,l =3,2;
  ideal j=xy,x^k+y^l+z2;
  print(deform(j));
@expansion{} 0,0, 0,0,z,1,
@expansion{} y,x2,x,1,0,0 
  versal(j);                  // using default names
@expansion{} // smooth base space
@expansion{} // ready: T_1 and T_2
@expansion{} 
@expansion{} // Result belongs to ring Px.
@expansion{} // Equations of total space of miniversal deformation are 
@expansion{} // given by Fs, equations of miniversal base space by Js.
@expansion{} // Make Px the basering and list objects defined in Px by typing:
@expansion{}    setring Px; show(Px);
@expansion{}    listvar(matrix);
@expansion{} // NOTE: rings Qx, Px, So are alive!
@expansion{} // (use 'kill_rings("");' to remove)
  setring Px;
  show(Px);                   // show is a procedure from inout.lib
@expansion{} // ring: (32003),(A,B,C,D,E,F,x,y,z),(ds(6),ds(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // Rs                   [0]  matrix 2 x 1
@expansion{} // Fs                   [0]  matrix 1 x 2
@expansion{} // Js                   [0]  matrix 1 x 0
  listvar(matrix);
@expansion{} // Rs                   [0]  matrix 2 x 1
@expansion{} // Fs                   [0]  matrix 1 x 2
@expansion{} // Js                   [0]  matrix 1 x 0
  // ___ Equations of miniversal base space ___:
  Js;
@expansion{} 
  // ___ Equations of miniversal total space ___:
  Fs;
@expansion{} Fs[1,1]=xy+Ez+F
@expansion{} Fs[1,2]=y2+z2+x3+Ay+Bx2+Cx+D
  // the miniversal deformation of V(j) is the projection from the
  // miniversal total space to the miniversal base space:
  // @{ (A,B,C,D,E,F,x,y,z) | xy+F+Ez=0, y2+z2+x3+D+Cx+Bx2+Ay=0 @}
  //  --> @{ (A,B,C,D,E,F) @}
  //----------------------------------------------------
  // general case (cone over rational normal curve of degree 4):
  ring r1=0,(x,y,z,u,v),ds;
  matrix m[2][4]=x,y,z,u,y,z,u,v;
  ideal i=minor(m,2);                 // 2x2 minors of matrix m
  int time=timer;
  // Def_r is the name of the miniversal base space with
  // parameters A(1),...,A(4)
  versal(i,0,"Def_r","A(");
@expansion{} // ready: T_1 and T_2
@expansion{} 
@expansion{} // Result belongs to ring Def_rPx.
@expansion{} // Equations of total space of miniversal deformation are 
@expansion{} // given by Fs, equations of miniversal base space by Js.
@expansion{} // Make Def_rPx the basering and list objects defined in Def_rPx by typin\
   g:
@expansion{}    setring Def_rPx; show(Def_rPx);
@expansion{}    listvar(matrix);
@expansion{} // NOTE: rings Def_rQx, Def_rPx, Def_rSo are alive!
@expansion{} // (use 'kill_rings("Def_r");' to remove)
  "// used time:",timer-time,"sec";   // time of last command
@expansion{} // used time: 1 sec
  // the miniversal deformation of V(i) is the projection from the
  // miniversal total space to the miniversal base space:
  // @{ (A(1..4),x,y,z,u,v) |
  //         -y^2+x*z+A(2)*x-A(3)*y=0, -y*z+x*u-A(1)*x-A(3)*z=0,
  //         -y*u+x*v-A(3)*u-A(4)*z=0, -z^2+y*u-A(1)*y-A(2)*z=0,
  //         -z*u+y*v-A(2)*u-A(4)*u=0, -u^2+z*v+A(1)*u-A(4)*v=0 @}
  //  --> @{ A(1..4) |
  //         -A(1)*A(4) = A(3)*A(4) = -A(2)*A(4)-A(4)^2 = 0 @}
  //----------------------------------------------------
@c end example Deformations examples.doc:787
@end smallexample

@c ----------------------------------------------------------------------------
@node Finite fields, Elimination, Deformations, Examples
@section Finite fields
@cindex Finite fields

We define a variety in 
@math{n}
@tex
$n$
@end tex
-space of codimension 2 defined by
polynomials of degree 
@math{d}
@tex
$d$
@end tex
 with generic coefficients over the prime
field 
@math{Z/p}
@tex
$Z/p$
@end tex
 and look for zeros on the torus. First over the prime
field and then in the finite extension field with
@tex
$p^k$
@end tex
p^k
elements.
In general there will be many more solutions in the second case.
(Since the @sc{Singular} language is interpreted, the evaluation of many
@code{for}-loops is not very fast):

@smallexample
@c computed example Finite_fields examples.doc:860 
  int p=3;  int n=3;  int d=5; int k=2;
  ring rp = p,(x(1..n)),dp;
  int s = size(maxideal(d));
  s;
@expansion{} 21
  // create a dense homogeneous ideal m, all generators of degree d, with
  // generic (random) coefficients:
  ideal m = maxideal(d)*random(p,s,n-2);
  m;
@expansion{} m[1]=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^3*x\
   (3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5
  // look for zeros on the torus by checking all points (with no component 0)
  // of the affine n-space over the field with p elements :
  ideal mt;
  int i(1..n);                    // initialize integers i(1),...,i(n)
  int l;
  s=0;
  for (i(1)=1;i(1)<p;i(1)=i(1)+1)
  @{
    for (i(2)=1;i(2)<p;i(2)=i(2)+1)
    @{
      for (i(3)=1;i(3)<p;i(3)=i(3)+1)
      @{
        mt=m;
        for (l=1;l<=n;l=l+1)
        @{
          mt=subst(mt,x(l),i(l));
        @}
        if (size(mt)==0)
        @{
          "solution:",i(1..n);
          s=s+1;
        @}
      @}
    @}
  @}
@expansion{} solution: 1 1 2
@expansion{} solution: 1 2 1
@expansion{} solution: 1 2 2
@expansion{} solution: 2 1 1
@expansion{} solution: 2 1 2
@expansion{} solution: 2 2 1
  "//",s,"solutions over GF("+string(p)+")";
@expansion{} // 6 solutions over GF(3)
  // Now go to the field with p^3 elements:
  // As long as there is no map from Z/p to the field with p^3 elements
  // implemented, use the following trick: convert the ideal to be mapped
  // to the new ring to a string and then execute this string in the
  // new ring
  string ms="ideal m="+string(m)+";";
  ms;
@expansion{} ideal m=x(1)^3*x(2)^2-x(1)*x(2)^4+x(1)^4*x(3)-x(1)^3*x(2)*x(3)+x(1)*x(2)^\
   3*x(3)+x(2)^4*x(3)+x(2)^3*x(3)^2+x(1)*x(2)*x(3)^3+x(1)*x(3)^4-x(3)^5;
  // define a ring rpk with p^k elements, call the primitive element z. Hence
  // 'solution exponent: 0 1 5' means that (z^0,z^1,z^5) is a solution
  ring rpk=(p^k,z),(x(1..n)),dp;
  rpk;
@expansion{} //   # ground field : 9
@expansion{} //   primitive element : z
@expansion{} //   minpoly        : 1*z^2+1*z^1+2*z^0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x(1) x(2) x(3) 
@expansion{} //        block   2 : ordering C
  execute(ms);
  s=0;
  ideal mt;
  for (i(1)=0;i(1)<p^k-1;i(1)=i(1)+1)
  @{
    for (i(2)=0;i(2)<p^k-1;i(2)=i(2)+1)
    @{
      for (i(3)=0;i(3)<p^k-1;i(3)=i(3)+1)
      @{
        mt=m;
        for (l=1;l<=n;l=l+1)
        @{
          mt=subst(mt,x(l),z^i(l));
        @}
        if (size(mt)==0)
        @{
          "solution exponent:",i(1..n);
          s=s+1;
        @}
      @}
    @}
  @}
@expansion{} solution exponent: 0 0 2
@expansion{} solution exponent: 0 0 4
@expansion{} solution exponent: 0 0 6
@expansion{} solution exponent: 0 1 0
@expansion{} solution exponent: 0 3 0
@expansion{} solution exponent: 0 4 0
@expansion{} solution exponent: 0 4 4
@expansion{} solution exponent: 0 4 5
@expansion{} solution exponent: 0 4 7
@expansion{} solution exponent: 1 1 3
@expansion{} solution exponent: 1 1 5
@expansion{} solution exponent: 1 1 7
@expansion{} solution exponent: 1 2 1
@expansion{} solution exponent: 1 4 1
@expansion{} solution exponent: 1 5 0
@expansion{} solution exponent: 1 5 1
@expansion{} solution exponent: 1 5 5
@expansion{} solution exponent: 1 5 6
@expansion{} solution exponent: 2 2 0
@expansion{} solution exponent: 2 2 4
@expansion{} solution exponent: 2 2 6
@expansion{} solution exponent: 2 3 2
@expansion{} solution exponent: 2 5 2
@expansion{} solution exponent: 2 6 1
@expansion{} solution exponent: 2 6 2
@expansion{} solution exponent: 2 6 6
@expansion{} solution exponent: 2 6 7
@expansion{} solution exponent: 3 3 1
@expansion{} solution exponent: 3 3 5
@expansion{} solution exponent: 3 3 7
@expansion{} solution exponent: 3 4 3
@expansion{} solution exponent: 3 6 3
@expansion{} solution exponent: 3 7 0
@expansion{} solution exponent: 3 7 2
@expansion{} solution exponent: 3 7 3
@expansion{} solution exponent: 3 7 7
@expansion{} solution exponent: 4 0 0
@expansion{} solution exponent: 4 0 1
@expansion{} solution exponent: 4 0 3
@expansion{} solution exponent: 4 0 4
@expansion{} solution exponent: 4 4 0
@expansion{} solution exponent: 4 4 2
@expansion{} solution exponent: 4 4 6
@expansion{} solution exponent: 4 5 4
@expansion{} solution exponent: 4 7 4
@expansion{} solution exponent: 5 0 5
@expansion{} solution exponent: 5 1 1
@expansion{} solution exponent: 5 1 2
@expansion{} solution exponent: 5 1 4
@expansion{} solution exponent: 5 1 5
@expansion{} solution exponent: 5 5 1
@expansion{} solution exponent: 5 5 3
@expansion{} solution exponent: 5 5 7
@expansion{} solution exponent: 5 6 5
@expansion{} solution exponent: 6 1 6
@expansion{} solution exponent: 6 2 2
@expansion{} solution exponent: 6 2 3
@expansion{} solution exponent: 6 2 5
@expansion{} solution exponent: 6 2 6
@expansion{} solution exponent: 6 6 0
@expansion{} solution exponent: 6 6 2
@expansion{} solution exponent: 6 6 4
@expansion{} solution exponent: 6 7 6
@expansion{} solution exponent: 7 0 7
@expansion{} solution exponent: 7 2 7
@expansion{} solution exponent: 7 3 3
@expansion{} solution exponent: 7 3 4
@expansion{} solution exponent: 7 3 6
@expansion{} solution exponent: 7 3 7
@expansion{} solution exponent: 7 7 1
@expansion{} solution exponent: 7 7 3
@expansion{} solution exponent: 7 7 5
  "//",s,"solutions over GF("+string(p^k)+")";
@expansion{} // 72 solutions over GF(9)
@c end example Finite_fields examples.doc:860
@end smallexample
@c ----------------------------------------------------------------------------
@node Elimination, Free resolution, Finite fields, Examples
@section Elimination
@cindex Elimination

Elimination is the algebraic counterpart of the geometric concept of
projection. If
@tex
$f=(f_1,\ldots,f_n):k^r\rightarrow k^n$
@end tex
f=(f1,...,fn) : k^r --> k^n
is a polynomial map,
the Zariski-closure of the image is the zero-set of the ideal
@tex
$$
\displaylines{
j=J \cap k[x_1,\ldots,x_n], \;\quad\hbox{\rm where}\cr
J=(x_1-f_1(t_1,\ldots,t_r),\ldots,x_n-f_n(t_1,\ldots,t_r))\subseteq
k[t_1,\ldots,t_r,x_1,\ldots,x_n]
}
$$
@end tex

@smallexample
        j = J intersected with K[x1,...,xn]
J=(x1-f1(t1,...,tr),...,xn-fn(t1,...,tr)) in k[t1,...tr,x1,...,xn]
@end smallexample

i.e, of the ideal j obtained from J by eliminating the variables
@tex
$t_1,\ldots,t_r$.
@end tex
t1,...,tr.
This can be done by computing a standard basis of J with respect to a product
ordering where the block of t-variables precedes the block of
x-variables and then selecting those polynomials which do not contain
any t. In @sc{Singular} the most convenient way is to use the
@code{eliminate} command.
In contrast to the first method, with @code{eliminate} the result needs not be a
standard basis in the given ordering.
Hence, there may be cases where the first method is the preferred one.

@strong{WARNING:} In the case of a local or a mixed ordering, elimination needs special
care. f may be considered as a map of germs
@tex
$f:(k^r,0)\rightarrow(k^n,0)$,
@end tex
f : (k^r,0) --> (k^n,0),
but even
if this map germ is finite, we are in general not able to compute the image
germ because for this we would need an implementation of the Weierstrass
preparation theorem. What we can compute, and what @code{eliminate} actually does,
is the following: let V(J) be the zero-set of J in
@tex
$k^r\times(k^n,0)$,
@end tex
k^r x (k^n,0),
then the
closure of the image of V(J) under the projection
@tex
$$\hbox{pr}:k^r\times(k^n,0)\rightarrow(k^n,0)$$
can be computed.
@end tex
@*           pr:  k^r x (k^n,0) --> (k^n,0)
@*can be computed.
Note that this germ contains also those components
of V(J) which meet the fiber of pr outside the origin.
This is achieved by an ordering with the block of t-variables having a
global ordering (and preceding the x-variables) and the x-variables having
a local ordering. In a local situation we propose @code{eliminate} with
ordering ls.

In any case, if the input is weighted homogeneous (=quasihomogeneous),
the weights given to the variables should be chosen accordingly.
@sc{Singular} offers a function @code{weight} which proposes,
given an ideal or module, integer weights for the variables, such that
the ideal, resp.@: module, is as homogeneous as possible with respect to these weights.
The function finds correct weights, if the input is weighted homogeneous
(but is rather slow for many variables). In order to check, whether the
input is quasihomogeneous, use the function @code{qhweight}, which returns
an intvec of correct weights if the input is quasihomogeneous and an intvec
of zeros otherwise.

Let us give two examples:
@enumerate
@item
First we compute the equations of the simple space curve
@tex
$\hbox{T}[7]^\prime$
@end tex
T[7]'
   consisting of two tangential cusps given in parametric form.
@item
We compute weights for the equations such that the
   equations are quasihomogeneous w.r.t. these weights.
@item
Then we compute the tangent developable of the rational
   normal curve in
@tex
$P^4$.
@end tex
P^4.
@end enumerate

@smallexample
@c computed example Elimination examples.doc:1058 
  // 1. Compute equations of curve given in parametric form:
  // Two transversal cusps in (k^3,0):
  ring r1 = 0,(t,x,y,z),ls;
  ideal i1 = x-t2,y-t3,z;        // parametrization of the first branch
  ideal i2 = y-t2,z-t3,x;        // parametrization of the second branch
  ideal j1 = eliminate(i1,t);
  j1;                            // equations of the first branch
@expansion{} j1[1]=z
@expansion{} j1[2]=y2-x3
  ideal j2 = eliminate(i2,t);
  j2;                            // equations of the second branch
@expansion{} j2[1]=x
@expansion{} j2[2]=z2-y3
  // Now map to a ring with only x,y,z as variables and compute the
  // intersection of j1 and j2 there:
  ring r2 = 0,(x,y,z),ds;
  ideal j1= imap(r1,j1);         // imap is a convenient ringmap for
  ideal j2= imap(r1,j2);         // inclusions and projections of rings
  ideal i = intersect(j1,j2);
  i;                             // equations of both branches
@expansion{} i[1]=z2-y3+x3y
@expansion{} i[2]=xz
@expansion{} i[3]=xy2-x4
@expansion{} i[4]=x3z
  //
  // 2. Compute the weights:
  intvec v= qhweight(i);         // compute weights
  v;
@expansion{} 4,6,9
  //
  // 3. Compute the tangent developable
  // The tangent developable of a projective variety given parametrically
  // by F=(f1,...,fn) : P^r --> P^n is the union of all tangent spaces
  // of the image. The tangent space at a smooth point F(t1,...,tr)
  // is given as the image of the tangent space at (t1,...,tr) under
  // the tangent map (affine coordinates)
  //   T(t1,...,tr): (y1,...,yr) --> jacob(f)*transpose((y1,...,yr))
  // where jacob(f) denotes the jacobian matrix of f with respect to the
  // t's evaluated at the point (t1,...,tr).
  // Hence we have to create the graph of this map and then to eliminate
  // the t's and y's.
  // The rational normal curve in P^4 is given as the image of
  //        F(s,t) = (s4,s3t,s2t2,st3,t4)
  // each component being homogeneous of degree 4.
  ring P = 0,(s,t,x,y,a,b,c,d,e),dp;
  ideal M = maxideal(1);
  ideal F = M[1..2];     // take the 1st two generators of M
  F=F^4;
  // simplify(...,2); deletes 0-columns
  matrix jac = simplify(jacob(F),2);
  ideal T = x,y;
  ideal J = jac*transpose(T);
  ideal H = M[5..9];
  ideal i = H-J;         // this is tricky: difference between two
                         // ideals is not defined, but between two
                         // matrices. By automatic type conversion
                         // the ideals are converted to matrices,
                         // subtracted and afterwards converted
                         // to an ideal. Note that '+' is defined
                         // and adds (concatenates) two ideals
  i;
@expansion{} i[1]=-4s3x+a
@expansion{} i[2]=-3s2tx-s3y+b
@expansion{} i[3]=-2st2x-2s2ty+c
@expansion{} i[4]=-t3x-3st2y+d
@expansion{} i[5]=-4t3y+e
  // Now we define a ring with product ordering and weights 4
  // for the variables a,...,e.
  // Then we map i from P to P1 and eliminate s,t,x,y from i.
  ring P1 = 0,(s,t,x,y,a,b,c,d,e),(dp(4),wp(4,4,4,4,4));
  ideal i = fetch(P,i);
  ideal j= eliminate(i,stxy);    // equations of tangent developable
  j;
@expansion{} j[1]=3c2-4bd+ae
@expansion{} j[2]=2bcd-3ad2-3b2e+4ace
@expansion{} j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde
  // We can use the product ordering to eliminate s,t,x,y from i
  // by a std-basis computation.
  // We need proc 'nselect' from elim.lib.
  LIB "elim.lib";
  j = std(i);                    // compute a std basis j
  j = nselect(j,1,4);            // select generators from j not
  j;                             // containing variable 1,...,4
@expansion{} j[1]=3c2-4bd+ae
@expansion{} j[2]=2bcd-3ad2-3b2e+4ace
@expansion{} j[3]=8b2d2-9acd2-9b2ce+12ac2e-2abde
@c end example Elimination examples.doc:1058
@end smallexample
@c  killall();


@c ----------------------------------------------------------------------------
@node Free resolution, Computation of Ext, Elimination, Examples
@section  Free resolution
@cindex  Free resolution

In @sc{Singular} a free resolution of a module or ideal has its own type:
@code{resolution}. It is a structure that stores all information related to
free resolutions. This allows partial computations of resolutions via
the command @code{res}. After applying @code{res}, only a pre-format of the
resolution is computed which allows to determine invariants like
Betti-numbers or homological dimension. To see the differentials
of the complex, a resolution must be converted into the type list which
yields a list of modules: the k-th module in this
list is the first syzygy-module (module of relations) of the (k-1)st module.
There are the following commands to compute a resolution:
@table @code
@item res
@ref{res}@*
computes a free resolution of an ideal or module using a heuristically
chosen method.
This is the preferred method to compute free resolutions of ideals or
modules.
@item lres
@ref{lres}@*
computes a free resolution of an ideal or module with La Scala's
method. The input needs to be homogeneous.
@item mres
@ref{mres}@*
computes a minimal free resolution of an ideal or module with the syzygy
method.
@item sres
@ref{sres}@*
computes a free resolution of an ideal or module with Schreyer's
method. The input has to be a standard basis.
@item nres
@ref{nres}@*
computes a free resolution of an ideal or module with the standard basis
method.
@item minres
@ref{minres}@*
minimizes a free resolution of an ideal or module.
@item syz
@ref{syz}@*
computes the first syzygy module.
@end table
@code{res(i,r)}, @code{lres(i,r)}, @code{sres(i,r)}, @code{mres(i,r)},
@code{nres(i,r)} compute the first r modules of the resolution
of i, resp.@: the full resolution if r=0 and the basering is not a qring.
See the manual for a precise description of these commands.
@*Note: The command @code{betti} does not require a minimal
resolution for the minimal betti numbers.

Now let's look at an example which uses resolutions: The Hilbert-Burch
theorem says that the ideal i of a reduced curve in
@tex
$K^3$
@end tex
K^3
has a free resolution of length 2 and that i is given by the 2x2 minors
of the 2nd matrix in the resolution.
We test this for two transversal cusps in
@tex
$K^3$.
@end tex
K^3.
Afterwards we compute the resolution of the ideal j of the tangent developable
of the rational normal curve in
@tex
$P^4$
@end tex
P^4
from above.
Finally we demonstrate the use of the type @code{resolution} in connection with
the @code{lres} command.

@smallexample
@c computed example Free_resolution examples.doc:1231 
  // Two transversal cusps in (k^3,0):
  ring r2 =0,(x,y,z),ds;
  ideal i =z2-1y3+x3y,xz,-1xy2+x4,x3z;
  resolution rs=mres(i,0);   // computes a minimal resolution
  rs;                        // the standard representation of complexes
@expansion{}   1       3       2       
@expansion{} r2 <--  r2 <--  r2
@expansion{} 
@expansion{} 0       1       2       
@expansion{} 
    list resi=rs;            // convertion to a list
  print(resi[1]);            // the 1st module is i minimized
@expansion{} xz,
@expansion{} z2-y3+x3y,
@expansion{} xy2-x4
  print(resi[2]);            // the 1st syzygy module of i
@expansion{} -z,-y2+x3,
@expansion{} x, 0,     
@expansion{} y, z      
  resi[3];                   // the 2nd syzygy module of i
@expansion{} _[1]=0
  ideal j=minor(resi[2],2);
  reduce(j,std(i));          // check whether j is contained in i
@expansion{} _[1]=0
@expansion{} _[2]=0
@expansion{} _[3]=0
  size(reduce(i,std(j)));    // check whether i is contained in j
@expansion{} 0
  // size(<ideal>) counts the non-zero generators
  // ---------------------------------------------
  // The tangent developable of the rational normal curve in P^4:
  ring P = 0,(a,b,c,d,e),dp;
  ideal j= 3c2-4bd+ae, -2bcd+3ad2+3b2e-4ace,
           8b2d2-9acd2-9b2ce+9ac2e+2abde-1a2e2;
  resolution rs=mres(j,0);
  rs;
@expansion{}  1      2      1      
@expansion{} P <--  P <--  P
@expansion{} 
@expansion{} 0      1      2      
@expansion{} 
  list L=rs;
  print(L[2]);
@expansion{} 2bcd-3ad2-3b2e+4ace,
@expansion{} -3c2+4bd-ae         
  // create an intmat with graded betti numbers
  intmat B=betti(rs);
  // this gives a nice output of betti numbers
  print(B,"betti");
@expansion{}            0     1     2
@expansion{} ------------------------
@expansion{}     0:     1     -     -
@expansion{}     1:     -     1     -
@expansion{}     2:     -     1     -
@expansion{}     3:     -     -     1
@expansion{} ------------------------
@expansion{} total:     1     2     1
  // the user has access to all betti numbers
  // the 2-nd column of B:
  B[1..4,2];
@expansion{} 0 1 1 0
  ring cyc5=32003,(a,b,c,d,e,h),dp;
  ideal i=
  a+b+c+d+e,
  ab+bc+cd+de+ea,
  abc+bcd+cde+dea+eab,
  abcd+bcde+cdea+deab+eabc,
  h5-abcde;
  resolution rs=lres(i,0);   //computes the resolution according La Scala
  rs;                        //the shape of the minimal resolution
@expansion{}     1         5         10         10         5         1         
@expansion{} cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
@expansion{} 
@expansion{} 0         1         2          3          4         5         
@expansion{} resolution not minimized yet
@expansion{} 
  print(betti(rs),"betti");  //shows the Betti-numbers of cyclic 5
@expansion{}            0     1     2     3     4     5
@expansion{} ------------------------------------------
@expansion{}     0:     1     1     -     -     -     -
@expansion{}     1:     -     1     1     -     -     -
@expansion{}     2:     -     1     1     -     -     -
@expansion{}     3:     -     1     2     1     -     -
@expansion{}     4:     -     1     2     1     -     -
@expansion{}     5:     -     -     2     2     -     -
@expansion{}     6:     -     -     1     2     1     -
@expansion{}     7:     -     -     1     2     1     -
@expansion{}     8:     -     -     -     1     1     -
@expansion{}     9:     -     -     -     1     1     -
@expansion{}    10:     -     -     -     -     1     1
@expansion{} ------------------------------------------
@expansion{} total:     1     5    10    10     5     1
  dim(rs);                   //the homological dimension
@expansion{} 4
  size(list(rs));            //gets the full (non-reduced) resolution
@expansion{} 6
  minres(rs);                //minimizes the resolution
@expansion{}     1         5         10         10         5         1         
@expansion{} cyc5 <--  cyc5 <--  cyc5 <--   cyc5 <--   cyc5 <--  cyc5
@expansion{} 
@expansion{} 0         1         2          3          4         5         
@expansion{} 
  size(list(rs));            //gets the minimized resolution
@expansion{} 6
@c end example Free_resolution examples.doc:1231
@end smallexample


@c ----------------------------------------------------------------------------
@node Computation of Ext, Polar curves, Free resolution, Examples
@section  Computation of Ext
@cindex  Ext

We start by showing how to calculate the 
@math{n}
@tex
$n$
@end tex
-th Ext group of an
ideal. The ingredients to do this are by the definition of Ext the
following: calculate a (minimal) resolution at least up to length

@math{n}
@tex
$n$
@end tex
, apply the Hom-functor, and calculate the 
@math{n}
@tex
$n$
@end tex
-th homology
group, that is form the quotient
@tex
$\hbox{\rm ker} / \hbox{\rm Im}$
@end tex
ker/Im
in the resolution sequence.

The Hom functor is given simply by transposing (hence dualizing) the
module or the corresponding matrix with the command @code{transpose}.
The image of the 
@math{(n-1)}
@tex
$(n-1)$
@end tex
-st map is generated by the columns of the
corresponding matrix. To calculate the kernel apply the command
@code{syz} at the 
@math{(n-1)}
@tex
$(n-1)$
@end tex
-st transposed entry of the resolution.
Finally, the quotient is obtained by the command @code{modulo}, which
gives for two modules A = ker, B = Im the module of relations of
@tex
$A/(A \cap B)$
@end tex
A/(A intersect B)
in the usual way. As we have a chain complex this is obviously the same
as ker/Im.

We collect these statements in the following short procedure:

@smallexample
proc ext(int n, ideal I)
@{
  resolution rs = mres(I,n+1);
  module tAn    = transpose(rs[n+1]);
  module tAn_1  = transpose(rs[n]);
  module ext_n  = modulo(syz(tAn),tAn_1);
  return(ext_n);
@}
@end smallexample

Now consider the following example:

@smallexample
ring r5 = 32003,(a,b,c,d,e),dp;
ideal I = a2b2+ab2c+b2cd, a2c2+ac2d+c2de,a2d2+ad2e+bd2e,a2e2+abe2+bce2;
print(ext(2,I));
@expansion{} 1,0,0,0,0,0,0,
@expansion{} 0,1,0,0,0,0,0,
@expansion{} 0,0,1,0,0,0,0,
@expansion{} 0,0,0,1,0,0,0,
@expansion{} 0,0,0,0,1,0,0,
@expansion{} 0,0,0,0,0,1,0,
@expansion{} 0,0,0,0,0,0,1
ext(3,I);   // too big to be displayed here
@end smallexample

The library @code{homolog.lib} contains several procedures for computing
Ext-modules and related modules, which are much more general and
sophisticated then the above one. They are used in the following
example.

If 
@math{M}
@tex
$M$
@end tex
 is a module, then
@tex
$\hbox{Ext}^1(M,M)$, resp.\ $\hbox{Ext}^2(M,M)$,
@end tex
Ext^1(M,M), resp.@: Ext^2(M,M),
are the modules of infinitesimal deformations, resp.@: of obstructions, of

@math{M}
@tex
$M$
@end tex
 (like T1 and T2 for a singularity).  Similar to the treatment
for singularities, the semiuniversal deformation of 
@math{M}
@tex
$M$
@end tex
 can be
computed (if
@tex
$\hbox{Ext}^1$
@end tex
Ext^1
is finite dimensional) with the help of
@tex
$\hbox{Ext}^1$, $\hbox{Ext}^2$
@end tex
Ext^1, Ext^2
and the cup product. There is an extra procedure for
@tex
$\hbox{Ext}^k(R/J,R)$
@end tex
Ext^k(R/J,R)
if 
@math{J}
@tex
$J$
@end tex
 is an ideal in 
@math{R}
@tex
$R$
@end tex
 since this is faster than the
general Ext.

We compute
@itemize @bullet
@item
the infinitesimal deformations
@tex
($=\hbox{Ext}^1(K,K)$)
@end tex
(=Ext^1(K,K))
and obstructions
@tex
($=\hbox{Ext}^2(K,K)$)
@end tex
(=Ext^2(K,K))
of the residue field 
@math{K=R/m}
@tex
$K=R/m$
@end tex
 of an ordinary cusp,
@tex
$R=Loc_m K[x,y]/(x^2-y^3)$, $m=(x,y)$.
@end tex
R=Loc_m K[x,y]/(x^2-y^3), m=(x,y).
To compute
@tex
$\hbox{Ext}^1(m,m)$
@end tex
Ext^1(m,m),
we have to apply @code{Ext(1,syz(m),syz(m))} with
@code{syz(m)} the first syzygy module of 
@math{m}
@tex
$m$
@end tex
, which is isomorphic to
@tex
$\hbox{Ext}^2(K,K)$.
@end tex
Ext^2(K,K).
@item
@tex
$\hbox{Ext}^k(R/i,R)$
@end tex
Ext^k(R/i,R)
for some ideal 
@math{i}
@tex
$i$
@end tex
 and with an extra option.
@end itemize

@smallexample
@c computed example Computation_of_Ext examples.doc:1432 
  LIB "homolog.lib";
  ring R=0,(x,y),ds;
  ideal i=x2-y3;
  qring q = std(i);      // defines the quotient ring Loc_m k[x,y]/(x2-y3)
  ideal m = maxideal(1);
  module T1K = Ext(1,m,m);  // computes Ext^1(R/m,R/m)
@expansion{} // dimension of Ext^1:  0
@expansion{} // vdim of Ext^1:       2
@expansion{} 
  print(T1K);
@expansion{} 0,  0,y,x,0,y,0,    x2-y3,
@expansion{} -y2,x,x,0,y,0,x2-y3,0,    
@expansion{} 1,  0,0,0,0,0,0,    0     
  printlevel=2;             // gives more explanation
  module T2K=Ext(2,m,m);    // computes Ext^2(R/m,R/m)
@expansion{} // Computing Ext^2 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F2,G0)-->Hom(F3,G0) is given by:
@expansion{} y2,x,
@expansion{} x, y 
@expansion{} // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
@expansion{} -y,x,  x,0,y,0,
@expansion{} x, -y2,0,x,0,y 
@expansion{} 
@expansion{} // dimension of Ext^2:  0
@expansion{} // vdim of Ext^2:       2
@expansion{} 
  print(std(T2K));
@expansion{} -y2,0,x,0,y,
@expansion{} 0,  x,0,y,0,
@expansion{} 1,  0,0,0,0 
  printlevel=0;
  module E = Ext(1,syz(m),syz(m));
@expansion{} // dimension of Ext^1:  0
@expansion{} // vdim of Ext^1:       2
@expansion{} 
  print(std(E));
@expansion{} -y,x, 0, 0,0,x,0,y,
@expansion{} 0, -y,-y,0,x,0,y,0,
@expansion{} 0, 0, 0, 1,0,0,0,0,
@expansion{} 0, 0, 1, 0,0,0,0,0,
@expansion{} 0, 1, 0, 0,0,0,0,0,
@expansion{} 1, 0, 0, 0,0,0,0,0 
  //The matrices which we have just computed are presentation matrices
  //of the modules T2K and E. Hence we may ignore those columns
  //containing 1 as an entry and see that T2K and E are isomorphic
  //as expected, but differently presented.
  //-------------------------------------------
  ring S=0,(x,y,z),dp;
  ideal  i = x2y,y2z,z3x;
  module E = Ext_R(2,i);
@expansion{} // dimension of Ext^2:  1
@expansion{} 
  print(E);
@expansion{} 0,y,0,z2,
@expansion{} z,0,0,-x,
@expansion{} 0,0,x,-y 
  // if a 3-rd argument is given (of any type)
  // a list of Ext^k(R/i,R), a SB of Ext^k(R/i,R) and a vector space basis
  // is returned:
  list LE = Ext_R(3,i,"");
@expansion{} // dimension of Ext^3:  0
@expansion{} // vdim of Ext^3:       2
@expansion{} 
  LE;
@expansion{} [1]:
@expansion{}    _[1]=y*gen(1)
@expansion{}    _[2]=x*gen(1)
@expansion{}    _[3]=z2*gen(1)
@expansion{} [2]:
@expansion{}    _[1]=y*gen(1)
@expansion{}    _[2]=x*gen(1)
@expansion{}    _[3]=z2*gen(1)
@expansion{} [3]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=1
  print(LE[2]);
@expansion{} y,x,z2
  print(kbase(LE[2]));
@expansion{} z,1
@c end example Computation_of_Ext examples.doc:1432
@end smallexample
@c  killall();
@c ----------------------------------------------------------------------------
@node Polar curves, Depth, Computation of Ext, Examples
@section   Polar curves
@cindex Polar curves

The polar curve of a hypersurface given by a polynomial
@tex
$f\in k[x_1,\ldots,x_n,t]$
@end tex
f in k[x1,...,xn,t]
with respect to 
@math{t}
@tex
$t$
@end tex
 (we may consider 
@math{f=0}
@tex
$f=0$
@end tex
 as a family of
hypersurfaces parametrized by 
@math{t}
@tex
$t$
@end tex
) is defined as the Zariski
closure of
@tex
$V(\partial f/\partial x_1,\ldots,\partial f/\partial x_n) \setminus V(f)$
@end tex
V(diff(f,x1),...,diff(f,xn)) \ V(f)
if this happens to be a curve.  Some authors consider
@tex
$V(\partial f/\partial x_1,\ldots,\partial f/\partial x_n)$
@end tex
V(diff(f,x1),...,diff(f,xn))
itself as polar curve.

We may consider projective hypersurfaces
@tex
(in $P^n$),
@end tex
(in P^n),
affine hypersurfaces
@tex
(in $k^n$)
@end tex
(in k^n)
or germs of hypersurfaces
@tex
(in $(k^n,0)$),
@end tex
(in (k^n,0)),
getting in this way
projective, affine or local polar curves.

Now let us compute this for a family of curves.  We need the library
@code{elim.lib} for saturation and @code{sing.lib} for the singular
locus.

@smallexample
@c computed example Polar_curves examples.doc:1526 
  LIB "elim.lib";
  LIB "sing.lib";
  // Affine polar curve:
  ring R = 0,(x,z,t),dp;              // global ordering dp
  poly f = z5+xz3+x2-tz6;
  dim_slocus(f);                      // dimension of singular locus
@expansion{} 1
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // dim V(j)
@expansion{} 1
  dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
@expansion{} 1
  // j defines a curve, but to get the polar curve we must remove the
  // branches contained in f=0 (they exist since dim V(j,f) = 1). This
  // gives the polar curve set theoretically. But for the structure we
  // may take either j:f or j:f^k for k sufficiently large. The first is
  // just the ideal quotient, the second the iterated ideal quotient
  // or saturation. In our case both coincide.
  ideal q = quotient(j,ideal(f));     // ideal quotient
  ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
  ideal sq = std(q);
  dim(sq);
@expansion{} 1
  // 1-dimensional, hence q defines the affine polar curve
  //
  // to check that q and qsat are the same, we show both inclusions, i.e.,
  // both reductions must give the 0-ideal
  size(reduce(qsat,sq));
@expansion{} 0
  size(reduce(q,std(qsat)));
@expansion{} 0
  qsat;
@expansion{} qsat[1]=12zt+3z-10
@expansion{} qsat[2]=5z2+12xt+3x
@expansion{} qsat[3]=144xt2+72xt+9x+50z
  // We see that the affine polar curve does not pass through the origin,
  // hence we expect the local polar "curve" to be empty
  // ------------------------------------------------
  // Local polar curve:
  ring r = 0,(x,z,t),ds;              // local ordering ds
  poly f = z5+xz3+x2-tz6;
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // V(j) 1-dimensional
@expansion{} 1
  dim(std(j+ideal(f)));               // V(j,f) also 1-dimensional
@expansion{} 1
  ideal q = quotient(j,ideal(f));     // ideal quotient
  q;
@expansion{} q[1]=1
  // The local polar "curve" is empty, i.e., V(j) is contained in V(f)
  // ------------------------------------------------
  // Projective polar curve: (we need "sing.lib" and "elim.lib")
  ring P = 0,(x,z,t,y),dp;            // global ordering dp
  poly f = z5y+xz3y2+x2y4-tz6;
                                      // but consider t as parameter
  dim_slocus(f);              // projective 1-dimensional singular locus
@expansion{} 2
  ideal j = diff(f,x),diff(f,z);
  dim(std(j));                        // V(j), projective 1-dimensional
@expansion{} 2
  dim(std(j+ideal(f)));               // V(j,f) also projective 1-dimensional
@expansion{} 2
  ideal q = quotient(j,ideal(f));
  ideal qsat = sat(j,f)[1];           // saturation, proc from elim.lib
  dim(std(qsat));
@expansion{} 2
  // projective 1-dimensional, hence q and/or qsat define the projective
  // polar curve. In this case, q and qsat are not the same, we needed
  // 2 quotients.
  // Let us check both reductions:
  size(reduce(qsat,std(q)));
@expansion{} 4
  size(reduce(q,std(qsat)));
@expansion{} 0
  // Hence q is contained in qsat but not conversely
  q;
@expansion{} q[1]=12zty+3zy-10y2
@expansion{} q[2]=60z2t-36xty-9xy-50zy
  qsat;
@expansion{} qsat[1]=12zt+3z-10y
@expansion{} qsat[2]=12xty+5z2+3xy
@expansion{} qsat[3]=144xt2+72xt+9x+50z
@expansion{} qsat[4]=z3+2xy2
  //
  // Now consider again the affine polar curve,
  // homogenize it with respect to y (deg t=0) and compare:
  // affine polar curve:
  ideal qa = 12zt+3z-10,5z2+12xt+3x,-144xt2-72xt-9x-50z;
  // homogenized:
  ideal qh = 12zt+3z-10y,5z2+12xyt+3xy,-144xt2-72xt-9x-50z;
  size(reduce(qh,std(qsat)));
@expansion{} 0
  size(reduce(qsat,std(qh)));
@expansion{} 0
  // both ideals coincide
@c end example Polar_curves examples.doc:1526
@end smallexample
@c ----------------------------------------------------------------------------
@node Depth, Formatting output, Polar curves, Examples
@section Depth
@cindex Depth

We compute the depth of the module of Kaehler differentials
@tex
D$_k$(R)
@end tex
D_k(R)
of the variety defined by the 
@math{(m+1)}
@tex
$(m+1)$
@end tex
-minors of a generic symmetric
@tex
$(n \times n)$-matrix.
@end tex
(n x n)-matrix.
We do this by computing the resolution over the polynomial
ring.  Then, by the Auslander-Buchsbaum formula, the depth is equal to
the number of variables minus the length of a minimal resolution.  This
example was suggested by U.@: Vetter in order to check whether his bound
@tex
$\hbox{depth}(\hbox{D}_k(R))\geq m(m+1)/2 + m-1$
@end tex
depth(D_k(R)) >= m(m+1)/2 + m-1
could be improved.

@smallexample
@c computed example Depth examples.doc:1632 
  LIB "matrix.lib"; LIB "sing.lib";
  int n = 4;
  int m = 3;
  int N = n*(n+1)/2;           // will become number of variables
  ring R = 32003,x(1..N),dp;
  matrix X = symmat(n);        // proc from matrix.lib
                               // creates the symmetric generic nxn matrix
  print(X);
@expansion{} x(1),x(2),x(3),x(4),
@expansion{} x(2),x(5),x(6),x(7),
@expansion{} x(3),x(6),x(8),x(9),
@expansion{} x(4),x(7),x(9),x(10)
  ideal J = minor(X,m);
  J=std(J);
  // Kaehler differentials D_k(R)
  // of R=k[x1..xn]/J:
  module D = J*freemodule(N)+transpose(jacob(J));
  ncols(D);
@expansion{} 110
  nrows(D);
@expansion{} 10
  //
  // Note: D is a submodule with 110 generators of a free module
  // of rank 10 over a polynomial ring in 10 variables.
  // Compute a full resolution of D with sres.
  // This takes about 17 sec on a Mac PB 520c and 2 sec an a HP 735
  int time = timer;
  module sD = std(D);
  list Dres = sres(sD,0);                // the full resolution
  timer-time;                            // time used for std + sres
@expansion{} 0
  intmat B = betti(Dres);
  print(B,"betti");
@expansion{}            0     1     2     3     4     5     6
@expansion{} ------------------------------------------------
@expansion{}     0:    10     -     -     -     -     -     -
@expansion{}     1:     -    10     -     -     -     -     -
@expansion{}     2:     -    84   144    60     -     -     -
@expansion{}     3:     -     -    35    80    60    16     1
@expansion{} ------------------------------------------------
@expansion{} total:    10    94   179   140    60    16     1
  N-ncols(B)+1;                          // the desired depth
@expansion{} 4
@c end example Depth examples.doc:1632
@end smallexample
@c  killall();

@c ----------------------------------------------------------------------------
@node Formatting output, Cyclic roots, Depth, Examples
@section Formatting output
@cindex Formatting output

We show how to insert the result of a computation inside a text
by using strings.
First we compute the powers of 2 and comment the result with some text.
Then we do the same and give the output a nice format by computing and
adding appropriate space.

@smallexample
@c computed example Formatting_output examples.doc:1682 
  // The powers of 2:
  int  n;
  for (n = 2; n <= 128; n = n * 2)
  @{"n = " + string (n);@}
@expansion{} n = 2
@expansion{} n = 4
@expansion{} n = 8
@expansion{} n = 16
@expansion{} n = 32
@expansion{} n = 64
@expansion{} n = 128
  // The powers of 2 in a nice format
  int j;
  string space = "";
  for (n = 2; n <= 128; n = n * 2)
  @{
    space = "";
    for (j = 1; j <= 5 - size (string (n)); j = j+1)
    @{ space = space + " "; @}
    "n =" + space + string (n);
  @}
@expansion{} n =    2
@expansion{} n =    4
@expansion{} n =    8
@expansion{} n =   16
@expansion{} n =   32
@expansion{} n =   64
@expansion{} n =  128
@c end example Formatting_output examples.doc:1682
@end smallexample

@c ----------------------------------------------------------------------------
@node Cyclic roots, G_a -Invariants, Formatting output, Examples
@section Cyclic roots
@cindex Cyclic roots

We write a procedure returning a string that enables us to create
automatically the ideal of cyclic roots over the basering with n
variables. The procedure assumes that the variables consist of a single
letter each (hence no indexed variables are allowed; the procedure
@code{cyclic} in @code{poly.lib} does not have this restriction). Then
we compute a standard basis of this ideal and some numerical
information.  (This ideal is used as a classical benchmark for standard
basis computations).

@smallexample
// We call the procedure 'cyclic':
proc cyclic (int n)
@{
   string vs = varstr(basering)+varstr(basering);
   int c=find(vs,",");
   while ( c!=0 )
   @{
      vs=vs[1,c-1]+vs[c+1,size(vs)];
      c=find(vs,",");
   @}
   string t,s;
   int i,j;
   for ( j=1; j<=n-1; j=j+1 )
   @{
      t="";
      for ( i=1; i <=n; i=i+1 )
      @{
         t = t + vs[i,j] + "+";
      @}
      t = t[1,size(t)-1] + ","+newline;
      s=s+t;
   @}
   s=s+vs[1,n]+"-1";
   return (s);
@}

ring r=0,(a,b,c,d,e),lp;         // basering, char 0, lex ordering
string sc=cyclic(nvars(basering));
sc;                              // the string of the ideal
@expansion{} a+b+c+d+e,
@expansion{} ab+bc+cd+de+ea,
@expansion{} abc+bcd+cde+dea+eab,
@expansion{} abcd+bcde+cdea+deab+eabc,
@expansion{} abcde-1
execute("ideal i="+sc+";");      // this defines the ideal of cyclic roots
i;
@expansion{} i[1]=a+b+c+d+e
@expansion{} i[2]=ab+bc+cd+ae+de
@expansion{} i[3]=abc+bcd+abe+ade+cde
@expansion{} i[4]=abcd+abce+abde+acde+bcde
@expansion{} i[5]=abcde-1
timer=1;
ideal j=std(i);
@expansion{} //used time: 7.5 sec
size(j);                         // number of elements in the std basis
@expansion{} 11
degree(j);
@expansion{} // codimension = 5
@expansion{} // dimension   = 0
@expansion{} // degree      = 70
@end smallexample
@c ----------------------------------------------------------------------------
@node G_a -Invariants, Invariants of a finite group, Cyclic roots, Examples
@section G_a -Invariants
@cindex G_a -Invariants

We work in characteristic 0 and use the Lie algebra generated by one
vector field of the form
@tex
$\sum x_i \partial /\partial x_{i+1}$.
@end tex
sum x(i)*d/dx(i+1).
@smallexample
@c computed example G_a_-Invariants examples.doc:1783 
  LIB "ainvar.lib";
  int n=5;
  int i;
  ring s=32003,(x(1..n)),wp(1,2,3,4,5);
  // definition of the vector field m=sum m[i,1]*d/dx(i)
  matrix m[n][1];
  for (i=1;i<=n-1;i=i+1)
  @{
     m[i+1,1]=x(i);
  @}
  // computation of the ring of invariants
  ideal in=invariantRing(m,x(2),x(1),0);
  in;   //invariant ring is generated by 5 invariants
@expansion{} in[1]=x(1)
@expansion{} in[2]=x(2)^2-2*x(1)*x(3)
@expansion{} in[3]=x(3)^2-2*x(2)*x(4)+2*x(1)*x(5)
@expansion{} in[4]=x(2)^3-3*x(1)*x(2)*x(3)+3*x(1)^2*x(4)
@expansion{} in[5]=x(3)^3-3*x(2)*x(3)*x(4)-15997*x(1)*x(4)^2+3*x(2)^2*x(5)-6*x(1)*x(3)\
   *x(5)
  ring q=32003,(x,y,z,u,v,w),dp;
  matrix m[6][1];
  m[2,1]=x;
  m[3,1]=y;
  m[5,1]=u;
  m[6,1]=v;
  // the vector field is: xd/dy+yd/dz+ud/dv+vd/dw
  ideal in=invariantRing(m,y,x,0);
  in; //invariant ring is generated by 6 invariants
@expansion{} in[1]=x
@expansion{} in[2]=u
@expansion{} in[3]=v2-2uw
@expansion{} in[4]=zu-yv+xw
@expansion{} in[5]=yu-xv
@expansion{} in[6]=y2-2xz
@c end example G_a_-Invariants examples.doc:1783
@end smallexample
@c kill n,i,s,q;
@c ----------------------------------------------------------------------------
@node Invariants of a finite group, Factorization, G_a -Invariants, Examples
@section Invariants of a finite group
@cindex Invariants of a finite group

Two algorithms to compute the invariant ring are implemented in
@sc{Singular}, @code{invariant_ring} and @code{invariant_ring_random},
both by Agnes E. Heydtmann (@code{agnes@@math.uni-sb.de}).

Bases of homogeneous invariants are generated successively and those are
chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1997) to appear in JSC).  In the
non-modular case secondary invariants are calculated by finding a basis
(in terms of monomials) of the basering modulo the primary invariants,
mapping to invariants with the Reynolds operator and using those or
their power products such that they are linearly independent modulo the
primary invariants (see paper "Some Algorithms in Invariant Theory of
Finite Groups" by Kemper and Steel (1997)).  In the modular case they
are generated according to "Generating Invariant Rings of Finite Groups
over Arbitrary Fields" by Kemper (1996, to appear in JSC).

We calculate now an example from Sturmfels: "Algorithms in Invariant
Theory 2.3.7":

@smallexample
@c computed example Invariants_of_a_finite_group examples.doc:1838 
  LIB "finvar.lib";
  ring R=0,(x,y,z),dp;
  matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
  // the group G is generated by A in Gl(3,Q);
  print(A);
@expansion{} 0, 1,0,
@expansion{} -1,0,0,
@expansion{} 0, 0,-1
  print(A*A*A*A); // the fourth power of A is 1
@expansion{} 1,0,0,
@expansion{} 0,1,0,
@expansion{} 0,0,1 
  // Use the first method to compute the invariants of G:
  matrix B(1..3);
  B(1..3)=invariant_ring(A);
  // SINGULAR returns 2 matrices, the first containing
  // primary invariants and the second secondary
  // invariants, i.e., module generators over a Noetherian
  // normalization
  // the third result are the irreducible secondary invariants
  // if the Molien series was available
  print(B(1));
@expansion{} z2,x2+y2,x2y2
  print(B(2));
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
  print(B(3));
@expansion{} xyz,x2z-y2z,x3y-xy3
  // Use the second method,
  // with random numbers between -1 and 1:
  B(1..3)=invariant_ring_random(A,1);
  print(B(1..3));
@expansion{} z2,x2+y2,x4+y4-z4
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
@expansion{} xyz,x2z-y2z,x3y-xy3
@c end example Invariants_of_a_finite_group examples.doc:1838
@end smallexample
@c ----------------------------------------------------------------------------
@node Factorization, Puiseux pairs, Invariants of a finite group, Examples
@section Factorization
@cindex Factorization

The factorization of polynomials is implemented in the C++ libraries
Factory (written mainly by Ruediger Stobbe) and libfac (written by
Michael Messollen) which are part of the @sc{Singular} system.

@smallexample
@c computed example Factorization examples.doc:1879 
  ring r = 0,(x,y),dp;
  poly f = 9x16-18x13y2-9x12y3+9x10y4-18x11y2+36x8y4
         +18x7y5-18x5y6+9x6y4-18x3y6-9x2y7+9y8;
  // = 9 * (x5-1y2)^2 * (x6-2x3y2-1x2y3+y4)
  factorize(f);
@expansion{} [1]:
@expansion{}    _[1]=9
@expansion{}    _[2]=x6-2x3y2-x2y3+y4
@expansion{}    _[3]=-x5+y2
@expansion{} [2]:
@expansion{}    1,1,2
  // returns factors and multiplicities,
  // first factor is a constant.
  poly g = (y4+x8)*(x2+y2);
  factorize(g);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x8+y4
@expansion{}    _[3]=x2+y2
@expansion{} [2]:
@expansion{}    1,1,1
  // The same in characteristic 2:
  ring s =2,(x,y),dp;
  poly g = (y4+x8)*(x2+y2);
  factorize(g);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x+y
@expansion{}    _[3]=x2+y
@expansion{} [2]:
@expansion{}    1,2,4
@c end example Factorization examples.doc:1879
@end smallexample

@c ----------------------------------------------------------------------------
@node Puiseux pairs, Primary decomposition, Factorization, Examples
@section Puiseux pairs
@cindex Puiseux pairs

The Puiseux pairs of an irreducible and reduced curve singularity are
its most important invariants.  They can be computed from its
Hamburger-Noether expansion.  The library @code{hnoether.lib} written by
Martin Lamm uses the algorithm of Antonio Campillo "Algebroid curves in
positive characteristic" SLN 813, 1980.  This algorithm has the
advantage that it needs least possible field extensions and, moreover,
works in any characteristic. This fact can be used to compute the
invariants over a field of finite characteristic, say 32003, which will
then most probably be the same in characteristic 0.

We compute the Hamburger-Noether expansion of a plane curve
singularity given by a polynomial 
@math{f}
@tex
$f$
@end tex
 in two variables. This is a
matrix which allows to compute the parametrization (up to a given order)
and all numerical invariants like the
@itemize @bullet
@item
    characteristic exponents,
@item
    Puiseux pairs (of a complex model),
@item
    degree of the conductor,
@item
    delta invariant,
@item
    generators of the semigroup.
@end itemize
Besides this, the library contains procedures to compute the Newton
polygon of 
@math{f}
@tex
$f$
@end tex
, the squarefree part of 
@math{f}
@tex
$f$
@end tex
 and a procedure to
convert one set of invariants to another.


@smallexample
@c computed example Puiseux_pairs examples.doc:1934 
  LIB "hnoether.lib";
  // ======== The irreducible case ========
  ring s = 0,(x,y),ds;
  poly f = y4-2x3y2-4x5y+x6-x7;
  list hn = develop(f);
  show(hn[1]);     // Hamburger-Noether matrix
@expansion{} // matrix, 3x3
@expansion{} 0,x,  0,  
@expansion{} 0,1,  x,  
@expansion{} 0,1/4,-1/2
  displayHNE(hn);  // Hamburger-Noether development
@expansion{} HNE[1]=-y+z(0)*z(1)
@expansion{} HNE[2]=-x+z(1)^2+z(1)^2*z(2)
@expansion{} HNE[3]=1/4*z(2)^2-1/2*z(2)^3
  setring s;
  displayInvariants(hn);
@expansion{}  characteristic exponents  : 4,6,7
@expansion{}  generators of semigroup   : 4,6,13
@expansion{}  Puiseux pairs             : (3,2)(7,2)
@expansion{}  degree of the conductor   : 16
@expansion{}  delta invariant           : 8
@expansion{}  sequence of multiplicities: 4,2,2,1,1
  // invariants(hn);  returns the invariants as list
  // partial parametrization of f: param takes the first variable
  // as infinite except the ring has more than 2 variables. Then
  // the 3rd variable is chosen.
  param(hn);
@expansion{} // ** Warning: result is exact up to order 5 in x and 7 in y !
@expansion{} _[1]=1/16x4-3/16x5+1/4x7
@expansion{} _[2]=1/64x6-5/64x7+3/32x8+1/16x9-1/8x10
  ring extring=0,(x,y,t),ds;
  poly f=x3+2xy2+y2;
  list hn=develop(f,-1);
  param(hn);       // partial parametrization of f
@expansion{} // ** Warning: result is exact up to order 2 in x and 3 in y !
@expansion{} _[1]=-t2
@expansion{} _[2]=-t3
  list hn1=develop(f,6);
  param(hn1);     // a better parametrization
@expansion{} // ** Warning: result is exact up to order 6 in x and 7 in y !
@expansion{} _[1]=-t2+2t4-4t6
@expansion{} _[2]=-t3+2t5-4t7
  // instead of recomputing you may extend the development:
  list hn2=extdevelop(hn,12);
  param(hn2);     // a still better parametrization
@expansion{} // ** Warning: result is exact up to order 12 in x and 13 in y !
@expansion{} _[1]=-t2+2t4-4t6+8t8-16t10+32t12
@expansion{} _[2]=-t3+2t5-4t7+8t9-16t11+32t13
  //
  // ======== The reducible case ========
  ring r = 0,(x,y),dp;
  poly f=x11-2y2x8-y3x7-y2x6+y4x5+2y4x3+y5x2-y6;
  // = (x5-1y2) * (x6-2x3y2-1x2y3+y4)
  list hn=reddevelop(f);
  show(hn[1][1]);     // Hamburger-Noether matrix of 1st branch
@expansion{} // matrix, 3x3
@expansion{} 0,x,0,
@expansion{} 0,1,x,
@expansion{} 0,1,-1
  displayInvariants(hn);
@expansion{}  --- invariants of branch number 1 : ---
@expansion{}  characteristic exponents  : 4,6,7
@expansion{}  generators of semigroup   : 4,6,13
@expansion{}  Puiseux pairs             : (3,2)(7,2)
@expansion{}  degree of the conductor   : 16
@expansion{}  delta invariant           : 8
@expansion{}  sequence of multiplicities: 4,2,2,1,1
@expansion{} 
@expansion{}  --- invariants of branch number 2 : ---
@expansion{}  characteristic exponents  : 2,5
@expansion{}  generators of semigroup   : 2,5
@expansion{}  Puiseux pairs             : (5,2)
@expansion{}  degree of the conductor   : 4
@expansion{}  delta invariant           : 2
@expansion{}  sequence of multiplicities: 2,2,1,1
@expansion{} 
@expansion{}  -------------- contact numbers : -------------- 
@expansion{} 
@expansion{} branch |    2    
@expansion{} -------+-----
@expansion{}     1  |    2
@expansion{} 
@expansion{}  -------------- intersection multiplicities : -------------- 
@expansion{} 
@expansion{} branch |    2    
@expansion{} -------+-----
@expansion{}     1  |   12
@expansion{} 
@expansion{}  -------------- delta invariant of the curve :  22
  param(hn[2]);      // parametrization of 2nd branch
@expansion{} _[1]=x2
@expansion{} _[2]=x5
@c end example Puiseux_pairs examples.doc:1934
@end smallexample
@c ----------------------------------------------------------------------------
@node Primary decomposition, Normalization, Puiseux pairs, Examples
@section Primary decomposition
@cindex Primary decomposition

There are two algorithms implemented in @sc{Singular} which provide
primary decomposition: @code{primdecGTZ}, based on
Gianni/Trager/Zacharias (written by Gerhard Pfister) and
@code{primdecSY}, based on Shimoyama/Yokoyama (written by Wolfram Decker
and Hans Schoenemann).

The result of @code{primdecGTZ} and @code{primdecSY} is returned as
a list of pairs of ideals,
where the second ideal form the prime ideal and the first
ideal form the corresponding primary ideal.

@smallexample
@c computed example Primary_decomposition examples.doc:1988 
  LIB "primdec.lib";
  ring r = 0,(a,b,c,d,e,f),dp;
  ideal i= f3, ef2, e2f, bcf-adf, de+cf, be+af, e3;
  primdecGTZ(i);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=f
@expansion{}       _[2]=e
@expansion{}    [2]:
@expansion{}       _[1]=f
@expansion{}       _[2]=e
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=f3
@expansion{}       _[2]=ef2
@expansion{}       _[3]=e2f
@expansion{}       _[4]=e3
@expansion{}       _[5]=de+cf
@expansion{}       _[6]=be+af
@expansion{}       _[7]=-bc+ad
@expansion{}    [2]:
@expansion{}       _[1]=f
@expansion{}       _[2]=e
@expansion{}       _[3]=-bc+ad
  // We consider now the ideal J of the base space of the
  // miniversal deformation of the cone over the rational
  // normal curve computed in section *8* and compute
  // its primary decomposition.
  ring R = 0,(A,B,C,D),dp;
  ideal J = CD, BD+D2, AD;
  primdecGTZ(J);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=D
@expansion{}    [2]:
@expansion{}       _[1]=D
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=C
@expansion{}       _[2]=B+D
@expansion{}       _[3]=A
@expansion{}    [2]:
@expansion{}       _[1]=C
@expansion{}       _[2]=B+D
@expansion{}       _[3]=A
  // We see that there are two components which are both
  // prime, even linear subspaces, one 3-dimensional,
  // the other 1-dimensional.
  // (This is Pinkhams example and was the first known
  // surface singularity with two components of
  // different dimensions)
  //
  // Let us now produce an embedded component in the last
  // example, compute the minimal associated primes and
  // the radical. We use the Characteristic set methods
  // from prim_dec.lib.
  J = intersect(J,maxideal(3));
  // The following shows that the maximal ideal defines an embedded
  // (prime) component.
  primdecSY(J);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=D
@expansion{}    [2]:
@expansion{}       _[1]=D
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=C
@expansion{}       _[2]=B+D
@expansion{}       _[3]=A
@expansion{}    [2]:
@expansion{}       _[1]=C
@expansion{}       _[2]=B+D
@expansion{}       _[3]=A
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=D2
@expansion{}       _[2]=C2
@expansion{}       _[3]=B2
@expansion{}       _[4]=AB
@expansion{}       _[5]=A2
@expansion{}       _[6]=BCD
@expansion{}       _[7]=ACD
@expansion{}    [2]:
@expansion{}       _[1]=D
@expansion{}       _[2]=C
@expansion{}       _[3]=B
@expansion{}       _[4]=A
  minAssChar(J);
@expansion{} [1]:
@expansion{}    _[1]=C
@expansion{}    _[2]=B+D
@expansion{}    _[3]=A
@expansion{} [2]:
@expansion{}    _[1]=D
  radical(J);
@expansion{} _[1]=CD
@expansion{} _[2]=BD+D2
@expansion{} _[3]=AD
@c end example Primary_decomposition examples.doc:1988
@end smallexample
@c ----------------------------------------------------------------------------
@node Normalization, Branches of an Isolated Space Curve Singularity, Primary decomposition, Examples
@section Normalization
@cindex Normalization
The normalization will be computed for a reduced ring 
@math{R/I}
@tex
$R/I$
@end tex
. The
result is a list of rings; ideals are always called @code{norid} in the
rings of this list. The normalization of 
@math{R/I}
@tex
$R/I$
@end tex
 is the product of
the factor rings of the rings in the list divided out by the ideals
@code{norid}.

@smallexample
@c computed example Normalization examples.doc:2032 
  LIB "normal.lib";
  // ----- first example: rational quadruple point -----
  ring R=32003,(x,y,z),wp(3,5,15);
  ideal I=z*(y3-x5)+x10;
  list pr=normal(I);
@expansion{} 
@expansion{} // 'normal' created a list of 1 ring(s).
@expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
  def S=pr[1];
  setring S;
  norid;
@expansion{} norid[1]=T(2)*T(3)-T(1)*T(4)
@expansion{} norid[2]=T(1)^7-T(1)^2*T(3)+T(2)*T(5)
@expansion{} norid[3]=T(1)^2*T(5)-T(2)*T(4)
@expansion{} norid[4]=T(1)^5*T(4)-T(3)*T(4)+T(5)^2
@expansion{} norid[5]=T(1)^6*T(3)-T(1)*T(3)^2+T(4)*T(5)
@expansion{} norid[6]=T(1)*T(3)*T(5)-T(4)^2
  // ----- second example: union of straight lines -----
  ring R1=0,(x,y,z),dp;
  ideal I=(x-y)*(x-z)*(y-z);
  list qr=normal(I);
@expansion{} 
@expansion{} // 'normal' created a list of 3 ring(s).
@expansion{} // nor[3+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
  def S1=qr[1]; def S2=qr[2];
  setring S1; norid;
@expansion{} norid[1]=0
  setring S2; norid;
@expansion{} norid[1]=0
@c end example Normalization examples.doc:2032
@end smallexample
@c ----------------------------------------------------------------------------
@node Branches of an Isolated Space Curve Singularity, Kernel of module homomorphisms, Normalization,Examples
@section Branches of an Isolated Space Curve Singularity
@cindex Branches of an Isolated Space Curve Singularity

In this example, the number of branches of a given quasihomogeneous isolated
space curve singularity will be computed as an example of the pitfalls
appearing in the use of primary decomposition. When dealing with singularities,
two situations are possible in which the primary decomposition algorithm
might not lead to a complete decomposition: first of all, one of the computed
components could be globally irreducible, but analytically reducible
(this is impossible for quasihomogeneous singularities) and,
as a second possibility, a component might be irreducible over the rational
numbers, but reducible over the complex numbers.
@smallexample
@c computed example Branches_of_an_Isolated_Space_Curve_Singularity examples.doc:2067 
  ring r=0,(x,y,z),ds;
  ideal i=x^4-y*z^2,x*y-z^3,y^2-x^3*z;  // the space curve singularity
  qhweight(i);
@expansion{} 1,2,1
  // The given space curve singularity is quasihomogeneous. Hence we can pass
  // to the polynomial ring.
  ring rr=0,(x,y,z),dp;
  ideal i=imap(r,i);
  resolution ires=mres(i,0);
  ires;
@expansion{}   1       3       2       
@expansion{} rr <--  rr <--  rr
@expansion{} 
@expansion{} 0       1       2       
@expansion{} 
  // From the structure of the resolution, we see that the Cohen-Macaulay
  // type of the given singularity is 2
  //
  // Let us now look for the branches using the primdec library.
  LIB "primdec.lib";
  primdecSY(i);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=z3-xy
@expansion{}       _[2]=x3+x2z+xz2+xy+yz
@expansion{}       _[3]=x2z2+x2y+xyz+yz2+y2
@expansion{}    [2]:
@expansion{}       _[1]=z3-xy
@expansion{}       _[2]=x3+x2z+xz2+xy+yz
@expansion{}       _[3]=x2z2+x2y+xyz+yz2+y2
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=x-z
@expansion{}       _[2]=z2-y
@expansion{}    [2]:
@expansion{}       _[1]=x-z
@expansion{}       _[2]=z2-y
  def li=_[2];
  ideal i2=li[2];       // call the second ideal i2
  // The curve seems to have 2 branches by what we computed using the
  // algorithm of Shimoyama-Yokoyama.
  // Now the same computation by the Gianni-Trager-Zacharias algorithm:
  primdecGTZ(i);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=z8+yz6+y2z4+y3z2+y4
@expansion{}       _[2]=xz5+z6+yz4+y2z2+y3
@expansion{}       _[3]=-z3+xy
@expansion{}       _[4]=x2z2+xz3+xyz+yz2+y2
@expansion{}       _[5]=x3+x2z+xz2+xy+yz
@expansion{}    [2]:
@expansion{}       _[1]=z8+yz6+y2z4+y3z2+y4
@expansion{}       _[2]=xz5+z6+yz4+y2z2+y3
@expansion{}       _[3]=-z3+xy
@expansion{}       _[4]=x2z2+xz3+xyz+yz2+y2
@expansion{}       _[5]=x3+x2z+xz2+xy+yz
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=-z2+y
@expansion{}       _[2]=x-z
@expansion{}    [2]:
@expansion{}       _[1]=-z2+y
@expansion{}       _[2]=x-z
  // Having computed the primary decomposition in 2 different ways and
  // having obtained the same number of branches, we might expect that the
  // number of branches is really 2, but we can check this by formulae
  // for the invariants of space curve singularities:
  //
  // mu = tau - t + 1 (for quasihomogeneous curve singularities)
  // where mu denotes the Milnor number, tau the Tjurina number and
  // t the Cohen-Macaulay type
  //
  // mu = 2 delta - r + 1
  // where delta denotes the delta-Invariant and r the number of branches
  //
  // tau can be computed by using the corresponding procedure T1 from
  // sing.lib.
  setring r;
  LIB "sing.lib";
  T_1(i);
@expansion{} // dim T_1 = 13
@expansion{} _[1]=gen(6)+2z*gen(5)
@expansion{} _[2]=gen(4)+3x2*gen(2)
@expansion{} _[3]=gen(3)+gen(1)
@expansion{} _[4]=x*gen(5)-y*gen(2)-z*gen(1)
@expansion{} _[5]=x*gen(1)-z2*gen(2)
@expansion{} _[6]=y*gen(5)+3x2z*gen(2)
@expansion{} _[7]=y*gen(2)-z*gen(1)
@expansion{} _[8]=2y*gen(1)-z2*gen(5)
@expansion{} _[9]=z2*gen(5)
@expansion{} _[10]=z2*gen(1)
@expansion{} _[11]=x3*gen(2)
@expansion{} _[12]=x2z2*gen(2)
@expansion{} _[13]=xz3*gen(2)
@expansion{} _[14]=z4*gen(2)
  setring rr;
  // Hence tau is 13 and therefore mu is 12. But then it is impossible that
  // the singularity has two branches, since mu is even and delta is an
  // integer!
  // So obviously, we did not decompose completely. Because the first branch
  // is smooth, only the second ideal can be the one which can be decomposed
  // further.
  // Let us now consider the normalization of this second ideal i2.
  LIB "normal.lib";
  normal(i2);
@expansion{} 
@expansion{} // 'normal' created a list of 1 ring(s).
@expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
@expansion{} [1]:
@expansion{}    //   characteristic : 0
@expansion{} //   number of vars : 1
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    T(1) 
@expansion{} //        block   2 : ordering C
  def rno=_[1];
  setring rno;
  norid;
@expansion{} norid[1]=0
  // The ideal is generated by a polynomial in one variable of degree 4 which
  // factors completely into 4 polynomials of type T(2)+a.
  // From this, we know that the ring of the normalization is the direct sum of 
  // 4 polynomial rings in one variable.
  // Hence our original curve has these 4 branches plus a smooth one
  // which we already determined by primary decomposition.
  // Our final result is therefore: 5 branches.
@c end example Branches_of_an_Isolated_Space_Curve_Singularity examples.doc:2067
@end smallexample
@c ----------------------------------------------------------------------------
@node Kernel of module homomorphisms, Algebraic dependence, Branches of an Isolated Space Curve Singularity, Examples
@section Kernel of module homomorphisms
@cindex Kernel of module homomorphisms
Let 
@math{A}
@tex
$A$
@end tex
, 
@math{B}
@tex
$B$
@end tex
 be two matrices of size
@tex
$m\times r$ and $m\times s$
@end tex
m x r and m x s
over the ring 
@math{R}
@tex
$R$
@end tex
 and consider the corresponding maps
@tex
$$
R^r \buildrel{A}\over{\longrightarrow}
R^m \buildrel{B}\over{\longleftarrow} R^s\;.
$$
@end tex

@smallexample
   r   A     m
  R  -----> R
            ^
            |
            |
             s
            R  .
@end smallexample

We want to compute the kernel of the map
@tex
$R^r \buildrel{A}\over{\longrightarrow}
R^m\longrightarrow
R^m/\hbox{Im}(B) \;.$
@end tex

@smallexample
   r   A     m         m
  R  -----> R  -----> R /Im(B) .
@end smallexample

This can be done using the @code{modulo} command:
@tex
$$
\hbox{\tt modulo}(A,B)=\hbox{ker}(R^r
\buildrel{A}\over{\longrightarrow}R^m/\hbox{Im}(B)) \; .
$$
@end tex

@smallexample
                   r   A     m
  modulo(A,B)=ker(R  -----> R /Im(B))  .
@end smallexample


@smallexample
@c computed example Kernel_of_module_homomorphisms examples.doc:2196 
  ring r=0,(x,y,z),(c,dp);
  matrix A[2][2]=x,y,z,1;
  matrix B[2][2]=x2,y2,z2,xz;
  print(modulo(A,B));
@expansion{} yz2-x2, xyz-y2,  x2z-xy, x3-y2z,
@expansion{} x2z-xz2,-x2z+y2z,xyz-yz2,0      
@c end example Kernel_of_module_homomorphisms examples.doc:2196
@end smallexample

@c ----------------------------------------------------------------------------
@node Algebraic dependence, Classification, Kernel of module homomorphisms, Examples
@section Algebraic dependence
@cindex Algebraic dependence
Let
@tex
$g$, $f_1$, \dots, $f_r\in K[x_1,\ldots,x_n]$.
@end tex
g, f_1, @dots{}, f_r in K[x1,@dots{},xn].
We want to check whether
@enumerate
@item
@tex
$f_1$, \dots, $f_r$
@end tex
f_1, @dots{}, f_r
are algebraically dependent.

Let
@tex
$I=\langle Y_1-f_1,\ldots,Y_r-f_r \rangle \subseteq
K[x_1,\ldots,x_n,Y_1,\ldots,Y_r]$.
@end tex

@smallexample
I=<Y_1-f_1,@dots{},Y_r-f_r> subset K[x1,@dots{},xn,Y_1,@dots{},Y_r].
@end smallexample

Then
@tex
$I \cap K[Y_1,\ldots,Y_r]$
@end tex
I intersected with K[Y_1,@dots{},Y_r]
are the algebraic relations between
@tex
$f_1$, \dots, $f_r$.
@end tex
f_1, @dots{}, f_r.

@item
@tex
$g \in K [f_1,\ldots,f_r]$.
@end tex
g in K[f_1,@dots{},f_r].

@tex
$g \in K[f_1,\ldots,f_r]$
@end tex
g in K[f_1,@dots{},f_r]
if and only if the normal form of 
@math{g}
@tex
$g$
@end tex
 with respect to 
@math{I}
@tex
$I$
@end tex
 and a
block ordering with respect to
@tex
$X=(x_1,\ldots,x_n)$ and $Y=(Y_1,\ldots,Y_r)$ with $X>Y$
@end tex
X=(x1,@dots{},xn) and Y=(Y_1,@dots{},Y_r) with X>Y
is in 
@math{K[Y]}
@tex
$K[Y]$
@end tex
.
@end enumerate

Both questions can be answered using the following procedure. If the
second argument is zero, it checks for algebraic dependence and returns
the ideal of relations between the generators of the given ideal.
Otherwise it checks for subring membership and returns the normal form
of the second argument with respect to the ideal I.

@smallexample
@c computed example Algebraic_dependence examples.doc:2290 
  proc algebraicDep(ideal J, poly g)
  @{
    def R=basering;         // give a name to the basering
    int n=size(J);
    int k=nvars(R);
    int i;
    intvec v;

    // construction of the new ring:

    // construct a weight vector
    v[n+k]=0;         // gives a zero vector of length n+k
    for(i=1;i<=k;i++)
    @{
      v[i]=1;
    @}
    string orde="(a("+string(v)+"),dp);";
    string ri="ring Rhelp=("+charstr(R)+"),
                          ("+varstr(R)+",Y(1.."+string(n)+")),"+orde;
                            // ring definition as a string
    execute(ri);            // execution of the string

    // construction of the new ideal I=(J[1]-Y(1),...,J[n]-Y(n))
    ideal I=imap(R,J);
    for(i=1;i<=n;i++)
    @{
      I[i]=I[i]-var(k+i);
    @}
    poly g=imap(R,g);
    if(g==0)
    @{
      // construction of the ideal of relations by elimination
      poly el=var(1);
      for(i=2;i<=k;i++)
      @{
        el=el*var(i);
      @}
      ideal KK=eliminate(I,el);
      keepring(Rhelp);
      return(KK);
    @}
    // reduction of g with respect to I
    ideal KK=reduce(g,std(I));
    keepring(Rhelp);
    return(KK);
  @}

  // applications of the procedure
  ring r=0,(x,y,z),dp;
  ideal i=xz,yz;
  algebraicDep(i,0);
@expansion{} _[1]=0
  // Note: after call of algebraicDep(), the basering is Rhelp.
  setring r; kill Rhelp;
  ideal j=xy+z2,z2+y2,x2y2-2xy3+y4;
  algebraicDep(j,0);
@expansion{} _[1]=Y(1)^2-2*Y(1)*Y(2)+Y(2)^2-Y(3)
  setring r; kill Rhelp;
  poly g=y2z2-xz;
  algebraicDep(i,g);
@expansion{} _[1]=Y(2)^2-Y(1)
  // this shows that g is contained in i.
  setring r; kill Rhelp;
  algebraicDep(j,g);
@expansion{} _[1]=-z^4+z^2*Y(2)-x*z
  // this shows that g is contained in j.
@c end example Algebraic_dependence examples.doc:2290
@end smallexample

@c ----------------------------------------------------------------------------
@node Classification, Fast lexicographical GB, Algebraic dependence, Examples
@section Classification
@cindex Classification

Classification of isolated hypersurface singularities with respect to
right equivalence is provided by the command @code{classify} of the
library @code{classify.lib}. The classification is done using the
algorithm of Arnold. Before entering this algorithm, a first guess based
on the Hilbert polynomial of the Milnor algebra is made.

@smallexample
@c computed example Classification examples.doc:2369 
  LIB "classify.lib";
  ring r=0,(x,y,z),ds;
  poly p=singularity("E[6k+2]",2)[1];
  p=p+z^2;
  p;
@expansion{} z2+x3+xy6+y8
  // We received an E_14 singularity in normal form
  // from the database of normal forms. Since only the residual
  // part is saved in the database, we added z^2 to get an E_14
  // of embedding dimension 3.
  //
  // Now we apply a coordinate change in order to deal with a
  // singularity which is not in normal form:
  map phi=r,x+y,y+z,x;
  poly q=phi(p);
  // Yes, q really looks ugly, now:
  q;
@expansion{} x2+x3+3x2y+3xy2+y3+xy6+y7+6xy5z+6y6z+15xy4z2+15y5z2+20xy3z3+20y4z3+15xy2z\
   4+15y3z4+6xyz5+6y2z5+xz6+yz6+y8+8y7z+28y6z2+56y5z3+70y4z4+56y3z5+28y2z6+8\
   yz7+z8
  // Classification
  classify(q);
@expansion{} About the singularity :
@expansion{}           Milnor number(f)   = 14
@expansion{}           Corank(f)          = 2
@expansion{}           Determinacy       <= 12
@expansion{} Guessing type via Milnorcode:   E[6k+2]=E[14]
@expansion{} 
@expansion{} Computing normal form ...
@expansion{} I have to apply the splitting lemma. This will take some time....:-)
@expansion{}    Arnold step number 9
@expansion{} The singularity
@expansion{}    x3-9/4x4+27/4x5-189/8x6+737/8x7+6x6y+15x5y2+20x4y3+15x3y4+6x2y5+xy6-24\
   089/64x8-x7y+11/2x6y2+26x5y3+95/2x4y4+47x3y5+53/2x2y6+8xy7+y8+104535/64x9\
   +27x8y+135/2x7y2+90x6y3+135/2x5y4+27x4y5+9/2x3y6-940383/128x10-405/4x9y-2\
   025/8x8y2-675/2x7y3-2025/8x6y4-405/4x5y5-135/8x4y6+4359015/128x11+1701/4x\
   10y+8505/8x9y2+2835/2x8y3+8505/8x7y4+1701/4x6y5+567/8x5y6-82812341/512x12\
   -15333/8x11y-76809/16x10y2-25735/4x9y3-78525/16x8y4-16893/8x7y5-8799/16x6\
   y6-198x5y7-495/4x4y8-55x3y9-33/2x2y10-3xy11-1/4y12
@expansion{} is R-equivalent to E[14].
@expansion{}    Milnor number = 14
@expansion{}    modality      = 1
@expansion{} 2z2+x3+xy6+y8
  // The library also provides routines to determine the corank of q
  // and its residual part without going through the whole
  // classification algorithm.
  corank(q);
@expansion{} 2
  morsesplit(q);
@expansion{} y3-9/4y4+27/4y5-189/8y6+737/8y7+6y6z+15y5z2+20y4z3+15y3z4+6y2z5+yz6-24089\
   /64y8-y7z+11/2y6z2+26y5z3+95/2y4z4+47y3z5+53/2y2z6+8yz7+z8+104535/64y9+27\
   y8z+135/2y7z2+90y6z3+135/2y5z4+27y4z5+9/2y3z6-940383/128y10-405/4y9z-2025\
   /8y8z2-675/2y7z3-2025/8y6z4-405/4y5z5-135/8y4z6+4359015/128y11+1701/4y10z\
   +8505/8y9z2+2835/2y8z3+8505/8y7z4+1701/4y6z5+567/8y5z6-82812341/512y12-15\
   333/8y11z-76809/16y10z2-25735/4y9z3-78525/16y8z4-16893/8y7z5-8799/16y6z6-\
   198y5z7-495/4y4z8-55y3z9-33/2y2z10-3yz11-1/4z12
@c end example Classification examples.doc:2369
@end smallexample
@c ----------------------------------------------------------------------------
@node Fast lexicographical GB, Parallelization with MPtcp links, Classification, Examples
@section Fast lexicographical GB
@cindex Fast lexicographical GB

Compute Groebner basis in lexicographical ordering
by using the FGLM algorithm (@code{stdfglm})
and Hilbert driven Groebner (@code{stdhilb}).

The command @code{stdfglm} applies only for zero-dimensional ideals and
returns a reduced Groebner basis.

For the ideal below, @code{stdfglm} is more than 100 times
and @code{stdhilb} about 10 times faster than @code{std}.

@smallexample
@c computed example Fast_lexicographical_GB examples.doc:2413 
  ring r =32003,(a,b,c,d,e),lp;
  ideal i=a+b+c+d, ab+bc+cd+ae+de, abc+bcd+abe+ade+cde,
          abc+abce+abde+acde+bcde, abcde-1;
  int t=timer;
  ideal j1=stdfglm(i);
  timer-t;
@expansion{} 0
  size(j1);   // size (no. of polys) in computed GB
@expansion{} 5
  t=timer;
  ideal j2=stdhilb(i);
  timer-t;
@expansion{} 0
  size(j2);   // size (no. of polys) in computed GB
@expansion{} 158
  // usual Groebner basis computation for lex ordering
  t=timer;
  ideal j0 =std(i);
  timer-t;
@expansion{} 1
@c end example Fast_lexicographical_GB examples.doc:2413
@end smallexample
@c ----------------------------------------------------------------------------
@node  Parallelization with MPtcp links,  , Fast lexicographical GB, Examples
@section Parallelization with MPtcp links
@cindex Parallelization
@cindex MPtcp
@cindex link
In this example, we demonstrate how MPtcp links can be used to
parallelize computations.

To compute a standard basis for a zero-dimensional ideal in the
lexicographical ordering, one of the two powerful routines
@code{stdhilb}
(see @ref{stdhilb})
and @code{stdfglm}
(see @ref{stdfglm})
should be used. However, a priory one can not predict
which one of the two commands is faster. This very much depends on the
(input) example. Therefore, we use MPtcp links to let both commands
work on the problem independently and in parallel, so that the one which
finishes first delivers the result.

The example we use is the so-called "omdi example". See @i{Tim
Wichmann; Der FGLM-Algorithmus: verallgemeinert und implementiert in
Singular; Diplomarbeit Fachbereich Mathematik, Universitaet
Kaiserslautern; 1997} for more details.

@smallexample
@c computed example Parallelization_with_MPtcp_links examples.doc:2464 
ring r=0,(a,b,c,u,v,w,x,y,z),lp;
ideal i=a+c+v+2x-1, ab+cu+2vw+2xy+2xz-2/3,  ab2+cu2+2vw2+2xy2+2xz2-2/5,
ab3+cu3+2vw3+2xy3+2xz3-2/7, ab4+cu4+2vw4+2xy4+2xz4-2/9, vw2+2xyz-1/9,
vw4+2xy2z2-1/25, vw3+xyz2+xy2z-1/15, vw4+xyz3+xy3z-1/21;

link l_hilb,l_fglm = "MPtcp:fork","MPtcp:fork";         // 1.

open(l_fglm); open(l_hilb);

write(l_hilb, quote(system("pid")));                    // 2.
write(l_fglm, quote(system("pid")));
int pid_hilb,pid_fglm = read(l_hilb),read(l_fglm);

write(l_hilb, quote(stdhilb(i)));                       // 3.
write(l_fglm, quote(stdfglm(eval(i))));

while ((! status(l_hilb, "read", "ready", 1)) &&        // 4.
       (! status(l_fglm, "read", "ready", 1))) @{@}

if (status(l_hilb, "read", "ready"))
@{
  "stdhilb won !!!!"; size(read(l_hilb));
  close(l_hilb); pid_fglm = system("sh","kill "+string(pid_fglm));
@}
else                                                    // 5.
@{
  "stdfglm won !!!!"; size(read(l_fglm));
  close(l_fglm); pid_hilb = system("sh","kill "+string(pid_hilb));
@}
@expansion{} stdfglm won !!!!
@expansion{} 9
@c end example Parallelization_with_MPtcp_links examples.doc:2464
@end smallexample
Some explanatory remarks are in order:
@enumerate
@item
Instead of using links of the type @code{MPtcp:fork}, we alternatively
could use @code{MPtcp:launch} links such that the two "competing"
@sc{Singular} processes run on different machines. This has the
advantage of "true" parallel computing since no resource sharing is
involved (as it usually is with forked processes).

@item
Unfortunately, MPtcp links do not offer means to (asynchronously)
interrupt or kill an attached (i.e., launched or forked)
process. Therefore, we explicitly need to get the process id numbers of
the competing @sc{Singular} processes, so that we can "kill" the
looser later.

@item
Notice how quoting is used in order to prevent local evaluation
(i.e., local computation of results). Since we "forked" the two
competing processes, the identifier @code{i} is defined and has
identical values in both child processes. Therefore, the innermost
@code{eval} can be omitted (as is done for the @code{l_hilb} link),
and only the identifier @code{i} needs to be communicated to the
children. However, when @code{MPtcp:launch} links are used, the inner
evaluation must be applied so that actual values, and not the
identifiers are communicated (as is done for the @code{l_fglm} link).

@item
We go into a "sleepy" loop and wait until one of the two children
finished the computation. That is, the current process checks approximately
once per second the status of one of the connecting links, and sleeps
(i.e., suspends its execution) in the intermediate time.

@item
The child which has won delivers the result and is terminated with the usual
@code{close} command. The other child which is still computing needs to
be terminated by an explicit (i.e., system) kill command, since it can
not be terminated through the link while it is still computing.
@end enumerate

@c --------------------------------------------------------------------

@c ----------------------------------------------------------------------------
@node Polynomial data,Mathematical background, Examples, Top
@appendix Polynomial data
@cindex Polynomial data
@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from pdata.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT pdata.doc INSTEAD
@comment Id: pdata.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the "Polynomial data" appendix.

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').

@menu
* Representation of mathematical objects::
* Monomial orderings::
@end menu

@c -----------------------------------------------------------------
@node Representation of mathematical objects,Monomial orderings,,Polynomial data
@section Representation of mathematical objects
@cindex mathematical objects
@cindex representation, math objects

@sc{Singular} distinguishes between objects which do not belong to a ring
and those which belong to a specific ring (see @ref{Rings and orderings}).
We comment only on the latter ones.

Internally all ring-dependent objects are polynomials or structures built from
polynomials (and some additional information).
Note that @sc{Singular} stores (and hence prints) a polynomial automatically
w.r.t@:. the monomial ordering.

Hence, in order to define such an object in @sc{Singular},
one has to give a list of polynomials in a specific format.

For ideals, resp.@: matrices, this is straight forward:
The user gives a list of polynomials
which generate the ideal, resp.@: which are the entries of the matrix.
(The number of rows and columns has to be given when creating the matrix.)

A vector  in @sc{Singular} is always an element of a free module over the
basering. It is given as a list of polynomials in one of the following
formats
@tex
$[f_1,...,f_n]$ or $f_1*gen(1)+...+f_n*gen(n)$, where $gen(i)$
@end tex
[f_1,...,f_n] or f_1*gen(1)+...+f_n*gen(n), where gen(i)
denotes the i-th canonical generator of a free module (with 1 at place i and
0 everywhere else).
Both forms are equivalent. A vector is internally represented in
the second form with the
@tex
$gen(i)$
@end tex
gen(i)
being "special" ring variables, ordered accordingly to the monomial ordering.
Therefore, the form
@tex
$[f_1,...,f_n]$
@end tex
[f_1,...,f_n]
is given as output only if the monomial ordering gives priority to the
component, i.e@:., is of the form @code{(c,...)} (see @ref{Module
orderings}).  However, in any case the procedure @code{show} from the
library @code{inout.lib} displays the bracket format.

A vector
@tex
$v=[f_1,...,f_n]$
@end tex
v=[f_1,...,f_n]
should always be considered as a column vector in a free module
of rank equal to
@tex
nrows($v$)
@end tex
nrows(v)
where 
@tex
nrows($v$)
@end tex
nrows(v) 
is equal to the maximal index 
@tex
$r$
@end tex
r
such that
@tex
$f_r \not= 0$.
@end tex
f_r<>0.
This is due to the fact, that internally 
@tex
$v$
@end tex
v
is a polynomial in a sparse representation, i.e.,
@tex
$f_i*gen(i)$
@end tex
f_i*gen(i)
is not stored if
@tex
$f_i=0$
@end tex
f_i=0
(for reasons of efficiency), hence the last 0-entries of 
@tex
$v$
@end tex
v
are lost.
Only more complex structures are able to keep the rank.

A module 
@tex
$M$
@end tex
M
in @sc{Singular} is given by a list of vectors
@tex
$v_1,...,v_k$
@end tex
v_1,....v_k
which generate the module as a submodule of the free module of rank
equal to 
@tex
nrows($M$)
@end tex
nrows(M)
which is the maximum of
@tex
nrows($v_i$).
@end tex
nrows(v_i).

If one wants to create a module with a larger rank than given by its
generators, one has to use the command @code{attrib(M,"rank",r)} (see
@ref{attrib}, @ref{nrows}) or to define a matrix first, then converting it
into a module.  Modules in @sc{Singular} are almost the same as
matrices, they may be considered as sparse representations of matrices.
A module of a matrix is generated by the columns of the matrix and a
matrix of a module has as columns the generators of the module.  These
conversions preserve the rank and the number of generators, resp@:. the
number of rows and columns.

By the above remarks it might appear that @sc{Singular} is only able to handle
submodules of a free module. However, this is not true. @sc{Singular}
can compute with any finitely generated module over the basering 
@tex
$R$.
@end tex 
R.
Such a module, say 
@tex
$N$,
@end tex
N,
is not represented by its generators but by its
(generators and) relations. This means that
@tex
$N = R^n/M$ where $n$ 
@end tex
N = R^n/M where n
is the number of generators of 
@tex
$N$ and $M \subseteq R^n$
@end tex
N and M in R^n
is the module of relations.
In other words, defining  a module 
@tex
$M$
@end tex
M
as a submodule of a free module
@tex
$R^n$
@end tex
R^n
can also be considered as the definition of
@tex
$N = R^n/M$.
@end tex
N=R^n/M.

Note that most functions, when applied to a module 
@tex
$M$,
@end tex
M,
really deal with
@tex
$M$.
@end tex
M.
However, there are some functions which deal with 
@tex
$N = R^n/M$ instead of $M$.
@end tex
N=R^n/M instead of M.

For example, @code{std(M)} computes a standard basis of 
@tex
$M$
@end tex
M
(and thus gives another representation of 
@tex
$N$ as $N = R^n/$std($M$)).
@end tex
N as N=R^n/std(M)).
However, @code{dim(M)}, resp.@: @code{vdim(M)}, returns
@tex
dim$(R^n/M)$, resp.@: dim$_k(R^n/M)$
@end tex
dim(R^n/M), resp.@: dim_k(R^n/M)
(if M is given by a standard basis).

The function @code{syz(M)}  returns the first syzygy module of 
@tex
$M$,
@end tex
M,
i.e@:., the module 
of relations of the given generators of 
@tex
$M$
@end tex
M
which is equal to the second syzygy module of 
@tex
$N$.
@end tex
N.
Refer to the description of each function in
@ref{Functions} to get information which module the function deals with.

The numbering in @code{res} and other commands for computing resolutions
refers to a resolution of
@tex
$N = R^n/M$
@end tex
N=R^n/M
(see @ref{res}; @ref{Syzygies and resolutions}).

It is possible to compute in any field which is a valid ground field in
@sc{Singular}.  For doing so, one has to define a ring with the desired
ground field and at least one variable. The elements of the field are of
type number, but may also be considered as polynomials (of degree
0). Large computations should be faster if the elements of the field are
defined as numbers.

The above remarks do also apply to quotient rings. Polynomial data are
stored internally in the same manner, the only difference is that this
polynomial representation is in general not unique. @code{reduce(f,std(0))}
computes a normal form of a polynomial f in a quotient ring (cf.@:
@ref{reduce}).

@c -----------------------------------------------------------------
@node Monomial orderings,,Representation of mathematical objects,Polynomial data
@section Monomial orderings
@cindex Monomial orderings

@menu
* Introduction to orderings::
* General definitions for orderings::
* Global orderings::
* Local orderings::
* Module orderings::
* Matrix orderings::
* Product orderings::
* Extra weight vector::
@end menu

@c --------------------------------------------------------------------------
@node Introduction to orderings, General definitions for orderings, , Monomial orderings
@subsection Introduction to orderings
@cindex orderings introduction
@cindex term orderings introduction
@cindex monomial orderings introduction

@sc{Singular} offers a great variety of monomial orderings which provide
an enormous functionality, if used diligently. However, this
flexibility might also be confusing for the novice user.  Therefore, we
recommend to those not familiar with monomial orderings to generally use
the ordering @code{dp} for computations in the polynomial ring
@tex
$K[x_1,\ldots,x_n]$, 
@end tex
K[x1,...,xn], 
resp.@:  @code{ds} for computations in the localization 
@tex
$\hbox{Loc}_{(x)}K[x_1,\ldots,x_n]$.
@end tex
Loc_(x)K[x1,...,xn].

For inhomogeneous input ideals,  standard (resp.@: groebner) bases
computations are generally faster 
with the orderings 
@tex
$\hbox{Wp}(w_1, \ldots, w_n)$
@end tex
Wp(w_1, ..., w_n)
(resp.@: 
@tex
$\hbox{Ws}(w_1, \ldots, w_n)$)
@end tex
Ws(w_1, ..., w_n))
if the input is quasihomogeneous w.r.t. the weights 
@tex
$w_1$, $\ldots$, $w_n$ of $x_1$, $\ldots$, $x_n$. 
@end tex
w_1, ..., w_n of x_1, ..., x_n. 

If the output needs to be "triangular" (resp.@: "block-triangular"), the
lexicographical ordering @code{lp} (resp.@: lexicographical
block-orderings) need to be used. However, these orderings usually
result in much less efficient computations.


@c --------------------------------------------------------------------------
@node General definitions for orderings, Global orderings, Introduction to orderings, Monomial orderings
@subsection General definitions for orderings
@cindex orderings
@cindex term orderings
@cindex monomial orderings

@tex
A monomial ordering (term ordering) on $K[x_1, \ldots, x_n]$ is
a total ordering $<$ on the
set of monomials (power products) $\{x^\alpha \mid \alpha \in \bf{N}^n\}$
which is compatible with the
natural semigroup structure, i.e., $x^\alpha < x^\beta$ implies $x^\gamma
x^\alpha < x^\gamma x^\beta$ for any $\gamma \in \bf{N}^n$.
We do not require
$<$ to be  a well ordering.
@end tex
A monomial ordering (term ordering) on K[x_1, ..., x_n] is
a total ordering < on the
set of monomials (power products) @{x^a | a in N^n@}
which is compatible with the
natural semigroup structure, i.e., x^a < x^b implies x^c*x^a < x^c*x^b for any
c in N^n.
We do not require
< to be  a well ordering.
 See the literature cited in @ref{References}.

It is known that any monomial ordering can be represented by a matrix 
@tex
$M$ in $GL(n,R)$,
@end tex
M in GL(n,R),
but, of course, only integer coefficients are of relevance in
practice.

@tex
Global orderings are well orderings (i.e.,  \hbox{$1 < x_i$} for each variable
$x_i$), local orderings satisfy $1 > x_i$ for each variable.   If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not well orderings.

Let $K$ be the ground field, \hbox{$x = (x_1, \ldots, x_n)$} the
variables and $<$ a monomial ordering, then Loc $K[x]$ denotes the
localization of $K[x]$ with respect to the multiplicatively closed set $$\{1 +
g \mid g = 0 \hbox{ or } g \in K[x]\backslash \{0\} \hbox{ and }L(g) <
1\}.$$   Here, $L(g)$ 
denotes the leading monomial of $g$, i.e., the biggest monomial of $g$ with
respect to $<$.   The result of any computation which uses standard basis
computations has to be interpreted in Loc $K[x]$.
@end tex
Global orderings are well orderings (i.e., 1 < x_i for each variable
x_i), local orderings satisfy 1 > x_i for each variable.
If some variables are ordered globally and others locally we
call it a mixed ordering.   Local or mixed orderings are not well orderings.

If K is the ground field, x = (x_1, @dots{}, x_n) the
variables and < a monomial ordering, then Loc K[x] denotes the
localization of K[x] with respect to the multiplicatively closed set @{1 +
g | g = 0 or g in K[x]\@{0@} and L(g) < 1@}.   L(g)
denotes the leading monomial of g, i.e., the biggest monomial of g with
respect to <.   The result of any computation which uses standard basis
computations has to be interpreted in Loc K[x].

Note that the definition of a ring includes the definition of its
monomial ordering (see 
@ref{Rings and orderings}). @sc{Singular} offers the monomial orderings
described in the following sections. 


@c --------------------------------------------------------------------------
@node Global orderings, Local orderings, General definitions for orderings, Monomial orderings
@subsection Global orderings
@cindex Global orderings
@cindex orderings, global

@tex
For all these orderings: Loc $K[x]$ = $K[x]$
@end tex
For all these orderings: Loc K[x] = K[x]

@table @asis
@item lp:
lexicographical ordering:
@cindex lp, global ordering
@cindex lexicographical ordering
@*
x^a < x^b  <==> there is an i,  1 <= i <= n :
@* a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@tex
$x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
\alpha_1 = \beta_1, \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i <
\beta_i$.
@end tex
@item rp:
reverse lexicographical ordering:
@cindex rp, global ordering
@cindex reverse lexicographical ordering
@*
x^a < x^b  <==> there is an i,  1 <= i <= n :
@*     a_n = b_n, @dots{}, a_(i+1) = b_(i+1), a_i > b_i.
@tex
$x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
\alpha_n = \beta_n,
    \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i.$
@end tex
@item dp:
degree reverse lexicographical ordering:
@cindex degree reverse lexicographical ordering
@cindex dp, global ordering
@*
let deg(x^a) = a_1 + @dots{} + a_n, then
@tex
let $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ then
@end tex
@*x^a < x^b <==>
@* deg(x^a) < deg(x^b),
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_n = b_n, @dots{}, a_(i+1) = b_(i+1), a_i > b_i.
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) < \deg(x^\beta)$ or
@end tex
@tex
    \phantom{$x^\alpha < x^\beta \Leftrightarrow $}$ \deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n: \alpha_n = \beta_n,
    \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i.$
@end tex
@item Dp:
degree lexicographical ordering:
@cindex degree lexicographical ordering
@cindex Dp, global ordering
@*
let deg(x^a) = a_1 + @dots{} + a_n, then
@tex
let $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ then
@end tex
@*x^a < x^b <==>
@* deg(x^a) < deg(x^b)
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) < \deg(x^\beta)$ or
@end tex
@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow $} $\deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:\alpha_1 = \beta_1,
    \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i < \beta_i.$
@end tex
@item wp:
weighted reverse lexicographical ordering:
@cindex weighted reverse lexicographical ordering
@cindex wp, global ordering
@*
 wp(w_1, @dots{}, w_n), w_i  positive integers,
@tex
let $w_1, \ldots, w_n$ be positive integers. Then ${\tt wp}(w_1, \ldots,
w_n)$ 
@end tex
 is defined as @code{dp}
 but with
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@item Wp:
weighted lexicographical ordering:
@cindex weighted lexicographical ordering
@cindex WP, global ordering
@*
 Wp(w_1, @dots{}, w_n), w_i  positive integers,
@tex
let $w_1, \ldots, w_n$ be positive integers. Then ${\tt Wp}(w_1, \ldots,
w_n)$ 
@end tex
 is defined as @code{Dp}
 but with
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@end table
@c --------------------------------------------------------------------------
@node Local orderings, Module orderings, Global orderings, Monomial orderings
@subsection Local orderings
@cindex Local orderings
@cindex orderings, local

For ls, ds, Ds and, if the weights are positive integers, also for ws and
Ws,  we have
Loc K[x] = K[x]_(x),
@tex
Loc $K[x]$ = $K[x]_{(x)}$,
@end tex
 the localization of 
@tex
$K[x]$
@end tex
K[x]
at the maximal ideal
 (x_1, @dots{}, x_n).
@tex
\ $(x_1, ..., x_n)$.
@end tex

@table @asis
@item ls:
negative lexicographical ordering:
@cindex negative lexicographical ordering
@cindex ls, local ordering
@*
x^a < x^b  <==> there is an i,  1 <= i <= n :
@* a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i > b_i.
@tex
$x^\alpha < x^\beta  \Leftrightarrow  \exists\; 1 \le i \le n :
\alpha_1 = \beta_1, \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i >
\beta_i$.
@end tex
@item ds:
negative degree reverse lexicographical ordering:
@cindex negative degree reverse lexicographical ordering
@cindex ds, local ordering
@*
let deg(x^a) = a_1 + @dots{} + a_n, then
@tex
let $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ then
@end tex
@*x^a < x^b <==>
@* deg(x^a) > deg(x^b)
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_n = b_n, @dots{}, a_(i+1) = b_(i+1), a_i > b_i.
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) > \deg(x^\beta)$ or
@end tex
@tex
    \phantom{ $x^\alpha < x^\beta \Leftrightarrow$}$ \deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n: \alpha_n = \beta_n,
    \ldots, \alpha_{i+1} = \beta_{i+1}, \alpha_i > \beta_i.$
@end tex
@item Ds:
negative degree lexicographical ordering:
@cindex negative degree lexicographical ordering
@cindex Ds, local ordering
@*
let deg(x^a) = a_1 + @dots{} + a_n, then
@tex
let $\deg(x^\alpha) = \alpha_1 + \cdots + \alpha_n,$ then
@end tex
x^a < x^b <==>
@* deg(x^a) > deg(x^b)
@* or
@* deg(x^a) = deg(x^b) and there exist an i, 1 <= i <= n:
@*     a_1 = b_1, @dots{}, a_(i-1) = b_(i-1), a_i < b_i.
@tex
    $x^\alpha < x^\beta \Leftrightarrow \deg(x^\alpha) > \deg(x^\beta)$ or 
@end tex
@tex
    \phantom{ $ x^\alpha < x^\beta \Leftrightarrow$}$ \deg(x^\alpha) =
    \deg(x^\beta)$ and $\exists\ 1 \le i \le n:\alpha_1 = \beta_1,
    \ldots, \alpha_{i-1} = \beta_{i-1}, \alpha_i < \beta_i.$
@end tex
@item ws:
(general) weighted reverse lexicographical ordering:
@cindex general weighted reverse lexicographical ordering
@cindex local weighted reverse lexicographical ordering
@cindex ws, local ordering
@*
 ws(w_1, @dots{}, w_n), w_1
@tex
${\tt ws}(w_1, \ldots, w_n),\; w_1$
@end tex
 a nonzero integer,
w_2,@dots{},w_n
@tex
$w_2,\ldots,w_n$
@end tex
 any integer (including 0),
 is defined as @code{ds}
 but with
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@item Ws:
(general) weighted lexicographical ordering:
@cindex general weighted lexicographical ordering
@cindex local weighted lexicographical ordering
@cindex Ws, local ordering
@*
 Ws(w_1, @dots{}, w_n), w_1
@tex
${\tt Ws}(w_1, \ldots, w_n),\; w_1$
@end tex
 a nonzero integer,
w_2,@dots{},w_n
@tex
$w_2,\ldots,w_n$
@end tex
 any integer (including 0),
 is defined as @code{Ds}
 but with
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n.
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n.$
@end tex
@end table

@c --------------------------------------------------------------------------
@node Module orderings, Matrix orderings, Local orderings, Monomial orderings
@subsection Module orderings
@cindex Module orderings

@sc{Singular} offers also orderings on the set of ``monomials''
@{ x^a*gen(i) | a in N^n, 1 <= i <= r @} in Loc K[x]^r = Loc K[x]gen(1)
+ @dots{} + Loc K[x]gen(r), where gen(1), @dots{}, gen(r) denote the canonical
generators of Loc K[x]^r, the r-fold direct sum of Loc K[x].
@tex
$\{ x^a e_i  \mid  a \in N^n, 1 \leq i \leq r \}$ in Loc $K[x]^r$ = Loc
$K[x]e_1 
+ \ldots +$Loc $K[x]e_r$, where $e_1, \ldots, e_r$ denote the canonical
generators of Loc $K[x]^r$, the r-fold direct sum of Loc $K[x]$.
(The function {\tt gen(i)} yields $e_i$).
@end tex

We have two possibilities: either to give priority to the component of a
vector in 
Loc K[x]^r
@tex
 Loc $K[x]^r$
@end tex
or (which is the default in @sc{Singular}) to give priority
to the coefficients.
The orderings @code{(<,c)} and @code{(<,C)} give priority to the
coefficients; whereas
@code{(c,<)} and @code{(C,<)} give priority to the components.
@*Let < be any of the monomial orderings of 
@tex
Loc $K[x]$
@end tex
Loc K[x]
as above.

@table @asis
@item (<,C):
@cindex C, module ordering
@cindex module ordering C
<_m = (<,C) denotes the module ordering (giving priority to the coefficients):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* x^a < x^b
@* or
@* x^a = x^b  and  i < j.
@tex
$<_m = (<,C)$ denotes the module ordering (giving priority to the coefficients):
@end tex
@*
@tex
\quad  \quad  $x^\alpha e_i <_m x^\beta e_j \Leftrightarrow x^\alpha <
x^\beta$ or ($x^\alpha = x^\beta $ and $ i < j$).
@end tex

@strong{Example:}
@smallexample
@c computed example Module_orderings pdata.doc:849 
  ring r = 0, (x,y,z), ds;
  // the same as ring r = 0, (x,y,z), (ds, C);
  [x+y2,z3+xy];
@expansion{} x*gen(1)+xy*gen(2)+y2*gen(1)+z3*gen(2)
  [x,x,x];
@expansion{} x*gen(3)+x*gen(2)+x*gen(1)
@c end example Module_orderings pdata.doc:849
@end smallexample

@item (C,<):
<_m = (C, <) denotes the module ordering (giving priority to the
component):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* i<j
@* or
@* i = j and x^a < x^b.
@tex
$<_m = (C, <)$ denotes the module ordering (giving priority to the component):
@end tex
@tex
\quad \quad   $x^\alpha e_i <_m x^\beta e_j \Leftrightarrow i < j$ or ($
i = j $ and $ x^\alpha < x^\beta $). 
@end tex

@strong{Example:}
@smallexample
@c computed example Module_orderings_1 pdata.doc:879 
  ring r = 0, (x,y,z), (C,lp);
  [x+y2,z3+xy];
@expansion{} xy*gen(2)+z3*gen(2)+x*gen(1)+y2*gen(1)
  [x,x,x];
@expansion{} x*gen(3)+x*gen(2)+x*gen(1)
@c end example Module_orderings_1 pdata.doc:879
@end smallexample

@item (<,c):
@cindex c, module ordering
@cindex module ordering c
<_m = (<,c) denotes the module ordering (giving priority to the coefficients):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* x^a < x^b
@* or
@* x^a = x^b  and  i > j.
@tex
$<_m = (<,c)$ denotes the module ordering (giving priority to the coefficients):
@end tex
@tex
\quad \quad $x^\alpha e_i <_m x^\beta e_j \Leftrightarrow x^\alpha <
x^\beta$ or ($x^\alpha = x^\beta $ and $ i > j$).
@end tex

@strong{Example:}
@smallexample
@c computed example Module_orderings_2 pdata.doc:909 
  ring r = 0, (x,y,z), (lp,c);
  [x+y2,z3+xy];
@expansion{} xy*gen(2)+x*gen(1)+y2*gen(1)+z3*gen(2)
  [x,x,x];
@expansion{} x*gen(1)+x*gen(2)+x*gen(3)
@c end example Module_orderings_2 pdata.doc:909
@end smallexample

@item (c,<):
<_m = (c, <) denotes the module ordering (giving priority to the
component):
@* x^a*gen(i) <_m x^b*gen(j) <==>
@* i>j
@* or
@* i = j and x^a < x^b.
@tex
$<_m = (c, <)$ denotes the module ordering (giving priority to the component):
@end tex
@tex
\quad \quad   $x^\alpha e_i <_m x^\beta e_j \Leftrightarrow i > j$ or ($
i = j $ and $ x^\alpha < x^\beta $). 
@end tex

@strong{Example:}
@smallexample
@c computed example Module_orderings_3 pdata.doc:938 
  ring r = 0, (x,y,z), (c,lp);
  [x+y2,z3+xy];
@expansion{} [x+y2,xy+z3]
  [x,x,x];
@expansion{} [x,x,x]
@c end example Module_orderings_3 pdata.doc:938
@end smallexample
@end table

The output of a vector v in K[x]^r with components v_1,
@dots{}, v_r has the format v_1 * gen(1) + @dots{} + v_r * gen(r)
@tex
The output of a vector $v$ in $K[x]^r$ with components $v_1,
\ldots, v_r$ has the format $v_1 * gen(1) + \ldots + v_r * gen(r)$
@end tex
(up to permutation) unless the ordering starts with @code{c}.
In this case a vector is written as [v_1, @dots{}, v_r].
@tex
In this case a vector is written as $[v_1, \ldots, v_r]$.
@end tex
In all cases @sc{Singular} can read input in both formats.

@c --------------------------------------------------------------------------
@node Matrix orderings, Product orderings, Module orderings, Monomial orderings
@subsection Matrix orderings
@cindex Matrix orderings
@cindex orderings, M
@cindex M, ordering

Let 
@tex
$M$
@end tex
M
be an invertible 
@tex
$(n \times n)$-matrix
@end tex
(n x n)-matrix
 with integer coefficients and
M_1, @dots{}, M_n the rows of M.
@tex
$M_1, \ldots, M_n$ the rows of $M$.
@end tex

The M-ordering < is defined as follows:
@*
x^a < x^b <==> there exists an i: 1 <= i <= n :
M_1*a = M_1*b, @dots{}, M_(i-1)*a = M_(i-1)*b, M_i*a < M_i*b.
@tex
\quad \quad $x^a < x^b \Leftrightarrow \exists\  1 \leq i \leq n :
M_1 a = \; M_1 b, \ldots, M_{i-1} a = \; M_{i-1} b$ and $M_i a < \; M_i b$.
@end tex

Thus,
x^a < x^b
if and only if M*a is smaller than M*b
@tex
$x^a < x^b$
if and only if $M a$ is smaller than $M b$
@end tex
with respect to the lexicographical ordering.

The following matrices represent (for 3 variables) the global and
local orderings defined above (note that the matrix is not uniquely determined
by the ordering):

@table @asis
@item lp:
 1   0   0
@* 0   1   0
@* 0   0   1
@item dp:
 1   1   1
@* 0   0  -1
@* 0  -1   0
@item Dp:
 1   1   1
@* 1   0   0
@* 0   1   0
@item wp(1,2,3):
 1   2   3
@* 0   0  -1
@* 0  -1   0
@item Wp(1,2,3):
 1   2   3
@* 1   0   0
@* 0   1   0
@item ls:
-1   0   0
@* 0  -1   0
@* 0   0  -1
@item ds:
-1  -1  -1
@* 0   0  -1
@* 0  -1   0
@item Ds:
-1  -1  -1
@* 1   0   0
@* 0   1   0
@item ws(1,2,3):
-1  -2  -3
@* 0   0  -1
@* 0  -1   0
@item Ws(1,2,3):
-1  -2  -3
@* 1   0   0
@* 0   1   0
@end table
@tex

$\quad$ lp:
$\left(\matrix{
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 0 & 0 & 1 \cr
 }\right)$
\quad dp:
$\left(\matrix{
 1 & 1 & 1 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Dp:
$\left(\matrix{
 1 & 1 & 1 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

$\quad$ wp(1,2,3):
$\left(\matrix{
 1 & 2 & 3 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Wp(1,2,3):
$\left(\matrix{
 1 & 2 & 3 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

$\quad$ ls:
$\left(\matrix{
-1 & 0 & 0 \cr
 0 &-1 & 0 \cr
 0 & 0 &-1 \cr
 }\right)$
\quad ds:
$\left(\matrix{
-1 &-1 &-1 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Ds:
$\left(\matrix{
-1 &-1 &-1 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$

$\quad$ ws(1,2,3):
$\left(\matrix{
-1 &-2 &-3 \cr
 0 & 0 &-1 \cr
 0 &-1 & 0 \cr
 }\right)$
\quad Ws(1,2,3):
$\left(\matrix{
-1 &-2 &-3 \cr
 1 & 0 & 0 \cr
 0 & 1 & 0 \cr
 }\right)$
@end tex

Product orderings (see next section) represented by  a matrix:

@table @asis
@item (dp(3), wp(1,2,3)):
1  1  1  0  0  0
@*0  0  -1  0  0  0
@*0  -1  0  0  0  0
@*0  0  0  1  2  3
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@item (Dp(3), ds(3)):
1  1  1  0  0  0
@*1  0  0  0  0  0
@*0  1  0  0  0  0
@*0  0  0  -1  -1  -1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@end table
@tex
$\quad$ (dp(3), wp(1,2,3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
0&  0&  -1&  0&  0&  0 \cr
0&  -1&  0&  0&  0&  0 \cr
0&  0&  0&  1&  2&  3 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$

$\quad$ (Dp(3), ds(3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
1&  0&  0&  0&  0&  0 \cr
0&  1&  0&  0&  0&  0 \cr
0&  0&  0&  -1&  -1&  -1 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@end tex

Orderings with extra weight vector (see below) represented by  a matrix:

@table @asis
@item (dp(3), a(1,2,3),dp(3)):
1  1  1  0  0  0
@*0  0  -1  0  0  0
@*0  -1  0  0  0  0
@*0  0  0  1  2  3
@*0  0  0  1  1  1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@item (a(1,2,3,4,5),Dp(3), ds(3)):
1  2  3  4  5  0
@*1  1  1  0  0  0
@*1  0  0  0  0  0
@*0  1  0  0  0  0
@*0  0  0  -1  -1  -1
@*0  0  0  0  0  -1
@*0  0  0  0  -1  0
@end table
@tex
$\quad$ (dp(3), a(1,2,3),dp(3)):
$\left(\matrix{
1&  1&  1&  0&  0&  0 \cr
0&  0&  -1&  0&  0&  0 \cr
0&  -1&  0&  0&  0&  0 \cr
0&  0&  0&  1&  2&  3 \cr
0&  0&  0&  1&  1&  1 \cr
0&  0&  0&  0&  0&  -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$

$\quad$ (a(1,2,3,4,5),Dp(3), ds(3)):
$\left(\matrix{
1&  2&  3&  4&  5&  0 \cr
1&  1&  1&  0&  0&  0 \cr
1&  0&  0&  0&  0&  0 \cr
0&  1&  0&  0&  0&  0 \cr
0&  0&  0&  -1&  -1&  -1 \cr
0&  0&  0&  0&  0 & -1 \cr
0&  0&  0&  0&  -1&  0 \cr
 }\right)$
@end tex

@*@strong{Example}:
@smallexample
@c computed example Matrix_orderings pdata.doc:1219 
  ring r = 0, (x,y,z), M(1, 0, 0,   0, 1, 0,   0, 0, 1);
@c end example Matrix_orderings pdata.doc:1219
@end smallexample
@*which may also be written as:
@smallexample
@c computed example Matrix_orderings_1 pdata.doc:1225 
  intmat m[3][3]=1, 0, 0, 0, 1, 0, 0, 0, 1;
  m;
@expansion{} 1,0,0,
@expansion{} 0,1,0,
@expansion{} 0,0,1 
  ring r = 0, (x,y,z), M(m);
  r;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering M
@expansion{} //                  : names    x y z 
@expansion{} //                  : weights  1 0 0 
@expansion{} //                  : weights  0 1 0 
@expansion{} //                  : weights  0 0 1 
@expansion{} //        block   2 : ordering C
@c end example Matrix_orderings_1 pdata.doc:1225
@end smallexample

If the ring has 
@tex
$n$
@end tex
n
variables and the matrix contains less than 
@tex
$n \times n$
@end tex
n x n 
entries an error message is given, if there are more entries,
the last ones are ignored.

@strong{WARNING:} @sc{Singular}
does not check whether the matrix has full rank.   In such a case some
computations might not terminate, others might give a nonsense result.

Having these matrix orderings @sc{Singular} can compute standard bases for
any monomial ordering which is compatible with the natural semigroup structure.
In practice the global and local orderings together with block orderings should be
sufficient in most cases. These orderings are faster than the corresponding
matrix orderings, since evaluating a matrix product is time consuming.

@c --------------------------------------------------------------------------
@node Product orderings, Extra weight vector, Matrix orderings, Monomial orderings
@subsection Product orderings
@cindex Product orderings
@cindex orderings, product

Let
x = (x_1, @dots{}, x_n) = x(1..n) and y = (y_1, @dots{}, y_m) =
y(1..m)
@tex
$x = (x_1, \ldots, x_n)$ and $y = (y_1, \ldots, y_m)$
@end tex
be two ordered sets of variables,
<_1 a monomial
ordering on K[x] and <_2 a monomial ordering on K[y].   The product
ordering (or block ordering) < = (<_1,<_2) on K[x,y] is the following:
@*x^a y^b < x^A y^B <==>
@*x^a <_1 x^A
@*or
@*x^a = x^A  and  y^b <_2 y^B.

Inductively one defines the product ordering of more than two monomial
orderings.

In @sc{Singular}, any of the above global orderings, local orderings or matrix
orderings may be combined (in an arbitrary manner and length) to a product
ordering.   E.g., @code{(lp(3), M(1, 2, 3, 1, 1, 1, 1, 0, 0), ds(4),
ws(1,2,3))} 
defines: @code{lp} on the first 3 variables, the matrix ordering
@code{M(1, 2, 3, 1, 1, 1, 1, 0, 0)} on the next 3 variables,
@code{ds} on the next 4 variables and
@code{ws(1,2,3)} on the last 3 variables.

@c --------------------------------------------------------------
@node Extra weight vector,  , Product orderings, Monomial orderings
@subsection Extra weight vector
@cindex Extra weight vector
@cindex a, ordering
@cindex orderings, a 

a(w_1, @dots{}, w_n),
@tex
${\tt a}(w_1, \ldots, w_n),\; $
@end tex
w_1,@dots{},w_n
@tex
$w_1,\ldots,w_n$
@end tex
any integers (including 0), defines
  deg(x^a) = w_1 a_1 + @dots{} + w_n a_n
@tex
$\deg(x^\alpha) = w_1 \alpha_1 + \cdots + w_n\alpha_n$
@end tex
and
@*
deg(x^a) < deg(x^b) ==> x^a < x^b 
@tex
    $$\deg(x^\alpha) < \deg(x^\beta) \Rightarrow x^\alpha < x^\beta,$$
@end tex
@*
deg(x^a) > deg(x^b) ==> x^a > x^b.
@tex
    $$\deg(x^\alpha) > \deg(x^\beta) \Rightarrow x^\alpha > x^\beta. $$
@end tex
@*An extra weight vector does not define a monomial ordering by itself:
it can only be used in combination with other orderings
to insert an extra line of weights into the ordering
matrix.

@*@strong{Example}:
@smallexample
ring r = 0, (x,y,z),  (a(1,2,3),wp(4,5,2));
ring s = 0, (x,y,z),  (a(1,2,3),dp);
ring q = 0, (a,b,c,d),(lp(1),a(1,2,3),ds);
@end smallexample

@c ----------------------------------------------------------------------------
@node Mathematical background, SINGULAR libraries, Polynomial data, Top
@appendix Mathematical background
@cindex Mathematical background
@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from math.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT math.doc INSTEAD
@comment Id: math.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the mathematical background of Singular

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').

This chapter introduces some of the mathematical notions and definitions used
throughout the manual. It is mostly a collection of the
most prominent definitions and properties. For details, please, refer to
some articles or text books (see @ref{References}).

@menu
* Standard bases::
* Hilbert function::
* Syzygies and resolutions::
* Characteristic sets::
* Gauss-Manin connection::
* Toric ideals and integer programming::
* References::
@end menu
@c ---------------------------------------------------------------------------
@node Standard bases, Hilbert function, ,Mathematical background
@section Standard bases
@cindex Standard bases

@subheading Definition
@tex
Let $R = \hbox{Loc}_< K[\underline{x}]$ and let $I$ be a submodule of $R^r$.
Note that for r=1 this means that $I$ is an ideal in $R$.
Denote by $L(I)$ the submodule of $R^r$ generated by the leading terms 
of elements of $I$, i.e. by $\left\{L(f) \mid f \in I\right\}$.
Then $f_1, \ldots, f_s \in I$ is called a {\bf standard basis} of $I$ 
if $L(f_1), \ldots, L(f_s)$ generate $L(I)$.
@end tex
Let R = Loc K[x] and let I be a submodule of $R^r$.
Denote by L(I) the submodule of R^r generated by the leading terms 
of elements in $I$, i.e. by @{ L(f) | f in I@}.
Then f_1, @dots{}, f_s in I is called a @strong{standard basis} of I 
if L(f_1), @dots{}, L(f_s) generate L(I).

@subheading Properties
@table @asis
@item normal form:
@cindex Normal form
@tex
A function $\hbox{NF} : R^r \times \{G \mid G\ \hbox{ a standard
basis}\} \to R^r, (p,G) \mapsto \hbox{NF}(p|G)$, is called a {\bf normal
form} if for any $p \in R^r$ and any standard basis $G$ the following
holds: if $\hbox{NF}(p|G) \not= 0$ then $L(g)$ does not divide
$L(\hbox{NF}(p|G))$ for all $g \in G$.

\noindent
$\hbox{NF}(p|G)$ is called a {\bf normal form of} $p$ {\bf with
respect to} $G$ (note that such a function is not unique).
@end tex
A function NF : R^r x @{G | G a standard basis@} -> R^r, (p,G) ->
NF(p|G), is called a @strong{normal form} if for any p in R^r and any
standard basis G the following holds: if NF(p|G) <> 0 then L(g) does not
divide L(NF(p|G)) for all g in G.
@*NF(p|G) is called a @strong{normal form} of p with respect to G (note
that such a function is not unique).
@item ideal membership:
@cindex Ideal membership
@tex
For a standard basis $G$ of $I$ the following holds: 
$f \in I$ if and only if $\hbox{NF}(f,G) = 0$.
@end tex
For a standart basis G of I the following holds: 
f in I if and only if NF(f,G) = 0.
@item Hilbert function:
@tex
Let \hbox{$I \subseteq K[\underline{x}]^r$} be a homogeneous module, then the Hilbert function
$H_I$ of $I$ (see below)
and the Hilbert function $H_{L(I)}$ of the leading module $L(I)$
coincide, i.e.,
$H_I=H_{L(I)}$.
@end tex
Let I in K[x]^r be a homogeneous ideal, then the Hilbert function H_I of I
and the Hilbert function H_L(I) of the leading ideal L(I) coincide.
@end table

@c ---------------------------------------------------------------------------
@node Hilbert function, Syzygies and resolutions, Standard bases, Mathematical background
@section Hilbert function
@cindex Hilbert function
@cindex Hilbert series
@tex
Let M $=\bigoplus_i M_i$ be a graded module over $K[x_1,..,x_n]$ with 
respect to weights $(w_1,..w_n)$.
The {\bf Hilbert function} of $M$, $H_M$, is defined (on the integers) by
$$H_M(k) :=dim_K M_k.$$
The {\bf Hilbert-Poincare series}  of $M$ is the power series
$$\hbox{HP}_M(t) :=\sum_{i=-\infty}^\infty
H_M(i)t^i=\sum_{i=-\infty}^\infty dim_K M_i \cdot t^i.$$
It turns out that $\hbox{HP}_M(t)$ can be written in two useful ways
for weights $(1,..,1)$:
$$\hbox{HP}_M(t)={Q(t)\over (1-t)^n}={P(t)\over (1-t)^{dim(M)}}$$
where $Q(t)$ and $P(t)$ are polynomials in ${\bf Z}[t]$.
$Q(t)$ is called the {\bf first Hilbert series},
and $P(t)$ the {\bf second Hilbert series}.
If \hbox{$P(t)=\sum_{k=0}^N a_k t^k$}, and \hbox{$d = dim(M)$},
then \hbox{$H_M(s)=\sum_{k=0}^N a_k$ ${d+s-k-1}\choose{d-1}$}
(the {\bf Hilbert polynomial}) for $s \ge N$.
@end tex
Let M =(+) M_i be a graded module over K[x_1,...,x_n] with
respect to weights (w_1,..w_n).
The Hilbert function of M H_M is defined by
@display
H_M(k)=dim_K M_k.
@end display
The Hilbert-Poincare series  of M is the power series
@display
HP_M(t)=sum_i dim_K (M_i)*t^i.
@end display
It turns out that HP_M(t) can be written in two useful ways
for weights $(1,..,1)$:
@display
H_M(t)=Q(t)/(1-t)^n=P(t)/(1-t)^dim(M).
@end display
where Q(t) and P(t) are polynomials in Z[t].
Q(t) is called the first Hilbert series, and P(t) the second Hilbert series.
If P(t)=sum_(k=0)^N a_k t^k, and d=dim(M),
then
@display
H_M(s)=sum_(k=0)^N a_k binomial(d+s-k-1,d-1) (the Hilbert polynomial)
@end display
for s >= N.
@*
@*
@tex
Generalizing these to quasihomogeneous modules we get
$$\hbox{HP}_M(t)={Q(t)\over {\Pi_{i=1}^n(1-t^{w_i})}}$$
where $Q(t)$ is a polynomial in ${\bf Z}[t]$.
$Q(t)$ is called the {\bf first (weighted) Hilbert series} of M.
@end tex
Generalizing these to quasihomogeneous modules we get
@display
H_M(t)=Q(t)/Prod((1-t)^(w_i)).
@end display
where Q(t) is a polynomial in Z[t].
Q(t) is called the first (weighted) Hilbert series of M.

@c ---------------------------------------------------------------------------
@node Syzygies and resolutions, Characteristic sets, Hilbert function, Mathematical background
@section Syzygies and resolutions
@cindex Syzygies and resolutions

@subheading Syzygies
@tex
Let $R$ be a quotient of $\hbox{Loc}_< K[\underline{x}]$ and let \hbox{$I=(g_1, ..., g_s)$} be a submodule of $R^r$.
Then the {\bf module of syzygies} (or {\bf 1st syzygy module}, {\bf module of relations}) of $I$, syz($I$), is defined to be the kernel of the map \hbox{$R^s \rightarrow R^r,\; \sum_{i=1}^s w_ie_i \mapsto \sum_{i=1}^s w_ig_i$.}
@end tex
Let R be a quotient of Loc K[x] and let I=(g_1, ..., g_s) be a submodule 
of R^r.
Then the @strong{module of syzygies} (or @strong{1st syzygy module}, @strong{module of relations}) of I, syz(I), is defined to be the kernel of the map
@display
R^s --> R^r,
w_1*e_1 + ... + w_s*e_s -> w_1*g_1 + ... + w_s*g_s.
@end display

The @strong{k-th syzygy module} is defined inductively to be the module
of syzygies of the
@tex
$(k-1)$-st 
@end tex
(k-1)-st 
 syzygy module.

@tex
Note, that the syzygy modules of $I$ depend on a choice of generators $g_1, ..., g_s$.
But one can show that they depend on $I$ uniquely up to direct summands.
@end tex
Note, that the syzygy modules of I depend on a choice of generators g_1, ..., g_s.
But one can show that they depend on I uniquely up to direct summands.

@table @code
@item @strong{Example:}
@smallexample
@c reused example Syzygies math.doc:213 
  ring R= 0,(u,v,x,y,z),dp;
  ideal i=ux, vx, uy, vy;
  print(syz(i));
@expansion{} -y,0, -v,0, 
@expansion{} 0, -y,u, 0, 
@expansion{} x, 0, 0, -v,
@expansion{} 0, x, 0, u  
@c end example Syzygies math.doc:213
@end smallexample
@end table

@subheading Free resolutions
@tex
Let $I=(g_1,...,g_s)\subseteq R^r$ and $M= R^r/I$.
A {\bf free resolution of $M$} is a long exact sequence
$$...\longrightarrow F_2 \buildrel{A_2}\over{\longrightarrow} F_1
\buildrel{A_1}\over{\longrightarrow} F_0\longrightarrow M\longrightarrow
0,$$
@end tex
Let I=(g_1,...,g_s) in R^r and M=R^r/I.  A free resolution of M is a
long exact sequence
@display
...--> F2 --A2-> F1 --A1-> F0-->M-->0,
@end display
@*where the columns of the matrix
@tex
$A_1$
@end tex
A_1
generate 
@math{I}
@tex
$I$
@end tex
. Note, that resolutions need not to be finite (i.e., of
finite length). The Hilbert Syzygy Theorem states, that for 
@tex
$R=\hbox{Loc}_< K[\underline{x}]$
@end tex
R=Loc K[x]
there exists a ("minimal") resolution of length not exceeding the number of
variables.

@table @code
@item @strong{Example:}
@smallexample
@c reused example Free_resolutions math.doc:257 
  ring R= 0,(u,v,x,y,z),dp;
  ideal I = ux, vx, uy, vy;
  resolution resI = mres(I,0); resI;
@expansion{}  1      4      4      1      
@expansion{} R <--  R <--  R <--  R
@expansion{} 
@expansion{} 0      1      2      3      
@expansion{} 
  // The matrix A_1 is given by
  print(matrix(resI[1]));
@expansion{} vy,uy,vx,ux
  // We see that the columns of A_1 generate I.
  // The matrix A_2 is given by
  print(matrix(resI[3]));
@expansion{} u, 
@expansion{} -v,
@expansion{} -x,
@expansion{} y  
@c end example Free_resolutions math.doc:257
@end smallexample
@end table

@subheading Betti numbers and regularity
@cindex Betti number
@cindex regularity
@tex
Let $R$ be a graded ring (e.g., $R = \hbox{Loc}_< K[\underline{x}]$) and
let $I \subset R^r$ be a graded submodule. Let
$$
  R^r = \bigoplus_a R\cdot e_{a,0} \buildrel A_1 \over \longleftarrow
        \bigoplus_a R\cdot e_{a,1} \longleftarrow \ldots \longleftarrow
        \bigoplus_a R\cdot e_{a,n} \longleftarrow 0
$$
be a minimal free resolution of $R^n/I$ considered with homogeneous maps
of degree 0. Then the {\bf graded Betti number} $b_{i,j}$ of $R^r/I$ is
the minimal number of generators $e_{a,j}$ in degree $i+j$ of the $j$-th
syzygy module of $R^r/I$ (i.e., the $(j-1)$-st syzygy module of
$I$). Note, that by definition the $0$-th syzygy module of $R^r/I$ is $R^r$
and the 1st syzygy module of $R^r/I$ is $I$.
@end tex
Let R be a graded ring (e.g., R = K[x]) and let I in R^r be a graded
submodule. Let
@display
R^r = (+) K[x]e(a,0) <--- (+) K[x]e(a,1)
            <--- @dots{} <--- (+) K[x]e(a,n) <--- 0
@end display
be a minimal free resolution of R^n/I considered with homogeneous maps
of degree 0. Then the @strong{graded Betti number} b_i,j of R^r/I is the
minimal number of generators e_a,j in degree i+j of the j-th syzygy
module of R^r/I (i.e., the (j-1)-st syzygy module of I). Note, that by
definition the 0th syzygy module of R^r/I is R^r and the 1st syzygy module
of R^r/I is I.

The @strong{regularity} of 
@math{I}
@tex
$I$
@end tex
 is the smallest integer 
@math{s}
@tex
$s$
@end tex

such that
@tex
$$
    \hbox{deg}(e_{a,j}) \le s+j-1 \quad \hbox{for all $j$.}
$$
@end tex
@display
deg(e(a,j)) <= s+j-1    for all j.
@end display

@table @code
@item @strong{Example:}
@smallexample
@c reused example Betti_numbers_and_regularity math.doc:319 
  ring R= 0,(u,v,x,y,z),dp;
  ideal I = ux, vx, uy, vy;
  resolution resI = mres(I,0); resI;
@expansion{}  1      4      4      1      
@expansion{} R <--  R <--  R <--  R
@expansion{} 
@expansion{} 0      1      2      3      
@expansion{} 
  // the betti number:
  print(betti(resI), "betti");
@expansion{}            0     1     2     3
@expansion{} ------------------------------
@expansion{}     0:     1     -     -     -
@expansion{}     1:     -     4     4     1
@expansion{} ------------------------------
@expansion{} total:     1     4     4     1
  // the regularity:
  regularity(resI);
@expansion{} 2
@c end example Betti_numbers_and_regularity math.doc:319
@end smallexample
@end table
@c ---------------------------------------------------------------------------
@node Characteristic sets, Gauss-Manin connection, Syzygies and resolutions, Mathematical background
@section Characteristic sets
@cindex Characteristic sets

@tex
Let $<$ be the lexicographical ordering on $R=K[x_1,...,x_n]$ with $x_1
< ... < x_n$.
For $f \in R$ let lvar($f$) (the leading variable of $f$) be the largest
variable in $f$,
i.e., if $f=a_s(x_1,...,x_{k-1})x_k^s+...+a_0(x_1,...,x_{k-1})$ for some
$k \leq n$ then lvar$(f)=x_k$.

Moreover, let
\hbox{ini}$(f):=a_s(x_1,...,x_{k-1})$. The pseudo remainder
$r=\hbox{prem}(g,f)$ of $g$ with respect to $f$ is
defined by the equality $\hbox{ini}(f)^a\cdot g = qf+r$ with
$\hbox{deg}_{lvar(f)}(r)<\hbox{deg}_{lvar(f)}(f)$ and $a$
minimal.

A set $T=\{f_1,...,f_r\} \subset R$ is called triangular if
$\hbox{lvar}(f_1)<...<\hbox{lvar}(f_r)$. Moreover, let $ U \subset T $,
then $(T,U)$ is called a triangular system, if $T$ is a triangular set
such that $\hbox{ini}(T)$ does not vanish on $V(T) \setminus V(U)
(=:V(T\setminus U))$.

$T$ is called irreducible if for every $i$ there are no
$d_i$,$f_i'$,$f_i''$ such that
$$   \hbox{lvar}(d_i)<\hbox{lvar}(f_i) =
\hbox{lvar}(f_i')=\hbox{lvar}(f_i''),$$
$$   0 \not\in \hbox{prem}(\{ d_i, \hbox{ini}(f_i'),
\hbox{ini}(f_i'')\},\{ f_1,...,f_{i-1}\}),$$
$$\hbox{prem}(d_if_i-f_i'f_i'',\{f_1,...,f_{i-1}\})=0.$$
Furthermore, $(T,U)$ is called irreducible if $T$ is irreducible.

The main result on triangular sets is the following:
let $G=\{g_1,...,g_s\} \subset R$ then there are irreducible triangular sets $T_1,...,T_l$
such that $V(G)=\bigcup_{i=1}^{l}(V(T_i\setminus I_i))$
where $I_i=\{\hbox{ini}(f) \mid f \in T_i \}$. Such a set
$\{T_1,...,T_l\}$ is called an {\bf irreducible characteristic series} of
the ideal $(G)$.
@end tex
Let > be the lexicographical ordering on R=K[x_1,...,x_n] with x_1<...<x_n .
For f in R let lvar(f) (the leading variable of f) be the largest
variable in lead(f) (the leading term of f with respect to >),
i.e., if f=a_s(x_1,...,x_(k-1))x_k^s+...+a_0(x_1,...,x_(k-1)) for some
k<=n then lvar(f)=x_k.

Moreover, let ini(f):=a_s(x_1,...,x_(k-1)). The pseudo remainder
r=prem(g,f) of g with respect to f is defined by ini(f)^a*g=q*f+r with
the property deg_(lvar(f))(r)<deg_(lvar(f))(f), @code{a} minimal.

A set T=@{f_1,...,f_r@} in R is called triangular if lvar(f_1)<...<lvar(f_r).

(T,U) is called a triangular system, if U is a subset of T and
if T is a triangular set such that ini(T)
does not vanish on the zero-set of T \ zero-set of U
( =:Zero(T\U)).

T is called irreducible if for every i there are no d_i,f_i',f_i'' with
the property:
@display
lvar(d_i)<lvar(f_i)
lvar(f_i')=lvar(f_i'')=lvar(f_i)
0 not in prem(@{ d_i, ini(f_i'), ini(f_i'')@},@{ f_1,...,f_(i-1)@})
@end display
such that prem(d_i*f_i-f_i'*f_i'',@{f_1,...,f_(i-1)@})=0.

(T,U) is called irreducible if T is irreducible.

The main result on triangular sets is the following: let
G=@{g_1,...,g_s@} then there are irreducible triangular sets T_1,...,T_l
such that Zero(G)=Union(i=1,...,l: Zero(T_i\I_i)) where I_i=@{ini(f), f
in T_i @}.  Such a set @{T_1,...,T_l@} is called an @strong{irreducibel
characteristic series} of the ideal (G).

@table @code
@item @strong{Example:}
@smallexample
@c reused example Characteristic_sets math.doc:411 
  ring R= 0,(x,y,z,u),dp;
  ideal i=-3zu+y2-2x+2,
          -3x2u-4yz-6xz+2y2+3xy,
          -3z2u-xu+y2z+y;
  print(char_series(i));
@expansion{} _[1,1],3x2z-y2+2yz,3x2u-3xy-2y2+2yu,
@expansion{} x,     -y+2z,      -2y2+3yu-4       
@c end example Characteristic_sets math.doc:411
@end smallexample
@end table
@c ---------------------------------------------------------------------------
@node Gauss-Manin connection, Toric ideals and integer programming, Characteristic sets, Mathematical background
@section Gauss-Manin connection
@cindex Gauss-Manin connection

@c the following text contain too much math code, so there are
@c tex and info versions of it. It end just before the introducing text
@c to the first example.

@tex
Let $f\colon(C^{n+1},0)\rightarrow(C,0)$ be a complex isolated hypersurface singularity given by a polynomial with algebraic coefficients which we also denote by $f$.
Let $O=C[x_0,\ldots,x_n]_{(x_0,\ldots,x_n)}$ be the local ring at the origin and $J_f$ the Jacobian ideal of $f$.

A {\bf Milnor representative} of $f$ defines a differentiable fibre bundle over the punctured disc with fibres of homotopy type of $\mu$ $n$-spheres.
The $n$-th cohomology bundle is a flat vector bundle of dimension $n$ and carries a natural flat connection with covariant derivative $\partial_t$.
The {\bf monodromy operator} is the action of a positively oriented generator of the fundamental group of the puctured disc on the Milnor fibre.
Sections in the cohomology bundle of {\bf moderate growth} at $0$ form a regular $D=C\{t\}[\partial_t]$-module $G$, the {\bf Gauss-Manin connection}.

By integrating along flat multivalued families of cycles, one can consider fibrewise global holomorphic differential forms as elements of $G$.
This factors through an inclusion of the {\bf Brieskorn lattice} $H'':=\Omega^{n+1}_{C^{n+1},0}/df\wedge d\Omega^{n-1}_{C^{n+1},0}$ in $G$.

The $D$-module structure defines the {\bf V-filtration} $V$ on $G$ by $V^\alpha:=\sum_{\beta\ge\alpha}C\{t\}ker(t\partial_t-\beta)^{n+1}$.
The Brieskorn lattice defines the {\bf Hodge filtration} $F$ on $G$ by $F_k=\partial_t^kH''$ which comes from the {\bf mixed Hodge structure} on the Milnor fibre.
Note that $F_{-1}=H'$.

The induced V-filtration on the Brieskorn lattice determines the {\bf singularity spectrum} $Sp$ by $Sp(\alpha):=\dim_CGr_V^\alpha Gr^F_0G$.
The spectrum consists of $\mu$ rational numbers $\alpha_1,\dots,\alpha_\mu$ such that $e^{2\pi i\alpha_1},\dots,e^{2\pi i\alpha_\mu}$ are the eigenvalues of the monodromy.
These {\bf spectral numbers} lie in the open interval $(-1,n)$, symmetric about the midpoint $(n-1)/2$.

The spectrum is constant under $\mu$-constant deformations and has the following semicontinuity property:
The number of spectral numbers in an interval $(a,a+1]$ of all singularities of a small deformation of $f$ is greater or equal to that of f in this interval.
For semiquasihomogeneous singularities, this also holds for intervals of the form $(a,a+1)$.

Two given isolated singularities $f$ and $g$ determine two spectra and from these spectra we get an integer.
This integer is the maximal positive integer $k$ such that the semicontinuity holds for the spectrum of $f$ and $k$ times the spectrum of $g$.
These numbers give bounds for the maximal number of isolated singularities of a specific type on a hypersurface $X\subset{P}^n$ of degree $d$: 
such a hypersurface has a smooth hyperplane section, and the complement is a small deformation of a cone over this hyperplane section.
The cone itself being a $\mu$-constant deformation of $x_0^d+\dots+x_n^d=0$, the singularities are bounded by the spectrum of $x_0^d+\dots+x_n^d$.

Using the library {\tt gaussman.lib} one can compute the {\bf monodromy}, the V-filtration on $H''/H'$, and the spectrum.
@end tex

Let f:(C^(n+1),0)--->(C,0) be a complex isolated hypersurface singularity given by a polynomial with algebraic coefficients which we also denote by f.
Let O=C[x_0,...,x_n]_(x_0,...,x_n) be the local ring at the origin and J_f the Jacobian ideal of f.

A @strong{Milnor representative} of f defines a differentiable fibre bundle over the punctured disc with fibres of homotopy type of mu n-spheres.
The n-th cohomology bundle is a flat vector bundle of dimension n and carries a natural flat connection with covariant derivative d_t.
The @strong{monodromy operator} is the action of a positively oriented generator of the fundamental group of the puctured disc on the Milnor fibre.
Sections in the cohomology bundle of @strong{moderate growth} at 0 form a regular D=C@{t@}[d_t]-module G, the @strong{Gauss-Manin connection}.

By integrating along flat multivalued families of cycles, one can consider fibrewise global holomorphic differential forms as elements of G.
This factors through an inclusion of the @strong{Brieskorn lattice} H'':=Omega^(n+1)_(C^(n+1),0)/df*dOmega^(n-1)_(C^(n+1),0) in G.

The D-module structure defines the @strong{V-filtration} V on G by V^a:=sum_(b>=a)C@{t@}ker(t*d_t-b)^(n+1).
The Brieskorn lattice defines the @strong{Hodge filtration} F on G by F_k=d_t^kH'' which comes from the @strong{mixed Hodge structure} on the Milnor fibre.
Note that F_(-1)=H'.

The induced V-filtration on the Brieskorn lattice determines the @strong{singularity spectrum} Sp by Sp(a):=dim_CGr_V^a Gr^F_0G.
The spectrum consists of mu rational numbers a_1,...,a_mu such that exp(2*pi*i*a_1),...,exp(2*pi*i*a_mu) are the eigenvalues of the monodromy.
These @strong{spectral numbers} lie in the open interval (-1,n), symmetric about the midpoint (n-1)/2.

The spectrum is constant under mu-constant deformations and has the following semicontinuity property:
The number of spectral numbers in an interval (a,a+1] of all singularities of a small deformation of f is greater or equal to that of f in this interval.
For semiquasihomogeneous singularities, this also holds for intervals of the form (a,a+1).

Two given isolated singularities f and g determine two spectra and from these spectra we get an integer.
This integer is the maximal positive integer k such that the semicontinuity holds for the spectrum of f and k times the spectrum of g.
These numbers give bounds for the maximal number of isolated singularties of a specific type on a hypersurface X in P^n of degree d: 
such a hypersurface has a smooth hyperplane section, and the complement is a small deformation of a cone over this hyperplane section.
The cone itself being a mu-constant deformation of x_0^d+...+x_n^d=0, the singularities are bounded by the spectrum of x_0^d+...+x_n^d.

Using the library @code{gaussman.lib} one can compute the @strong{monodromy}, the V-filtration on H''/H', and the spectrum.

Let us consider as an example 
@math{f=x^5+x^2y^2+y^5}
@tex
$f=x^5+x^2y^2+y^5$
@end tex
.
First, we compute a matrix 
@math{M}
@tex
$M$
@end tex
 such that
@tex
$\exp(2\pi iM)$
@end tex
exp(-2*pi*i*M)
is a monodromy matrix of 
@math{f}
@tex
$f$
@end tex
 and the Jordan normal form of 
@math{M}
@tex
$M$
@end tex
:
@smallexample
@c reused example Gauss-Manin_connection math.doc:505 
  LIB "gaussman.lib";
  ring R=0,(x,y),ds;
  poly f=x5+x2y2+y5;
  list l=monodromy(f);
  matrix M=jordanmatrix(l[1],l[2],l[3]);
  print(M);
@expansion{} 1/2,0,  0,   0,   0,   0,   0,0,    0,    0,    0,   
@expansion{} 1,  1/2,0,   0,   0,   0,   0,0,    0,    0,    0,   
@expansion{} 0,  0,  7/10,0,   0,   0,   0,0,    0,    0,    0,   
@expansion{} 0,  0,  0,   7/10,0,   0,   0,0,    0,    0,    0,   
@expansion{} 0,  0,  0,   0,   9/10,0,   0,0,    0,    0,    0,   
@expansion{} 0,  0,  0,   0,   0,   9/10,0,0,    0,    0,    0,   
@expansion{} 0,  0,  0,   0,   0,   0,   1,0,    0,    0,    0,   
@expansion{} 0,  0,  0,   0,   0,   0,   0,11/10,0,    0,    0,   
@expansion{} 0,  0,  0,   0,   0,   0,   0,0,    11/10,0,    0,   
@expansion{} 0,  0,  0,   0,   0,   0,   0,0,    0,    13/10,0,   
@expansion{} 0,  0,  0,   0,   0,   0,   0,0,    0,    0,    13/10
@c end example Gauss-Manin_connection math.doc:505
@end smallexample

Now, we compute the V-filtration on 
@math{H''/H'}
@tex
$H''/H'$
@end tex
 and the spectrum:
@smallexample
@c reused example Gauss-Manin_connection_1 math.doc:517 
  LIB "gaussman.lib";
  ring R=0,(x,y),ds;
  poly f=x5+x2y2+y5;
  list l=vfilt(f);
  print(l[1]);
@expansion{} -1/2,
@expansion{} -3/10,
@expansion{} -1/10,
@expansion{} 0,
@expansion{} 1/10,
@expansion{} 3/10,
@expansion{} 1/2
  print(l[2]);
@expansion{} 1,2,2,1,2,2,1
  print(l[3]);
@expansion{} [1]:
@expansion{}    _[1]=gen(11)
@expansion{} [2]:
@expansion{}    _[1]=gen(10)
@expansion{}    _[2]=gen(6)
@expansion{} [3]:
@expansion{}    _[1]=gen(9)
@expansion{}    _[2]=gen(4)
@expansion{} [4]:
@expansion{}    _[1]=gen(5)
@expansion{} [5]:
@expansion{}    _[1]=gen(3)
@expansion{}    _[2]=gen(8)
@expansion{} [6]:
@expansion{}    _[1]=gen(2)
@expansion{}    _[2]=gen(7)
@expansion{} [7]:
@expansion{}    _[1]=gen(1)
  print(l[4]);
@expansion{} y5,
@expansion{} y4,
@expansion{} y3,
@expansion{} y2,
@expansion{} xy,
@expansion{} y,
@expansion{} x4,
@expansion{} x3,
@expansion{} x2,
@expansion{} x,
@expansion{} 1
@c end example Gauss-Manin_connection_1 math.doc:517
@end smallexample
Here @code{l[1]} contains the spectral numbers, @code{l[2]} the corresponding multiplicities, @code{l[3]} a 
@math{C}
@tex
$C$
@end tex
-basis of the V-filtration on 
@math{H''/H'}
@tex
$H''/H'$
@end tex
 in terms of the monomial basis of
@tex
$O/J_f\cong H''/H'$
@end tex
O/J_f~=H''/H' 
in @code{l[4]}.

@tex
If the principal part of $f$ is $C$-nondegenerate, one can compute the spectrum using the library {\tt spectrum.lib}.
In this case, the V-filtration on $H''$ coincides with the Newton-filtration on $H''$ which allows to compute the spectrum more efficiently.
@end tex

If the principal part of f is C-nondegenerate, one can compute the spectrum using the library @code{spectrum.lib}.
In this case, the V-filtration on H'' coincides with the Newton-filtration on H'' which allows to compute the spectrum more efficiently.

Let us calculate one specific example, the maximal number 
of triple points of type
@tex
$\tilde{E}_6$ on a surface $X\subset{P}^3$
@end tex
E~_6 on a surface X in P^3
of degree seven.
This calculation can be done over the rationals.
So choose a local ordering on 
@math{Q[x,y,z]}
@tex
$Q[x,y,z]$
@end tex
. Here we take the
negative degree lexicographical ordering which is denoted
@code{ds} in @sc{Singular}:

@smallexample
@c reused example Gauss-Manin_connection_2 math.doc:562 
ring r=0,(x,y,z),ds;
LIB "spectrum.lib";
poly f=x^7+y^7+z^7;
list s1=spectrumnd( f );
s1;
@expansion{} [1]:
@expansion{}    _[1]=-4/7
@expansion{}    _[2]=-3/7
@expansion{}    _[3]=-2/7
@expansion{}    _[4]=-1/7
@expansion{}    _[5]=0
@expansion{}    _[6]=1/7
@expansion{}    _[7]=2/7
@expansion{}    _[8]=3/7
@expansion{}    _[9]=4/7
@expansion{}    _[10]=5/7
@expansion{}    _[11]=6/7
@expansion{}    _[12]=1
@expansion{}    _[13]=8/7
@expansion{}    _[14]=9/7
@expansion{}    _[15]=10/7
@expansion{}    _[16]=11/7
@expansion{} [2]:
@expansion{}    1,3,6,10,15,21,25,27,27,25,21,15,10,6,3,1
@c end example Gauss-Manin_connection_2 math.doc:562
@end smallexample

The command @code{spectrumnd(f)} computes the spectrum of 
@math{f}
@tex
$f$
@end tex
 and
returns a list with six entries:
The Milnor number
@tex
$\mu(f)$, the geometric genus $p_g(f)$
@end tex
mu(f), the geometric genus p_g(f)
and the number of different spectrum numbers.
The other three entries are of type @code{intvec}.
They contain the numerators, denominators and
multiplicities of the spectrum numbers. So
@tex
$x^7+y^7+z^7=0$
@end tex
x^7+y^7+z^7=0
has Milnor number 216 and geometrical
genus 35. Its spectrum consists of the 16 different rationals
@*
@tex
${3 \over 7}, {4 \over 7}, {5 \over 7}, {6 \over 7}, {1 \over 1},
{8 \over 7}, {9 \over 7}, {10 \over 7}, {11 \over 7}, {12 \over 7},
{13 \over 7}, {2 \over 1}, {15 \over 7}, {16 \over 7}, {17 \over 7},
{18 \over 7}$
@end tex
3/7, 4/7, 5/7, 6/7, 1, 8/7, 9/7, 10/7, 11/7, 12/7, 13/7, 2, 15/7, 16/7, 17/7, 
18/7
@*appearing with multiplicities
@*1,3,6,10,15,21,25,27,27,25,21,15,10,6,3,1.

@tex
The singularities of type $\tilde{E}_6$ form a
$\mu$-constant one parameter family given by
$x^3+y^3+z^3+\lambda xyz=0,\quad \lambda^3\neq-27$.
@end tex
The singularities of type E~_6 form a
mu-constant one parameter family given by
x^3+y^3+z^3+lambda xyz=0, lambda^3 <> -27.
Therefore they have all the same spectrum, which we compute
for 
@tex
$x^3+y^3+z^3$.
@end tex
@math{x^3+y^3+z^3}.

@smallexample
poly g=x^3+y^3+z^3;
list s2=spectrumnd(g);
s2;
@expansion{} [1]:
@expansion{}    8
@expansion{} [2]:
@expansion{}    1
@expansion{} [3]:
@expansion{}    4
@expansion{} [4]:
@expansion{}    1,4,5,2
@expansion{} [5]:
@expansion{}    1,3,3,1
@expansion{} [6]:
@expansion{}    1,3,3,1
@end smallexample
Evaluating semicontinuity is very easy:
@smallexample
semicont(s1,s2);
@expansion{} 18
@end smallexample

This tells us that there are at most 18 singularities of type
@tex
$\tilde{E}_6$ on a septic in $P^3$. But $x^7+y^7+z^7$
@end tex
E~_6 on a septic in P^3. But x^7+y^7+z^7
is semiquasihomogeneous (sqh), so we can also apply the stronger
form of semicontinuity:

@smallexample
semicontsqh(s1,s2);
@expansion{} 17
@end smallexample

So in fact a septic has at most 17 triple points of type
@tex
$\tilde{E}_6$.
@end tex
E~_6.

Note that @code{spectrumnd(f)} works only if 
@math{f}
@tex
$f$
@end tex
 has nondegenerate
principal part. In fact @code{spectrumnd} will detect a degenerate
principal part in many cases and print out an error message.
However if it is known in advance that 
@math{f}
@tex
$f$
@end tex
 has nondegenerate
principal part, then the spectrum may be computed much faster
using @code{spectrumnd(f,1)}.

@c ---------------------------------------------------------------------------
@node Toric ideals and integer programming, References, Gauss-Manin connection, Mathematical background
@section Toric ideals and integer programming
@cindex Toric ideals and integer programming

@menu
* Toric ideals::                Definition and computation.
* Integer programming::         An algorithm using toric ideals.
* Relevant References::
@end menu

@node Toric ideals, Integer programming, , Toric ideals and integer programming

@subsection Toric ideals
@cindex toric ideals
@comment This file was generated by doc2tex.pl from ti_ip.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT ti_ip.doc INSTEAD
@cindex ideal, toric

@tex
Let $A$ denote an $m\times n$ matrix with integral coefficients. For $u
\in Z\!\!\! Z^n$, we define $u^+,u^-$ to be the uniquely determined
vectors with nonnegative coefficients and disjoint support (i.e.,
$u_i^+=0$ or $u_i^-=0$ for each component $i$) such that
$u=u^+-u^-$. For $u\geq 0$ component-wise, let $x^u$ denote the monomial
$x_1^{u_1}\cdot\ldots\cdot x_n^{u_n}\in K[x_1,\ldots,x_n]$.

The ideal
$$ I_A:=<x^{u^+}-x^{u^-} | u\in\ker(A)\cap Z\!\!\! Z^n>\ \subset
K[x_1,\ldots,x_n] $$
is called a \bf toric ideal. \rm

The first problem in computing toric ideals is to find a finite
generating set: Let $v_1,\ldots,v_r$ be a lattice basis of $\ker(A)\cap
Z\!\!\! Z^n$ (i.e, a basis of the $Z\!\!\! Z$-module). Then
$$ I_A:=I:(x_1\cdot\ldots\cdot x_n)^\infty $$
where
$$ I=<x^{v_i^+}-x^{v_i^-}|i=1,\ldots,r> $$
@end tex

Let A denote an mxn matrix with integral coefficients. For u in
Z^n, we define u+,u- to be the uniquely determined vectors with
nonnegative coefficients and disjoint support (i.e., u+[i]=0 or u-[i]=0
for each component i) such that u = u+ - u-.
For u>=0 component-wise, let x^u
denote the monomial x(1)^u[1] *@dots{}* x(n)^u[n] in K[x(1),@dots{},x(n)].

The ideal in K[x(1),@dots{},x(n)] @*
@display
I(A):= < x^u+ - x^u- | u in ker(A), u in Z^n >
@end display
is called a @strong{toric ideal}.

The first problem in computing toric ideals is to find a finite
generating set: Let v(1),@dots{},v(r) be a lattice basis of ker(A) as a
subset of Z^n (i.e., a basis of the Z-module). Then @*
@display
I(A):= sat( I, x[1] *@dots{}* x[n])
@end display
where @*
@display
I= < x^v(i)+ - x^v(i)- | i=1,@dots{},r >.
@end display

The required lattice basis can be computed using the LLL-algorithm (@pxref{[Coh93]}). For the computation of the saturation, there are various
possibilities described in the
@tex
section Algorithms.
@end tex
menu entry Algorithms.

@menu
* Algorithms::             Various algorithms for computing toric ideals.
* Buchberger algorithm::   Specializing it for toric ideals.
@end menu

@node Algorithms, Buchberger algorithm, , Toric ideals
@subsection Algorithms

The following algorithms are implemented in @ref{toric_lib}.

@menu
* Conti and Traverso::
* Pottier::
* Hosten and Sturmfels::
* Di Biase and Urbanke::
* Bigatti and La Scala and Robbiano::
@end menu

@node Conti and Traverso, Pottier, , Algorithms

@subsubsection The algorithm of Conti and Traverso
@cindex Conti-Traverso algorithm
@cindex algorithm of Conti and Traverso


The algorithm of Conti and Traverso (@pxref{[CoTr91]})
@tex
computes $I_A$ via the
extended matrix $B=(I_m|A)$,
where $I_m$ is the $m\times m$ unity matrix. A lattice basis of $B$ is
given by the set of vectors $(a^j,-e_j)\in Z\!\!\! Z^{m+n}$, where $a^j$
is the $j$-th row of $A$ and $e_j$ the $j$-th coordinate vector. We
look at the ideal in $K[y_1,\ldots,y_m,x_1,\ldots,x_n]$ corresponding to
these vectors, namely
$$ I_1=<y^{a_j^+}- x_j y^{a_j^-} | j=1,\ldots, n>.$$
We introduce a further variable $t$ and adjoin the binomial $t\cdot
y_1\cdot\ldots\cdot y_m -1$ to the generating set of $I_1$, obtaining
an ideal $I_2$ in the polynomial ring $K[t,
y_1,\ldots,y_m,x_1,\ldots,x_n]$. $I_2$ is saturated w.r.t. all
variables because all variables are invertible modulo $I_2$. Now $I_A$
can be computed from $I_2$ by eliminating the variables
$t,y_1,\ldots,y_m$.
@end tex
computes I(A) via the extended matrix B= ( I | A ),
where I is the mxm unity matrix. A lattice basis of B is given by the
set of vectors (a^j,-e_j) in Z^(m+n), where a^j is the j-th row of A and
e_j the j-th coordinate vector. We look at the ideal in
K[y(1),@dots{},y(m),x(1),@dots{},x(n)] corresponding to these vectors,
namely @*
@display
I1= < y^(a_j)+ - x(j) * y^(a_j)- | j=1,@dots{},n >.
@end display
We introduce a further variable t and adjoin the binomial t * y(1)
*@dots{}* y(m) -1 to the generating set of I1, obtaining an ideal I2 in
the polynomial ring K[t,y(1),@dots{},y(m),x(1),@dots{},x(n)]. I2 is
saturated w.r.t.@: all variables because all variables are invertible
modulo I2. Now I(A) can be computed from I2 by eliminating the variables
t,y(1),@dots{},y(m).

Because of the big number of auxiliary variables needed to compute a
toric ideal, this algorithm is rather slow in practice. However, it has
a special importance in the application to integer programming
(@pxref{Integer programming}).

@node Pottier, Hosten and Sturmfels, Conti and Traverso, Algorithms

@subsubsection The algorithm of Pottier
@cindex Pottier algorithm
@cindex algorithm of Pottier


The algorithm of Pottier (@pxref{[Pot94]}) starts by computing a lattice
@tex
basis $v_1,\ldots,v_r$ for the integer kernel of $A$ using the
LLL-algorithm. The ideal corresponding to the lattice basis vectors
$$ I_1=<x^{v_i^+}-x^{v_i^-}|i=1,\ldots,r> $$
is saturated -- as in the algorithm of Conti and Traverso -- by
inversion of all variables: One adds an auxiliary variable $t$ and the
generator $t\cdot x_1\cdot\ldots\cdot x_n -1$ to obtain an ideal $I_2$
in $K[t,x_1,\ldots,x_n]$ from which one computes $I_A$ by elimination of
$t$.
@end tex
basis v(1),@dots{},v(r) for the integer kernel of A using the
LLL-algorithm. The ideal corresponding to the lattice basis vectors @*
@display
I1= < x^v(i)+ - x^v(i)- | i=1,@dots{},r >
@end display
is saturated -- as in the algorithm of Conti and Traverso -- by
inversion of all variables: One adds an auxiliary variable t and the
generator t * x(1) *@dots{}* x(n) -1 to obtain an ideal I2 in
K[t,x(1),@dots{},x(n)] from which one computes I(A) by elimination of
t.


@node Hosten and Sturmfels, Di Biase and Urbanke, Pottier, Algorithms

@subsubsection The algorithm of Hosten and Sturmfels
@cindex Hosten-Sturmfels algorithm
@cindex algorithm of Hosten and Sturmfels


The algorithm of Hosten and Sturmfels (@pxref{[HoSt95]}) allows to
@tex
compute $I_A$ without any auxiliary variables, provided that $A$ contains a vector $w$
with positive coefficients in its row space. This is a real restriction,
i.e., the algorithm will not necessarily work in the general case.

A lattice basis $v_1,\ldots,v_r$ is again computed via the
LLL-algorithm. The saturation step is performed in the following way:
First note that $w$ induces a positive grading w.r.t. which the ideal
$$ I=<x^{v_i^+}-x^{v_i^-}|i=1,\ldots,r> $$
corresponding to our lattice basis is homogeneous. We use the following
lemma:

Let $I$ be a homogeneous ideal w.r.t. the weighted reverse
lexicographical ordering with weight vector $w$ and variable order $x_1
> x_2 > \ldots > x_n$. Let $G$ denote a Groebner basis of $I$ w.r.t. to
this ordering.  Then a Groebner basis of $(I:x_n^\infty)$ is obtained by
dividing each element of $G$ by the highest possible power of $x_n$.

From this fact, we can successively compute
$$ I_A= I:(x_1\cdot\ldots\cdot x_n)^\infty
=(((I:x_1^\infty):x_2^\infty):\ldots :x_n^\infty); $$
in the $i$-th step we take $x_i$ as the cheapest variable and apply the
lemma with $x_i$ instead of $x_n$.

This procedure involves $n$ Groebner basis computations. Actually, this
number can be reduced to at most $n/2$
@end tex
compute I(A) without any auxiliary variables, provided that A contains a vector w
with positive coefficients in its row space. This is a real restriction,
i.e., the algorithm will not necessarily work in the general case.

A lattice basis v(1),@dots{},v(r) is again computed via the
LLL-algorithm. The saturation step is performed in the following way:
First note that w induces a positive grading w.r.t.@: which the ideal @*
@display
I= < x^v(i)+ - x^v(i)- | i=1,@dots{},r >
@end display
corresponding to our lattice basis is homogeneous. We use the following
lemma:

Let I be a homogeneous ideal w.r.t.@: the weighted reverse lexicographical
ordering with weight vector w and variable order x(1) > x(2) > @dots{} >
x(n). Let G denote a Groebner basis of I w.r.t.@: to this ordering.  Then
a Groebner basis of sat(I,x(n)) is obtained by dividing each element
of G by the highest possible power of x(n).

From this fact, we can successively compute @*
@display
I(A)= sat(I, x(1) *@dots{}* x(n))
@ @ @ @ = sat(@dots{}(sat(sat(I,x(1)), x(2)), @dots{}, x(n)));
@end display
in the i-th step we take x(i) as the cheapest variable and apply the
lemma with x(i) instead of x(n).

This procedure involves n Groebner basis computations. Actually, this
number can be reduced to at most n/2
(@pxref{[HoSh98]}), and the single
computations -- except from the first one -- show to be easy and fast in
practice.

@node Di Biase and Urbanke, Bigatti and La Scala and Robbiano, Hosten and Sturmfels, Algorithms

@subsubsection The algorithm of Di Biase and Urbanke
@cindex Di Biase-Urbanke algorithm
@cindex algorithm of Di Biase and Urbanke

Like the algorithm of Hosten and Sturmfels, the algorithm of Di Biase
and Urbanke (@pxref{[DBUr95]}) performs up
@tex
to $n/2$ Groebner basis
computations. It needs no auxiliary variables, but a supplementary
precondition; namely, the existence of a vector without zero components
in the kernel of $A$.

The main idea comes from the following observation:

Let $B$ be an integer matrix, $u_1,\ldots,u_r$ a lattice basis of the
integer kernel of $B$. Assume that all components of $u_1$ are
positive. Then
$$ I_B=<x^{u_i^+}-x^{u_i^-}|i=1,\ldots,r>, $$
i.e., the ideal on the right is already saturated w.r.t. all variables.

The algorithm starts by finding a lattice basis $v_1,\ldots,v_r$ of the
kernel of $A$ such that $v_1$ has no zero component. Let
$\{i_1,\ldots,i_l\}$ be the set of indices $i$ with
$v_{1,i}<0$. Multiplying the components $i_1,\ldots,i_l$ of
$v_1,\ldots,v_r$ and the columns $i_1,\ldots,i_l$ of $A$ by $-1$ yields
a matrix $B$ and a lattice basis $u_1,\ldots,u_r$ of the kernel of $B$
that fulfill the assumption of the observation above. We are then able
to compute a generating set of $I_A$ by applying the following
``variable flip'' successively to $i=i_1,\ldots,i_l$:

Let $>$ be an elimination ordering for $x_i$. Let $A_i$ be the matrix
obtained by multiplying the $i$-th column of $A$ with $-1$. Let
$$\{x_i^{r_j} x^{a_j} - x^{b_j} | j\in J \}$$
be a Groebner basis of $I_{A_i}$ w.r.t. $>$ (where $x_i$ is neither
involved in $x^{a_j}$ nor in $x^{b_j}$). Then
$$\{x^{a_j} - x_i^{r_j} x^{b_j} | j\in J \}$$
is a generating set for $I_A$.
@end tex
to n/2 Groebner basis
computations. It needs no auxiliary variables, but a supplementary
precondition; namely, the existence of a vector without zero components
in the kernel of A.

The main idea comes from the following observation:

Let B be an integer matrix, u(1),@dots{},u(r) a lattice basis of the
integer kernel of B. Assume that all components of u(1) are
positive. Then @*
@display
I(B)= < x^u(i)+ - x^u(i)- | i=1,@dots{},r >,
@end display
i.e., the ideal on the right is already saturated w.r.t.@: all variables.

The algorithm starts by finding a lattice basis v(1),@dots{},v(r) of the
kernel of A such that v(1) has no zero component. Let @{ i1,@dots{},il
@} be the set of indices i with v(1)_i <0. Multiplying the components
i1,@dots{},il of v(1),@dots{},v(r) and the columns i1,@dots{},il of A by
-1 yields a matrix B and a lattice basis u(1),@dots{},u(r) of the kernel
of B that fulfill the assumption of the observation above. We are then
able to compute a generating set of I(A) by applying the following
``variable flip'' successively to i=i1,@dots{},il:

Let > be an elimination ordering for x(i). Let A(i) be the matrix
obtained by multiplying the i-th column of A with -1. Let @*
@display
@{ x(i)^r(j) * x^a(j) - x^b(j) | j in J @}
@end display
be a Groebner basis of I(A(i)) w.r.t.@: > (where x(i) is neither
involved in x^a(j) nor in x^b(j)). Then @*
@display
@{ x^a(j) - x(i)^r(j) * x^b(j) | j in J @}
@end display
is a generating set for I(A).

@node Bigatti and La Scala and Robbiano, , Di Biase and Urbanke, Algorithms

@subsubsection The algorithm of Bigatti, La Scala and Robbiano
@cindex Bigatti-La Scala-Robbiano algorithm
@cindex algorithm of Bigatti, La Scala and Robbiano

The algorithm of Bigatti, La Scala and Robbiano (@pxref{[BLR98]}) combines the ideas of
the algorithms of Pottier and of Hosten and Sturmfels. The
computations are performed on a graded ideal with one auxiliary
@tex
variable $u$ and one supplementary generator $x_1\cdot\ldots\cdot x_n -
u$ (instead of the generator $t\cdot x_1\cdot\ldots\cdot x_n -1$ in
the algorithm of Pottier). The algorithm uses a quite unusual technique to
get rid of the variable $u$ again.
@end tex
variable u and one supplementary generator x(1) *@dots{}* x(n) -u (instead of the
generator t * x(1) *@dots{}* x(n) -1 in
the algorithm of Pottier). The algorithm uses a quite unusual technique to
get rid of the variable u again.

There is another algorithm of the authors which tries to parallelize
the computations (but which is not implemented in this library).

@node Buchberger algorithm, , Algorithms, Toric ideals

@subsection The Buchberger algorithm for toric ideals
@cindex Buchberger algorithm for toric ideals

Toric ideals have a very special structure that allows us to improve
the Buchberger algorithm in many respects: They are prime ideals and
generated by binomials. Pottier used this fact to describe all
operations of the Buchberger algorithm on the ideal generators in terms
of vector additions and subtractions. Some other strategies like
multiple reduction (@pxref{[CoTr91]}) or the use of bit
vectors to represent the support of a monomial (@pxref{[Big97]}) may be
applied to more general ideals, but show to
be especially useful in the toric case.

@node Integer programming, Relevant References, Toric ideals, Toric ideals and integer programming

@subsection Integer programming
@cindex integer programming

@tex
Let $A$ be an $m\times n$ matrix with integral coefficients, $b\in
Z\!\!\! Z^m$ and $c\in Z\!\!\! Z^n$. The problem
$$ \min\{c^T x | x\in Z\!\!\! Z^n, Ax=b, x\geq 0\hbox{
component-wise}\} $$
is called an instance of the \bf integer programming problem \rm or
\bf IP problem. \rm

The IP problem is very hard; namely, it is NP-complete.

For the following discussion let $c\geq 0$ (component-wise). We
consider $c$ as a weight vector; because of its non-negativity, $c$ can
be refined into a monomial ordering $>_c$. It turns out that we can
solve such an IP instance with the help of toric ideals:

First we assume that an initial solution $v$ (i.e., $v\in Z\!\!\!
Z^n, v\geq 0, Av=b$) is already known. We obtain the optimal solution
$v_0$ (i.e., with $c^T v_0$ minimal) by the following procedure:
@end tex
@c \begin{itemize}
@c \item (1) Compute the toric ideal $I_A$ using one of the algorithms in the
@c       previous section.
@c \item (2) Compute the reduced Groebner basis $G_c$ of $I_A$ w.r.t.
@c       $>_c$.
@c \item (3) Reduce $x^v$ modulo $G_c$ using the Hironaka division algorithm.
@c       If the result of this reduction is $x^{v_0}$, then $v_0$ is an
@c       optimal solution of the given instance.
@c \end{itemize}

Let A be an mxn matrix with integral coefficients, b in Z^m and c in
Z^n. The problem @*
@display
min @{ c*x | x in Z^n, A*x=b, x>=0 component-wise @}
@end display
is called an instance of the @strong{integer programming problem} or
@strong{IP problem}.

The IP problem is very hard; namely, it is NP-complete.

For the following discussion let c>=0 (component-wise). We
consider c as a weight vector; because of its non-negativity, c can
be refined into a monomial ordering >_c. It turns out that we can
solve such an IP instance with the help of toric ideals:

First we assume that an initial solution v (i.e., v in Z^n, v>=0,
A*v=b) is already known. We obtain the optimal solution v(opt) (i.e.,
with c*v(opt) minimal) by the following procedure:

@itemize @bullet
@item (1) Compute the toric ideal I(A) using one of the algorithms in the previous section.
@item (2) Compute the reduced Groebner basis G(c) of I(A) w.r.t.@: 
@math{>_c}
@tex
$>_c$
@end tex
.
@item (3) Reduce 
@math{x^v}
@tex
$x^v$
@end tex
 modulo G(c) using the Hironaka division algorithm.
If the result of this reduction is 
@math{x^(v_0)}
@tex
$x^(v_0)$
@end tex
, then 
@math{v_0}
@tex
$v_0$
@end tex
 is an optimal
solution of the given instance.
@end itemize

If no initial solution is known, we are nevertheless able to solve the
problem with similar techniques. For this purpose we replace our
instance by an extended instance with the matrix used
in the Conti-Traverso algorithm. Indeed, the Conti-Traverso
algorithm offers the possibility to verify solvability of a given
instance and to find an initial solution in the case of existence (but
none of the other algorithms does!). Details can be found in [CoTr91]
and [The99].

An implementation of the above algorithm and some examples can be found in @ref{intprog_lib}.

Classical methods for solving IP instances like Branch-and-Bound
methods seem to be faster in general than the methods using toric
ideals. But the latter have one great advantage: If one wants to solve
various instances that differ only by the vector 
@math{b}
@tex
$b$
@end tex
, one has to
perform steps (1) and (2) above only once. As the running time of step (3)
is very short, solving all the instances is not much harder than
solving one single instance.

For a detailed discussion see [The99].

@node Relevant References, , Integer programming, Toric ideals and integer programming
@subsection Relevant References

@itemize @bullet
@item [Big97]  Bigatti, A.M.: @anchor{[Big97]}
   Computation of Hilbert-Poincare series.
   Journal of Pure and Applied Algebra (1997) 199, 237-253

@item [BLR98]  Bigatti, A.M.; La Scala, R.; Robbiano, L.: @anchor{[BLR98]}
   Computing toric ideals.
   Journal of Symbolic Computation (to appear)

@item [Coh93]  Cohen, H.: @anchor{[Coh93]}
   A Course in Computational Algebraic Number Theory.
   Springer (1997)

@item [CoTr91]  Conti, P.; Traverso, C.: @anchor{[CoTr91]}
   Buchberger algorithm and integer programming.
   Proceedings AAECC-9 (new Orleans), Springer LNCS (1991) 539,
   130-139

@item [DBUr95]  Di Biase, F.; Urbanke, R.: @anchor{[DBUr95]}
   An algorithm to calculate the kernel of certain polynomial ring
   homomorphisms.
   Experimental Mathematics (1995) 4, 227-234

@item [HoSh98]  Hosten, S.; Shapiro, J.: @anchor{[HoSh98]}
   Primary decomposition of lattice basis ideals.
   (to appear)

@item [HoSt95]  Hosten, S.; Sturmfels, B.: @anchor{[HoSt95]}
   GRIN: An implementation of Groebner bases for integer programming.
   in Balas, E.; Clausen, J. (editors): Integer Programming and
   Combinatorial Optimization.
   Springer LNCS (1995) 920, 267-276

@item [Pot94]  Pottier, L.: @anchor{[Pot94]}
   Groebner bases of toric ideals.
   Rapport de recherche 2224 (1997), INRIA Sophia Antipolis

@item [Stu96]  Sturmfels, B.: @anchor{[Stu96]}
   Groebner Bases and Convex Polytopes.
   University Lecture Series, Volume 8 (1996), American Mathematical
   Society

@item [The99]  Theis, C.: @anchor{[The99]}
   Der Buchberger-Algorithmus fuer torische Ideale und seine Anwendung
   in der ganzzahligen Optimierung.
   Diplomarbeit, Universitaet des Saarlandes (1999), Saarbruecken
   (Germany)

@end itemize

@c ---------------------------------------------------------------------------
@node References, , Toric ideals and integer programming, Mathematical background
@section References
@cindex References

The Centre for Computer Algebra Kaiserslautern publishes a series of preprints
which are electronically available at
@code{http://www.mathematik.uni-kl.de/~zca/Reports_on_ca}.
Other sources to check are @code{http://symbolicnet.mcs.kent.edu/},
@code{http://www.can.nl/},... and the following list of books:

@subheading Text books on computational algebraic geometry
@itemize @bullet

@item
Adams, W.; Loustaunau, P.: An Introduction to Gr@"obner Bases. Providence, RI,
AMS, 1996

@item
Becker, T.; Weisspfenning, V.:
Gr@"obner Bases - A Computational Approach to Commutative Algebra. Springer, 1993

@item
Cohen, H.:
A Course in Computational Algebraic Number Theory,
Springer, 1995

@item
Cox, D.; Little, J.; O'Shea, D.:
Ideals, Varieties and Algorithms. Springer, 1996

@item
Eisenbud, D.: Commutative Algebra with a View Toward Algebraic Geometry.
Springer, 1995

@item
Greuel, G.-M.; Pfister, G.: A SINGULAR Introduction to Commuative Algebra, Springer, 2002

@item
Mishra, B.: Algorithmic Algebra, Texts and Monographs in Computer Science.
Springer, 1993
@item
Sturmfels, B.: Algorithms in Invariant Theory. Springer 1993

@item
Vasconcelos, W.: Computational Methods in Commutative Algebra and Algebraic
Geometry. Springer, 1998
@end itemize

@subheading Descriptions of algorithms
@itemize @bullet
@item
Bareiss, E.:
Sylvester's identity and multistep integer-preserving Gaussian elimination.
Math. Comp. 22 (1968), 565-578

@item
Campillo, A.: Algebroid curves in positive characteristic. SLN 813, 1980

@item
Chou, S.:
Mechanical Geometry Theorem Proving.
D.Reidel Publishing Company, 1988

@item
Decker, W.; Greuel, G.-M.; Pfister, G.:
Primary decomposition: algorithms and
comparisons.  Preprint, Univ. Kaiserslautern, 1998.
To appear in: Greuel, G.-M.; Matzat, B. H.; Hiss, G. (Eds.),
Algorithmic Algebra and Number Theory. Springer Verlag, Heidelberg, 1998

@item
Decker, W.; Greuel, G.-M.; de Jong, T.; Pfister, G.:
The normalization: a new algorithm,
implementation and comparisons. Preprint, Univ. Kaiserslautern, 1998

@item
Decker, W.; Heydtmann, A.; Schreyer, F. O.: Generating a Noetherian Normalization of
the Invariant Ring of a Finite Group, 1997, to appear in Journal of
Symbolic Computation

@item
@tex
Faug\`ere,
@end tex
Faugere,
J. C.; Gianni, P.; Lazard, D.; Mora, T.: Efficient computation
of zero-dimensional
Gr@"obner bases by change of ordering. Journal of Symbolic Computation, 1989

@item
Gr@"abe, H.-G.: On factorized Gr@"obner bases, Univ. Leipzig, Inst. f@"ur
Informatik, 1994

@item
Grassmann, H.; Greuel, G.-M.; Martin, B.; Neumann,
W.; Pfister, G.; Pohl, W.; Sch@"onemann, H.; Siebert, T.:  On an
implementation of standard bases and syzygies in  @sc{Singular}.
Proceedings of the Workshop  Computational Methods in Lie theory in AAECC (1995)

@item
Greuel, G.-M.; Pfister, G.:
Advances and improvements in the theory of standard bases and
syzygies. Arch. d. Math. 63(1995)

@item
Kemper; Generating Invariant Rings of Finite Groups over Arbitrary
Fields. 1996, to appear in Journal of Symbolic Computation

@item
Kemper and Steel: Some Algorithms in Invariant Theory of Finite Groups. 1997

@item
Lee, H.R.; Saunders, B.D.: Fraction Free Gaussian Elimination for
Sparse Matrices. Journal of Symbolic Computation (1995) 19, 393-402

@item
Sch@"onemann, H.:
Algorithms in @sc{Singular},
Reports on Computer Algebra 2(1996), Kaiserslautern

@item
Siebert, T.:
On strategies and implementations for computations of free resolutions.
Reports on Computer Algebra 8(1996), Kaiserslautern

@item
Wang, D.:
Characteristic Sets and Zero Structure of Polynomial Sets.
Lecture Notes, RISC Linz, 1989
@end itemize

@c ----------------------------------------------------------------------------
@node SINGULAR libraries, Release Notes, Mathematical background, Top
@appendix SINGULAR libraries
@cindex SINGULAR libraries
@cindex LIBs

@sc{Singular} comes with a set of standard libraries. Their content is
described in the following subsections.

Use the @ref{LIB} command for loading of single libraries, and the
command @code{LIB "all.lib";} for loading all libraries.

@menu
* standard_lib:: extensions of Singular kernel
* General purpose::
* Linear algebra::
* Commutative algebra::
* Singularities::
* Invariant theory::
* Symbolic-numerical solving::
* Visualization::
* Coding theory::
@end menu
@c ----------------------------------------------------------
@node standard_lib, General purpose, SINGULAR libraries, SINGULAR libraries
@section standard_lib

The library @code{standard.lib} provides extensions to the
set of built-in commands and is automatically loaded
during the start of @sc{Singular}, unless @sc{Singular} is started up
with the @code{--no-stdlib} command line option (see
@ref{Command line options}).

@c start include of docu for standard.lib:LibInfo
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/standard_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/standard_lib.doc INSTEAD
@c library version: (1.58.2.9,2003/06/16)
@c library file: ../Singular/LIB/standard.lib
@cindex standard.lib
@cindex standard_lib
@table @asis
@item @strong{Library:}
standard.lib
@item @strong{Purpose:}
   Procedures which are always loaded at Start-up

@end table

@strong{Procedures:}
@menu
* stdfglm:: standard basis of ideal via fglm [and ordering ord]
* stdhilb:: standard basis of ideal using the Hilbert function
* groebner:: standard basis using a heuristically chosen method
* quot:: quotient using heuristically chosen method
* res:: free resolution of ideal or module
* sprintf:: returns formatted string
* fprintf:: writes formatted string to link
* printf:: displays formatted string
@end menu
@c ---end content LibInfo---
@c generated lib proc docu for standard.lib:LibInfo singular.doc:200 
@c end include of docu for standard.lib:LibInfo

@c ----------------------------------------------------------------------------
@node General purpose, Linear algebra, standard_lib, SINGULAR libraries
@section General purpose
@cindex General purpose

@menu
* all_lib:: load all other libraries
* general_lib:: procedures of general type
* inout_lib:: procedures for manipulating in- and output
* poly_lib:: procedures for manipulating polynomials and ideals
* random_lib:: procedures of random/sparse  matrix and poly operations
* ring_lib:: procedures for manipulating rings and maps
@end menu

@c ----------------------------------------------------------
@node all_lib, general_lib, General purpose, General purpose
@subsection all_lib
@cindex all_lib
@cindex all.lib

The library @code{all.lib} provides a convenient way to load all
libraries of the @sc{Singular} distribution.

@strong{Example:}
@smallexample
@c reused example all_lib singular.doc:227 
option(loadLib);
LIB "all.lib";
@expansion{} // ** loaded all.lib (1.35.2.4,2003/02/25)
@expansion{} // ** loaded makedbm.lib (1.11,2000/12/22)
@expansion{} // ** loaded brnoeth.lib (1.11.2.5,2002/10/18)
@expansion{} // ** loaded paramet.lib (1.11.2.1,2002/10/21)
@expansion{} // ** loaded surf.lib (1.19.2.6,2002/07/17)
@expansion{} // ** loaded latex.lib (1.19.2.1,2002/02/20)
@expansion{} // ** loaded graphics.lib (1.10,2001/02/19)
@expansion{} // ** loaded zeroset.lib (1.7.2.2,2002/02/20)
@expansion{} // ** loaded ntsolve.lib (1.12.2.1,2002/04/12)
@expansion{} // ** loaded triang.lib (1.7,2001/02/19)
@expansion{} // ** loaded solve.lib (1.21.2.13,2002/10/21)
@expansion{} // ** loaded presolve.lib (1.17.2.6,2003/03/26)
@expansion{} // ** loaded stratify.lib (1.7.2.4,2002/04/11)
@expansion{} // ** loaded rinvar.lib (1.7.2.3,2002/02/20)
@expansion{} // ** loaded finvar.lib (1.32.2.2,2002/08/13)
@expansion{} // ** loaded ainvar.lib (1.6.2.2,2002/04/12)
@expansion{} // ** loaded spectrum.lib (1.12.2.3,2002/03/06)
@expansion{} // ** loaded spcurve.lib (1.15.2.1,2002/02/20)
@expansion{} // ** loaded sing.lib (1.24.2.5,2003/04/15)
@expansion{} // ** loaded qhmoduli.lib (1.0,2000/12/12)
@expansion{} // ** loaded mondromy.lib (1.22.2.2,2002/02/20)
@expansion{} // ** loaded hnoether.lib (1.29.2.14,2002/10/21)
@expansion{} // ** loaded gaussman.lib (1.33.2.26,2003/02/10)
@expansion{} // ** loaded equising.lib (1.7.2.5,2003/02/25)
@expansion{} // ** loaded deform.lib (1.25.2.2,2003/02/24)
@expansion{} // ** loaded classify.lib (1.48.2.4,2002/04/11)
@expansion{} // ** loaded toric.lib (1.11,2001/02/06)
@expansion{} // ** loaded intprog.lib (1.5,2001/02/06)
@expansion{} // ** loaded reesclos.lib (1.50,2001/08/06)
@expansion{} // ** loaded primitiv.lib (1.15,2001/02/05)
@expansion{} // ** loaded primdec.lib (1.98.2.14,2003/04/07)
@expansion{} // ** loaded normal.lib (1.34.2.17,2002/10/21)
@expansion{} // ** loaded mregular.lib (1.6.2.1,2002/02/20)
@expansion{} // ** loaded mprimdec.lib (1.1.2.3,2002/03/19)
@expansion{} // ** loaded homolog.lib (1.15.2.2,2002/10/07)
@expansion{} // ** loaded elim.lib (1.14.2.4,2003/04/16)
@expansion{} // ** loaded algebra.lib (1.9.2.3,2002/04/11)
@expansion{} // ** loaded linalg.lib (1.10.2.15,2003/04/04)
@expansion{} // ** loaded matrix.lib (1.26.2.2,2002/10/07)
@expansion{} // ** loaded ring.lib (1.17.2.1,2002/02/20)
@expansion{} // ** loaded random.lib (1.16.2.1,2002/02/20)
@expansion{} // ** loaded poly.lib (1.33.2.6,2003/02/10)
@expansion{} // ** loaded inout.lib (1.21.2.5,2002/06/12)
@expansion{} // ** loaded general.lib (1.38.2.9,2003/04/04)
@c end example all_lib singular.doc:227
@end smallexample
@c ----------------------------------------------------------
@node general_lib, inout_lib, all_lib, General purpose
@subsection general_lib
@c include of docu for general.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/general_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/general_lib.doc INSTEAD
@c library version: (1.38.2.9,2003/04/04)
@c library file: ../Singular/LIB/general.lib
@cindex general.lib
@cindex general_lib
@table @asis
@item @strong{Library:}
general.lib
@item @strong{Purpose:}
   Elementary Computations of General Type

@end table

@strong{Procedures:}
@menu
* A_Z:: string a,b,... of n comma separated letters
* ASCII:: string of printable ASCII characters (number n to m)
* absValue:: absolute value of c
* binomial:: n choose m (type int), [type string/type number]
* deleteSublist:: delete entries given by iv from list l
* factorial:: n factorial (=n!) (type int), [type string/number]
* fibonacci:: nth Fibonacci number [char p]
* kmemory:: active [allocated] memory in kilobyte
* killall:: kill all user-defined variables
* number_e:: compute exp(1) up to n decimal digits
* number_pi:: compute pi (area of unit circle) up to n digits
* primes:: intvec of primes p, n<=p<=m
* product:: multiply components of vector/ideal/...[indices v]
* sort:: sort generators according to monomial ordering
* sum:: add components of vector/ideal/...[with indices v]
* watchdog:: only wait for result of command cmd for i seconds
* which:: search for command and return absolute path, if found
* primecoeffs:: primefactors <= min(p,32003) of coeffs of J
* primefactors:: primefactors <= min(p,32003) of n
* timeStd:: std(i) if computation finished after d seconds else i
* timeFactorize:: works as timeStd with factorization
* factorH:: factorizes with good choice of principal variable
@end menu
@c ---end content LibInfo---

@c ------------------- A_Z -------------
@node A_Z, ASCII,, general_lib
@subsubsection A_Z
@cindex A_Z
@c ---content A_Z---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
A_Z("a",n); a any letter, n integer (-26<= n <=26, !=0)

@item @strong{Return:}
string of n small (if a is small) or capital (if a is capital)
letters, comma separated, beginning with a, in alphabetical
order (or revers alphabetical order if n<0)

@end table
@strong{Example:}
@smallexample
@c computed example A_Z d2t_singular/general_lib.doc:60 
LIB "general.lib";
A_Z("c",5);
@expansion{} c,d,e,f,g
A_Z("Z",-5);
@expansion{} Z,Y,X,W,V
string sR = "ring R = (0,"+A_Z("A",6)+"),("+A_Z("a",10)+"),dp;";
sR;
@expansion{} ring R = (0,A,B,C,D,E,F),(a,b,c,d,e,f,g,h,i,j),dp;
execute(sR);
R;
@expansion{} //   characteristic : 0
@expansion{} //   6 parameter    : A B C D E F 
@expansion{} //   minpoly        : 0
@expansion{} //   number of vars : 10
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    a b c d e f g h i j 
@expansion{} //        block   2 : ordering C
@c end example A_Z d2t_singular/general_lib.doc:60
@end smallexample
@c ---end content A_Z---

@c ------------------- ASCII -------------
@node ASCII, absValue, A_Z, general_lib
@subsubsection ASCII
@cindex ASCII
@c ---content ASCII---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
ASCII([n,m]); n,m= integers (32 <= n <= m <= 126)

@item @strong{Return:}
string of printable ASCII characters (no native language support)
ASCII(): string of all ASCII characters with its numbers,
ASCII(n): n-th ASCII character
@*ASCII(n,m): n-th up to m-th ASCII character (inclusive)

@end table
@strong{Example:}
@smallexample
@c computed example ASCII d2t_singular/general_lib.doc:92 
LIB "general.lib";
ASCII();"";
@expansion{}      !    "    #    $    %    &    '    (    )    *    +    ,    -    .
@expansion{} 32   33   34   35   36   37   38   39   40   41   42   43   44   45   46
@expansion{} /    0    1    2    3    4    5    6    7    8    9    :    ;    <    =
@expansion{} 47   48   49   50   51   52   53   54   55   56   57   58   59   60   61
@expansion{} >    ?    @@    A    B    C    D    E    F    G    H    I    J    K    L
@expansion{} 62   63   64   65   66   67   68   69   70   71   72   73   74   75   76
@expansion{} M    N    O    P    Q    R    S    T    U    V    W    X    Y    Z    [
@expansion{} 77   78   79   80   81   82   83   84   85   86   87   88   89   90   91
@expansion{} \    ]    ^    _    `    a    b    c    d    e    f    g    h    i    j
@expansion{} 92   93   94   95   96   97   98   99  100  101  102  103  104  105  10
@expansion{} k    l    m    n    o    p    q    r    s    t    u    v    w    x    y
@expansion{} 107  108  109  110  111  112  113  114  115  116  117  118  119  120  121
@expansion{} z    @{    |    @}    ~
@expansion{} 122  123  124  125  126 
@expansion{} 
ASCII(42);
@expansion{} *
ASCII(32,126);
@expansion{}  !"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefgh\
   ijklmnopqrstuvwxyz@{|@}~
@c end example ASCII d2t_singular/general_lib.doc:92
@end smallexample
@c ---end content ASCII---

@c ------------------- absValue -------------
@node absValue, binomial, ASCII, general_lib
@subsubsection absValue
@cindex absValue
@c ---content absValue---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
absValue(c); c int, number or poly

@item @strong{Return:}
absValue(c); the absolute value of c

@item @strong{Note:}
absValue(c)=c if c>=0; absValue=-c if c<=0.
@* So the function can be applied to any type, for which comparison
@* operators are defined.

@end table
@strong{Example:}
@smallexample
@c computed example absValue d2t_singular/general_lib.doc:123 
LIB "general.lib";
ring r1 = 0,x,dp;
absValue(-2002);
@expansion{} 2002
poly f=-4;
absValue(f);
@expansion{} 4
@c end example absValue d2t_singular/general_lib.doc:123
@end smallexample
@c inserted refs from d2t_singular/general_lib.doc:131
@menu
See also:
* boolean expressions::
@end menu
@c end inserted refs from d2t_singular/general_lib.doc:131

@c ---end content absValue---

@c ------------------- binomial -------------
@node binomial, deleteSublist, absValue, general_lib
@subsubsection binomial
@cindex binomial
@c ---content binomial---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
binomial(n,k[,p]); n,k,p integers

@item @strong{Return:}
binomial(n,k); binomial coefficient n choose k
@* - of type string (computed in characteristic 0)
@* binomial(n,k,p); n choose k, computed in characteristic 0 or prime(p)
@* - of type number if a basering, say R, is present and p=0=char(R)
or if prime(p)=char(R)
@* - of type string else

@item @strong{Note:}
In any characteristic, binomial(n,k) = coefficient of x^k in (1+x)^n

@end table
@strong{Example:}
@smallexample
@c computed example binomial d2t_singular/general_lib.doc:162 
LIB "general.lib";
binomial(200,100);"";                   //type string, computed in char 0
@expansion{} 90548514656103281165404177077484163874504589675413336841320
@expansion{} 
binomial(200,100,3);"";                 //type string, computed in char 3
@expansion{} 0
@expansion{} 
int n,k = 200,100;
ring r = 0,x,dp;
number b1 = binomial(n,k,0);            //type number, computed in ring r
poly b2 = coeffs((x+1)^n,x)[k+1,1];     //coefficient of x^k in (x+1)^n
b1-b2;                                  //b1 and b2 should coincide
@expansion{} 0
@c end example binomial d2t_singular/general_lib.doc:162
@end smallexample
@c inserted refs from d2t_singular/general_lib.doc:173
@menu
See also:
* prime::
@end menu
@c end inserted refs from d2t_singular/general_lib.doc:173

@c ---end content binomial---

@c ------------------- deleteSublist -------------
@node deleteSublist, factorial, binomial, general_lib
@subsubsection deleteSublist
@cindex deleteSublist
@c ---content deleteSublist---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
deleteSublist(v,l); intvec v; list l
@*where the entries of the integer vector v correspond to the
positions of the elements to be deleted

@item @strong{Return:}
list without the deleted elements

@end table
@strong{Example:}
@smallexample
@c computed example deleteSublist d2t_singular/general_lib.doc:198 
LIB "general.lib";
list l=1,2,3,4,5;
intvec v=1,3,4;
l=deleteSublist(v,l);
l;
@expansion{} [1]:
@expansion{}    2
@expansion{} [2]:
@expansion{}    5
@c end example deleteSublist d2t_singular/general_lib.doc:198
@end smallexample
@c ---end content deleteSublist---

@c ------------------- factorial -------------
@node factorial, fibonacci, deleteSublist, general_lib
@subsubsection factorial
@cindex factorial
@c ---content factorial---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
factorial(n[,p]); n,p integers

@item @strong{Return:}
factorial(n): n! (computed in characteristic 0), of type string.
@* factorial(n,p): n! computed in characteristic 0 or prime(p)
@* - of type number if a basering is present and 0=p=char(basering)
or if prime(p)=char(basering)
@* - of type string else

@end table
@strong{Example:}
@smallexample
@c computed example factorial d2t_singular/general_lib.doc:229 
LIB "general.lib";
factorial(37);"";                 //37! of type string (as long integer)
@expansion{} 13763753091226345046315979581580902400000000
@expansion{} 
ring r1 = 0,x,dp;
number p = factorial(37,0);       //37! of type number, computed in r
p;
@expansion{} 13763753091226345046315979581580902400000000
@c end example factorial d2t_singular/general_lib.doc:229
@end smallexample
@c inserted refs from d2t_singular/general_lib.doc:237
@menu
See also:
* prime::
@end menu
@c end inserted refs from d2t_singular/general_lib.doc:237

@c ---end content factorial---

@c ------------------- fibonacci -------------
@node fibonacci, kmemory, factorial, general_lib
@subsubsection fibonacci
@cindex fibonacci
@c ---content fibonacci---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
fibonacci(n); n,p integers

@item @strong{Return:}
fibonacci(n): nth Fibonacci number, f(0)=f(1)=1, f(i+1)=f(i-1)+f(i)
@* - computed in characteristic 0, of type string
@* fibonacci(n,p): f(n) computed in characteristic 0 or prime(p)
@* - of type number if a basering is present and p=0=char(basering)
or if prime(p)=char(basering)
@* - of type string else

@end table
@strong{Example:}
@smallexample
@c computed example fibonacci d2t_singular/general_lib.doc:265 
LIB "general.lib";
fibonacci(42); "";             //f(42) of type string (as long integer)
@expansion{} 267914296
@expansion{} 
ring r = 2,x,dp;
number b = fibonacci(42,2);    //f(42) of type number, computed in r
b;
@expansion{} 0
@c end example fibonacci d2t_singular/general_lib.doc:265
@end smallexample
@c inserted refs from d2t_singular/general_lib.doc:273
@menu
See also:
* prime::
@end menu
@c end inserted refs from d2t_singular/general_lib.doc:273

@c ---end content fibonacci---

@c ------------------- kmemory -------------
@node kmemory, killall, fibonacci, general_lib
@subsubsection kmemory
@cindex kmemory
@c ---content kmemory---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
kmemory([n,[v]]); n,v integers

@item @strong{Return:}
memory in kilobyte of type int
@* n=0: memory used by active variables (same as no parameters)
@* n=1: total memory allocated by Singular
@* n=2: difference between top and init memory address (sbrk memory)
@* n!=0,1,2: 0

@item @strong{Display:}
detailed information about allocated and used memory if v!=0

@item @strong{Note:}
kmemory uses internal function 'memory' to compute kilobyte, and
is the same as 'memory' for n!=0,1,2

@end table
@strong{Example:}
@smallexample
@c computed example kmemory d2t_singular/general_lib.doc:307 
LIB "general.lib";
kmemory();
@expansion{} 152
kmemory(1,1);
@expansion{} // total memory allocated, at the moment, by SINGULAR (kilobyte):
@expansion{} 650
@c end example kmemory d2t_singular/general_lib.doc:307
@end smallexample
@c ---end content kmemory---

@c ------------------- killall -------------
@node killall, number_e, kmemory, general_lib
@subsubsection killall
@cindex killall
@c ---content killall---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
killall(); (no parameter)
@*killall("type_name");
@*killall("not", "type_name");

@item @strong{Return:}
killall(); kills all user-defined variables except loaded procedures,
no return value.
@* - killall("type_name"); kills all user-defined variables,
of type "type_name"
@* - killall("not", "type_name"); kills all user-defined variables,
except those of type "type_name" and except loaded procedures
@* - killall("not", "name_1", "name_2", ...);
kills all user-defined variables, except those of name "name_i"
and except loaded procedures

@item @strong{Note:}
killall should never be used inside a procedure

@end table
@strong{Example:}
@smallexample
@c computed example killall d2t_singular/general_lib.doc:345 
LIB "general.lib";
ring rtest; ideal i=x,y,z; string str="hi"; int j = 3;
export rtest,i,str,j;       //this makes the local variables global
@expansion{} // ** `rtest` is already global
@expansion{} // ** `i` is already global
@expansion{} // ** `str` is already global
@expansion{} // ** `j` is already global
listvar();
@expansion{} // j                    [0]  int 3
@expansion{} // str                  [0]  string hi
@expansion{} // rtest                [0]  *ring
@expansion{} //      i                    [0]  ideal, 3 generator(s)
@expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
killall("ring");            // kills all rings
@expansion{} // ** killing the basering for level 0
listvar();
@expansion{} // j                    [0]  int 3
@expansion{} // str                  [0]  string hi
@expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
killall("not", "int");      // kills all variables except int's (and procs)
listvar();
@expansion{} // j                    [0]  int 3
@expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
killall();                  // kills all vars except loaded procs
listvar();
@expansion{} // j                    [0]  int 3
@expansion{} // LIB                  [0]  string standard.lib,general..., 74 char(s)
@c end example killall d2t_singular/general_lib.doc:345
@end smallexample
@c ---end content killall---

@c ------------------- number_e -------------
@node number_e, number_pi, killall, general_lib
@subsubsection number_e
@cindex number_e
@c ---content number_e---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
number_e(n); n integer

@item @strong{Return:}
Euler number e=exp(1) up to n decimal digits (no rounding)
@* - of type string if no basering of char 0 is defined
@* - of type number if a basering of char 0 is defined

@item @strong{Display:}
decimal format of e if printlevel > 0 (default:printlevel=0 )

@item @strong{Note:}
procedure uses algorithm of A.H.J. Sale

@end table
@strong{Example:}
@smallexample
@c computed example number_e d2t_singular/general_lib.doc:385 
LIB "general.lib";
number_e(30);"";
@expansion{} 2.71828182845904523536028747135
@expansion{} 
ring R = 0,t,lp;
number e = number_e(30);
e;
@expansion{} 13591409142295226176801437356763/5000000000000000000000000000000
@c end example number_e d2t_singular/general_lib.doc:385
@end smallexample
@c ---end content number_e---

@c ------------------- number_pi -------------
@node number_pi, primes, number_e, general_lib
@subsubsection number_pi
@cindex number_pi
@c ---content number_pi---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
number_pi(n); n positive integer

@item @strong{Return:}
pi (area of unit circle) up to n decimal digits (no rounding)
@* - of type string if no basering of char 0 is defined,
@* - of type number, if a basering of char 0 is defined

@item @strong{Display:}
decimal format of pi if printlevel > 0 (default:printlevel=0 )

@item @strong{Note:}
procedure uses algorithm of S. Rabinowitz

@end table
@strong{Example:}
@smallexample
@c computed example number_pi d2t_singular/general_lib.doc:420 
LIB "general.lib";
number_pi(11);"";
@expansion{} 3.1415926535
@expansion{} 
ring r = (real,10),t,dp;
number pi = number_pi(11); pi;
@expansion{} 3.1415926536
@c end example number_pi d2t_singular/general_lib.doc:420
@end smallexample
@c ---end content number_pi---

@c ------------------- primes -------------
@node primes, product, number_pi, general_lib
@subsubsection primes
@cindex primes
@c ---content primes---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
primes(n,m); n,m integers

@item @strong{Return:}
intvec, consisting of all primes p, prime(n)<=p<=m, in increasing
order if n<=m, resp. prime(m)<=p<=n, in decreasing order if m<n.

@item @strong{Note:}
prime(n); returns the biggest prime number <= min(n,32003)
if n>=2, else 2

@end table
@strong{Example:}
@smallexample
@c computed example primes d2t_singular/general_lib.doc:451 
LIB "general.lib";
primes(50,100);"";
@expansion{} 47,53,59,61,67,71,73,79,83,89,97
@expansion{} 
intvec v = primes(37,1); v;
@expansion{} 37,31,29,23,19,17,13,11,7,5,3,2
@c end example primes d2t_singular/general_lib.doc:451
@end smallexample
@c ---end content primes---

@c ------------------- product -------------
@node product, sort, primes, general_lib
@subsubsection product
@cindex product
@c ---content product---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
product(id[,v]); id ideal/vector/module/matrix/intvec/intmat/list,
v intvec (default: v=1..number of entries of id)

@item @strong{Assume:}
list members can be multiplied.

@item @strong{Return:}
The product of all entries of id [with index given by v] of type
depending on the entries of id.

@item @strong{Note:}
If id is not a list, id is treated as a list of polys resp. integers.
A module m is identified with the corresponding matrix M (columns
of M generate m).
@* If v is outside the range of id, we have the empty product and the
result will be 1 (of type int).

@end table
@strong{Example:}
@smallexample
@c computed example product d2t_singular/general_lib.doc:488 
LIB "general.lib";
ring r= 0,(x,y,z),dp;
ideal m = maxideal(1);
product(m);
@expansion{} xyz
product(m[2..3]);
@expansion{} yz
matrix M[2][3] = 1,x,2,y,3,z;
product(M);
@expansion{} 6xyz
intvec v=2,4,6;
product(M,v);
@expansion{} xyz
intvec iv = 1,2,3,4,5,6,7,8,9;
v=1..5,7,9;
product(iv,v);
@expansion{} 7560
intmat A[2][3] = 1,1,1,2,2,2;
product(A,3..5);
@expansion{} 4
@c end example product d2t_singular/general_lib.doc:488
@end smallexample
@c ---end content product---

@c ------------------- sort -------------
@node sort, sum, product, general_lib
@subsubsection sort
@cindex sort
@c ---content sort---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
sort(id[v,o,n]); id = ideal/module/intvec/list(of intvec's or int's)
@* sort may be called with 1, 2 or 3 arguments in the following way:
@* sort(id[v,n]); v=intvec of positive integers, n=integer,
@* sort(id[o,n]); o=string (any allowed ordstr of a ring), n=integer

@item @strong{Return:}
a list l of two elements:
@format
        l[1]: object of same type as input but sorted in the following way:
           - if id=ideal/module: generators of id are sorted w.r.t. intvec v
             (id[v[1]] becomes 1-st, id[v[2]]  2-nd element, etc.). If no v is
             present, id is sorted w.r.t. ordering o (if o is given) or w.r.t.
             actual monomial ordering (if no o is given):
             NOTE: generators with SMALLER(!) leading term come FIRST
             (e.g. sort(id); sorts backwards to actual monomial ordering)
           - if id=list of intvec's or int's: consider a list element, say
             id[1]=3,2,5, as exponent vector of the monomial x^3*y^2*z^5;
             the corresponding monomials are ordered w.r.t. intvec v (s.a.).
             If no v is present, the monomials are sorted w.r.t. ordering o
             (if o is given) or w.r.t. lexicographical ordering (if no o is
             given). The corresponding ordered list of exponent vectors is
             returned.
             (e.g. sort(id); sorts lexicographically, smaller int's come first)
             WARNING: Since negative exponents create the 0 polynomial in
             Singular, id should not contain negative integers: the result
             might not be as expected
           - if id=intvec: id is treated as list of integers
           - if n!=0 the ordering is inverse, i.e. w.r.t. v(size(v)..1)
             default: n=0
         l[2]: intvec, describing the permutation of the input (hence l[2]=v
             if v is given (with positive integers))
@end format

@item @strong{Note:}
If v is given id may be any simply indexed object (e.g. any list or
string); if v[i]<0 and i<=size(id) v[i] is set internally to i;
entries of v must be pairwise distinct to get a permutation if id.
Zero generators of ideal/module are deleted

@end table
@strong{Example:}
@smallexample
@c computed example sort d2t_singular/general_lib.doc:558 
LIB "general.lib";
ring r0 = 0,(x,y,z,t),lp;
ideal i = x3,z3,xyz;
sort(i);            //sorts using lex ordering, smaller polys come first
@expansion{} [1]:
@expansion{}    _[1]=z3
@expansion{}    _[2]=xyz
@expansion{}    _[3]=x3
@expansion{} [2]:
@expansion{}    2,3,1
sort(i,3..1);
@expansion{} [1]:
@expansion{}    _[1]=xyz
@expansion{}    _[2]=z3
@expansion{}    _[3]=x3
@expansion{} [2]:
@expansion{}    3,2,1
sort(i,"ls")[1];     //sort w.r.t. negative lex ordering
@expansion{} _[1]=x3
@expansion{} _[2]=xyz
@expansion{} _[3]=z3
intvec v =1,10..5,2..4;v;
@expansion{} 1,10,9,8,7,6,5,2,3,4
sort(v)[1];          // sort v lexicographically
@expansion{} 1,2,3,4,5,6,7,8,9,10
sort(v,"Dp",1)[1];   // sort v w.r.t (total sum, reverse lex)
@expansion{} 10,9,8,7,6,5,4,3,2,1
@c end example sort d2t_singular/general_lib.doc:558
@end smallexample
@c ---end content sort---

@c ------------------- sum -------------
@node sum, watchdog, sort, general_lib
@subsubsection sum
@cindex sum
@c ---content sum---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
sum(id[,v]); id ideal/vector/module/matrix/intvec/intmat/list,
v intvec (default: v=1..number of entries of id)

@item @strong{Assume:}
list members can be added.

@item @strong{Return:}
The sum of all entries of id [with index given by v] of type
depending on the entries of id.

@item @strong{Note:}
If id is not a list, id is treated as a list of polys resp. integers.
A module m is identified with the corresponding matrix M (columns
of M generate m).
@* If v is outside the range of id, we have the empty sum and the
result will be 0 (of type int).

@end table
@strong{Example:}
@smallexample
@c computed example sum d2t_singular/general_lib.doc:601 
LIB "general.lib";
ring r= 0,(x,y,z),dp;
vector pv = [xy,xz,yz,x2,y2,z2];
sum(pv);
@expansion{} x2+xy+y2+xz+yz+z2
sum(pv,2..5);
@expansion{} x2+y2+xz+yz
matrix M[2][3] = 1,x,2,y,3,z;
intvec w=2,4,6;
sum(M,w);
@expansion{} x+y+z
intvec iv = 1,2,3,4,5,6,7,8,9;
sum(iv,2..4);
@expansion{} 9
@c end example sum d2t_singular/general_lib.doc:601
@end smallexample
@c ---end content sum---

@c ------------------- watchdog -------------
@node watchdog, which, sum, general_lib
@subsubsection watchdog
@cindex watchdog
@c ---content watchdog---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Return:}
Result of cmd, if the result can be computed in i seconds.
Otherwise the computation is interrupted after i seconds,
the string "Killed" is returned and the global variable
'watchdog_interrupt' is defined.

@item @strong{Note:}
* the MP package must be enabled
@** the current basering should not be watchdog_rneu, since
watchdog_rneu will be killed
@** if there are variable names of the structure x(i) all
polynomials have to be put into eval(...) in order to be
interpreted correctly
@** a second Singular process is started by this procedure

@end table
@strong{Example:}
@smallexample
@c computed example watchdog d2t_singular/general_lib.doc:642 
LIB "general.lib";
ring r=0,(x,y,z),dp;
poly f=x^30+y^30;
watchdog(1,"factorize(eval("+string(f)+"))");
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x16+x14y2-x10y6-x8y8-x6y10+x2y14+y16
@expansion{}    _[3]=x8-x6y2+x4y4-x2y6+y8
@expansion{}    _[4]=x4-x2y2+y4
@expansion{}    _[5]=x2+y2
@expansion{} [2]:
@expansion{}    1,1,1,1,1
watchdog(100,"factorize(eval("+string(f)+"))");
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x16+x14y2-x10y6-x8y8-x6y10+x2y14+y16
@expansion{}    _[3]=x8-x6y2+x4y4-x2y6+y8
@expansion{}    _[4]=x4-x2y2+y4
@expansion{}    _[5]=x2+y2
@expansion{} [2]:
@expansion{}    1,1,1,1,1
@c end example watchdog d2t_singular/general_lib.doc:642
@end smallexample
@c ---end content watchdog---

@c ------------------- which -------------
@node which, primecoeffs, watchdog, general_lib
@subsubsection which
@cindex which
@c ---content which---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
which(command); command = string expression

@item @strong{Return:}
Absolute pathname of command, if found in search path.
Empty string, otherwise.

@item @strong{Note:}
Based on the Unix command 'which'.

@end table
@strong{Example:}
@smallexample
@c computed example which d2t_singular/general_lib.doc:673 
LIB "general.lib";
which("sh");
@expansion{} /bin/sh
@c end example which d2t_singular/general_lib.doc:673
@end smallexample
@c ---end content which---

@c ------------------- primecoeffs -------------
@node primecoeffs, primefactors, which, general_lib
@subsubsection primecoeffs
@cindex primecoeffs
@c ---content primecoeffs---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
primecoeffs(J[,q]); J any type which can be converted to a matrix
e.g. ideal, matrix, vector, module, int, intvec
@*q = intger

@item @strong{Compute:}
primefactors <= min(p,32003) of coeffs of J (default p = 32003)

@item @strong{Return:}
a list, say l, of two intvectors:
@*l[1] : the different primefactors of all coefficients of J
l[2] : the different remaining factors

@item @strong{Note:}
the procedure works for small integers only, just by testing all
primes (not to be considerd as serious prime factorization!)

@end table
@strong{Example:}
@smallexample
@c computed example primecoeffs d2t_singular/general_lib.doc:708 
LIB "general.lib";
primecoeffs(intvec(7*8*121,7*8));"";
@expansion{} [1]:
@expansion{}    2,7,11
@expansion{} [2]:
@expansion{}    1
@expansion{} 
ring r = 0,(b,c,t),dp;
ideal I = -13b6c3t+4b5c4t,-10b4c2t-5b4ct2;
primecoeffs(I);
@expansion{} [1]:
@expansion{}    2,5,13
@expansion{} [2]:
@expansion{}    _[1]=1
@c end example primecoeffs d2t_singular/general_lib.doc:708
@end smallexample
@c ---end content primecoeffs---

@c ------------------- primefactors -------------
@node primefactors, timeStd, primecoeffs, general_lib
@subsubsection primefactors
@cindex primefactors
@c ---content primefactors---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
primefactors(n [,p]); n = int or number, p = integer

@item @strong{Compute:}
primefactors <= min(p,32003) of n (default p = 32003)

@item @strong{Return:}
a list, say l,
@*l[1] : primefactors <= min(p,32003) of n
@*l[2] : l[2][i] = multiplicity of l[1][i]
@*l[3] : remaining factor ( n=product@{ (l[1][i]^l[2][i])*l[3]@} )
type(l[3])=typeof(n)

@item @strong{Note:}
If n is a long integer (of type number) then the procedure
finds primefactors <= min(p,32003) but n may be larger as
2147483647 (max. integer representation)

@item @strong{Warning:}
the procedure works for small integers only, just by testing all
primes (not to be considerd as serious prime factorization!)

@end table
@strong{Example:}
@smallexample
@c computed example primefactors d2t_singular/general_lib.doc:751 
LIB "general.lib";
primefactors(7*8*121);
@expansion{} [1]:
@expansion{}    2,7,11
@expansion{} [2]:
@expansion{}    3,1,2
@expansion{} [3]:
@expansion{}    1
ring r = 0,x,dp;
primefactors(123456789100);
@expansion{} [1]:
@expansion{}    2,5
@expansion{} [2]:
@expansion{}    2,2
@expansion{} [3]:
@expansion{}    1234567891
@c end example primefactors d2t_singular/general_lib.doc:751
@end smallexample
@c ---end content primefactors---

@c ------------------- timeStd -------------
@node timeStd, timeFactorize, primefactors, general_lib
@subsubsection timeStd
@cindex timeStd
@c ---content timeStd---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
timeStd(i,d), i ideal, d integer

@item @strong{Return:}
std(i) if the standard basis computation finished after
d-1 seconds and i otherwise

@end table
@strong{Example:}
@smallexample
@c computed example timeStd d2t_singular/general_lib.doc:778 
LIB "general.lib";
ring r=32003,(a,b,c,d,e),dp;
int n=6;
ideal i=
a^n-b^n,
b^n-c^n,
c^n-d^n,
d^n-e^n,
a^(n-1)*b+b^(n-1)*c+c^(n-1)*d+d^(n-1)*e+e^(n-1)*a;
ideal j=timeStd(i,2);
j;
@expansion{} j[1]=a6-b6
@expansion{} j[2]=b6-c6
@expansion{} j[3]=c6-d6
@expansion{} j[4]=d6-e6
@expansion{} j[5]=a5b+b5c+c5d+d5e+ae5
@c end example timeStd d2t_singular/general_lib.doc:778
@end smallexample
@c ---end content timeStd---

@c ------------------- timeFactorize -------------
@node timeFactorize, factorH, timeStd, general_lib
@subsubsection timeFactorize
@cindex timeFactorize
@c ---content timeFactorize---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
timeFactorize(p,d) poly p , integer d

@item @strong{Return:}
factorize(p) if the factorization finished after d-1
@*seconds otherwise f is considered to be irreducible

@end table
@strong{Example:}
@smallexample
@c computed example timeFactorize d2t_singular/general_lib.doc:812 
LIB "general.lib";
ring r=0,(x,y),dp;
poly p=((x2+y3)^2+xy6)*((x3+y2)^2+x10y);
p=p^2;
list l=timeFactorize(p,2);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       x22y14+2x21y14+4x23y11+x20y14+2x25y8+4x22y11+6x24y8+4x26y5+2x18y13+\
   x28y2+4x17y13+4x15y15+8x19y10+2x16y13+8x14y15+2x12y17+4x21y7+8x18y10+16x1\
   6y12+4x13y15+4x11y17+12x20y7+8x18y9+16x15y12+8x13y14+2x10y17+8x22y4+24x17\
   y9+4x15y11+x14y12+8x12y14+2x24y+16x19y6+12x14y11+2x13y12+4x11y14+4x21y3+8\
   x16y8+4x15y9+x12y12+8x10y14+6x8y16+2x18y5+2x17y6+4x14y9+16x12y11+4x9y14+1\
   2x7y16+4x5y18+6x16y6+8x14y8+16x11y11+24x9y13+6x6y16+8x4y18+x2y20+4x18y3+2\
   4x13y8+12x11y10+24x8y13+16x6y15+4x3y18+2xy20+x20+16x15y5+36x10y10+8x8y12+\
   16x5y15+4x3y17+y20+4x17y2+24x12y7+24x7y12+2x5y14+4x2y17+6x14y4+16x9y9+6x4\
   y14+4x11y6+4x6y11+x8y8
@expansion{} [2]:
@expansion{}    1,1
@c end example timeFactorize d2t_singular/general_lib.doc:812
@end smallexample
@c ---end content timeFactorize---

@c ------------------- factorH -------------
@node factorH,, timeFactorize, general_lib
@subsubsection factorH
@cindex factorH
@c ---content factorH---
Procedure from library @code{general.lib} (@pxref{general_lib}).

@table @asis
@item @strong{Usage:}
factorH(p) p poly

@item @strong{Return:}
factorize(p)

@item @strong{Note:}
changes variables to become the last variable the principal
one in the multivariate factorization and factorizes then
the polynomial

@end table
@strong{Example:}
@smallexample
@c computed example factorH d2t_singular/general_lib.doc:845 
LIB "general.lib";
system("random",992851144);
ring r=32003,(x,y,z,w,t),lp;
poly p=y2w9+yz7t-yz5w4-z2w4t4-w8t3;
//factorize(p);  //fast
//system("random",992851262);
//factorize(p);  //slow
//system("random",992851262);
factorH(p);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=y2w9+yz7t-yz5w4-z2w4t4-w8t3
@expansion{} [2]:
@expansion{}    1,1
@c end example factorH d2t_singular/general_lib.doc:845
@end smallexample
@c ---end content factorH---
@c ----------------------------------------------------------
@node inout_lib, poly_lib, general_lib, General purpose
@subsection inout_lib
@c include of docu for inout.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/inout_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/inout_lib.doc INSTEAD
@c library version: (1.21.2.5,2002/06/12)
@c library file: ../Singular/LIB/inout.lib
@cindex inout.lib
@cindex inout_lib
@table @asis
@item @strong{Library:}
inout.lib
@item @strong{Purpose:}
     Printing and Manipulating In- and Output

@end table

@strong{Procedures:}
@menu
* allprint:: print list if ALLprint is defined, with pause if >0
* lprint:: display poly/... fitting to pagewidth [size n]
* pmat:: print form-matrix [first n chars of each column]
* rMacaulay:: read Macaulay_1 output and return its Singular format
* show:: display any object in a compact format
* showrecursive:: display id recursively with respect to variables in p
* split:: split given string into lines of length n
* tab:: string of n space tabs
* writelist:: write a list into a file and keep the list structure
* pause:: stop the computation until user input
@end menu
@c ---end content LibInfo---

@c ------------------- allprint -------------
@node allprint, lprint,, inout_lib
@subsubsection allprint
@cindex allprint
@c ---content allprint---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
allprint(L); L list

@item @strong{Display:}
prints L[1], L[2], ... if an integer with name ALLprint is defined.
@* makes "pause", if ALLprint > 0
@* listvar(matrix), if ALLprint = 2

@item @strong{Return:}
no return value

@end table
@strong{Example:}
@smallexample
@c computed example allprint d2t_singular/inout_lib.doc:51 
LIB "inout.lib";
ring S;
matrix M=matrix(freemodule(2),3,3);
int ALLprint; export ALLprint;
@expansion{} // ** `ALLprint` is already global
allprint("M =",M);
@expansion{} M =
@expansion{} 1,0,0,
@expansion{} 0,1,0,
@expansion{} 0,0,0 
kill ALLprint;
@c end example allprint d2t_singular/inout_lib.doc:51
@end smallexample
@c ---end content allprint---

@c ------------------- lprint -------------
@node lprint, pmat, allprint, inout_lib
@subsubsection lprint
@cindex lprint
@c ---content lprint---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
lprint(id[,n]); id poly/ideal/vector/module/matrix, n integer

@item @strong{Return:}
string of id in a format fitting into lines of size n, such that no
monomial is destroyed, i.e. the new line starts with + or -;
(default: n = pagewidth).

@item @strong{Note:}
id is printed columnwise, each column separated by a blank line;
hence lprint(transpose(id)); displays a matrix id in a format which
can be used as input.

@end table
@strong{Example:}
@smallexample
@c computed example lprint d2t_singular/inout_lib.doc:86 
LIB "inout.lib";
ring r= 0,(x,y,z),ds;
poly f=((x+y)*(x-y)*(x+z)*(y+z)^2);
lprint(f,40);
@expansion{}   x3y2-xy4+2x3yz+x2y2z-2xy3z-y4z+x3z2
@expansion{} +2x2yz2-xy2z2-2y3z2+x2z3-y2z3
module m = [f*(x-y)],[0,f*(x-y)];
string s=lprint(m); s;"";
@expansion{}   x4y2-x3y3-x2y4+xy5+2x4yz-x3y2z-3x2y3z+xy4z+y5z+x4z2+x3yz2-3x2y2z2-xy3z2
@expansion{} +2y4z2+x3z3-x2yz3-xy2z3+y3z3,
@expansion{}   0,
@expansion{} 
@expansion{}   0,
@expansion{}   x4y2-x3y3-x2y4+xy5+2x4yz-x3y2z-3x2y3z+xy4z+y5z+x4z2+x3yz2-3x2y2z2-xy3z2
@expansion{} +2y4z2+x3z3-x2yz3-xy2z3+y3z3
@expansion{} 
execute("matrix M[2][2]="+s+";");      //use the string s as input
module m1 = transpose(M);	          //should be the same as m
print(m-m1);
@expansion{} 0,0,
@expansion{} 0,0 
@c end example lprint d2t_singular/inout_lib.doc:86
@end smallexample
@c ---end content lprint---

@c ------------------- pmat -------------
@node pmat, rMacaulay, lprint, inout_lib
@subsubsection pmat
@cindex pmat
@c ---content pmat---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
pmat(M,[n]); M matrix, n integer

@item @strong{Display:}
display M in array format if it fits into pagewidth; if n is given,
only the first n characters of each column are shown

@item @strong{Return:}
no return value

@end table
@strong{Example:}
@smallexample
@c computed example pmat d2t_singular/inout_lib.doc:121 
LIB "inout.lib";
ring r=0,(x,y,z),ls;
ideal i= x,z+3y,x+y,z;
matrix m[3][3]=i^2;
pmat(m);
@expansion{} x2,     xz+3xy,     xy+x2,         
@expansion{} xz,     z2+6yz+9y2, yz+3y2+xz+3xy, 
@expansion{} z2+3yz, y2+2xy+x2,  yz+xz
pmat(m,3);
@expansion{} x2  xz+ xy+ 
@expansion{} xz  z2+ yz+ 
@expansion{} z2+ y2+ yz+ 
@c end example pmat d2t_singular/inout_lib.doc:121
@end smallexample
@c ---end content pmat---

@c ------------------- rMacaulay -------------
@node rMacaulay, show, pmat, inout_lib
@subsubsection rMacaulay
@cindex rMacaulay
@c ---content rMacaulay---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
rMacaulay(s[,n]); s string, n integer

@item @strong{Return:}
A string which should be readable by Singular if s is a string which
was produced by Macaulay. If a second argument is present the first
n lines of the file are deleted (which is useful if the file was
produced e.g. by the putstd command of Macaulay).

@item @strong{Note:}
This does not always work with 'cut and paste' since the character
\ is treated differently

@end table
@strong{Example:}
@smallexample
@c computed example rMacaulay d2t_singular/inout_lib.doc:156 
LIB "inout.lib";
// Assume there exists a file 'Macid' with the following ideal in
// Macaulay format:"
// x[0]3-101/74x[0]2x[1]+7371x[0]x[1]2-13/83x[1]3-x[0]2x[2] \
//     -4/71x[0]x[1]x[2]
// Read this file into Singular and assign it to the string s1 by:
// string s1 = read("Macid");
// This is equivalent to";
string s1 =
"x[0]3-101/74x[0]2x[1]+7371x[0]x[1]2-13/83x[1]3-x[0]2x[2]-4/71x[0]x[1]x[2]";
rMacaulay(s1);
@expansion{} x(0)^3-101/74*x(0)^2*x(1)+7371*x(0)*x(1)^2-13/83*x(1)^3-x(0)^2*x(2)-4/71*\
   x(0)*x(1)*x(2)
// You may wish to assign s1 to a Singular ideal id:
string sid = "ideal id =",rMacaulay(s1),";";
ring r = 0,x(0..3),dp;
execute(sid);
id; "";
@expansion{} id[1]=x(0)^3-101/74*x(0)^2*x(1)+7371*x(0)*x(1)^2-13/83*x(1)^3-x(0)^2*x(2)\
   -4/71*x(0)*x(1)*x(2)
@expansion{} 
// Now treat a matrix in Macaulay format. Using the execute
// command, this could be assinged to a Singular matrix as above.
string s2 = "
0  0  0  0  0
a3 0  0  0  0
0  b3 0  0  0
0  0  c3 0  0
0  0  0  d3 0
0  0  0  0  e3 ";
rMacaulay(s2);
@expansion{} 0, 0, 0, 0, 0,
@expansion{} a3,0, 0, 0, 0,
@expansion{} 0, b3,0, 0, 0,
@expansion{} 0, 0, c3,0, 0,
@expansion{} 0, 0, 0, d3,0,
@expansion{} 0, 0, 0, 0, e3
@c end example rMacaulay d2t_singular/inout_lib.doc:156
@end smallexample
@c ---end content rMacaulay---

@c ------------------- show -------------
@node show, showrecursive, rMacaulay, inout_lib
@subsubsection show
@cindex show
@c ---content show---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
show(id); id any object of basering or of type ring/qring
@* show(R,s); R=ring, s=string (s = name of an object belonging to R)

@item @strong{Display:}
display id/s in a compact format together with some information

@item @strong{Return:}
no return value

@item @strong{Note:}
objects of type string, int, intvec, intmat belong to any ring.
id may be a ring or a qring. In this case the minimal polynomial is
displayed, and, for a qring, also the defining ideal.
@*id may be of type list but the list must not contain a ring.
@* show(R,s) does not work inside a procedure!

@end table
@strong{Example:}
@smallexample
@c computed example show d2t_singular/inout_lib.doc:215 
LIB "inout.lib";
ring r;
show(r);
@expansion{} // ring: (32003),(x,y,z),(dp(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
ideal i=x^3+y^5-6*z^3,xy,x3-y2;
show(i,3);            // introduce 3 space tabs before information
@expansion{}    // ideal, 3 generator(s)
@expansion{} y5+x3-6z3,
@expansion{} xy,
@expansion{} x3-y2
vector v=x*gen(1)+y*gen(3);
module m=v,2*v+gen(4);
list L = i,v,m;
show(L);
@expansion{} // list, 3 element(s):
@expansion{} [1]:
@expansion{}    // ideal, 3 generator(s)
@expansion{} y5+x3-6z3,
@expansion{} xy,
@expansion{} x3-y2
@expansion{} [2]:
@expansion{}    // vector
@expansion{} [x,0,y]
@expansion{} [3]:
@expansion{}    // module, 2 generator(s)
@expansion{} [x,0,y]
@expansion{} [2x,0,2y,1]
ring S=(0,T),(a,b,c,d),ws(1,2,3,4);
minpoly = T^2+1;
ideal i=a2+b,c2+T^2*d2; i=std(i);
qring Q=i;
show(Q);
@expansion{} // qring: (0,T),(a,b,c,d),(ws(1,2,3,4),C);
@expansion{} // minpoly = (T2+1)
@expansion{} // quotient ring from ideal:
@expansion{} _[1]=a2+b
@expansion{} _[2]=c2-d2
map F=r,a2,b^2,3*c3;
show(F);
@expansion{} // i-th variable of preimage ring is mapped to @@map[i]
@expansion{} // @@map                 [1]  map from r
@expansion{} @@map[1]=a2
@expansion{} @@map[2]=b2
@expansion{} @@map[3]=3*c3
// Apply 'show' to i (which does not belong to the basering) by typing
// ring r; ideal i=xy,x3-y2; ring Q; show(r,"i");
@c end example show d2t_singular/inout_lib.doc:215
@end smallexample
@c ---end content show---

@c ------------------- showrecursive -------------
@node showrecursive, split, show, inout_lib
@subsubsection showrecursive
@cindex showrecursive
@c ---content showrecursive---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
showrecursive(id,p[ord]); id= any object of basering, p= product of
variables and ord=string (any allowed ordstr)

@item @strong{Display:}
display 'id' in a recursive format as a polynomial in the variables
occurring in p with coefficients in the remaining variables. This is
done by mapping to a ring with parameters [and ordering 'ord',
if a 3rd argument is present (default: ord="dp")] and applying
procedure 'show'

@item @strong{Return:}
no return value

@end table
@strong{Example:}
@smallexample
@c computed example showrecursive d2t_singular/inout_lib.doc:263 
LIB "inout.lib";
ring r=2,(a,b,c,d,x,y),ds;
poly f=y+ax2+bx3+cx2y2+dxy3;
showrecursive(f,x);
@expansion{} // poly, 4 monomial(s)
@expansion{} (b)*x3+(a+cy2)*x2+(dy3)*x+(y)
showrecursive(f,xy,"lp");
@expansion{} // poly, 5 monomial(s)
@expansion{} (b)*x3+(c)*x2y2+(a)*x2+(d)*xy3+y
@c end example showrecursive d2t_singular/inout_lib.doc:263
@end smallexample
@c ---end content showrecursive---

@c ------------------- split -------------
@node split, tab, showrecursive, inout_lib
@subsubsection split
@cindex split
@c ---content split---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
split(s[,n]); s string, n integer

@item @strong{Return:}
same string, split into lines of length n separated by \
(default: n=pagewidth)

@item @strong{Note:}
may be used in connection with lprint

@end table
@strong{Example:}
@smallexample
@c computed example split d2t_singular/inout_lib.doc:294 
LIB "inout.lib";
ring r= 0,(x,y,z),ds;
poly f = (x+y+z)^4;
split(string(f),50);
@expansion{} x4+4x3y+6x2y2+4xy3+y4+4x3z+12x2yz+12xy2z+4y3z+6x\
@expansion{} 2z2+12xyz2+6y2z2+4xz3+4yz3+z4
split(lprint(f));
@expansion{}   x4+4x3y+6x2y2+4xy3+y4+4x3z+12x2yz+12xy2z+4y3z+6x2z2+12xyz2+6y2z2+4xz3+4\
   yz3\
@expansion{} +z4
@c end example split d2t_singular/inout_lib.doc:294
@end smallexample
@c ---end content split---

@c ------------------- tab -------------
@node tab, writelist, split, inout_lib
@subsubsection tab
@cindex tab
@c ---content tab---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
tab(n); n integer

@item @strong{Return:}
string of n space tabs

@end table
@strong{Example:}
@smallexample
@c computed example tab d2t_singular/inout_lib.doc:321 
LIB "inout.lib";
for(int n=0; n<=5; n=n+1)
@{ tab(5-n)+"*"+tab(n)+"+"+tab(n)+"*"; @}
@expansion{}      *+*
@expansion{}     * + *
@expansion{}    *  +  *
@expansion{}   *   +   *
@expansion{}  *    +    *
@expansion{} *     +     *
@c end example tab d2t_singular/inout_lib.doc:321
@end smallexample
@c ---end content tab---

@c ------------------- writelist -------------
@node writelist, pause, tab, inout_lib
@subsubsection writelist
@cindex writelist
@c ---content writelist---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
writelist(file,name,L); file,name strings (file-name, list-name),
L a list.

@item @strong{Create:}
a file with name `file`, write the content of the list L into it and
call the list `name`, keeping the list structure

@item @strong{Return:}
no return value

@item @strong{Note:}
The syntax of writelist uses and is similar to the syntax of the
write command of Singular which does not manage lists properly.
If (file,name) = ("listfile","L1"), writelist creates (resp.
appends if listfile exists) a file with name listfile and stores
there the list L under the name L1. The Singular command
execute(read("listfile")); assigns the content of L (stored in
listfile) to a list L1.
@* On a UNIX system, write(">file",...) overwrites an existing file
`file` while write("file",...) and write(">>file",...) append.

@end table
@strong{Example:}
@smallexample
@c computed example writelist d2t_singular/inout_lib.doc:362 
LIB "inout.lib";
ring r;
ideal i=x,y,z;
list k="Hi",nameof(basering),i,37;
writelist("zumSpass","lustig",k);
read("zumSpass");
@expansion{} list lustig;
@expansion{}    lustig[1]=
@expansion{} Hi;
@expansion{}    lustig[2]=
@expansion{} r;
@expansion{}    lustig[3]=
@expansion{} x,y,z;
@expansion{}    lustig[4]=
@expansion{} 37;
@expansion{} 
list L=res(i,0);                    //resolution of the ideal i
writelist("res_list","res-name",L); "";
@expansion{} 
read("res_list");
@expansion{} list res-name;
@expansion{}    res-name[1]=
@expansion{} z,y,x;
@expansion{}    res-name[2]=
@expansion{} -y*gen(1)+z*gen(2),-x*gen(1)+z*gen(3),-x*gen(2)+y*gen(3);
@expansion{}    res-name[3]=
@expansion{} x*gen(1)-y*gen(2)+z*gen(3);
@expansion{} 
// execute(read("res_list")); would create a list with name res-name,
// which is the resolution of i (the same content as L)
system("sh","/bin/rm res_list zumSpass");
@expansion{} 0
// Under UNIX, this removes the files 'res_list' and 'zumSpass'
// Type help system; to get more information about the shell escape
// If your operating system does not accept the shell escape, you
// must remove the just created files 'zumSpass' and 'res_list' directly
@c end example writelist d2t_singular/inout_lib.doc:362
@end smallexample
@c ---end content writelist---

@c ------------------- pause -------------
@node pause,, writelist, inout_lib
@subsubsection pause
@cindex pause
@c ---content pause---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
pause([ prompt ]) prompt string

@item @strong{Return:}
none

@item @strong{Purpose:}
interrupt the execution of commands until user input

@item @strong{Note:}
pause is useful in procedures in connection with printlevel to
interrupt the computation and to display intermediate results.

@end table
@strong{Example:}
@smallexample
@c computed example pause d2t_singular/inout_lib.doc:407 
LIB "inout.lib";
// can only be shown interactively, try the following commands:
// pause("press <return> to continue");
// pause();
// In the following pocedure TTT, xxx is printed and the execution of
// TTT is stopped until the return-key is pressed, if printlevel>0.
// xxx may be any result of a previous computation or a comment, etc:
//
// proc TTT
// @{ int pp = printlevel-voice+2;  //pp=0 if printlevel=0 and if TTT is
//    ....                         //not called from another procedure
//    if( pp>0 )
//    @{
//       print( xxx );
//       pause("press <return> to continue");
//    @}
//     ....
// @}
@c end example pause d2t_singular/inout_lib.doc:407
@end smallexample
@c inserted refs from d2t_singular/inout_lib.doc:428
@menu
See also:
* printlevel::
* read::
@end menu
@c end inserted refs from d2t_singular/inout_lib.doc:428

@c ---end content pause---
@c ----------------------------------------------------------
@node poly_lib, random_lib, inout_lib, General purpose
@subsection poly_lib
@c include of docu for poly.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/poly_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/poly_lib.doc INSTEAD
@c library version: (1.33.2.6,2003/02/10)
@c library file: ../Singular/LIB/poly.lib
@cindex poly.lib
@cindex poly_lib
@table @asis
@item @strong{Library:}
poly.lib
@item @strong{Purpose:}
      Procedures for Manipulating Polys, Ideals, Modules
@item @strong{Authors:}
O. Bachmann, G.-M: Greuel, A. Fruehbis

@end table

@strong{Procedures:}
@menu
* cyclic:: ideal of cyclic n-roots
* katsura:: katsura [i] ideal
* freerank:: rank of coker(input) if coker is free else -1
* is_homog:: int, =1 resp. =0 if input is homogeneous resp. not
* is_zero:: int, =1 resp. =0 if coker(input) is 0 resp. not
* lcm:: lcm of given generators of ideal
* maxcoef:: maximal length of coefficient occurring in poly/...
* maxdeg:: int/intmat = degree/s of terms of maximal order
* maxdeg1:: int = [weighted] maximal degree of input
* mindeg:: int/intmat = degree/s of terms of minimal order
* mindeg1:: int = [weighted] minimal degree of input
* normalize:: normalize poly/... such that leading coefficient is 1
* rad_con:: check radical containment of poly p in ideal I
* content:: content of polynomial/vector f
* numerator:: numerator of number n
* denominator:: denominator of number n
* mod2id:: conversion of a module M to an ideal
* id2mod:: conversion inverse to mod2id
* substitute:: substitute in I variables by polynomials
* subrInterred:: interred w.r.t. a subset of variables
* hilbPoly:: Hilbert polynomial of basering/I
@end menu
@c ---end content LibInfo---

@c ------------------- cyclic -------------
@node cyclic, katsura,, poly_lib
@subsubsection cyclic
@cindex cyclic
@c ---content cyclic---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
cyclic(n); n integer

@item @strong{Return:}
ideal of cyclic n-roots from 1-st n variables of basering

@end table
@strong{Example:}
@smallexample
@c computed example cyclic d2t_singular/poly_lib.doc:59 
LIB "poly.lib";
ring r=0,(u,v,w,x,y,z),lp;
cyclic(nvars(basering));
@expansion{} _[1]=u+v+w+x+y+z
@expansion{} _[2]=uv+uz+vw+wx+xy+yz
@expansion{} _[3]=uvw+uvz+uyz+vwx+wxy+xyz
@expansion{} _[4]=uvwx+uvwz+uvyz+uxyz+vwxy+wxyz
@expansion{} _[5]=uvwxy+uvwxz+uvwyz+uvxyz+uwxyz+vwxyz
@expansion{} _[6]=uvwxyz-1
homog(cyclic(5),z);
@expansion{} _[1]=u+v+w+x+y
@expansion{} _[2]=uv+uy+vw+wx+xy
@expansion{} _[3]=uvw+uvy+uxy+vwx+wxy
@expansion{} _[4]=uvwx+uvwy+uvxy+uwxy+vwxy
@expansion{} _[5]=uvwxy-z5
@c end example cyclic d2t_singular/poly_lib.doc:59
@end smallexample
@c ---end content cyclic---

@c ------------------- katsura -------------
@node katsura, freerank, cyclic, poly_lib
@subsubsection katsura
@cindex katsura
@c ---content katsura---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
katsura([n]): n integer

@item @strong{Return:}
katsura(n) : n-th katsura ideal of
@*(1) newly created and set ring (32003, x(0..n), dp), if
nvars(basering) < n
@*(2) basering, if nvars(basering) >= n
@*katsura() : katsura ideal of basering

@end table
@strong{Example:}
@smallexample
@c computed example katsura d2t_singular/poly_lib.doc:89 
LIB "poly.lib";
ring r; basering;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z 
@expansion{} //        block   2 : ordering C
katsura();
@expansion{} _[1]=x+2y+2z-1
@expansion{} _[2]=x2+2y2+2z2-x
@expansion{} _[3]=2xy+2yz-y
katsura(4); basering;
@expansion{} _[1]=x(0)+2*x(1)+2*x(2)+2*x(3)-1
@expansion{} _[2]=x(0)^2+2*x(1)^2+2*x(2)^2+2*x(3)^2-x(0)
@expansion{} _[3]=2*x(0)*x(1)+2*x(1)*x(2)+2*x(2)*x(3)-x(1)
@expansion{} _[4]=x(1)^2+2*x(0)*x(2)+2*x(1)*x(3)-x(2)
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x(0) x(1) x(2) x(3) x(4) 
@expansion{} //        block   2 : ordering C
@c end example katsura d2t_singular/poly_lib.doc:89
@end smallexample
@c ---end content katsura---

@c ------------------- freerank -------------
@node freerank, is_homog, katsura, poly_lib
@subsubsection freerank
@cindex freerank
@c ---content freerank---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
freerank(M[,any]); M=poly/ideal/vector/module/matrix

@item @strong{Compute:}
rank of module presented by M in case it is free.
@*By definition this is vdim(coker(M)/m*coker(M)) if coker(M)
is free, where m = maximal ideal of the variables of the
basering and M is considered as matrix.
@*(the 0-module is free of rank 0)

@item @strong{Return:}
rank of coker(M) if coker(M) is free and -1 else;
@*in case of a second argument return a list:
@*L[1] = rank of coker(M) or -1
@*L[2] = minbase(M)

@item @strong{Note:}
freerank(syz(M)); computes the rank of M if M is free (and -1 else)

@end table
@strong{Example:}
@smallexample
@c computed example freerank d2t_singular/poly_lib.doc:128 
LIB "poly.lib";
ring r;
ideal i=x;
module M=[x,0,1],[-x,0,-1];
freerank(M);          // should be 2, coker(M) is not free
@expansion{} 2
freerank(syz (M),"");
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    _[1]=gen(2)+gen(1)
// [1] should be 1, coker(syz(M))=M is free of rank 1
// [2] should be gen(2)+gen(1) (minimal relation of M)
freerank(i);
@expansion{} -1
freerank(syz(i));     // should be 1, coker(syz(i))=i is free of rank 1
@expansion{} 1
@c end example freerank d2t_singular/poly_lib.doc:128
@end smallexample
@c ---end content freerank---

@c ------------------- is_homog -------------
@node is_homog, is_zero, freerank, poly_lib
@subsubsection is_homog
@cindex is_homog
@c ---content is_homog---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
is_homog(id); id poly/ideal/vector/module/matrix

@item @strong{Return:}
integer which is 1 if input is homogeneous (resp. weighted homogeneous
if the monomial ordering consists of one block of type ws,Ws,wp or Wp,
assuming that all weights are positive) and 0 otherwise

@item @strong{Note:}
A vector is homogeneous, if the components are homogeneous of same
degree, a module/matrix is homogeneous if all column vectors are
homogeneous
@*//*** ergaenzen, wenn Matrizen-Spalten Gewichte haben

@end table
@strong{Example:}
@smallexample
@c computed example is_homog d2t_singular/poly_lib.doc:168 
LIB "poly.lib";
ring r = 0,(x,y,z),wp(1,2,3);
is_homog(x5-yz+y3);
@expansion{} 0
ideal i = x6+y3+z2, x9-z3;
is_homog(i);
@expansion{} 1
ring s = 0,(a,b,c),ds;
vector v = [a2,0,ac+bc];
vector w = [a3,b3,c4];
is_homog(v);
@expansion{} 1
is_homog(w);
@expansion{} 0
@c end example is_homog d2t_singular/poly_lib.doc:168
@end smallexample
@c ---end content is_homog---

@c ------------------- is_zero -------------
@node is_zero, lcm, is_homog, poly_lib
@subsubsection is_zero
@cindex is_zero
@c ---content is_zero---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
is_zero(M[,any]); M=poly/ideal/vector/module/matrix

@item @strong{Return:}
integer, 1 if coker(M)=0 resp. 0 if coker(M)!=0, where M is
considered as matrix.
@*If a second argument is given, return a list:
@*L[1] = 1 if coker(M)=0 resp. 0 if coker(M)!=0
@*L[2] = dim(M)

@end table
@strong{Example:}
@smallexample
@c computed example is_zero d2t_singular/poly_lib.doc:204 
LIB "poly.lib";
ring r;
module m = [x],[y],[1,z];
is_zero(m,1);
@expansion{} [1]:
@expansion{}    0
@expansion{} [2]:
@expansion{}    2
qring q = std(ideal(x2+y3+z2));
ideal j = x2+y3+z2-37;
is_zero(j);
@expansion{} 1
@c end example is_zero d2t_singular/poly_lib.doc:204
@end smallexample
@c ---end content is_zero---

@c ------------------- lcm -------------
@node lcm, maxcoef, is_zero, poly_lib
@subsubsection lcm
@cindex lcm
@c ---content lcm---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
lcm(p[,q]); p int/intvec q a list of integers or
@*p poly/ideal q a list of polynomials

@item @strong{Return:}
the least common multiple of the common entries of p and q:
@* - of type int if p is an int/intvec
@* - of type poly if p is a poly/ideal

@end table
@strong{Example:}
@smallexample
@c computed example lcm d2t_singular/poly_lib.doc:236 
LIB "poly.lib";
ring  r = 0,(x,y,z),lp;
poly  p = (x+y)*(y+z);
poly  q = (z4+2)*(y+z);
lcm(p,q);
@expansion{} xyz4+2xy+xz5+2xz+y2z4+2y2+yz5+2yz
ideal i=p,q,y+z;
lcm(i,p);
@expansion{} xyz4+2xy+xz5+2xz+y2z4+2y2+yz5+2yz
lcm(2,3,6);
@expansion{} 6
lcm(2..6);
@expansion{} 60
@c end example lcm d2t_singular/poly_lib.doc:236
@end smallexample
@c ---end content lcm---

@c ------------------- maxcoef -------------
@node maxcoef, maxdeg, lcm, poly_lib
@subsubsection maxcoef
@cindex maxcoef
@c ---content maxcoef---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
maxcoef(f); f poly/ideal/vector/module/matrix

@item @strong{Return:}
maximal length of coefficient of f of type int (by counting the
length of the string of each coefficient)

@end table
@strong{Example:}
@smallexample
@c computed example maxcoef d2t_singular/poly_lib.doc:268 
LIB "poly.lib";
ring r= 0,(x,y,z),ds;
poly g = 345x2-1234567890y+7/4z;
maxcoef(g);
@expansion{} 10
ideal i = g,10/1234567890;
maxcoef(i);
@expansion{} 11
// since i[2]=1/123456789
@c end example maxcoef d2t_singular/poly_lib.doc:268
@end smallexample
@c ---end content maxcoef---

@c ------------------- maxdeg -------------
@node maxdeg, maxdeg1, maxcoef, poly_lib
@subsubsection maxdeg
@cindex maxdeg
@c ---content maxdeg---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
maxdeg(id); id poly/ideal/vector/module/matrix

@item @strong{Return:}
int/intmat, each component equals maximal degree of monomials in the
corresponding component of id, independent of ring ordering
(maxdeg of each var is 1).
@*Of type int if id is of type poly, of type intmat else

@item @strong{Note:}
proc maxdeg1 returns 1 integer, the absolute maximum; moreover, it has
an option for computing weighted degrees

@end table
@strong{Example:}
@smallexample
@c computed example maxdeg d2t_singular/poly_lib.doc:304 
LIB "poly.lib";
ring r = 0,(x,y,z),wp(1,2,3);
poly f = x+y2+z3;
deg(f);             //deg; returns weighted degree (in case of 1 block)!
@expansion{} 9
maxdeg(f);
@expansion{} 3
matrix m[2][2]=f+x10,1,0,f^2;
maxdeg(m);
@expansion{} 10,0,
@expansion{} -1,6 
@c end example maxdeg d2t_singular/poly_lib.doc:304
@end smallexample
@c ---end content maxdeg---

@c ------------------- maxdeg1 -------------
@node maxdeg1, mindeg, maxdeg, poly_lib
@subsubsection maxdeg1
@cindex maxdeg1
@c ---content maxdeg1---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
maxdeg1(id[,v]); id=poly/ideal/vector/module/matrix, v=intvec

@item @strong{Return:}
integer, maximal [weighted] degree of monomials of id independent of
ring ordering, maxdeg1 of i-th variable is v[i] (default: v=1..1).

@item @strong{Note:}
This proc returns one integer while maxdeg returns, in general,
a matrix of integers. For one polynomial and if no intvec v is given
maxdeg is faster

@end table
@strong{Example:}
@smallexample
@c computed example maxdeg1 d2t_singular/poly_lib.doc:339 
LIB "poly.lib";
ring r = 0,(x,y,z),wp(1,2,3);
poly f = x+y2+z3;
deg(f);            //deg returns weighted degree (in case of 1 block)!
@expansion{} 9
maxdeg1(f);
@expansion{} 3
intvec v = ringweights(r);
maxdeg1(f,v);                        //weighted maximal degree
@expansion{} 9
matrix m[2][2]=f+x10,1,0,f^2;
maxdeg1(m,v);                        //absolute weighted maximal degree
@expansion{} 18
@c end example maxdeg1 d2t_singular/poly_lib.doc:339
@end smallexample
@c ---end content maxdeg1---

@c ------------------- mindeg -------------
@node mindeg, mindeg1, maxdeg1, poly_lib
@subsubsection mindeg
@cindex mindeg
@c ---content mindeg---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
mindeg(id); id poly/ideal/vector/module/matrix

@item @strong{Return:}
minimal degree/s of monomials of id, independent of ring ordering
(mindeg of each variable is 1) of type int if id of type poly, else
of type intmat.

@item @strong{Note:}
proc mindeg1 returns one integer, the absolute minimum; moreover it
has an option for computing weighted degrees.

@end table
@strong{Example:}
@smallexample
@c computed example mindeg d2t_singular/poly_lib.doc:376 
LIB "poly.lib";
ring r = 0,(x,y,z),ls;
poly f = x5+y2+z3;
ord(f);                  // ord returns weighted order of leading term!
@expansion{} 3
mindeg(f);               // computes minimal degree
@expansion{} 2
matrix m[2][2]=x10,1,0,f^2;
mindeg(m);               // computes matrix of minimum degrees
@expansion{} 10,0,
@expansion{} -1,4 
@c end example mindeg d2t_singular/poly_lib.doc:376
@end smallexample
@c ---end content mindeg---

@c ------------------- mindeg1 -------------
@node mindeg1, normalize, mindeg, poly_lib
@subsubsection mindeg1
@cindex mindeg1
@c ---content mindeg1---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
mindeg1(id[,v]); id=poly/ideal/vector/module/matrix, v=intvec

@item @strong{Return:}
integer, minimal [weighted] degree of monomials of id independent of
ring ordering, mindeg1 of i-th variable is v[i] (default v=1..1).

@item @strong{Note:}
This proc returns one integer while mindeg returns, in general,
a matrix of integers. For one polynomial and if no intvec v is given
mindeg is faster.

@end table
@strong{Example:}
@smallexample
@c computed example mindeg1 d2t_singular/poly_lib.doc:411 
LIB "poly.lib";
ring r = 0,(x,y,z),ls;
poly f = x5+y2+z3;
ord(f);                  // ord returns weighted order of leading term!
@expansion{} 3
intvec v = 1,-3,2;
mindeg1(f,v);            // computes minimal weighted degree
@expansion{} -6
matrix m[2][2]=x10,1,0,f^2;
mindeg1(m,1..3);         // computes absolute minimum of weighted degrees
@expansion{} -1
@c end example mindeg1 d2t_singular/poly_lib.doc:411
@end smallexample
@c ---end content mindeg1---

@c ------------------- normalize -------------
@node normalize, rad_con, mindeg1, poly_lib
@subsubsection normalize
@cindex normalize
@c ---content normalize---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
normalize(id); id=poly/vector/ideal/module

@item @strong{Return:}
object of same type with leading coefficient equal to 1

@end table
@strong{Example:}
@smallexample
@c computed example normalize d2t_singular/poly_lib.doc:441 
LIB "poly.lib";
ring r = 0,(x,y,z),ls;
poly f = 2x5+3y2+4z3;
normalize(f);
@expansion{} z3+3/4y2+1/2x5
module m=[9xy,0,3z3],[4z,6y,2x];
normalize(m);
@expansion{} _[1]=z3*gen(3)+3xy*gen(1)
@expansion{} _[2]=z*gen(1)+3/2y*gen(2)+1/2x*gen(3)
ring s = 0,(x,y,z),(c,ls);
module m=[9xy,0,3z3],[4z,6y,2x];
normalize(m);
@expansion{} _[1]=[xy,0,1/3z3]
@expansion{} _[2]=[z,3/2y,1/2x]
@c end example normalize d2t_singular/poly_lib.doc:441
@end smallexample
@c ---end content normalize---

@c ------------------- rad_con -------------
@node rad_con, content, normalize, poly_lib
@subsubsection rad_con
@cindex rad_con
@c ---content rad_con---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
rad_con(g,I); g polynomial, I ideal

@item @strong{Return:}
1 (TRUE) (type int) if g is contained in the radical of I
@* 0 (FALSE) (type int) otherwise

@end table
@strong{Example:}
@smallexample
@c computed example rad_con d2t_singular/poly_lib.doc:473 
LIB "poly.lib";
ring R=0,(x,y,z),dp;
ideal I=x2+y2,z2;
poly f=x4+y4;
rad_con(f,I);
@expansion{} 0
ideal J=x2+y2,z2,x4+y4;
poly g=z;
rad_con(g,I);
@expansion{} 1
@c end example rad_con d2t_singular/poly_lib.doc:473
@end smallexample
@c ---end content rad_con---

@c ------------------- content -------------
@node content, numerator, rad_con, poly_lib
@subsubsection content
@cindex content
@c ---content content---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
content(f); f polynomial/vector

@item @strong{Return:}
number, the content (greatest common factor of coefficients)
of the polynomial/vector f

@end table
@strong{Example:}
@smallexample
@c computed example content d2t_singular/poly_lib.doc:504 
LIB "poly.lib";
ring r=0,(x,y,z),(c,lp);
content(3x2+18xy-27xyz);
@expansion{} 3
vector v=[3x2+18xy-27xyz,15x2+12y4,3];
content(v);
@expansion{} 3
@c end example content d2t_singular/poly_lib.doc:504
@end smallexample
@c ---end content content---

@c ------------------- numerator -------------
@node numerator, denominator, content, poly_lib
@subsubsection numerator
@cindex numerator
@c ---content numerator---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
numerator(n); n number

@item @strong{Return:}
number, the numerator of n

@end table
@strong{Example:}
@smallexample
@c computed example numerator d2t_singular/poly_lib.doc:531 
LIB "poly.lib";
ring r = 0,x, dp;
number n = 3/2;
numerator(n);
@expansion{} 3
@c end example numerator d2t_singular/poly_lib.doc:531
@end smallexample
@c inserted refs from d2t_singular/poly_lib.doc:538
@menu
See also:
* cleardenom::
* content::
* denominator::
@end menu
@c end inserted refs from d2t_singular/poly_lib.doc:538

@c ---end content numerator---

@c ------------------- denominator -------------
@node denominator, mod2id, numerator, poly_lib
@subsubsection denominator
@cindex denominator
@c ---content denominator---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
denominator(n); n number

@item @strong{Return:}
number, the denominator of n

@end table
@strong{Example:}
@smallexample
@c computed example denominator d2t_singular/poly_lib.doc:561 
LIB "poly.lib";
ring r = 0,x, dp;
number n = 3/2;
denominator(n);
@expansion{} 2
@c end example denominator d2t_singular/poly_lib.doc:561
@end smallexample
@c inserted refs from d2t_singular/poly_lib.doc:568
@menu
See also:
* cleardenom::
* content::
* denominator::
@end menu
@c end inserted refs from d2t_singular/poly_lib.doc:568

@c ---end content denominator---

@c ------------------- mod2id -------------
@node mod2id, id2mod, denominator, poly_lib
@subsubsection mod2id
@cindex mod2id
@c ---content mod2id---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
mod2id(M,vpos); M matrix, vpos intvec

@item @strong{Assume:}
vpos is an integer vector such that gen(i) corresponds
to var(vpos[i]).
@*The basering contains variables var(vpos[i]) which do not occur
in M.

@item @strong{Return:}
ideal I in which each gen(i) from the module is replaced by
var(vpos[i]) and all monomials var(vpos[i])*var(vpos[j]) have
been added to the generating set of I.

@item @strong{Note:}
This procedure should be used in the following situation:
one wants to pass to a ring with new variables, say e(1),..,e(s),
which correspond to the components gen(1),..,gen(s) of the
module M such that e(i)*e(j)=0 for all i,j.
@*The new ring should already exist and be the current ring

@end table
@strong{Example:}
@smallexample
@c computed example mod2id d2t_singular/poly_lib.doc:606 
LIB "poly.lib";
ring r=0,(e(1),e(2),x,y,z),(dp(2),ds(3));
module mo=x*gen(1)+y*gen(2);
intvec iv=2,1;
mod2id(mo,iv);
@expansion{} _[1]=e(2)^2
@expansion{} _[2]=e(1)*e(2)
@expansion{} _[3]=e(1)^2
@expansion{} _[4]=e(1)*y+e(2)*x
@c end example mod2id d2t_singular/poly_lib.doc:606
@end smallexample
@c ---end content mod2id---

@c ------------------- id2mod -------------
@node id2mod, substitute, mod2id, poly_lib
@subsubsection id2mod
@cindex id2mod
@c ---content id2mod---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
id2mod(I,vpos); I ideal, vpos intvec

@item @strong{Return:}
module corresponding to the ideal by replacing var(vpos[i]) by
gen(i) and omitting all generators var(vpos[i])*var(vpos[j])

@item @strong{Note:}
* This procedure only makes sense if the ideal contains
all var(vpos[i])*var(vpos[j]) as monomial generators and
all other generators of I are linear combinations of the
var(vpos[i]) over the ring in the other variables.
@** This is the inverse procedure to mod2id and should be applied
only to ideals created by mod2id using the same intvec vpos
(possibly after a standard basis computation)

@end table
@strong{Example:}
@smallexample
@c computed example id2mod d2t_singular/poly_lib.doc:643 
LIB "poly.lib";
ring r=0,(e(1),e(2),x,y,z),(dp(2),ds(3));
ideal i=e(2)^2,e(1)*e(2),e(1)^2,e(1)*y+e(2)*x;
intvec iv=2,1;
id2mod(i,iv);
@expansion{} _[1]=x*gen(1)+y*gen(2)
@c end example id2mod d2t_singular/poly_lib.doc:643
@end smallexample
@c ---end content id2mod---

@c ------------------- substitute -------------
@node substitute, subrInterred, id2mod, poly_lib
@subsubsection substitute
@cindex substitute
@c ---content substitute---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
- case 1: typeof(#[1])==poly:
@*substitute (I,v,f[,v1,f1,v2,f2,...]); I object of basering which
can be mapped, v,v1,v2,.. ring variables, f,f1,f2,... poly
@* - case 2: typeof(#[1])==ideal:
substitute1 (I,v,f); I object of basering which can be mapped,
v ideal of ring variables, f ideal

@item @strong{Return:}
object of same type as I,
@* - case 1: ring variable v,v1,v2,... substituted by polynomials
f,f1,f2,..., in this order
@* - case 2: ring variables in v substituted by polynomials in f:
v[i] is substituted by f[i], i=1,...,i=min(size(v),ncols(f))

@item @strong{Note:}
this procedure extends the built-in command subst which substitutes
ring variables only by monomials

@end table
@strong{Example:}
@smallexample
@c computed example substitute d2t_singular/poly_lib.doc:683 
LIB "poly.lib";
ring r = 0,(b,c,t),dp;
ideal I = -bc+4b2c2t,bc2t-5b2c;
substitute(I,c,b+c,t,0,b,b-1);
@expansion{} _[1]=-b2-bc+2b+c-1
@expansion{} _[2]=-5b3-5b2c+15b2+10bc-15b-5c+5
ideal v = c,t,b;
ideal f = b+c,0,b-1;
substitute(I,v,f);
@expansion{} _[1]=-b2-bc+2b+c-1
@expansion{} _[2]=-5b3-5b2c+15b2+10bc-15b-5c+5
@c end example substitute d2t_singular/poly_lib.doc:683
@end smallexample
@c ---end content substitute---

@c ------------------- subrInterred -------------
@node subrInterred, hilbPoly, substitute, poly_lib
@subsubsection subrInterred
@cindex subrInterred
@c ---content subrInterred---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
subrInterred(mon,sm,iv);
@*sm: ideal in a ring r with n + s variables,
@*e.g. x_1,..,x_n and t_1,..,t_s
@*mon: ideal with monomial generators (not divisible by
any of the t_i) such that sm is contained in the module
k[t_1,..,t_s]*mon[1]+..+k[t_1,..,t_s]*mon[size(mon)]
@*iv: intvec listing the variables which are supposed to be used
as x_i

@item @strong{Return:}
list l:
@*l[1]=the monomials from mon in the order used
@*l[2]=their coefficients after interreduction
@*l[3]=l[1]*l[2]

@item @strong{Purpose:}
Do interred only w.r.t. a subset of variables.
@*The procedure returns an interreduced system of generators of
sm considered as a k[t_1,..,t_s]-submodule of the free module
k[t_1,..,t_s]*mon[1]+..+k[t_1,..,t_s]*mon[size(mon)]).

@end table
@strong{Example:}
@smallexample
@c computed example subrInterred d2t_singular/poly_lib.doc:728 
LIB "poly.lib";
ring r=0,(x,y,z),dp;
ideal i=x^2+x*y^2,x*y+x^2*y,z;
ideal j=x^2+x*y^2,x*y,z;
ideal mon=x^2,z,x*y;
intvec iv=1,3;
subrInterred(mon,i,iv);
@expansion{} [1]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=xy
@expansion{}    _[1,3]=x2
@expansion{} [2]:
@expansion{}    _[1]=gen(1)
@expansion{}    _[2]=y2*gen(2)-gen(2)
@expansion{}    _[3]=y*gen(2)+gen(3)
@expansion{} [3]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=xy3-xy
@expansion{}    _[1,3]=xy2+x2
subrInterred(mon,j,iv);
@expansion{} [1]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=xy
@expansion{}    _[1,3]=x2
@expansion{} [2]:
@expansion{}    _[1]=gen(1)
@expansion{}    _[2]=gen(2)
@expansion{}    _[3]=gen(3)
@expansion{} [3]:
@expansion{}    _[1,1]=z
@expansion{}    _[1,2]=xy
@expansion{}    _[1,3]=x2
@c end example subrInterred d2t_singular/poly_lib.doc:728
@end smallexample
@c ---end content subrInterred---

@c ------------------- hilbPoly -------------
@node hilbPoly,, subrInterred, poly_lib
@subsubsection hilbPoly
@cindex hilbPoly
@c ---content hilbPoly---
Procedure from library @code{poly.lib} (@pxref{poly_lib}).

@table @asis
@item @strong{Usage:}
hilbPoly(I) I a homogeneous ideal

@item @strong{Return:}
the Hilbert polynomial of basering/I as an intvec v=v_0,...,v_r
such that the Hilbert polynomial is (v_0+v_1*t+...v_r*t^r)/r!

@end table
@strong{Example:}
@smallexample
@c computed example hilbPoly d2t_singular/poly_lib.doc:759 
LIB "poly.lib";
ring r = 0,(b,c,t,h),dp;
ideal I=
bct-t2h+2th2+h3,
bt3-ct3-t4+b2th+c2th-2bt2h+2ct2h+2t3h-bch2-2bth2+2cth2+2th3,
b2c2+bt2h-ct2h-t3h+b2h2+2bch2+c2h2-2bth2+2cth2+t2h2-2bh3+2ch3+2th3+3h4,
c2t3+ct4-c3th-2c2t2h-2ct3h-t4h+bc2h2-2c2th2-bt2h2+4t3h2+2bth3-2cth3-t2h3
+bh4-6th4-2h5;
hilbPoly(I);
@expansion{} -11,10
@c end example hilbPoly d2t_singular/poly_lib.doc:759
@end smallexample
@c ---end content hilbPoly---
@c ----------------------------------------------------------
@node random_lib, ring_lib, poly_lib, General purpose
@subsection random_lib
@c include of docu for random.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/random_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/random_lib.doc INSTEAD
@c library version: (1.16.2.1,2002/02/20)
@c library file: ../Singular/LIB/random.lib
@cindex random.lib
@cindex random_lib
@table @asis
@item @strong{Library:}
random.lib
@item @strong{Purpose:}
    Creating Random and Sparse Matrices, Ideals, Polys

@end table

@strong{Procedures:}
@menu
* genericid:: generic sparse linear combinations of generators of i
* randomid:: random linear combinations of generators of id
* randommat:: nxm matrix of random linear combinations of id
* sparseid:: ideal of k random sparse poly's of degree d [u<=d<=o]
* sparsematrix:: nxm sparse matrix of polynomials of degree<=o
* sparsemat:: nxm sparse integer matrix with random coefficients
* sparsepoly:: random sparse polynomial with terms of degree in [u,o]
* sparsetriag:: nxm sparse lower-triag intmat with random coefficients
* triagmatrix:: nxm sparse lower-triag matrix of poly's of degree<=o
* randomLast:: random transformation of the last variable
* randomBinomial:: binomial ideal, k random generators of degree >=u
@end menu
@c ---end content LibInfo---

@c ------------------- genericid -------------
@node genericid, randomid,, random_lib
@subsubsection genericid
@cindex genericid
@c ---content genericid---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
genericid(id,[,p,b]); id ideal/module, k,p,b integers

@item @strong{Return:}
system of generators of id which are generic, sparse, triagonal linear
combinations of given generators with coefficients in [1,b] and
sparseness p percent, bigger p being sparser (default: p=75, b=30000)

@item @strong{Note:}
For performance reasons try small bound b in characteristic 0

@end table
@strong{Example:}
@smallexample
@c computed example genericid d2t_singular/random_lib.doc:52 
LIB "random.lib";
ring r=0,(t,x,y,z),ds;
ideal i= x3+y4,z4+yx,t+x+y+z;
genericid(i,0,10);
@expansion{} _[1]=3t+3x+3y+3z+2xy+x3+y4+2z4
@expansion{} _[2]=4t+4x+4y+4z+xy+z4
@expansion{} _[3]=t+x+y+z
module m=[x,0,0,0],[0,y2,0,0],[0,0,z3,0],[0,0,0,t4];
print(genericid(m));
@expansion{} x,      0,      0, 0,
@expansion{} 17904y2,y2,     0, 0,
@expansion{} 0,      24170z3,z3,0,
@expansion{} 0,      0,      0, t4
@c end example genericid d2t_singular/random_lib.doc:52
@end smallexample
@c ---end content genericid---

@c ------------------- randomid -------------
@node randomid, randommat, genericid, random_lib
@subsubsection randomid
@cindex randomid
@c ---content randomid---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
randomid(id,[k,b]); id ideal/module, b,k integers

@item @strong{Return:}
ideal/module having k generators which are random linear combinations
of generators of id with coefficients in the interval [-b,b]
(default: b=30000, k=size(id))

@item @strong{Note:}
For performance reasons try small bound b in characteristic 0

@end table
@strong{Example:}
@smallexample
@c computed example randomid d2t_singular/random_lib.doc:85 
LIB "random.lib";
ring r=0,(x,y,z),dp;
randomid(maxideal(2),2,9);
@expansion{} _[1]=-5x2-9xy+6y2-8xz-8yz+4z2
@expansion{} _[2]=-9xy+2y2+xz+yz-z2
module m=[x,0,1],[0,y2,0],[y,0,z3];
show(randomid(m));
@expansion{} // module, 3 generator(s)
@expansion{} [1369x-11685y,-4481y2,-11685z3+1369]
@expansion{} [-642x-13756y,25342y2,-13756z3-642]
@expansion{} [2536x-6355y,8285y2,-6355z3+2536]
@c end example randomid d2t_singular/random_lib.doc:85
@end smallexample
@c ---end content randomid---

@c ------------------- randommat -------------
@node randommat, sparseid, randomid, random_lib
@subsubsection randommat
@cindex randommat
@c ---content randommat---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
randommat(n,m[,id,b]); n,m,b integers, id ideal

@item @strong{Return:}
nxm matrix, entries are random linear combinations of elements
of id and coefficients in [-b,b]
@*[default: (id,b) = (maxideal(1),30000)]

@item @strong{Note:}
For performance reasons try small bound b in char 0

@end table
@strong{Example:}
@smallexample
@c computed example randommat d2t_singular/random_lib.doc:117 
LIB "random.lib";
ring r=0,(x,y,z),dp;
matrix A=randommat(3,3,maxideal(2),9);
print(A);
@expansion{} 9x2-2xy-8y2-9xz+yz+4z2, 9x2-4xy+y2-5xz+6yz-z2,   8x2+xy-9y2+2yz-8z2,    
@expansion{} -x2+5xy-8y2-7xz+4yz-3z2,x2+xy-4y2-xz+5z2,        5x2-8xy+8y2+6xz+yz+7z2,
@expansion{} 4x2-5xy-6y2-4yz-5z2,    -4x2-6xy-4y2-8xz+3yz+5z2,2x2+3xy+y2+4xz-3yz+2z2 
A=randommat(2,3);
print(A);
@expansion{} 15276x+9897y+7526z,  6495x-24178y+11295z,-5745x-14754y+15979z,
@expansion{} 20788x-28366y-20283z,24911x-10978y+3341z,12412x+11216y+15344z 
@c end example randommat d2t_singular/random_lib.doc:117
@end smallexample
@c ---end content randommat---

@c ------------------- sparseid -------------
@node sparseid, sparsematrix, randommat, random_lib
@subsubsection sparseid
@cindex sparseid
@c ---content sparseid---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
sparseid(k,u[,o,p,b]); k,u,o,p,b integers

@item @strong{Return:}
ideal having k generators, each of degree d, u<=d<=o, p percent of
terms in degree d are 0, the remaining have random coefficients
in the interval [1,b], (default: o=u=d, p=75, b=30000)

@end table
@strong{Example:}
@smallexample
@c computed example sparseid d2t_singular/random_lib.doc:147 
LIB "random.lib";
ring r = 0,(a,b,c,d),ds;
sparseid(2,3);"";
@expansion{} _[1]=12773a3+24263a2c+20030abc+17904b2c+26359c3
@expansion{} _[2]=24004a3+6204b2c+24170bc2+19505c2d+21962bd2
@expansion{} 
sparseid(3,0,4,90,9);
@expansion{} _[1]=1+4a2+8b2c+3c3+4a3b+4a2b2+5abc2+3ac3
@expansion{} _[2]=a+a2+7ab2+6a2c+3c3+5a3b+9ab3+2c4+3c3d+8ad3
@expansion{} _[3]=5a+ab+2ac2+2b3c+8abcd
@c end example sparseid d2t_singular/random_lib.doc:147
@end smallexample
@c ---end content sparseid---

@c ------------------- sparsematrix -------------
@node sparsematrix, sparsemat, sparseid, random_lib
@subsubsection sparsematrix
@cindex sparsematrix
@c ---content sparsematrix---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
sparsematrix(n,m,o[,u,pe,pp,b]); n,m,o,u,pe,pp,b integers

@item @strong{Return:}
nxm matrix, about pe percent of the entries are 0, the remaining
are random polynomials of degree d, u<=d<=o, with pp percent of
the terms being 0, the remaining have random coefficients
in the interval [1,b] [default: (pe,u,pp,b) = (0,50,75,100)]

@end table
@strong{Example:}
@smallexample
@c computed example sparsematrix d2t_singular/random_lib.doc:176 
LIB "random.lib";
ring r = 0,(a,b,c,d),dp;
// sparse matrix of sparse polys of degree <=2:
print(sparsematrix(3,4,2));"";
@expansion{} 14ab+20bc+79cd+30b,    32a2+97bc+5b,      0,             0,
@expansion{} 0,                     0,                 6c2+16b+64c+76,0,
@expansion{} 17a2+30ab+94bc+19b+45d,88a2+44bc+13d2+31a,59ac,          0 
@expansion{} 
// dense matrix of sparse linear forms:
print(sparsematrix(3,3,1,1,0,55,9));
@expansion{} 9b+7c+8d,9b+9d,5a,   
@expansion{} 7c+d,    a+6b, 2b+2d,
@expansion{} 9a+5b+9c,2a+9d,2d    
@c end example sparsematrix d2t_singular/random_lib.doc:176
@end smallexample
@c ---end content sparsematrix---

@c ------------------- sparsemat -------------
@node sparsemat, sparsepoly, sparsematrix, random_lib
@subsubsection sparsemat
@cindex sparsemat
@c ---content sparsemat---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
sparsemat(n,m[,p,b]); n,m,p,b integers

@item @strong{Return:}
nxm integer matrix, p percent of the entries are 0, the remaining
are random coefficients >=1 and <= b; [defaults: (p,b) = (75,1)]

@end table
@strong{Example:}
@smallexample
@c computed example sparsemat d2t_singular/random_lib.doc:205 
LIB "random.lib";
sparsemat(5,5);"";
@expansion{} 0,0,0,0,0,
@expansion{} 0,1,0,0,1,
@expansion{} 0,0,0,1,0,
@expansion{} 0,1,0,0,0,
@expansion{} 0,1,0,1,1 
@expansion{} 
sparsemat(5,5,95);"";
@expansion{} 1,0,0,0,0,
@expansion{} 0,0,0,0,0,
@expansion{} 0,0,0,0,0,
@expansion{} 0,0,0,0,0,
@expansion{} 0,0,0,1,0 
@expansion{} 
sparsemat(5,5,5);"";
@expansion{} 1,1,1,1,1,
@expansion{} 1,1,1,1,1,
@expansion{} 1,1,1,1,1,
@expansion{} 1,0,1,1,1,
@expansion{} 1,1,1,1,0 
@expansion{} 
sparsemat(5,5,50,100);
@expansion{} 0,17,24,80,0,
@expansion{} 0,13,30,45,0,
@expansion{} 19,0,0,0,0,
@expansion{} 93,0,23,0,69,
@expansion{} 0,88,44,31,0 
@c end example sparsemat d2t_singular/random_lib.doc:205
@end smallexample
@c ---end content sparsemat---

@c ------------------- sparsepoly -------------
@node sparsepoly, sparsetriag, sparsemat, random_lib
@subsubsection sparsepoly
@cindex sparsepoly
@c ---content sparsepoly---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
sparsepoly(u[,o,p,b]); u,o,p,b integers

@item @strong{Return:}
poly having only terms in degree d, u<=d<=o, p percent of the terms
in degree d are 0, the remaining have random coefficients in [1,b),
(defaults: o=u=d, p=75, b=30000)

@end table
@strong{Example:}
@smallexample
@c computed example sparsepoly d2t_singular/random_lib.doc:234 
LIB "random.lib";
ring r=0,(x,y,z),dp;
sparsepoly(5);"";
@expansion{} 24263xy4+24170x4z+21962x3yz+26642xy3z+5664xy2z2+17904xz4
@expansion{} 
sparsepoly(3,5,90,9);
@expansion{} 8x3z2+2y3z2+3xyz3+2xy3+yz3+xy2
@c end example sparsepoly d2t_singular/random_lib.doc:234
@end smallexample
@c ---end content sparsepoly---

@c ------------------- sparsetriag -------------
@node sparsetriag, triagmatrix, sparsepoly, random_lib
@subsubsection sparsetriag
@cindex sparsetriag
@c ---content sparsetriag---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
sparsetriag(n,m[,p,b]); n,m,p,b integers

@item @strong{Return:}
nxm lower triagonal integer matrix, diagonal entries equal to 1, about
p percent of lower diagonal entries are 0, the remaining are random
integers >=1 and <= b; [defaults: (p,b) = (75,1)]

@end table
@strong{Example:}
@smallexample
@c computed example sparsetriag d2t_singular/random_lib.doc:262 
LIB "random.lib";
sparsetriag(5,7);"";
@expansion{} 1,0,0,0,0,0,0,
@expansion{} 0,1,0,0,0,0,0,
@expansion{} 0,1,1,0,0,0,0,
@expansion{} 0,0,0,1,0,0,0,
@expansion{} 1,1,0,0,1,0,0 
@expansion{} 
sparsetriag(7,5,90);"";
@expansion{} 1,0,0,0,0,
@expansion{} 0,1,0,0,0,
@expansion{} 0,1,1,0,0,
@expansion{} 0,0,0,1,0,
@expansion{} 0,0,0,0,1,
@expansion{} 0,0,0,1,0,
@expansion{} 0,1,0,0,0 
@expansion{} 
sparsetriag(5,5,0);"";
@expansion{} 1,0,0,0,0,
@expansion{} 1,1,0,0,0,
@expansion{} 1,1,1,0,0,
@expansion{} 1,1,1,1,0,
@expansion{} 1,1,1,1,1 
@expansion{} 
sparsetriag(5,5,50,100);
@expansion{} 1,0,0,0,0,
@expansion{} 73,1,0,0,0,
@expansion{} 0,79,1,0,0,
@expansion{} 14,0,0,1,0,
@expansion{} 0,48,23,0,1 
@c end example sparsetriag d2t_singular/random_lib.doc:262
@end smallexample
@c ---end content sparsetriag---

@c ------------------- triagmatrix -------------
@node triagmatrix, randomLast, sparsetriag, random_lib
@subsubsection triagmatrix
@cindex triagmatrix
@c ---content triagmatrix---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
triagmatrix(n,m,o[,u,pe,pp,b]); n,m,o,u,pe,pp,b integers

@item @strong{Return:}
nxm lower triagonal matrix, diagonal entries equal to 1, about
p percent of lower diagonal entries are 0, the remaining
are random polynomials of degree d, u<=d<=o, with pp percent of
the terms being 0, the remaining have random coefficients
in the interval [1,b] [default: (pe,u,pp,b) = (0,50,75,100)]

@end table
@strong{Example:}
@smallexample
@c computed example triagmatrix d2t_singular/random_lib.doc:293 
LIB "random.lib";
ring r = 0,(a,b,c,d),dp;
// sparse triagonal matrix of sparse polys of degree <=2:
print(triagmatrix(3,4,2));"";
@expansion{} 1,                                 0,0,0,
@expansion{} 52ac+54cd+14c,                     1,0,0,
@expansion{} 17a2+19b2+45ac+94bc+50b+87c+54d+21,0,1,0 
@expansion{} 
// dense triagonal matrix of sparse linear forms:
print(triagmatrix(3,3,1,1,0,55,9));
@expansion{} 1,       0,    0,
@expansion{} 7a+8d,   1,    0,
@expansion{} 9b+7c+4d,7b+9d,1 
@c end example triagmatrix d2t_singular/random_lib.doc:293
@end smallexample
@c ---end content triagmatrix---

@c ------------------- randomLast -------------
@node randomLast, randomBinomial, triagmatrix, random_lib
@subsubsection randomLast
@cindex randomLast
@c ---content randomLast---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
randomLast(b); b int

@item @strong{Return:}
ideal = maxideal(1), but the last variable is exchanged by a random
linear combination of all variables, with coefficients in the
interval [-b,b].

@end table
@strong{Example:}
@smallexample
@c computed example randomLast d2t_singular/random_lib.doc:323 
LIB "random.lib";
ring  r = 0,(x,y,z),lp;
ideal i = randomLast(10);
i;
@expansion{} i[1]=x
@expansion{} i[2]=y
@expansion{} i[3]=-x+z
@c end example randomLast d2t_singular/random_lib.doc:323
@end smallexample
@c ---end content randomLast---

@c ------------------- randomBinomial -------------
@node randomBinomial,, randomLast, random_lib
@subsubsection randomBinomial
@cindex randomBinomial
@c ---content randomBinomial---
Procedure from library @code{random.lib} (@pxref{random_lib}).

@table @asis
@item @strong{Usage:}
randomBinomial(k,u[,o,b]); k,u,o,b integers

@item @strong{Return:}
binomial ideal, k homogeneous generators of degree d, u<=d<=o, with
randomly chosen monomials and coefficients in the interval [-b,b]
(default: u=o, b=10).

@end table
@strong{Example:}
@smallexample
@c computed example randomBinomial d2t_singular/random_lib.doc:351 
LIB "random.lib";
ring  r = 0,(x,y,z),lp;
ideal i = randomBinomial(4,5,6);
i;
@expansion{} i[1]=-x4z-xz4
@expansion{} i[2]=8x2y3+8xy3z
@expansion{} i[3]=-4x2y2z2-4xy5
@expansion{} i[4]=5x3yz2+5xz5
@c end example randomBinomial d2t_singular/random_lib.doc:351
@end smallexample
@c ---end content randomBinomial---
@c ----------------------------------------------------------
@node ring_lib, , random_lib, General purpose
@subsection ring_lib
@c include of docu for ring.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/ring_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/ring_lib.doc INSTEAD
@c library version: (1.17.2.1,2002/02/20)
@c library file: ../Singular/LIB/ring.lib
@cindex ring.lib
@cindex ring_lib
@table @asis
@item @strong{Library:}
ring.lib
@item @strong{Purpose:}
      Manipulating Rings and Maps

@end table

@strong{Procedures:}
@menu
* changechar:: make a copy R of basering [ring r] with new char c
* changeord:: make a copy R of basering [ring r] with new ord o
* changevar:: make a copy R of basering [ring r] with new vars v
* defring:: define a ring R in specified char c, n vars v, ord o
* defrings:: define ring Sn in n vars, char 32003 [p], ord ds
* defringp:: define ring Pn in n vars, char 32003 [p], ord dp
* extendring:: extend given ring by n vars v, ord o and name it R
* fetchall:: fetch all objects of ring R to basering
* imapall:: imap all objects of ring R to basering
* mapall:: map all objects of ring R via ideal i to basering
* ord_test:: test whether ordering of R is global, local or mixed
* ringtensor:: create ring R, tensor product of rings s,t,...
* ringweights:: intvec of weights of ring variables of ring r
@end menu
@c ---end content LibInfo---

@c ------------------- changechar -------------
@node changechar, changeord,, ring_lib
@subsubsection changechar
@cindex changechar
@c ---content changechar---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
changechar(newr,c[,r]); newr,c=strings, r=ring

@item @strong{Create:}
create a new ring with name `newr` and make it the basering if r is
an existing ring [default: r=basering].
@*The new ring differs from the old ring only in the characteristic.
If, say, (newr,c) = ("R","0,A") and the ring r exists, the new
basering will have name R, characteristic 0 and one parameter A.

@item @strong{Return:}
No return value

@item @strong{Note:}
Works for qrings if map from old_char to new_char is implemented
This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@.

@end table
@strong{Example:}
@smallexample
@c computed example changechar d2t_singular/ring_lib.doc:62 
LIB "ring.lib";
ring r=0,(x,y,u,v),(dp(2),ds);
changechar("R","2,A"); R;"";
@expansion{} // basering is now R
@expansion{} //   characteristic : 2
@expansion{} //   1 parameter    : A 
@expansion{} //   minpoly        : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering ds
@expansion{} //                  : names    u v 
@expansion{} //        block   3 : ordering C
@expansion{} 
changechar("R1","32003",R); R1;
@expansion{} // basering is now R1
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering ds
@expansion{} //                  : names    u v 
@expansion{} //        block   3 : ordering C
kill R,R1;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R,Top::R1;
@} else @{
kill Ring::R,Ring::R1;
@}
@}
@c end example changechar d2t_singular/ring_lib.doc:62
@end smallexample
@c ---end content changechar---

@c ------------------- changeord -------------
@node changeord, changevar, changechar, ring_lib
@subsubsection changeord
@cindex changeord
@c ---content changeord---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
changeord(newr,o[,r]); newr,o=strings, r=ring/qring

@item @strong{Create:}
create a new ring with name `newr` and make it the basering if r is
an existing ring/qring [default: r=basering].
@*The new ring differs from the old ring only in the ordering. If, say,
(newr,o) = ("R","wp(2,3),dp") and the ring r exists and has >=3
variables, the new basering will have name R and ordering wp(2,3),dp.

@item @strong{Return:}
No return value

@item @strong{Note:}
This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@.

@end table
@strong{Example:}
@smallexample
@c computed example changeord d2t_singular/ring_lib.doc:108 
LIB "ring.lib";
ring r=0,(x,y,u,v),(dp(2),ds);
changeord("R","wp(2,3),dp"); R; "";
@expansion{} // basering is now R
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering wp
@expansion{} //                  : names    x y 
@expansion{} //                  : weights  2 3 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    u v 
@expansion{} //        block   3 : ordering C
@expansion{} 
ideal i = x^2,y^2-u^3,v;
qring Q = std(i);
changeord("Q'","lp",Q); Q';
@expansion{} // basering is now Q'
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering lp
@expansion{} //                  : names    x y u v 
@expansion{} //        block   2 : ordering C
@expansion{} // quotient ring from ideal
@expansion{} _[1]=v
@expansion{} _[2]=x2
@expansion{} _[3]=y2-u3
kill R,Q,Q';
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R,Top::Q';
@} else @{
kill Ring::R,Ring::Q';
@}
@}
@c end example changeord d2t_singular/ring_lib.doc:108
@end smallexample
@c ---end content changeord---

@c ------------------- changevar -------------
@node changevar, defring, changeord, ring_lib
@subsubsection changevar
@cindex changevar
@c ---content changevar---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
changevar(newr,vars[,r]); newr,vars=strings, r=ring/qring

@item @strong{Create:}
creates a new ring with name `newr` and makes it the basering if r
is an existing ring/qring [default: r=basering].
@*The new ring differs from the old ring only in the variables. If,
say, (newr,vars) = ("R","t()") and the ring r exists and has n
variables, the new basering will have name R and variables
t(1),...,t(n).
@*If vars = "a,b,c,d", the new ring will have the variables a,b,c,d.

@item @strong{Return:}
No return value

@item @strong{Note:}
This procedure is useful in connection with the procedure ringtensor,
when a conflict between variable names must be avoided.
This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@.

@end table
@strong{Example:}
@smallexample
@c computed example changevar d2t_singular/ring_lib.doc:160 
LIB "ring.lib";
ring r=0,(x,y,u,v),(dp(2),ds);
ideal i = x^2,y^2-u^3,v;
qring Q = std(i);
setring(r);
changevar("R","A()"); R; "";
@expansion{} // basering is now R
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    A(1) A(2) 
@expansion{} //        block   2 : ordering ds
@expansion{} //                  : names    A(3) A(4) 
@expansion{} //        block   3 : ordering C
@expansion{} 
changevar("Q'","a,b,c,d",Q); Q';
@expansion{} // basering is now Q'
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    a b 
@expansion{} //        block   2 : ordering ds
@expansion{} //                  : names    c d 
@expansion{} //        block   3 : ordering C
@expansion{} // quotient ring from ideal
@expansion{} _[1]=d
@expansion{} _[2]=a2
@expansion{} _[3]=b2-c3
kill R,Q,Q';
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R,Top::Q';
@} else @{
kill Ring::R,Ring::Q';
@}
@}
@c end example changevar d2t_singular/ring_lib.doc:160
@end smallexample
@c ---end content changevar---

@c ------------------- defring -------------
@node defring, defrings, changevar, ring_lib
@subsubsection defring
@cindex defring
@c ---content defring---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
defring(s1,s2,n,s3,s4); s1..s4=strings, n=integer

@item @strong{Create:}
Define a ring with name 's1', characteristic 's2', ordering 's4' and
n variables with names derived from s3 and make it the basering.
If s3 is a single letter, say s3="a", and if n<=26 then a and the
following n-1 letters from the alphabet (cyclic order) are taken as
variables. If n>26 or if s3 is a single letter followed by (, say
s3="T(", the variables are T(1),...,T(n).

@item @strong{Return:}
No return value

@item @strong{Note:}
This proc is useful for defining a ring in a procedure.
This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@.

@end table
@strong{Example:}
@smallexample
@c computed example defring d2t_singular/ring_lib.doc:211 
LIB "ring.lib";
defring("r","0",5,"u","ls"); r; "";
@expansion{} // basering is now: r
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering ls
@expansion{} //                  : names    u v w x y 
@expansion{} //        block   2 : ordering C
@expansion{} 
defring("R","2,A",10,"x(","dp(3),ws(1,2,3),ds"); R;
@expansion{} // basering is now: R
@expansion{} //   characteristic : 2
@expansion{} //   1 parameter    : A 
@expansion{} //   minpoly        : 0
@expansion{} //   number of vars : 10
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x(1) x(2) x(3) 
@expansion{} //        block   2 : ordering ws
@expansion{} //                  : names    x(4) x(5) x(6) 
@expansion{} //                  : weights     1    2    3 
@expansion{} //        block   3 : ordering ds
@expansion{} //                  : names    x(7) x(8) x(9) x(10) 
@expansion{} //        block   4 : ordering C
kill r,R;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::r,Top::R;
@} else @{
kill Ring::r,Ring::R;
@}
@}
@c end example defring d2t_singular/ring_lib.doc:211
@end smallexample
@c ---end content defring---

@c ------------------- defrings -------------
@node defrings, defringp, defring, ring_lib
@subsubsection defrings
@cindex defrings
@c ---content defrings---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
defrings(n,[p]); n,p integers

@item @strong{Create:}
Defines a ring with name Sn, characteristic p, ordering ds and n
variables x,y,z,a,b,...if n<=26 (resp. x(1..n) if n>26) and makes it
the basering (default: p=32003)

@item @strong{Return:}
No return value

@end table
@strong{Example:}
@smallexample
@c computed example defrings d2t_singular/ring_lib.doc:249 
LIB "ring.lib";
defrings(5,0); S5; "";
@expansion{} // basering is now: ring S5=0,(x,y,z,a,b),ds;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering ds
@expansion{} //                  : names    x y z a b 
@expansion{} //        block   2 : ordering C
@expansion{} 
defrings(30); S30;
@expansion{} // basering is now: ring S30=32003,x(1..30),ds;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 30
@expansion{} //        block   1 : ordering ds
@expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(\
   9) x(10) x(11) x(12) x(13) x(14) x(15) x(16) x(17) x(18) x(19) x(20) x(21\
   ) x(22) x(23) x(24) x(25) x(26) x(27) x(28) x(29) x(30) 
@expansion{} //        block   2 : ordering C
kill S5, S30;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::S5,Top::S30;
@} else @{
kill Ring::S5,Ring::S30;
@}
@}
@c end example defrings d2t_singular/ring_lib.doc:249
@end smallexample
@c ---end content defrings---

@c ------------------- defringp -------------
@node defringp, extendring, defrings, ring_lib
@subsubsection defringp
@cindex defringp
@c ---content defringp---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
defringp(n,[p]); n,p=integers

@item @strong{Create:}
defines a ring with name Pn, characteristic p, ordering dp and n
variables x,y,z,a,b,...if n<=26 (resp. x(1..n) if n>26) and makes it
the basering (default: p=32003)

@item @strong{Return:}
No return value

@end table
@strong{Example:}
@smallexample
@c computed example defringp d2t_singular/ring_lib.doc:287 
LIB "ring.lib";
defringp(5,0); P5; "";
@expansion{} // basering is now: ring P5=0,(x,y,z,a,b),dp;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y z a b 
@expansion{} //        block   2 : ordering C
@expansion{} 
defringp(30); P30;
@expansion{} // basering is now: ring P30=32003,x(1..30),dp;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 30
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) x(6) x(7) x(8) x(\
   9) x(10) x(11) x(12) x(13) x(14) x(15) x(16) x(17) x(18) x(19) x(20) x(21\
   ) x(22) x(23) x(24) x(25) x(26) x(27) x(28) x(29) x(30) 
@expansion{} //        block   2 : ordering C
kill P5, P30;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::P5,Top::P30;
@} else @{
kill Ring::P5,Ring::P30;
@}
@}
@c end example defringp d2t_singular/ring_lib.doc:287
@end smallexample
@c ---end content defringp---

@c ------------------- extendring -------------
@node extendring, fetchall, defringp, ring_lib
@subsubsection extendring
@cindex extendring
@c ---content extendring---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
extendring(na,n,va,o[iv,i,r]); na,va,o=strings,
@*n,i=integers, r=ring, iv=intvec of positive integers or iv=0

@item @strong{Create:}
Define a ring with name `na` which extends the ring r by adding n new
variables in front of [after, if i!=0] the old variables and make it
the basering [default: (i,r)=(0,basering)].
@* -- The characteristic is the characteristic of r.
@* -- The new vars are derived from va. If va is a single letter, say
va="T", and if n<=26 then T and the following n-1 letters from
T..Z..T (resp. T(1..n) if n>26) are taken as additional variables.
If va is a single letter followed by (, say va="x(", the new
variables are x(1),...,x(n).
@* -- The ordering is the product ordering between the ordering of r and
an ordering derived from `o` [and iv].
@* - If o contains a 'c' or a 'C' in front resp. at the end this is
taken for the whole ordering in front resp. at the end. If o does
not contain a 'c' or a 'C' the same rule applies to ordstr(r).
@* - If no intvec iv is given, or if iv=0, o may be any allowed ordstr,
like "ds" or "dp(2),wp(1,2,3),Ds(2)" or "ds(a),dp(b),ls" if
a and b are globally (!) defined integers and if a+b+1<=n.
If, however, a and b are local to a proc calling extendring, the
intvec iv must be used to let extendring know the values of a and b
@* - If an intvec iv !=0 is given, iv[1],iv[2],... is taken for the
1st, 2nd,... block of o, if o contains no substring "w" or "W"
i.e. no weighted ordering (in the above case o="ds,dp,ls"
and iv=a,b).
@*If o contains a weighted ordering (only one (!) weighted block is
allowed) iv[1] is taken as size for the weight-vector, the next
iv[1] values of iv are taken as weights and the remaining values of
iv as block-size for the remaining non-weighted blocks.
e.g. o="dp,ws,Dp,ds", iv=3,2,3,4,2,5 creates the ordering
dp(2),ws(2,3,4),Dp(5),ds

@item @strong{Return:}
No return value

@item @strong{Note:}
This proc is useful for adding deformation parameters.
@*This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@ (see the file HelpForProc)

@end table
@strong{Example:}
@smallexample
@c computed example extendring d2t_singular/ring_lib.doc:358 
LIB "ring.lib";
ring r=0,(x,y,z),ds;
show(r);"";
@expansion{} // ring: (0),(x,y,z),(ds(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} 
//blocksize is derived from no of vars:
int t=5;
extendring("R1",t,"a","dp");         //t global: "dp" -> "dp(5)"
@expansion{} // basering is now R1
show(R1); "";
@expansion{} // ring: (0),(a,b,c,d,e,x,y,z),(dp(5),ds(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} 
extendring("R2",4,"T(","c,dp",1,r);    //"dp" -> "c,..,dp(4)"
@expansion{} // basering is now R2
show(R2);"";
@expansion{} // ring: (0),(x,y,z,T(1),T(2),T(3),T(4)),(c,ds(3),dp(4));
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} 
//no intvec given, blocksize given: given blocksize is used:
extendring("R3",4,"T(","dp(2)",0,r);   // "dp(2)" -> "dp(2)"
@expansion{} // basering is now R3
show(R3);"";
@expansion{} // ring: (0),(T(1),T(2),T(3),T(4),x,y,z),(dp(2),ds(5),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} 
//intvec given: weights and blocksize is derived from given intvec
//(no specification of a blocksize in the given ordstr is allowed!)
//if intvec does not cover all given blocks, the last block is used
//for the remaining variables, if intvec has too many components,
//the last ones are ignored
intvec v=3,2,3,4,1,3;
extendring("R4",10,"A","ds,ws,Dp,dp",v,0,r);
@expansion{} // basering is now R4
//v covers 3 blocks: v[1] (=3) : no of components of ws
//next v[1] values (=v[2..4]) give weights
//remaining components of v are used for the remaining blocks
show(R4);
@expansion{} // ring: (0),(A,B,C,D,E,F,G,H,I,J,x,y,z),(ds(1),ws(2,3,4),Dp(3),dp(3),ds(\
   3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
kill r,R1,R2,R3,R4;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R1,Top::R2,Top::R3,Top::R4;
@} else @{
kill Ring::R1,Ring::R2,Ring::R3,Ring::R4;
@}
@}
@c end example extendring d2t_singular/ring_lib.doc:358
@end smallexample
@c ---end content extendring---

@c ------------------- fetchall -------------
@node fetchall, imapall, extendring, ring_lib
@subsubsection fetchall
@cindex fetchall
@c ---content fetchall---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
fetchall(R[,s]); R=ring/qring, s=string

@item @strong{Create:}
fetch all objects of ring R (of type poly/ideal/vector/module/number/
matrix) into the basering.
@*If no 3rd argument is present, the names are the same as in R. If,
say, f is a poly in R and the 3rd argument is the string "R", then f
is mapped to f_R etc.

@item @strong{Return:}
no return value

@item @strong{Note:}
As fetch, this procedure maps the 1st, 2nd, ... variable of R to the
1st, 2nd, ... variable of the basering.
@*The 3rd argument is useful in order to avoid conflicts of names, the
empty string is allowed

@item @strong{Caution:}
fetchall does not work inside a procedure.
@*It does not work if R contains a map.

@end table
@strong{Example:}
@smallexample
@c computed example fetchall d2t_singular/ring_lib.doc:428 
LIB "ring.lib";
// The example is not shown since fetchall does not work in a procedure;
// (and hence not in the example procedure). Try the following commands:
//   ring R=0,(x,y,z),dp;
//   ideal j=x,y2,z2;
//   matrix M[2][3]=1,2,3,x,y,z;
//   j; print(M);
//   ring S=0,(a,b,c),ds;
//   fetchall(R);       //map from R to S: x->a, y->b, z->c;
//   names(S);
//   j; print(M);
//   fetchall(S,"1");   //identity map of S: copy objects, change names
//   names(S);
//   kill R,S;
@c end example fetchall d2t_singular/ring_lib.doc:428
@end smallexample
@c ---end content fetchall---

@c ------------------- imapall -------------
@node imapall, mapall, fetchall, ring_lib
@subsubsection imapall
@cindex imapall
@c ---content imapall---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
imapall(R[,s]); R=ring/qring, s=string

@item @strong{Create:}
map all objects of ring R (of type poly/ideal/vector/module/number/
matrix) into the basering, by applying imap to all objects of R.
If no 3rd argument is present, the names are the same as in R. If,
say, f is a poly in R and the 3rd argument is the string "R", then f
is mapped to f_R etc.

@item @strong{Return:}
no return value

@item @strong{Note:}
As imap, this procedure maps the variables of R to the variables with
the same name in the basering, the other variables are mapped to 0.
The 3rd argument is useful in order to avoid conflicts of names, the
empty string is allowed

@item @strong{Caution:}
imapall does not work inside a procedure
@*It does not work if R contains a map

@end table
@strong{Example:}
@smallexample
@c computed example imapall d2t_singular/ring_lib.doc:481 
LIB "ring.lib";
// The example is not shown since imapall does not work in a procedure
// (and hence not in the example procedure). Try the following commands:
//   ring R=0,(x,y,z,u),dp;
//   ideal j=x,y,z,u2+ux+z;
//   matrix M[2][3]=1,2,3,x,y,uz;
//   j; print(M);
//   ring S=0,(a,b,c,x,z,y),ds;
//   imapall(R);         //map from R to S: x->x, y->y, z->z, u->0
//   names(S);
//   j; print(M);
//   imapall(S,"1");     //identity map of S: copy objects, change names
//   names(S);
//   kill R,S;
@c end example imapall d2t_singular/ring_lib.doc:481
@end smallexample
@c ---end content imapall---

@c ------------------- mapall -------------
@node mapall, ord_test, imapall, ring_lib
@subsubsection mapall
@cindex mapall
@c ---content mapall---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
mapall(R,i[,s]); R=ring/qring, i=ideal of basering, s=string

@item @strong{Create:}
map all objects of ring R (of type poly/ideal/vector/module/number/
matrix, map) into the basering, by mapping the j-th variable of R to
the j-th generator of the ideal i. If no 3rd argument is present, the
names are the same as in R. If, say, f is a poly in R and the 3rd
argument is the string "R", then f is mapped to f_R etc.

@item @strong{Return:}
no return value.

@item @strong{Note:}
This procedure has the same effect as defining a map, say psi, by
map psi=R,i; and then applying psi to all objects of R. In particular,
maps from R to some ring S are composed with psi, creating thus a map
from the basering to S.
@*mapall may be combined with copyring to change vars for all objects.
The 3rd argument is useful in order to avoid conflicts of names, the
empty string is allowed.

@item @strong{Caution:}
mapall does not work inside a procedure.

@end table
@strong{Example:}
@smallexample
@c computed example mapall d2t_singular/ring_lib.doc:536 
LIB "ring.lib";
// The example is not shown since mapall does not work in a procedure
// (and hence not in the example procedure). Try the following commands:
//   ring R=0,(x,y,z),dp;
//   ideal j=x,y,z;
//   matrix M[2][3]=1,2,3,x,y,z;
//   map phi=R,x2,y2,z2;
//   ring S=0,(a,b,c),ds;
//   ideal i=c,a,b;
//   mapall(R,i);         //map from R to S: x->c, y->a, z->b
//   names(S);
//   j; print(M); phi;    //phi maps R to S: x->c2, y->a2, z->b2
//   ideal i1=a2,a+b,1;
//   mapall(R,i1,"");   //map from R to S: x->a2, y->a+b, z->1
//   names(S);
//   j_; print(M_); phi_;
//   changevar("T","x()",R);  //change vars in R and call result T
//   mapall(R,maxideal(1));       //identity map from R to T
//   names(T);
//   j; print(M); phi;
//   kill R,S,T;
@c end example mapall d2t_singular/ring_lib.doc:536
@end smallexample
@c ---end content mapall---

@c ------------------- ord_test -------------
@node ord_test, ringtensor, mapall, ring_lib
@subsubsection ord_test
@cindex ord_test
@c ---content ord_test---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
ord_test(r); r ring

@item @strong{Return:}
int 1 (resp. -1, resp. 0) if ordering of r is global (resp. local,
resp. mixed)

@end table
@strong{Example:}
@smallexample
@c computed example ord_test d2t_singular/ring_lib.doc:580 
LIB "ring.lib";
ring R = 0,(x,y),dp;
ring S = 0,(u,v),ls;
ord_test(R);
@expansion{} 1
ord_test(S);
@expansion{} -1
ord_test(R+S);
@expansion{} 0
@c end example ord_test d2t_singular/ring_lib.doc:580
@end smallexample
@c ---end content ord_test---

@c ------------------- ringtensor -------------
@node ringtensor, ringweights, ord_test, ring_lib
@subsubsection ringtensor
@cindex ringtensor
@c ---content ringtensor---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
ringtensor(s,r1,r2,...); s=string, r1,r2,...=rings

@item @strong{Create:}
A new base ring with name `s` if r1,r2,... are existing rings.
If, say, s = "R" and the rings r1,r2,... exist, the new ring will
have name R, variables from all rings r1,r2,... and as monomial
ordering the block (product) ordering of r1,r2,... . Hence, R
is the tensor product of the rings r1,r2,... with ordering matrix
equal to the direct sum of the ordering matrices of r1,r2,...

@item @strong{Return:}
no return value

@item @strong{Note:}
The characteristic of the new ring will be that of r1. The names of
variables in the rings r1,r2,... should differ (if a name, say x,
occurs in r1 and r2, then, in the new ring r, x always refers to the
variable with name x in r1, there is no access to x in r2).
The procedure works also for quotient rings ri, if the characteristic
of ri is compatible with the characteristic of r1 (i.e. if imap from
ri to r1 is implemented)
@*This proc uses 'execute' or calls a procedure using 'execute'.
If you use it in your own proc, let the local names of your proc
start with @@ (see the file HelpForProc)

@end table
@strong{Example:}
@smallexample
@c computed example ringtensor d2t_singular/ring_lib.doc:628 
LIB "ring.lib";
ring r=32003,(x,y,u,v),dp;
ring s=0,(a,b,c),wp(1,2,3);
ring t=0,x(1..5),(c,ls);
ringtensor("R",r,s,t);
@expansion{} // basering is now R
type R;
@expansion{} // R                    [0]  *ring
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 12
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y u v 
@expansion{} //        block   2 : ordering wp
@expansion{} //                  : names    a b c 
@expansion{} //                  : weights  1 2 3 
@expansion{} //        block   3 : ordering ls
@expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) 
@expansion{} //        block   4 : ordering C
setring s;
ideal i = a2+b3+c5;
changevar("S","x,y,z");       //change vars of sand make S the basering
@expansion{} // basering is now S
qring qS =std(fetch(s,i));    //create qring of S mod i (mapped to S)
changevar("T","d,e,f,g,h",t); //change vars of t and make T the basering
@expansion{} // basering is now T
qring qT=std(d2+e2-f3);       //create qring of T mod d2+e2-f3
ringtensor("Q",s,qS,t,qT);
@expansion{} // basering is now Q
type Q;
@expansion{} // Q                    [0]  *qring
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 16
@expansion{} //        block   1 : ordering wp
@expansion{} //                  : names    a b c 
@expansion{} //                  : weights  1 2 3 
@expansion{} //        block   2 : ordering wp
@expansion{} //                  : names    x y z 
@expansion{} //                  : weights  1 2 3 
@expansion{} //        block   3 : ordering ls
@expansion{} //                  : names    x(1) x(2) x(3) x(4) x(5) 
@expansion{} //        block   4 : ordering ls
@expansion{} //                  : names    d e f g h 
@expansion{} //        block   5 : ordering C
@expansion{} // quotient ring from ideal
@expansion{} _[1]=f3-e2-d2
@expansion{} _[2]=z5+y3+x2
kill R,Q,S,T;
if(system("with","Namespaces")) @{
if( nameof(Current) == "Ring" ) @{
kill Top::R,Top::Q,Top::S,Top::T;
@} else @{
kill Ring::R,Ring::Q,Ring::S,Ring::T;
@}
@}
@c end example ringtensor d2t_singular/ring_lib.doc:628
@end smallexample
@c ---end content ringtensor---

@c ------------------- ringweights -------------
@node ringweights,, ringtensor, ring_lib
@subsubsection ringweights
@cindex ringweights
@c ---content ringweights---
Procedure from library @code{ring.lib} (@pxref{ring_lib}).

@table @asis
@item @strong{Usage:}
ringweights(P); P=name of an existing ring (true name, not a string)

@item @strong{Return:}
intvec consisting of the weights of the variables of P, as they
appear when typing P;.

@item @strong{Note:}
This is useful when enlarging P but keeping the weights of the old
variables.

@end table
@strong{Example:}
@smallexample
@c computed example ringweights d2t_singular/ring_lib.doc:677 
LIB "ring.lib";
ring r0 = 0,(x,y,z),dp;
ringweights(r0);
@expansion{} 1,1,1
ring r1 = 0,x(1..5),(ds(3),wp(2,3));
ringweights(r1);"";
@expansion{} 1,1,1,2,3
@expansion{} 
// an example for enlarging the ring, keeping the first weights:
intvec v = ringweights(r1),6,2,3,4,5;
ring R = 0,x(1..10),(a(v),dp);
ordstr(R);
@expansion{} a(1,1,1,2,3,6,2,3,4,5),dp(10),C
@c end example ringweights d2t_singular/ring_lib.doc:677
@end smallexample
@c ---end content ringweights---
@c ----------------------------------------------------------------------------
@node Linear algebra, Commutative algebra, General purpose, SINGULAR libraries
@section Linear algebra
@cindex Linear algebra

@menu
* matrix_lib:: procedures for matrix operations
* linalg_lib:: procedures for algorithmic linear algebra
@end menu

@c ----------------------------------------------------------
@node matrix_lib, linalg_lib,  Linear algebra, Linear algebra
@subsection matrix_lib
@c include of docu for matrix.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/matrix_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/matrix_lib.doc INSTEAD
@c library version: (1.26.2.3,2003/05/14)
@c library file: ../Singular/LIB/matrix.lib
@cindex matrix.lib
@cindex matrix_lib
@table @asis
@item @strong{Library:}
matrix.lib
@item @strong{Purpose:}
    Elementary Matrix Operations

@end table

@strong{Procedures:}
@menu
* compress:: matrix, zero columns from A deleted
* concat:: matrix, concatenation of matrices A1,A2,...
* diag:: matrix, nxn diagonal matrix with entries poly p
* dsum:: matrix, direct sum of matrices A1,A2,...
* flatten:: ideal, generated by entries of matrix A
* genericmat:: generic nxm matrix [entries from id]
* is_complex:: 1 if list c is a complex, 0 if not
* outer:: matrix, outer product of matrices A and B
* power:: matrix/intmat, n-th power of matrix/intmat A
* skewmat:: generic skew-symmetric nxn matrix [entries from id]
* submat:: submatrix of A with rows/cols specified by intvec r/c
* symmat:: generic symmetric nxn matrix [entries from id]
* tensor:: matrix, tensor product of matrices A nd B
* unitmat:: unit square matrix of size n
* gauss_col:: transform a matrix into col-reduced Gauss normal form
* gauss_row:: transform a matrix into row-reduced Gauss normal form
* addcol:: add p*(c1-th col) to c2-th column of matrix A, p poly
* addrow:: add p*(r1-th row) to r2-th row of matrix A, p poly
* multcol:: multiply c-th column of A with poly p
* multrow:: multiply r-th row of A with poly p
* permcol:: permute i-th and j-th columns
* permrow:: permute i-th and j-th rows
* rowred:: reduction of matrix A with elementary row-operations
* colred:: reduction of matrix A with elementary col-operations
* rm_unitrow:: remove unit rows and associated columns of A
* rm_unitcol:: remove unit columns and associated rows of A
* headStand:: A[n-i+1,m-j+1]=headStand(A[i,j])
@end menu
@c ---end content LibInfo---

@c ------------------- compress -------------
@node compress, concat,, matrix_lib
@subsubsection compress
@cindex compress
@c ---content compress---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
compress(A); A matrix/ideal/module/intmat/intvec

@item @strong{Return:}
same type, zero columns/generators from A deleted
@*(if A=intvec, zero elements are deleted)

@end table
@strong{Example:}
@smallexample
@c reused example compress d2t_singular/matrix_lib.doc:64 
LIB "matrix.lib";
ring r=0,(x,y,z),ds;
matrix A[3][4]=1,0,3,0,x,0,z,0,x2,0,z2,0;
print(A);
@expansion{} 1, 0,3, 0,
@expansion{} x, 0,z, 0,
@expansion{} x2,0,z2,0 
print(compress(A));
@expansion{} 1, 3,
@expansion{} x, z,
@expansion{} x2,z2
module m=module(A); show(m);
@expansion{} // module, 4 generator(s)
@expansion{} [1,x,x2]
@expansion{} [0]
@expansion{} [3,z,z2]
@expansion{} [0]
show(compress(m));
@expansion{} // module, 2 generator(s)
@expansion{} [1,x,x2]
@expansion{} [3,z,z2]
intmat B[3][4]=1,0,3,0,4,0,5,0,6,0,7,0;
compress(B);
@expansion{} 1,3,
@expansion{} 4,5,
@expansion{} 6,7 
intvec C=0,0,1,2,0,3;
compress(C);
@expansion{} 1,2,3
@c end example compress d2t_singular/matrix_lib.doc:64
@end smallexample
@c ---end content compress---

@c ------------------- concat -------------
@node concat, diag, compress, matrix_lib
@subsubsection concat
@cindex concat
@c ---content concat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
concat(A1,A2,..); A1,A2,... matrices

@item @strong{Return:}
matrix, concatenation of A1,A2,.... Number of rows of result matrix
is max(nrows(A1),nrows(A2),...)

@end table
@strong{Example:}
@smallexample
@c reused example concat d2t_singular/matrix_lib.doc:98 
LIB "matrix.lib";
ring r=0,(x,y,z),ds;
matrix A[3][3]=1,2,3,x,y,z,x2,y2,z2;
matrix B[2][2]=1,0,2,0; matrix C[1][4]=4,5,x,y;
print(A);
@expansion{} 1, 2, 3,
@expansion{} x, y, z,
@expansion{} x2,y2,z2
print(B);
@expansion{} 1,0,
@expansion{} 2,0 
print(C);
@expansion{} 4,5,x,y
print(concat(A,B,C));
@expansion{} 1, 2, 3, 1,0,4,5,x,y,
@expansion{} x, y, z, 2,0,0,0,0,0,
@expansion{} x2,y2,z2,0,0,0,0,0,0 
@c end example concat d2t_singular/matrix_lib.doc:98
@end smallexample
@c ---end content concat---

@c ------------------- diag -------------
@node diag, dsum, concat, matrix_lib
@subsubsection diag
@cindex diag
@c ---content diag---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
diag(p,n); p poly, n integer
@*diag(A); A matrix

@item @strong{Return:}
diag(p,n): diagonal matrix, p times unit matrix of size n.
@* diag(A) : n*m x n*m diagonal matrix with entries all the entries of
the nxm matrix A, taken from the 1st row, 2nd row etc of A

@end table
@strong{Example:}
@smallexample
@c reused example diag d2t_singular/matrix_lib.doc:131 
LIB "matrix.lib";
ring r = 0,(x,y,z),ds;
print(diag(xy,4));
@expansion{} xy,0, 0, 0,
@expansion{} 0, xy,0, 0,
@expansion{} 0, 0, xy,0,
@expansion{} 0, 0, 0, xy
matrix A[3][2] = 1,2,3,4,5,6;
print(A);
@expansion{} 1,2,
@expansion{} 3,4,
@expansion{} 5,6 
print(diag(A));
@expansion{} 1,0,0,0,0,0,
@expansion{} 0,2,0,0,0,0,
@expansion{} 0,0,3,0,0,0,
@expansion{} 0,0,0,4,0,0,
@expansion{} 0,0,0,0,5,0,
@expansion{} 0,0,0,0,0,6 
@c end example diag d2t_singular/matrix_lib.doc:131
@end smallexample
@c ---end content diag---

@c ------------------- dsum -------------
@node dsum, flatten, diag, matrix_lib
@subsubsection dsum
@cindex dsum
@c ---content dsum---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
dsum(A1,A2,..); A1,A2,... matrices

@item @strong{Return:}
matrix, direct sum of A1,A2,...

@end table
@strong{Example:}
@smallexample
@c reused example dsum d2t_singular/matrix_lib.doc:159 
LIB "matrix.lib";
ring r = 0,(x,y,z),ds;
matrix A[3][3] = 1,2,3,4,5,6,7,8,9;
matrix B[2][2] = 1,x,y,z;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(B);
@expansion{} 1,x,
@expansion{} y,z 
print(dsum(A,B));
@expansion{} 1,2,3,0,0,
@expansion{} 4,5,6,0,0,
@expansion{} 7,8,9,0,0,
@expansion{} 0,0,0,1,x,
@expansion{} 0,0,0,y,z 
@c end example dsum d2t_singular/matrix_lib.doc:159
@end smallexample
@c ---end content dsum---

@c ------------------- flatten -------------
@node flatten, genericmat, dsum, matrix_lib
@subsubsection flatten
@cindex flatten
@c ---content flatten---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
flatten(A); A matrix

@item @strong{Return:}
ideal, generated by all entries from A

@end table
@strong{Example:}
@smallexample
@c reused example flatten d2t_singular/matrix_lib.doc:188 
LIB "matrix.lib";
ring r = 0,(x,y,z),ds;
matrix A[2][3] = 1,2,x,y,z,7;
print(A);
@expansion{} 1,2,x,
@expansion{} y,z,7 
flatten(A);
@expansion{} _[1]=1
@expansion{} _[2]=2
@expansion{} _[3]=x
@expansion{} _[4]=y
@expansion{} _[5]=z
@expansion{} _[6]=7
@c end example flatten d2t_singular/matrix_lib.doc:188
@end smallexample
@c ---end content flatten---

@c ------------------- genericmat -------------
@node genericmat, is_complex, flatten, matrix_lib
@subsubsection genericmat
@cindex genericmat
@c ---content genericmat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
genericmat(n,m[,id]); n,m=integers, id=ideal

@item @strong{Return:}
nxm matrix, with entries from id.

@item @strong{Note:}
if id has less than nxm elements, the matrix is filled with 0's,
(default: id=maxideal(1)).
@*genericmat(n,m); creates the generic nxm matrix

@end table
@strong{Example:}
@smallexample
@c reused example genericmat d2t_singular/matrix_lib.doc:220 
LIB "matrix.lib";
ring R = 0,x(1..16),lp;
print(genericmat(3,3));      // the generic 3x3 matrix
@expansion{} x(1),x(2),x(3),
@expansion{} x(4),x(5),x(6),
@expansion{} x(7),x(8),x(9) 
ring R1 = 0,(a,b,c,d),dp;
matrix A = genericmat(3,4,maxideal(1)^3);
print(A);
@expansion{} a3, a2b,a2c,a2d,
@expansion{} ab2,abc,abd,ac2,
@expansion{} acd,ad2,b3, b2c 
int n,m = 3,2;
ideal i = ideal(randommat(1,n*m,maxideal(1),9));
print(genericmat(n,m,i));    // matrix of generic linear forms
@expansion{} 4a-8b-2c-3d,-a+b-4c+5d,
@expansion{} -8a-9b+c+7d,a-9b+9c+4d,
@expansion{} 6a-5b+9c,   2a+8c+d    
@c end example genericmat d2t_singular/matrix_lib.doc:220
@end smallexample
@c ---end content genericmat---

@c ------------------- is_complex -------------
@node is_complex, outer, genericmat, matrix_lib
@subsubsection is_complex
@cindex is_complex
@c ---content is_complex---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
is_complex(c); c = list of size-compatible modules or matrices

@item @strong{Return:}
1 if c[i]*c[i+1]=0 for all i, 0 if not, hence checking whether the
list of matrices forms a complex.

@item @strong{Note:}
Ideals are treated internally as 1-line matrices.
@*If printlevel > 0, the position where c is not a complex is shown.

@end table
@strong{Example:}
@smallexample
@c reused example is_complex d2t_singular/matrix_lib.doc:256 
LIB "matrix.lib";
ring r  = 32003,(x,y,z),ds;
ideal i = x4+y5+z6,xyz,yx2+xz2+zy7;
list L  = nres(i,0);
is_complex(L);
@expansion{} 1
L[4]    = matrix(i);
is_complex(L);
@expansion{} 0
@c end example is_complex d2t_singular/matrix_lib.doc:256
@end smallexample
@c ---end content is_complex---

@c ------------------- outer -------------
@node outer, power, is_complex, matrix_lib
@subsubsection outer
@cindex outer
@c ---content outer---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
outer(A,B); A,B matrices

@item @strong{Return:}
matrix, outer (tensor) product of A and B

@end table
@strong{Example:}
@smallexample
@c reused example outer d2t_singular/matrix_lib.doc:285 
LIB "matrix.lib";
ring r=32003,(x,y,z),ds;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix B[2][2]=x,y,0,z;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(B);
@expansion{} x,y,
@expansion{} 0,z 
print(outer(A,B));
@expansion{} x, y, 2x,2y,3x,3y,
@expansion{} 0, z, 0, 2z,0, 3z,
@expansion{} 4x,4y,5x,5y,6x,6y,
@expansion{} 0, 4z,0, 5z,0, 6z,
@expansion{} 7x,7y,8x,8y,9x,9y,
@expansion{} 0, 7z,0, 8z,0, 9z 
@c end example outer d2t_singular/matrix_lib.doc:285
@end smallexample
@c ---end content outer---

@c ------------------- power -------------
@node power, skewmat, outer, matrix_lib
@subsubsection power
@cindex power
@c ---content power---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
power(A,n); A a square-matrix of type intmat or matrix, n=integer

@item @strong{Return:}
intmat resp. matrix, the n-th power of A

@item @strong{Note:}
for A=intmat and big n the result may be wrong because of int overflow

@end table
@strong{Example:}
@smallexample
@c reused example power d2t_singular/matrix_lib.doc:317 
LIB "matrix.lib";
intmat A[3][3]=1,2,3,4,5,6,7,8,9;
print(power(A,3));"";
@expansion{}    468   576   684
@expansion{}   1062  1305  1548
@expansion{}   1656  2034  2412
@expansion{} 
ring r=0,(x,y,z),dp;
matrix B[3][3]=0,x,y,z,0,0,y,z,0;
print(power(B,3));"";
@expansion{} yz2,    xy2+x2z,y3+xyz,
@expansion{} y2z+xz2,yz2,    0,     
@expansion{} y3+xyz, y2z+xz2,yz2    
@expansion{} 
@c end example power d2t_singular/matrix_lib.doc:317
@end smallexample
@c ---end content power---

@c ------------------- skewmat -------------
@node skewmat, submat, power, matrix_lib
@subsubsection skewmat
@cindex skewmat
@c ---content skewmat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
skewmat(n[,id]); n integer, id ideal

@item @strong{Return:}
skew-symmetric nxn matrix, with entries from id
@*(default: id=maxideal(1))
@*skewmat(n); creates the generic skew-symmetric matrix

@item @strong{Note:}
if id has less than n*(n-1)/2 elements, the matrix is
@*filled with 0's,

@end table
@strong{Example:}
@smallexample
@c reused example skewmat d2t_singular/matrix_lib.doc:351 
LIB "matrix.lib";
ring R=0,x(1..5),lp;
print(skewmat(4));    // the generic skew-symmetric matrix
@expansion{} 0,    x(1), x(2),x(3),
@expansion{} -x(1),0,    x(4),x(5),
@expansion{} -x(2),-x(4),0,   0,   
@expansion{} -x(3),-x(5),0,   0    
ring R1 = 0,(a,b,c),dp;
matrix A=skewmat(4,maxideal(1)^2);
print(A);
@expansion{} 0,  a2, ab, ac,
@expansion{} -a2,0,  b2, bc,
@expansion{} -ab,-b2,0,  c2,
@expansion{} -ac,-bc,-c2,0  
int n=3;
ideal i = ideal(randommat(1,n*(n-1) div 2,maxideal(1),9));
print(skewmat(n,i));  // skew matrix of generic linear forms
@expansion{} 0,       4a+b-8c, -a+6b+c,  
@expansion{} -4a-b+8c,0,       -8a+2b-9c,
@expansion{} a-6b-c,  8a-2b+9c,0         
kill R1;
@c end example skewmat d2t_singular/matrix_lib.doc:351
@end smallexample
@c ---end content skewmat---

@c ------------------- submat -------------
@node submat, symmat, skewmat, matrix_lib
@subsubsection submat
@cindex submat
@c ---content submat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
submat(A,r,c); A=matrix, r,c=intvec

@item @strong{Return:}
matrix, submatrix of A with rows specified by intvec r
and columns specified by intvec c.

@end table
@strong{Example:}
@smallexample
@c reused example submat d2t_singular/matrix_lib.doc:384 
LIB "matrix.lib";
ring R=32003,(x,y,z),lp;
matrix A[4][4]=x,y,z,0,1,2,3,4,5,6,7,8,9,x2,y2,z2;
print(A);
@expansion{} x,y, z, 0,
@expansion{} 1,2, 3, 4,
@expansion{} 5,6, 7, 8,
@expansion{} 9,x2,y2,z2
intvec v=1,3,4;
matrix B=submat(A,v,1..3);
print(B);
@expansion{} x,y, z,
@expansion{} 5,6, 7,
@expansion{} 9,x2,y2
@c end example submat d2t_singular/matrix_lib.doc:384
@end smallexample
@c ---end content submat---

@c ------------------- symmat -------------
@node symmat, tensor, submat, matrix_lib
@subsubsection symmat
@cindex symmat
@c ---content symmat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
symmat(n[,id]); n integer, id ideal

@item @strong{Return:}
symmetric nxn matrix, with entries from id (default: id=maxideal(1))

@item @strong{Note:}
if id has less than n*(n+1)/2 elements, the matrix is filled with 0's,
symmat(n); creates the generic symmetric matrix

@end table
@strong{Example:}
@smallexample
@c reused example symmat d2t_singular/matrix_lib.doc:417 
LIB "matrix.lib";
ring R=0,x(1..10),lp;
print(symmat(4));    // the generic symmetric matrix
@expansion{} x(1),x(2),x(3),x(4),
@expansion{} x(2),x(5),x(6),x(7),
@expansion{} x(3),x(6),x(8),x(9),
@expansion{} x(4),x(7),x(9),x(10)
ring R1 = 0,(a,b,c),dp;
matrix A=symmat(4,maxideal(1)^3);
print(A);
@expansion{} a3, a2b,a2c,ab2,
@expansion{} a2b,abc,ac2,b3, 
@expansion{} a2c,ac2,b2c,bc2,
@expansion{} ab2,b3, bc2,c3  
int n=3;
ideal i = ideal(randommat(1,n*(n+1) div 2,maxideal(1),9));
print(symmat(n,i));  // symmetric matrix of generic linear forms
@expansion{} 4a-8b-2c,-a+b-4c, -8a-9b+c,
@expansion{} -a+b-4c, a-9b+9c, 6a-5b+9c,
@expansion{} -8a-9b+c,6a-5b+9c,2a+8c    
kill R1;
@c end example symmat d2t_singular/matrix_lib.doc:417
@end smallexample
@c ---end content symmat---

@c ------------------- tensor -------------
@node tensor, unitmat, symmat, matrix_lib
@subsubsection tensor
@cindex tensor
@c ---content tensor---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
tensor(A,B); A,B matrices

@item @strong{Return:}
matrix, tensor product of A and B

@end table
@strong{Example:}
@smallexample
@c reused example tensor d2t_singular/matrix_lib.doc:449 
LIB "matrix.lib";
ring r=32003,(x,y,z),(c,ds);
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
matrix B[2][2]=x,y,0,z;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(B);
@expansion{} x,y,
@expansion{} 0,z 
print(tensor(A,B));
@expansion{} x, y, 2x,2y,3x,3y,
@expansion{} 0, z, 0, 2z,0, 3z,
@expansion{} 4x,4y,5x,5y,6x,6y,
@expansion{} 0, 4z,0, 5z,0, 6z,
@expansion{} 7x,7y,8x,8y,9x,9y,
@expansion{} 0, 7z,0, 8z,0, 9z 
@c end example tensor d2t_singular/matrix_lib.doc:449
@end smallexample
@c ---end content tensor---

@c ------------------- unitmat -------------
@node unitmat, gauss_col, tensor, matrix_lib
@subsubsection unitmat
@cindex unitmat
@c ---content unitmat---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
unitmat(n); n integer >= 0

@item @strong{Return:}
nxn unit matrix

@item @strong{Note:}
needs a basering, diagonal entries are numbers (=1) in the basering

@end table
@strong{Example:}
@smallexample
@c reused example unitmat d2t_singular/matrix_lib.doc:481 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
print(xyz*unitmat(4));
@expansion{} xyz,0,  0,  0, 
@expansion{} 0,  xyz,0,  0, 
@expansion{} 0,  0,  xyz,0, 
@expansion{} 0,  0,  0,  xyz
print(unitmat(5));
@expansion{} 1,0,0,0,0,
@expansion{} 0,1,0,0,0,
@expansion{} 0,0,1,0,0,
@expansion{} 0,0,0,1,0,
@expansion{} 0,0,0,0,1 
@c end example unitmat d2t_singular/matrix_lib.doc:481
@end smallexample
@c ---end content unitmat---

@c ------------------- gauss_col -------------
@node gauss_col, gauss_row, unitmat, matrix_lib
@subsubsection gauss_col
@cindex gauss_col
@c ---content gauss_col---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
gauss_col(A[,e]); A a matrix, e any type

@item @strong{Return:}
- a matrix B, if called with one argument; B is the complete column-
reduced upper-triangular normal form of A if A is constant,
(resp. as far as this is possible if A is a polynomial matrix;
no division by polynomials).
@* - a list L of two matrices, if called with two arguments;
L satisfies L[1] = A * L[2] with L[1] the column-reduced form of A
and L[2] the transformation matrix.

@item @strong{Note:}
* The procedure just applies interred to A with ordering (C,dp).
The transformation matrix is obtained by applying 'lift'.
This should be faster than the procedure colred.
@* * It should only be used with exact coefficient field (there is no
pivoting and rounding error treatment).
@* * Parameters are allowed. Hence, if the entries of A are parameters,
B is the column-reduced form of A over the rational function field.

@end table
@strong{Example:}
@smallexample
@c reused example gauss_col d2t_singular/matrix_lib.doc:522 
LIB "matrix.lib";
ring r=(0,a,b),(A,B,C),dp;
matrix m[8][6]=
0,    2*C, 0,    0,  0,   0,
0,    -4*C,a*A,  0,  0,   0,
b*B,  -A,  0,    0,  0,   0,
-A,   B,   0,    0,  0,   0,
-4*C, 0,   B,    2,  0,   0,
2*A,  B,   0,    0,  0,   0,
0,    3*B, 0,    0,  2b,  0,
0,    AB,  0,    2*A,A,   2a;"";
@expansion{} 
list L=gauss_col(m,1);
print(L[1]);
@expansion{} 0,0,2*C, 0,       0,0,
@expansion{} A,0,-4*C,0,       0,0,
@expansion{} 0,0,-A,  (1/2b)*B,0,0,
@expansion{} 0,0,B,   -1/2*A,  0,0,
@expansion{} 0,1,0,   0,       0,0,
@expansion{} 0,0,B,   A,       0,0,
@expansion{} 0,0,0,   0,       1,0,
@expansion{} 0,0,0,   0,       0,1 
print(L[2]);
@expansion{} 0,         0,        0,               1/2,      0,         0,    
@expansion{} 0,         0,        1,               0,        0,         0,    
@expansion{} 1/(a),     0,        0,               0,        0,         0,    
@expansion{} -1/(2a)*B, 1/2,      0,               C,        0,         0,    
@expansion{} 0,         0,        -3/(2b)*B,       0,        1/(2b),    0,    
@expansion{} 1/(2a2)*AB,-1/(2a)*A,(-2b+3)/(4ab)*AB,-1/(a)*AC,-1/(4ab)*A,1/(2a)
ring S=0,x,(c,dp);
matrix A[5][4] =
3, 1, 1, 1,
13, 8, 6,-7,
14,10, 6,-7,
7, 4, 3,-3,
2, 1, 0, 3;
print(gauss_col(A));
@expansion{} 8/9,-5/9,-1/3,7/9,
@expansion{} 1,  0,   0,   0,  
@expansion{} 0,  1,   0,   0,  
@expansion{} 0,  0,   1,   0,  
@expansion{} 0,  0,   0,   1   
@c end example gauss_col d2t_singular/matrix_lib.doc:522
@end smallexample
@c inserted refs from d2t_singular/matrix_lib.doc:547
@menu
See also:
* colred::
@end menu
@c end inserted refs from d2t_singular/matrix_lib.doc:547

@c ---end content gauss_col---

@c ------------------- gauss_row -------------
@node gauss_row, addcol, gauss_col, matrix_lib
@subsubsection gauss_row
@cindex gauss_row
@c ---content gauss_row---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
gauss_row(A [,e]); A matrix, e any type

@item @strong{Return:}
- a matrix B, if called with one argument; B is the complete row-
reduced lower-triangular normal form of A if A is constant,
(resp. as far as this is possible if A is a polynomial matrix;
no division by polynomials).
@* - a list L of two matrices, if called with two arguments;
L satisfies L[1] = L[2] * A with L[1] the row-reduced form of A
and L[2] the transformation matrix.

@item @strong{Note:}
* This procedure just applies gauss_col to the transposed matrix.
The transformation matrix is obtained by applying lift.
This should be faster than the procedure rowred.
@* * It should only be used with exact coefficient field (there is no
pivoting and rounding error treatment).
@* * Parameters are allowed. Hence, if the entries of A are parameters,
B is the row-reduced form of A over the rational function field.

@end table
@strong{Example:}
@smallexample
@c reused example gauss_row d2t_singular/matrix_lib.doc:585 
LIB "matrix.lib";
ring r=(0,a,b),(A,B,C),dp;
matrix m[6][8]=
0, 0,  b*B, -A,-4C,2A,0, 0,
2C,-4C,-A,B, 0,  B, 3B,AB,
0,a*A,  0, 0, B,  0, 0, 0,
0, 0,  0, 0, 2,  0, 0, 2A,
0, 0,  0, 0, 0,  0, 2b, A,
0, 0,  0, 0, 0,  0, 0, 2a;"";
@expansion{} 
print(gauss_row(m));"";
@expansion{} 0,  A,   0,       0,     0,0,0,0,
@expansion{} 0,  0,   0,       0,     1,0,0,0,
@expansion{} 2*C,-4*C,-A,      B,     0,B,0,0,
@expansion{} 0,  0,   (1/2b)*B,-1/2*A,0,A,0,0,
@expansion{} 0,  0,   0,       0,     0,0,1,0,
@expansion{} 0,  0,   0,       0,     0,0,0,1 
@expansion{} 
ring S=0,x,dp;
matrix A[4][5] =  3, 1,1,-1,2,
13, 8,6,-7,1,
14,10,6,-7,1,
7, 4,3,-3,3;
list L=gauss_row(A,1);
print(L[1]);
@expansion{} 1/2,-7/3,-19/6,5/6,
@expansion{} 1,  0,   0,    0,  
@expansion{} 0,  1,   0,    0,  
@expansion{} 0,  0,   1,    0,  
@expansion{} 0,  0,   0,    1   
print(L[2]);
@expansion{} 0,   -6,  -5,  1,   
@expansion{} -1/2,2/3, -1/6,-1/6,
@expansion{} 1/2, -5/3,-5/6,1/6, 
@expansion{} 0,   13/3,11/3,-1/3 
@c end example gauss_row d2t_singular/matrix_lib.doc:585
@end smallexample
@c inserted refs from d2t_singular/matrix_lib.doc:606
@menu
See also:
* rowred::
@end menu
@c end inserted refs from d2t_singular/matrix_lib.doc:606

@c ---end content gauss_row---

@c ------------------- addcol -------------
@node addcol, addrow, gauss_row, matrix_lib
@subsubsection addcol
@cindex addcol
@c ---content addcol---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
addcol(A,c1,p,c2); A matrix, p poly, c1, c2 positive integers

@item @strong{Return:}
matrix, A being modified by adding p times column c1 to column c2

@end table
@strong{Example:}
@smallexample
@c reused example addcol d2t_singular/matrix_lib.doc:629 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(addcol(A,1,xy,2));
@expansion{} 1,xy+2, 3,
@expansion{} 4,4xy+5,6,
@expansion{} 7,7xy+8,9 
@c end example addcol d2t_singular/matrix_lib.doc:629
@end smallexample
@c ---end content addcol---

@c ------------------- addrow -------------
@node addrow, multcol, addcol, matrix_lib
@subsubsection addrow
@cindex addrow
@c ---content addrow---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
addcol(A,r1,p,r2); A matrix, p poly, r1, r2 positive integers

@item @strong{Return:}
matrix, A being modified by adding p times row r1 to row r2

@end table
@strong{Example:}
@smallexample
@c reused example addrow d2t_singular/matrix_lib.doc:656 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(addrow(A,1,xy,3));
@expansion{} 1,   2,    3,   
@expansion{} 4,   5,    6,   
@expansion{} xy+7,2xy+8,3xy+9
@c end example addrow d2t_singular/matrix_lib.doc:656
@end smallexample
@c ---end content addrow---

@c ------------------- multcol -------------
@node multcol, multrow, addrow, matrix_lib
@subsubsection multcol
@cindex multcol
@c ---content multcol---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
addcol(A,c,p); A matrix, p poly, c positive integer

@item @strong{Return:}
matrix, A being modified by multiplying column c with p

@end table
@strong{Example:}
@smallexample
@c reused example multcol d2t_singular/matrix_lib.doc:683 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(multcol(A,2,xy));
@expansion{} 1,2xy,3,
@expansion{} 4,5xy,6,
@expansion{} 7,8xy,9 
@c end example multcol d2t_singular/matrix_lib.doc:683
@end smallexample
@c ---end content multcol---

@c ------------------- multrow -------------
@node multrow, permcol, multcol, matrix_lib
@subsubsection multrow
@cindex multrow
@c ---content multrow---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
multrow(A,r,p); A matrix, p poly, r positive integer

@item @strong{Return:}
matrix, A being modified by multiplying row r with p

@end table
@strong{Example:}
@smallexample
@c reused example multrow d2t_singular/matrix_lib.doc:710 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,4,5,6,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(multrow(A,2,xy));
@expansion{} 1,  2,  3,  
@expansion{} 4xy,5xy,6xy,
@expansion{} 7,  8,  9   
@c end example multrow d2t_singular/matrix_lib.doc:710
@end smallexample
@c ---end content multrow---

@c ------------------- permcol -------------
@node permcol, permrow, multrow, matrix_lib
@subsubsection permcol
@cindex permcol
@c ---content permcol---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
permcol(A,c1,c2); A matrix, c1,c2 positive integers

@item @strong{Return:}
matrix, A being modified by permuting column c1 and c2

@end table
@strong{Example:}
@smallexample
@c reused example permcol d2t_singular/matrix_lib.doc:737 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,x,3,4,y,6,7,z,9;
print(A);
@expansion{} 1,x,3,
@expansion{} 4,y,6,
@expansion{} 7,z,9 
print(permcol(A,2,3));
@expansion{} 1,3,x,
@expansion{} 4,6,y,
@expansion{} 7,9,z 
@c end example permcol d2t_singular/matrix_lib.doc:737
@end smallexample
@c ---end content permcol---

@c ------------------- permrow -------------
@node permrow, rowred, permcol, matrix_lib
@subsubsection permrow
@cindex permrow
@c ---content permrow---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
permrow(A,r1,r2); A matrix, r1,r2 positive integers

@item @strong{Return:}
matrix, A being modified by permuting row r1 and r2

@end table
@strong{Example:}
@smallexample
@c reused example permrow d2t_singular/matrix_lib.doc:764 
LIB "matrix.lib";
ring r=32003,(x,y,z),lp;
matrix A[3][3]=1,2,3,x,y,z,7,8,9;
print(A);
@expansion{} 1,2,3,
@expansion{} x,y,z,
@expansion{} 7,8,9 
print(permrow(A,2,1));
@expansion{} x,y,z,
@expansion{} 1,2,3,
@expansion{} 7,8,9 
@c end example permrow d2t_singular/matrix_lib.doc:764
@end smallexample
@c ---end content permrow---

@c ------------------- rowred -------------
@node rowred, colred, permrow, matrix_lib
@subsubsection rowred
@cindex rowred
@c ---content rowred---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
rowred(A[,e]); A matrix, e any type

@item @strong{Return:}
- a matrix B, being the row reduced form of A, if rowred is called
with one argument.
@*(as far as this is possible over the polynomial ring; no division
by polynomials)
@* - a list L of two matrices, such that L[1] = L[2] * A with L[1]
the row-reduced form of A and L[2] the transformation matrix
(if rowred is called with two arguments).

@item @strong{Note:}
* This procedure is designed for teaching purposes mainly.
@* * The straight forward Gaussian algorithm is implemented in the
library (no standard basis computation).
@*The transformation matrix is obtained by concatenating a unit
matrix to A. proc gauss_row should be faster.
@* * It should only be used with exact coefficient field (there is no
pivoting) over the polynomial ring (ordering lp or dp).
@* * Parameters are allowed. Hence, if the entries of A are parameters
the computation takes place over the field of rational functions.

@end table
@strong{Example:}
@smallexample
@c reused example rowred d2t_singular/matrix_lib.doc:808 
LIB "matrix.lib";
ring r=(0,a,b),(A,B,C),dp;
matrix m[6][8]=
0, 0,  b*B, -A,-4C,2A,0, 0,
2C,-4C,-A,B, 0,  B, 3B,AB,
0,a*A,  0, 0, B,  0, 0, 0,
0, 0,  0, 0, 2,  0, 0, 2A,
0, 0,  0, 0, 0,  0, 2b, A,
0, 0,  0, 0, 0,  0, 0, 2a;"";
@expansion{} 
print(rowred(m));"";
@expansion{} 0,  0,    0,    0, 1,0,  0,0,
@expansion{} 0,  0,    0,    0, 0,0,  1,0,
@expansion{} 0,  0,    0,    0, 0,0,  0,1,
@expansion{} 0,  0,    (b)*B,-A,0,2*A,0,0,
@expansion{} 2*C,-4*C, -A,   B, 0,B,  0,0,
@expansion{} 0,  (a)*A,0,    0, 0,0,  0,0 
@expansion{} 
list L=rowred(m,1);
print(L[1]);
@expansion{} 0,  0,    0,    0, 1,0,  0,0,
@expansion{} 0,  0,    0,    0, 0,0,  1,0,
@expansion{} 0,  0,    0,    0, 0,0,  0,1,
@expansion{} 0,  0,    (b)*B,-A,0,2*A,0,0,
@expansion{} 2*C,-4*C, -A,   B, 0,B,  0,0,
@expansion{} 0,  (a)*A,0,    0, 0,0,  0,0 
print(L[2]);
@expansion{} 0,0,0,1/2,   0,        -1/(2a)*A,       
@expansion{} 0,0,0,0,     1/(2b),   -1/(4ab)*A,      
@expansion{} 0,0,0,0,     0,        1/(2a),          
@expansion{} 1,0,0,2*C,   0,        -2/(a)*AC,       
@expansion{} 0,1,0,0,     -3/(2b)*B,(-2b+3)/(4ab)*AB,
@expansion{} 0,0,1,-1/2*B,0,        1/(2a)*AB        
@c end example rowred d2t_singular/matrix_lib.doc:808
@end smallexample
@c inserted refs from d2t_singular/matrix_lib.doc:824
@menu
See also:
* gauss_row::
@end menu
@c end inserted refs from d2t_singular/matrix_lib.doc:824

@c ---end content rowred---

@c ------------------- colred -------------
@node colred, rm_unitrow, rowred, matrix_lib
@subsubsection colred
@cindex colred
@c ---content colred---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
colred(A[,e]); A matrix, e any type

@item @strong{Return:}
- a matrix B, being the column reduced form of A, if colred is
called with one argument.
@*(as far as this is possible over the polynomial ring;
no division by polynomials)
@* - a list L of two matrices, such that L[1] = A * L[2] with L[1]
the column-reduced form of A and L[2] the transformation matrix
(if colred is called with two arguments).

@item @strong{Note:}
* This procedure is designed for teaching purposes mainly.
@* * It applies rowred to the transposed matrix.
proc gauss_col should be faster.
@* * It should only be used with exact coefficient field (there is no
pivoting) over the polynomial ring (ordering lp or dp).
@* * Parameters are allowed. Hence, if the entries of A are parameters
the computation takes place over the field of rational functions.

@end table
@strong{Example:}
@smallexample
@c reused example colred d2t_singular/matrix_lib.doc:862 
LIB "matrix.lib";
ring r=(0,a,b),(A,B,C),dp;
matrix m[8][6]=
0,    2*C, 0,    0,  0,   0,
0,    -4*C,a*A,  0,  0,   0,
b*B,  -A,  0,    0,  0,   0,
-A,   B,   0,    0,  0,   0,
-4*C, 0,   B,    2,  0,   0,
2*A,  B,   0,    0,  0,   0,
0,    3*B, 0,    0,  2b,  0,
0,    AB,  0,    2*A,A,   2a;"";
@expansion{} 
print(colred(m));"";
@expansion{} 0,0,0,0,    2*C, 0,    
@expansion{} 0,0,0,0,    -4*C,(a)*A,
@expansion{} 0,0,0,(b)*B,-A,  0,    
@expansion{} 0,0,0,-A,   B,   0,    
@expansion{} 1,0,0,0,    0,   0,    
@expansion{} 0,0,0,2*A,  B,   0,    
@expansion{} 0,1,0,0,    0,   0,    
@expansion{} 0,0,1,0,    0,   0     
@expansion{} 
list L=colred(m,1);
print(L[1]);
@expansion{} 0,0,0,0,    2*C, 0,    
@expansion{} 0,0,0,0,    -4*C,(a)*A,
@expansion{} 0,0,0,(b)*B,-A,  0,    
@expansion{} 0,0,0,-A,   B,   0,    
@expansion{} 1,0,0,0,    0,   0,    
@expansion{} 0,0,0,2*A,  B,   0,    
@expansion{} 0,1,0,0,    0,   0,    
@expansion{} 0,0,1,0,    0,   0     
print(L[2]);
@expansion{} 0,        0,         0,     1,        0,               0,       
@expansion{} 0,        0,         0,     0,        1,               0,       
@expansion{} 0,        0,         0,     0,        0,               1,       
@expansion{} 1/2,      0,         0,     2*C,      0,               -1/2*B,  
@expansion{} 0,        1/(2b),    0,     0,        -3/(2b)*B,       0,       
@expansion{} -1/(2a)*A,-1/(4ab)*A,1/(2a),-2/(a)*AC,(-2b+3)/(4ab)*AB,1/(2a)*AB
@c end example colred d2t_singular/matrix_lib.doc:862
@end smallexample
@c inserted refs from d2t_singular/matrix_lib.doc:880
@menu
See also:
* gauss_col::
@end menu
@c end inserted refs from d2t_singular/matrix_lib.doc:880

@c ---end content colred---

@c ------------------- rm_unitrow -------------
@node rm_unitrow, rm_unitcol, colred, matrix_lib
@subsubsection rm_unitrow
@cindex rm_unitrow
@c ---content rm_unitrow---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
rm_unitrow(A); A matrix (being col-reduced)

@item @strong{Return:}
matrix, obtained from A by deleting unit rows (having just one 1
and else 0 as entries) and associated columns

@end table
@strong{Example:}
@smallexample
@c reused example rm_unitrow d2t_singular/matrix_lib.doc:904 
LIB "matrix.lib";
ring r=0,(A,B,C),dp;
matrix m[8][6]=
0,0,  0,   0, 2C, 0,
0,0,  0,   0, -4C,A,
A,-C2,0,   B, -A, 0,
0,0,  1/2B,-A,B,  0,
1,0,  0,   0, 0,  0,
0,0,  0,   2A,B,  0,
0,1,  0,   0, 0,  0,
0,0,  1,   0, 0,  0;
print(rm_unitrow(m));
@expansion{} 0, 2C, 0,
@expansion{} 0, -4C,A,
@expansion{} B, -A, 0,
@expansion{} -A,B,  0,
@expansion{} 2A,B,  0 
@c end example rm_unitrow d2t_singular/matrix_lib.doc:904
@end smallexample
@c ---end content rm_unitrow---

@c ------------------- rm_unitcol -------------
@node rm_unitcol, headStand, rm_unitrow, matrix_lib
@subsubsection rm_unitcol
@cindex rm_unitcol
@c ---content rm_unitcol---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@item @strong{Usage:}
rm_unitcol(A); A matrix (being row-reduced)

@item @strong{Return:}
matrix, obtained from A by deleting unit columns (having just one 1
and else 0 as entries) and associated rows

@end table
@strong{Example:}
@smallexample
@c reused example rm_unitcol d2t_singular/matrix_lib.doc:939 
LIB "matrix.lib";
ring r=0,(A,B,C),dp;
matrix m[6][8]=
0,  0,    A,   0, 1,0,  0,0,
0,  0,  -C2,   0, 0,0,  1,0,
0,  0,    0,1/2B, 0,0,  0,1,
0,  0,    B,  -A, 0,2A, 0,0,
2C,-4C,  -A,   B, 0,B,  0,0,
0,  A,    0,   0, 0,0,  0,0;
print(rm_unitcol(m));
@expansion{} 0, 0,  B, -A,2A,
@expansion{} 2C,-4C,-A,B, B, 
@expansion{} 0, A,  0, 0, 0  
@c end example rm_unitcol d2t_singular/matrix_lib.doc:939
@end smallexample
@c ---end content rm_unitcol---

@c ------------------- headStand -------------
@node headStand,, rm_unitcol, matrix_lib
@subsubsection headStand
@cindex headStand
@c ---content headStand---
Procedure from library @code{matrix.lib} (@pxref{matrix_lib}).

@table @asis
@end table
@c ---end content headStand---
@c ---------------------------------------------------------
@node linalg_lib, , matrix_lib, Linear algebra
@subsection linalg_lib
@c include of docu for linalg.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/linalg_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/linalg_lib.doc INSTEAD
@c library version: (1.10.2.15,2003/04/04)
@c library file: ../Singular/LIB/linalg.lib
@cindex linalg.lib
@cindex linalg_lib
@table @asis
@item @strong{Library:}
linalg.lib
@item @strong{Purpose:}
  Algorithmic Linear Algebra
@item @strong{Authors:}
Ivor Saynisch (ivs@@math.tu-cottbus.de)
@* Mathias Schulze (mschulze@@mathematik.uni-kl.de)

@end table

@strong{Procedures:}
@menu
* inverse:: matrix, the inverse of A
* inverse_B:: list(matrix Inv,poly p),Inv*A=p*En ( using busadj(A) )
* inverse_L:: list(matrix Inv,poly p),Inv*A=p*En ( using lift )
* sym_gauss:: symmetric gaussian algorithm
* orthogonalize:: Gram-Schmidt orthogonalization
* diag_test:: test whether A can be diagonalized
* busadj:: coefficients of Adj(E*t-A) and coefficients of det(E*t-A)
* charpoly:: characteristic polynomial of A ( using busadj(A) )
* adjoint:: adjoint of A ( using busadj(A) )
* det_B:: determinant of A ( using busadj(A) )
* gaussred:: gaussian reduction: P*A=U*S, S a row reduced form of A
* gaussred_pivot:: gaussian reduction: P*A=U*S, uses row pivoting
* gauss_nf:: gaussian normal form of A
* mat_rk:: rank of constant matrix A
* U_D_O:: P*A=U*D*O, P,D,U,O=permutation,diag,lower-,upper-triang
* pos_def:: test symmetric matrix for positive definiteness
* hessenberg:: Hessenberg form of M
* evnf:: eigenvalues normal form of (e[,m])
* eigenvals:: eigenvalues with multiplicities of M
* minipoly:: minimal polynomial of M
* jordan:: Jordan data of M
* jordanbasis:: Jordan basis and weight filtration of M
* jordanmatrix:: Jordan matrix with Jordan data (e,s,m)
* jordannf:: Jordan normal form of M
@end menu
@c ---end content LibInfo---

@c ------------------- inverse -------------
@node inverse, inverse_B,, linalg_lib
@subsubsection inverse
@cindex inverse
@c ---content inverse---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
inverse(A [,opt]); A a square matrix, opt integer

@item @strong{Return:}
@format
          a matrix:
          - the inverse matrix of A, if A is invertible;
          - the 1x1 0-matrix if A is not invertible (in the polynomial ring!).
          There are the following options:
          - opt=0 or not given: heuristically best option from below
          - opt=1 : apply std to (transpose(E,A)), ordering (C,dp).
          - opt=2 : apply interred (transpose(E,A)), ordering (C,dp).
          - opt=3 : apply lift(A,E), ordering (C,dp).
@end format

@item @strong{Note:}
parameters and minpoly are allowed; opt=2 is only correct for
matrices with entries in a field

@end table
@strong{Example:}
@smallexample
@c skipped computation of example inverse d2t_singular/linalg_lib.doc:76 
LIB "linalg.lib";
ring r=0,(x,y,z),lp;
matrix A[3][3]=
1,4,3,
1,5,7,
0,4,17;
print(inverse(A));"";
matrix B[3][3]=
y+1,  x+y,    y,
z,    z+1,    z,
y+z+2,x+y+z+2,y+z+1;
print(inverse(B));
print(B*inverse(B));
@end smallexample
@c inserted refs from d2t_singular/linalg_lib.doc:92
@menu
See also:
* inverse_B::
* inverse_L::
@end menu
@c end inserted refs from d2t_singular/linalg_lib.doc:92

@c ---end content inverse---

@c ------------------- inverse_B -------------
@node inverse_B, inverse_L, inverse, linalg_lib
@subsubsection inverse_B
@cindex inverse_B
@c ---content inverse_B---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
inverse_B(A); A = square matrix

@item @strong{Return:}
list Inv with
@*- Inv[1] = matrix I and
@*- Inv[2] = poly p
@*such that I*A = unitmat(n)*p;

@item @strong{Note:}
p=1 if 1/det(A) is computable and p=det(A) if not;
@*the computation uses busadj.

@end table
@strong{Example:}
@smallexample
@c skipped computation of example inverse_B d2t_singular/linalg_lib.doc:122 
LIB "linalg.lib";
ring r=0,(x,y),lp;
matrix A[3][3]=x,y,1,1,x2,y,x,6,0;
print(A);
list Inv=inverse_B(A);
print(Inv[1]);
print(Inv[2]);
print(Inv[1]*A);
@end smallexample
@c inserted refs from d2t_singular/linalg_lib.doc:133
@menu
See also:
* inverse::
* inverse_L::
@end menu
@c end inserted refs from d2t_singular/linalg_lib.doc:133

@c ---end content inverse_B---

@c ------------------- inverse_L -------------
@node inverse_L, sym_gauss, inverse_B, linalg_lib
@subsubsection inverse_L
@cindex inverse_L
@c ---content inverse_L---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
inverse_L(A); A = square matrix

@item @strong{Return:}
list Inv representing a left inverse of A, i.e
@*- Inv[1] = matrix I and
@*- Inv[2] = poly p
@*such that I*A = unitmat(n)*p;

@item @strong{Note:}
p=1 if 1/det(A) is computable and p=det(A) if not;
@*the computation computes first det(A) and then uses lift

@end table
@strong{Example:}
@smallexample
@c skipped computation of example inverse_L d2t_singular/linalg_lib.doc:163 
LIB "linalg.lib";
ring r=0,(x,y),lp;
matrix A[3][3]=x,y,1,1,x2,y,x,6,0;
print(A);
list Inv=inverse_L(A);
print(Inv[1]);
print(Inv[2]);
print(Inv[1]*A);
@end smallexample
@c inserted refs from d2t_singular/linalg_lib.doc:174
@menu
See also:
* inverse::
* inverse_B::
@end menu
@c end inserted refs from d2t_singular/linalg_lib.doc:174

@c ---end content inverse_L---

@c ------------------- sym_gauss -------------
@node sym_gauss, orthogonalize, inverse_L, linalg_lib
@subsubsection sym_gauss
@cindex sym_gauss
@c ---content sym_gauss---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
sym_gauss(A); A = symmetric matrix

@item @strong{Return:}
matrix, diagonalisation with symmetric gauss algorithm

@end table
@strong{Example:}
@smallexample
@c skipped computation of example sym_gauss d2t_singular/linalg_lib.doc:197 
LIB "linalg.lib";
ring r=0,(x),lp;
matrix A[2][2]=1,4,4,15;
print(A);
print(sym_gauss(A));
@end smallexample
@c ---end content sym_gauss---

@c ------------------- orthogonalize -------------
@node orthogonalize, diag_test, sym_gauss, linalg_lib
@subsubsection orthogonalize
@cindex orthogonalize
@c ---content orthogonalize---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
orthogonalize(A); A = constant matrix

@item @strong{Return:}
matrix, orthogonal basis of the column space of A

@end table
@strong{Example:}
@smallexample
@c skipped computation of example orthogonalize d2t_singular/linalg_lib.doc:224 
LIB "linalg.lib";
ring r=0,(x),lp;
matrix A[4][4]=5,6,12,4,7,3,2,6,12,1,1,2,6,4,2,10;
print(A);
print(orthogonalize(A));
@end smallexample
@c ---end content orthogonalize---

@c ------------------- diag_test -------------
@node diag_test, busadj, orthogonalize, linalg_lib
@subsubsection diag_test
@cindex diag_test
@c ---content diag_test---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
diag_test(A); A = const square matrix

@item @strong{Return:}
int, 1 if A is diagonalisable, 0 if not
@*-1 no statement is possible, since A does not split.

@item @strong{Note:}
The test works only for split matrices, i.e if eigenvalues of A
are in the ground field.
@*Does not work with parameters (uses factorize,gcd).

@end table
@strong{Example:}
@smallexample
@c skipped computation of example diag_test d2t_singular/linalg_lib.doc:257 
LIB "linalg.lib";
ring r=0,(x),dp;
matrix A[4][4]=6,0,0,0,0,0,6,0,0,6,0,0,0,0,0,6;
print(A);
diag_test(A);
@end smallexample
@c ---end content diag_test---

@c ------------------- busadj -------------
@node busadj, charpoly, diag_test, linalg_lib
@subsubsection busadj
@cindex busadj
@c ---content busadj---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
busadj(A); A = square matrix (of size nxn)

@item @strong{Return:}
list L:
@format
         L[1] contains the (n+1) coefficients of the characteristic
              polynomial X of A, i.e.
              X = L[1][1]+..+L[1][k]*t^(k-1)+..+(L[1][n+1])*t^n
         L[2] contains the n (nxn)-matrices Hk which are the coefficients of
              the busadjoint bA = adjoint(E*t-A) of A, i.e.
              bA = (Hn-1)*t^(n-1)+...+Hk*t^k+...+H0,  ( Hk=L[2][k+1] )
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example busadj d2t_singular/linalg_lib.doc:292 
LIB "linalg.lib";
ring r = 0,(t,x),lp;
matrix A[2][2] = 1,x2,x,x2+3x;
print(A);
list L = busadj(A);
poly X = L[1][1]+L[1][2]*t+L[1][3]*t2; X;
matrix bA[2][2] = L[2][1]+L[2][2]*t;
print(bA);               //the busadjoint of A;
print(bA*(t*unitmat(2)-A));
@end smallexample
@c ---end content busadj---

@c ------------------- charpoly -------------
@node charpoly, adjoint, busadj, linalg_lib
@subsubsection charpoly
@cindex charpoly
@c ---content charpoly---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
charpoly(A[,v]); A square matrix, v string, name of a variable

@item @strong{Return:}
poly, the characteristic polynomial det(E*v-A)
@*(default: v=name of last variable)

@item @strong{Note:}
A must be independent of the variable v. The computation uses det.
If printlevel>0, det(E*v-A) is diplayed recursively.

@end table
@strong{Example:}
@smallexample
@c skipped computation of example charpoly d2t_singular/linalg_lib.doc:328 
LIB "linalg.lib";
ring r=0,(x,t),dp;
matrix A[3][3]=1,x2,x,x2,6,4,x,4,1;
print(A);
charpoly(A,"t");
@end smallexample
@c ---end content charpoly---

@c ------------------- adjoint -------------
@node adjoint, det_B, charpoly, linalg_lib
@subsubsection adjoint
@cindex adjoint
@c ---content adjoint---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
adjoint(A); A = square matrix

@item @strong{Return:}
adjoint matrix of A, i.e. Adj*A=det(A)*E

@item @strong{Note:}
computation uses busadj(A)

@end table
@strong{Example:}
@smallexample
@c skipped computation of example adjoint d2t_singular/linalg_lib.doc:358 
LIB "linalg.lib";
ring r=0,(t,x),lp;
matrix A[2][2]=1,x2,x,x2+3x;
print(A);
matrix Adj[2][2]=adjoint(A);
print(Adj);                    //Adj*A=det(A)*E
print(Adj*A);
@end smallexample
@c ---end content adjoint---

@c ------------------- det_B -------------
@node det_B, gaussred, adjoint, linalg_lib
@subsubsection det_B
@cindex det_B
@c ---content det_B---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
det_B(A); A any matrix

@item @strong{Return:}
returns the determinant of A

@item @strong{Note:}
the computation uses the busadj algorithm

@end table
@strong{Example:}
@smallexample
@c skipped computation of example det_B d2t_singular/linalg_lib.doc:390 
LIB "linalg.lib";
ring r=0,(x),dp;
matrix A[10][10]=random(2,10,10)+unitmat(10)*x;
print(A);
det_B(A);
@end smallexample
@c ---end content det_B---

@c ------------------- gaussred -------------
@node gaussred, gaussred_pivot, det_B, linalg_lib
@subsubsection gaussred
@cindex gaussred
@c ---content gaussred---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
gaussred(A); A any constant matrix

@item @strong{Return:}
list Z: Z[1]=P , Z[2]=U , Z[3]=S , Z[4]=rank(A)
@*gives a row reduced matrix S, a permutation matrix P and a
normalized lower triangular matrix U, with P*A=U*S

@item @strong{Note:}
This procedure is designed for teaching purposes mainly.
The straight forward implementation in the interpreted library
is not very efficient (no standard basis computation).

@end table
@strong{Example:}
@smallexample
@c skipped computation of example gaussred d2t_singular/linalg_lib.doc:424 
LIB "linalg.lib";
ring r=0,(x),dp;
matrix A[5][4]=1,3,-1,4,2,5,-1,3,1,3,-1,4,0,4,-3,1,-3,1,-5,-2;
print(A);
list Z=gaussred(A);   //construct P,U,S s.t. P*A=U*S
print(Z[1]);          //P
print(Z[2]);          //U
print(Z[3]);          //S
print(Z[4]);          //rank
print(Z[1]*A);        //P*A
print(Z[2]*Z[3]);     //U*S
@end smallexample
@c ---end content gaussred---

@c ------------------- gaussred_pivot -------------
@node gaussred_pivot, gauss_nf, gaussred, linalg_lib
@subsubsection gaussred_pivot
@cindex gaussred_pivot
@c ---content gaussred_pivot---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
gaussred_pivot(A); A any constant matrix

@item @strong{Return:}
list Z: Z[1]=P , Z[2]=U , Z[3]=S , Z[4]=rank(A)
@*gives n row reduced matrix S, a permutation matrix P and a
normalized lower triangular matrix U, with P*A=U*S

@item @strong{Note:}
with row pivoting

@end table
@strong{Example:}
@smallexample
@c skipped computation of example gaussred_pivot d2t_singular/linalg_lib.doc:462 
LIB "linalg.lib";
ring r=0,(x),dp;
matrix A[5][4] = 1, 3,-1,4,
2, 5,-1,3,
1, 3,-1,4,
0, 4,-3,1,
-3,1,-5,-2;
list Z=gaussred_pivot(A);  //construct P,U,S s.t. P*A=U*S
print(Z[1]);               //P
print(Z[2]);               //U
print(Z[3]);               //S
print(Z[4]);               //rank
print(Z[1]*A);             //P*A
print(Z[2]*Z[3]);          //U*S
@end smallexample
@c ---end content gaussred_pivot---

@c ------------------- gauss_nf -------------
@node gauss_nf, mat_rk, gaussred_pivot, linalg_lib
@subsubsection gauss_nf
@cindex gauss_nf
@c ---content gauss_nf---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
gauss_nf(A); A any constant matrix

@item @strong{Return:}
matrix; gauss normal form of A (uses gaussred)

@end table
@strong{Example:}
@smallexample
@c skipped computation of example gauss_nf d2t_singular/linalg_lib.doc:498 
LIB "linalg.lib";
ring r = 0,(x),dp;
matrix A[4][4] = 1,4,4,7,2,5,5,4,4,1,1,3,0,2,2,7;
print(gauss_nf(A));
@end smallexample
@c ---end content gauss_nf---

@c ------------------- mat_rk -------------
@node mat_rk, U_D_O, gauss_nf, linalg_lib
@subsubsection mat_rk
@cindex mat_rk
@c ---content mat_rk---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
mat_rk(A); A any constant matrix

@item @strong{Return:}
int, rank of A

@end table
@strong{Example:}
@smallexample
@c skipped computation of example mat_rk d2t_singular/linalg_lib.doc:524 
LIB "linalg.lib";
ring r = 0,(x),dp;
matrix A[4][4] = 1,4,4,7,2,5,5,4,4,1,1,3,0,2,2,7;
mat_rk(A);
@end smallexample
@c ---end content mat_rk---

@c ------------------- U_D_O -------------
@node U_D_O, pos_def, mat_rk, linalg_lib
@subsubsection U_D_O
@cindex U_D_O
@c ---content U_D_O---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
U_D_O(A); constant invertible matrix A

@item @strong{Return:}
list Z: Z[1]=P , Z[2]=U , Z[3]=D , Z[4]=O
@*gives a permutation matrix P,
@*a normalized lower triangular matrix U ,
@*a diagonal matrix D, and
@*a normalized upper triangular matrix O
@*with P*A=U*D*O

@item @strong{Note:}
Z[1]=-1 means that A is not regular (proc uses gaussred)

@end table
@strong{Example:}
@smallexample
@c skipped computation of example U_D_O d2t_singular/linalg_lib.doc:558 
LIB "linalg.lib";
ring r = 0,(x),dp;
matrix A[5][5] = 10, 4,  0, -9,  8,
-3, 6, -6, -4,  9,
0, 3, -1, -9, -8,
-4,-2, -6, -10,10,
-9, 5, -1, -6,  5;
list Z = U_D_O(A);              //construct P,U,D,O s.t. P*A=U*D*O
print(Z[1]);                    //P
print(Z[2]);                    //U
print(Z[3]);                    //D
print(Z[4]);                    //O
print(Z[1]*A);                  //P*A
print(Z[2]*Z[3]*Z[4]);          //U*D*O
@end smallexample
@c ---end content U_D_O---

@c ------------------- pos_def -------------
@node pos_def, hessenberg, U_D_O, linalg_lib
@subsubsection pos_def
@cindex pos_def
@c ---content pos_def---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
pos_def(A); A = constant, symmetric square matrix

@item @strong{Return:}
int:
@*1 if A is positive definit ,
@*0 if not,
@*-1 if unknown

@end table
@strong{Example:}
@smallexample
@c skipped computation of example pos_def d2t_singular/linalg_lib.doc:597 
LIB "linalg.lib";
ring r = 0,(x),dp;
matrix A[5][5] = 20,  4,  0, -9,   8,
4, 12, -6, -4,   9,
0, -6, -2, -9,  -8,
-9, -4, -9, -20, 10,
8,  9, -8,  10, 10;
pos_def(A);
matrix B[3][3] =  3,  2,  0,
2, 12,  4,
0,  4,  2;
pos_def(B);
@end smallexample
@c ---end content pos_def---

@c ------------------- hessenberg -------------
@node hessenberg, evnf, pos_def, linalg_lib
@subsubsection hessenberg
@cindex hessenberg
@c ---content hessenberg---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
hessenberg(M); matrix M

@item @strong{Assume:}
M constant square matrix

@item @strong{Return:}
matrix H; Hessenberg form of M

@end table
@strong{Example:}
@smallexample
@c skipped computation of example hessenberg d2t_singular/linalg_lib.doc:634 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
print(hessenberg(M));
@end smallexample
@c ---end content hessenberg---

@c ------------------- evnf -------------
@node evnf, eigenvals, hessenberg, linalg_lib
@subsubsection evnf
@cindex evnf
@c ---content evnf---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
evnf(e[,m]); ideal e, intvec m

@item @strong{Assume:}
ncols(e)==size(m)

@item @strong{Return:}
order eigenvalues e with multiplicities m

@end table
@c ---end content evnf---

@c ------------------- eigenvals -------------
@node eigenvals, minipoly, evnf, linalg_lib
@subsubsection eigenvals
@cindex eigenvals
@c ---content eigenvals---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
eigenvals(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
@format
list l; 
  ideal l[1];
    number l[1][i];  i-th eigenvalue of M
  intvec l[2]; 
    int l[2][i];  multiplicity of i-th eigenvalue of M
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example eigenvals d2t_singular/linalg_lib.doc:690 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
eigenvals(M);
@end smallexample
@c ---end content eigenvals---

@c ------------------- minipoly -------------
@node minipoly, jordan, eigenvals, linalg_lib
@subsubsection minipoly
@cindex minipoly
@c ---content minipoly---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
minpoly(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
@format
list l;  minimal polynomial of M
  ideal l[1]; 
    number l[1][i];  i-th root of minimal polynomial of M
  intvec l[2]; 
    int l[2][i];  multiplicity of i-th root of minimal polynomial of M
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example minipoly d2t_singular/linalg_lib.doc:726 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
minipoly(M);
@end smallexample
@c ---end content minipoly---

@c ------------------- jordan -------------
@node jordan, jordanbasis, minipoly, linalg_lib
@subsubsection jordan
@cindex jordan
@c ---content jordan---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
jordan(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
@format
list l;  Jordan data of M
  ideal l[1]; 
    number l[1][i];  eigenvalue of i-th Jordan block of M
  intvec l[2]; 
    int l[2][i];  size of i-th Jordan block of M
  intvec l[3]; 
    int l[3][i];  multiplicity of i-th Jordan block of M
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example jordan d2t_singular/linalg_lib.doc:764 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
jordan(M);
@end smallexample
@c ---end content jordan---

@c ------------------- jordanbasis -------------
@node jordanbasis, jordanmatrix, jordan, linalg_lib
@subsubsection jordanbasis
@cindex jordanbasis
@c ---content jordanbasis---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
jordanbasis(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
@format
list l:
  module l[1];  inverse(l[1])*M*l[1] in Jordan normal form
  intvec l[2]; 
    int l[2][i];  weight filtration index of l[1][i]
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example jordanbasis d2t_singular/linalg_lib.doc:799 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
list l=jordanbasis(M);
print(l[1]);
print(l[2]);
print(inverse(l[1])*M*l[1]);
@end smallexample
@c ---end content jordanbasis---

@c ------------------- jordanmatrix -------------
@node jordanmatrix, jordannf, jordanbasis, linalg_lib
@subsubsection jordanmatrix
@cindex jordanmatrix
@c ---content jordanmatrix---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
jordanmatrix(e,s,m); ideal e, intvec s, intvec m

@item @strong{Assume:}
ncols(e)==size(s)==size(m)

@item @strong{Return:}
@format
matrix J;  Jordan matrix with list(e,s,m)==jordan(J)
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example jordanmatrix d2t_singular/linalg_lib.doc:834 
LIB "linalg.lib";
ring R=0,x,dp;
ideal e=ideal(2,3);
intvec s=1,2;
intvec m=1,1;
print(jordanmatrix(e,s,m));
@end smallexample
@c ---end content jordanmatrix---

@c ------------------- jordannf -------------
@node jordannf,, jordanmatrix, linalg_lib
@subsubsection jordannf
@cindex jordannf
@c ---content jordannf---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
jordannf(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
matrix J; Jordan normal form of M

@end table
@strong{Example:}
@smallexample
@c skipped computation of example jordannf d2t_singular/linalg_lib.doc:865 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
print(jordannf(M));
@end smallexample
@c ---end content jordannf---
@c ----------------------------------------------------------------------------
@node Commutative algebra, Singularities, Linear algebra, SINGULAR libraries
@section Commutative algebra
@cindex Commutative algebra

@menu
* algebra_lib:: procedures for computing with algebras and maps
* elim_lib:: procedures for elimination, saturation and blowing up
* homolog_lib:: procedures for homological algebra
* mprimdec_lib:: procedures for primary decomposition of modules
* mregular_lib:: procedures for Castelnuovo-Mumford regularity
* normal_lib:: procedure for normalization
* primdec_lib:: procedures for primary decomposition
* primitiv_lib:: procedures for finding a primitive element
* reesclos_lib:: Rees Algebra and integral closure of an ideal
* intprog_lib:: Integer Programming
* toric_lib:: toric ideals
@end menu

@c ---------------------------------------------------------
@node algebra_lib, elim_lib, Commutative algebra, Commutative algebra
@subsection algebra_lib
@c include of docu for algebra.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/algebra_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/algebra_lib.doc INSTEAD
@c library version: (1.9.2.3,2002/04/11)
@c library file: ../Singular/LIB/algebra.lib
@cindex algebra.lib
@cindex algebra_lib
@table @asis
@item @strong{Library:}
algebra.lib
@item @strong{Purpose:}
   Compute with Algebras and Algebra Maps
@item @strong{Authors:}
Gert-Martin Greuel, greuel@@mathematik.uni-kl.de,
@* Agnes Eileen Heydtmann, agnes@@math.uni-sb.de,
@* Gerhard Pfister, pfister@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* algebra_containment:: query of algebra containment
* module_containment:: query of module containment over a subalgebra
* inSubring:: test whether poly p is in subring generated by I
* algDependent:: computes algebraic relations between generators of I
* alg_kernel:: computes the kernel of the ring map phi
* is_injective:: test for injectivity of ring map phi
* is_surjective:: test for surjectivity of ring map phi
* is_bijective:: test for bijectivity of ring map phi
* noetherNormal:: noether normalization of ideal id
* mapIsFinite:: query for finiteness of map phi:R --> basering/I
* finitenessTest:: find variables which occur as pure power in lead(i)
@end menu
@c ---end content LibInfo---

@c ------------------- algebra_containment -------------
@node algebra_containment, module_containment,, algebra_lib
@subsubsection algebra_containment
@cindex algebra_containment
@c ---content algebra_containment---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
algebra_containment(p,A[,k]); p poly, A ideal, k integer.
@* A = A[1],...,A[m] generators of subalgebra of the basering

@item @strong{Return:}
@format
         - k=0 (or if k is not given) an integer:
           1  : if p is contained in the subalgebra K[A[1],...,A[m]]
           0  : if p is not contained in K[A[1],...,A[m]]
         - k=1 : a list, say l, of size 2, l[1] integer, l[2] ring, satisfying
           l[1]=1 if p is in the subalgebra K[A[1],...,A[m]] and then the ring
           l[2] contains poly check = h(y(1),...,y(m)) if p=h(A[1],...,A[m])
           l[1]=0 if p is in not the subalgebra K[A[1],...,A[m]] and then
           l[2] contains the poly check = h(x,y(1),...,y(m)) if p satisfies
           the nonlinear relation p = h(x,A[1],...,A[m]) where
           x = x(1),...,x(n) denote the variables of the basering
@end format

@item @strong{Display:}
if k=0 and printlevel >= voice+1 (default) display the poly check

@item @strong{Note:}
The proc inSubring uses a different algorithm which is sometimes
faster.

@item @strong{Theory:}
The ideal of algebraic relations of the algebra generators A[1],...,
A[m] is computed introducing new variables y(i) and the product
order with x(i) >> y(i).
@*p reduces to a polynomial only in the y(i) <=> p is contained in the
subring generated by the polynomials A[1],...,A[m].

@end table
@strong{Example:}
@smallexample
@c computed example algebra_containment d2t_singular/algebra_lib.doc:77 
LIB "algebra.lib";
int p = printlevel; printlevel = 1;
ring R = 0,(x,y,z),dp;
ideal A=x2+y2,z2,x4+y4,1,x2z-1y2z,xyz,x3y-1xy3;
poly p1=z;
poly p2=
x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
algebra_containment(p1,A);
@expansion{} // x(3)
@expansion{} 0
algebra_containment(p2,A);
@expansion{} // y(1)*y(2)*y(5)^2+y(3)*y(5)^3+4*y(1)*y(2)*y(6)^2+4*y(6)^3*y(7)+2*y(2)*y\
   (5)*y(7)^2
@expansion{} 1
list L = algebra_containment(p2,A,1);
@expansion{} 
@expansion{} // 'algebra_containment' created a ring as 2nd element of the list.
@expansion{} // The ring contains the poly check which defines the algebraic relation.
@expansion{} // To access to the ring and see check you must give the ring a name,
@expansion{} // e.g.:
@expansion{}                def S = l[2]; setring S; check;
@expansion{} 	
L[1];
@expansion{} 1
def S = L[2]; setring S;
check;
@expansion{} y(1)*y(2)*y(5)^2+y(3)*y(5)^3+4*y(1)*y(2)*y(6)^2+4*y(6)^3*y(7)+2*y(2)*y(5)\
   *y(7)^2
printlevel = p;
@c end example algebra_containment d2t_singular/algebra_lib.doc:77
@end smallexample
@c ---end content algebra_containment---

@c ------------------- module_containment -------------
@node module_containment, inSubring, algebra_containment, algebra_lib
@subsubsection module_containment
@cindex module_containment
@c ---content module_containment---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
module_containment(p,P,M[,k]); p poly, P ideal, M ideal, k int
@* P = P[1],...,P[n] generators of a subalgebra of the basering,
@* M = M[1],...,M[m] generators of a module over the subalgebra K[P]

@item @strong{Assume:}
ncols(P) = nvars(basering), the P[i] are algebraically independent

@item @strong{Return:}
@format
         - k=0 (or if k is not given), an integer:
           1    : if p is contained in the module <M[1],...,M[m]> over K[P]
           0    : if p is not contained in <M[1],...,M[m]>
         - k=1, a list, say l, of size 2, l[1] integer, l[2] ring:
           l[1]=1 : if p is in <M[1],...,M[m]> and then the ring l[2] contains
             the polynomial check = h(y(1),...,y(m),z(1),...,z(n)) if
             p = h(M[1],...,M[m],P[1],...,P[n])
           l[1]=0 : if p is in not in <M[1],...,M[m]>, then l[2] contains the
             poly check = h(x,y(1),...,y(m),z(1),...,z(n)) if p satisfies
             the nonlinear relation p = h(x,M[1],...,M[m],P[1],...,P[n]) where
             x = x(1),...,x(n) denote the variables of the basering
@end format

@item @strong{Display:}
the polynomial h(y(1),...,y(m),z(1),...,z(n)) if k=0, resp.
a comment how to access the relation check if k=1, provided
printlevel >= voice+1 (default).

@item @strong{Theory:}
The ideal of algebraic relations of all the generators p1,...,pn,
s1,...,st given by P and S is computed introducing new variables y(j),
z(i) and the product order: x^a*y^b*z^c > x^d*y^e*z^f if x^a > x^d
with respect to the lp ordering or else if z^c > z^f with respect to
the dp ordering or else if y^b > y^e with respect to the lp ordering
again. p reduces to a polynomial only in the y(j) and z(i), linear in
the z(i) <=> p is contained in the module.

@end table
@strong{Example:}
@smallexample
@c computed example module_containment d2t_singular/algebra_lib.doc:144 
LIB "algebra.lib";
int p = printlevel; printlevel = 1;
ring R=0,(x,y,z),dp;
ideal P = x2+y2,z2,x4+y4;           //algebra generators
ideal M = 1,x2z-1y2z,xyz,x3y-1xy3;  //module generators
poly p1=
x10z3-x8y2z3+2x6y4z3-2x4y6z3+x2y8z3-y10z3+x6z4+3x4y2z4+3x2y4z4+y6z4;
module_containment(p1,P,M);
@expansion{} // y(2)*z(2)*z(3)^2+z(1)^3*z(2)^2
@expansion{} 1
poly p2=z;
list l = module_containment(p2,P,M,1);
@expansion{} 
@expansion{} // 'module_containment' created a ring as 2nd element of the list. The
@expansion{} // ring contains the poly check which defines the algebraic relation
@expansion{} // for p. To access to the ring and see check you must give the ring
@expansion{} // a name, e.g.:
@expansion{}      def S = l[2]; setring S; check;
@expansion{}       
l[1];
@expansion{} 0
def S = l[2]; setring S; check;
@expansion{} x(3)
printlevel=p;
@c end example module_containment d2t_singular/algebra_lib.doc:144
@end smallexample
@c ---end content module_containment---

@c ------------------- inSubring -------------
@node inSubring, algDependent, module_containment, algebra_lib
@subsubsection inSubring
@cindex inSubring
@c ---content inSubring---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
inSubring(p,i); p poly, i ideal

@item @strong{Return:}
@format
         a list l of size 2, l[1] integer, l[2] string
         l[1]=1 iff p is in the subring generated by i=i[1],...,i[k],
                and then l[2] = y(0)-h(y(1),...,y(k)) if p = h(i[1],...,i[k])
         l[1]=0 iff p is in not the subring generated by i,
                and then l[2] = h(y(0),y(1),...,y(k) where p satisfies the
                nonlinear relation h(p,i[1],...,i[k])=0.
@end format

@item @strong{Note:}
the proc algebra_containment tests the same with a different
algorithm, which is often faster

@end table
@strong{Example:}
@smallexample
@c computed example inSubring d2t_singular/algebra_lib.doc:190 
LIB "algebra.lib";
ring q=0,(x,y,z,u,v,w),dp;
poly p=xyzu2w-1yzu2w2+u4w2-1xu2vw+u2vw2+xyz-1yzw+2u2w-1xv+vw+2;
ideal I =x-w,u2w+1,yz-v;
inSubring(p,I);
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    y(1)*y(2)*y(3)+y(2)^2-y(0)+1
@c end example inSubring d2t_singular/algebra_lib.doc:190
@end smallexample
@c ---end content inSubring---

@c ------------------- algDependent -------------
@node algDependent, alg_kernel, inSubring, algebra_lib
@subsubsection algDependent
@cindex algDependent
@c ---content algDependent---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
algDependent(f[,c]); f ideal (say, f = f1,...,fm), c integer

@item @strong{Return:}
@format	
         a list l  of size 2, l[1] integer, l[2] ring:
         - l[1] = 1 if f1,...,fm are algebraic dependent, 0 if not
         - l[2] is a ring with variables x(1),...,x(n),y(1),...,y(m) if the
           basering has n variables. It contains the ideal 'ker', depending
           only on the y(i) and generating the algebraic relations between the
           f[i], i.e. substituting y(i) by fi yields 0. Of course, ker is
           nothing but the kernel of the ring map
              K[y(1),...,y(m)] ---> basering,  y(i) --> fi.
@end format

@item @strong{Note:}
Three different algorithms are used depending on c = 1,2,3.
If c is not given or c=0, a heuristically best method is chosen.
The basering may be a quotient ring.
@*To access to the ring l[2] and see ker you must give the ring a name,
e.g. def S=l[2]; setring S; ker;

@item @strong{Display:}
The above comment is displayed if printlevel >= 0 (default).

@end table
@strong{Example:}
@smallexample
@c computed example algDependent d2t_singular/algebra_lib.doc:236 
LIB "algebra.lib";
int p = printlevel; printlevel = 1;
ring R = 0,(x,y,z,u,v,w),dp;
ideal I = xyzu2w-1yzu2w2+u4w2-1xu2vw+u2vw2+xyz-1yzw+2u2w-1xv+vw+2,
x-w, u2w+1, yz-v;
list l = algDependent(I);
@expansion{} 
@expansion{} // The 2nd element of the list l is a ring with variables x(1),...,x(n),
@expansion{} // and y(1),...,y(m) if the basering has n variables and if the ideal
@expansion{} // is f[1],...,f[m]. The ring contains the ideal ker which depends only
@expansion{} // on the y(i) and generates the relations between the f[i].
@expansion{} // I.e. substituting y(i) by f[i] yields 0.
@expansion{} // To access to the ring and see ker you must give the ring a name,
@expansion{} // e.g.:
@expansion{}              def S = l[2]; setring S; ker;
@expansion{} 	
l[1];
@expansion{} 1
def S = l[2]; setring S;
ker;
@expansion{} ker[1]=y(2)*y(3)*y(4)+y(3)^2-y(1)+1
printlevel = p;
@c end example algDependent d2t_singular/algebra_lib.doc:236
@end smallexample
@c ---end content algDependent---

@c ------------------- alg_kernel -------------
@node alg_kernel, is_injective, algDependent, algebra_lib
@subsubsection alg_kernel
@cindex alg_kernel
@c ---content alg_kernel---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
alg_kernel(phi,pr[,s,c]); phi map to basering, pr preimage ring,
s string (name of kernel in pr), c integer.

@item @strong{Return:}
a string, the kernel of phi as string.
@*If, moreover, a string s is given, the algorithm creates, in the
preimage ring pr the kernel of phi with name s.
@*Three different algorithms are used depending on c = 1,2,3.
If c is not given or c=0, a heuristically best method is chosen.
(algorithm 1 uses the preimage command)

@item @strong{Note:}
Since the kernel of phi lives in pr, it cannot be returned to the
basering. If s is given, the user has access to it in pr via s.
The basering may be a quotient ring.

@end table
@strong{Example:}
@smallexample
@c computed example alg_kernel d2t_singular/algebra_lib.doc:279 
LIB "algebra.lib";
ring r = 0,(a,b,c),ds;
ring s = 0,(x,y,z,u,v,w),dp;
ideal I = x-w,u2w+1,yz-v;
map phi = r,I;                // a map from r to s:
alg_kernel(phi,r);            // a,b,c ---> x-w,u2w+1,yz-v
@expansion{} 0
ring S = 0,(a,b,c),ds;
ring R = 0,(x,y,z),dp;
qring Q = std(x-y);
ideal i = x, y, x2-y3;
map phi = S,i;                 // a map to a quotient ring
alg_kernel(phi,S,"ker",3);     // uses algorithm 3
@expansion{} a-b,b^3-b^2+c
setring S;                     // you have access to kernel in preimage
ker;
@expansion{} ker[1]=a-b
@expansion{} ker[2]=c-b2+b3
@c end example alg_kernel d2t_singular/algebra_lib.doc:279
@end smallexample
@c ---end content alg_kernel---

@c ------------------- is_injective -------------
@node is_injective, is_surjective, alg_kernel, algebra_lib
@subsubsection is_injective
@cindex is_injective
@c ---content is_injective---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
is_injective(phi,pr[,c,s]); phi map, pr preimage ring, c int, s string

@item @strong{Return:}
@format	
         - 1 (type int) if phi is injective, 0 if not (if s is not given).
         - If s is given, return a list l of size 2, l[1] int, l[2] ring:
           l[1] is 1 if phi is injective, 0 if not
           l[2] is a ring with variables x(1),...,x(n),y(1),...,y(m) if the
           basering has n variables and the map m components, it contains the
           ideal 'ker', depending only on the y(i), the kernel of the given map
@end format

@item @strong{Note:}
Three different algorithms are used depending on c = 1,2,3.
If c is not given or c=0, a heuristically best method is chosen.
The basering may be a quotient ring. However, if the preimage ring is
a quotient ring, say pr = P/I, consider phi as a map from P and then
the algorithm returns 1 if the kernel of phi is 0 mod I.
To access to the ring l[2] and see ker you must give the ring a name,
e.g. def S=l[2]; setring S; ker;

@item @strong{Display:}
The above comment is displayed if printlevel >= 0 (default).

@end table
@strong{Example:}
@smallexample
@c computed example is_injective d2t_singular/algebra_lib.doc:334 
LIB "algebra.lib";
int p = printlevel;
ring r = 0,(a,b,c),ds;
ring s = 0,(x,y,z,u,v,w),dp;
ideal I = x-w,u2w+1,yz-v;
map phi = r,I;                    // a map from r to s:
is_injective(phi,r);              // a,b,c ---> x-w,u2w+1,yz-v
@expansion{} 1
ring R = 0,(x,y,z),dp;
ideal i = x, y, x2-y3;
map phi = R,i;                    // a map from R to itself, z --> x2-y3
list l = is_injective(phi,R,"");
@expansion{} 
@expansion{} // The 2nd element of the list is a ring with variables x(1),...,x(n),
@expansion{} // y(1),...,y(m) if the basering has n variables and the map is
@expansion{} // F[1],...,F[m].
@expansion{} // It contains the ideal ker, the kernel of the given map y(i) --> F[i].
@expansion{} // To access to the ring and see ker you must give the ring a name,
@expansion{} // e.g.:
@expansion{}      def S = l[2]; setring S; ker;
@expansion{} 	
l[1];
@expansion{} 0
def S = l[2]; setring S;
ker;
@expansion{} ker[1]=y(2)^3-y(1)^2+y(3)
@c end example is_injective d2t_singular/algebra_lib.doc:334
@end smallexample
@c ---end content is_injective---

@c ------------------- is_surjective -------------
@node is_surjective, is_bijective, is_injective, algebra_lib
@subsubsection is_surjective
@cindex is_surjective
@c ---content is_surjective---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
is_surjective(phi); phi map to basering, or ideal defining it

@item @strong{Return:}
an integer, 1 if phi is surjective, 0 if not

@item @strong{Note:}
The algorithm returns 1 iff all the variables of the basering are
contained in the polynomial subalgebra generated by the polynomials
defining phi. Hence, if the basering has local or mixed ordering
or if the preimage ring is a quotient ring (in which case the map
may not be well defined) then the return value 1 means
@*"surjectivity" in this sense.

@end table
@strong{Example:}
@smallexample
@c computed example is_surjective d2t_singular/algebra_lib.doc:378 
LIB "algebra.lib";
ring R = 0,(x,y,z),dp;
ideal i = x, y, x2-y3;
map phi = R,i;                    // a map from R to itself, z->x2-y3
is_surjective(phi);
@expansion{} 0
qring Q = std(ideal(z-x37));
map psi = R, x,y,x2-y3;           // the same map to the quotient ring
is_surjective(psi);
@expansion{} 1
ring S = 0,(a,b,c),dp;
map psi = R,ideal(a,a+b,c-a2+b3); // a map from R to S,
is_surjective(psi);               // x->a, y->a+b, z->c-a2+b3
@expansion{} 1
@c end example is_surjective d2t_singular/algebra_lib.doc:378
@end smallexample
@c ---end content is_surjective---

@c ------------------- is_bijective -------------
@node is_bijective, noetherNormal, is_surjective, algebra_lib
@subsubsection is_bijective
@cindex is_bijective
@c ---content is_bijective---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
is_bijective(phi,pr); phi map to basering, pr preimage ring

@item @strong{Return:}
an integer, 1 if phi is bijective, 0 if not

@item @strong{Note:}
The algorithm checks first injectivity and then surjectivity
To interpret this for local/mixed orderings, or for quotient rings
type help is_surjective; and help is_injective;

@item @strong{Display:}
A comment if printlevel >= voice-1 (default)

@end table
@strong{Example:}
@smallexample
@c computed example is_bijective d2t_singular/algebra_lib.doc:419 
LIB "algebra.lib";
int p = printlevel;  printlevel = 1;
ring R = 0,(x,y,z),dp;
ideal i = x, y, x2-y3;
map phi = R,i;                      // a map from R to itself, z->x2-y3
is_bijective(phi,R);
@expansion{} // map not injective
@expansion{} 0
qring Q = std(z-x2+y3);
is_bijective(ideal(x,y,x2-y3),Q);
@expansion{} 1
ring S = 0,(a,b,c,d),dp;
map psi = R,ideal(a,a+b,c-a2+b3,0); // a map from R to S,
is_bijective(psi,R);                // x->a, y->a+b, z->c-a2+b3
@expansion{} // map injective, but not surjective
@expansion{} 0
qring T = std(d,c-a2+b3);
@expansion{} // ** _ is no standardbasis
map chi = Q,a,b,a2-b3;              // amap between two quotient rings
is_bijective(chi,Q);
@expansion{} 1
printlevel = p;
@c end example is_bijective d2t_singular/algebra_lib.doc:419
@end smallexample
@c ---end content is_bijective---

@c ------------------- noetherNormal -------------
@node noetherNormal, mapIsFinite, is_bijective, algebra_lib
@subsubsection noetherNormal
@cindex noetherNormal
@c ---content noetherNormal---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
noetherNormal(id[,p]); id ideal, p integer

@item @strong{Return:}
@format	
         a list l two ideals, say I,J:
         - I is generated by a subset of the variables with size(I) = dim(id)
         - J defines a map (coordinate change in the basering), such that:
           if we define  map phi=basering,J;
           then k[var(1),...,var(n)]/phi(id) is finite over k[I].
         If p is given, 0<=p<=100, a sparse coordinate change with p percent
         of the matrix entries being 0 (default: p=0 i.e. dense)
@end format

@item @strong{Note:}
Designed for characteristic 0.It works also in char k > 0 if it
terminates,but may result in an infinite loop in small characteristic

@end table
@strong{Example:}
@smallexample
@c computed example noetherNormal d2t_singular/algebra_lib.doc:468 
LIB "algebra.lib";
ring r=0,(x,y,z),dp;
ideal i= xy,xz;
noetherNormal(i);
@expansion{} [1]:
@expansion{}    _[1]=x
@expansion{}    _[2]=2x+y
@expansion{}    _[3]=3x+4y+z
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{}    _[2]=z
@c end example noetherNormal d2t_singular/algebra_lib.doc:468
@end smallexample
@c ---end content noetherNormal---

@c ------------------- mapIsFinite -------------
@node mapIsFinite, finitenessTest, noetherNormal, algebra_lib
@subsubsection mapIsFinite
@cindex mapIsFinite
@c ---content mapIsFinite---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
mapIsFinite(phi,R[,J]); R a ring, phi: R ---> basering a map
J an ideal in the basering, J = 0 if not given

@item @strong{Return:}
1 if R ---> basering/J is finite and 0 else

@end table
@strong{Example:}
@smallexample
@c computed example mapIsFinite d2t_singular/algebra_lib.doc:495 
LIB "algebra.lib";
ring r = 0,(a,b,c),dp;
ring s = 0,(x,y,z),dp;
ideal i= xy;
map phi= r,(xy)^3+x2+z,y2-1,z3;
mapIsFinite(phi,r,i);
@expansion{} 1
@c end example mapIsFinite d2t_singular/algebra_lib.doc:495
@end smallexample
@c ---end content mapIsFinite---

@c ------------------- finitenessTest -------------
@node finitenessTest,, mapIsFinite, algebra_lib
@subsubsection finitenessTest
@cindex finitenessTest
@c ---content finitenessTest---
Procedure from library @code{algebra.lib} (@pxref{algebra_lib}).

@table @asis
@item @strong{Usage:}
finitenessTest(J[,v]); J ideal, v intvec (say v1,...,vr with vi>0)

@item @strong{Return:}
@format
         a list l with l[1] integer, l[2], l[3], l[4] ideals
         - l[1] = 1 if var(v1),...,var(vr) are in l[2] and 0 else
         - l[2] (resp. l[3]) contains those variables which occur,
           (resp. occur not) as pure power in the leading term of one of the
           generators of J,
         - l[4] contains those J[i] for which the leading term is a pure power
           of a variable (which is then in l[2])
         (default: v = [1,2,..,nvars(basering)])
@end format

@item @strong{Theory:}
If J is a standard basis of an ideal generated by x_1 - f_1(y),...,
x_n - f_n with y_j ordered lexicographically and y_j >> x_i, then,
if y_i appears as pure power in the leading term of J[k]. J[k] defines
an integral relation for y_i over the y_(i+1),... and the f's.
Moreover, in this situation, if l[2] = y_1,...,y_r, then K[y_1,...y_r]
is finite over K[f_1..f_n]. If J contains furthermore polynomials
h_j(y), then K[y_1,...y_z]/<h_j> is finite over K[f_1..f_n].

@end table
@strong{Example:}
@smallexample
@c computed example finitenessTest d2t_singular/algebra_lib.doc:541 
LIB "algebra.lib";
ring s = 0,(x,y,z,a,b,c),(lp(3),dp);
ideal i= a -(xy)^3+x2-z, b -y2-1, c -z3;
ideal j = a -(xy)^3+x2-z, b -y2-1, c -z3, xy;
finitenessTest(std(i),1..3);
@expansion{} [1]:
@expansion{}    0
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{}    _[2]=z
@expansion{} [3]:
@expansion{}    _[1]=x
@expansion{}    _[2]=a
@expansion{}    _[3]=b
@expansion{}    _[4]=c
@expansion{} [4]:
@expansion{}    _[1]=z3-c
@expansion{}    _[2]=y2-b+1
finitenessTest(std(j),1..3);
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    _[1]=x
@expansion{}    _[2]=y
@expansion{}    _[3]=z
@expansion{} [3]:
@expansion{}    _[1]=a
@expansion{}    _[2]=b
@expansion{}    _[3]=c
@expansion{} [4]:
@expansion{}    _[1]=z3-c
@expansion{}    _[2]=y2-b+1
@expansion{}    _[3]=x2-z+a
@c end example finitenessTest d2t_singular/algebra_lib.doc:541
@end smallexample
@c ---end content finitenessTest---
@c ----------------------------------------------------------
@node elim_lib, homolog_lib, algebra_lib, Commutative algebra
@subsection elim_lib
@c include of docu for elim.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/elim_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/elim_lib.doc INSTEAD
@c library version: (1.14.2.4,2003/04/16)
@c library file: ../Singular/LIB/elim.lib
@cindex elim.lib
@cindex elim_lib
@table @asis
@item @strong{Library:}
elim.lib
@item @strong{Purpose:}
      Elimination, Saturation and Blowing up

@end table

@strong{Procedures:}
@menu
* blowup0:: create presentation of blownup ring of ideal j
* elim:: variable n..m eliminated from id (ideal/module)
* elim1:: p=product of vars to be eliminated from id
* nselect:: select generators not containing n-th [..m-th] variable
* sat:: saturated quotient of ideal/module id by ideal j
* select:: select generators containing all variables n...m
* select1:: select generators containing one variable n...m
@end menu
@c ---end content LibInfo---

@c ------------------- blowup0 -------------
@node blowup0, elim,, elim_lib
@subsubsection blowup0
@cindex blowup0
@c ---content blowup0---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
blowup0(j[,s1,s2]); j ideal, s1,s2 nonempty strings

@item @strong{Create:}
Create a presentation of the blowup ring of j

@item @strong{Return:}
no return value

@item @strong{Note:}
s1 and s2 are used to give names to the blownup ring and the blownup
ideal (default: s1="j", s2="A")
@*Assume R = char,x(1..n),ord is the basering of j, and s1="j", s2="A"
then the procedure creates a new ring with name Bl_jR
@*(equal to R[A,B,...])
@*Bl_jR = char,(A,B,...,x(1..n)),(dp(k),ord)
@*with k=ncols(j) new variables A,B,... and ordering wp(d1..dk) if j is
homogeneous with deg(j[i])=di resp. dp otherwise for these vars.
If k>26 or size(s2)>1, say s2="A()", the new vars are A(1),...,A(k).
Let j_ be the kernel of the ring map Bl_jR -> R defined by A(i)->j[i],
x(i)->x(i), then the quotient ring Bl_jR/j_ is the blowup ring of j
in R (being isomorphic to R+j+j^2+...). Moreover the procedure creates
a std basis of j_ with name j_ in Bl_jR.
@*This proc uses 'execute' or calls a procedure using 'execute'.

@item @strong{Display:}
printlevel >=0: explain created objects (default)

@end table
@strong{Example:}
@smallexample
@c computed example blowup0 d2t_singular/elim_lib.doc:65 
LIB "elim.lib";
ring R=0,(x,y),dp;
poly f=y2+x3; ideal j=jacob(f);
blowup0(j);
@expansion{} 
@expansion{} // The proc created the ring Bl_jR (equal to R[A,B])
@expansion{} // it contains the ideal j_ , such that
@expansion{} //             Bl_jR/j_ is the blowup ring
@expansion{} // show(Bl_jR); shows this ring.
@expansion{} // Make Bl_jR the basering and see j_ by typing:
@expansion{}    setring Bl_jR;
@expansion{}    j_;
show(Bl_jR);
@expansion{} // ring: (0),(A,B,x,y),(wp(2,1),dp(2),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // j_                   [0]  ideal, 1 generator(s)
setring Bl_jR;
j_;"";
@expansion{} j_[1]=2Ay-3Bx2
@expansion{} 
ring r=32003,(x,y,z),ds;
blowup0(maxideal(1),"m","T()");
@expansion{} 
@expansion{} // The proc created the ring Bl_mr (equal to r[T(1..3)])
@expansion{} // it contains the ideal m_ , such that
@expansion{} //             Bl_mr/m_ is the blowup ring
@expansion{} // show(Bl_mr); shows this ring.
@expansion{} // Make Bl_mr the basering and see m_ by typing:
@expansion{}    setring Bl_mr;
@expansion{}    m_;
show(Bl_mr);
@expansion{} // ring: (32003),(T(1),T(2),T(3),x,y,z),(wp(1,1,1),ds(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // m_                   [0]  ideal, 3 generator(s)
setring Bl_mr;
m_;
@expansion{} m_[1]=T(1)y-T(2)x
@expansion{} m_[2]=T(1)z-T(3)x
@expansion{} m_[3]=T(2)z-T(3)y
kill Bl_jR, Bl_mr;
@c end example blowup0 d2t_singular/elim_lib.doc:65
@end smallexample
@c ---end content blowup0---

@c ------------------- elim -------------
@node elim, elim1, blowup0, elim_lib
@subsubsection elim
@cindex elim
@c ---content elim---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
elim(id,n,m); id ideal/module, n,m integers

@item @strong{Returns:}
ideal/module obtained from id by eliminating variables n..m

@item @strong{Note:}
no special monomial ordering is required, result is a SB with
respect to ordering dp (resp. ls) if the first var not to be
eliminated belongs to a -p (resp. -s) block ordering
@*This proc uses 'execute' or calls a procedure using 'execute'.

@end table
@strong{Example:}
@smallexample
@c computed example elim d2t_singular/elim_lib.doc:106 
LIB "elim.lib";
ring r=0,(x,y,u,v,w),dp;
ideal i=x-u,y-u2,w-u3,v-x+y3;
elim(i,3,4);
@expansion{} _[1]=y2-xw
@expansion{} _[2]=xy-w
@expansion{} _[3]=x2-y
module m=i*gen(1)+i*gen(2);
m=elim(m,3,4);show(m);
@expansion{} // module, 6 generator(s)
@expansion{} [y2-xw]
@expansion{} [0,y2-xw]
@expansion{} [xy-w]
@expansion{} [0,xy-w]
@expansion{} [x2-y]
@expansion{} [0,x2-y]
@c end example elim d2t_singular/elim_lib.doc:106
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:115
@menu
See also:
* elim1::
* eliminate::
@end menu
@c end inserted refs from d2t_singular/elim_lib.doc:115

@c ---end content elim---

@c ------------------- elim1 -------------
@node elim1, nselect, elim, elim_lib
@subsubsection elim1
@cindex elim1
@c ---content elim1---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
elim1(id,p); id ideal/module, p product of vars to be eliminated

@item @strong{Return:}
ideal/module obtained from id by eliminating vars occurring in poly

@item @strong{Note:}
no special monomial ordering is required, result is a SB with
respect to ordering dp (resp. ls) if the first var not to be
eliminated belongs to a -p (resp. -s) block ordering
@*This proc uses 'execute' or calls a procedure using 'execute'.

@end table
@strong{Example:}
@smallexample
@c computed example elim1 d2t_singular/elim_lib.doc:144 
LIB "elim.lib";
ring r=0,(x,y,t,s,z),dp;
ideal i=x-t,y-t2,z-t3,s-x+y3;
elim1(i,ts);
@expansion{} _[1]=y2-xz
@expansion{} _[2]=xy-z
@expansion{} _[3]=x2-y
module m=i*gen(1)+i*gen(2);
m=elim1(m,st); show(m);
@expansion{} // module, 6 generator(s)
@expansion{} [y2-xz]
@expansion{} [0,y2-xz]
@expansion{} [xy-z]
@expansion{} [0,xy-z]
@expansion{} [x2-y]
@expansion{} [0,x2-y]
@c end example elim1 d2t_singular/elim_lib.doc:144
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:153
@menu
See also:
* elim::
* eliminate::
@end menu
@c end inserted refs from d2t_singular/elim_lib.doc:153

@c ---end content elim1---

@c ------------------- nselect -------------
@node nselect, sat, elim1, elim_lib
@subsubsection nselect
@cindex nselect
@c ---content nselect---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
nselect(id,n[,m]); id a module or ideal, n, m integers

@item @strong{Return:}
generators of id not containing the variable n [up to m]

@end table
@strong{Example:}
@smallexample
@c computed example nselect d2t_singular/elim_lib.doc:176 
LIB "elim.lib";
ring r=0,(x,y,t,s,z),(c,dp);
ideal i=x-y,y-z2,z-t3,s-x+y3;
nselect(i,3);
@expansion{} _[1]=x-y
@expansion{} _[2]=-z2+y
@expansion{} _[3]=y3-x+s
module m=i*(gen(1)+gen(2));
show(m);
@expansion{} // module, 4 generator(s)
@expansion{} [x-y,x-y]
@expansion{} [-z2+y,-z2+y]
@expansion{} [-t3+z,-t3+z]
@expansion{} [y3-x+s,y3-x+s]
show(nselect(m,3,4));
@expansion{} // module, 2 generator(s)
@expansion{} [x-y,x-y]
@expansion{} [-z2+y,-z2+y]
@c end example nselect d2t_singular/elim_lib.doc:176
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:186
@menu
See also:
* select::
* select1::
@end menu
@c end inserted refs from d2t_singular/elim_lib.doc:186

@c ---end content nselect---

@c ------------------- sat -------------
@node sat, select, nselect, elim_lib
@subsubsection sat
@cindex sat
@c ---content sat---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
sat(id,j); id=ideal/module, j=ideal

@item @strong{Return:}
list of an ideal/module [1] and an integer [2]:
@*[1] = saturation of id with respect to j (= union_(k=1...) of id:j^k)
[2] = saturation exponent (= min( k | id:j^k = id:j^(k+1) ))

@item @strong{Note:}
[1] is a standard basis in the basering

@item @strong{Display:}
saturation exponent during computation if printlevel >=1

@end table
@strong{Example:}
@smallexample
@c computed example sat d2t_singular/elim_lib.doc:217 
LIB "elim.lib";
int p      = printlevel;
ring r     = 2,(x,y,z),dp;
poly F     = x5+y5+(x-y)^2*xyz;
ideal j    = jacob(F);
sat(j,maxideal(1));
@expansion{} [1]:
@expansion{}    _[1]=x3+x2y+xy2+y3
@expansion{}    _[2]=y4+x2yz+y3z
@expansion{}    _[3]=x2y2+x2yz+y3z
@expansion{} [2]:
@expansion{}    4
printlevel = 2;
sat(j,maxideal(2));
@expansion{} // compute quotient 1
@expansion{} // compute quotient 2
@expansion{} // compute quotient 3
@expansion{} // saturation becomes stable after 2 iteration(s)
@expansion{} 
@expansion{} [1]:
@expansion{}    _[1]=x3+x2y+xy2+y3
@expansion{}    _[2]=y4+x2yz+y3z
@expansion{}    _[3]=x2y2+x2yz+y3z
@expansion{} [2]:
@expansion{}    2
printlevel = p;
@c end example sat d2t_singular/elim_lib.doc:217
@end smallexample
@c ---end content sat---

@c ------------------- select -------------
@node select, select1, sat, elim_lib
@subsubsection select
@cindex select
@c ---content select---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
select(id,n[,m]); id ideal/module, n, m integers

@item @strong{Return:}
generators of id containing the variable n [all variables up to m]

@item @strong{Note:}
use 'select1' for selecting generators containing at least one of the
variables between n and m

@end table
@strong{Example:}
@smallexample
@c computed example select d2t_singular/elim_lib.doc:252 
LIB "elim.lib";
ring r=0,(x,y,t,s,z),(c,dp);
ideal i=x-y,y-z2,z-t3,s-x+y3;
ideal j=select(i,1);
j;
@expansion{} j[1]=x-y
@expansion{} j[2]=y3-x+s
module m=i*(gen(1)+gen(2));
m;
@expansion{} m[1]=[x-y,x-y]
@expansion{} m[2]=[-z2+y,-z2+y]
@expansion{} m[3]=[-t3+z,-t3+z]
@expansion{} m[4]=[y3-x+s,y3-x+s]
select(m,1,2);
@expansion{} _[1]=[x-y,x-y]
@expansion{} _[2]=[y3-x+s,y3-x+s]
@c end example select d2t_singular/elim_lib.doc:252
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:263
@menu
See also:
* nselect::
* select1::
@end menu
@c end inserted refs from d2t_singular/elim_lib.doc:263

@c ---end content select---

@c ------------------- select1 -------------
@node select1,, select, elim_lib
@subsubsection select1
@cindex select1
@c ---content select1---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
select1(id,n[,m]); id ideal/module, n, m integers

@item @strong{Return:}
generators of id containing the variable n
@*[at least one of the variables up to m]

@item @strong{Note:}
use 'select' for selecting generators containing all the
variables between n and m

@end table
@strong{Example:}
@smallexample
@c computed example select1 d2t_singular/elim_lib.doc:291 
LIB "elim.lib";
ring r=0,(x,y,t,s,z),(c,dp);
ideal i=x-y,y-z2,z-t3,s-x+y3;
ideal j=select1(i,1);
j;
@expansion{} j[1]=x-y
@expansion{} j[2]=y3-x+s
module m=i*(gen(1)+gen(2));
m;
@expansion{} m[1]=[x-y,x-y]
@expansion{} m[2]=[-z2+y,-z2+y]
@expansion{} m[3]=[-t3+z,-t3+z]
@expansion{} m[4]=[y3-x+s,y3-x+s]
select1(m,1,2);
@expansion{} _[1]=[x-y,x-y]
@expansion{} _[2]=[-z2+y,-z2+y]
@expansion{} _[3]=[y3-x+s,y3-x+s]
@c end example select1 d2t_singular/elim_lib.doc:291
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:302
@menu
See also:
* nselect::
* select::
@end menu
@c end inserted refs from d2t_singular/elim_lib.doc:302

@c ---end content select1---
@c ----------------------------------------------------------
@node homolog_lib, mprimdec_lib, elim_lib, Commutative algebra
@subsection homolog_lib
@c include of docu for homolog.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/homolog_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/homolog_lib.doc INSTEAD
@c library version: (1.15.2.2,2002/10/07)
@c library file: ../Singular/LIB/homolog.lib
@cindex homolog.lib
@cindex homolog_lib
@table @asis
@item @strong{Library:}
homolog.lib
@item @strong{Purpose:}
   Procedures for Homological Algebra
@item @strong{Authors:}
Gert-Martin Greuel, greuel@@mathematik.uni-kl.de,
@* Bernd Martin, martin@@math.tu-cottbus.de
@* Christoph Lossen, lossen@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* cup:: cup: Ext^1(M',M') x Ext^1() --> Ext^2()
* cupproduct:: cup: Ext^p(M',N') x Ext^q(N',P') --> Ext^p+q(M',P')
* depth:: depth(I,M'), I ideal, M module, M'=coker(M)
* Ext_R:: Ext^k(M',R), M module, R basering, M'=coker(M)
* Ext:: Ext^k(M',N'), M,N modules, M'=coker(M), N'=coker(N)
* fitting:: n-th Fitting ideal of M'=coker(M), M module, n int
* flatteningStrat:: Flattening stratification of M'=coker(M), M module
* Hom:: Hom(M',N'), M,N modules, M'=coker(M), N'=coker(N)
* homology:: ker(B)/im(A), homology of complex R^k--A->M'--B->N'
* isCM:: test if coker(M) is Cohen-Macaulay, M module
* isFlat:: test if coker(M) is flat, M module
* isLocallyFree:: test if coker(M) is locally free of constant rank r
* isReg:: test if I is coker(M)-sequence, I ideal, M module
* kernel:: ker(M'--A->N') M,N modules, A matrix
* kohom:: Hom(R^k,A), A matrix over basering R
* kontrahom:: Hom(A,R^k), A matrix over basering R
* KoszulHomology:: n-th Koszul homology H_n(I,coker(M)), I=ideal
* tensorMod:: Tensor product of modules M'=coker(M), N'=coker(N)
* Tor:: Tor_k(M',N'), M,N modules, M'=coker(M), N'=coker(N)
@end menu
@c ---end content LibInfo---

@c ------------------- cup -------------
@node cup, cupproduct,, homolog_lib
@subsubsection cup
@cindex cup
@c ---content cup---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
cup(M,[,any,any]); M=module

@item @strong{Compute:}
cup-product Ext^1(M',M') x Ext^1(M',M') ---> Ext^2(M',M'), where
M':=R^m/M, if M in R^m, R basering (i.e. M':=coker(matrix(M))).
@* If called with >= 2 arguments: compute symmetrized cup-product

@item @strong{Assume:}
all Ext's are finite dimensional

@item @strong{Return:}
- if called with 1 argument: matrix, the columns of the output present
the coordinates of b_i&b_j with respect to a kbase of Ext^2, where
b_1,b_2,... is a kbase of Ext^1 and & denotes cup product;@*
- if called with 2 arguments: matrix, the columns of the output
present the coordinates of (1/2)(b_i&b_j + b_j&b_i) with respect to
a kbase of Ext^2;
@*- if called with 3 arguments: list,
@format
      L[1] = matrix see above (symmetric case, for >=2 arguments)
      L[2] = matrix of kbase of Ext^1
      L[3] = matrix of kbase of Ext^2
@end format

@item @strong{Note:}
printlevel >=1; shows what is going on.
@*printlevel >=2; shows result in another representation.
@* For computing cupproduct of M itself, apply proc to syz(M)!

@end table
@strong{Example:}
@smallexample
@c computed example cup d2t_singular/homolog_lib.doc:83 
LIB "homolog.lib";
int p      = printlevel;
ring  rr   = 32003,(x,y,z),(dp,C);
ideal  I   = x4+y3+z2;
qring  o   = std(I);
module M   = [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
print(cup(M));
@expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
print(cup(M,1));
@expansion{} 0,1,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,1,0,0,0,0,0,0 
// 2nd EXAMPLE  (shows what is going on)
printlevel = 3;
ring   r   = 0,(x,y),(dp,C);
ideal  i   = x2-y3;
qring  q   = std(i);
module M   = [-x,y],[-y2,x];
print(cup(M));
@expansion{} // vdim (Ext^1) = 2
@expansion{} // kbase of Ext^1(M,M)
@expansion{} //  - the columns present the kbase elements in Hom(F(1),F(0))
@expansion{} //  - F(*) a free resolution of M
@expansion{} -1,0,
@expansion{} 0, y,
@expansion{} 0, 1,
@expansion{} -1,0 
@expansion{} // lift kbase of Ext^1:
@expansion{} //  - the columns present liftings of kbase elements into Hom(F(2),F(1))
@expansion{} //  - F(*) a free resolution of M 
@expansion{} 1,0,
@expansion{} 0,y,
@expansion{} 0,1,
@expansion{} 1,0 
@expansion{} // vdim (Ext^2) = 2
@expansion{} // kbase of Ext^2(M,M)
@expansion{} //  - the columns present the kbase elements in Hom(F(2),F(0))
@expansion{} //  - F(*) is a a free resolution of M 
@expansion{} -1,0,
@expansion{} 0, y,
@expansion{} 0, 1,
@expansion{} -1,0 
@expansion{} // matrix of cup-products (in Ext^2)
@expansion{} 0,-1,0, 0,y,
@expansion{} 0,0, -y,y,0,
@expansion{} 0,0, -1,1,0,
@expansion{} 0,-1,0, 0,y 
@expansion{} ////// end level 2 //////
@expansion{} // the associated matrices of the bilinear mapping 'cup' 
@expansion{} // corresponding to the kbase elements of Ext^2(M,M) are shown,
@expansion{} //  i.e. the rows of the final matrix are written as matrix of
@expansion{} //  a bilinear form on Ext^1 x Ext^1
@expansion{} //-----component 1:
@expansion{} 0,1,
@expansion{} 0,0 
@expansion{} //-----component 2:
@expansion{} 0, 0,
@expansion{} -1,1 
@expansion{} ////// end level 3 //////
@expansion{} 0,1,0, 0,0,
@expansion{} 0,0,-1,1,0 
printlevel = p;
@c end example cup d2t_singular/homolog_lib.doc:83
@end smallexample
@c ---end content cup---

@c ------------------- cupproduct -------------
@node cupproduct, depth, cup, homolog_lib
@subsubsection cupproduct
@cindex cupproduct
@c ---content cupproduct---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
cupproduct(M,N,P,p,q[,any]); M,N,P modules, p,q integers

@item @strong{Compute:}
cup-product Ext^p(M',N') x Ext^q(N',P') ---> Ext^p+q(M',P'),
where M':=R^m/M, if M in R^m, R basering (i.e. M':=coker(matrix(M)))

@item @strong{Assume:}
all Ext's are of finite dimension

@item @strong{Return:}
- if called with 5 arguments: matrix of the associated linear map
Ext^p (tensor) Ext^q --> Ext^p+q, i.e. the columns of <matrix>
present the coordinates of the cup products (b_i & c_j) with respect
to a kbase of Ext^p+q (b_i resp. c_j are the choosen bases of Ext^p,
resp. Ext^q).@*
- if called with 6 arguments: list L,
@format
      L[1] = matrix (see above)
      L[2] = matrix of kbase of Ext^p(M',N')
      L[3] = matrix of kbase of Ext^q(N',P')
      L[4] = matrix of kbase of Ext^p+q(N',P')
@end format

@item @strong{Note:}
printlevel >=1; shows what is going on.
@*printlevel >=2; shows the result in another representation.@*
For computing the cupproduct of M,N itself, apply proc to syz(M),
syz(N)!

@end table
@strong{Example:}
@smallexample
@c computed example cupproduct d2t_singular/homolog_lib.doc:145 
LIB "homolog.lib";
int p      = printlevel;
ring  rr   = 32003,(x,y,z),(dp,C);
ideal  I   = x4+y3+z2;
qring  o   = std(I);
module M   = [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
print(cupproduct(M,M,M,1,3));
@expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
printlevel = 3;
list l     = (cupproduct(M,M,M,1,3,"any"));
@expansion{} // vdim Ext(M,N) = 4
@expansion{} // kbase of Ext^p(M,N)
@expansion{} //  - the columns present the kbase elements in Hom(F(p),G(0))
@expansion{} //  - F(*),G(*) are free resolutions of M and N
@expansion{} 0, 0, 1, 0,  
@expansion{} 0, y, 0, 0,  
@expansion{} 1, 0, 0, 0,  
@expansion{} 0, 0, 0, y,  
@expansion{} 0, -1,0, 0,  
@expansion{} 0, 0, x2,0,  
@expansion{} 0, 0, 0, -x2,
@expansion{} 1, 0, 0, 0,  
@expansion{} 0, 0, 0, -1, 
@expansion{} -1,0, 0, 0,  
@expansion{} 0, 1, 0, 0,  
@expansion{} 0, 0, 1, 0,  
@expansion{} -1,0, 0, 0,  
@expansion{} 0, 0, 0, x2y,
@expansion{} 0, 0, x2,0,  
@expansion{} 0, -y,0, 0   
@expansion{} // vdim Ext(N,P) = 4
@expansion{} // kbase of Ext(N,P):
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 0, 0,  y,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, -1,0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, 0, 0,  -x2,
@expansion{} 0, 0, -x2,0,  
@expansion{} 0, 0, 0,  -1, 
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 1, 0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} -1,0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, 0, x2, 0,  
@expansion{} 0, 0, 0,  -x2y
@expansion{} // kbase of Ext^q(N,P)
@expansion{} //  - the columns present the kbase elements in Hom(G(q),H(0))
@expansion{} //  - G(*),H(*) are free resolutions of N and P
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 0, 0,  y,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, -1,0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, 0, 0,  -x2,
@expansion{} 0, 0, -x2,0,  
@expansion{} 0, 0, 0,  -1, 
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 1, 0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} -1,0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, 0, x2, 0,  
@expansion{} 0, 0, 0,  -x2y
@expansion{} // vdim Ext(M,P) = 4
@expansion{} // kbase of Ext^p+q(M,P)
@expansion{} //  - the columns present the kbase elements in Hom(F(p+q),H(0))
@expansion{} //  - F(*),H(*) are free resolutions of M and P
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 0, 0,  y,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, -1,0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, 0, 0,  -x2,
@expansion{} 0, 0, -x2,0,  
@expansion{} 0, 0, 0,  -1, 
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 1, 0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} -1,0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, 0, x2, 0,  
@expansion{} 0, 0, 0,  -x2y
@expansion{} // lifting of kbase of Ext^p(M,N)
@expansion{} //  - the columns present liftings of kbase elements in Hom(F(p+q),G(q))
@expansion{} 1,0, 0, 0,  
@expansion{} 0,-y,0, 0,  
@expansion{} 0,0, x2,0,  
@expansion{} 0,0, 0, x2y,
@expansion{} 0,1, 0, 0,  
@expansion{} 1,0, 0, 0,  
@expansion{} 0,0, 0, -x2,
@expansion{} 0,0, x2,0,  
@expansion{} 0,0, -1,0,  
@expansion{} 0,0, 0, y,  
@expansion{} 1,0, 0, 0,  
@expansion{} 0,y, 0, 0,  
@expansion{} 0,0, 0, -1, 
@expansion{} 0,0, -1,0,  
@expansion{} 0,-1,0, 0,  
@expansion{} 1,0, 0, 0   
@expansion{} // matrix of cup-products (in Ext^p+q)
@expansion{} 0,0, 0, -1, 0,   0, 0, 0,   y,   1,  0,  0,  0,  0,   y,   0,  0,   
@expansion{} 0,0, 0, 0,  y,   0, 0, y,   0,   0,  -y, 0,  0,  y,   0,   0,  0,   
@expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
@expansion{} 0,0, y, 0,  0,   -y,0, 0,   0,   0,  0,  0,  x2y,0,   0,   x2y,0,   
@expansion{} 0,0, 1, 0,  0,   -1,0, 0,   0,   0,  0,  0,  x2, 0,   0,   x2, 0,   
@expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
@expansion{} 0,0, 0, 0,  -x2, 0, 0, -x2, 0,   0,  x2, 0,  0,  -x2, 0,   0,  0,   
@expansion{} 0,0, 0, x2, 0,   0, 0, 0,   -x2y,-x2,0,  0,  0,  0,   -x2y,0,  0,   
@expansion{} 0,0, 0, 0,  -1,  0, 0, -1,  0,   0,  1,  0,  0,  -1,  0,   0,  0,   
@expansion{} 0,0, 0, -1, 0,   0, 0, 0,   y,   1,  0,  0,  0,  0,   y,   0,  0,   
@expansion{} 0,0, -1,0,  0,   1, 0, 0,   0,   0,  0,  0,  -x2,0,   0,   -x2,0,   
@expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
@expansion{} 0,-1,0, 0,  0,   0, -y,0,   0,   0,  0,  -x2,0,  0,   0,   0,  x2y, 
@expansion{} 0,0, y, 0,  0,   -y,0, 0,   0,   0,  0,  0,  x2y,0,   0,   x2y,0,   
@expansion{} 0,0, 0, -x2,0,   0, 0, 0,   x2y, x2, 0,  0,  0,  0,   x2y, 0,  0,   
@expansion{} 0,0, 0, 0,  -x2y,0, 0, -x2y,0,   0,  x2y,0,  0,  -x2y,0,   0,  0    
@expansion{} ////// end level 2 //////
@expansion{} // the associated matrices of the bilinear mapping 'cup' 
@expansion{} // corresponding to the kbase elements of Ext^p+q(M,P) are shown,
@expansion{} //  i.e. the rows of the final matrix are written as matrix of
@expansion{} //  a bilinear form on Ext^p x Ext^q
@expansion{} //----component 1:
@expansion{} 0,1,0,0,
@expansion{} 0,0,0,0,
@expansion{} 0,0,0,0,
@expansion{} 0,0,0,0 
@expansion{} //----component 2:
@expansion{} 0,0,-1,0,
@expansion{} 0,1,0, 0,
@expansion{} 0,0,0, 0,
@expansion{} 0,0,0, 0 
@expansion{} //----component 3:
@expansion{} 0,0,0,-1,
@expansion{} 0,0,0,0, 
@expansion{} 0,1,0,0, 
@expansion{} 0,0,0,0  
@expansion{} //----component 4:
@expansion{} 0,0,0, 0,
@expansion{} 1,0,0, 1,
@expansion{} 0,0,-1,0,
@expansion{} 0,1,0, 0 
@expansion{} ////// end level 3 //////
show(l[1]);show(l[2]);
@expansion{} // matrix, 4x17
@expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
@expansion{} // matrix, 16x4
@expansion{} 0, 0, 1, 0,  
@expansion{} 0, y, 0, 0,  
@expansion{} 1, 0, 0, 0,  
@expansion{} 0, 0, 0, y,  
@expansion{} 0, -1,0, 0,  
@expansion{} 0, 0, x2,0,  
@expansion{} 0, 0, 0, -x2,
@expansion{} 1, 0, 0, 0,  
@expansion{} 0, 0, 0, -1, 
@expansion{} -1,0, 0, 0,  
@expansion{} 0, 1, 0, 0,  
@expansion{} 0, 0, 1, 0,  
@expansion{} -1,0, 0, 0,  
@expansion{} 0, 0, 0, x2y,
@expansion{} 0, 0, x2,0,  
@expansion{} 0, -y,0, 0   
printlevel = p;
@c end example cupproduct d2t_singular/homolog_lib.doc:145
@end smallexample
@c ---end content cupproduct---

@c ------------------- depth -------------
@node depth, Ext_R, cupproduct, homolog_lib
@subsubsection depth
@cindex depth
@c ---content depth---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
depth(M,[I]); M module, I ideal

@item @strong{Return:}
int,
@*- if called with 1 argument: the depth of M'=coker(M) w.r.t. the
maxideal in the basering (which is then assumed to be local)@*
- if called with 2 arguments: the depth of M'=coker(M) w.r.t. the
ideal I.

@item @strong{Note:}
procedure makes use of KoszulHomology.

@end table
@strong{Example:}
@smallexample
@c computed example depth d2t_singular/homolog_lib.doc:185 
LIB "homolog.lib";
ring R=0,(x,y,z),dp;
ideal I=x2,xy,yz;
module M=0;
depth(M,I);   // depth(<x2,xy,yz>,Q[x,y,z])
@expansion{} 2
ring r=0,(x,y,z),ds;  // local ring
matrix M[2][2]=x,xy,1+yz,0;
print(M);
@expansion{} x,   xy,
@expansion{} 1+yz,0  
depth(M);     // depth(maxideal,coker(M))
@expansion{} 2
ideal I=x;
depth(M,I);   // depth(<x>,coker(M))
@expansion{} 0
I=x+z;
depth(M,I);   // depth(<x+z>,coker(M))
@expansion{} 1
@c end example depth d2t_singular/homolog_lib.doc:185
@end smallexample
@c ---end content depth---

@c ------------------- Ext_R -------------
@node Ext_R, Ext, depth, homolog_lib
@subsubsection Ext_R
@cindex Ext_R
@c ---content Ext_R---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
Ext_R(v,M[,p]); v int resp. intvec , M module, p int

@item @strong{Compute:}
A presentation of Ext^k(M',R); for k=v[1],v[2],..., M'=coker(M).
Let
@smallexample
  0 <-- M' <-- F0 <-M-- F1 <-- F2 <-- ...
@end smallexample
be a free resolution of M'. If
@smallexample
        0 --> F0* -A1-> F1* -A2-> F2* -A3-> ...
@end smallexample
is the dual sequence, Fi*=Hom(Fi,R), then Ext^k = ker(Ak+1)/im(Ak)
is presented as in the following exact sequences:
@smallexample
    R^p --syz(Ak+1)-> Fk* ---Ak+1---->  Fk+1* ,
    R^q ----Ext^k---> R^p --syz(Ak+1)-> Fk*/im(Ak).
@end smallexample
Hence, Ext^k=modulo(syz(Ak+1),Ak) presents Ext^k(M',R).

@item @strong{Return:}
- module Ext, a presentation of Ext^k(M',R) if v is of type int@*
- a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.@*
- In case of a third argument of type int return a list l:
@format
     l[1] = module Ext^k resp. list of Ext^k
     l[2] = SB of Ext^k resp. list of SB of Ext^k
     l[3] = matrix resp. list of matrices, each representing a kbase of Ext^k 
              (if finite dimensional)
@end format

@item @strong{Display:}
printlevel >=0: (affine) dimension of Ext^k for each k (default)
printlevel >=1: Ak, Ak+1 and kbase of Ext^k in Fk*

@item @strong{Note:}
In order to compute Ext^k(M,R) use the command Ext_R(k,syz(M));
or the 2 commands: list L=mres(M,2); Ext_R(k,L[2]);

@end table
@strong{Example:}
@smallexample
@c computed example Ext_R d2t_singular/homolog_lib.doc:254 
LIB "homolog.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 0,(x,y,z),dp;
ideal i    = x2y,y2z,z3x;
module E   = Ext_R(1,i);    //computes Ext^1(r/i,r)
@expansion{} // Computing Ext^1:
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
@expansion{} // then F1*-->F2* is given by:
@expansion{} x2, -yz,0,  
@expansion{} 0,  z3, -xy,
@expansion{} xz2,0,  -y2 
@expansion{} // and F0*-->F1* is given by:
@expansion{} y2z,
@expansion{} x2y,
@expansion{} xz3 
@expansion{} 
@expansion{} // dimension of Ext^1:  -1
@expansion{} 
is_zero(E);
@expansion{} 1
qring R    = std(x2+yz);
intvec v   = 0,2;
printlevel = 2;             //shows what is going on
ideal i    = x,y,z;         //computes Ext^i(r/(x,y,z),r/(x2+yz)), i=0,2
list L     = Ext_R(v,i,1);  //over the qring R=r/(x2+yz), std and kbase
@expansion{} // Computing Ext^0:
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
@expansion{} // then F0*-->F1* is given by:
@expansion{} z,
@expansion{} y,
@expansion{} x 
@expansion{} // and F-1*-->F0* is given by:
@expansion{} 0
@expansion{} 
@expansion{} // dimension of Ext^0:  -1
@expansion{} 
@expansion{} // columns of matrix are kbase of Ext^0 in F0*:
@expansion{} 0
@expansion{} 
@expansion{} // Computing Ext^2:
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
@expansion{} // then F2*-->F3* is given by:
@expansion{} x,-y,z, 0,
@expansion{} z,x, 0, z,
@expansion{} 0,0, x, y,
@expansion{} 0,0, -z,x 
@expansion{} // and F1*-->F2* is given by:
@expansion{} y,-z,0, 
@expansion{} x,0, -z,
@expansion{} 0,x, -y,
@expansion{} 0,z, x  
@expansion{} 
@expansion{} // dimension of Ext^2:  0
@expansion{} // vdim of Ext^2:       1
@expansion{} 
@expansion{} // columns of matrix are kbase of Ext^2 in F2*:
@expansion{} x, 
@expansion{} -z,
@expansion{} 0, 
@expansion{} 0  
@expansion{} 
printlevel = p;
@c end example Ext_R d2t_singular/homolog_lib.doc:254
@end smallexample
@c ---end content Ext_R---

@c ------------------- Ext -------------
@node Ext, fitting, Ext_R, homolog_lib
@subsubsection Ext
@cindex Ext
@c ---content Ext---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
Ext(v,M,N[,any]); v int resp. intvec, M,N modules

@item @strong{Compute:}
A presentation of Ext^k(M',N'); for k=v[1],v[2],... where
M'=coker(M) and N'=coker(N). Let
@smallexample
       0 <-- M' <-- F0 <-M-- F1 <-- F2 <--... ,   
       0 <-- N' <-- G0 <--N- G1
@end smallexample
be a free resolution of M', resp. a presentation of N'. Consider
the commutative diagram
@smallexample
           0                  0                  0
           |^                 |^                 |^
   --> Hom(Fk-1,N') -Ak-> Hom(Fk,N') -Ak+1-> Hom(Fk+1,N')
           |^                 |^                 |^
   --> Hom(Fk-1,G0) -Ak-> Hom(Fk,G0) -Ak+1-> Hom(Fk+1,G0)
                              |^                 |^
                              |C                 |B
                          Hom(Fk,G1) ------> Hom(Fk+1,G1)

      (Ak,Ak+1 induced by M and B,C induced by N).
@end smallexample
Let K=modulo(Ak+1,B), J=module(Ak)+module(C) and Ext=modulo(K,J),
then we have exact sequences
@smallexample
    R^p --K-> Hom(Fk,G0) --Ak+1-> Hom(Fk+1,G0)/im(B),

    R^q -Ext-> R^p --K-> Hom(Fk,G0)/(im(Ak)+im(C)).
@end smallexample
Hence, Ext presents Ext^k(M',N').

@item @strong{Return:}
- module Ext, a presentation of Ext^k(M',N') if v is of type int@*
- a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.@*
- In case of a third argument of any type return a list l:
@format
             l[1] = module Ext/list of Ext^k
             l[2] = SB of Ext/list of SB of Ext^k
             l[3] = matrix/list of matrices, each representing a kbase of Ext^k
                       (if finite dimensional)
@end format

@item @strong{Display:}
printlevel >=0: dimension, vdim of Ext^k for each k (default).
@* printlevel >=1: matrices Ak, Ak+1 and kbase of Ext^k in Hom(Fk,G0)
(if finite dimensional)

@item @strong{Note:}
In order to compute Ext^k(M,N) use the command Ext(k,syz(M),syz(N));
or: list P=mres(M,2); list Q=mres(N,2); Ext(k,P[2],Q[2]);

@end table
@strong{Example:}
@smallexample
@c computed example Ext d2t_singular/homolog_lib.doc:336 
LIB "homolog.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 0,(x,y),dp;
ideal i    = x2-y3;
ideal j    = x2-y5;
list E     = Ext(0..2,i,j);    // Ext^k(r/i,r/j) for k=0,1,2 over r
@expansion{} // Computing Ext^0 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F0,G0)-->Hom(F1,G0) is given by:
@expansion{} y3-x2
@expansion{} // and Hom(F-1,G0) + Hom(F0,G1)-->Hom(F0,G0) is given by:
@expansion{} 0,-y5+x2
@expansion{} 
@expansion{} // dimension of Ext^0:  -1
@expansion{} 
@expansion{} // Computing Ext^1 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F1,G0)-->Hom(F2,G0) is given by:
@expansion{} 0
@expansion{} // and Hom(F0,G0) + Hom(F1,G1)-->Hom(F1,G0) is given by:
@expansion{} y3-x2,-y5+x2
@expansion{} 
@expansion{} // dimension of Ext^1:  0
@expansion{} // vdim of Ext^1:       10
@expansion{} 
@expansion{} // Computing Ext^2 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F2,G0)-->Hom(F3,G0) is given by:
@expansion{} 1
@expansion{} // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
@expansion{} 0,-y5+x2
@expansion{} 
@expansion{} // dimension of Ext^2:  -1
@expansion{} 
qring R    = std(i);
ideal j    = fetch(r,j);
module M   = [-x,y],[-y2,x];
printlevel = 2;
module E1  = Ext(1,M,j);       // Ext^1(R^2/M,R/j) over R=r/i
@expansion{} // Computing Ext^1 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F1,G0)-->Hom(F2,G0) is given by:
@expansion{} x, -y,
@expansion{} y2,-x 
@expansion{} // and Hom(F0,G0) + Hom(F1,G1)-->Hom(F1,G0) is given by:
@expansion{} x, -y,-y5+x2,0,    
@expansion{} y2,-x,0,     -y5+x2
@expansion{} 
@expansion{} // dimension of Ext^1:  -1
@expansion{} 
list l     = Ext(4,M,M,1);     // Ext^4(R^2/M,R^2/M) over R=r/i
@expansion{} // Computing Ext^4 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F4,G0)-->Hom(F5,G0) is given by:
@expansion{} x, -y,0, 0, 
@expansion{} y2,-x,0, 0, 
@expansion{} 0, 0, x, -y,
@expansion{} 0, 0, y2,-x 
@expansion{} // and Hom(F3,G0) + Hom(F4,G1)-->Hom(F4,G0) is given by:
@expansion{} x, -y,0, 0, -x,0, -y2,0,  
@expansion{} y2,-x,0, 0, 0, -x,0,  -y2,
@expansion{} 0, 0, x, -y,y, 0, x,  0,  
@expansion{} 0, 0, y2,-x,0, y, 0,  x   
@expansion{} 
@expansion{} // dimension of Ext^4:  0
@expansion{} // vdim of Ext^4:       2
@expansion{} 
@expansion{} // columns of matrix are kbase of Ext^4 in Hom(F4,G0)
@expansion{} 1,0,
@expansion{} 0,y,
@expansion{} 0,1,
@expansion{} 1,0 
@expansion{} 
@expansion{} // element 1 of kbase of Ext^4 in Hom(F4,G0)
@expansion{} // as matrix: F4-->G0
@expansion{} 1,0,
@expansion{} 0,1 
@expansion{} // element 2 of kbase of Ext^4 in Hom(F4,G0)
@expansion{} // as matrix: F4-->G0
@expansion{} 0,y,
@expansion{} 1,0 
@expansion{} 
printlevel = p;
@c end example Ext d2t_singular/homolog_lib.doc:336
@end smallexample
@c ---end content Ext---

@c ------------------- fitting -------------
@node fitting, flatteningStrat, Ext, homolog_lib
@subsubsection fitting
@cindex fitting
@c ---content fitting---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
fitting (M,n); M module, n int

@item @strong{Return:}
ideal, (standard basis of) n-th Fitting ideal of M'=coker(M).

@end table
@strong{Example:}
@smallexample
@c computed example fitting d2t_singular/homolog_lib.doc:372 
LIB "homolog.lib";
ring R=0,x(0..4),dp;
matrix M[2][4]=x(0),x(1),x(2),x(3),x(1),x(2),x(3),x(4);
print(M);
@expansion{} x(0),x(1),x(2),x(3),
@expansion{} x(1),x(2),x(3),x(4) 
fitting(M,-1);
@expansion{} _[1]=0
fitting(M,0);
@expansion{} _[1]=x(3)^2-x(2)*x(4)
@expansion{} _[2]=x(2)*x(3)-x(1)*x(4)
@expansion{} _[3]=x(1)*x(3)-x(0)*x(4)
@expansion{} _[4]=x(2)^2-x(0)*x(4)
@expansion{} _[5]=x(1)*x(2)-x(0)*x(3)
@expansion{} _[6]=x(1)^2-x(0)*x(2)
fitting(M,1);
@expansion{} _[1]=x(4)
@expansion{} _[2]=x(3)
@expansion{} _[3]=x(2)
@expansion{} _[4]=x(1)
@expansion{} _[5]=x(0)
fitting(M,2);
@expansion{} _[1]=1
@c end example fitting d2t_singular/homolog_lib.doc:372
@end smallexample
@c ---end content fitting---

@c ------------------- flatteningStrat -------------
@node flatteningStrat, Hom, fitting, homolog_lib
@subsubsection flatteningStrat
@cindex flatteningStrat
@c ---content flatteningStrat---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
flatteningStrat(M); M module

@item @strong{Return:}
list of ideals.
@*The list entries L[1],...,L[r] describe the flattening stratification
of M'=coker(M): setting L[0]=0, L[r+1]=1, the flattening
stratification is given by the open sets Spec(A/V(L[i-1])) \ V(L[i]),
i=1,...,r+1 (A = basering).

@item @strong{Note:}
for more information see the book 'A Singular Introduction to
Commutative Algebra' (by Greuel/Pfister, Springer 2002).

@end table
@strong{Example:}
@smallexample
@c computed example flatteningStrat d2t_singular/homolog_lib.doc:410 
LIB "homolog.lib";
ring A = 0,x(0..4),dp;
// presentation matrix:
matrix M[2][4] = x(0),x(1),x(2),x(3),x(1),x(2),x(3),x(4);
list L = flatteningStrat(M);
L;
@expansion{} [1]:
@expansion{}    _[1]=x(3)^2-x(2)*x(4)
@expansion{}    _[2]=x(2)*x(3)-x(1)*x(4)
@expansion{}    _[3]=x(1)*x(3)-x(0)*x(4)
@expansion{}    _[4]=x(2)^2-x(0)*x(4)
@expansion{}    _[5]=x(1)*x(2)-x(0)*x(3)
@expansion{}    _[6]=x(1)^2-x(0)*x(2)
@expansion{} [2]:
@expansion{}    _[1]=x(4)
@expansion{}    _[2]=x(3)
@expansion{}    _[3]=x(2)
@expansion{}    _[4]=x(1)
@expansion{}    _[5]=x(0)
@c end example flatteningStrat d2t_singular/homolog_lib.doc:410
@end smallexample
@c ---end content flatteningStrat---

@c ------------------- Hom -------------
@node Hom, homology, flatteningStrat, homolog_lib
@subsubsection Hom
@cindex Hom
@c ---content Hom---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
Hom(M,N,[any]); M,N=modules

@item @strong{Compute:}
A presentation of Hom(M',N'), M'=coker(M), N'=coker(N) as follows:
let
@smallexample
   F1 --M-> F0 -->M' --> 0,    G1 --N-> G0 --> N' --> 0  
@end smallexample
be presentations of M' and N'. Consider
@smallexample
                                  0               0
                                  |^              |^
       0 --> Hom(M',N') ----> Hom(F0,N') ----> Hom(F1,N')
                                  |^              |^
  (A:  induced by M)          Hom(F0,G0) --A-> Hom(F1,G0)
                                  |^              |^
  (B,C:induced by N)              |C              |B
                              Hom(F0,G1) ----> Hom(F1,G1)

@end smallexample
Let D=modulo(A,B) and Hom=modulo(D,C), then we have exact sequences
@smallexample
   R^p  --D-> Hom(F0,G0) --A-> Hom(F1,G0)/im(B),

 R^q -Hom-> R^p --D-> Hom(F0,G0)/im(C) --A-> Hom(F1,G0)/im(B).
@end smallexample
Hence Hom presents Hom(M',N')

@item @strong{Return:}
module Hom, a presentation of Hom(M',N'), resp., in case of
3 arguments, a list l (of size <=3):
@format
           - l[1] = Hom
           - l[2] = SB of Hom
           - l[3] = kbase of coker(Hom) (if finite dimensional, not 0),
                    represented by elements in Hom(F0,G0) via mapping D
@end format

@item @strong{Display:}
printlevel >=0: (affine) dimension of Hom (default)
@* printlevel >=1: D and C and kbase of coker(Hom) in Hom(F0,G0)
@* printlevel >=2: elements of kbase of coker(Hom) as matrix :F0-->G0

@item @strong{Note:}
DISPLAY is as described only for a direct call of 'Hom'. Calling 'Hom'
from another proc has the same effect as decreasing printlevel by 1.

@end table
@strong{Example:}
@smallexample
@c computed example Hom d2t_singular/homolog_lib.doc:480 
LIB "homolog.lib";
int p     = printlevel;
printlevel= 1;   //in 'example proc' printlevel has to be increased by 1
ring r    = 0,(x,y),dp;
ideal i   = x2-y3,xy;
qring q   = std(i);
ideal i   = fetch(r,i);
module M  = [-x,y],[-y2,x],[x3];
module H  = Hom(M,i);
@expansion{} // dimension of Hom:  0
@expansion{} // vdim of Hom:       5
@expansion{} 
@expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
@expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
@expansion{} y,x, 0,
@expansion{} x,y2,x2
@expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
@expansion{} -y3+x2,0,     xy,0,
@expansion{} 0,     -y3+x2,0, xy
@expansion{} 
print(H);
@expansion{} 0, x, 0,y2,0, 
@expansion{} y, 0, 0,-x,x2,
@expansion{} -1,-1,x,0, 0  
printlevel= 2;
list L    = Hom(M,i,1);"";
@expansion{} // dimension of Hom:  0
@expansion{} // vdim of Hom:       5
@expansion{} 
@expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
@expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
@expansion{} y,x, 0,
@expansion{} x,y2,x2
@expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
@expansion{} -y3+x2,0,     xy,0,
@expansion{} 0,     -y3+x2,0, xy
@expansion{} 
@expansion{} // element 1 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} y2,xy
@expansion{} // element 2 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} y,x
@expansion{} // element 3 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} x2,xy2
@expansion{} // element 4 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} x,y2
@expansion{} // element 5 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} 0,x2
@expansion{} 
printlevel=1;
ring s    = 3,(x,y,z),(c,dp);
ideal i   = jacob(ideal(x2+y5+z4));
qring rq=std(i);
matrix M[2][2]=xy,x3,5y,4z,x2;
matrix N[3][2]=x2,x,y3,3xz,x2z,z;
print(M);
@expansion{} xy,x3,
@expansion{} -y,z  
print(N);
@expansion{} x2, x,
@expansion{} y3, 0,
@expansion{} x2z,z 
list l=Hom(M,N,1);
@expansion{} // dimension of Hom:  0
@expansion{} // vdim of Hom:       16
@expansion{} 
@expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
@expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
@expansion{} 0,0, 0,0, 0,   0,0,   1,
@expansion{} 0,0, 0,0, 0,   0,y3z2,0,
@expansion{} 0,0, 0,0, 0,   1,0,   0,
@expansion{} 0,0, 0,y3,y2z2,0,0,   0,
@expansion{} 0,0, 1,0, 0,   0,0,   0,
@expansion{} z,y3,0,0, 0,   0,0,   0 
@expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
@expansion{} x2, 0,  x,0,
@expansion{} 0,  x2, 0,x,
@expansion{} y3, 0,  0,0,
@expansion{} 0,  y3, 0,0,
@expansion{} x2z,0,  z,0,
@expansion{} 0,  x2z,0,z 
@expansion{} 
@expansion{} // columns of matrix are kbase of Hom in Hom(F0,G0)
@expansion{} 0, 0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,0,   
@expansion{} 0, 0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,y3z2,
@expansion{} 0, 0, 0, 0,0,0,   y2z2,yz2,z2,y2z,yz,z,y2,y,1,0,   
@expansion{} 0, 0, 0, 0,0,y2z2,0,   0,  0, 0,  0, 0,0, 0,0,0,   
@expansion{} 0, y3,y2,y,1,0,   0,   0,  0, 0,  0, 0,0, 0,0,0,   
@expansion{} y3,0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,0    
printlevel = p;
@c end example Hom d2t_singular/homolog_lib.doc:480
@end smallexample
@c ---end content Hom---

@c ------------------- homology -------------
@node homology, isCM, Hom, homolog_lib
@subsubsection homology
@cindex homology
@c ---content homology---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
homology(A,B,M,N);

@item @strong{Compute:}
Let M and N be submodules of R^m and R^n presenting M'=R^m/M, N'=R^n/N
(R=basering) and let A,B matrices inducing maps
@smallexample
    R^k --A--> R^m --B--> R^n.
@end smallexample
Compute a presentation of the module
@smallexample
    ker(B)/im(A) := ker(M'/im(A) --B--> N'/im(BM)+im(BA)).
@end smallexample
If B induces a map M'-->N' (i.e BM=0) and if im(A) is contained in
ker(B) (that is, BA=0) then ker(B)/im(A) is the homology of the
complex
@smallexample
    R^k--A-->M'--B-->N'. 
@end smallexample

@item @strong{Return:}
module H, a presentation of ker(B)/im(A).

@item @strong{Note:}
homology returns a free module of rank m if ker(B)=im(A).

@end table
@strong{Example:}
@smallexample
@c computed example homology d2t_singular/homolog_lib.doc:544 
LIB "homolog.lib";
ring r;
ideal id=maxideal(4);
qring qr=std(id);
module N=maxideal(3)*freemodule(2);
module M=maxideal(2)*freemodule(2);
module B=[2x,0],[x,y],[z2,y];
module A=M;
module H=homology(A,B,M,N);
H=std(H);
// dimension of homology:
dim(H);
@expansion{} 0
// vector space dimension: 
vdim(H);
@expansion{} 19
ring s=0,x,ds;
qring qs=std(x4);
module A=[x];
module B=A;
module M=[x3];
module N=M;
homology(A,B,M,N);
@expansion{} _[1]=gen(1)
@c end example homology d2t_singular/homolog_lib.doc:544
@end smallexample
@c ---end content homology---

@c ------------------- isCM -------------
@node isCM, isFlat, homology, homolog_lib
@subsubsection isCM
@cindex isCM
@c ---content isCM---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
isCM(M); M module

@item @strong{Return:}
1 if M'=coker(M) is Cohen-Macaulay;@*
0 if this is not the case.

@item @strong{Assume:}
basering is local.

@end table
@strong{Example:}
@smallexample
@c computed example isCM d2t_singular/homolog_lib.doc:591 
LIB "homolog.lib";
ring R=0,(x,y,z),ds;  // local ring R = Q[x,y,z]_<x,y,z>
module M=xz,yz,z2;   
isCM(M);             // test if R/<xz,yz,z2> is Cohen-Macaulay
@expansion{} 0
M=x2+y2,z7;          // test if R/<x2+y2,z7> is Cohen-Macaulay
isCM(M);
@expansion{} 1
@c end example isCM d2t_singular/homolog_lib.doc:591
@end smallexample
@c ---end content isCM---

@c ------------------- isFlat -------------
@node isFlat, isLocallyFree, isCM, homolog_lib
@subsubsection isFlat
@cindex isFlat
@c ---content isFlat---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
isFlat(M); M module

@item @strong{Return:}
1 if M'=coker(M) is flat;@*
0 if this is not the case.

@end table
@strong{Example:}
@smallexample
@c computed example isFlat d2t_singular/homolog_lib.doc:620 
LIB "homolog.lib";
ring A = 0,(x,y),dp;
matrix M[3][3] = x-1,y,x,x,x+1,y,x2,xy+x+1,x2+y;
print(M);
@expansion{} x-1,y,     x,  
@expansion{} x,  x+1,   y,  
@expansion{} x2, xy+x+1,x2+y
isFlat(M);             // coker(M) is not flat over A=Q[x,y]
@expansion{} 0
qring B = std(x2+x-y);   // the ring B=Q[x,y]/<x2+x-y>
matrix M = fetch(A,M);
isFlat(M);             // coker(M) is flat over B
@expansion{} 1
setring A;
qring C = std(x2+x+y);   // the ring C=Q[x,y]/<x2+x+y>
matrix M = fetch(A,M);
isFlat(M);             // coker(M) is not flat over C
@expansion{} 0
@c end example isFlat d2t_singular/homolog_lib.doc:620
@end smallexample
@c ---end content isFlat---

@c ------------------- isLocallyFree -------------
@node isLocallyFree, isReg, isFlat, homolog_lib
@subsubsection isLocallyFree
@cindex isLocallyFree
@c ---content isLocallyFree---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
isLocallyFree(M,r); M module, r int

@item @strong{Return:}
1 if M'=coker(M) is locally free of constant rank r;@*
0 if this is not the case.

@end table
@strong{Example:}
@smallexample
@c computed example isLocallyFree d2t_singular/homolog_lib.doc:655 
LIB "homolog.lib";
ring R=0,(x,y,z),dp;
matrix M[2][3];     // the presentation matrix
M=x-1,y-1,z,y-1,x-2,x;
ideal I=fitting(M,0); // 0-th Fitting ideal of coker(M)
qring Q=I;
matrix M=fetch(R,M);
isLocallyFree(M,1); // as R/I-module, coker(M) is locally free of rk 1
@expansion{} 1
isLocallyFree(M,0);
@expansion{} 0
@c end example isLocallyFree d2t_singular/homolog_lib.doc:655
@end smallexample
@c ---end content isLocallyFree---

@c ------------------- isReg -------------
@node isReg, kernel, isLocallyFree, homolog_lib
@subsubsection isReg
@cindex isReg
@c ---content isReg---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
isReg(I,M); I ideal, M module

@item @strong{Return:}
1 if given (ordered) list of generators for I is coker(M)-sequence;@*
0 if this is not the case.

@end table
@strong{Example:}
@smallexample
@c computed example isReg d2t_singular/homolog_lib.doc:687 
LIB "homolog.lib";
ring R = 0,(x,y,z),dp;
ideal I = x*(y-1),y,z*(y-1);
isReg(I,0);             // given list of generators is Q[x,y,z]-sequence
@expansion{} 1
I = x*(y-1),z*(y-1),y;  // change sorting of generators 
isReg(I,0);
@expansion{} 0
ring r = 0,(x,y,z),ds;  // local ring
ideal I=fetch(R,I);
isReg(I,0);             // result independent of sorting of generators
@expansion{} 1
@c end example isReg d2t_singular/homolog_lib.doc:687
@end smallexample
@c ---end content isReg---

@c ------------------- kernel -------------
@node kernel, kohom, isReg, homolog_lib
@subsubsection kernel
@cindex kernel
@c ---content kernel---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
kernel(A,M,N);

@item @strong{Compute:}
Let M and N be submodules of R^m and R^n, presenting M'=R^m/M,
N'=R^n/N (R=basering), and let A:R^m-->R^n be a matrix inducing a
map A':M'-->N'. Then kernel(A,M,N); computes a presentation K of
ker(A') as in the commutative diagram:
@smallexample
          ker(A') --->  M' --A'--> N'
             |^         |^         |^
             |          |          |
             R^r  ---> R^m --A--> R^n
             |^         |^         |^
             |K         |M         |N
             |          |          |
             R^s  ---> R^p -----> R^q
@end smallexample

@item @strong{Return:}
module K, a presentation of ker(A':coker(M)->coker(N)).

@end table
@strong{Example:}
@smallexample
@c computed example kernel d2t_singular/homolog_lib.doc:734 
LIB "homolog.lib";
ring r;
module N=[2x,x],[0,y];
module M=maxideal(1)*freemodule(2);
matrix A[2][2]=2x,0,x,y,z2,y;
module K=kernel(A,M,N);
// dimension of kernel:  
dim(std(K));
@expansion{} 0
// vector space dimension of kernel: 
vdim(std(K));
@expansion{} 2
print(K);
@expansion{} z,0,y,0,x,0,
@expansion{} 0,z,0,y,0,x 
@c end example kernel d2t_singular/homolog_lib.doc:734
@end smallexample
@c ---end content kernel---

@c ------------------- kohom -------------
@node kohom, kontrahom, kernel, homolog_lib
@subsubsection kohom
@cindex kohom
@c ---content kohom---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
kohom(A,k); A=matrix, k=integer

@item @strong{Return:}
matrix Hom(R^k,A), i.e. let A be a matrix defining a map F1-->F2
of free R-modules, then the matrix of Hom(R^k,F1)-->Hom(R^k,F2)
is computed (R=basering).

@end table
@strong{Example:}
@smallexample
@c computed example kohom d2t_singular/homolog_lib.doc:769 
LIB "homolog.lib";
ring r;
matrix n[2][3]=x,y,5,z,77,33;
print(kohom(n,3));
@expansion{} x,0,0,y, 0, 0, 5, 0, 0,
@expansion{} 0,x,0,0, y, 0, 0, 5, 0,
@expansion{} 0,0,x,0, 0, y, 0, 0, 5,
@expansion{} z,0,0,77,0, 0, 33,0, 0,
@expansion{} 0,z,0,0, 77,0, 0, 33,0,
@expansion{} 0,0,z,0, 0, 77,0, 0, 33
@c end example kohom d2t_singular/homolog_lib.doc:769
@end smallexample
@c ---end content kohom---

@c ------------------- kontrahom -------------
@node kontrahom, KoszulHomology, kohom, homolog_lib
@subsubsection kontrahom
@cindex kontrahom
@c ---content kontrahom---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
kontrahom(A,k); A=matrix, k=integer

@item @strong{Return:}
matrix Hom(A,R^k), i.e. let A be a matrix defining a map F1-->F2 of
free R-modules, then the matrix of Hom(F2,R^k)-->Hom(F1,R^k) is
computed (R=basering).

@end table
@strong{Example:}
@smallexample
@c computed example kontrahom d2t_singular/homolog_lib.doc:797 
LIB "homolog.lib";
ring r;
matrix n[2][3]=x,y,5,z,77,33;
print(kontrahom(n,3));
@expansion{} x,z, 0,0, 0,0, 
@expansion{} y,77,0,0, 0,0, 
@expansion{} 5,33,0,0, 0,0, 
@expansion{} 0,0, x,z, 0,0, 
@expansion{} 0,0, y,77,0,0, 
@expansion{} 0,0, 5,33,0,0, 
@expansion{} 0,0, 0,0, x,z, 
@expansion{} 0,0, 0,0, y,77,
@expansion{} 0,0, 0,0, 5,33 
@c end example kontrahom d2t_singular/homolog_lib.doc:797
@end smallexample
@c ---end content kontrahom---

@c ------------------- KoszulHomology -------------
@node KoszulHomology, tensorMod, kontrahom, homolog_lib
@subsubsection KoszulHomology
@cindex KoszulHomology
@c ---content KoszulHomology---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Compute:}
A presentation of the p-th Koszul homology module H_p(f_1,...,f_k;M'),
where M'=coker(M) and f_1,...,f_k are the given (ordered list
of generators of the) ideal I. The computed presentation is minimized
via prune. In particular, if H_p(f_1,...,f_k;M')=0 then the
return value is 0.

@item @strong{Return:}
module H, s.th. coker(H) = H_p(f_1,...,f_k;M').

@item @strong{Note:}
size of input ideal has to be <= 20.

@end table
@strong{Example:}
@smallexample
@c computed example KoszulHomology d2t_singular/homolog_lib.doc:830 
LIB "homolog.lib";
ring R=0,x(1..3),dp;
ideal x=maxideal(1);
module M=0;
KoszulHomology(x,M,0);  // H_0(x,R), x=(x_1,x_2,x_3)
@expansion{} _[1]=x(3)*gen(1)
@expansion{} _[2]=x(2)*gen(1)
@expansion{} _[3]=x(1)*gen(1)
KoszulHomology(x,M,1);  // H_1(x,R), x=(x_1,x_2,x_3)
@expansion{} _[1]=0
qring S=std(x(1)*x(2));
module M=0;
ideal x=maxideal(1);
KoszulHomology(x,M,1);
@expansion{} _[1]=-x(3)*gen(1)
@expansion{} _[2]=-x(2)*gen(1)
@expansion{} _[3]=-x(1)*gen(1)
KoszulHomology(x,M,2);
@expansion{} _[1]=0
@c end example KoszulHomology d2t_singular/homolog_lib.doc:830
@end smallexample
@c ---end content KoszulHomology---

@c ------------------- tensorMod -------------
@node tensorMod, Tor, KoszulHomology, homolog_lib
@subsubsection tensorMod
@cindex tensorMod
@c ---content tensorMod---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
tensorMod(M,N); M,N modules

@item @strong{Compute:}
presentation matrix A of the tensor product T of the modules
M'=coker(M), N'=coker(N): if matrix(M) defines a map M: R^r-->R^s and
matrix(N) defines a map N: R^p-->R^q, then A defines a presentation
@smallexample
         R^(sp+rq) --A-> R^(sq)  --> T --> 0 .
@end smallexample

@item @strong{Return:}
matrix A satisfying coker(A) = tensorprod(coker(M),coker(N)) .

@end table
@strong{Example:}
@smallexample
@c computed example tensorMod d2t_singular/homolog_lib.doc:871 
LIB "homolog.lib";
ring A=0,(x,y,z),dp;
matrix M[3][3]=1,2,3,4,5,6,7,8,9;
matrix N[2][2]=x,y,0,z;
print(M);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(N);
@expansion{} x,y,
@expansion{} 0,z 
print(tensorMod(M,N));
@expansion{} x,y,0,0,0,0,1,0,2,0,3,0,
@expansion{} 0,z,0,0,0,0,0,1,0,2,0,3,
@expansion{} 0,0,x,y,0,0,4,0,5,0,6,0,
@expansion{} 0,0,0,z,0,0,0,4,0,5,0,6,
@expansion{} 0,0,0,0,x,y,7,0,8,0,9,0,
@expansion{} 0,0,0,0,0,z,0,7,0,8,0,9 
@c end example tensorMod d2t_singular/homolog_lib.doc:871
@end smallexample
@c ---end content tensorMod---

@c ------------------- Tor -------------
@node Tor,, tensorMod, homolog_lib
@subsubsection Tor
@cindex Tor
@c ---content Tor---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Compute:}
a presentation of Tor_k(M',N'), for k=v[1],v[2],... , where
M'=coker(M) and N'=coker(N): let
@smallexample
       0 <-- M' <-- G0 <-M-- G1                
       0 <-- N' <-- F0 <--N- F1 <-- F2 <--...  
@end smallexample
be a presentation of M', resp. a free resolution of N', and consider
the commutative diagram
@smallexample
          0                    0                    0
          |^                   |^                   |^
  Tensor(M',Fk+1) -Ak+1-> Tensor(M',Fk) -Ak-> Tensor(M',Fk-1)
          |^                   |^                   |^
  Tensor(G0,Fk+1) -Ak+1-> Tensor(G0,Fk) -Ak-> Tensor(G0,Fk-1)
                               |^                   |^
                               |C                   |B
                          Tensor(G1,Fk) ----> Tensor(G1,Fk-1)

       (Ak,Ak+1 induced by N and B,C induced by M).
@end smallexample
Let K=modulo(Ak,B), J=module(C)+module(Ak+1) and Tor=modulo(K,J),
then we have exact sequences
@smallexample
    R^p  --K-> Tensor(G0,Fk) --Ak-> Tensor(G0,Fk-1)/im(B),

    R^q -Tor-> R^p --K-> Tensor(G0,Fk)/(im(C)+im(Ak+1)). 
@end smallexample
Hence, Tor presents Tor_k(M',N').

@item @strong{Return:}
- if v is of type int: module Tor, a presentation of Tor_k(M',N');@*
- if v is of type intvec: a list of Tor_k(M',N') (k=v[1],v[2],...);@*
- in case of a third argument of any type: list l with
@format
     l[1] = module Tor/list of Tor_k(M',N'),
     l[2] = SB of Tor/list of SB of Tor_k(M',N'),
     l[3] = matrix/list of matrices, each representing a kbase of Tor_k(M',N')
                (if finite dimensional), or 0.
@end format

@item @strong{Display:}
printlevel >=0: (affine) dimension of Tor_k for each k (default).
@* printlevel >=1: matrices Ak, Ak+1 and kbase of Tor_k in Tensor(G0,Fk)
(if finite dimensional).

@item @strong{Note:}
In order to compute Tor_k(M,N) use the command Tor(k,syz(M),syz(N));
or: list P=mres(M,2); list Q=mres(N,2); Tor(k,P[2],Q[2]);

@end table
@strong{Example:}
@smallexample
@c computed example Tor d2t_singular/homolog_lib.doc:944 
LIB "homolog.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 0,(x,y),dp;
ideal i    = x2,y;
ideal j    = x;
list E     = Tor(0..2,i,j);    // Tor_k(r/i,r/j) for k=0,1,2 over r
@expansion{} // dimension of Tor_0:  0
@expansion{} // vdim of Tor_0:       1
@expansion{} 
@expansion{} // Computing Tor_1 (help Tor; gives an explanation):
@expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
@expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
@expansion{} // coker(N), then Tensor(G0,F1)-->Tensor(G0,F0) is given by:
@expansion{} x
@expansion{} // and Tensor(G0,F2) + Tensor(G1,F1)-->Tensor(G0,F1) is given by:
@expansion{} 0,x2,y
@expansion{} 
@expansion{} // dimension of Tor_1:  0
@expansion{} // vdim of Tor_1:       1
@expansion{} 
@expansion{} // Computing Tor_2 (help Tor; gives an explanation):
@expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
@expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
@expansion{} // coker(N), then Tensor(G0,F2)-->Tensor(G0,F1) is given by:
@expansion{} 0
@expansion{} // and Tensor(G0,F3) + Tensor(G1,F2)-->Tensor(G0,F2) is given by:
@expansion{} 1,x2,y
@expansion{} 
@expansion{} // dimension of Tor_2:  -1
@expansion{} 
qring R    = std(i);
ideal j    = fetch(r,j);
module M   = [x,0],[0,x];
printlevel = 2;
module E1  = Tor(1,M,j);       // Tor_1(R^2/M,R/j) over R=r/i
@expansion{} // Computing Tor_1 (help Tor; gives an explanation):
@expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
@expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
@expansion{} // coker(N), then Tensor(G0,F1)-->Tensor(G0,F0) is given by:
@expansion{} x,0,
@expansion{} 0,x 
@expansion{} // and Tensor(G0,F2) + Tensor(G1,F1)-->Tensor(G0,F1) is given by:
@expansion{} x,0,x,0,
@expansion{} 0,x,0,x 
@expansion{} 
@expansion{} // dimension of Tor_1:  0
@expansion{} // vdim of Tor_1:       2
@expansion{} 
list l     = Tor(3,M,M,1);     // Tor_3(R^2/M,R^2/M) over R=r/i
@expansion{} // Computing Tor_3 (help Tor; gives an explanation):
@expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
@expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
@expansion{} // coker(N), then Tensor(G0,F3)-->Tensor(G0,F2) is given by:
@expansion{} x,0,0,0,
@expansion{} 0,x,0,0,
@expansion{} 0,0,x,0,
@expansion{} 0,0,0,x 
@expansion{} // and Tensor(G0,F4) + Tensor(G1,F3)-->Tensor(G0,F3) is given by:
@expansion{} x,0,0,0,x,0,0,0,
@expansion{} 0,x,0,0,0,x,0,0,
@expansion{} 0,0,x,0,0,0,x,0,
@expansion{} 0,0,0,x,0,0,0,x 
@expansion{} 
@expansion{} // dimension of Tor_3:  0
@expansion{} // vdim of Tor_3:       4
@expansion{} 
@expansion{} // columns of matrix are kbase of Tor_3 in Tensor(G0,F3)
@expansion{} 1,0,0,0,
@expansion{} 0,1,0,0,
@expansion{} 0,0,1,0,
@expansion{} 0,0,0,1 
@expansion{} 
printlevel = p;
@c end example Tor d2t_singular/homolog_lib.doc:944
@end smallexample
@c ---end content Tor---
@c ----------------------------------------------------------
@node mprimdec_lib, mregular_lib, homolog_lib, Commutative algebra
@subsection mprimdec_lib
@c include of docu for mprimdec.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/mprimdec_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/mprimdec_lib.doc INSTEAD
@c library version: (1.1.2.3,2002/03/19)
@c library file: ../Singular/LIB/mprimdec.lib
@cindex mprimdec.lib
@cindex mprimdec_lib
@table @asis
@item @strong{Library:}
mprimdec.lib
@item @strong{Purpose:}
   procedures for primary decomposition of modules
@item @strong{Authors:}
Alexander Dreyer, dreyer@@mathematik.uni-kl.de; adreyer@@web.de

@item @strong{Remark:}
These procedures are implemented to be used in characteristic 0.
@*They also work in positive characteristic >> 0.
@*In small characteristic and for algebraic extensions, the
procedures via Gianni, Trager, Zacharias may not terminate.

@end table

@strong{Procedures:}
@menu
* separator:: computes a list of separators of prime ideals
* PrimdecA:: (not necessarily minimal) primary decomposition via Shimoyama/Yokoyama (suggested by Graebe)
* PrimdecB:: (not necessarily minimal) primary decomposition for pseudo-primary ideals
* modDec:: minimal primary decomposition via Shimoyama/Yokoyama (suggested by Graebe)
* zeroMod:: minimal zero-dimensional primary decomposition via Gianni, Trager and Zacharias
* GTZmod:: minimal primary decomposition via Gianni, Trager and Zacharias
* dec1var:: primary decomposition for one variable
* annil:: the annihilator of M/N in the basering
* splitting:: splitting to simpler modules
* primTest:: tests whether i is prime or homogeneous
* preComp:: enhanced Version of splitting
* indSet:: lists with varstrings of(in)dependent variables
* GTZopt:: a faster version of GTZmod
* zeroOpt:: a faster version of zeroMod
* clrSBmod:: extracts an minimal SB from a SB
* minSatMod:: minimal saturation of N w.r.t. I
* specialModulesEqual:: checks for equality of standard bases of modules if N1 is contained in N2 or vice versa
* stdModulesEqual:: checks for equality of standard bases
* modulesEqual:: checks for equality of modules
* getData:: extracts oldData and computes the remaining data
@end menu
@c ---end content LibInfo---

@c ------------------- separator -------------
@node separator, PrimdecA,, mprimdec_lib
@subsubsection separator
@cindex separator
@c ---content separator---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
separator(l); list l of prime ideals

@item @strong{Return:}
list sepList;
@*a list of separators of the prime ideals in l,
@*i.e. polynomials p_ij, s.th. p_ij is in l[j],
@*for all l[j] not contained in l[i]
@*but p_ij is not in l[i]

@end table
@strong{Example:}
@smallexample
@c computed example separator d2t_singular/mprimdec_lib.doc:68 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
ideal i=(x2y,xz2,y2z,z3);
list l=minAssGTZ(i);
list sepL=separator(l);
sepL;
@expansion{} [1]:
@expansion{}    x
@expansion{} [2]:
@expansion{}    y
@c end example separator d2t_singular/mprimdec_lib.doc:68
@end smallexample
@c ---end content separator---

@c ------------------- PrimdecA -------------
@node PrimdecA, PrimdecB, separator, mprimdec_lib
@subsubsection PrimdecA
@cindex PrimdecA
@c ---content PrimdecA---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
PrimdecA (N[, i]); module N, int i

@item @strong{Return:}
list l
@*a (not necessarily minimal) primary decomposition of N
computed by a generalized version of
@*the algorithm of Schimoyama/Yokoyama,
@*if i=1 is given, the factorizing Groebner is used
@*to compute the isolated primes.

@end table
@strong{Example:}
@smallexample
@c computed example PrimdecA d2t_singular/mprimdec_lib.doc:101 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1)+ y*gen(2),
x*gen(1)-x2*gen(2);
list l=PrimdecA(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=x*gen(1)+y*gen(2)
@expansion{}       _[2]=x*gen(2)-gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x2+y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=x*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=y*gen(1)
@expansion{}       _[2]=y*gen(2)
@expansion{}       _[3]=x*gen(1)
@expansion{}       _[4]=x*gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=y
@expansion{}       _[2]=x
@c end example PrimdecA d2t_singular/mprimdec_lib.doc:101
@end smallexample
@c ---end content PrimdecA---

@c ------------------- PrimdecB -------------
@node PrimdecB, modDec, PrimdecA, mprimdec_lib
@subsubsection PrimdecB
@cindex PrimdecB
@c ---content PrimdecB---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
PrimdecB (N, p); pseudo-primary module N, isolated prime ideal p

@item @strong{Return:}
list l
@*a (not necessarily minimal) primary decomposition of N

@end table
@strong{Example:}
@smallexample
@c computed example PrimdecB d2t_singular/mprimdec_lib.doc:130 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=y*gen(1),y2*gen(2),yz*gen(2),yx*gen(2);
ideal p=y;
list l=PrimdecB(N,p);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=y*gen(1)
@expansion{}       _[2]=y*gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=y*gen(1)
@expansion{}       _[2]=y*gen(2)
@expansion{}       _[3]=x*gen(1)
@expansion{}       _[4]=x*gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=y
@expansion{}       _[2]=x
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=z*gen(1)
@expansion{}       _[2]=z*gen(2)
@expansion{}       _[3]=y*gen(1)
@expansion{}       _[4]=x*gen(1)
@expansion{}       _[5]=x*gen(2)
@expansion{}       _[6]=y2*gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{}       _[2]=y
@expansion{}       _[3]=x
@c end example PrimdecB d2t_singular/mprimdec_lib.doc:130
@end smallexample
@c ---end content PrimdecB---

@c ------------------- modDec -------------
@node modDec, zeroMod, PrimdecB, mprimdec_lib
@subsubsection modDec
@cindex modDec
@c ---content modDec---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
modDec (N[, i]); module N, int i

@item @strong{Return:}
list l
@*a minimal primary decomposition of N
@*computed by an generalized version of
@*the algorithm of Schimoyama/Yokoyama,
@*if i=1 is given, the factorizing Groebner is used

@end table
@strong{Example:}
@smallexample
@c computed example modDec d2t_singular/mprimdec_lib.doc:162 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1)+ y*gen(2),
x*gen(1)-x2*gen(2);
list l=modDec(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=x*gen(1)+y*gen(2)
@expansion{}       _[2]=x*gen(2)-gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x2+y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=x*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x
@c end example modDec d2t_singular/mprimdec_lib.doc:162
@end smallexample
@c ---end content modDec---

@c ------------------- zeroMod -------------
@node zeroMod, GTZmod, modDec, mprimdec_lib
@subsubsection zeroMod
@cindex zeroMod
@c ---content zeroMod---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
zeroMod (N[, check]); zero-dimensional module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of a zero-dimensional module N,
computed by a generalized version of the algorithm
@*of Gianni, Trager and Zacharias

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example zeroMod d2t_singular/mprimdec_lib.doc:197 
LIB "mprimdec.lib";
ring r=0,z,dp;
module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
list l=zeroMod(N);
@expansion{} 2
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(3)
@expansion{}       _[3]=z*gen(2)-gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z-1
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=gen(3)
@expansion{}       _[3]=z*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}       _[3]=z*gen(3)+gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@c end example zeroMod d2t_singular/mprimdec_lib.doc:197
@end smallexample
@c ---end content zeroMod---

@c ------------------- GTZmod -------------
@node GTZmod, dec1var, zeroMod, mprimdec_lib
@subsubsection GTZmod
@cindex GTZmod
@c ---content GTZmod---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
GTZmod (N[, check]); module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of the module N,
@*computed by a generalized version of the algorithm
@*of Gianny, Trager and Zacharias

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example GTZmod d2t_singular/mprimdec_lib.doc:231 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1)+ y*gen(2),
x*gen(1)-x2*gen(2);
list l=GTZmod(N);
@expansion{} 2
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=x*gen(1)+y*gen(2)
@expansion{}       _[2]=x*gen(2)-gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x2+y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=x*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x
@c end example GTZmod d2t_singular/mprimdec_lib.doc:231
@end smallexample
@c ---end content GTZmod---

@c ------------------- dec1var -------------
@node dec1var, annil, GTZmod, mprimdec_lib
@subsubsection dec1var
@cindex dec1var
@c ---content dec1var---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
dec1var (N); zero-dimensional module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of a submodule N of R^s
if nvars(R)=1

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example dec1var d2t_singular/mprimdec_lib.doc:265 
LIB "mprimdec.lib";
ring r=0,z,dp;
module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
list l=dec1var(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(3)
@expansion{}       _[3]=z*gen(2)-gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z-1
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=gen(3)
@expansion{}       _[3]=z*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}       _[3]=z*gen(3)+gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@c end example dec1var d2t_singular/mprimdec_lib.doc:265
@end smallexample
@c ---end content dec1var---

@c ------------------- annil -------------
@node annil, splitting, dec1var, mprimdec_lib
@subsubsection annil
@cindex annil
@c ---content annil---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
annil(N); module N

@item @strong{Return:}
ideal ann=std(quotient(N,freemodule(nrows(N))));
@*the annihilator of M/N in the basering

@item @strong{Note:}
ann is a std basis in the basering

@end table
@strong{Example:}
@smallexample
@c computed example annil d2t_singular/mprimdec_lib.doc:296 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1), y*gen(2);
ideal ann=annil(N);
ann;
@expansion{} ann[1]=xy
@c end example annil d2t_singular/mprimdec_lib.doc:296
@end smallexample
@c ---end content annil---

@c ------------------- splitting -------------
@node splitting, primTest, annil, mprimdec_lib
@subsubsection splitting
@cindex splitting
@c ---content splitting---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
splitting(N[,check[, ann]]); module N, module check, ideal ann

@item @strong{Return:}
(l, check) list l, module check
@*the elements of l consists of a triple with
@*[1] of type module [2] and [3] of type ideal
@*s.th. the intersection of the modules is equal to the
zero-dimensional module N, furthermore l[j][3]=annil(l[j][1])
if l[j][2]!=0 then the module l[j][1] is primary
@*with associated prime l[j][2],
@*and check=intersect(check, l[j][1]) is computed

@item @strong{Note:}
if the parameter check is given, only components not containing
check are computed; if ann is given, ann is used instead of annil(N)

@end table
@strong{Example:}
@smallexample
@c computed example splitting d2t_singular/mprimdec_lib.doc:334 
LIB "mprimdec.lib";
ring r=0,z,lp;
module N=z*gen(1), (z+1)*gen(2);
N=std(N);
list l; module check;
(l, check)=splitting(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=z*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{}    [3]:
@expansion{}       _[1]=z
@expansion{}    [4]:
@expansion{}       _[1]=z
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=z*gen(2)+gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@expansion{}    [3]:
@expansion{}       _[1]=z+1
@expansion{}    [4]:
@expansion{}       _[1]=z+1
check;
@expansion{} check[1]=z*gen(2)+gen(2)
@expansion{} check[2]=z*gen(1)
@c end example splitting d2t_singular/mprimdec_lib.doc:334
@end smallexample
@c ---end content splitting---

@c ------------------- primTest -------------
@node primTest, preComp, splitting, mprimdec_lib
@subsubsection primTest
@cindex primTest
@c ---content primTest---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
primTest(i[, p]); a zero-dimensional ideal i, irreducible poly p in i

@item @strong{Return:}
if i neither is prime nor is homogeneous then ideal(0) is returned,
else radical(i)

@end table
@strong{Example:}
@smallexample
@c computed example primTest d2t_singular/mprimdec_lib.doc:365 
LIB "mprimdec.lib";
ring r=0,(x,y,z),lp;
ideal i=x+1,y-1,z;
i=std(i);
ideal primId=primTest(i,z);
primId;
@expansion{} primId[1]=z
@expansion{} primId[2]=y-1
@expansion{} primId[3]=x+1
i=x,z2,yz,y2;
i=std(i);
primId=primTest(i);
primId;
@expansion{} primId[1]=x
@expansion{} primId[2]=y
@expansion{} primId[3]=z
@c end example primTest d2t_singular/mprimdec_lib.doc:365
@end smallexample
@c ---end content primTest---

@c ------------------- preComp -------------
@node preComp, indSet, primTest, mprimdec_lib
@subsubsection preComp
@cindex preComp
@c ---content preComp---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
preComp(N,check[, ann]); module N, module check, ideal ann

@item @strong{Return:}
(l, check) list l, module check
@*the elements of l consists of a triple with
@*[1] of type module [2] and [3] of type ideal
@*s.th. the intersection of the modules is equal to the
zero-dimensional module N, furthermore l[j][3]=annil(l[j][1])
if l[j][2]!=0 then the module l[j][1] is primary
@*with associated prime l[j][2],
@*and check=intersect(check, l[j][1]) is computed

@item @strong{Note:}
only components not containing check are computed;
@*if ann is given, ann is used instead of annil(N)

@end table
@strong{Example:}
@smallexample
@c computed example preComp d2t_singular/mprimdec_lib.doc:408 
LIB "mprimdec.lib";
ring r=0,z,lp;
module N=z*gen(1), (z+1)*gen(2);
N=std(N);
list l; module check;
(l, check)=preComp(N,freemodule(2));
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=z*gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{}    [3]:
@expansion{}       _[1]=z
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=z*gen(2)+gen(2)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@expansion{}    [3]:
@expansion{}       _[1]=z+1
check;
@expansion{} check[1]=z*gen(1)
@expansion{} check[2]=z*gen(2)+gen(2)
@c end example preComp d2t_singular/mprimdec_lib.doc:408
@end smallexample
@c ---end content preComp---

@c ------------------- indSet -------------
@node indSet, GTZopt, preComp, mprimdec_lib
@subsubsection indSet
@cindex indSet
@c ---content indSet---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
indSet(i); i ideal

@item @strong{Return:}
list with two entrees
@*both are lists of new varstrings with the dependent variables
the independent set, the ordstring with the corresp. block ordering,
and the integer where the independent set starts in the varstring

@item @strong{Note:}
the first entry gives the strings for all maximal independent sets
the second gives the strings for the independent sets,
@*which cannot be enhanced

@end table
@strong{Example:}
@smallexample
@c computed example indSet d2t_singular/mprimdec_lib.doc:446 
LIB "mprimdec.lib";
ring s1=(0,x,y),(a,b,c,d,e,f,g),lp;
ideal i=ea-fbg,fa+be,ec-fdg,fc+de;
i=std(i);
list  l=indSet(i);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       [1]:
@expansion{}          e,f
@expansion{}       [2]:
@expansion{}          a,b,c,d,g
@expansion{}       [3]:
@expansion{}          (C,dp(2),dp)
@expansion{}       [4]:
@expansion{}          5
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       [1]:
@expansion{}          a,b,c,d
@expansion{}       [2]:
@expansion{}          e,f,g
@expansion{}       [3]:
@expansion{}          (C,dp(4),dp)
@expansion{}       [4]:
@expansion{}          3
@expansion{}    [2]:
@expansion{}       [1]:
@expansion{}          a,c,e
@expansion{}       [2]:
@expansion{}          b,d,f,g
@expansion{}       [3]:
@expansion{}          (C,dp(3),dp)
@expansion{}       [4]:
@expansion{}          4
@c end example indSet d2t_singular/mprimdec_lib.doc:446
@end smallexample
@c ---end content indSet---

@c ------------------- GTZopt -------------
@node GTZopt, zeroOpt, indSet, mprimdec_lib
@subsubsection GTZopt
@cindex GTZopt
@c ---content GTZopt---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
GTZopt (N[, check]); module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of the module N,
@*computed by a generalized and optimized version of
@*the algorithm of Gianny, Trager and Zacharias

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example GTZopt d2t_singular/mprimdec_lib.doc:481 
LIB "mprimdec.lib";
ring r=0,(x,y,z),dp;
module N=x*gen(1)+ y*gen(2),
x*gen(1)-x2*gen(2);
list l=GTZopt(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=x*gen(1)+y*gen(2)
@expansion{}       _[2]=x*gen(2)-gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x2+y
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=x*gen(1)
@expansion{}    [2]:
@expansion{}       _[1]=x
@c end example GTZopt d2t_singular/mprimdec_lib.doc:481
@end smallexample
@c ---end content GTZopt---

@c ------------------- zeroOpt -------------
@node zeroOpt, clrSBmod, GTZopt, mprimdec_lib
@subsubsection zeroOpt
@cindex zeroOpt
@c ---content zeroOpt---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
zeroOpt (N[, check]); zero-dimensional module N[, module check]

@item @strong{Return:}
list l
@*the minimal primary decomposition of a zero-dimensional module N,
computed by a generalized and optimized version of the algorithm
of Gianny, Trager and Zacharias

@item @strong{Note:}
if the parameter check is given, only components
@*not containing check are computed

@end table
@strong{Example:}
@smallexample
@c computed example zeroOpt d2t_singular/mprimdec_lib.doc:516 
LIB "mprimdec.lib";
ring r=0,z,dp;
module N=z*gen(1),(z-1)*gen(2),(z+1)*gen(3);
list l=zeroOpt(N);
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=z*gen(2)-gen(2)
@expansion{}       _[3]=gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z-1
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=z*gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}       _[3]=gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(1)
@expansion{}       _[2]=gen(2)
@expansion{}       _[3]=z*gen(3)+gen(3)
@expansion{}    [2]:
@expansion{}       _[1]=z+1
@c end example zeroOpt d2t_singular/mprimdec_lib.doc:516
@end smallexample
@c ---end content zeroOpt---

@c ------------------- clrSBmod -------------
@node clrSBmod, minSatMod, zeroOpt, mprimdec_lib
@subsubsection clrSBmod
@cindex clrSBmod
@c ---content clrSBmod---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
clrSBmod(N); N module which is SB ordered by monomial ordering

@item @strong{Return:}
module = minimal SB

@end table
@strong{Example:}
@smallexample
@c computed example clrSBmod d2t_singular/mprimdec_lib.doc:543 
LIB "mprimdec.lib";
ring  r = (0,a,b),(x,y,z),dp;
module N1=ax2+y,a2x+y,bx;
module N2=clrSBmod(N1);
N2;
@expansion{} N2[1]=(a)*x2*gen(1)+y*gen(1)
@expansion{} N2[2]=(b)*x*gen(1)
@c end example clrSBmod d2t_singular/mprimdec_lib.doc:543
@end smallexample
@c ---end content clrSBmod---

@c ------------------- minSatMod -------------
@node minSatMod, specialModulesEqual, clrSBmod, mprimdec_lib
@subsubsection minSatMod
@cindex minSatMod
@c ---content minSatMod---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
minSatMod(N, I); module N, ideal I

@item @strong{Return:}
list with 2 elements:
@*[1]=sat(N,product(I))[1],
@*[2]=p, the polynomial of minimal degree s.th. [1]=quotient(N,p)

@end table
@strong{Example:}
@smallexample
@c computed example minSatMod d2t_singular/mprimdec_lib.doc:572 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),dp;
module N=xy*gen(1);
ideal h=yz,z2;
list l=minSatMod(N,h);
l;
@expansion{} [1]:
@expansion{}    _[1]=x*gen(1)
@expansion{} [2]:
@expansion{}    y
@c end example minSatMod d2t_singular/mprimdec_lib.doc:572
@end smallexample
@c ---end content minSatMod---

@c ------------------- specialModulesEqual -------------
@node specialModulesEqual, stdModulesEqual, minSatMod, mprimdec_lib
@subsubsection specialModulesEqual
@cindex specialModulesEqual
@c ---content specialModulesEqual---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
specialModulesEqual(N1, N2) N1, N2 standard bases of modules,
s.th. N1 is contained in N2 or vice versa

@item @strong{Return:}
int i
@*if (N1==N2) then i=1
@*else i=0

@end table
@strong{Example:}
@smallexample
@c computed example specialModulesEqual d2t_singular/mprimdec_lib.doc:603 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),dp;
module N1=x*freemodule(2);
module N2=xy*freemodule(2);
int i=specialModulesEqual(N1,N2);
i;
@expansion{} 0
N2=N1;
i=specialModulesEqual(N1,N2);
i;
@expansion{} 1
@c end example specialModulesEqual d2t_singular/mprimdec_lib.doc:603
@end smallexample
@c ---end content specialModulesEqual---

@c ------------------- stdModulesEqual -------------
@node stdModulesEqual, modulesEqual, specialModulesEqual, mprimdec_lib
@subsubsection stdModulesEqual
@cindex stdModulesEqual
@c ---content stdModulesEqual---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
stdModulesEqual(N1, N2) N1, N2 standard bases of modules,

@item @strong{Return:}
int i
@*if (N1==N2) then i=1
@*else i=0

@end table
@strong{Example:}
@smallexample
@c computed example stdModulesEqual d2t_singular/mprimdec_lib.doc:636 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),dp;
module N1=x*freemodule(2);
module N2=xy*freemodule(2);
int i=stdModulesEqual(N1,N2);
i;
@expansion{} 0
N2=N1;
i=stdModulesEqual(N1,N2);
i;
@expansion{} 1
@c end example stdModulesEqual d2t_singular/mprimdec_lib.doc:636
@end smallexample
@c ---end content stdModulesEqual---

@c ------------------- modulesEqual -------------
@node modulesEqual, getData, stdModulesEqual, mprimdec_lib
@subsubsection modulesEqual
@cindex modulesEqual
@c ---content modulesEqual---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
modulesEqual(N1, N2) N1, N2 modules,

@item @strong{Return:}
int i
@*if (N1==N2) then i=1
@*else i=0

@end table
@strong{Example:}
@smallexample
@c computed example modulesEqual d2t_singular/mprimdec_lib.doc:669 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),dp;
module N1=x*freemodule(2);
module N2=xy*freemodule(2);
int i=modulesEqual(N1,N2);
i;
@expansion{} 0
N2=N1;
i=modulesEqual(N1,N2);
i;
@expansion{} 1
@c end example modulesEqual d2t_singular/mprimdec_lib.doc:669
@end smallexample
@c ---end content modulesEqual---

@c ------------------- getData -------------
@node getData,, modulesEqual, mprimdec_lib
@subsubsection getData
@cindex getData
@c ---content getData---
Procedure from library @code{mprimdec.lib} (@pxref{mprimdec_lib}).

@table @asis
@item @strong{Usage:}
getData(N, l[, noCheck]); module N, list l[, int noCheck]

@item @strong{Return:}
(ann, check, M, checked)
@*ideal ann, module check, M, int checked

if l[1] is contained in N [and noCheck is not given]
@*then checked=1, ann=ideal(0), check=0, M=0;
@*else checked=0, M=freemodule(nrows(N)); check=l[1]
@*(resp. check=M if l is an empty list) and
@*if size(l)>1 then ann=l[2] else ann is the annihilator of M/N.

@item @strong{Note:}
ann is a std basis in the basering

@end table
@strong{Example:}
@smallexample
@c computed example getData d2t_singular/mprimdec_lib.doc:710 
LIB "mprimdec.lib";
ring  r = 0,(x,y,z),lp;
module N=x*gen(1),y*gen(2);
N=std(N);
ideal ann; module check, M; int checked; list l;
(ann, check, M, checked)=getData(N,l);
ann; check; M; checked;
@expansion{} ann[1]=xy
@expansion{} check[1]=gen(1)
@expansion{} check[2]=gen(2)
@expansion{} M[1]=gen(1)
@expansion{} M[2]=gen(2)
@expansion{} 0
l=list(check,ann);
(ann, check, M, checked)=getData(N,l);
ann; check; M; checked;
@expansion{} ann[1]=xy
@expansion{} check[1]=gen(1)
@expansion{} check[2]=gen(2)
@expansion{} M[1]=gen(1)
@expansion{} M[2]=gen(2)
@expansion{} 0
l=list(N);
(ann, check, M, checked)=getData(N,l);
ann; check; M; checked;
@expansion{} ann[1]=0
@expansion{} check[1]=0
@expansion{} M[1]=0
@expansion{} 1
@c end example getData d2t_singular/mprimdec_lib.doc:710
@end smallexample
@c ---end content getData---
@c ----------------------------------------------------------
@node mregular_lib, normal_lib, mprimdec_lib, Commutative algebra
@subsection mregular_lib
@c include of docu for mregular.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/mregular_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/mregular_lib.doc INSTEAD
@c library version: (1.6.2.1,2002/02/20)
@c library file: ../Singular/LIB/mregular.lib
@cindex mregular.lib
@cindex mregular_lib
@table @asis
@item @strong{Library:}
mregular.lib
@item @strong{Purpose:}
   Castelnuovo-Mumford Regularity of CM-Schemes and Curves
@item @strong{Authors:}
I.Bermejo, ibermejo@@ull.es
@* Ph.Gimenez, pgimenez@@agt.uva.es
@* G.-M.Greuel, greuel@@mathematik.uni-kl.de

@item @strong{Overview:}
A library for computing the Castelnuovo-Mumford regularity of a subscheme of
the projective n-space that DOES NOT require the computation of a minimal
graded free resolution of the saturated ideal defining the subscheme.
The procedures are based on two papers by Isabel Bermejo and Philippe Gimenez:
'On Castelnuovo-Mumford regularity of projective curves' Proc.Amer.Math.Soc.
128(5) (2000), and 'Computing the Castelnuovo-Mumford regularity of some
subschemes of Pn using quotients of monomial ideals', Proceedings of
MEGA-2000, J. Pure Appl. Algebra (to appear).
@*The algorithm assumes the variables to be in Noether position.

@end table

@strong{Procedures:}
@menu
* reg_CM:: regularity of arith. C-M subscheme V(id_sat) of Pn
* reg_curve:: regularity of projective curve V(id_sat) in Pn
* reg_moncurve:: regularity of projective monomial curve defined by li
@end menu
@c ---end content LibInfo---

@c ------------------- reg_CM -------------
@node reg_CM, reg_curve,, mregular_lib
@subsubsection reg_CM
@cindex reg_CM
@c ---content reg_CM---
Procedure from library @code{mregular.lib} (@pxref{mregular_lib}).

@table @asis
@item @strong{Usage:}
reg_CM (i); i ideal

@item @strong{Return:}
an integer, the Castelnuovo-Mumford regularity of i-sat.

@item @strong{Assume:}
i is a homogeneous ideal of the basering S=K[x(0)..x(n)] where
the field K is infinite, and S/i-sat is Cohen-Macaulay.
Assume that K[x(n-d),...,x(n)] is a Noether normalization of S/i-sat
where d=dim S/i -1. If this is not the case, compute a Noether
normalization e.g. by using the proc noetherNormal from algebra.lib.

@item @strong{Note:}
The output is reg(X)=reg(i-sat) where X is the arithmetically
Cohen-Macaulay subscheme of the projective n-space defined by i.
If printlevel > 0 (default = 0) additional information is displayed.
In particular, the value of the regularity of the Hilbert function of
S/i-sat is given.

@end table
@strong{Example:}
@smallexample
@c computed example reg_CM d2t_singular/mregular_lib.doc:68 
LIB "mregular.lib";
ring s=0,x(0..5),dp;
ideal i=x(2)^2-x(4)*x(5),x(1)*x(2)-x(0)*x(5),x(0)*x(2)-x(1)*x(4),
x(1)^2-x(3)*x(5),x(0)*x(1)-x(2)*x(3),x(0)^2-x(3)*x(4);
reg_CM(i);
@expansion{} 2
// Additional information can be obtained as follows:
printlevel = 1;
reg_CM(i);
@expansion{} // Ideal i of S defining an arithm. Cohen-Macaulay subscheme X of P5:
@expansion{} //   - dimension of X: 2
@expansion{} //   - i is saturated: YES
@expansion{} //   - regularity of the Hilbert function of S/i-sat: -1
@expansion{} //   - time for computing reg(X): 0 sec.
@expansion{} // Castelnuovo-Mumford regularity of X:
@expansion{} 2
@c end example reg_CM d2t_singular/mregular_lib.doc:68
@end smallexample
@c ---end content reg_CM---

@c ------------------- reg_curve -------------
@node reg_curve, reg_moncurve, reg_CM, mregular_lib
@subsubsection reg_curve
@cindex reg_curve
@c ---content reg_curve---
Procedure from library @code{mregular.lib} (@pxref{mregular_lib}).

@table @asis
@item @strong{Usage:}
reg_curve (i[,e]); i ideal, e integer

@item @strong{Return:}
an integer, the Castelnuovo-Mumford regularity of i-sat.

@item @strong{Assume:}
i is a homogeneous ideal of the basering S=K[x(0)..x(n)] where
the field K is infinite, and it defines a projective curve C in
the projective n-space (dim(i)=2). We assume that K[x(n-1),x(n)]
is a Noether normalization of S/i-sat.
@*e=0: (default)
@*Uses a random choice of an element of K when it is necessary.
This is absolutely safe (if the element is bad, another random
choice will be done until a good element is found).
@*e=1: Substitutes the random choice of an element of K by a simple
transcendental field extension of K.

@item @strong{Note:}
The output is the integer reg(C)=reg(i-sat).
@*If printlevel > 0 (default = 0) additional information is displayed.
In particular, says if C is arithmetically Cohen-Macaulay or not,
determines in which step of a minimal graded free resolution of i-sat
the regularity of C is attained, and sometimes gives the value of the
regularity of the Hilbert function of S/i-sat (otherwise, an upper
bound is given).

@end table
@strong{Example:}
@smallexample
@c computed example reg_curve d2t_singular/mregular_lib.doc:119 
LIB "mregular.lib";
ring s = 0,(x,y,z,t),dp;
// 1st example is Ex.2.5 in [Bermejo-Gimenez], Proc.Amer.Math.Soc. 128(5):
ideal i  = x17y14-y31, x20y13, x60-y36z24-x20z20t20;
reg_curve(i);
@expansion{} 72
// 2nd example is Ex.2.9 in [Bermejo-Gimenez], Proc.Amer.Math.Soc. 128(5):
int k=43;
ideal j=x17y14-y31,x20y13,x60-y36z24-x20z20t20,y41*z^k-y40*z^(k+1);
reg_curve(j);
@expansion{} 93
// Additional information can be obtained as follows:
printlevel = 1;
reg_curve(j);
@expansion{} // Ideal i of S defining a projective curve C in P3:
@expansion{} //   - i is saturated: YES
@expansion{} //   - C is arithm. Cohen-Macaulay: NO
@expansion{} //   - reg(C) attained at the last step of a m.g.f.r. of i-sat: YES
@expansion{} //   - regularity of the Hilbert function of S/i-sat: 92
@expansion{} //   - time for computing reg(C): 0 sec.
@expansion{} // Castelnuovo-Mumford regularity of C:
@expansion{} 93
@c end example reg_curve d2t_singular/mregular_lib.doc:119
@end smallexample
@c ---end content reg_curve---

@c ------------------- reg_moncurve -------------
@node reg_moncurve,, reg_curve, mregular_lib
@subsubsection reg_moncurve
@cindex reg_moncurve
@c ---content reg_moncurve---
Procedure from library @code{mregular.lib} (@pxref{mregular_lib}).

@table @asis
@item @strong{Usage:}
reg_moncurve (a0,...,an) ; ai integers with a0=0 < a1 < ... < an=:d

@item @strong{Return:}
an integer, the Castelnuovo-Mumford regularity of the projective
monomial curve C in Pn parametrically defined by:
@*x(0)=t^d , x(1)=s^(a1)t^(d-a1), ... , x(n)=s^d.

@item @strong{Assume:}
a0=0 < a1 < ... < an are integers and the base field is infinite.

@item @strong{Note:}
The defining ideal I(C) in S is determined using elimination.
The procedure reg_curve is improved in this case since one
knows beforehand that the dimension is 2, that the variables are
in Noether position, that I(C) is prime.
@*If printlevel > 0 (default = 0) additional information is displayed.
In particular, says if C is arithmetically Cohen-Macaulay or not,
determines in which step of a minimal graded free resolution of I(C)
the regularity is attained, and sometimes gives the value of the
regularity of the Hilbert function of S/I(C) (otherwise, an upper
bound is given).

@end table
@strong{Example:}
@smallexample
@c computed example reg_moncurve d2t_singular/mregular_lib.doc:170 
LIB "mregular.lib";
// The 1st example is the twisted cubic:
reg_moncurve(0,1,2,3);
@expansion{} 2
// The 2nd. example is the non arithm. Cohen-Macaulay monomial curve in P4
// parametrized by: x(0)-s6,x(1)-s5t,x(2)-s3t3,x(3)-st5,x(4)-t6:
reg_moncurve(0,1,3,5,6);
@expansion{} 3
// Additional information can be obtained as follows:
printlevel = 1;
reg_moncurve(0,1,3,5,6);
@expansion{} // Sequence of integers defining a monomial curve C in P4:
@expansion{} //   - time for computing ideal I(C) of S (elimination): 0 sec.
@expansion{} //   - C is arithm. Cohen-Macaulay: NO
@expansion{} //   - reg(C) attained at the last step of a m.g.f.r. of I(C): YES
@expansion{} //   - reg(C) attained at the second last step of a m.g.f.r. of I(C): YES
@expansion{} //   - regularity of the Hilbert function of S/I(C): 2
@expansion{} //   - time for computing reg(C): 0 sec.
@expansion{} // Castelnuovo-Mumford regularity of C:
@expansion{} 3
@c end example reg_moncurve d2t_singular/mregular_lib.doc:170
@end smallexample
@c ---end content reg_moncurve---
@c ---------------------------------------------------------
@node normal_lib, primdec_lib, mregular_lib, Commutative algebra
@subsection normal_lib
@c include of docu for normal.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/normal_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/normal_lib.doc INSTEAD
@c library version: (1.34.2.17,2002/10/21)
@c library file: ../Singular/LIB/normal.lib
@cindex normal.lib
@cindex normal_lib
@table @asis
@item @strong{Library:}
normal.lib
@item @strong{Purpose:}
     Normalization of Affine Rings
@item @strong{Authors:}
G.-M. Greuel, greuel@@mathematik.uni-kl.de,
@* G. Pfister, pfister@@mathematik.uni-kl.de

@end table

@strong{Main procedures:}
@menu
* normal:: computes the normalization of basering/I, resp. computes the normalization of basering/I and the delta invariant
* HomJJ:: presentation of End_R(J) as affine ring, L a list
* genus:: computes genus of the projective curve defined by I
@end menu
@strong{Auxiliary procedure:}
@menu
* deltaLoc:: (sum of) delta invariant(s) at conjugated singular points
@end menu
@c ---end content LibInfo---

@c ------------------- normal -------------
@node normal, HomJJ,, normal_lib
@subsubsection normal
@cindex normal
@c ---content normal---
Procedure from library @code{normal.lib} (@pxref{normal_lib}).

@table @asis
@item @strong{Usage:}
normal(i [,choose]); i a radical ideal, choose empty, 1 or "wd"
if choose=1 the normalization of the associated primes is computed
(which is sometimes more efficient);
if @code{choose="wd"} the delta invariant is computed
simultaneously; this may take much more time in the reducible case,
since the factorizing standard basis algorithm cannot be used.

@item @strong{Assume:}
The ideal must be radical, for non-radical ideals the output may
be wrong (i=radical(i); makes i radical)

@item @strong{Return:}
a list of rings, say nor and in case of @code{choose="wd"} an
integer at the end of the list.
Each ring @code{nor[i]} contains two ideals with given names
@code{norid} and @code{normap} such that@*
- the direct sum of the rings @code{nor[i]/norid} is the
normalization of basering/id;@*
- @code{normap} gives the normalization map from basering/id to
@code{nor[i]/norid} (for each i).

@item @strong{Note:}
to use the i-th ring type: @code{def R=nor[i]; setring R;}.
@* Increasing printlevel displays more comments (default: printlevel=0).
@* Not implemented for local or mixed orderings.
@* If the input ideal i is weighted homogeneous a weighted ordering may
be used (qhweight(i); computes weights).

@cindex normalization
@cindex delta invariant.
@end table
@strong{Example:}
@smallexample
@c computed example normal d2t_singular/normal_lib.doc:71 
LIB "normal.lib";
ring r=32003,(x,y,z),wp(2,1,2);
ideal i=z3-xy4;
list nor=normal(i);
@expansion{} 
@expansion{} // 'normal' created a list of 1 ring(s).
@expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
show(nor);
@expansion{} // list, 1 element(s):
@expansion{} [1]:
@expansion{}    // ring: (32003),(T(1),T(2),T(3)),(a(2,1,1),dp(3),C);
@expansion{}    // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // normap               [0]  ideal, 3 generator(s)
@expansion{} // norid                [0]  ideal, 1 generator(s)
def r1=nor[1];
setring r1;
norid;
@expansion{} norid[1]=T(3)3-T(1)T(2)
normap;
@expansion{} normap[1]=T(1)
@expansion{} normap[2]=T(2)
@expansion{} normap[3]=T(2)T(3)
ring s=0,(x,y),dp;
ideal i=(x-y^2)^2 - y*x^3;
nor=normal(i,"wd");
@expansion{} 
@expansion{} // 'normal' created a list of 1 ring(s).
@expansion{} // nor[1+1] is the delta-invariant in case of choose=wd.
@expansion{} // To see the rings, type (if the name of your list is nor):
@expansion{}      show( nor);
@expansion{} // To access the 1-st ring and map (similar for the others), type:
@expansion{}      def R = nor[1]; setring R;  norid; normap;
@expansion{} // R/norid is the 1-st ring of the normalization and
@expansion{} // normap the map from the original basering to R/norid
//the delta-invariant
nor[size(nor)];
@expansion{} 3
@c end example normal d2t_singular/normal_lib.doc:71
@end smallexample
@c ---end content normal---

@c ------------------- HomJJ -------------
@node HomJJ, genus, normal, normal_lib
@subsubsection HomJJ
@cindex HomJJ
@c ---content HomJJ---
Procedure from library @code{normal.lib} (@pxref{normal_lib}).

@table @asis
@item @strong{Usage:}
HomJJ (Li); Li = list: ideal SBid, ideal id, ideal J, poly p

@item @strong{Assume:}
R = P/id, P = basering, a polynomial ring, id an ideal of P,
@* SBid = standard basis of id,
@* J = ideal of P containing the polynomial p,
@* p = nonzero divisor of R

@item @strong{Compute:}
Endomorphism ring End_R(J)=Hom_R(J,J) with its ring structure as
affine ring, together with the canonical map R --> Hom_R(J,J),
where R is the quotient ring of P modulo the standard basis SBid.

@item @strong{Return:}
a list l of two objects
@format
         l[1] : a polynomial ring, containing two ideals, 'endid' and 'endphi'
               such that l[1]/endid = Hom_R(J,J) and
               endphi describes the canonical map R -> Hom_R(J,J)
         l[2] : an integer which is 1 if phi is an isomorphism, 0 if not
         l[3] : an integer, the contribution to delta
@end format

@item @strong{Note:}
printlevel >=1: display comments (default: printlevel=0)

@end table
@strong{Example:}
@smallexample
@c computed example HomJJ d2t_singular/normal_lib.doc:128 
LIB "normal.lib";
ring r   = 0,(x,y),wp(2,3);
ideal id = y^2-x^3;
ideal J  = x,y;
poly p   = x;
list Li = std(id),id,J,p;
list L   = HomJJ(Li);
def end = L[1];    // defines ring L[1], containing ideals endid, endphi
setring end;       // makes end the basering
end;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 1
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    T(1) 
@expansion{} //        block   2 : ordering C
endid;             // end/endid is isomorphic to End(r/id) as ring
@expansion{} endid[1]=0
map psi = r,endphi;// defines the canonical map r/id -> End(r/id)
psi;
@expansion{} psi[1]=T(1)^2
@expansion{} psi[2]=T(1)^3
@c end example HomJJ d2t_singular/normal_lib.doc:128
@end smallexample
@c ---end content HomJJ---

@c ------------------- genus -------------
@node genus, deltaLoc, HomJJ, normal_lib
@subsubsection genus
@cindex genus
@c ---content genus---
Procedure from library @code{normal.lib} (@pxref{normal_lib}).

@table @asis
@item @strong{Usage:}
genus(I) or genus(i,1); I a 1-dimensional ideal

@item @strong{Return:}
an integer, the geometric genus p_g = p_a - delta of the projective
curve defined by I, where p_a is the arithmetic genus.

@item @strong{Note:}
delta is the sum of all local delta-invariants of the singularities,
i.e. dim(R'/R), R' the normalization of the local ring R of the
singularity.
@*genus(i,1) uses the normalization to compute delta. Usually this
is slow but sometimes not.

@end table
@strong{Example:}
@smallexample
@c computed example genus d2t_singular/normal_lib.doc:171 
LIB "normal.lib";
ring r=0,(x,y),dp;
ideal i=y^9 - x^2*(x - 1)^9;
genus(i);
@expansion{} 0
@c end example genus d2t_singular/normal_lib.doc:171
@end smallexample
@c ---end content genus---

@c ------------------- deltaLoc -------------
@node deltaLoc,, genus, normal_lib
@subsubsection deltaLoc
@cindex deltaLoc
@c ---content deltaLoc---
Procedure from library @code{normal.lib} (@pxref{normal_lib}).

@table @asis
@item @strong{Usage:}
deltaLoc(f,J); f poly, J ideal

@item @strong{Assume:}
f is reduced bivariate polynomial; basering has exactly two variables;
J is irreducible prime component of the singular locus of f (e.g., one
entry of the output of @code{minAssGTZ(I);}, I = <f,jacob(f)>).

@item @strong{Return:}
list L:

@table @asis
@item @code{L[1]}; int:
         the sum of (local) delta invariants of f at the (conjugated) singular
         points given by J.
@item @code{L[2]}; int:
         the sum of (local) Tjurina numbers of f at the (conjugated) singular
         points given by J.
@item @code{L[3]}; int:
         the sum of (local) number of branches of f at the (conjugated) 
         singular points given by J.
@end table

@item @strong{Note:}
procedure makes use of @code{execute}; increasing printlevel displays
more comments (default: printlevel=0).

@cindex delta invariant
@cindex Tjurina number
@end table
@strong{Example:}
@smallexample
@c computed example deltaLoc d2t_singular/normal_lib.doc:220 
LIB "normal.lib";
ring r=0,(x,y),dp;
poly f=(x2+y^2-1)^3 +27x2y2;
ideal I=f,jacob(f);
I=std(I);
list qr=minAssGTZ(I);
size(qr);
@expansion{} 6
// each component of the singular locus either describes a cusp or a pair
// of conjugated nodes:
deltaLoc(f,qr[1]); 
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
deltaLoc(f,qr[2]); 
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
deltaLoc(f,qr[3]); 
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
deltaLoc(f,qr[4]); 
@expansion{} [1]:
@expansion{}    1
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
deltaLoc(f,qr[5]); 
@expansion{} [1]:
@expansion{}    2
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    4
deltaLoc(f,qr[6]);
@expansion{} [1]:
@expansion{}    2
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    4
@c end example deltaLoc d2t_singular/normal_lib.doc:220
@end smallexample
@c inserted refs from d2t_singular/normal_lib.doc:238
@menu
See also:
* delta::
* tjurina::
@end menu
@c end inserted refs from d2t_singular/normal_lib.doc:238

@c ---end content deltaLoc---
@c ----------------------------------------------------------
@node primdec_lib, primitiv_lib, normal_lib, Commutative algebra
@subsection primdec_lib
@c include of docu for primdec.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/primdec_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/primdec_lib.doc INSTEAD
@c library version: (1.98.2.16,2003/06/23)
@c library file: ../Singular/LIB/primdec.lib
@cindex primdec.lib
@cindex primdec_lib
@table @asis
@item @strong{Library:}
primdec.lib
@item @strong{Purpose:}
   Primary Decomposition and Radical of Ideals
@item @strong{Authors:}
Gerhard Pfister, pfister@@mathematik.uni-kl.de (GTZ)
@* Wolfram Decker, decker@@math.uni-sb.de (SY)
@* Hans Schoenemann, hannes@@mathematik.uni-kl.de (SY)

@item @strong{Overview:}
Algorithms for primary decomposition based on the ideas of
Gianni, Trager and Zacharias (implementation by Gerhard Pfister),
respectively based on the ideas of Shimoyama and Yokoyama (implementation
by Wolfram Decker and Hans Schoenemann).
@* The procedures are implemented to be used in characteristic 0.
@* They also work in positive characteristic >> 0.
@* In small characteristic and for algebraic extensions, primdecGTZ
may not terminate.
@*Algorithms for the computation of the radical based on the ideas of
Krick, Logar and Kemper (implementation by Gerhard Pfister).

@end table

@strong{Procedures:}
@menu
* Ann:: annihilator of R^n/M, R=basering, M in R^n
* primdecGTZ:: complete primary decomposition via Gianni,Trager,Zacharias
* primdecSY:: complete primary decomposition via Shimoyama-Yokoyama
* minAssGTZ:: the minimal associated primes via Gianni,Trager,Zacharias
* minAssChar:: the minimal associated primes using characteristic sets
* testPrimary:: tests the result of the primary decomposition
* radical:: computes the radical of I via Krick/Logar and Kemper
* radicalEHV:: computes the radical of I via Eisenbud,Huneke,Vasconcelos
* equiRadical:: the radical of the equidimensional part of the ideal I
* prepareAss:: list of radicals of the equidimensional components of I
* equidim:: weak equidimensional decomposition of I
* equidimMax:: equidimensional locus of I
* equidimMaxEHV:: equidimensional locus of I via Eisenbud,Huneke,Vasconcelos
* zerodec:: zerodimensional decomposition via Monico
@end menu
@c ---end content LibInfo---

@c ------------------- Ann -------------
@node Ann, primdecGTZ,, primdec_lib
@subsubsection Ann
@cindex Ann
@c ---content Ann---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@end table
@c ---end content Ann---

@c ------------------- primdecGTZ -------------
@node primdecGTZ, primdecSY, Ann, primdec_lib
@subsubsection primdecGTZ
@cindex primdecGTZ
@c ---content primdecGTZ---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
primdecGTZ(i); i ideal

@item @strong{Return:}
a list pr of primary ideals and their associated primes:
@format
   pr[i][1]   the i-th primary component,
   pr[i][2]   the i-th prime component.
@end format

@item @strong{Note:}
Algorithm of Gianni/Trager/Zacharias.
@*Designed for characteristic 0, works also in char k > 0, if it
terminates (may result in an infinite loop in small characteristic!)

@end table
@strong{Example:}
@smallexample
@c reused example primdecGTZ d2t_singular/primdec_lib.doc:86 
LIB "primdec.lib";
ring  r = 0,(x,y,z),lp;
poly  p = z2+1;
poly  q = z3+2;
ideal i = p*q^2,y-z2;
list pr = primdecGTZ(i);
pr;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=z6+4z3+4
@expansion{}       _[2]=y-z2
@expansion{}    [2]:
@expansion{}       _[1]=z3+2
@expansion{}       _[2]=y-z2
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=z2+1
@expansion{}       _[2]=y-z2
@expansion{}    [2]:
@expansion{}       _[1]=z2+1
@expansion{}       _[2]=y-z2
@c end example primdecGTZ d2t_singular/primdec_lib.doc:86
@end smallexample
@c ---end content primdecGTZ---

@c ------------------- primdecSY -------------
@node primdecSY, minAssGTZ, primdecGTZ, primdec_lib
@subsubsection primdecSY
@cindex primdecSY
@c ---content primdecSY---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
primdecSY(i); i ideal, c int

@item @strong{Return:}
a list pr of primary ideals and their associated primes:
@format
   pr[i][1]   the i-th primary component,
   pr[i][2]   the i-th prime component.
@end format

@item @strong{Note:}
Algorithm of Shimoyama/Yokoyama.
@format
   if c=0,  the given ordering of the variables is used,
   if c=1,  minAssChar tries to use an optimal ordering,
   if c=2,  minAssGTZ is used,
   if c=3,  minAssGTZ and facstd are used.
@end format

@end table
@strong{Example:}
@smallexample
@c reused example primdecSY d2t_singular/primdec_lib.doc:128 
LIB "primdec.lib";
ring  r = 0,(x,y,z),lp;
poly  p = z2+1;
poly  q = z3+2;
ideal i = p*q^2,y-z2;
list pr = primdecSY(i);
pr;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=z6+4z3+4
@expansion{}       _[2]=y-z2
@expansion{}    [2]:
@expansion{}       _[1]=z3+2
@expansion{}       _[2]=y-z2
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=z2+1
@expansion{}       _[2]=y+1
@expansion{}    [2]:
@expansion{}       _[1]=z2+1
@expansion{}       _[2]=y+1
@c end example primdecSY d2t_singular/primdec_lib.doc:128
@end smallexample
@c ---end content primdecSY---

@c ------------------- minAssGTZ -------------
@node minAssGTZ, minAssChar, primdecSY, primdec_lib
@subsubsection minAssGTZ
@cindex minAssGTZ
@c ---content minAssGTZ---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
minAssGTZ(i); i ideal
@*minAssGTZ(i,1); i ideal does not use the factorizing Groebner

@item @strong{Return:}
a list, the minimal associated prime ideals of i.

@item @strong{Note:}
Designed for characteristic 0, works also in char k > 0 based
on an algorithm of Yokoyama

@end table
@strong{Example:}
@smallexample
@c reused example minAssGTZ d2t_singular/primdec_lib.doc:162 
LIB "primdec.lib";
ring  r = 0,(x,y,z),dp;
poly  p = z2+1;
poly  q = z3+2;
ideal i = p*q^2,y-z2;
list pr = minAssGTZ(i);
pr;
@expansion{} [1]:
@expansion{}    _[1]=z2+1
@expansion{}    _[2]=-z2+y
@expansion{} [2]:
@expansion{}    _[1]=z3+2
@expansion{}    _[2]=-z2+y
@c end example minAssGTZ d2t_singular/primdec_lib.doc:162
@end smallexample
@c ---end content minAssGTZ---

@c ------------------- minAssChar -------------
@node minAssChar, testPrimary, minAssGTZ, primdec_lib
@subsubsection minAssChar
@cindex minAssChar
@c ---content minAssChar---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
minAssChar(i[,c]); i ideal, c int.

@item @strong{Return:}
list, the minimal associated prime ideals of i.

@item @strong{Note:}
If c=0, the given ordering of the variables is used. @*
Otherwise, the system tries to find an optimal ordering,
which in some cases may considerably speed up the algorithm. @*
Due to a bug in the factorization, the result may be not completely
decomposed in small characteristic.

@end table
@strong{Example:}
@smallexample
@c reused example minAssChar d2t_singular/primdec_lib.doc:198 
LIB "primdec.lib";
ring  r = 0,(x,y,z),dp;
poly  p = z2+1;
poly  q = z3+2;
ideal i = p*q^2,y-z2;
list pr = minAssChar(i);
pr;
@expansion{} [1]:
@expansion{}    _[1]=y+1
@expansion{}    _[2]=z2+1
@expansion{} [2]:
@expansion{}    _[1]=z2-y
@expansion{}    _[2]=yz+2
@expansion{}    _[3]=y2+2z
@c end example minAssChar d2t_singular/primdec_lib.doc:198
@end smallexample
@c ---end content minAssChar---

@c ------------------- testPrimary -------------
@node testPrimary, radical, minAssChar, primdec_lib
@subsubsection testPrimary
@cindex testPrimary
@c ---content testPrimary---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
testPrimary(pr,k); pr a list, k an ideal.

@item @strong{Assume:}
pr is the result of primdecGTZ(k) or primdecSY(k).

@item @strong{Return:}
int, 1 if the intersection of the ideals in pr is k, 0 if not

@end table
@strong{Example:}
@smallexample
@c reused example testPrimary d2t_singular/primdec_lib.doc:230 
LIB "primdec.lib";
ring  r = 32003,(x,y,z),dp;
poly  p = z2+1;
poly  q = z4+2;
ideal i = p^2*q^3,(y-z3)^3,(x-yz+z4)^4;
list pr = primdecGTZ(i);
testPrimary(pr,i);
@expansion{} 1
@c end example testPrimary d2t_singular/primdec_lib.doc:230
@end smallexample
@c ---end content testPrimary---

@c ------------------- radical -------------
@node radical, radicalEHV, testPrimary, primdec_lib
@subsubsection radical
@cindex radical
@c ---content radical---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
radical(i); i ideal.

@item @strong{Return:}
ideal, the radical of i.

@item @strong{Note:}
A combination of the algorithms of Krick/Logar and Kemper is used.
Works also in positive characteristic (Kempers algorithm).

@end table
@strong{Example:}
@smallexample
@c reused example radical d2t_singular/primdec_lib.doc:263 
LIB "primdec.lib";
ring  r = 0,(x,y,z),dp;
poly  p = z2+1;
poly  q = z3+2;
ideal i = p*q^2,y-z2;
ideal pr= radical(i);
pr;
@expansion{} pr[1]=z2-y
@expansion{} pr[2]=y2z+yz+2y+2
@c end example radical d2t_singular/primdec_lib.doc:263
@end smallexample
@c ---end content radical---

@c ------------------- radicalEHV -------------
@node radicalEHV, equiRadical, radical, primdec_lib
@subsubsection radicalEHV
@cindex radicalEHV
@c ---content radicalEHV---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
radicalEHV(i); i ideal.

@item @strong{Return:}
ideal, the radical of i.

@item @strong{Note:}
Uses the algorithm of Eisenbud/Huneke/Vasconcelos, which
reduces the computation to the complete intersection case,
by taking, in the general case, a generic linear combination
of the input.
@*Works only in characteristic 0 or p large.

@end table
@strong{Example:}
@smallexample
@c reused example radicalEHV d2t_singular/primdec_lib.doc:299 
LIB "primdec.lib";
ring  r = 0,(x,y,z),dp;
poly  p = z2+1;
poly  q = z3+2;
ideal i = p*q^2,y-z2;
ideal pr= radicalEHV(i);
pr;
@expansion{} pr[1]=z2-y
@expansion{} pr[2]=y2z+yz+2y+2
@expansion{} pr[3]=y3+y2+2yz+2z
@c end example radicalEHV d2t_singular/primdec_lib.doc:299
@end smallexample
@c ---end content radicalEHV---

@c ------------------- equiRadical -------------
@node equiRadical, prepareAss, radicalEHV, primdec_lib
@subsubsection equiRadical
@cindex equiRadical
@c ---content equiRadical---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
equiRadical(i); i ideal

@item @strong{Return:}
ideal, intersection of associated primes of i of maximal dimension.

@item @strong{Note:}
A combination of the algorithms of Krick/Logar and Kemper is used.
Works also in positive characteristic (Kempers algorithm).

@end table
@strong{Example:}
@smallexample
@c reused example equiRadical d2t_singular/primdec_lib.doc:332 
LIB "primdec.lib";
ring  r = 0,(x,y,z),dp;
poly  p = z2+1;
poly  q = z3+2;
ideal i = p*q^2,y-z2;
ideal pr= equiRadical(i);
pr;
@expansion{} pr[1]=z2-y
@expansion{} pr[2]=y2z+yz+2y+2
@c end example equiRadical d2t_singular/primdec_lib.doc:332
@end smallexample
@c ---end content equiRadical---

@c ------------------- prepareAss -------------
@node prepareAss, equidim, equiRadical, primdec_lib
@subsubsection prepareAss
@cindex prepareAss
@c ---content prepareAss---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
prepareAss(i); i ideal

@item @strong{Return:}
list, the radicals of the maximal dimensional components of i.

@item @strong{Note:}
Uses algorithm of Eisenbud/Huneke/Vasconcelos.

@end table
@strong{Example:}
@smallexample
@c reused example prepareAss d2t_singular/primdec_lib.doc:364 
LIB "primdec.lib";
ring  r = 0,(x,y,z),dp;
poly  p = z2+1;
poly  q = z3+2;
ideal i = p*q^2,y-z2;
list pr = prepareAss(i);
pr;
@expansion{} [1]:
@expansion{}    _[1]=z2-y
@expansion{}    _[2]=y2z+yz+2y+2
@c end example prepareAss d2t_singular/primdec_lib.doc:364
@end smallexample
@c ---end content prepareAss---

@c ------------------- equidim -------------
@node equidim, equidimMax, prepareAss, primdec_lib
@subsubsection equidim
@cindex equidim
@c ---content equidim---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
equidim(i) or equidim(i,1) ; i ideal

@item @strong{Return:}
list of equidimensional ideals a[1],...,a[s] with:
@*- a[s] the equidimensional locus of i, i.e. the intersection
of the primary ideals of dimension of i
@*- a[1],...,a[s-1] the lower dimensional equidimensional loci.

@item @strong{Note:}
An embedded component q (primary ideal) of i can be replaced in the
decomposition by a primary ideal q1 with the same radical as q. @*
@code{equidim(i,1)} uses the algorithm of Eisenbud/Huneke/Vasconcelos.

@end table
@strong{Example:}
@smallexample
@c reused example equidim d2t_singular/primdec_lib.doc:401 
LIB "primdec.lib";
ring  r = 32003,(x,y,z),dp;
ideal i = intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
equidim(i);
@expansion{} [1]:
@expansion{}    _[1]=z4
@expansion{}    _[2]=y5
@expansion{}    _[3]=x5
@expansion{}    _[4]=x3z3
@expansion{}    _[5]=x4y4
@expansion{} [2]:
@expansion{}    _[1]=yz
@expansion{}    _[2]=xz
@expansion{}    _[3]=x2
@expansion{} [3]:
@expansion{}    _[1]=z
@c end example equidim d2t_singular/primdec_lib.doc:401
@end smallexample
@c ---end content equidim---

@c ------------------- equidimMax -------------
@node equidimMax, equidimMaxEHV, equidim, primdec_lib
@subsubsection equidimMax
@cindex equidimMax
@c ---content equidimMax---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
equidimMax(i); i ideal

@item @strong{Return:}
ideal of equidimensional locus (of maximal dimension) of i.

@end table
@strong{Example:}
@smallexample
@c reused example equidimMax d2t_singular/primdec_lib.doc:427 
LIB "primdec.lib";
ring  r = 32003,(x,y,z),dp;
ideal i = intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
equidimMax(i);
@expansion{} _[1]=z
@c end example equidimMax d2t_singular/primdec_lib.doc:427
@end smallexample
@c ---end content equidimMax---

@c ------------------- equidimMaxEHV -------------
@node equidimMaxEHV, zerodec, equidimMax, primdec_lib
@subsubsection equidimMaxEHV
@cindex equidimMaxEHV
@c ---content equidimMaxEHV---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
equidimMaxEHV(i); i ideal

@item @strong{Return:}
ideal, the equidimensional component (of maximal dimension) of i.

@item @strong{Note:}
Uses algorithm of Eisenbud, Huneke and Vasconcelos.

@end table
@strong{Example:}
@smallexample
@c reused example equidimMaxEHV d2t_singular/primdec_lib.doc:456 
LIB "primdec.lib";
ring  r = 0,(x,y,z),dp;
ideal i=intersect(ideal(z),ideal(x,y),ideal(x2,z2),ideal(x5,y5,z5));
equidimMaxEHV(i);
@expansion{} _[1]=z
@c end example equidimMaxEHV d2t_singular/primdec_lib.doc:456
@end smallexample
@c ---end content equidimMaxEHV---

@c ------------------- zerodec -------------
@node zerodec,, equidimMaxEHV, primdec_lib
@subsubsection zerodec
@cindex zerodec
@c ---content zerodec---
Procedure from library @code{primdec.lib} (@pxref{primdec_lib}).

@table @asis
@item @strong{Usage:}
zerodec(I); I ideal

@item @strong{Assume:}
I is zero-dimensional, the characteristic of the ground field is 0

@item @strong{Return:}
list of primary ideals, the zero-dimensional decomposition of I

@item @strong{Note:}
The algorithm (of Monico), works well only for a small total number
of solutions (@code{vdim(std(I))} should be < 100) and without
parameters. In practice, it works also in large characteristic p>0
but may fail for small p.
@* If printlevel > 0 (default = 0) additional information is displayed.

@end table
@strong{Example:}
@smallexample
@c reused example zerodec d2t_singular/primdec_lib.doc:492 
LIB "primdec.lib";
ring r  = 0,(x,y),dp;
ideal i = x2-2,y2-2;
list pr = zerodec(i);
pr;
@expansion{} [1]:
@expansion{}    _[1]=y2-2
@expansion{}    _[2]=xy-2
@expansion{}    _[3]=x2-2
@expansion{} [2]:
@expansion{}    _[1]=y2-2
@expansion{}    _[2]=xy+2
@expansion{}    _[3]=x2-2
@c end example zerodec d2t_singular/primdec_lib.doc:492
@end smallexample
@c ---end content zerodec---
@c ---------------------------------------------------------
@node primitiv_lib, reesclos_lib, primdec_lib, Commutative algebra
@subsection primitiv_lib
@c include of docu for primitiv.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/primitiv_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/primitiv_lib.doc INSTEAD
@c library version: (1.15,2001/02/05)
@c library file: ../Singular/LIB/primitiv.lib
@cindex primitiv.lib
@cindex primitiv_lib
@table @asis
@item @strong{Library:}
primitiv.lib
@item @strong{Purpose:}
    Computing a Primitive Element
@item @strong{Author:}
Martin Lamm, email: lamm@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* primitive:: find minimal polynomial for a primitive element
* primitive_extra:: find primitive element for two generators
* splitring:: define ring extension with name R and switch to it
@end menu
@c ---end content LibInfo---

@c ------------------- primitive -------------
@node primitive, primitive_extra,, primitiv_lib
@subsubsection primitive
@cindex primitive
@c ---content primitive---
Procedure from library @code{primitiv.lib} (@pxref{primitiv_lib}).

@table @asis
@item @strong{Usage:}
primitive(i); i ideal

@item @strong{Assume:}
i is given by generators m[1],...,m[n] such that for j=1,...,n @*
- m[j] is a polynomial in k[x(1),...,x(j)] @*
- m[j](a[1],...,a[j-1],x(j)) is the minimal polynomial for a[j] over
k(a[1],...,a[j-1]) @*
(k the ground field of the current basering and x(1),...,x(n)
the ring variables).

@item @strong{Return:}
ideal j in k[x(n)] with
@*- j[1] a minimal polynomial for a primitive element b of 
k(a[1],...,a[n]) over k,
@*- j[2],...,j[n+1] polynomials in k[x(n)] such that j[i+1](b)=a[i]
for i=1,...,n.

@item @strong{Note:}
the number of variables in the basering has to be exactly n,
the number of given generators (i.e., minimal polynomials).@*
If the ground field k has only a few elements it may happen that no
linear combination of a[1],...,a[n] is a primitive element. In this
case @code{primitive(i)} returns the zero ideal, and one should use
@code{primitive_extra(i)} instead.

@cindex primitive element
@end table
@strong{Example:}
@smallexample
@c computed example primitive d2t_singular/primitiv_lib.doc:62 
LIB "primitiv.lib";
ring exring=0,(x,y),dp;
ideal i=x2+1,y2-x;                  // compute Q(i,i^(1/2))=:L
ideal j=primitive(i);
j[1];                               // L=Q(a) with a=(-1)^(1/4)
@expansion{} y4+1
j[2];                               // i=a^2
@expansion{} y2
j[3];                               // i^(1/2)=a
@expansion{} y
// the 2nd element was already primitive!
j=primitive(ideal(x2-2,y2-3));      // compute Q(sqrt(2),sqrt(3))
j[1];
@expansion{} y4-10y2+1
j[2];
@expansion{} 1/2y3-9/2y
j[3];
@expansion{} -1/2y3+11/2y
// no element was primitive -- the calculation of primitive elements 
// is based on a random choice.
@c end example primitive d2t_singular/primitiv_lib.doc:62
@end smallexample
@c inserted refs from d2t_singular/primitiv_lib.doc:79
@menu
See also:
* primitive_extra::
@end menu
@c end inserted refs from d2t_singular/primitiv_lib.doc:79

@c ---end content primitive---

@c ------------------- primitive_extra -------------
@node primitive_extra, splitring, primitive, primitiv_lib
@subsubsection primitive_extra
@cindex primitive_extra
@c ---content primitive_extra---
Procedure from library @code{primitiv.lib} (@pxref{primitiv_lib}).

@table @asis
@item @strong{Usage:}
primitive_extra(i); i ideal

@item @strong{Assume:}
The ground field of the basering is k=Q or k=Z/pZ and the ideal
i is given by 2 generators f,g with the following properties:
@format
   f is the minimal polynomial of a in k[x], 
   g is a polynomial in k[x,y] s.th. g(a,y) is the minpoly of b in k(a)[y].
@end format
Here, x is the name of the first ring variable, y the name of the
second.

@item @strong{Return:}
ideal j in k[y] such that
@format
   j[1] is the minimal polynomial for a primitive element c of k(a,b) over k,
   j[2] is a polynomial s.th. j[2](c)=a.
@end format

@item @strong{Note:}
While @code{primitive(i)} may fail for finite fields,
@code{primitive_extra(i)} tries all elements of k(a,b) and, hence,
always finds a primitive element. @*
In order to do this (try all elements), field extensions like Z/pZ(a)
are not allowed for the ground field k. @*
@code{primitive_extra(i)} assumes that the second generator, g, is
monic as polynomial in (k[x])[y].

@end table
@strong{Example:}
@smallexample
@c computed example primitive_extra d2t_singular/primitiv_lib.doc:125 
LIB "primitiv.lib";
ring exring=3,(x,y),dp;
ideal i=x2+1,y3+y2-1;
primitive_extra(i);
@expansion{} _[1]=y6-y5+y4-y3-y-1
@expansion{} _[2]=y5+y4+y2+y+1
ring extension=(3,y),x,dp;
minpoly=y6-y5+y4-y3-y-1;
number a=y5+y4+y2+y+1;
a^2;
@expansion{} -1
factorize(x2+1);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x+(-y5-y4-y2-y-1)
@expansion{}    _[3]=x+(y5+y4+y2+y+1)
@expansion{} [2]:
@expansion{}    1,1,1
factorize(x3+x2-1);
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=x+(-y5-y4-y3-y2-y-1)
@expansion{}    _[3]=x+(y5+y4+y2+1)
@expansion{}    _[4]=x+(y3+y+1)
@expansion{} [2]:
@expansion{}    1,1,1,1
@c end example primitive_extra d2t_singular/primitiv_lib.doc:125
@end smallexample
@c ---end content primitive_extra---

@c ------------------- splitring -------------
@node splitring,, primitive_extra, primitiv_lib
@subsubsection splitring
@cindex splitring
@c ---content splitring---
Procedure from library @code{primitiv.lib} (@pxref{primitiv_lib}).

@table @asis
@item @strong{Usage:}
splitring(f,R[,L]); f poly, R string, L list of polys and/or ideals
(optional)

@item @strong{Assume:}
f is univariate and irreducible over the active basering. @*
The active ring must allow an algebraic extension (e.g., it cannot
be a transcendent ring extension of Q or Z/p).

@item @strong{Create:}
a ring with name R, in which f is reducible, and CHANGE to it.

@item @strong{Return:}
list L mapped into the new ring R, if L is given; else nothing

@item @strong{Note:}
If the old ring has no parameter, the name @code{a} is chosen for the
parameter of R (if @code{a} is no ring variable; if it is, @code{b} is
chosen, etc.; if @code{a,b,c,o} are ring variables,
@code{splitring(f,R[,L])} produces an error message), otherwise the
name of the parameter is kept and only the minimal polynomial is
changed. @*
The names of the ring variables and the orderings are not affected. @*
It is also allowed to call @code{splitring} with R="".
Then the old basering will be REPLACED by the new ring (with the
same name as the old ring).

@cindex algebraic field extension
@cindex extension of rings
@end table
@strong{Example:}
@smallexample
@c computed example splitring d2t_singular/primitiv_lib.doc:180 
LIB "primitiv.lib";
ring r=0,(x,y),dp;
splitring(x2-2,"r1");   // change to Q(sqrt(2))
// change to Q(sqrt(2),sqrt(sqrt(2)))=Q(a) and return the transformed 
// old parameter:
splitring(x2-a,"r2",a); 
@expansion{} // new minimal polynomial: a4-2
@expansion{} [1]:
@expansion{}    (a2)
// the result is (a)^2 = (sqrt(sqrt(2)))^2
nameof(basering);
@expansion{} r2
r2;
@expansion{} //   characteristic : 0
@expansion{} //   1 parameter    : a 
@expansion{} //   minpoly        : (a4-2)
@expansion{} //   number of vars : 2
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y 
@expansion{} //        block   2 : ordering C
kill r1; kill r2;
@c end example splitring d2t_singular/primitiv_lib.doc:180
@end smallexample
@c ---end content splitring---
@c ---------------------------------------------------------
@node reesclos_lib, intprog_lib, primitiv_lib, Commutative algebra
@subsection reesclos_lib
@c include of docu for reesclos.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/reesclos_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/reesclos_lib.doc INSTEAD
@c library version: (1.50,2001/08/06)
@c library file: ../Singular/LIB/reesclos.lib
@cindex reesclos.lib
@cindex reesclos_lib
@table @asis
@item @strong{Library:}
reesclos.lib
@item @strong{Purpose:}
     procedures to compute the int. closure of an ideal
@item @strong{Author:}
Tobias Hirsch, email: hirsch@@math.tu-cottbus.de

@item @strong{Overview:}
A library to compute the integral closure of an ideal I in a polynomial ring
R=K[x(1),...,x(n)] using the Rees Algebra R[It] of I. It computes the integral
closure of R[It] (in the same manner as done in the library 'normal.lib'),
which is a graded subalgebra of R[t]. The degree-k-component is the integral
closure of the k-th power of I.
@*These procedures can also be used to compute the integral closure R^ of an
integral domain R=k[x(1),...,x(n)]/ker, ker a prime ideal, in its quotient
field K=Q(R), as an affine ring R^=k[T(1),...,T(s)]]/J and to get
representations of elements of R^ as fractions of elements of R.

@end table

@strong{Procedures:}
@menu
* ReesAlgebra:: computes the Rees Algebra of an ideal I
* normalI:: computes the integral closure of an ideal I using R[It]
* primeClosure:: computes the integral closure of the int. domain R
* closureRingtower:: defines the rings in the list L as global objects R(i)
* closureFrac:: computes fractions representing elements of R^=L[n]
@end menu
@c ---end content LibInfo---

@c ------------------- ReesAlgebra -------------
@node ReesAlgebra, normalI,, reesclos_lib
@subsubsection ReesAlgebra
@cindex ReesAlgebra
@c ---content ReesAlgebra---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Usage:}
ReesAlgebra (I); I = ideal

@item @strong{Return:}
The Rees algebra R[It] as an affine ring, where I is an ideal in R.
The procedure returns a list containing two rings:
@*[1]: a ring, say RR; in the ring an ideal ker such that R[It]=RR/ker

[2]: a ring, say Kxt; the basering with additional variable t
containing an ideal mapI that defines the map RR-->Kxt

@end table
@strong{Example:}
@smallexample
@c computed example ReesAlgebra d2t_singular/reesclos_lib.doc:59 
LIB "reesclos.lib";
ring R = 0,(x,y),dp;
ideal I = x2,xy4,y5;
list L = ReesAlgebra(I);
def Rees = L[1];       // defines the ring Rees, containing the ideal ker
setring Rees;          // passes to the ring Rees
Rees;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 5
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y U(1) U(2) U(3) 
@expansion{} //        block   2 : ordering C
ker;                   // R[It] is isomorphic to Rees/ker
@expansion{} ker[1]=y*U(2)-x*U(3)
@expansion{} ker[2]=y^3*U(1)*U(3)-U(2)^2
@expansion{} ker[3]=y^4*U(1)-x*U(2)
@expansion{} ker[4]=x*y^2*U(1)*U(3)^2-U(2)^3
@expansion{} ker[5]=x^2*y*U(1)*U(3)^3-U(2)^4
@expansion{} ker[6]=x^3*U(1)*U(3)^4-U(2)^5
@c end example ReesAlgebra d2t_singular/reesclos_lib.doc:59
@end smallexample
@c ---end content ReesAlgebra---

@c ------------------- normalI -------------
@node normalI, primeClosure, ReesAlgebra, reesclos_lib
@subsubsection normalI
@cindex normalI
@c ---content normalI---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Usage:}
normalI(I [,p[,c]]); I an ideal, p and c optional integers

@item @strong{Return:}
the integral closure of I,...,I^p. If p is not given, or p==0,
compute the closure of all powers up to the maximum degree in t
occurring in the generators of the closure of R[It] (so this is the
last one that is not just the sum/product of the above ones).
c is transferred to the procedure primeClosure and toggles its
behavior in computing the integral closure of R[It].
@*The result is a list containing the closure of the desired powers of
I as ideals of the basering.

@end table
@strong{Example:}
@smallexample
@c computed example normalI d2t_singular/reesclos_lib.doc:96 
LIB "reesclos.lib";
ring R=0,(x,y),dp;
ideal I = x2,xy4,y5;
list J = normalI(I);
I;
@expansion{} I[1]=x2
@expansion{} I[2]=xy4
@expansion{} I[3]=y5
J;                             // J[1] is the integral closure of I
@expansion{} [1]:
@expansion{}    _[1]=x2
@expansion{}    _[2]=y5
@expansion{}    _[3]=-xy3
@c end example normalI d2t_singular/reesclos_lib.doc:96
@end smallexample
@c ---end content normalI---

@c ------------------- primeClosure -------------
@node primeClosure, closureRingtower, normalI, reesclos_lib
@subsubsection primeClosure
@cindex primeClosure
@c ---content primeClosure---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Usage:}
primeClosure(L [,c]); L a list of a ring containing a prime ideal
ker, c an optional integer

@item @strong{Return:}
a list L consisting of rings L[1],...,L[n] such that
@*- L[1] is a copy of (not a reference to!) the input ring L[1]
- all rings L[i] contain ideals ker, L[2],...,L[n] contain ideals phi
such that
@*L[1]/ker --> ... --> L[n]/ker
@*are injections given by the corresponding ideals phi, and L[n]/ker
is the integral closure of L[1]/ker in its quotient field.
- all rings L[i] contain a polynomial nzd such that elements of
L[i]/ker are quotients of elements of L[i-1]/ker with denominator
nzd via the injection phi.

@item @strong{Note:}
- L is constructed by recursive calls of primeClosure itself.
- c determines the choice of nzd:
@*- c not given or equal to 0: first generator of the ideal SL,
the singular locus of Spec(L[i]/ker)
@*- c<>0: the generator of SL with least number of monomials.

@end table
@strong{Example:}
@smallexample
@c computed example primeClosure d2t_singular/reesclos_lib.doc:141 
LIB "reesclos.lib";
ring R=0,(x,y),dp;
ideal I=x4,y4;
def K=ReesAlgebra(I)[1];        // K contains ker such that K/ker=R[It]
list L=primeClosure(K);
def R(1)=L[1];                  // L[4] contains ker, L[4]/ker is the
def R(4)=L[4];                  // integral closure of L[1]/ker
setring R(1);
R(1);
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y U(1) U(2) 
@expansion{} //        block   2 : ordering C
ker;
@expansion{} ker[1]=y^4*U(1)-x^4*U(2)
setring R(4);
R(4);
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 7
@expansion{} //        block   1 : ordering a
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
@expansion{} //                  : weights     1    1    1    1    1    1    1 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
@expansion{} //        block   3 : ordering C
ker;
@expansion{} ker[1]=T(2)*T(5)-T(1)*T(7)
@expansion{} ker[2]=T(1)*T(5)-T(2)*T(6)
@expansion{} ker[3]=T(5)*T(6)-T(3)*T(7)
@expansion{} ker[4]=T(4)*T(6)-T(5)*T(7)
@expansion{} ker[5]=T(5)^2-T(6)*T(7)
@expansion{} ker[6]=T(4)*T(5)-T(7)^2
@expansion{} ker[7]=T(3)*T(5)-T(6)^2
@expansion{} ker[8]=T(2)^2*T(6)-T(1)^2*T(7)
@expansion{} ker[9]=T(3)*T(4)-T(6)*T(7)
@expansion{} ker[10]=T(1)*T(4)-T(2)*T(7)
@expansion{} ker[11]=T(2)*T(3)-T(1)*T(6)
@expansion{} ker[12]=T(2)^2*T(6)^2-T(1)^2*T(6)*T(7)
@c end example primeClosure d2t_singular/reesclos_lib.doc:141
@end smallexample
@c ---end content primeClosure---

@c ------------------- closureRingtower -------------
@node closureRingtower, closureFrac, primeClosure, reesclos_lib
@subsubsection closureRingtower
@cindex closureRingtower
@c ---content closureRingtower---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Usage:}
closureRingtower(list L); L a list of rings

@item @strong{Create:}
rings R(1),...,R(n) such that R(i)=L[i] for all i

@end table
@strong{Example:}
@smallexample
@c computed example closureRingtower d2t_singular/reesclos_lib.doc:176 
LIB "reesclos.lib";
ring R=0,(x,y),dp;
ideal I=x4,y4;
list L=primeClosure(ReesAlgebra(I)[1]);
closureRingtower(L);
R(1);
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    x y U(1) U(2) 
@expansion{} //        block   2 : ordering C
R(4);
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 7
@expansion{} //        block   1 : ordering a
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
@expansion{} //                  : weights     1    1    1    1    1    1    1 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) 
@expansion{} //        block   3 : ordering C
@c end example closureRingtower d2t_singular/reesclos_lib.doc:176
@end smallexample
@c ---end content closureRingtower---

@c ------------------- closureFrac -------------
@node closureFrac,, closureRingtower, reesclos_lib
@subsubsection closureFrac
@cindex closureFrac
@c ---content closureFrac---
Procedure from library @code{reesclos.lib} (@pxref{reesclos_lib}).

@table @asis
@item @strong{Create:}
a list fraction of two elements of L[1], such that
@*f=fraction[1]/fraction[2] via the injections phi L[i]-->L[i+1].

@end table
@strong{Example:}
@smallexample
@c computed example closureFrac d2t_singular/reesclos_lib.doc:203 
LIB "reesclos.lib";
ring R=0,(x,y),dp;
ideal ker=x2+y2;
export R;
@expansion{} // ** `R` is already global
list L=primeClosure(R);          // We normalize R/ker
closureRingtower(L);             // Now R/ker=R(1) with normalization R(2)
setring R(2);
kill(R);
phi;                             // The map R(1)-->R(2)
@expansion{} phi[1]=T(1)*T(2)
@expansion{} phi[2]=T(1)
poly f=T(1)*T(2);                // We will get a representation of f
export R(2);
@expansion{} // ** `R(2)` is already global
closureFrac(L);
setring R(1);
kill (R(2));
fraction;                        // f=fraction[1]/fraction[2] via phi
@expansion{} [1]:
@expansion{}    xy
@expansion{} [2]:
@expansion{}    y
@c end example closureFrac d2t_singular/reesclos_lib.doc:203
@end smallexample
@c ---end content closureFrac---
@c ---------------------------------------------------------
@node intprog_lib, toric_lib, reesclos_lib, Commutative algebra
@subsection intprog_lib
@c include of docu for intprog.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/intprog_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/intprog_lib.doc INSTEAD
@c library version: (1.5,2001/02/06)
@c library file: ../Singular/LIB/intprog.lib
@cindex intprog.lib
@cindex intprog_lib
@table @asis
@item @strong{Library:}
intprog.lib
@item @strong{Purpose:}
      Integer Programming with Groebner Basis Methods
@item @strong{Author:}
Christine Theis, email: ctheis@@math.uni-sb.de

@end table

@strong{Procedures:}
@menu
* solve_IP:: procedures for solving Integer Programming problems
@end menu
@c ---end content LibInfo---

@c ------------------- solve_IP -------------
@node solve_IP,,, intprog_lib
@subsubsection solve_IP
@cindex solve_IP
@c ---content solve_IP---
Procedure from library @code{intprog.lib} (@pxref{intprog_lib}).

@table @asis
@item @strong{Usage:}
solve_IP(A,bx,c,alg); A intmat, bx intvec, c intvec, alg string.
solve_IP(A,bx,c,alg); A intmat, bx list of intvec, c intvec,
alg string.
@*solve_IP(A,bx,c,alg,prsv); A intmat, bx intvec, c intvec,
alg string, prsv intvec.
@*solve_IP(A,bx,c,alg,prsv); A intmat, bx list of intvec, c intvec,
alg string, prsv intvec.

@item @strong{Return:}
same type as bx: solution of the associated integer programming
problem(s) as explained in

   @ref{Toric ideals and integer programming}.

@item @strong{Note:}
This procedure returns the solution(s) of the given IP-problem(s)
or the message `not solvable'.
@*One may call the procedure with several different algorithms:
@*- the algorithm of Conti/Traverso (ct),
@*- the positive variant of the algorithm of Conti/Traverso (pct),
@*- the algorithm of Conti/Traverso using elimination (ect),
@*- the algorithm of Pottier (pt),
@*- an algorithm of Bigatti/La Scala/Robbiano (blr),
@*- the algorithm of Hosten/Sturmfels (hs),
@*- the algorithm of DiBiase/Urbanke (du).
The argument `alg' should be the abbreviation for an algorithm as
above: ct, pct, ect, pt, blr, hs or du.

`ct' allows computation of an optimal solution of the IP-problem
directly from the right-hand vector b.
@*The same is true for its `positive' variant `pct' which may only be
applied if A and b have nonnegative entries.
@*All other algorithms need initial solutions of the IP-problem.

If `alg' is chosen to be `ct' or `pct', bx is read as the right hand
vector b of the system Ax=b. b should then be an intvec of size m
where m is the number of rows of A.
@*Furthermore, bx and A should be nonnegative if `pct' is used.
If `alg' is chosen to be `ect',`pt',`blr',`hs' or `du',
bx is read as an initial solution x of the system Ax=b.
bx should then be a nonnegative intvec of size n where n is the
number of columns of A.

If `alg' is chosen to be `blr' or `hs', the algorithm needs a vector
with positive coefficients in the row space of A.
@*If no row of A contains only positive entries, one has to use the
versions of solve_IP which take such a vector prsv as an argument.

solve_IP may also be called with a list bx of intvecs instead of a
single intvec.

@end table
@strong{Example:}
@smallexample
@c computed example solve_IP d2t_singular/intprog_lib.doc:85 
LIB "intprog.lib";
// 1. call with single right-hand vector
intmat A[2][3]=1,1,0,0,1,1;
intvec b1=1,1;
intvec c=2,2,1;
intvec solution_vector=solve_IP(A,b1,c,"pct");
solution_vector;"";
@expansion{} 0,1,0
@expansion{} 
// 2. call with list of right-hand vectors
intvec b2=-1,1;
list l=b1,b2;
l;
@expansion{} [1]:
@expansion{}    1,1
@expansion{} [2]:
@expansion{}    -1,1
list solution_list=solve_IP(A,l,c,"ct");
solution_list;"";
@expansion{} [1]:
@expansion{}    0,1,0
@expansion{} [2]:
@expansion{}    not solvable
@expansion{} 
// 3. call with single initial solution vector
A=2,1,-1,-1,1,2;
b1=3,4,5;
solve_IP(A,b1,c,"du");"";
@expansion{} 0,7,2
@expansion{} 
// 4. call with single initial solution vector
//    and algorithm needing a positive row space vector
solution_vector=solve_IP(A,b1,c,"hs");"";
@expansion{} ERROR: The chosen algorithm needs a positive vector in the row space of t\
   he matrix.
@expansion{} 0
@expansion{} 
// 5. call with single initial solution vector
//     and positive row space vector
intvec prsv=1,2,1;
solution_vector=solve_IP(A,b1,c,"hs",prsv);
solution_vector;"";
@expansion{} 0,7,2
@expansion{} 
// 6. call with list of initial solution vectors
//    and positive row space vector
b2=7,8,0;
l=b1,b2;
l;
@expansion{} [1]:
@expansion{}    3,4,5
@expansion{} [2]:
@expansion{}    7,8,0
solution_list=solve_IP(A,l,c,"blr",prsv);
solution_list;
@expansion{} [1]:
@expansion{}    0,7,2
@expansion{} [2]:
@expansion{}    7,8,0
@c end example solve_IP d2t_singular/intprog_lib.doc:85
@end smallexample
@c inserted refs from d2t_singular/intprog_lib.doc:120
@menu
See also:
* Integer programming::
* intprog_lib::
* toric_lib::
@end menu
@c end inserted refs from d2t_singular/intprog_lib.doc:120

@c ---end content solve_IP---
@c ---------------------------------------------------------
@node toric_lib, ,intprog_lib, Commutative algebra
@subsection toric_lib
@c include of docu for toric.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/toric_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/toric_lib.doc INSTEAD
@c library version: (1.11,2001/02/06)
@c library file: ../Singular/LIB/toric.lib
@cindex toric.lib
@cindex toric_lib
@table @asis
@item @strong{Library:}
toric.lib
@item @strong{Purpose:}
   Standard Basis of Toric Ideals
@item @strong{Author:}
Christine Theis, email: ctheis@@math.uni-sb.de

@end table

@strong{Procedures:}
@menu
* toric_ideal:: computes the toric ideal of A
* toric_std:: standard basis of I by a specialized Buchberger algorithm
@end menu
@c ---end content LibInfo---

@c ------------------- toric_ideal -------------
@node toric_ideal, toric_std,, toric_lib
@subsubsection toric_ideal
@cindex toric_ideal
@c ---content toric_ideal---
Procedure from library @code{toric.lib} (@pxref{toric_lib}).

@table @asis
@item @strong{Usage:}
toric_ideal(A,alg); A intmat, alg string
@*toric_ideal(A,alg,prsv); A intmat, alg string, prsv intvec

@item @strong{Return:}
ideal: standard basis of the toric ideal of A

@item @strong{Note:}
These procedures return the standard basis of the toric ideal of A
with respect to the term ordering in the current basering. Not all
term orderings are supported: The usual global term orderings may be
used, but no block orderings combining them.
@*One may call the procedure with several different algorithms: @*
- the algorithm of Conti/Traverso using elimination (ect), @*
- the algorithm of Pottier (pt),
@*- an algorithm of Bigatti/La Scala/Robbiano (blr),
@*- the algorithm of Hosten/Sturmfels (hs),
@*- the algorithm of DiBiase/Urbanke (du).
@*The argument `alg' should be the abbreviation for an algorithm as
above: ect, pt, blr, hs or du.

If `alg' is chosen to be `blr' or `hs', the algorithm needs a vector
with positive coefficients in the row space of A.
@*If no row of A contains only positive entries, one has to use the
second version of toric_ideal which takes such a vector as its third
argument.
@*For the mathematical background, see

  @ref{Toric ideals and integer programming}.

@end table
@strong{Example:}
@smallexample
@c computed example toric_ideal d2t_singular/toric_lib.doc:64 
LIB "toric.lib";
ring r=0,(x,y,z),dp;
// call with two arguments
intmat A[2][3]=1,1,0,0,1,1;
A;
@expansion{} 1,1,0,
@expansion{} 0,1,1 
ideal I=toric_ideal(A,"du");
I;
@expansion{} I[1]=xz-y
I=toric_ideal(A,"blr");
@expansion{} ERROR: The chosen algorithm needs a positive vector in the row space of t\
   he matrix.
I;
@expansion{} I[1]=0
// call with three arguments
intvec prsv=1,2,1;
I=toric_ideal(A,"blr",prsv);
I;
@expansion{} I[1]=xz-y
@c end example toric_ideal d2t_singular/toric_lib.doc:64
@end smallexample
@c inserted refs from d2t_singular/toric_lib.doc:80
@menu
See also:
* Toric ideals::
* intprog_lib::
* toric_lib::
* toric_std::
@end menu
@c end inserted refs from d2t_singular/toric_lib.doc:80

@c ---end content toric_ideal---

@c ------------------- toric_std -------------
@node toric_std,, toric_ideal, toric_lib
@subsubsection toric_std
@cindex toric_std
@c ---content toric_std---
Procedure from library @code{toric.lib} (@pxref{toric_lib}).

@table @asis
@item @strong{Usage:}
toric_std(I); I ideal

@item @strong{Return:}
ideal: standard basis of I

@item @strong{Note:}
This procedure computes the standard basis of I using a specialized
Buchberger algorithm. The generating system by which I is given has
to consist of binomials of the form x^u-x^v. There is no real check
if I is toric. If I is generated by binomials of the above form,
but not toric, toric_std computes an ideal `between' I and its
saturation with respect to all variables.
@*For the mathematical background, see

   @ref{Toric ideals and integer programming}.

@end table
@strong{Example:}
@smallexample
@c computed example toric_std d2t_singular/toric_lib.doc:114 
LIB "toric.lib";
ring r=0,(x,y,z),wp(3,2,1);
// call with toric ideal (of the matrix A=(1,1,1))
ideal I=x-y,x-z;
ideal J=toric_std(I);
J;
@expansion{} J[1]=y-z
@expansion{} J[2]=x-z
// call with the same ideal, but badly chosen generators:
// 1) not only binomials
I=x-y,2x-y-z;
J=toric_std(I);
@expansion{} ERROR: Generator 2 of the input ideal is no difference of monomials.
// 2) binomials whose monomials are not relatively prime
I=x-y,xy-yz,y-z;
J=toric_std(I);
@expansion{} Warning: The monomials of generator 2 of the input ideal are not relative\
   ly prime.
J;
@expansion{} J[1]=y-z
@expansion{} J[2]=x-z
// call with a non-toric ideal that seems to be toric
I=x-yz,xy-z;
J=toric_std(I);
J;
@expansion{} J[1]=y2-1
@expansion{} J[2]=x-yz
// comparison with real standard basis and saturation
ideal H=std(I);
H;
@expansion{} H[1]=x-yz
@expansion{} H[2]=y2z-z
LIB "elim.lib";
sat(H,xyz);
@expansion{} [1]:
@expansion{}    _[1]=x-yz
@expansion{}    _[2]=y2-1
@expansion{} [2]:
@expansion{}    1
@c end example toric_std d2t_singular/toric_lib.doc:114
@end smallexample
@c inserted refs from d2t_singular/toric_lib.doc:140
@menu
See also:
* Toric ideals::
* intprog_lib::
* toric_ideal::
* toric_lib::
@end menu
@c end inserted refs from d2t_singular/toric_lib.doc:140

@c ---end content toric_std---
@c ----------------------------------------------------------------------------
@node Singularities, Invariant theory, Commutative algebra, SINGULAR libraries
@section Singularities
@cindex Singularities

@menu
@c * alexpoly_lib:: Resolution Graph and Alexander Polynomial
* classify_lib:: procedures for the Arnold-classifier of singularities
* deform_lib:: procedures for computing miniversal deformation
* equising_lib:: procedures for equisingularity strata
* gaussman_lib:: procedures for gauss-manin connection of a singularity
* hnoether_lib:: procedures for the Hamburger-Noether (Puiseux) development
* mondromy_lib:: procedures to compute the monodromy of a singularity
* qhmoduli_lib:: procedures for moduli spaces of sqh-singularities
* sing_lib:: procedures for computing invariants of singularities
* spcurve_lib:: procedures for cm codimension 2 singularities
* spectrum_lib:: procedures for computing singularity spectra
@end menu

@c ---------------------------------------------------------
@c @node alexpoly_lib, classify_lib, Singularities, Singularities
@c @subsection alexpoly_lib
@c @c lib alexpoly.lib
@c ---------------------------------------------------------
@c @node classify_lib, deform_lib, alexpoly_lib, Singularities
@node classify_lib, deform_lib, Singularities, Singularities
@subsection classify_lib
@c include of docu for classify.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/classify_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/classify_lib.doc INSTEAD
@c library version: (1.48.2.4,2002/04/11)
@c library file: ../Singular/LIB/classify.lib
@cindex classify.lib
@cindex classify_lib
@table @asis
@item @strong{Library:}
classify.lib
@item @strong{Purpose:}
  Arnold Classifier of Singularities
@item @strong{Authors:}
Kai Krueger, krueger@@mathematik.uni-kl.de
@*Corina Baciu, baciu@@mathematik.uni-kl.de

@item @strong{Overview:}
A library for classifying isolated hypersurface singularities w.r.t. right
equivalence, based on the determinator of singularities by V.I. Arnold.

@end table

@strong{Procedures:}
@menu
* basicinvariants:: computes Milnor number, determinacy-bound and corank of
* classify:: normal form of poly f determined with Arnold's method
* corank:: computes the corank of f (i.e. of the Hessian of f)
* Hcode:: coding of intvec v according to the number repetitions
* init_debug:: print trace and debugging information depending on int n
* internalfunctions:: display names of internal procedures of this library
* milnorcode:: Hilbert poly of [e-th] Milnor algebra coded with Hcode
* morsesplit:: residual part of f after applying the splitting lemma
* quickclass:: normal form of f determined by invariants (milnorcode)
* singularity:: normal form of singularity given by its name s and index
* swap:: returns b,a
* A_L:: shortcut for quickclass(f) or normalform(s)
* normalform:: normal form of singularity given by its name s
* debug_log:: print trace and debugging information w.r.t level>@@DeBug
@end menu
@c ---end content LibInfo---

@c ------------------- basicinvariants -------------
@node basicinvariants, classify,, classify_lib
@subsubsection basicinvariants
@cindex basicinvariants
@c ---content basicinvariants---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
basicinvariants(f); f = poly

@item @strong{Compute:}
Compute basic invariants of f: an upper bound d for the
determinacy, the milnor number mu and the corank c of f

@item @strong{Return:}
intvec: d, mu, c

@end table
@strong{Example:}
@smallexample
@c computed example basicinvariants d2t_singular/classify_lib.doc:61 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
basicinvariants((x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3);
@expansion{} 5,4,2
@c end example basicinvariants d2t_singular/classify_lib.doc:61
@end smallexample
@c ---end content basicinvariants---

@c ------------------- classify -------------
@node classify, corank, basicinvariants, classify_lib
@subsubsection classify
@cindex classify
@c ---content classify---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
classify(f); f=poly

@item @strong{Compute:}
normal form and singularity type of f with respect to right
equivalence, as given in the book "Singularities of differentiable
maps, Volume I" by V.I. Arnold, S.M. Gusein-Zade, A.N. Varchenko

@item @strong{Return:}
normal form of f, of type poly

@item @strong{Remark:}
This version of classify is only beta. Please send bugs and
comments to: "Kai Krueger" <krueger@@mathematik.uni-kl.de> @*
Be sure to have at least Singular version 1.0.1. Updates can be
found at: @*
URL=http://www.mathematik.uni-kl.de/~krueger/Singular/

@item @strong{Note:}
type init_debug(n); (0 <= n <= 10) in order to get intermediate
information, higher values of n give more information.
@*The proc creates several global objects with names all starting
with @@, hence there should be no name conflicts

@end table
@strong{Example:}
@smallexample
@c computed example classify d2t_singular/classify_lib.doc:104 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
classify(f);
@expansion{} About the singularity :
@expansion{}           Milnor number(f)   = 4
@expansion{}           Corank(f)          = 2
@expansion{}           Determinacy       <= 5
@expansion{} Guessing type via Milnorcode:   D[k]=D[4]
@expansion{} 
@expansion{} Computing normal form ...
@expansion{} I have to apply the splitting lemma. This will take some time....:-)
@expansion{}    Arnold step number 4
@expansion{} The singularity
@expansion{}    -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
@expansion{} is R-equivalent to D[4].
@expansion{}    Milnor number = 4
@expansion{}    modality      = 0
@expansion{} 2z2+x2y+y3
init_debug(3);
@expansion{} Debugging level change from  0  to  3
classify(f);
@expansion{} Computing Basicinvariants of f ...
@expansion{} About the singularity :
@expansion{}           Milnor number(f)   = 4
@expansion{}           Corank(f)          = 2
@expansion{}           Determinacy       <= 5
@expansion{} Hcode: 1,2,1,0,0
@expansion{} Milnor code :  1,1,1
@expansion{} Debug:(2):  entering HKclass3_teil_1 1,1,1
@expansion{} Debug:(2):  finishing HKclass3_teil_1
@expansion{} Guessing type via Milnorcode:   D[k]=D[4]
@expansion{} 
@expansion{} Computing normal form ...
@expansion{} I have to apply the splitting lemma. This will take some time....:-)
@expansion{} Debug:(3):  Split the polynomial below using determinacy:  5
@expansion{} Debug:(3):  9y2-12yz+4z2-x3+6x2y-4x2z+xyz+x4+3x2y3
@expansion{} Debug:(2):  Permutations: 3,2,1
@expansion{} Debug:(2):  Permutations: 3,2,1
@expansion{} Debug:(2):  rank determined with Morse rg= 1
@expansion{} Residual singularity f= -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
@expansion{} Step 3
@expansion{}    Arnold step number 4
@expansion{} The singularity
@expansion{}    -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
@expansion{} is R-equivalent to D[4].
@expansion{}    Milnor number = 4
@expansion{}    modality      = 0
@expansion{} Debug:(2):  Decode:
@expansion{} Debug:(2):  S_in= D[4]   s_in= D[4]                          
@expansion{} Debug:(2):  Looking for Normalform of  D[k] with (k,r,s) = ( 4 , 0 , 0 )
@expansion{} Debug:(2):  Opening Singalarity-database:  
@expansion{}  DBM: NFlist
@expansion{} Debug:(2):  DBMread( D[k] )= x2y+y^(k-1) .
@expansion{} Debug:(2):  S= f = x2y+y^(k-1);  Tp= x2y+y^(k-1) Key= I_D[k]
@expansion{} Polynom f= x2y+y3   crk= 2   Mu= 4  MlnCd= 1,1,1
@expansion{} Debug:(2):  Info= x2y+y3
@expansion{} Debug:(2):  Normal form NF(f)= 2*x(3)^2+x(1)^2*x(2)+x(2)^3
@expansion{} 2z2+x2y+y3
@c end example classify d2t_singular/classify_lib.doc:104
@end smallexample
@c ---end content classify---

@c ------------------- corank -------------
@node corank, Hcode, classify, classify_lib
@subsubsection corank
@cindex corank
@c ---content corank---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
corank(f); f=poly

@item @strong{Return:}
the corank of the Hessian matrix of f, of type int

@item @strong{Remark:}
corank(f) is the number of variables occurring in the residual
singularity after applying 'morsesplit' to f

@end table
@strong{Example:}
@smallexample
@c computed example corank d2t_singular/classify_lib.doc:136 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
corank(f);
@expansion{} 2
@c end example corank d2t_singular/classify_lib.doc:136
@end smallexample
@c ---end content corank---

@c ------------------- Hcode -------------
@node Hcode, init_debug, corank, classify_lib
@subsubsection Hcode
@cindex Hcode
@c ---content Hcode---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
Hcode(v); v=intvec

@item @strong{Return:}
intvec, coding v according to the number of successive
repetitions of an entry

@end table
@strong{Example:}
@smallexample
@c computed example Hcode d2t_singular/classify_lib.doc:163 
LIB "classify.lib";
intvec v1 = 1,3,5,5,2;
Hcode(v1);
@expansion{} 1,0,1,0,2,0,0,1,0
intvec v2 = 1,2,3,4,4,4,4,4,4,4,3,2,1;
Hcode(v2);
@expansion{} 1,1,1,7,1,1,1
@c end example Hcode d2t_singular/classify_lib.doc:163
@end smallexample
@c ---end content Hcode---

@c ------------------- init_debug -------------
@node init_debug, internalfunctions, Hcode, classify_lib
@subsubsection init_debug
@cindex init_debug
@c ---content init_debug---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
init_debug([level]); level=int

@item @strong{Compute:}
Set the global variable @@DeBug to level. The variable @@DeBug is
used by the function debug_log(level, list of strings) to know
when to print the list of strings. init_debug() reports only
changes of @@DeBug.

@item @strong{Note:}
The procedure init_debug(n); is useful as trace-mode. n may
range from 0 to 10, higher values of n give more information.

@end table
@strong{Example:}
@smallexample
@c computed example init_debug d2t_singular/classify_lib.doc:197 
LIB "classify.lib";
init_debug();
debug_log(1,"no trace information printed");
init_debug(1);
@expansion{} Debugging level change from  0  to  1
debug_log(1,"some trace information");
@expansion{} some trace information
init_debug(2);
@expansion{} Debugging level change from  1  to  2
debug_log(2,"nice for debugging scripts");
@expansion{} Debug:(2):  nice for debugging scripts
init_debug(0);
@expansion{} Debugging switched off.
@c end example init_debug d2t_singular/classify_lib.doc:197
@end smallexample
@c ---end content init_debug---

@c ------------------- internalfunctions -------------
@node internalfunctions, milnorcode, init_debug, classify_lib
@subsubsection internalfunctions
@cindex internalfunctions
@c ---content internalfunctions---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
internalfunctions();

@item @strong{Return:}
nothing, display names of internal procedures of classify.lib

@end table
@strong{Example:}
@smallexample
@c computed example internalfunctions d2t_singular/classify_lib.doc:227 
LIB "classify.lib";
internalfunctions();
@expansion{}    Internal functions for the classification using Arnold's method,
@expansion{}    the function numbers correspond to numbers in Arnold's classifier:
@expansion{} Klassifiziere(poly f);      //determine the type of the singularity f
@expansion{}   Funktion1bis (poly f, list cstn)
@expansion{}   Funktion3 (poly f, list cstn)
@expansion{}   Funktion6 (poly f, list cstn)
@expansion{}   Funktion13 (poly f, list cstn)
@expansion{}   Funktion17 (poly f, list cstn)
@expansion{}   Funktion25 (poly f, list cstn)
@expansion{}   Funktion40 (poly f, list cstn, int k)
@expansion{}   Funktion47 (poly f, list cstn)
@expansion{}   Funktion50 (poly f, list cstn)
@expansion{}   Funktion58 (poly fin, list cstn)
@expansion{}   Funktion59 (poly f, list cstn)
@expansion{}   Funktion66 (poly f, list cstn)
@expansion{}   Funktion82 (poly f, list cstn)
@expansion{}   Funktion83 (poly f, list cstn)
@expansion{}   Funktion91 (poly f, list cstn, int k)
@expansion{}   Funktion92 (poly f, list cstn, int k)
@expansion{}   Funktion93 (poly f, list cstn, int k)
@expansion{}   Funktion94 (poly f, list cstn, int k)
@expansion{}   Funktion95 (poly f, list cstn, int k)
@expansion{}   Funktion96 (poly f, list cstn, int k)
@expansion{}   Funktion97 (poly f, list cstn)
@expansion{}   Isomorphie_s82_x (poly f, poly fk, int k)
@expansion{}   Isomorphie_s82_z (poly f, poly fk, int k)
@expansion{}   Isomorphie_s17 (poly f, poly fk, int k, int ct)
@expansion{}   printresult (string f,string typ,int Mu,int m,int corank,int K)
@expansion{}   
@expansion{}    Internal functions for the classifcation by invariants:
@expansion{}   Cubic (poly f)
@expansion{}   parity (int e)             //return the parity of e
@expansion{}   HKclass (intvec i)
@expansion{}   HKclass3( intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass3_teil_1 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass5 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass5_teil_1 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass5_teil_2 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass7 (intvec i, string SG_Typ, int cnt)
@expansion{}   HKclass7_teil_1 (intvec i, string SG_Typ, int cnt)
@expansion{}   
@expansion{}    Internal functions for the Morse-splitting lemma:
@expansion{}   Morse(poly fi, int K, int corank)  //splitting lemma itself
@expansion{}   Coeffs (list #)
@expansion{}   Coeff
@expansion{}   
@expansion{}    Internal functions providing tools:
@expansion{}   ReOrder(poly f)
@expansion{}   Singularitaet(string typ,int k,int r,int s,poly a,poly b,poly c,poly d)
@expansion{}   RandomPolyK
@expansion{}   Faktorisiere(poly f, poly g, int p, int k)   compute g = (ax+by^k)^p
@expansion{}   Teile(poly f, poly g);             //divides f by g
@expansion{}   GetRf(poly f, int n);
@expansion{}   Show(poly f);
@expansion{}   checkring();
@expansion{}   DecodeNormalFormString(string s);
@expansion{}   Setring(int n, string ringname);
@expansion{}   
@c end example internalfunctions d2t_singular/classify_lib.doc:227
@end smallexample
@c ---end content internalfunctions---

@c ------------------- milnorcode -------------
@node milnorcode, morsesplit, internalfunctions, classify_lib
@subsubsection milnorcode
@cindex milnorcode
@c ---content milnorcode---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
milnorcode(f[,e]); f=poly, e=int

@item @strong{Return:}
intvec, coding the Hilbert function of the e-th Milnor algebra
of f, i.e. of basering/(jacob(f)^e) (default e=1), according
to proc Hcode

@end table
@strong{Example:}
@smallexample
@c computed example milnorcode d2t_singular/classify_lib.doc:253 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
poly f=x2y+y3+z2;
milnorcode(f);
@expansion{} 1,1,1
milnorcode(f,2);  // a big second argument may result in memory overflow
@expansion{} 1,0,1,0,2,0,0,1,0
@c end example milnorcode d2t_singular/classify_lib.doc:253
@end smallexample
@c ---end content milnorcode---

@c ------------------- morsesplit -------------
@node morsesplit, quickclass, milnorcode, classify_lib
@subsubsection morsesplit
@cindex morsesplit
@c ---content morsesplit---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
morsesplit(f); f=poly

@item @strong{Return:}
Normal form of f in M^3 after application of the splitting lemma

@item @strong{Compute:}
apply the splitting lemma (generalized Morse lemma) to f

@end table
@strong{Example:}
@smallexample
@c computed example morsesplit d2t_singular/classify_lib.doc:283 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
export r;
@expansion{} // ** `r` is already global
init_debug(1);
@expansion{} Debugging level is set to  1
poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
poly g=morsesplit(f);
@expansion{} Residual singularity f= -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
g;
@expansion{} -x3+3/2xy2+1/2x3y-1/16x2y2+3x2y3
@c end example morsesplit d2t_singular/classify_lib.doc:283
@end smallexample
@c ---end content morsesplit---

@c ------------------- quickclass -------------
@node quickclass, singularity, morsesplit, classify_lib
@subsubsection quickclass
@cindex quickclass
@c ---content quickclass---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
quickclass(f); f=poly

@item @strong{Return:}
Normal form of f in Arnold's list

@item @strong{Remark:}
try to determine the normal form of f by invariants, mainly by
computing the Hilbert function of the Milnor algebra,
no coordinate change is needed (see also proc 'milnorcode').

@end table
@strong{Example:}
@smallexample
@c computed example quickclass d2t_singular/classify_lib.doc:317 
LIB "classify.lib";
ring r=0,(x,y,z),ds;
poly f=(x2+3y-2z)^2+xyz-(x-y3+x2*z3)^3;
quickclass(f);
@expansion{} Singularity R-equivalent to :  D[k]=D[4]
@expansion{} normal form : z2+x2y+y3
@expansion{} z2+x2y+y3
@c end example quickclass d2t_singular/classify_lib.doc:317
@end smallexample
@c ---end content quickclass---

@c ------------------- singularity -------------
@node singularity, swap, quickclass, classify_lib
@subsubsection singularity
@cindex singularity
@c ---content singularity---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
singularity(t, l); t=string (name of singularity),
@*l=list of integers/polynomials (indices/parameters of singularity)

@item @strong{Compute:}
get the singularity named by type t from the database.
list l is as follows: @*
l= k [,r [,s [,a [,b [,c [,d]..]: k,r,s=int a,b,c,d=poly. @*
The name of the dbm-database file is: NFlist.[dir,pag].
The file is found in the current directory. If it does not
exist, please run the script MakeDBM first.

@item @strong{Return:}
Normal form and corank of the singularity named by type t and its
index (indices) l.

@end table
@strong{Example:}
@smallexample
@c computed example singularity d2t_singular/classify_lib.doc:353 
LIB "classify.lib";
ring r=0,(x,y,z),(c,ds);
init_debug(0);
singularity("E[6k]",6);
@expansion{} [1]:
@expansion{}    x3+xy13+y19
@expansion{} [2]:
@expansion{}    2
singularity("T[k,r,s]", 3, 7, 5);
@expansion{} [1]:
@expansion{}    x3+xyz+z5+y7
@expansion{} [2]:
@expansion{}    3
poly f=y;
singularity("J[k,r]", 4, 0, 0, f);
@expansion{} [1]:
@expansion{}    x3+x2y4+y13
@expansion{} [2]:
@expansion{}    2
@c end example singularity d2t_singular/classify_lib.doc:353
@end smallexample
@c ---end content singularity---

@c ------------------- swap -------------
@node swap, A_L, singularity, classify_lib
@subsubsection swap
@cindex swap
@c ---content swap---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
swap(a,b);

@item @strong{Return:}
b,a if b,a is the input (any type)

@end table
@strong{Example:}
@smallexample
@c computed example swap d2t_singular/classify_lib.doc:382 
LIB "classify.lib";
swap("variable1","variable2");
@expansion{} variable2 variable1
@c end example swap d2t_singular/classify_lib.doc:382
@end smallexample
@c ---end content swap---

@c ------------------- A_L -------------
@node A_L, normalform, swap, classify_lib
@subsubsection A_L
@cindex A_L
@c ---content A_L---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
A_L(f); f poly
@*A_L(s); s string, the name of the singularity

@item @strong{Compute:}
the normal form of f in Arnold's list of singularities in case 1,
in case 2 nothing has to be computed.

@item @strong{Return:}
A_L(f): compute via 'milnorcode' the class of f and return the normal
form of f found in the database.
@*A_L("name"): get the normal form from the database for the
singularity given by its name.

@end table
@strong{Example:}
@smallexample
@c computed example A_L d2t_singular/classify_lib.doc:414 
LIB "classify.lib";
ring r=0,(a,b,c),ds;
poly f=A_L("E[13]");
f;
@expansion{} c2+a3+ab5+b8
A_L(f);
@expansion{} Singularity R-equivalent to :  E[6k+1]=E[13]
@expansion{} normal form : c2+a3+ab5+b8
@expansion{} c2+a3+ab5+b8
@c end example A_L d2t_singular/classify_lib.doc:414
@end smallexample
@c ---end content A_L---

@c ------------------- normalform -------------
@node normalform, debug_log, A_L, classify_lib
@subsubsection normalform
@cindex normalform
@c ---content normalform---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
normalform(s); s=string

@item @strong{Return:}
Arnold's normal form of singularity with name s

@end table
@strong{Example:}
@smallexample
@c computed example normalform d2t_singular/classify_lib.doc:441 
LIB "classify.lib";
ring r=0,(a,b,c),ds;
normalform("E[13]");
@expansion{} c2+a3+ab5+b8
@c end example normalform d2t_singular/classify_lib.doc:441
@end smallexample
@c ---end content normalform---

@c ------------------- debug_log -------------
@node debug_log,, normalform, classify_lib
@subsubsection debug_log
@cindex debug_log
@c ---content debug_log---
Procedure from library @code{classify.lib} (@pxref{classify_lib}).

@table @asis
@item @strong{Usage:}
debug_log(level,li); level=int, li=comma separated "message" list

@item @strong{Compute:}
print "messages" if level>=@@DeBug.
@*useful for user-defined trace messages.

@end table
@strong{Example:}
@smallexample
@c computed example debug_log d2t_singular/classify_lib.doc:467 
LIB "classify.lib";
example init_debug;
@expansion{} // proc init_debug from lib classify.lib
@expansion{} EXAMPLE:
@expansion{}   init_debug();
@expansion{}   debug_log(1,"no trace information printed");
@expansion{}   init_debug(1);
@expansion{} Debugging level change from  0  to  1
@expansion{}   debug_log(1,"some trace information");
@expansion{} some trace information
@expansion{}   init_debug(2);
@expansion{} Debugging level change from  1  to  2
@expansion{}   debug_log(2,"nice for debugging scripts");
@expansion{} Debug:(2):  nice for debugging scripts
@expansion{}   init_debug(0);
@expansion{} Debugging switched off.
@expansion{} 
@c end example debug_log d2t_singular/classify_lib.doc:467
@end smallexample
@c inserted refs from d2t_singular/classify_lib.doc:472
@menu
See also:
* init_debug::
@end menu
@c end inserted refs from d2t_singular/classify_lib.doc:472

@c ---end content debug_log---
@c ----------------------------------------------------------
@node deform_lib, equising_lib, classify_lib, Singularities
@subsection deform_lib
@c include of docu for deform.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/deform_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/deform_lib.doc INSTEAD
@c library version: (1.25.2.2,2003/02/24)
@c library file: ../Singular/LIB/deform.lib
@cindex deform.lib
@cindex deform_lib
@table @asis
@item @strong{Library:}
deform.lib
@item @strong{Purpose:}
    Miniversal Deformation of Singularities and Modules
@item @strong{Author:}
Bernd Martin, email: martin@@math.tu-cottbus.de

@end table

@strong{Procedures:}
@menu
* versal:: miniversal deformation of isolated singularity Fo
* mod_versal:: miniversal deformation of module Mo modulo ideal I
* lift_kbase:: lifting N into standard kbase of M
* lift_rel_kb:: relative lifting N into a kbase of M
* kill_rings:: kills the exported rings from above
@end menu
@c ---end content LibInfo---

@c ------------------- versal -------------
@node versal, mod_versal,, deform_lib
@subsubsection versal
@cindex versal
@c ---content versal---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
versal(Fo[,d,any]); Fo=ideal, d=int, any=list

@item @strong{Compute:}
miniversal deformation of Fo up to degree d (default d=100),

@item @strong{Create:}
Rings (exported):
@*'my'Px = extending the basering Po by new variables given by
"A,B,.." (deformation parameters), returns as basering; the
new variables precede the old ones, the ordering is the
product between "ls" and "ord(Po)"
@*'my'Qx = Px/Fo extending Qo=Po/Fo,
@*'my'So = the embedding-ring of the versal base space,
@*'my'Ox = Px/Js extending So/Js. (default my="")

Matrices (in Px, exported):
@*Js = giving the versal base space (obstructions),
@*Fs = giving the versal family of Fo,
@*Rs = giving the lifting of Ro=syz(Fo).

If d is defined (!=0), it computes up to degree d.
@*If 'any' is defined and any[1] is no string, interactive version.
@*Otherwise 'any' gives predefined strings: "my","param","order","out"
("my" prefix-string, "param" is a letter (e.g. "A") for the name of
first parameter or (e.g. "A(") for index parameter variables, "order"
ordering string for ring extension), "out" name of output-file).

@item @strong{Note:}
printlevel < 0 no output at all,
@*printlevel >=0,1,2,.. informs you, what is going on;
@*this proc uses 'execute'.

@end table
@strong{Example:}
@smallexample
@c computed example versal d2t_singular/deform_lib.doc:70 
LIB "deform.lib";
int p          = printlevel;
printlevel     = 0;
ring r1        = 0,(x,y,z,u,v),ds;
matrix m[2][4] = x,y,z,u,y,z,u,v;
ideal Fo       = minor(m,2);
// cone over rational normal curve of degree 4
versal(Fo);
@expansion{} // ready: T_1 and T_2
@expansion{} // start computation in degree 2.
@expansion{} 
@expansion{} // Result belongs to ring Px.
@expansion{} // Equations of total space of miniversal deformation are 
@expansion{} // given by Fs, equations of miniversal base space by Js.
@expansion{} // Make Px the basering and list objects defined in Px by typing:
@expansion{}    setring Px; show(Px);
@expansion{}    listvar(matrix);
@expansion{} // NOTE: rings Qx, Px, So are alive!
@expansion{} // (use 'kill_rings("");' to remove)
setring Px;
// ___ Equations of miniversal base space ___:
Js;"";
@expansion{} Js[1,1]=BD
@expansion{} Js[1,2]=-AD+D2
@expansion{} Js[1,3]=-CD
@expansion{} 
// ___ Equations of miniversal total space ___:
Fs;"";
@expansion{} Fs[1,1]=-u2+zv+Bu+Dv
@expansion{} Fs[1,2]=-zu+yv-Au+Du
@expansion{} Fs[1,3]=-yu+xv+Cu+Dz
@expansion{} Fs[1,4]=z2-yu+Az+By
@expansion{} Fs[1,5]=yz-xu+Bx-Cz
@expansion{} Fs[1,6]=-y2+xz+Ax+Cy
@expansion{} 
@c end example versal d2t_singular/deform_lib.doc:70
@end smallexample
@c ---end content versal---

@c ------------------- mod_versal -------------
@node mod_versal, lift_kbase, versal, deform_lib
@subsubsection mod_versal
@cindex mod_versal
@c ---content mod_versal---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
mod_versal(Mo,I[,d,any]); I=ideal, M=module, d=int, any =list

@item @strong{Compute:}
miniversal deformation of coker(Mo) over Qo=Po/Io, Po=basering;

@item @strong{Create:}
Ringsr (exported):
@*'my'Px = extending the basering by new variables (deformation
parameters), the new variables precede the old ones,
@*the ordering is the product between "my_ord"
@*and "ord(Po)"
@*'my'Qx = Px/Io extending Qo (returns as basering),
@*'my'Ox = Px/(Io+Js) ring of the versal deformation of coker(Ms),
@*'my'So = embedding-ring of the versal base space. (default 'my'="")

Matrices (in Qx, exported):
@*Js = giving the versal base space (obstructions),
@*Ms = giving the versal family of Mo,
@*Ls = giving the lifting of syzygies Lo=syz(Mo),

If d is defined (!=0), it computes up to degree d.
@*If 'any' is defined and any[1] is no string, interactive version.
@*Otherwise 'any' gives predefined strings:"my","param","order","out"
("my" prefix-string, "param" is a letter (e.g. "A") for the name of
first parameter or (e.g. "A(") for index parameter variables, "ord"
ordering string for ring extension), "out" name of output-file).

@item @strong{Note:}
printlevel < 0 no output at all,
@*printlevel >=0,1,2,.. informs you, what is going on,
@*this proc uses 'execute'.

@end table
@strong{Example:}
@smallexample
@c computed example mod_versal d2t_singular/deform_lib.doc:132 
LIB "deform.lib";
int p = printlevel;
printlevel = 1;
ring  Ro = 0,(x,y),wp(3,4);
ideal Io = x4+y3;
matrix Mo[2][2] = x2,y,-y2,x2;
mod_versal(Mo,Io);
@expansion{} // vdim (Ext^2) = 4
@expansion{} // vdim (Ext^1) = 4
@expansion{} // ready: Ext1 and Ext2
@expansion{} // Ext1 is quasi-homogeneous represented: 3,6,1,4
@expansion{} // infinitesimal extension
@expansion{} x2-Ax-B,   y+Cx+D,
@expansion{} -y2+Cxy+Dy,x2+Ax+B
@expansion{} // start deg = 2
@expansion{} // start deg = 3
@expansion{} // start deg = 4
@expansion{} // start deg = 5
@expansion{} // finished in degree 
@expansion{} 5
@expansion{} // quasi-homogeneous weights of miniversal base
@expansion{} 3,6,1,4
@expansion{} // Result belongs to qring Qx
@expansion{} // Equations of total space of miniversal deformation are in Js
@expansion{} -2AB+A3+3CD2-BC3-3AC2D+A2C3,
@expansion{} -B2+A2B+D3-3BC2D+ABC3
@expansion{} // Matrix of the deformed module is Ms and lifted syzygies are Ls.
@expansion{} // Make Qx the basering and list objects defined in Qx by typing:
@expansion{}    listvar(ring);setring Qx; show(Qx);listvar(ideal);listvar(matrix);
@expansion{} // NOTE: rings Qx, Ox, So are still alive!
@expansion{} // (use: 'kill_rings();' to remove them)
printlevel = p;
if(system("with","Namespaces")) @{
if(nameof(Current) == "Ring" ) @{
kill Top::Px,Top::Qx,Top::So;
@} else @{
kill Ring::Px,Ring::So;
@}
@}
kill Px,Qx,So;
@c end example mod_versal d2t_singular/deform_lib.doc:132
@end smallexample
@c ---end content mod_versal---

@c ------------------- lift_kbase -------------
@node lift_kbase, lift_rel_kb, mod_versal, deform_lib
@subsubsection lift_kbase
@cindex lift_kbase
@c ---content lift_kbase---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
lift_kbase(N,M); N,M=poly/ideal/vector/module

@item @strong{Return:}
matrix A, coefficient matrix expressing N as linear combination of
k-basis of M. Let the k-basis have k elements and size(N)=c columns.
Then A satisfies:
@*matrix(reduce(N,std(M)),k,c) = matrix(kbase(std(M)))*A

@item @strong{Assume:}
dim(M)=0 and the monomial ordering is a well ordering or the last
block of the ordering is c or C

@end table
@strong{Example:}
@smallexample
@c computed example lift_kbase d2t_singular/deform_lib.doc:177 
LIB "deform.lib";
ring R=0,(x,y),ds;
module M=[x2,xy],[y2,xy],[0,xx],[0,yy];
module N=[x3+xy,x],[x,x+y2];
print(M);
@expansion{} x2,y2,0, 0,
@expansion{} xy,xy,x2,y2
module kb=kbase(std(M));
print(kb);
@expansion{} y2,xy,y,x,1,0,0,0,
@expansion{} 0, 0, 0,0,0,y,x,1 
print(N);
@expansion{} xy+x3,x,  
@expansion{} x,    x+y2
matrix A=lift_kbase(N,M);
print(A);
@expansion{} 0,0,
@expansion{} 1,0,
@expansion{} 0,0,
@expansion{} 0,1,
@expansion{} 0,0,
@expansion{} 0,0,
@expansion{} 1,1,
@expansion{} 0,0 
matrix(reduce(N,std(M)),nrows(kb),ncols(A)) - matrix(kbase(std(M)))*A;
@expansion{} _[1,1]=0
@expansion{} _[1,2]=0
@expansion{} _[2,1]=0
@expansion{} _[2,2]=0
@c end example lift_kbase d2t_singular/deform_lib.doc:177
@end smallexample
@c ---end content lift_kbase---

@c ------------------- lift_rel_kb -------------
@node lift_rel_kb, kill_rings, lift_kbase, deform_lib
@subsubsection lift_rel_kb
@cindex lift_rel_kb
@c ---content lift_rel_kb---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
lift_rel_kb(N,M[,kbaseM,p]);

@item @strong{Assume:}
[p a monomial ] or the product of all variables
@*N, M modules of same rank, M depending only on variables not in p
and vdim(M) is finite in this ring,
@*[ kbaseM the kbase of M in the subring given by variables not in p ] @*
warning: these assumptions are not checked by the procedure

@item @strong{Return:}
matrix A, whose j-th columns present the coeff's of N[j] in kbaseM,
i.e. kbaseM*A = reduce(N,std(M))

@end table
@strong{Example:}
@smallexample
@c computed example lift_rel_kb d2t_singular/deform_lib.doc:218 
LIB "deform.lib";
ring r=0,(A,B,x,y),dp;
module M      = [x2,xy],[xy,y3],[y2],[0,x];
module kbaseM = [1],[x],[xy],[y],[0,1],[0,y],[0,y2];
poly f=xy;
module N = [AB,BBy],[A3xy+x4,AB*(1+y2)];
matrix A = lift_rel_kb(N,M,kbaseM,f);
print(A);
@expansion{} AB,0, 
@expansion{} 0, 0, 
@expansion{} 0, A3,
@expansion{} 0, 0, 
@expansion{} 0, AB,
@expansion{} B2,0, 
@expansion{} 0, AB 
"TEST:";
@expansion{} TEST:
print(matrix(kbaseM)*A-matrix(reduce(N,std(M))));
@expansion{} 0,0,
@expansion{} 0,0 
@c end example lift_rel_kb d2t_singular/deform_lib.doc:218
@end smallexample
@c ---end content lift_rel_kb---

@c ------------------- kill_rings -------------
@node kill_rings,, lift_rel_kb, deform_lib
@subsubsection kill_rings
@cindex kill_rings
@c ---content kill_rings---
Procedure from library @code{deform.lib} (@pxref{deform_lib}).

@table @asis
@item @strong{Usage:}
kill_rings([string]);

@item @strong{Return:}
nothing, but kills exported rings generated by procedures
'versal' and 'mod_versal' with optional prefix 'string'

@end table
@c ---end content kill_rings---
@c ----------------------------------------------------------
@node equising_lib, gaussman_lib, deform_lib, Singularities
@subsection equising_lib
@c include of docu for equising.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/equising_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/equising_lib.doc INSTEAD
@c library version: (1.7.2.6,2003/05/23)
@c library file: ../Singular/LIB/equising.lib
@cindex equising.lib
@cindex equising_lib
@table @asis
@item @strong{Library:}
equising.lib
@item @strong{Purpose:}
  Equisingularity Stratum of a Family of Plane Curves
@item @strong{Author:}
Christoph Lossen, lossen@@mathematik.uni-kl.de
@*Andrea Mindnich, mindnich@@mathematik.uni-kl.de

@end table

@strong{Main procedures:}
@menu
* tau_es:: codim of mu-const stratum in semi-universal def. base
* esIdeal:: (Wahl's) equisingularity ideal of f
* esStratum:: equisingularity stratum of a family F
* isEquising:: tests if a given deformation is equisingular
@end menu
@strong{Auxiliary procedure:}
@menu
* control_Matrix:: computes list of blowing-up data
@end menu
@c ---end content LibInfo---

@c ------------------- tau_es -------------
@node tau_es, esIdeal,, equising_lib
@subsubsection tau_es
@cindex tau_es
@c ---content tau_es---
Procedure from library @code{equising.lib} (@pxref{equising_lib}).

@table @asis
@item @strong{Usage:}
tau_es(f); f poly

@item @strong{Assume:}
f is a reduced bivariate polynomial, the basering has precisely
two variables, is local and no qring.

@item @strong{Return:}
int, the codimension of the mu-const stratum in the semi-universal
deformation base.

@item @strong{Note:}
printlevel>=1 displays additional information.
@*When called with any additional parameter, the computation of the
Milnor number is avoided (no check for NND).

@end table
@strong{Example:}
@smallexample
@c reused example tau_es d2t_singular/equising_lib.doc:57 
LIB "equising.lib";
ring r=32003,(x,y),ds;
poly f=(x4-y4)^2-x10;
tau_es(f);
@expansion{} 42
@c end example tau_es d2t_singular/equising_lib.doc:57
@end smallexample
@c inserted refs from d2t_singular/equising_lib.doc:64
@menu
See also:
* esIdeal::
* invariants::
* tjurina::
@end menu
@c end inserted refs from d2t_singular/equising_lib.doc:64

@c ---end content tau_es---

@c ------------------- esIdeal -------------
@node esIdeal, esStratum, tau_es, equising_lib
@subsubsection esIdeal
@cindex esIdeal
@c ---content esIdeal---
Procedure from library @code{equising.lib} (@pxref{equising_lib}).

@table @asis
@item @strong{Usage:}
esIdeal(f); f poly

@item @strong{Assume:}
f is a reduced bivariate polynomial, the basering has precisely
two variables, is local and no qring, and the characteristic of
the ground field does not divide mult(f).

@item @strong{Return:}
list of two ideals:
@format
          _[1]:  equisingularity ideal of f (in sense of Wahl)
          _[2]:  equisingularity ideal of f with fixed section
@end format

@item @strong{Note:}
if some of the above condition is not satisfied then return
value is list(0,0).

@cindex equisingularity ideal
@end table
@strong{Example:}
@smallexample
@c computed example esIdeal d2t_singular/equising_lib.doc:101 
LIB "equising.lib";
ring r=0,(x,y),ds;
poly f=x7+y7+(x-y)^2*x2y2; 
list K=esIdeal(f);
@expansion{} polynomial is Newton degenerated !
@expansion{} 
@expansion{} // 
@expansion{} // versal deformation with triv. section
@expansion{} // =====================================
@expansion{} // 
@expansion{} // 
@expansion{} // Compute equisingular Stratum over Spec(C[t]/t^2)
@expansion{} // ================================================
@expansion{} // 
@expansion{} // finished
@expansion{} // 
option(redSB);
// Wahl's equisingularity ideal:
std(K[1]);
@expansion{} _[1]=4x4y-10x2y3+6xy4+21x6+14y6
@expansion{} _[2]=4x3y2-6x2y3+2xy4+7x6
@expansion{} _[3]=x2y4-xy5
@expansion{} _[4]=x7
@expansion{} _[5]=xy6
@expansion{} _[6]=y7
ring rr=0,(x,y),ds;
poly f=x4+4x3y+6x2y2+4xy3+y4+2x2y15+4xy16+2y17+xy23+y24+y30+y31;
list K=esIdeal(f);
@expansion{} polynomial is Newton degenerated !
@expansion{} 
@expansion{} // 
@expansion{} // versal deformation with triv. section
@expansion{} // =====================================
@expansion{} // 
@expansion{} // 
@expansion{} // Compute equisingular Stratum over Spec(C[t]/t^2)
@expansion{} // ================================================
@expansion{} // 
@expansion{} // finished
@expansion{} // 
vdim(std(K[1]));
@expansion{} 68
// the latter should be equal to: 
tau_es(f);
@expansion{} 68
@c end example esIdeal d2t_singular/equising_lib.doc:101
@end smallexample
@c inserted refs from d2t_singular/equising_lib.doc:117
@menu
See also:
* esStratum::
* tau_es::
@end menu
@c end inserted refs from d2t_singular/equising_lib.doc:117

@c ---end content esIdeal---

@c ------------------- esStratum -------------
@node esStratum, isEquising, esIdeal, equising_lib
@subsubsection esStratum
@cindex esStratum
@c ---content esStratum---
Procedure from library @code{equising.lib} (@pxref{equising_lib}).

@table @asis
@item @strong{Usage:}
esStratum(F[,m,L]); F poly, m int, L list

@item @strong{Assume:}
F defines a deformation of a reduced bivariate polynomial f
and the characteristic of the basering does not divide mult(f). @*
If nv is the number of variables of the basering, then the first
nv-2 variables are the deformation parameters. @*
If the basering is a qring, ideal(basering) must only depend
on the deformation parameters.

@item @strong{Compute:}
equations for the stratum of equisingular deformations with 
fixed (trivial) section.

@item @strong{Return:}
list l: either consisting of an ideal and an integer, where
@format
  l[1]=ideal defining the equisingular stratum
  l[2]=1 if some error has occured,  l[2]=0 otherwise;
@end format
or consisting of a ring and an integer, where
@format
  l[1]=ESSring is a ring extension of basering containing the ideal ES 
        (describing the ES-stratum) and the poly p_F=F,
  l[2]=1 if some error has occured,  l[2]=0 otherwise.
@end format

@item @strong{Note:}
L is supposed to be the output of reddevelop (with the given ordering
of the variables appearing in f). @*
If m is given, the ES Stratum over A/maxideal(m) is computed. @*
This procedure uses @code{execute} or calls a procedure using
@code{execute}.
printlevel>=2 displays additional information.

@cindex equisingular stratum
@end table
@strong{Example:}
@smallexample
@c reused example esStratum d2t_singular/equising_lib.doc:171 
LIB "equising.lib";
int p=printlevel; 
printlevel=1;
ring r = 0,(a,b,c,d,e,f,g,x,y),ds;
poly F = (x2+2xy+y2+x5)+ax+by+cx2+dxy+ey2+fx3+gx4;
list M = esStratum(F);
M[1];
@expansion{} _[1]=g
@expansion{} _[2]=f
@expansion{} _[3]=b
@expansion{} _[4]=a
@expansion{} _[5]=-4c+4d-4e+d2-4ce
printlevel=3;    // displays additional information
esStratum(F,2);  // es stratum over Q[a,b,c,d,e,f,g] / <a,b,c,d,e,f,g>^2
@expansion{} // 
@expansion{} // Compute HN development
@expansion{} // ----------------------
@expansion{} // finished
@expansion{} // 
@expansion{} // Blowup Step 1 completed
@expansion{} // Blowup Step 2 completed
@expansion{} // Blowup Step 3 completed
@expansion{} // 1 branch finished
@expansion{} // 
@expansion{} // Elimination starts:
@expansion{} // -------------------
@expansion{} // finished
@expansion{} // 
@expansion{} // output of 'esStratum' is list consisting of:
@expansion{} //    _[1] = ideal defining equisingular stratum
@expansion{} //    _[2] = 0
@expansion{} [1]:
@expansion{}    _[1]=b
@expansion{}    _[2]=a
@expansion{}    _[3]=c-d+e
@expansion{}    _[4]=g
@expansion{}    _[5]=f
@expansion{} [2]:
@expansion{}    0
ideal I = f-fa,e+b;
qring q = std(I);
poly F = imap(r,F);
esStratum(F);
@expansion{} // 
@expansion{} // Compute HN development
@expansion{} // ----------------------
@expansion{} // finished
@expansion{} // 
@expansion{} // Blowup Step 1 completed
@expansion{} // Blowup Step 2 completed
@expansion{} // Blowup Step 3 completed
@expansion{} // 1 branch finished
@expansion{} // 
@expansion{} // Elimination starts:
@expansion{} // -------------------
@expansion{} // finished
@expansion{} // 
@expansion{} // output of 'esStratum' is list consisting of:
@expansion{} //    _[1] = ideal defining equisingular stratum
@expansion{} //    _[2] = 0
@expansion{} [1]:
@expansion{}    _[1]=e
@expansion{}    _[2]=a
@expansion{}    _[3]=-4c+4d+d2
@expansion{}    _[4]=g
@expansion{} [2]:
@expansion{}    0
printlevel=p;
@c end example esStratum d2t_singular/equising_lib.doc:171
@end smallexample
@c inserted refs from d2t_singular/equising_lib.doc:188
@menu
See also:
* esIdeal::
* isEquising::
@end menu
@c end inserted refs from d2t_singular/equising_lib.doc:188

@c ---end content esStratum---

@c ------------------- isEquising -------------
@node isEquising, control_Matrix, esStratum, equising_lib
@subsubsection isEquising
@cindex isEquising
@c ---content isEquising---
Procedure from library @code{equising.lib} (@pxref{equising_lib}).

@table @asis
@item @strong{Usage:}
isEquising(F[,m,L]); F poly, m int, L list

@item @strong{Assume:}
F defines a deformation of a reduced bivariate polynomial f
and the characteristic of the basering does not divide mult(f). @*
If nv is the number of variables of the basering, then the first
nv-2 variables are the deformation parameters. @*
If the basering is a qring, ideal(basering) must only depend
on the deformation parameters.

@item @strong{Compute:}
tests if the given family is equisingular along the trivial
section.

@item @strong{Return:}
int: 1 if the family is equisingular, 0 otherwise.

@item @strong{Note:}
L is supposed to be the output of reddevelop (with the given ordering
of the variables appearing in f). @*
If m is given, the family is considered over A/maxideal(m). @*
This procedure uses @code{execute} or calls a procedure using
@code{execute}.
printlevel>=2 displays additional information.

@end table
@strong{Example:}
@smallexample
@c reused example isEquising d2t_singular/equising_lib.doc:231 
LIB "equising.lib";
ring r = 0,(a,b,x,y),ds;
poly F = (x2+2xy+y2+x5)+ay3+bx5;
isEquising(F);
@expansion{} 0
ideal I = ideal(a);
qring q = std(I);
poly F = imap(r,F);
isEquising(F);
@expansion{} 1
ring rr=0,(A,B,C,x,y),ls;
poly f=x7+y7+(x-y)^2*x2y2;
poly F=f+A*y*diff(f,x)+B*x*diff(f,x);
isEquising(F);  
@expansion{} 0
isEquising(F,2);    // computation over  Q[a,b] / <a,b>^2
@expansion{} 1
@c end example isEquising d2t_singular/equising_lib.doc:231
@end smallexample
@c ---end content isEquising---

@c ------------------- control_Matrix -------------
@node control_Matrix,, isEquising, equising_lib
@subsubsection control_Matrix
@cindex control_Matrix
@c ---content control_Matrix---
Procedure from library @code{equising.lib} (@pxref{equising_lib}).

@table @asis
@item @strong{Assume:}
L is the output of multsequence(reddevelop(f)).

@item @strong{Return:}
list M of 4 intmat's:
@format
  M[1] contains the multiplicities at the respective infinitely near points 
       p[i,j] (i=step of blowup+1, j=branch) -- if branches j=k,...,k+m pass 
       through the same p[i,j] then the multiplicity is stored in M[1][k,j], 
       while M[1][k+1]=...=M[1][k+m]=0.   
  M[2] contains the number of branches meeting at p[i,j] (again, the information 
       is stored according to the above rule)   
  M[3] contains the information about the splitting of M[1][i,j] with respect to 
       different tangents of branches at p[i,j] (information is stored only for 
       minimal j>=k corresponding to a new tangent direction). 
       The entries are the sum of multiplicities of all branches with the 
       respective tangent.
  M[4] contains the maximal sum of higher multiplicities for a branch passing 
       through p[i,j] ( = degree Bound for blowing up)  
@end format

@item @strong{Note:}
the branches are ordered in such a way that only consecutive branches
can meet at an infinitely near point. @*
the final rows of the matrices M[1],...,M[3] is (1,1,1,...,1), and
correspond to infinitely near points such that the strict transforms
of the branches are smooth and intersect the exceptional divisor
transversally.

@end table
@c inserted refs from d2t_singular/equising_lib.doc:287
@menu
See also:
* multsequence::
@end menu
@c end inserted refs from d2t_singular/equising_lib.doc:287

@c ---end content control_Matrix---
@c ----------------------------------------------------------
@node gaussman_lib, hnoether_lib, equising_lib, Singularities
@subsection gaussman_lib
@c include of docu for gaussman.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/gaussman_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/gaussman_lib.doc INSTEAD
@c library version: (1.33.2.26,2003/02/10)
@c library file: ../Singular/LIB/gaussman.lib
@cindex gaussman.lib
@cindex gaussman_lib
@table @asis
@item @strong{Library:}
gaussman.lib
@item @strong{Purpose:}
  Algorithmic Gauss-Manin Connection

@item @strong{Author:}
Mathias Schulze, email: mschulze@@mathematik.uni-kl.de

@item @strong{Overview:}
A library to compute Hodge-theoretic invariants
@*of isolated hypersurface singularities

@end table

@strong{Procedures:}
@menu
* gmsring:: Gauss-Manin system of t with variable s
* gmsnf:: Gauss-Manin normal form of p
* gmscoeffs:: Gauss-Manin basis representation of p
* bernstein:: roots of the Bernstein polynomial of t
* monodromy:: Jordan data of complex monodromy of t
* spectrum:: singularity spectrum of t
* sppairs:: spectral pairs of t
* spnf:: spectrum normal form of (a,m,V)
* sppnf:: spectral pairs normal form of (a,w,m,V)
* vfilt:: V-filtration of t on Brieskorn lattice
* vwfilt:: weighted V-filtration of t on Brieskorn lattice
* tmatrix:: C[[s]]-matrix of t on Brieskorn lattice
* endvfilt:: endomorphism V-filtration on Jacobian algebra
* spprint:: print spectrum sp
* sppprint:: print spectral pairs spp
* spadd:: sum of spectra sp1 and sp2
* spsub:: difference of spectra sp1 and sp2
* spmul:: linear combination of spectra sp
* spissemicont:: semicontinuity test of spectrum sp
* spsemicont:: semicontinuous combinations of spectra sp0 in sp
* spmilnor:: Milnor number of spectrum sp
* spgeomgenus:: geometrical genus of spectrum sp
* spgamma:: gamma invariant of spectrum sp
@end menu
@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex monodromy
@cindex spectrum
@cindex spectral pairs
@cindex mixed Hodge structure
@cindex V-filtration
@cindex weight filtration
@c inserted refs from d2t_singular/gaussman_lib.doc:56
@menu
See also:
* mondromy_lib::
* spectrum_lib::
@end menu
@c end inserted refs from d2t_singular/gaussman_lib.doc:56

@c ---end content LibInfo---

@c ------------------- gmsring -------------
@node gmsring, gmsnf,, gaussman_lib
@subsubsection gmsring
@cindex gmsring
@c ---content gmsring---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
gmsring(t,s); poly t, string s

@item @strong{Assume:}
characteristic 0; local degree ordering;
@*isolated critical point 0 of t

@item @strong{Return:}
@format
ring G;  Gauss-Manin system of t with variable s
  poly gmspoly=t;
  ideal gmsjacob;  Jacobian ideal of t
  ideal gmsstd;  standard basis of Jacobian ideal
  matrix gmsmatrix;  matrix(gmsjacob)*gmsmatrix==matrix(gmsstd)
  ideal gmsbasis;  monomial vector space basis of Jacobian algebra
  int gmsmaxdeg;  maximal weight of variables
@end format

@item @strong{Note:}
gmsbasis is a C[[s]]-basis of H'' and [t,s]=s^2

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@end table
@strong{Example:}
@smallexample
@c computed example gmsring d2t_singular/gaussman_lib.doc:97 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
def G=gmsring(t,"s");
setring(G);
gmspoly;
@expansion{} x2y2+x5+y5
print(gmsjacob);
@expansion{} 2xy2+5x4,
@expansion{} 2x2y+5y4
print(gmsstd);
@expansion{} 2x2y+5y4,
@expansion{} 2xy2+5x4,
@expansion{} 5x5-5y5,
@expansion{} 10y6+25x3y4
print(gmsmatrix);
@expansion{} 0,1,x, -2xy,  
@expansion{} 1,0,-y,2y2+5x3
print(gmsbasis);
@expansion{} y5,
@expansion{} y4,
@expansion{} y3,
@expansion{} y2,
@expansion{} xy,
@expansion{} y,
@expansion{} x4,
@expansion{} x3,
@expansion{} x2,
@expansion{} x,
@expansion{} 1
gmsmaxdeg;
@expansion{} 1
@c end example gmsring d2t_singular/gaussman_lib.doc:97
@end smallexample
@c ---end content gmsring---

@c ------------------- gmsnf -------------
@node gmsnf, gmscoeffs, gmsring, gaussman_lib
@subsubsection gmsnf
@cindex gmsnf
@c ---content gmsnf---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
gmsnf(p,K); poly p, int K

@item @strong{Assume:}
basering returned by gmsring

@item @strong{Return:}
@format
list nf;
  ideal nf[1];  projection of p to <gmsbasis>C[[s]] mod s^(K+1)
  ideal nf[2];  p==nf[1]+nf[2]
@end format

@item @strong{Note:}
computation can be continued by setting p=nf[2]

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@end table
@strong{Example:}
@smallexample
@c computed example gmsnf d2t_singular/gaussman_lib.doc:143 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
def G=gmsring(t,"s");
setring(G);
list l0=gmsnf(gmspoly,0);
print(l0[1]);
@expansion{} -1/2y5
list l1=gmsnf(gmspoly,1);
print(l1[1]);
@expansion{} -1/2y5+1/2s
list l=gmsnf(l0[2],1);
print(l[1]);
@expansion{} 1/2s
@c end example gmsnf d2t_singular/gaussman_lib.doc:143
@end smallexample
@c ---end content gmsnf---

@c ------------------- gmscoeffs -------------
@node gmscoeffs, bernstein, gmsnf, gaussman_lib
@subsubsection gmscoeffs
@cindex gmscoeffs
@c ---content gmscoeffs---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
gmscoeffs(p,K); poly p, int K

@item @strong{Assume:}
basering constructed by gmsring

@item @strong{Return:}
@format
list l;
  matrix l[1];  C[[s]]-basis representation of p mod s^(K+1)
  ideal l[2];  p==matrix(gmsbasis)*l[1]+l[2]
@end format

@item @strong{Note:}
computation can be continued by setting p=l[2]

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@end table
@strong{Example:}
@smallexample
@c computed example gmscoeffs d2t_singular/gaussman_lib.doc:189 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
def G=gmsring(t,"s");
setring(G);
list l0=gmscoeffs(gmspoly,0);
print(l0[1]);
@expansion{} -1/2,
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0    
list l1=gmscoeffs(gmspoly,1);
print(l1[1]);
@expansion{} -1/2,
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 0,   
@expansion{} 1/2s 
list l=gmscoeffs(l0[2],1);
print(l[1]);
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 0,  
@expansion{} 1/2s
@c end example gmscoeffs d2t_singular/gaussman_lib.doc:189
@end smallexample
@c ---end content gmscoeffs---

@c ------------------- bernstein -------------
@node bernstein, monodromy, gmscoeffs, gaussman_lib
@subsubsection bernstein
@cindex bernstein
@c ---content bernstein---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
bernstein(t); poly t

@item @strong{Assume:}
characteristic 0; local degree ordering;
@*isolated critical point 0 of t

@item @strong{Return:}
ideal r; roots of the Bernstein polynomial b excluding the root -1

@item @strong{Note:}
the roots of b are negative rational numbers and -1 is a root of b

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex Bernstein polynomial
@end table
@strong{Example:}
@smallexample
@c computed example bernstein d2t_singular/gaussman_lib.doc:233 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
bernstein(t);
@expansion{} [1]:
@expansion{}    _[1]=-1/2
@expansion{}    _[2]=-7/10
@expansion{}    _[3]=-9/10
@expansion{}    _[4]=-1
@expansion{}    _[5]=-11/10
@expansion{}    _[6]=-13/10
@expansion{} [2]:
@expansion{}    2,1,1,2,1,1
@c end example bernstein d2t_singular/gaussman_lib.doc:233
@end smallexample
@c ---end content bernstein---

@c ------------------- monodromy -------------
@node monodromy, spectrum, bernstein, gaussman_lib
@subsubsection monodromy
@cindex monodromy
@c ---content monodromy---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
monodromy(t); poly t

@item @strong{Assume:}
characteristic 0; local degree ordering;
@*isolated critical point 0 of t

@item @strong{Return:}
@format
list l;  Jordan data jordan(M) of monodromy matrix exp(-2*pi*i*M)
  ideal l[1]; 
    number l[1][i];  eigenvalue of i-th Jordan block of M
  intvec l[2]; 
    int l[2][i];  size of i-th Jordan block of M
  intvec l[3]; 
    int l[3][i];  multiplicity of i-th Jordan block of M
@end format

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex monodromy
@end table
@strong{Example:}
@smallexample
@c computed example monodromy d2t_singular/gaussman_lib.doc:275 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
monodromy(t);
@expansion{} [1]:
@expansion{}    _[1]=1/2
@expansion{}    _[2]=7/10
@expansion{}    _[3]=9/10
@expansion{}    _[4]=1
@expansion{}    _[5]=11/10
@expansion{}    _[6]=13/10
@expansion{} [2]:
@expansion{}    2,1,1,1,1,1
@expansion{} [3]:
@expansion{}    1,2,2,1,2,2
@c end example monodromy d2t_singular/gaussman_lib.doc:275
@end smallexample
@c inserted refs from d2t_singular/gaussman_lib.doc:282
@menu
See also:
* linalg_lib::
* mondromy_lib::
@end menu
@c end inserted refs from d2t_singular/gaussman_lib.doc:282

@c ---end content monodromy---

@c ------------------- spectrum -------------
@node spectrum, sppairs, monodromy, gaussman_lib
@subsubsection spectrum
@cindex spectrum
@c ---content spectrum---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spectrum(t); poly t

@item @strong{Assume:}
characteristic 0; local degree ordering;
@*isolated critical point 0 of t

@item @strong{Return:}
@format
list sp;  singularity spectrum of t
  ideal sp[1];
    number sp[1][i];  i-th spectral number
  intvec sp[2];
    int sp[2][i];  multiplicity of i-th spectral number
@end format

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex mixed Hodge structure
@cindex V-filtration
@cindex spectrum
@end table
@strong{Example:}
@smallexample
@c computed example spectrum d2t_singular/gaussman_lib.doc:321 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
spprint(spectrum(t));
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
@c end example spectrum d2t_singular/gaussman_lib.doc:321
@end smallexample
@c inserted refs from d2t_singular/gaussman_lib.doc:328
@menu
See also:
* spectrum_lib::
@end menu
@c end inserted refs from d2t_singular/gaussman_lib.doc:328

@c ---end content spectrum---

@c ------------------- sppairs -------------
@node sppairs, spnf, spectrum, gaussman_lib
@subsubsection sppairs
@cindex sppairs
@c ---content sppairs---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
sppairs(t); poly t

@item @strong{Assume:}
characteristic 0; local degree ordering;
@*isolated critical point 0 of t

@item @strong{Return:}
@format
list spp;  spectral pairs of t
  ideal spp[1];
    number spp[1][i];  V-filtration index of i-th spectral pair
  intvec spp[2];
    int spp[2][i];  weight filtration index of i-th spectral pair
  intvec spp[3];
    int spp[3][i];  multiplicity of i-th spectral pair
@end format

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex mixed Hodge structure
@cindex V-filtration
@cindex weight filtration
@cindex spectrum
@cindex spectral pairs
@end table
@strong{Example:}
@smallexample
@c computed example sppairs d2t_singular/gaussman_lib.doc:371 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
sppprint(sppairs(t));
@expansion{} ((-1/2,2),1),((-3/10,1),2),((-1/10,1),2),((0,1),1),((1/10,1),2),((3/10,1)\
   ,2),((1/2,0),1)
@c end example sppairs d2t_singular/gaussman_lib.doc:371
@end smallexample
@c inserted refs from d2t_singular/gaussman_lib.doc:378
@menu
See also:
* spectrum_lib::
@end menu
@c end inserted refs from d2t_singular/gaussman_lib.doc:378

@c ---end content sppairs---

@c ------------------- spnf -------------
@node spnf, sppnf, sppairs, gaussman_lib
@subsubsection spnf
@cindex spnf
@c ---content spnf---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Assume:}
ncols(a)==size(m)==size(V); typeof(V[i])=="int"

@item @strong{Return:}
order (a[i][,V[i]]) with multiplicity m[i] lexicographically

@end table
@c ---end content spnf---

@c ------------------- sppnf -------------
@node sppnf, vfilt, spnf, gaussman_lib
@subsubsection sppnf
@cindex sppnf
@c ---content sppnf---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Assume:}
ncols(e)=size(w)=size(m)=size(V); typeof(V[i])=="module"

@item @strong{Return:}
order (a[i][,w[i]][,V[i]]) with multiplicity m[i] lexicographically

@end table
@c ---end content sppnf---

@c ------------------- vfilt -------------
@node vfilt, vwfilt, sppnf, gaussman_lib
@subsubsection vfilt
@cindex vfilt
@c ---content vfilt---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
vfilt(t); poly t

@item @strong{Assume:}
characteristic 0; local degree ordering;
@*isolated critical point 0 of t

@item @strong{Return:}
@format
list v;  V-filtration on H''/s*H''
  ideal v[1];
    number v[1][i];  V-filtration index of i-th spectral number
  intvec v[2];
    int v[2][i];  multiplicity of i-th spectral number
  list v[3];
    module v[3][i];  vector space of i-th graded part in terms of v[4]
  ideal v[4];  monomial vector space basis of H''/s*H''
  ideal v[5];  standard basis of Jacobian ideal
@end format

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex mixed Hodge structure
@cindex V-filtration
@cindex spectrum
@end table
@strong{Example:}
@smallexample
@c computed example vfilt d2t_singular/gaussman_lib.doc:455 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
vfilt(t);
@expansion{} [1]:
@expansion{}    _[1]=-1/2
@expansion{}    _[2]=-3/10
@expansion{}    _[3]=-1/10
@expansion{}    _[4]=0
@expansion{}    _[5]=1/10
@expansion{}    _[6]=3/10
@expansion{}    _[7]=1/2
@expansion{} [2]:
@expansion{}    1,2,2,1,2,2,1
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(11)
@expansion{}    [2]:
@expansion{}       _[1]=gen(10)
@expansion{}       _[2]=gen(6)
@expansion{}    [3]:
@expansion{}       _[1]=gen(9)
@expansion{}       _[2]=gen(4)
@expansion{}    [4]:
@expansion{}       _[1]=gen(5)
@expansion{}    [5]:
@expansion{}       _[1]=gen(3)
@expansion{}       _[2]=gen(8)
@expansion{}    [6]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=gen(7)
@expansion{}    [7]:
@expansion{}       _[1]=gen(1)
@expansion{} [4]:
@expansion{}    _[1]=y5
@expansion{}    _[2]=y4
@expansion{}    _[3]=y3
@expansion{}    _[4]=y2
@expansion{}    _[5]=xy
@expansion{}    _[6]=y
@expansion{}    _[7]=x4
@expansion{}    _[8]=x3
@expansion{}    _[9]=x2
@expansion{}    _[10]=x
@expansion{}    _[11]=1
@expansion{} [5]:
@expansion{}    _[1]=2x2y+5y4
@expansion{}    _[2]=2xy2+5x4
@expansion{}    _[3]=5x5-5y5
@expansion{}    _[4]=10y6+25x3y4
@c end example vfilt d2t_singular/gaussman_lib.doc:455
@end smallexample
@c inserted refs from d2t_singular/gaussman_lib.doc:462
@menu
See also:
* spectrum_lib::
@end menu
@c end inserted refs from d2t_singular/gaussman_lib.doc:462

@c ---end content vfilt---

@c ------------------- vwfilt -------------
@node vwfilt, tmatrix, vfilt, gaussman_lib
@subsubsection vwfilt
@cindex vwfilt
@c ---content vwfilt---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
vwfilt(t); poly t

@item @strong{Assume:}
characteristic 0; local degree ordering;
@*isolated critical point 0 of t

@item @strong{Return:}
@format
list vw;  weighted V-filtration on H''/s*H''
  ideal vw[1];
    number vw[1][i];  V-filtration index of i-th spectral pair
  intvec vw[2];
    int vw[2][i];  weight filtration index of i-th spectral pair
  intvec vw[3];
    int vw[3][i];  multiplicity of i-th spectral pair
  list vw[4];
    module vw[4][i];  vector space of i-th graded part in terms of vw[5]
  ideal vw[5];  monomial vector space basis of H''/s*H''
  ideal vw[6];  standard basis of Jacobian ideal
@end format

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex mixed Hodge structure
@cindex V-filtration
@cindex weight filtration
@cindex spectrum
@cindex spectral pairs
@end table
@strong{Example:}
@smallexample
@c computed example vwfilt d2t_singular/gaussman_lib.doc:509 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
vwfilt(t);
@expansion{} [1]:
@expansion{}    _[1]=-1/2
@expansion{}    _[2]=-3/10
@expansion{}    _[3]=-1/10
@expansion{}    _[4]=0
@expansion{}    _[5]=1/10
@expansion{}    _[6]=3/10
@expansion{}    _[7]=1/2
@expansion{} [2]:
@expansion{}    2,1,1,1,1,1,0
@expansion{} [3]:
@expansion{}    1,2,2,1,2,2,1
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(11)
@expansion{}    [2]:
@expansion{}       _[1]=gen(10)
@expansion{}       _[2]=gen(6)
@expansion{}    [3]:
@expansion{}       _[1]=gen(9)
@expansion{}       _[2]=gen(4)
@expansion{}    [4]:
@expansion{}       _[1]=gen(5)
@expansion{}    [5]:
@expansion{}       _[1]=gen(3)
@expansion{}       _[2]=gen(8)
@expansion{}    [6]:
@expansion{}       _[1]=gen(2)
@expansion{}       _[2]=gen(7)
@expansion{}    [7]:
@expansion{}       _[1]=gen(1)
@expansion{} [5]:
@expansion{}    _[1]=y5
@expansion{}    _[2]=y4
@expansion{}    _[3]=y3
@expansion{}    _[4]=y2
@expansion{}    _[5]=xy
@expansion{}    _[6]=y
@expansion{}    _[7]=x4
@expansion{}    _[8]=x3
@expansion{}    _[9]=x2
@expansion{}    _[10]=x
@expansion{}    _[11]=1
@expansion{} [6]:
@expansion{}    _[1]=2x2y+5y4
@expansion{}    _[2]=2xy2+5x4
@expansion{}    _[3]=5x5-5y5
@expansion{}    _[4]=10y6+25x3y4
@c end example vwfilt d2t_singular/gaussman_lib.doc:509
@end smallexample
@c inserted refs from d2t_singular/gaussman_lib.doc:516
@menu
See also:
* spectrum_lib::
@end menu
@c end inserted refs from d2t_singular/gaussman_lib.doc:516

@c ---end content vwfilt---

@c ------------------- tmatrix -------------
@node tmatrix, endvfilt, vwfilt, gaussman_lib
@subsubsection tmatrix
@cindex tmatrix
@c ---content tmatrix---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
tmatrix(t); poly t

@item @strong{Assume:}
characteristic 0; local degree ordering;
@*isolated critical point 0 of t

@item @strong{Return:}
@format
list l=A0,A1,T,M;
  matrix A0,A1;  t=A0+s*A1+s^2*(d/ds) on H'' w.r.t. C[[s]]-basis M*T
  module T;  C-basis of C^mu
  ideal M;  monomial C-basis of H''/sH''
@end format

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex mixed Hodge structure
@cindex opposite Hodge filtration
@cindex V-filtration
@end table
@strong{Example:}
@smallexample
@c computed example tmatrix d2t_singular/gaussman_lib.doc:554 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
list A=tmatrix(t);
print(A[1]);
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 1,0,0,0,0,0,0,0,0,0,0 
print(A[2]);
@expansion{} 1/2,0,   0,   0,   0,   0,0,    0,    0,    0,    0, 
@expansion{} 0,  7/10,0,   0,   0,   0,0,    0,    0,    0,    0, 
@expansion{} 0,  0,   7/10,0,   0,   0,0,    0,    0,    0,    0, 
@expansion{} 0,  0,   0,   9/10,0,   0,0,    0,    0,    0,    0, 
@expansion{} 0,  0,   0,   0,   9/10,0,0,    0,    0,    0,    0, 
@expansion{} 0,  0,   0,   0,   0,   1,0,    0,    0,    0,    0, 
@expansion{} 0,  0,   0,   0,   0,   0,11/10,0,    0,    0,    0, 
@expansion{} 0,  0,   0,   0,   0,   0,0,    11/10,0,    0,    0, 
@expansion{} 0,  0,   0,   0,   0,   0,0,    0,    13/10,0,    0, 
@expansion{} 0,  0,   0,   0,   0,   0,0,    0,    0,    13/10,0, 
@expansion{} 0,  0,   0,   0,   0,   0,0,    0,    0,    0,    3/2
print(A[3]);
@expansion{} -1445/64,0,  0,  0,0,85/8,0,0,0,0,1/2,
@expansion{} 0,       125,0,  0,0,0,   0,0,1,0,0,  
@expansion{} 0,       0,  0,  5,0,0,   1,0,0,0,0,  
@expansion{} 0,       0,  0,  0,4,0,   0,0,0,0,0,  
@expansion{} 2,       0,  0,  0,0,1,   0,0,0,0,0,  
@expansion{} 0,       0,  16, 0,0,0,   0,0,0,0,0,  
@expansion{} 0,       0,  125,0,0,0,   0,0,0,1,0,  
@expansion{} 0,       0,  0,  0,5,0,   0,1,0,0,0,  
@expansion{} 0,       0,  0,  4,0,0,   0,0,0,0,0,  
@expansion{} 0,       16, 0,  0,0,0,   0,0,0,0,0,  
@expansion{} -1,      0,  0,  0,0,0,   0,0,0,0,0   
print(A[4]);
@expansion{} y5,
@expansion{} y4,
@expansion{} y3,
@expansion{} y2,
@expansion{} xy,
@expansion{} y,
@expansion{} x4,
@expansion{} x3,
@expansion{} x2,
@expansion{} x,
@expansion{} 1
@c end example tmatrix d2t_singular/gaussman_lib.doc:554
@end smallexample
@c ---end content tmatrix---

@c ------------------- endvfilt -------------
@node endvfilt, spprint, tmatrix, gaussman_lib
@subsubsection endvfilt
@cindex endvfilt
@c ---content endvfilt---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
endvfilt(v); list v

@item @strong{Assume:}
v returned by vfilt

@item @strong{Return:}
@format
list ev;  V-filtration on Jacobian algebra
  ideal ev[1];
    number ev[1][i];  i-th V-filtration index
  intvec ev[2];
    int ev[2][i];  i-th multiplicity
  list ev[3];
    module ev[3][i];  vector space of i-th graded part in terms of ev[4]
  ideal ev[4];  monomial vector space basis of Jacobian algebra
  ideal ev[5];  standard basis of Jacobian ideal
@end format

@cindex singularities
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@cindex mixed Hodge structure
@cindex V-filtration
@cindex endomorphism filtration
@end table
@strong{Example:}
@smallexample
@c computed example endvfilt d2t_singular/gaussman_lib.doc:603 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
poly t=x5+x2y2+y5;
endvfilt(vfilt(t));
@expansion{} [1]:
@expansion{}    _[1]=0
@expansion{}    _[2]=1/5
@expansion{}    _[3]=2/5
@expansion{}    _[4]=1/2
@expansion{}    _[5]=3/5
@expansion{}    _[6]=4/5
@expansion{}    _[7]=1
@expansion{} [2]:
@expansion{}    1,2,2,1,2,2,1
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=gen(11)
@expansion{}    [2]:
@expansion{}       _[1]=gen(10)
@expansion{}       _[2]=gen(6)
@expansion{}    [3]:
@expansion{}       _[1]=gen(9)
@expansion{}       _[2]=gen(4)
@expansion{}    [4]:
@expansion{}       _[1]=gen(5)
@expansion{}    [5]:
@expansion{}       _[1]=gen(8)
@expansion{}       _[2]=gen(3)
@expansion{}    [6]:
@expansion{}       _[1]=gen(7)
@expansion{}       _[2]=gen(2)
@expansion{}    [7]:
@expansion{}       _[1]=gen(1)
@expansion{} [4]:
@expansion{}    _[1]=y5
@expansion{}    _[2]=y4
@expansion{}    _[3]=y3
@expansion{}    _[4]=y2
@expansion{}    _[5]=xy
@expansion{}    _[6]=y
@expansion{}    _[7]=x4
@expansion{}    _[8]=x3
@expansion{}    _[9]=x2
@expansion{}    _[10]=x
@expansion{}    _[11]=1
@expansion{} [5]:
@expansion{}    _[1]=2x2y+5y4
@expansion{}    _[2]=2xy2+5x4
@expansion{}    _[3]=5x5-5y5
@expansion{}    _[4]=10y6+25x3y4
@c end example endvfilt d2t_singular/gaussman_lib.doc:603
@end smallexample
@c ---end content endvfilt---

@c ------------------- spprint -------------
@node spprint, sppprint, endvfilt, gaussman_lib
@subsubsection spprint
@cindex spprint
@c ---content spprint---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spprint(sp); list sp

@item @strong{Return:}
string s; spectrum sp

@end table
@strong{Example:}
@smallexample
@c computed example spprint d2t_singular/gaussman_lib.doc:629 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
@c end example spprint d2t_singular/gaussman_lib.doc:629
@end smallexample
@c ---end content spprint---

@c ------------------- sppprint -------------
@node sppprint, spadd, spprint, gaussman_lib
@subsubsection sppprint
@cindex sppprint
@c ---content sppprint---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
sppprint(spp); list spp

@item @strong{Return:}
string s; spectral pairs spp

@end table
@strong{Example:}
@smallexample
@c computed example sppprint d2t_singular/gaussman_lib.doc:655 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list spp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(2,1,1,1,1,1,0),intvec(1,2,2,1,2,2,1));
sppprint(spp);
@expansion{} ((-1/2,2),1),((-3/10,1),2),((-1/10,1),2),((0,1),1),((1/10,1),2),((3/10,1)\
   ,2),((1/2,0),1)
@c end example sppprint d2t_singular/gaussman_lib.doc:655
@end smallexample
@c ---end content sppprint---

@c ------------------- spadd -------------
@node spadd, spsub, sppprint, gaussman_lib
@subsubsection spadd
@cindex spadd
@c ---content spadd---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spadd(sp1,sp2); list sp1, list sp2

@item @strong{Return:}
list sp; sum of spectra sp1 and sp2

@end table
@strong{Example:}
@smallexample
@c computed example spadd d2t_singular/gaussman_lib.doc:681 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp1);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
list sp2=list(ideal(-1/6,1/6),intvec(1,1));
spprint(sp2);
@expansion{} (-1/6,1),(1/6,1)
spprint(spadd(sp1,sp2));
@expansion{} (-1/2,1),(-3/10,2),(-1/6,1),(-1/10,2),(0,1),(1/10,2),(1/6,1),(3/10,2),(1/\
   2,1)
@c end example spadd d2t_singular/gaussman_lib.doc:681
@end smallexample
@c ---end content spadd---

@c ------------------- spsub -------------
@node spsub, spmul, spadd, gaussman_lib
@subsubsection spsub
@cindex spsub
@c ---content spsub---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spsub(sp1,sp2); list sp1, list sp2

@item @strong{Return:}
list sp; difference of spectra sp1 and sp2

@end table
@strong{Example:}
@smallexample
@c computed example spsub d2t_singular/gaussman_lib.doc:710 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp1);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
list sp2=list(ideal(-1/6,1/6),intvec(1,1));
spprint(sp2);
@expansion{} (-1/6,1),(1/6,1)
spprint(spsub(sp1,sp2));
@expansion{} (-1/2,1),(-3/10,2),(-1/6,-1),(-1/10,2),(0,1),(1/10,2),(1/6,-1),(3/10,2),(\
   1/2,1)
@c end example spsub d2t_singular/gaussman_lib.doc:710
@end smallexample
@c ---end content spsub---

@c ------------------- spmul -------------
@node spmul, spissemicont, spsub, gaussman_lib
@subsubsection spmul
@cindex spmul
@c ---content spmul---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spmul(sp0,k); list sp0, int[vec] k

@item @strong{Return:}
list sp; linear combination of spectra sp0 with coefficients k

@end table
@strong{Example:}
@smallexample
@c computed example spmul d2t_singular/gaussman_lib.doc:739 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
spprint(spmul(sp,2));
@expansion{} (-1/2,2),(-3/10,4),(-1/10,4),(0,2),(1/10,4),(3/10,4),(1/2,2)
list sp1=list(ideal(-1/6,1/6),intvec(1,1));
spprint(sp1);
@expansion{} (-1/6,1),(1/6,1)
list sp2=list(ideal(-1/3,0,1/3),intvec(1,2,1));
spprint(sp2);
@expansion{} (-1/3,1),(0,2),(1/3,1)
spprint(spmul(list(sp1,sp2),intvec(1,2)));
@expansion{} (-1/3,2),(-1/6,1),(0,4),(1/6,1),(1/3,2)
@c end example spmul d2t_singular/gaussman_lib.doc:739
@end smallexample
@c ---end content spmul---

@c ------------------- spissemicont -------------
@node spissemicont, spsemicont, spmul, gaussman_lib
@subsubsection spissemicont
@cindex spissemicont
@c ---content spissemicont---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spissemicont(sp[,1]); list sp, int opt

@item @strong{Return:}
@format
int k=
  1;  if sum of sp is positive on all intervals [a,a+1) [and (a,a+1)]
  0;  if sum of sp is negative on some interval [a,a+1) [or (a,a+1)]
@end format

@end table
@strong{Example:}
@smallexample
@c computed example spissemicont d2t_singular/gaussman_lib.doc:775 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp1=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp1);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
list sp2=list(ideal(-1/6,1/6),intvec(1,1));
spprint(sp2);
@expansion{} (-1/6,1),(1/6,1)
spissemicont(spsub(sp1,spmul(sp2,3)));
@expansion{} 1
spissemicont(spsub(sp1,spmul(sp2,4)));
@expansion{} 0
@c end example spissemicont d2t_singular/gaussman_lib.doc:775
@end smallexample
@c ---end content spissemicont---

@c ------------------- spsemicont -------------
@node spsemicont, spmilnor, spissemicont, gaussman_lib
@subsubsection spsemicont
@cindex spsemicont
@c ---content spsemicont---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spsemicont(sp0,sp,k[,1]); list sp0, list sp

@item @strong{Return:}
@format
list l;
  intvec l[i];  if the spectra sp0 occur with multiplicities k
                in a deformation of a [quasihomogeneous] singularity
                with spectrum sp then k<=l[i]
@end format

@end table
@strong{Example:}
@smallexample
@c computed example spsemicont d2t_singular/gaussman_lib.doc:810 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp0=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp0);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
list sp1=list(ideal(-1/6,1/6),intvec(1,1));
spprint(sp1);
@expansion{} (-1/6,1),(1/6,1)
list sp2=list(ideal(-1/3,0,1/3),intvec(1,2,1));
spprint(sp2);
@expansion{} (-1/3,1),(0,2),(1/3,1)
list sp=sp1,sp2;
list l=spsemicont(sp0,sp);
l;
@expansion{} [1]:
@expansion{}    3
@expansion{} [2]:
@expansion{}    2,1
spissemicont(spsub(sp0,spmul(sp,l[1])));
@expansion{} 1
spissemicont(spsub(sp0,spmul(sp,l[1]-1)));
@expansion{} 1
spissemicont(spsub(sp0,spmul(sp,l[1]+1)));
@expansion{} 0
@c end example spsemicont d2t_singular/gaussman_lib.doc:810
@end smallexample
@c ---end content spsemicont---

@c ------------------- spmilnor -------------
@node spmilnor, spgeomgenus, spsemicont, gaussman_lib
@subsubsection spmilnor
@cindex spmilnor
@c ---content spmilnor---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spmilnor(sp); list sp

@item @strong{Return:}
int mu; Milnor number of spectrum sp

@end table
@strong{Example:}
@smallexample
@c computed example spmilnor d2t_singular/gaussman_lib.doc:846 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
spmilnor(sp);
@expansion{} 11
@c end example spmilnor d2t_singular/gaussman_lib.doc:846
@end smallexample
@c ---end content spmilnor---

@c ------------------- spgeomgenus -------------
@node spgeomgenus, spgamma, spmilnor, gaussman_lib
@subsubsection spgeomgenus
@cindex spgeomgenus
@c ---content spgeomgenus---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spgeomgenus(sp); list sp

@item @strong{Return:}
int g; geometrical genus of spectrum sp

@end table
@strong{Example:}
@smallexample
@c computed example spgeomgenus d2t_singular/gaussman_lib.doc:873 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
spgeomgenus(sp);
@expansion{} 6
@c end example spgeomgenus d2t_singular/gaussman_lib.doc:873
@end smallexample
@c ---end content spgeomgenus---

@c ------------------- spgamma -------------
@node spgamma,, spgeomgenus, gaussman_lib
@subsubsection spgamma
@cindex spgamma
@c ---content spgamma---
Procedure from library @code{gaussman.lib} (@pxref{gaussman_lib}).

@table @asis
@item @strong{Usage:}
spgamma(sp); list sp

@item @strong{Return:}
number gamma; gamma invariant of spectrum sp

@end table
@strong{Example:}
@smallexample
@c computed example spgamma d2t_singular/gaussman_lib.doc:900 
LIB "gaussman.lib";
ring R=0,(x,y),ds;
list sp=list(ideal(-1/2,-3/10,-1/10,0,1/10,3/10,1/2),intvec(1,2,2,1,2,2,1));
spprint(sp);
@expansion{} (-1/2,1),(-3/10,2),(-1/10,2),(0,1),(1/10,2),(3/10,2),(1/2,1)
spgamma(sp);
@expansion{} 1/240
@c end example spgamma d2t_singular/gaussman_lib.doc:900
@end smallexample
@c ---end content spgamma---
@c ---------------------------------------------------------
@node hnoether_lib, mondromy_lib, gaussman_lib, Singularities
@subsection hnoether_lib
@c include of docu for hnoether.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/hnoether_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/hnoether_lib.doc INSTEAD
@c library version: (1.29.2.14,2002/10/21)
@c library file: ../Singular/LIB/hnoether.lib
@cindex hnoether.lib
@cindex hnoether_lib
@table @asis
@item @strong{Library:}
hnoether.lib
@item @strong{Purpose:}
   Hamburger-Noether (Puiseux) Development
@item @strong{Author:}
Martin Lamm, lamm@@mathematik.uni-kl.de

@item @strong{Overview:}
A library for computing the Hamburger-Noether, resp. Puiseux, development
of a plane curve singularity following [Campillo, A.: Algebroid curves
in positive characteristic, Springer LNM 813 (1980)]. @*
The library contains also procedures for computing the (topological)
numerical invariants of plane curve singularities.

@end table

@strong{Main procedures:}
@menu
* hnexpansion:: Hamburger-Noether (H-N) development of f
* sethnering:: changes to the hnering created by hnexpansion
* develop:: H-N development of irreducible curves
* extdevelop:: extension of the H-N development hne of f
* parametrisation:: a parametrization of f
* displayHNE:: display H-N development as an ideal
* invariants:: invariants of f, e.g. the characteristic exponents
* displayInvariants:: display invariants of f
* multsequence:: sequence of multiplicities
* displayMultsequence:: display sequence of multiplicities
* intersection:: intersection multiplicity of two curves
* stripHNE:: reduce amount of memory consumed by hne
* is_irred:: test if f is irreducible
* delta:: delta invariant of f
* newtonpoly:: (local) Newton polygon of f
* is_NND:: test if f is Newton non-degenerate
@end menu
@strong{Auxiliary procedures:}
@menu
* puiseux2generators:: convert Puiseux pairs to generators of semigroup
* separateHNE:: number of quadratic transf. needed for separation
* squarefree:: a squarefree divisor of the poly f
* allsquarefree:: the maximal squarefree divisor of the poly f
* further_hn_proc:: show further procedures useful for interactive use
@end menu
@cindex Hamburger-Noether expansion
@cindex Puiseux expansion
@cindex curve singularities
@c ---end content LibInfo---

@c ------------------- hnexpansion -------------
@node hnexpansion, sethnering,, hnoether_lib
@subsubsection hnexpansion
@cindex hnexpansion
@c ---content hnexpansion---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
hnexpansion(f); or hnexpansion(f,"ess"); f poly

@item @strong{Usage:}
hnexpansion(f); f poly

@item @strong{Assume:}
f is a bivariate polynomial (in the first 2 ring variables)

@item @strong{Create:}
ring with variables @code{x,y} and ordering @code{ls} over a
field extension of the current basering's ground field, 
since the Hamburger-Noether development usually does not exist
in the originally given basering. The field extension is chosen
minimally.@*
Moreover, in the ring a list @code{hne} of lists @code{hne[i]} is
created (corresponding to the output of @code{develop(f[i])},
f[i] a branch of f, but the last entry being omitted).

@table @asis
@item @code{hne[i][1]}; matrix:
         Each row contains the coefficients of the corresponding line of the
         Hamburger-Noether expansion (HNE) for f[i]. The end of the line is
         marked in the matrix by the first ring variable (usually x).
@item @code{hne[i][2]}; intvec:
         indicating the length of lines of the HNE
@item @code{hne[i][3]}; int:
         0  if the 1st ring variable was transversal (with respect to f[i]), @*
         1  if the variables were changed at the beginning of the
            computation, @*
        -1  if an error has occurred.
@item @code{hne[i][4]}; poly:
         the transformed polynomial of f[i] to make it possible to extend the
         Hamburger-Noether development a posteriori without having to do
         all the previous calculation once again (0 if not needed)
@end table

@item @strong{Return:}
a list, say @code{hn}, containing the created ring

@item @strong{Note:}
to use the ring type: @code{def HNEring=hn[i]; setring HNEring;}.
@*
If f is known to be irreducible as a power series, @code{develop(f)}
could be chosen instead to avoid the change of basering. @*
Increasing @code{printlevel} leads to more and more comments.

@item @strong{Usage:}
hnexpansion(f,"ess"); f poly

@item @strong{Assume:}
f is a bivariate polynomial (in the first 2 ring variables)

@item @strong{Create:}
ring with variables @code{x,y} and ordering @code{ls} over a
field extension of the current basering's ground field, 
since the Hamburger-Noether development usually does not exist
in the originally given basering. The field extension is chosen
minimally.
@*
Moreover, in the ring a list @code{hne} of lists @code{hne[i]} is
created (corresponding to the output of @code{develop(f[i])}, f[i] an
"essential" branch of f, but the last entry being omitted). See
@code{hnexpansion} above for more details.

@item @strong{Return:}
a list, say @code{hn}, containing the created ring

@item @strong{Note:}
to use the ring type: @code{def hnering=hn[i]; setring hnering;}.
@*
Alternatively you may use the procedure sethnering and type:
@code{sethnering(hn);}
@*
If the HNE needs a field extension, some of the branches will be
conjugate. In this case @code{hnexpansion(f,"ess")} reduces the
computation to one representative for each group of conjugate
branches.@*
Note that the degree of each branch is in general less than the degree
of the field extension in which all HNEs can be put.@*
Use @code{hnexpansion(f)} to compute a complete HNE, i.e., a HNE for
all branches.@*
Increasing @code{printlevel} leads to more and more comments.

@end table
@strong{Example:}
@smallexample
@c computed example hnexpansion d2t_singular/hnoether_lib.doc:150 
LIB "hnoether.lib";
ring r=0,(x,y),ls;
list hn=hnexpansion(x4-y6);
show(hn);
@expansion{} // list, 1 element(s):
@expansion{} [1]:
@expansion{}    // ring: (0),(x,y),(ls(2),C);
@expansion{}    // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // hne                  [0]  list, size: 2
def hnering=hn[1];
setring hnering;
size(hne);           // number of branches
@expansion{} 2
print(hne[1][1]);    // HN-matrix of 1st branch
@expansion{} 0,x,0,
@expansion{} 0,1,x 
parametrisation(hne);    // parametrization of the two branches
@expansion{} [1]:
@expansion{}    _[1]=x3
@expansion{}    _[2]=x2
@expansion{} [2]:
@expansion{}    _[1]=-x3
@expansion{}    _[2]=-x2
/////////////////////////////////////////////////////////
ring s=2,(x,y),ls;
poly f=(x4+x2y+y2)*(x3+xy2+y3);
// --------- compute all branches: ---------
hn=hnexpansion(f);
@expansion{} // new minimal polynomial: a6+a5+a3+a2+1
hnering=hn[1];
setring hnering;
displayHNE(hne[1]);   // HN-matrix of 1st branch
@expansion{} HNE[1]=y+(a^4+a+1)*z(0)
@expansion{} HNE[2]=x+z(0)
displayHNE(hne[4]);   // HN-matrix of 4th branch
@expansion{} HNE[1]=y+(a^4+a^2+a+1)*z(0)^2
@expansion{} HNE[2]=x+z(0)
setring s;
// --- compute only one of conjugate branches: ---
hn=hnexpansion(f,"ess");
@expansion{} // new minimal polynomial: a6+a5+a3+a2+1
hnering=hn[1];
setring hnering;
displayHNE(hne);
@expansion{} // Hamburger-Noether development of branch nr.1:
@expansion{} HNE[1]=y+(a^4+a^2)*z(0)
@expansion{} HNE[2]=x+z(0)
@expansion{} 
@expansion{} // Hamburger-Noether development of branch nr.2:
@expansion{} HNE[1]=y+(a^4+a^2+a)*z(0)^2
@expansion{} HNE[2]=x+z(0)
@expansion{} 
// no. 1 of hnexpansion(f,"ess") represents no. 1 - 3 of hnexpansion(f) and
// no. 2 of hnexpansion(f,"ess") represents no. 4 + 5 of hnexpansion(f)
@c end example hnexpansion d2t_singular/hnoether_lib.doc:150
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:179
@menu
See also:
* develop::
* displayHNE::
* extdevelop::
* parametrisation::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:179

@c ---end content hnexpansion---

@c ------------------- sethnering -------------
@node sethnering, develop, hnexpansion, hnoether_lib
@subsubsection sethnering
@cindex sethnering
@c ---content sethnering---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
sethnering(L[,s]); L list, s string (optional)

@item @strong{Assume:}
L is a list containing a ring (e.g. the output of @code{hnexpansion}).

@item @strong{Create:}
The procedure creates a ring with name given by the optional parameter
s resp. with name hnering, if no optional parameter is given, and
changes your ring to this ring. The new ring will be the ring given
as the first entry in the list L.

@item @strong{Return:}
nothing.

@end table
@strong{Example:}
@smallexample
@c computed example sethnering d2t_singular/hnoether_lib.doc:211 
LIB "hnoether.lib";
// -------- prepare for example ---------
if (defined(hnering))
@{
def rette@@ring=hnering;
if (nameof(basering)=="hnering")
@{
int wechsel=1;
@}
else
@{
int wechsel;
@}
kill hnering;
@}
// ------ the example starts here -------
ring r=0,(x,y),ls;
nameof(basering);
@expansion{} r
sethnering(hnexpansion(x4-y6)); // Creates hnering and changes to it!
nameof(basering);
@expansion{} hnering
// --- restore HNEring if previously defined ---
kill hnering;
if (defined(rette@@ring)) @{
def hnering=rette@@ring;
export hnering;
if (wechsel==1)
@{
setring hnering;
@}
@}
@c end example sethnering d2t_singular/hnoether_lib.doc:211
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:244
@menu
See also:
* hnexpansion::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:244

@c ---end content sethnering---

@c ------------------- develop -------------
@node develop, extdevelop, sethnering, hnoether_lib
@subsubsection develop
@cindex develop
@c ---content develop---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
develop(f [,n]); f poly, n int

@item @strong{Assume:}
f is a bivariate polynomial (in the first 2 ring variables) and
irreducible as power series (for reducible f use @code{hnexpansion}).

@item @strong{Return:}
list @code{L} with:

@table @asis
@item @code{L[1]}; matrix:
         Each row contains the coefficients of the corresponding line of the
         Hamburger-Noether expansion (HNE). The end of the line is marked in
         the matrix by the first ring variable (usually x).
@item @code{L[2]}; intvec:
         indicating the length of lines of the HNE
@item @code{L[3]}; int:
         0  if the 1st ring variable was transversal (with respect to f), @*
         1  if the variables were changed at the beginning of the
            computation, @*
        -1  if an error has occurred.
@item @code{L[4]}; poly:
         the transformed polynomial of f to make it possible to extend the
         Hamburger-Noether development a posteriori without having to do
         all the previous calculation once again (0 if not needed)
@item @code{L[5]}; int:
         1  if the curve has exactly one branch (i.e., is irreducible), @*
         0  else (i.e., the curve has more than one HNE, or f is not valid).
@end table

@item @strong{Display:}
The (non zero) elements of the HNE (if not called by another proc).

@item @strong{Note:}
The optional parameter @code{n} affects only the computation of
the LAST line of the HNE. If it is given, the HN-matrix @code{L[1]}
will have at least @code{n} columns. @*
Otherwise, the number of columns will be chosen minimal such that the
matrix contains all necessary information (i.e., all lines of the HNE
but the last (which is in general infinite) have place). @*
If @code{n} is negative, the algorithm is stopped as soon as the
computed information is sufficient for @code{invariants(L)}, but the
HN-matrix @code{L[1]} may still contain undetermined elements, which
are marked with the 2nd variable (of the basering). @*
For time critical computations it is recommended to use
@code{ring ...,(x,y),ls} as basering - it increases the algorithm's
speed. @*
If @code{printlevel>=0} comments are displayed (default is
@code{printlevel=0}).

@end table
@strong{Example:}
@smallexample
@c computed example develop d2t_singular/hnoether_lib.doc:312 
LIB "hnoether.lib";
ring exring = 7,(x,y),ds;
list hne=develop(4x98+2x49y7+x11y14+2y14);
print(hne[1]);
@expansion{} 0,0, 0,0,0,0,3,x,
@expansion{} 0,x, 0,0,0,0,0,0,
@expansion{} 0,0, 0,x,0,0,0,0,
@expansion{} 0,x, 0,0,0,0,0,0,
@expansion{} 0,-1,0,0,0,0,0,0 
// therefore the HNE is:
// z(-1)= 3*z(0)^7 + z(0)^7*z(1),
// z(0) = z(1)*z(2),       (there is 1 zero in the 2nd row before x)
// z(1) = z(2)^3*z(3),     (there are 3 zeroes in the 3rd row)
// z(2) = z(3)*z(4),
// z(3) = -z(4)^2 + 0*z(4)^3 +...+ 0*z(4)^8 + ?*z(4)^9 + ...
// (the missing x in the last line indicates that it is not complete.)
hne[2];
@expansion{} 7,1,3,1,-1
parametrisation(hne);
@expansion{} [1]:
@expansion{}    _[1]=-x14
@expansion{}    _[2]=-3x98-x109
// parametrization:   x(t)= -t^14+O(t^21),  y(t)= -3t^98+O(t^105)
// (the term -t^109 in y may have a wrong coefficient)
displayHNE(hne);
@expansion{} HNE[1]=-y+3*z(0)^7+z(0)^7*z(1)
@expansion{} HNE[2]=-x+z(1)*z(2)
@expansion{} HNE[3]=z(2)^3*z(3)
@expansion{} HNE[4]=z(3)*z(4)
@expansion{} HNE[5]=-z(4)^2
@c end example develop d2t_singular/hnoether_lib.doc:312
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:331
@menu
See also:
* displayHNE::
* extdevelop::
* hnexpansion::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:331

@c ---end content develop---

@c ------------------- extdevelop -------------
@node extdevelop, parametrisation, develop, hnoether_lib
@subsubsection extdevelop
@cindex extdevelop
@c ---content extdevelop---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
extdevelop(L,N); list L, int N

@item @strong{Assume:}
L is the output of @code{develop(f)}, or of @code{extdevelop(l,n)},
or one entry in the list @code{hne} in the ring created by
@code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
an extension of the Hamburger-Noether development of f as a list
in the same format as L has (up to the last entry in the output
of @code{develop(f)}).@*
Type @code{help develop;}, resp. @code{help hnexpansion;} for more
details.

@item @strong{Note:}
The new HN-matrix will have at least N columns (if the HNE is not
finite). In particular, if f is irreducible then (in most cases)
@code{extdevelop(develop(f),N)} will produce the same result as
@code{develop(f,N)}.@*
If the matrix M of L has n columns then, compared with
@code{parametrisation(L)}, @code{paramametrize(extdevelop(L,N))} will increase the
exactness by at least (N-n) more significant monomials.

@end table
@strong{Example:}
@smallexample
@c computed example extdevelop d2t_singular/hnoether_lib.doc:372 
LIB "hnoether.lib";
if (defined(HNEring))
@{
def save_r_i_n_g=HNEring;
kill HNEring;
@}
// ------ the example starts here -------
ring exring=0,(x,y),dp;
list hn=hnexpansion(x14-3y2x11-y3x10-y2x9+3y4x8+y5x7+3y4x6+x5*(-y6+y5)
-3y6x3-y7x2+y8);
def HNEring=hn[1];
setring HNEring;  
export(HNEring);  
@expansion{} // ** `HNEring` is already global
print(hne[1][1]);    // HNE of 1st branch is finite
@expansion{} 0,x,0,
@expansion{} 0,1,x 
print(extdevelop(hne[1],5)[1]);
@expansion{}  No extension is possible
@expansion{} 0,x,0,
@expansion{} 0,1,x 
print(hne[2][1]);    // HNE of 2nd branch can be extended
@expansion{} 0,x,0,
@expansion{} 0,1,x,
@expansion{} 0,1,-1
list ehne=extdevelop(hne[2],5);
print(ehne[1]);      // new HN-matrix has 5 columns
@expansion{} 0,x,0, 0,0,
@expansion{} 0,1,x, 0,0,
@expansion{} 0,1,-1,1,-1
parametrisation(hne[2]);
@expansion{} [1]:
@expansion{}    _[1]=x4-x5-x6+x7
@expansion{}    _[2]=x6-2x7+2x9-x10
parametrisation(ehne);
@expansion{} [1]:
@expansion{}    _[1]=x4-x5+x6-x7-x8+x9-x10+x11
@expansion{}    _[2]=x6-2x7+3x8-4x9+2x10-2x12+4x13-3x14+2x15-x16
if (defined(save_r_i_n_g))
@{
kill HNEring;
def HNEring=save_r_i_n_g;
@}
@c end example extdevelop d2t_singular/hnoether_lib.doc:372
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:400
@menu
See also:
* develop::
* hnexpansion::
* parametrisation::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:400

@c ---end content extdevelop---

@c ------------------- parametrisation -------------
@node parametrisation, displayHNE, extdevelop, hnoether_lib
@subsubsection parametrisation
@cindex parametrisation
@c ---content parametrisation---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
parametrisation(INPUT [,x]); INPUT list or poly, x int (optional)

@item @strong{Assume:}
INPUT is either a bivariate polynomial f defining a plane curve
singularity, or it is the output of @code{hnexpansion(f[,"ess"])},
or of @code{develop(f)}, or of @code{extdevelop(develop(f),n)},
or the list @@@{hne@} in the ring created by @code{hnexpansion(f)}
respectively one entry thereof.

@item @strong{Return:}
a list L containing a parametrization L[i] for each branch f[i] of f
in the following format: @*
- if only the list INPUT is given, L[i] is an ideal of two polynomials
p[1],p[2]: if the HNE of was finite then f[i](p[1],p[2])=0; if not,
the "real" parametrization will be two power series and p[1],p[2] are
truncations of these series.@*
- if the optional parameter x is given, L[i] is itself a list:
L[i][1] is the parametrization ideal as above and L[i][2] is an intvec
with two entries indicating the highest degree up to which the
coefficients of the monomials in L[i][1] are exact (entry -1 means that
the corresponding parametrization is exact).

@item @strong{Note:}
If the basering has only 2 variables, the first variable is chosen
as indefinite. Otherwise, the 3rd variable is chosen. @*
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@cindex parametrization
@end table
@strong{Example:}
@smallexample
@c computed example parametrisation d2t_singular/hnoether_lib.doc:449 
LIB "hnoether.lib";
ring exring=0,(x,y,t),ds;
// 1st Example: input is a polynomial
poly g=(x2-y3)*(x3-y5);
parametrisation(g);
@expansion{} [1]:
@expansion{}    _[1]=t3
@expansion{}    _[2]=t2
@expansion{} [2]:
@expansion{}    _[1]=t5
@expansion{}    _[2]=t3
// 2nd Example: input is the ring of a Hamburger-Noether expansion
poly h=x2-y2-y3;
list hn=hnexpansion(h);
parametrisation(h,1);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=t
@expansion{}       _[2]=t-1/2t2
@expansion{}    [2]:
@expansion{}       -1,2
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=t
@expansion{}       _[2]=-t-1/2t2
@expansion{}    [2]:
@expansion{}       -1,2
// 3rd Example: input is a Hamburger-Noether expansion
poly f=x3+2xy2+y2;
list hne=develop(f);
list hne_extended=extdevelop(hne,10);
//   compare the matrices ...
print(hne[1]);
@expansion{} 0,x,
@expansion{} 0,-1
print(hne_extended[1]);
@expansion{} 0,x, 0,0,0,0, 0,0,0,0, 
@expansion{} 0,-1,0,2,0,-4,0,8,0,-16
// ... and the resulting parametrizations:
parametrisation(hne);
@expansion{} [1]:
@expansion{}    _[1]=-t2
@expansion{}    _[2]=-t3
parametrisation(hne_extended);
@expansion{} [1]:
@expansion{}    _[1]=-t2+2t4-4t6+8t8-16t10
@expansion{}    _[2]=-t3+2t5-4t7+8t9-16t11
parametrisation(hne_extended,0);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=-t2+2t4-4t6+8t8-16t10
@expansion{}       _[2]=-t3+2t5-4t7+8t9-16t11
@expansion{}    [2]:
@expansion{}       10,11
@c end example parametrisation d2t_singular/hnoether_lib.doc:449
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:472
@menu
See also:
* develop::
* extdevelop::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:472

@c ---end content parametrisation---

@c ------------------- displayHNE -------------
@node displayHNE, invariants, parametrisation, hnoether_lib
@subsubsection displayHNE
@cindex displayHNE
@c ---content displayHNE---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
displayHNE(L[,n]); L list, n int

@item @strong{Assume:}
L is the output of @code{develop(f)}, or of @code{exdevelop(f,n)},
or of @code{hnexpansion(f[,"ess"])}, or (one entry in) the list
@code{hne} in the ring created by @code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
- if only one argument is given, no return value, but
display an ideal HNE of the following form:
@smallexample
     HNE[1]=-y+[]*z(0)^1+[]*z(0)^2+...+z(0)^<>*z(1)
     HNE[2]=-x+          []*z(1)^2+...+z(1)^<>*z(2)
     HNE[3]=             []*z(2)^2+...+z(2)^<>*z(3)
     .......             ..........................
     HNE[r+1]=           []*z(r)^2+[]*z(r)^3+......
@end smallexample
where @code{x},@code{y} are the first 2 variables of the basering.
The values of @code{[]} are the coefficients of the Hamburger-Noether
matrix, the values of @code{<>} are represented by @code{x} in the
HN-matrix.@*
- if a second argument is given, create and export a new ring with
name @code{displayring} containing an ideal @code{HNE} as described
above.@*
- if L corresponds to the output of @code{hnexpansion(f[,"ess"])}
or to the list @code{hne} in the ring created by @code{hnexpansion(f[,"ess"])},
@code{displayHNE(L[,n])} shows the HNE's of all branches of f in the form
described above. The optional parameter is then ignored.

@item @strong{Note:}
The 1st line of the above ideal (i.e., @code{HNE[1]}) means that
@code{y=[]*z(0)^1+...}, the 2nd line (@code{HNE[2]}) means that
@code{x=[]*z(1)^2+...}, so you can see which indeterminate
corresponds to which line (it's also possible that @code{x} corresponds
to the 1st line and @code{y} to the 2nd).

@end table
@strong{Example:}
@smallexample
@c computed example displayHNE d2t_singular/hnoether_lib.doc:526 
LIB "hnoether.lib";
ring r=0,(x,y),dp;
poly f=x3+2xy2+y2;
list hn=develop(f);
displayHNE(hn);
@expansion{} HNE[1]=-y+z(0)*z(1)
@expansion{} HNE[2]=-x-z(1)^2
@c end example displayHNE d2t_singular/hnoether_lib.doc:526
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:534
@menu
See also:
* develop::
* hnexpansion::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:534

@c ---end content displayHNE---

@c ------------------- invariants -------------
@node invariants, displayInvariants, displayHNE, hnoether_lib
@subsubsection invariants
@cindex invariants
@c ---content invariants---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
invariants(INPUT); INPUT list or poly

@item @strong{Assume:}
INPUT is the output of @code{develop(f)}, or of
@code{extdevelop(develop(f),n)}, or one entry in the list @code{hne}
of the HNEring created by @code{hnexpansion}.

@item @strong{Return:}
list, if INPUT contains a valid HNE:
@format
    invariants(INPUT)[1]:  intvec    (characteristic exponents)
    invariants(INPUT)[2]:  intvec    (generators of the semigroup)
    invariants(INPUT)[3]:  intvec    (Puiseux pairs, 1st components)
    invariants(INPUT)[4]:  intvec    (Puiseux pairs, 2nd components)
    invariants(INPUT)[5]:  int       (degree of the conductor)
    invariants(INPUT)[6]:  intvec    (sequence of multiplicities)
@end format
an empty list, if INPUT contains no valid HNE.

@item @strong{Assume:}
INPUT is bivariate polynomial f or the output of @code{hnexpansion(f[,"ess"])},
or the list @code{hne} in the HNEring created by @code{hnexpansion}.

@item @strong{Return:}
list INV, such that INV[i] is the output of @code{invariants(develop(f[i]))}
as above, where f[i] is the ith branch of the curve f, and the last
entry contains further invariants of f in the format:
@format
    INV[i][1]    : intvec    (characteristic exponents)
    INV[i][2]    : intvec    (generators of the semigroup)
    INV[i][3]    : intvec    (Puiseux pairs, 1st components)
    INV[i][4]    : intvec    (Puiseux pairs, 2nd components)
    INV[i][5]    : int       (degree of the conductor)
    INV[i][6]    : intvec    (sequence of multiplicities)
    INV[last][1] : intmat    (contact matrix of the branches)
    INV[last][2] : intmat    (intersection multiplicities of the branches)
    INV[last][3] : int       (delta invariant of f)
@end format

@item @strong{Note:}
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@cindex characteristic exponents
@cindex semigroup of values
@cindex Puiseux pairs
@cindex conductor, degree
@cindex multiplicities, sequence of
@end table
@strong{Example:}
@smallexample
@c computed example invariants d2t_singular/hnoether_lib.doc:602 
LIB "hnoether.lib";
ring exring=0,(x,y),dp;
list hne=develop(y4+2x3y2+x6+x5y);
list INV=invariants(hne);
INV[1];                   // the characteristic exponents
@expansion{} 4,6,7
INV[2];                   // the generators of the semigroup of values
@expansion{} 4,6,13
INV[3],INV[4];            // the Puiseux pairs in packed form
@expansion{} 3,7 2,2
INV[5] / 2;               // the delta-invariant
@expansion{} 8
INV[6];                   // the sequence of multiplicities
@expansion{} 4,2,2,1,1
// To display the invariants more 'nicely':
displayInvariants(hne);
@expansion{}  characteristic exponents  : 4,6,7
@expansion{}  generators of semigroup   : 4,6,13
@expansion{}  Puiseux pairs             : (3,2)(7,2)
@expansion{}  degree of the conductor   : 16
@expansion{}  delta invariant           : 8
@expansion{}  sequence of multiplicities: 4,2,2,1,1
/////////////////////////////
INV=invariants((x2-y3)*(x3-y5));
INV[1][1];                // the characteristic exponents of the first branch
@expansion{} 2,3
INV[2][6];                // the sequence of multiplicities of the second branch
@expansion{} 3,2,1,1
print(INV[size(INV)][1]);         // the contact matrix of the branches
@expansion{}      0     3
@expansion{}      3     0
print(INV[size(INV)][2]);         // the intersection numbers of the branches
@expansion{}      0     9
@expansion{}      9     0
INV[size(INV)][3];                // the delta invariant of the curve
@expansion{} 14
@c end example invariants d2t_singular/hnoether_lib.doc:602
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:623
@menu
See also:
* develop::
* displayInvariants::
* intersection::
* multsequence::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:623

@c ---end content invariants---

@c ------------------- displayInvariants -------------
@node displayInvariants, multsequence, invariants, hnoether_lib
@subsubsection displayInvariants
@cindex displayInvariants
@c ---content displayInvariants---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
displayInvariants(INPUT); INPUT list or poly

@item @strong{Assume:}
INPUT is a bivariate polynomial, or the output of @code{develop(f)}, or of
@code{extdevelop(develop(f),n)}, or (one entry of) the list @code{hne}
in the ring created by @code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
none

@item @strong{Display:}
invariants of the corresponding branch, resp. of all branches,
in a better readable form.

@item @strong{Note:}
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@end table
@strong{Example:}
@smallexample
@c computed example displayInvariants d2t_singular/hnoether_lib.doc:661 
LIB "hnoether.lib";
ring exring=0,(x,y),dp;
list hne=develop(y4+2x3y2+x6+x5y);
displayInvariants(hne);
@expansion{}  characteristic exponents  : 4,6,7
@expansion{}  generators of semigroup   : 4,6,13
@expansion{}  Puiseux pairs             : (3,2)(7,2)
@expansion{}  degree of the conductor   : 16
@expansion{}  delta invariant           : 8
@expansion{}  sequence of multiplicities: 4,2,2,1,1
@c end example displayInvariants d2t_singular/hnoether_lib.doc:661
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:668
@menu
See also:
* develop::
* hnexpansion::
* intersection::
* invariants::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:668

@c ---end content displayInvariants---

@c ------------------- multsequence -------------
@node multsequence, displayMultsequence, displayInvariants, hnoether_lib
@subsubsection multsequence
@cindex multsequence
@c ---content multsequence---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
multsequence(INPUT); INPUT list or poly

@item @strong{Assume:}
INPUT is the output of @code{develop(f)}, or of @code{extdevelop(develop(f),n)},
or one entry in the list @code{hne} of the ring created by @code{hnexpansion(f)}.

@item @strong{Return:}
intvec corresponding to the multiplicity sequence of (a branch)
of the curve (the same as @code{invariants(INPUT)[6]}).

@item @strong{Assume:}
INPUT is a bivariate polynomial, or the output of @code{hnexpansion(f)},
or the list @code{hne} in the ring created by @code{hnexpansion(f)}.

@item @strong{Return:}
list of two integer matrices:

@table @asis
@item  @code{multsequence(INPUT)[1][i,*]}
   contains the multiplicities of the branches at their infinitely near point
   of 0 in its (i-1) order neighbourhood (i.e., i=1: multiplicity of the
   branches themselves, i=2: multiplicity of their 1st quadratic transformed,
   etc., @*
   Hence, @code{multsequence(INPUT)[1][*,j]} is the multiplicity sequence
   of branch j.
@item  @code{multsequence(INPUT)[2][i,*]}:
   contains the information which of these infinitely near points coincide.
@end table

@item @strong{Note:}
The order of elements of the list @code{hne} obtained from @code{hnexpansion(f[,"ess")}
must not be changed (because then the coincident infinitely near points
couldn't be grouped together, cf. meaning of 2nd intmat in example).
Hence, it is not wise to compute the HNE of several polynomials
separately, put them into a list INPUT and call @code{multsequence(INPUT)}. @*
Use @code{displayMultsequence} to produce a better readable output for
reducible curves on the screen. @*
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@cindex multiplicity sequence
@end table
@strong{Example:}
@smallexample
@c computed example multsequence d2t_singular/hnoether_lib.doc:729 
LIB "hnoether.lib";
// -------- prepare for example ---------
if (nameof(basering)=="HNEring") @{
def rettering=HNEring;
kill HNEring;
@}
// ------ the example starts here -------
ring r=0,(x,y),dp;
list hn=hnexpansion((x6-y10)*(x+y2-y3)*(x+y2+y3));   // 4 branches
def HNEring=hn[1];
setring HNEring;
multsequence(hne[1]),"  |  ",multsequence(hne[2]),"  |  ",
multsequence(hne[3]),"  |  ",multsequence(hne[4]);
@expansion{} 3,2,1,1   |   3,2,1,1   |   1   |   1
multsequence(hne);
@expansion{} [1]:
@expansion{}    3,3,1,1,
@expansion{}    2,2,1,1,
@expansion{}    1,1,1,1,
@expansion{}    1,1,1,1,
@expansion{}    1,1,1,1 
@expansion{} [2]:
@expansion{}    4,0,0,0,
@expansion{}    4,0,0,0,
@expansion{}    2,2,0,0,
@expansion{}    2,1,1,0,
@expansion{}    1,1,1,1 
// The meaning of the entries of the 2nd matrix is as follows:
displayMultsequence(hne);
@expansion{} [(3,3,1,1)],
@expansion{} [(2,2,1,1)],
@expansion{} [(1,1),(1,1)],
@expansion{} [(1,1),(1),(1)],
@expansion{} [(1),(1),(1),(1)]
// --- restore HNEring if previously defined ---
kill HNEring,r;
if (defined(rettering)) @{
setring rettering;
def HNEring=rettering;
export HNEring;
@}
@c end example multsequence d2t_singular/hnoether_lib.doc:729
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:755
@menu
See also:
* develop::
* displayMultsequence::
* hnexpansion::
* separateHNE::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:755

@c ---end content multsequence---

@c ------------------- displayMultsequence -------------
@node displayMultsequence, intersection, multsequence, hnoether_lib
@subsubsection displayMultsequence
@cindex displayMultsequence
@c ---content displayMultsequence---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
displayMultsequence(INPUT); INPUT list or poly

@item @strong{Assume:}
INPUT is a bivariate polynomial, or the output of @code{develop(f)},
or of @code{extdevelop(develop(f),n)}, or of of @code{hnexpansion(f[,"ess"])},
or (one entry in) the list @code{hne} of the ring created by @code{hnexpansion(f[,"ess "])}.

@item @strong{Return:}
nothing

@item @strong{Display:}
the sequence of multiplicities:
@format
 - if @code{INPUT=develop(f)} or @code{INPUT=extdevelop(develop(f),n)} or @code{INPUT=hne[i]}:
                      @code{a , b , c , ....... , 1}
 - if @code{INPUT=f} or @code{INPUT=hnexpansion(f[,"ess"])} or @code{INPUT=hne}:
                      @code{[(a_1, .... , b_1 , .... , c_1)],}
                      @code{[(a_2, ... ), ... , (... , c_2)],}
                      @code{ ........................................ ,}
                      @code{[(a_n),(b_n), ....., (c_n)]}
     with:
       @code{a_1 , ... , a_n} the sequence of multiplicities of the 1st branch,
       @code{[...]} the multiplicities of the j-th transformed of all branches,
       @code{(...)} indicating branches meeting in an infinitely near point.
@end format

@item @strong{Note:}
The same restrictions for INPUT as in @code{multsequence} apply.@*
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@end table
@strong{Example:}
@smallexample
@c computed example displayMultsequence d2t_singular/hnoether_lib.doc:806 
LIB "hnoether.lib";
// ------ the example starts here -------
ring r=0,(x,y),dp;
//// Example 1: Input = output of develop
displayMultsequence(develop(x3-y5));
@expansion{} The sequence of multiplicities is   3,2,1,1
//// Example 2: Input = bivariate polynomial
displayMultsequence((x6-y10)*(x+y2-y3)*(x+y2+y3));
@expansion{} [(3,3,1,1)],
@expansion{} [(2,2,1,1)],
@expansion{} [(1,1),(1,1)],
@expansion{} [(1,1),(1),(1)],
@expansion{} [(1),(1),(1),(1)]
@c end example displayMultsequence d2t_singular/hnoether_lib.doc:806
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:816
@menu
See also:
* develop::
* hnexpansion::
* multsequence::
* separateHNE::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:816

@c ---end content displayMultsequence---

@c ------------------- intersection -------------
@node intersection, stripHNE, displayMultsequence, hnoether_lib
@subsubsection intersection
@cindex intersection
@c ---content intersection---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
intersection(hne1,hne2); hne1, hne2 lists

@item @strong{Assume:}
hne1, hne2 represent a HNE (i.e., are the output of
@code{develop(f)}, or of @code{extdevelop(develop(f),n)}, or
one entry of the list @code{hne} in the ring created by
@code{hnexpansion(f[,"ess"])}).

@item @strong{Return:}
int, the intersection multiplicity of the branches corresponding to
hne1 and hne2.

@cindex intersection multiplicity
@end table
@strong{Example:}
@smallexample
@c computed example intersection d2t_singular/hnoether_lib.doc:847 
LIB "hnoether.lib";
// ------ the example starts here -------
ring r=0,(x,y),dp;
list hn=hnexpansion((x2-y3)*(x2+y3));
def HNEring=hn[1];
setring HNEring;
intersection(hne[1],hne[2]);
@expansion{} 6
@c end example intersection d2t_singular/hnoether_lib.doc:847
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:857
@menu
See also:
* displayInvariants::
* hnexpansion::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:857

@c ---end content intersection---

@c ------------------- stripHNE -------------
@node stripHNE, is_irred, intersection, hnoether_lib
@subsubsection stripHNE
@cindex stripHNE
@c ---content stripHNE---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
stripHNE(L); L list

@item @strong{Assume:}
L is the output of @code{develop(f)}, or of
@code{extdevelop(develop(f),n)}, or (one entry of) the list
@code{hne} in the ring created by @code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
list in the same format as L, but all polynomials L[4], resp.
L[i][4], are set to zero.

@item @strong{Note:}
The purpose of this procedure is to remove huge amounts of data
no longer needed. It is useful, if one or more of the polynomials
in L consume much memory. It is still possible to compute invariants,
parametrizations etc. with the stripped HNE(s), but it is not possible
to use @code{extdevelop} with them.

@end table
@strong{Example:}
@smallexample
@c computed example stripHNE d2t_singular/hnoether_lib.doc:893 
LIB "hnoether.lib";
ring r=0,(x,y),dp;
list hne=develop(x2+y3+y4);
hne;
@expansion{} [1]:
@expansion{}    _[1,1]=0
@expansion{}    _[1,2]=x
@expansion{}    _[2,1]=0
@expansion{}    _[2,2]=-1
@expansion{} [2]:
@expansion{}    1,-1
@expansion{} [3]:
@expansion{}    1
@expansion{} [4]:
@expansion{}    x4-2x2y+y2+y
@expansion{} [5]:
@expansion{}    1
stripHNE(hne);
@expansion{} [1]:
@expansion{}    _[1,1]=0
@expansion{}    _[1,2]=x
@expansion{}    _[2,1]=0
@expansion{}    _[2,2]=-1
@expansion{} [2]:
@expansion{}    1,-1
@expansion{} [3]:
@expansion{}    1
@expansion{} [4]:
@expansion{}    0
@expansion{} [5]:
@expansion{}    1
@c end example stripHNE d2t_singular/hnoether_lib.doc:893
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:901
@menu
See also:
* develop::
* extdevelop::
* hnexpansion::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:901

@c ---end content stripHNE---

@c ------------------- is_irred -------------
@node is_irred, delta, stripHNE, hnoether_lib
@subsubsection is_irred
@cindex is_irred
@c ---content is_irred---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
is_irred(f); f poly

@item @strong{Assume:}
f is a squarefree bivariate polynomial (in the first 2 ring
variables).

@item @strong{Return:}
int (0 or 1): @*
- @code{is_irred(f)=1} if f is irreducible as a formal power
series over the algebraic closure of its coefficient field (f
defines an analytically irreducible curve at zero), @*
- @code{is_irred(f)=0} otherwise.

@item @strong{Note:}
0 and units in the ring of formal power series are considered to be
not irreducible.

@cindex irreducible power series
@end table
@strong{Example:}
@smallexample
@c computed example is_irred d2t_singular/hnoether_lib.doc:937 
LIB "hnoether.lib";
ring exring=0,(x,y),ls;
is_irred(x2+y3);
@expansion{} 1
is_irred(x2+y2);
@expansion{} 0
is_irred(x2+y3+1);
@expansion{} 0
@c end example is_irred d2t_singular/hnoether_lib.doc:937
@end smallexample
@c ---end content is_irred---

@c ------------------- delta -------------
@node delta, newtonpoly, is_irred, hnoether_lib
@subsubsection delta
@cindex delta
@c ---content delta---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
delta(INPUT); INPUT a polynomial defining an isolated plane curve
singularity at 0, or the Hamburger-Noether expansion thereof, i.e.
the output of @code{develop(f)}, or the output of @code{hnexpansion(f[,"ess"])},
or (one of the entries of) the list @code{hne} in the ring created
by @code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
the delta invariant of the singularity at 0, the vector space
dimension of R~/R, where R~ is the normalization of the
singularity R=basering/f

@item @strong{Note:}
In case the Hamburger-Noether expansion of the curve f is needed
for other purposes as well it is better to calculate this first
with the aid of @code{hnexpansion} and use it as input instead of
the polynomial itself.

@cindex delta invariant
@end table
@strong{Example:}
@smallexample
@c computed example delta d2t_singular/hnoether_lib.doc:977 
LIB "hnoether.lib";
ring r = 32003,(x,y),ds;
poly f = x25+x24-4x23-1x22y+4x22+8x21y-2x21-12x20y-4x19y2+4x20+10x19y
+12x18y2-24x18y-20x17y2-4x16y3+x18+60x16y2+20x15y3-9x16y
-80x14y3-10x13y4+36x14y2+60x12y4+2x11y5-84x12y3-24x10y5
+126x10y4+4x8y6-126x8y5+84x6y6-36x4y7+9x2y8-1y9;
delta(f);
@expansion{} 96
@c end example delta d2t_singular/hnoether_lib.doc:977
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:987
@menu
See also:
* deltaLoc::
* invariants::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:987

@c ---end content delta---

@c ------------------- newtonpoly -------------
@node newtonpoly, is_NND, delta, hnoether_lib
@subsubsection newtonpoly
@cindex newtonpoly
@c ---content newtonpoly---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
newtonpoly(f); f poly

@item @strong{Assume:}
basering has exactly two variables; @*
f is convenient, that is, f(x,0) != 0 != f(0,y).

@item @strong{Return:}
list of intvecs (= coordinates x,y of the Newton polygon of f).

@item @strong{Note:}
Procedure uses @code{execute}; this can be avoided by calling
@code{newtonpoly(f,1)} if the ordering of the basering is @code{ls}.

@cindex Newton polygon
@end table
@strong{Example:}
@smallexample
@c computed example newtonpoly d2t_singular/hnoether_lib.doc:1019 
LIB "hnoether.lib";
ring r=0,(x,y),ls;
poly f=x5+2x3y-x2y2+3xy5+y6-y7;
newtonpoly(f);
@expansion{} [1]:
@expansion{}    0,6
@expansion{} [2]:
@expansion{}    2,2
@expansion{} [3]:
@expansion{}    3,1
@expansion{} [4]:
@expansion{}    5,0
@c end example newtonpoly d2t_singular/hnoether_lib.doc:1019
@end smallexample
@c ---end content newtonpoly---

@c ------------------- is_NND -------------
@node is_NND, puiseux2generators, newtonpoly, hnoether_lib
@subsubsection is_NND
@cindex is_NND
@c ---content is_NND---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
is_NND(f[,mu,NP]); f poly, mu int, NP list of intvecs

@item @strong{Assume:}
f is convenient, that is, f(x,0) != 0 != f(0,y);@*
mu (optional) is Milnor number of f.@*
NP (optional) is output of @code{newtonpoly(f)}.

@item @strong{Return:}
int: 1 if f in Newton non-degenerate, 0 otherwise.

@cindex Newton non-degenerate
@cindex Newton polygon
@end table
@strong{Example:}
@smallexample
@c computed example is_NND d2t_singular/hnoether_lib.doc:1052 
LIB "hnoether.lib";
ring r=0,(x,y),ls;
poly f=x5+y3;
is_NND(f);
@expansion{} 1
poly g=(x-y)^5+3xy5+y6-y7;
is_NND(g);
@expansion{} 0
// if already computed, one should give the Minor number and Newton polygon
// as second and third input: 
int mu=milnor(g);
list NP=newtonpoly(g);
is_NND(g,mu,NP);
@expansion{} 0
@c end example is_NND d2t_singular/hnoether_lib.doc:1052
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1066
@menu
See also:
* newtonpoly::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:1066

@c ---end content is_NND---

@c ------------------- puiseux2generators -------------
@node puiseux2generators, separateHNE, is_NND, hnoether_lib
@subsubsection puiseux2generators
@cindex puiseux2generators
@c ---content puiseux2generators---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
puiseux2generators(m,n); m,n intvec

@item @strong{Assume:}
m, resp. n, represent the 1st, resp. 2nd, components of Puiseux pairs
(e.g., @code{m=invariants(L)[3]}, @code{n=invariants(L)[4]}).

@item @strong{Return:}
intvec of the generators of the semigroup of values.

@end table
@strong{Example:}
@smallexample
@c computed example puiseux2generators d2t_singular/hnoether_lib.doc:1093 
LIB "hnoether.lib";
// take (3,2),(7,2),(15,2),(31,2),(63,2),(127,2) as Puiseux pairs:
puiseux2generators(intvec(3,7,15,31,63,127),intvec(2,2,2,2,2,2));
@expansion{} 64,96,208,424,852,1706,3413
@c end example puiseux2generators d2t_singular/hnoether_lib.doc:1093
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1099
@menu
See also:
* invariants::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:1099

@c ---end content puiseux2generators---

@c ------------------- separateHNE -------------
@node separateHNE, squarefree, puiseux2generators, hnoether_lib
@subsubsection separateHNE
@cindex separateHNE
@c ---content separateHNE---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
separateHNE(hne1,hne2); hne1, hne2 lists

@item @strong{Assume:}
hne1, hne2 are HNEs (=output of
@code{develop(f)}, @code{extdevelop(develop(f),n)}, or
one entry in the list @code{hne} in the ring created by
@code{hnexpansion(f[,"ess"])}.

@item @strong{Return:}
number of quadratic transformations needed to separate both curves
(branches).

@end table
@strong{Example:}
@smallexample
@c computed example separateHNE d2t_singular/hnoether_lib.doc:1129 
LIB "hnoether.lib";
int p=printlevel; printlevel=-1;
ring r=0,(x,y),dp;
list hne1=develop(x);
list hne2=develop(x+y);
list hne3=develop(x+y2);
separateHNE(hne1,hne2);  // two transversal lines
@expansion{} 1
separateHNE(hne1,hne3);  // one quadratic transform. gives 1st example
@expansion{} 2
printlevel=p;
@c end example separateHNE d2t_singular/hnoether_lib.doc:1129
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1141
@menu
See also:
* develop::
* displayMultsequence::
* hnexpansion::
* multsequence::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:1141

@c ---end content separateHNE---

@c ------------------- squarefree -------------
@node squarefree, allsquarefree, separateHNE, hnoether_lib
@subsubsection squarefree
@cindex squarefree
@c ---content squarefree---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
squarefree(f); f poly

@item @strong{Assume:}
f is a bivariate polynomial (in the first 2 ring variables).

@item @strong{Return:}
poly, a squarefree divisor of f.

@item @strong{Note:}
Usually, the return value is the greatest squarefree divisor, but
there is one exception: factors with a p-th root, p the
characteristic of the basering, are lost.

@end table
@strong{Example:}
@smallexample
@c computed example squarefree d2t_singular/hnoether_lib.doc:1172 
LIB "hnoether.lib";
ring exring=3,(x,y),dp;
squarefree((x3+y)^2);
@expansion{} x3+y
squarefree((x+y)^3*(x-y)^2); // Warning: (x+y)^3 is lost
@expansion{} x-y
squarefree((x+y)^4*(x-y)^2); // result is (x+y)*(x-y)
@expansion{} x2-y2
@c end example squarefree d2t_singular/hnoether_lib.doc:1172
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1180
@menu
See also:
* allsquarefree::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:1180

@c ---end content squarefree---

@c ------------------- allsquarefree -------------
@node allsquarefree, further_hn_proc, squarefree, hnoether_lib
@subsubsection allsquarefree
@cindex allsquarefree
@c ---content allsquarefree---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage :}
allsquarefree(f,g); f,g poly

@item @strong{Assume:}
g is the output of @code{squarefree(f)}.

@item @strong{Return:}
the greatest squarefree divisor of f.

@item @strong{Note  :}
This proc uses factorize to get the missing factors of f not in g and,
therefore, may be slow.

@end table
@strong{Example:}
@smallexample
@c computed example allsquarefree d2t_singular/hnoether_lib.doc:1210 
LIB "hnoether.lib";
ring exring=7,(x,y),dp;
poly f=(x+y)^7*(x-y)^8;
poly g=squarefree(f);
g;                      // factor x+y lost, since characteristic=7
@expansion{} x-y
allsquarefree(f,g);     // all factors (x+y)*(x-y) found
@expansion{} x2-y2
@c end example allsquarefree d2t_singular/hnoether_lib.doc:1210
@end smallexample
@c inserted refs from d2t_singular/hnoether_lib.doc:1219
@menu
See also:
* squarefree::
@end menu
@c end inserted refs from d2t_singular/hnoether_lib.doc:1219

@c ---end content allsquarefree---

@c ------------------- further_hn_proc -------------
@node further_hn_proc,, allsquarefree, hnoether_lib
@subsubsection further_hn_proc
@cindex further_hn_proc
@c ---content further_hn_proc---
Procedure from library @code{hnoether.lib} (@pxref{hnoether_lib}).

@table @asis
@item @strong{Usage:}
further_hn_proc();

@item @strong{Note:}
The library @code{hnoether.lib} contains some more procedures which
are not shown when typing @code{help hnoether.lib;}. They may be useful
for interactive use (e.g. if you want to do the calculation of an HN
development "by hand" to see the intermediate results), and they
can be enumerated by calling @code{further_hn_proc()}. @*
Use @code{help <procedure>;} for detailed information about each of
them.

@end table
@strong{Example:}
@smallexample
@c computed example further_hn_proc d2t_singular/hnoether_lib.doc:1248 
LIB "hnoether.lib";
further_hn_proc();
@expansion{} 
@expansion{}  The following procedures are also part of `hnoether.lib':
@expansion{} 
@expansion{}  getnm(f);           intersection pts. of Newton polygon with axes
@expansion{}  T_Transform(f,Q,N); returns f(y,xy^Q)/y^NQ (f: poly, Q,N: int)
@expansion{}  T1_Transform(f,d,M); returns f(x,y+d*x^M)  (f: poly,d:number,M:int)
@expansion{}  T2_Transform(f,d,M,N,ref);   a composition of T1 & T
@expansion{}  koeff(f,I,J);       gets coefficient of indicated monomial of poly f
@expansion{}  redleit(f,S,E);     restriction of monomials of f to line (S-E)
@expansion{}  leit(f,n,m);        special case of redleit (for irred. polynomials)
@expansion{}  testreducible(f,n,m); tests whether f is reducible
@expansion{}  charPoly(f,M,N);    characteristic polynomial of f
@expansion{}  find_in_list(L,p);  find int p in list L
@expansion{}  get_last_divisor(M,N); last divisor in Euclid's algorithm
@expansion{}  factorfirst(f,M,N); try to factor f without `factorize'
@expansion{}  factorlist(L);      factorize a list L of polynomials
@expansion{}  referencepoly(D);   a polynomial f s.t. D is the Newton diagram of f
@c end example further_hn_proc d2t_singular/hnoether_lib.doc:1248
@end smallexample
@c ---end content further_hn_proc---
@c ---------------------------------------------------------
@node mondromy_lib, qhmoduli_lib, hnoether_lib, Singularities
@subsection mondromy_lib
@c include of docu for mondromy.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/mondromy_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/mondromy_lib.doc INSTEAD
@c library version: (1.22.2.2,2002/02/20)
@c library file: ../Singular/LIB/mondromy.lib
@cindex mondromy.lib
@cindex mondromy_lib
@table @asis
@item @strong{Library:}
mondromy.lib
@item @strong{Purpose:}
  Monodromy of an Isolated Hypersurface Singularity
@item @strong{Author:}
Mathias Schulze, email: mschulze@@mathematik.uni-kl.de

@item @strong{Overview:}
A library to compute the monodromy of an isolated hypersurface singularity.
It uses an algorithm by Brieskorn (manuscripta math. 2 (1970), 103-161) to
compute a connection matrix of the meromorphic Gauss-Manin connection up to
arbitrarily high order, and an algorithm of Gerard and Levelt (Ann. Inst.
Fourier, Grenoble 23,1 (1973), pp. 157-195) to transform it to a simple pole.

@end table

@strong{Procedures:}
@menu
* detadj:: determinant and adjoint matrix of square matrix U
* invunit:: series inverse of polynomial u up to order n
* jacoblift:: lifts f^kappa in jacob(f) with minimal kappa
* monodromyB:: monodromy of isolated hypersurface singularity f
* H2basis:: basis of Brieskorn lattice H''
@end menu
@cindex Monodromy
@cindex hypersurface singularity
@cindex Gauss-Manin connection
@cindex Brieskorn lattice
@c inserted refs from d2t_singular/mondromy_lib.doc:35
@menu
See also:
* gaussman_lib::
@end menu
@c end inserted refs from d2t_singular/mondromy_lib.doc:35

@c ---end content LibInfo---

@c ------------------- detadj -------------
@node detadj, invunit,, mondromy_lib
@subsubsection detadj
@cindex detadj
@c ---content detadj---
Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).

@table @asis
@item @strong{Usage:}
detadj(U); U matrix

@item @strong{Assume:}
U is a square matrix with non zero determinant.

@item @strong{Return:}
The procedure returns a list with at most 2 entries.
@*If U is not a square matrix, the list is empty.
@*If U is a square matrix, then the first entry is the determinant of U.
If U is a square matrix and the determinant of U not zero,
then the second entry is the adjoint matrix of U.

@item @strong{Display:}
The procedure displays comments if printlevel>=1.

@end table
@strong{Example:}
@smallexample
@c computed example detadj d2t_singular/mondromy_lib.doc:68 
LIB "mondromy.lib";
ring R=0,x,dp;
matrix U[2][2]=1,1+x,1+x2,1+x3;
list daU=detadj(U);
daU[1];
@expansion{} -x2-x
print(daU[2]);
@expansion{} x3+1, -x-1,
@expansion{} -x2-1,1    
@c end example detadj d2t_singular/mondromy_lib.doc:68
@end smallexample
@c ---end content detadj---

@c ------------------- invunit -------------
@node invunit, jacoblift, detadj, mondromy_lib
@subsubsection invunit
@cindex invunit
@c ---content invunit---
Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).

@table @asis
@item @strong{Usage:}
invunit(u,n); u poly, n int

@item @strong{Assume:}
The polynomial u is a series unit.

@item @strong{Return:}
The procedure returns the series inverse of u up to order n
or a zero polynomial if u is no series unit.

@item @strong{Display:}
The procedure displays comments if printlevel>=1.

@end table
@strong{Example:}
@smallexample
@c computed example invunit d2t_singular/mondromy_lib.doc:103 
LIB "mondromy.lib";
ring R=0,(x,y),dp;
invunit(2+x3+xy4,10);
@expansion{} 1/8x2y8-1/16x9+1/4x4y4+1/8x6-1/4xy4-1/4x3+1/2
@c end example invunit d2t_singular/mondromy_lib.doc:103
@end smallexample
@c ---end content invunit---

@c ------------------- jacoblift -------------
@node jacoblift, monodromyB, invunit, mondromy_lib
@subsubsection jacoblift
@cindex jacoblift
@c ---content jacoblift---
Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).

@table @asis
@item @strong{Usage:}
jacoblift(f); f poly

@item @strong{Assume:}
The polynomial f in a series ring (local ordering) defines
an isolated hypersurface singularity.

@item @strong{Return:}
The procedure returns a list with entries kappa, xi, u of type
int, vector, poly such that kappa is minimal with f^kappa in jacob(f),
u is a unit, and u*f^kappa=(matrix(jacob(f))*xi)[1,1].

@item @strong{Display:}
The procedure displays comments if printlevel>=1.

@end table
@strong{Example:}
@smallexample
@c computed example jacoblift d2t_singular/mondromy_lib.doc:137 
LIB "mondromy.lib";
ring R=0,(x,y),ds;
poly f=x2y2+x6+y6;
jacoblift(f);
@expansion{} [1]:
@expansion{}    2
@expansion{} [2]:
@expansion{}    1/2x2y3*gen(2)+1/6x7*gen(1)+5/6x6y*gen(2)-2/3xy6*gen(1)+1/6y7*gen(2)-4\
   x4y5*gen(2)-3/2x9y2*gen(1)-15/2x8y3*gen(2)+9/2x3y8*gen(1)-3/2x2y9*gen(2)
@expansion{} [3]:
@expansion{}    1-9x2y2
@c end example jacoblift d2t_singular/mondromy_lib.doc:137
@end smallexample
@c ---end content jacoblift---

@c ------------------- monodromyB -------------
@node monodromyB, H2basis, jacoblift, mondromy_lib
@subsubsection monodromyB
@cindex monodromyB
@c ---content monodromyB---
Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).

@table @asis
@item @strong{Usage:}
monodromyB(f[,opt]); f poly, opt int

@item @strong{Assume:}
The polynomial f in a series ring (local ordering) defines
an isolated hypersurface singularity.

@item @strong{Return:}
The procedure returns a residue matrix M of the meromorphic
Gauss-Manin connection of the singularity defined by f
or an empty matrix if the assumptions are not fulfilled.
If opt=0 (default), exp(-2*pi*i*M) is a monodromy matrix of f,
else, only the characteristic polynomial of exp(-2*pi*i*M) coincides
with the characteristic polynomial of the monodromy of f.

@item @strong{Display:}
The procedure displays more comments for higher printlevel.

@end table
@strong{Example:}
@smallexample
@c computed example monodromyB d2t_singular/mondromy_lib.doc:175 
LIB "mondromy.lib";
ring R=0,(x,y),ds;
poly f=x2y2+x6+y6;
matrix M=monodromyB(f);
print(M);
@expansion{} 7/6,0,  0,0,  0,  0,0,   0,-1/2,0,  0,  0,    0,       
@expansion{} 0,  7/6,0,0,  0,  0,-1/2,0,0,   0,  0,  0,    0,       
@expansion{} 0,  0,  1,0,  0,  0,0,   0,0,   0,  0,  0,    0,       
@expansion{} 0,  0,  0,4/3,0,  0,0,   0,0,   0,  0,  0,    0,       
@expansion{} 0,  0,  0,0,  4/3,0,0,   0,0,   0,  0,  0,    0,       
@expansion{} 0,  0,  0,0,  0,  1,0,   0,0,   0,  0,  0,    0,       
@expansion{} 0,  0,  0,0,  0,  0,5/6, 0,0,   0,  0,  0,    0,       
@expansion{} 0,  0,  0,0,  0,  0,0,   1,0,   0,  0,  0,    0,       
@expansion{} 0,  0,  0,0,  0,  0,0,   0,5/6, 0,  0,  0,    0,       
@expansion{} 0,  0,  0,0,  0,  0,0,   0,0,   2/3,0,  0,    0,       
@expansion{} 0,  0,  0,0,  0,  0,0,   0,0,   0,  2/3,0,    0,       
@expansion{} 0,  0,  0,0,  0,  0,0,   0,0,   0,  0,  47/44,-625/396,
@expansion{} 0,  0,  0,0,  0,  0,0,   0,0,   0,  0,  9/44, -3/44    
@c end example monodromyB d2t_singular/mondromy_lib.doc:175
@end smallexample
@c ---end content monodromyB---

@c ------------------- H2basis -------------
@node H2basis,, monodromyB, mondromy_lib
@subsubsection H2basis
@cindex H2basis
@c ---content H2basis---
Procedure from library @code{mondromy.lib} (@pxref{mondromy_lib}).

@table @asis
@item @strong{Usage:}
H2basis(f); f poly

@item @strong{Assume:}
The polynomial f in a series ring (local ordering) defines
an isolated hypersurface singularity.

@item @strong{Return:}
The procedure returns a list of representatives of a C@{f@}-basis of the
Brieskorn lattice H''=Omega^(n+1)/df^dOmega^(n-1).

@item @strong{Theory:}
H'' is a free C@{f@}-module of rank milnor(f).

@item @strong{Display:}
The procedure displays more comments for higher printlevel.

@end table
@strong{Example:}
@smallexample
@c computed example H2basis d2t_singular/mondromy_lib.doc:213 
LIB "mondromy.lib";
ring R=0,(x,y),ds;
poly f=x2y2+x6+y6;
H2basis(f);
@expansion{} [1]:
@expansion{}    x4
@expansion{} [2]:
@expansion{}    x2y2
@expansion{} [3]:
@expansion{}    y4
@expansion{} [4]:
@expansion{}    x3
@expansion{} [5]:
@expansion{}    x2y
@expansion{} [6]:
@expansion{}    xy2
@expansion{} [7]:
@expansion{}    y3
@expansion{} [8]:
@expansion{}    x2
@expansion{} [9]:
@expansion{}    xy
@expansion{} [10]:
@expansion{}    y2
@expansion{} [11]:
@expansion{}    x
@expansion{} [12]:
@expansion{}    y
@expansion{} [13]:
@expansion{}    1
@c end example H2basis d2t_singular/mondromy_lib.doc:213
@end smallexample
@c ---end content H2basis---
@c ---------------------------------------------------------
@node qhmoduli_lib, sing_lib, mondromy_lib, Singularities
@subsection qhmoduli_lib
@c include of docu for qhmoduli.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/qhmoduli_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/qhmoduli_lib.doc INSTEAD
@c library version: (1.0,2000/12/12)
@c library file: ../Singular/LIB/qhmoduli.lib
@cindex qhmoduli.lib
@cindex qhmoduli_lib
@table @asis
@item @strong{Library:}
qhmoduli.lib
@item @strong{Purpose:}
    Moduli Spaces of Semi-Quasihomogeneous Singularities
@item @strong{Author:}
Thomas Bayer, email: bayert@@in.tum.de

@end table

@strong{Procedures:}
@menu
* ArnoldAction:: Induced action of G_f on T_.
* ModEqn:: Equations of the moduli space for principal part f
* QuotientEquations:: Equations of Variety(I)/G w.r.t. action 'A'
* StabEqn:: Equations of the stabilizer of f.
* StabEqnId:: Equations of the stabilizer of the qhom. ideal I.
* StabOrder:: Order of the stabilizer of f.
* UpperMonomials:: Upper basis of the Milnor algebra of f.
* Max:: maximal integer contained in 'data'
* Min:: minimal integer contained in 'data'
* Table:: list, i-th entry is cmd(i), lb <= i <= ub
@end menu
@c ---end content LibInfo---

@c ------------------- ArnoldAction -------------
@node ArnoldAction, ModEqn,, qhmoduli_lib
@subsubsection ArnoldAction
@cindex ArnoldAction
@c ---content ArnoldAction---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
ArnoldAction(f, [Gf, B]); poly f; list Gf, B;
@*'Gf' is a list of two rings (coming from 'StabEqn')

@item @strong{Purpose:}
compute the induced action of the stabilizer G of f on T_, where
T_ is given by the upper monomials B of the Milnor algebra of f.

@item @strong{Assume:}
f is quasihomogeneous

@item @strong{Return:}
polynomial ring over the same ground field, containing the ideals
'actionid' and 'stabid'.
@*- 'actionid' is the ideal defining the induced action of Gf on T_ @*
- 'stabid' is the ideal of the stabilizer Gf in the new ring

@end table
@strong{Example:}
@smallexample
@c computed example ArnoldAction d2t_singular/qhmoduli_lib.doc:59 
LIB "qhmoduli.lib";
ring B   = 0,(x,y,z), ls;
poly f = -z5+y5+x2z+x2y;
def R = ArnoldAction(f);
setring R;
actionid;
@expansion{} actionid[1]=-s(2)*t(1)+s(3)*t(1)
@expansion{} actionid[2]=-s(2)^2*t(2)+2*s(2)^2*t(3)^2+s(3)^2*t(2)
@expansion{} actionid[3]=s(2)*t(3)+s(3)*t(3)
stabid;
@expansion{} stabid[1]=s(2)*s(3)
@expansion{} stabid[2]=s(1)^2*s(2)+s(1)^2*s(3)-1
@expansion{} stabid[3]=s(1)^2*s(3)^2-s(3)
@expansion{} stabid[4]=s(1)^2+s(2)^4-s(3)^4
@expansion{} stabid[5]=s(1)^4+s(2)^3-s(3)^3
@expansion{} stabid[6]=-s(1)^2*s(3)+s(3)^5
@c end example ArnoldAction d2t_singular/qhmoduli_lib.doc:59
@end smallexample
@c ---end content ArnoldAction---

@c ------------------- ModEqn -------------
@node ModEqn, QuotientEquations, ArnoldAction, qhmoduli_lib
@subsubsection ModEqn
@cindex ModEqn
@c ---content ModEqn---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
ModEqn(f [, opt]); poly f; int opt;

@item @strong{Purpose:}
compute equations of the moduli space of semiquasihomogeneous hypersurface singularity with principal part f w.r.t. right equivalence

@item @strong{Assume:}
f quasihomogeneous polynomial with an isolated singularity at 0

@item @strong{Return:}
polynomial ring, possibly a simple extension of the ground field of
the basering, containing the ideal 'modid'
@*- 'modid' is the ideal of the moduli space if opt is even (> 0).
otherwise it contains generators of the coordinate ring R of the
moduli space (note : Spec(R) is the moduli space)

@item @strong{Options:}
1 compute equations of the mod. space,
@*2 use a primary decomposition
@*4 compute E_f0, i.e., the image of G_f0
@*To combine options, add their value, default: opt =7

@end table
@strong{Example:}
@smallexample
@c computed example ModEqn d2t_singular/qhmoduli_lib.doc:104 
LIB "qhmoduli.lib";
ring B   = 0,(x,y), ls;
poly f = -x4 + xy5;
def R = ModEqn(f);
setring R;
modid;
@expansion{} modid[1]=Y(5)^2-Y(4)*Y(6)
@expansion{} modid[2]=Y(4)*Y(5)-Y(3)*Y(6)
@expansion{} modid[3]=Y(3)*Y(5)-Y(2)*Y(6)
@expansion{} modid[4]=Y(2)*Y(5)-Y(1)*Y(6)
@expansion{} modid[5]=Y(4)^2-Y(2)*Y(6)
@expansion{} modid[6]=Y(3)*Y(4)-Y(1)*Y(6)
@expansion{} modid[7]=Y(2)*Y(4)-Y(1)*Y(5)
@expansion{} modid[8]=Y(3)^2-Y(1)*Y(5)
@expansion{} modid[9]=Y(2)*Y(3)-Y(1)*Y(4)
@expansion{} modid[10]=Y(2)^2-Y(1)*Y(3)
@c end example ModEqn d2t_singular/qhmoduli_lib.doc:104
@end smallexample
@c ---end content ModEqn---

@c ------------------- QuotientEquations -------------
@node QuotientEquations, StabEqn, ModEqn, qhmoduli_lib
@subsubsection QuotientEquations
@cindex QuotientEquations
@c ---content QuotientEquations---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
QuotientEquations(G,action,emb [, opt]); ideal G,action,emb;int opt

@item @strong{Purpose:}
compute the quotient of the variety given by the parameterization
'emb' by the linear action 'action' of the algebraic group G.

@item @strong{Assume:}
'action' is linear, G must be finite if the Reynolds operator is
needed (i.e., NullCone(G,action) returns some non-invariant polys)

@item @strong{Return:}
polynomial ring over a simple extension of the ground field of the
basering, containing the ideals 'id' and 'embedid'.
@*- 'id' contains the equations of the quotient, if opt = 1;
if opt = 0, 2, 'id' contains generators of the coordinate ring R
of the quotient (Spec(R) is the quotient)
@*- 'embedid' = 0, if opt = 1;
@*if opt = 0, 2, it is the ideal defining the equivariant embedding

@item @strong{Options:}
1 compute equations of the quotient,
@*2 use a primary decomposition when computing the Reynolds operator @*
To combine options, add their value, default: opt =3.

@end table
@c ---end content QuotientEquations---

@c ------------------- StabEqn -------------
@node StabEqn, StabEqnId, QuotientEquations, qhmoduli_lib
@subsubsection StabEqn
@cindex StabEqn
@c ---content StabEqn---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
StabEqn(f); f polynomial

@item @strong{Purpose:}
compute the equations of the isometry group of f.

@item @strong{Assume:}
f semiquasihomogeneous polynomial with an isolated singularity at 0

@item @strong{Return:}
list of two ring 'S1', 'S2'
@*- 'S1' contains the equations of the stabilizer (ideal 'stabid') @*
- 'S2' contains the action of the stabilizer (ideal 'actionid')

@item @strong{Global:}
varSubsList, contains the index j s.t. x(i) -> x(i)t(j) ...

@end table
@strong{Example:}
@smallexample
@c computed example StabEqn d2t_singular/qhmoduli_lib.doc:179 
LIB "qhmoduli.lib";
ring B = 0,(x,y,z), ls;
poly f = -z5+y5+x2z+x2y;
list stab = StabEqn(f);
def S1 = stab[1]; setring S1;  stabid;
@expansion{} stabid[1]=s(2)*s(3)
@expansion{} stabid[2]=s(1)^2*s(2)+s(1)^2*s(3)-1
@expansion{} stabid[3]=s(1)^2*s(3)^2-s(3)
@expansion{} stabid[4]=s(2)^4-s(3)^4+s(1)^2
@expansion{} stabid[5]=s(1)^4+s(2)^3-s(3)^3
@expansion{} stabid[6]=s(3)^5-s(1)^2*s(3)
def S2 = stab[2]; setring S2;  actionid;
@expansion{} actionid[1]=s(1)*x
@expansion{} actionid[2]=s(3)*y+s(2)*z
@expansion{} actionid[3]=s(2)*y+s(3)*z
@c end example StabEqn d2t_singular/qhmoduli_lib.doc:179
@end smallexample
@c ---end content StabEqn---

@c ------------------- StabEqnId -------------
@node StabEqnId, StabOrder, StabEqn, qhmoduli_lib
@subsubsection StabEqnId
@cindex StabEqnId
@c ---content StabEqnId---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
StabEqn(I, w); I ideal, w intvec

@item @strong{Purpose:}
compute the equations of the isometry group of the ideal I
each generator of I is fixed by the stabilizer.

@item @strong{Assume:}
I semiquasihomogeneous ideal wrt 'w' with an isolated singularity at 0

@item @strong{Return:}
list of two ring 'S1', 'S2'
@*- 'S1' contains the equations of the stabilizer (ideal 'stabid') @*
- 'S2' contains the action of the stabilizer (ideal 'actionid')

@item @strong{Global:}
varSubsList, contains the index j s.t. t(i) -> t(i)t(j) ...

@end table
@strong{Example:}
@smallexample
@c computed example StabEqnId d2t_singular/qhmoduli_lib.doc:219 
LIB "qhmoduli.lib";
ring B   = 0,(x,y,z), ls;
ideal I = x2,y3,z6;
intvec w = 3,2,1;
list stab = StabEqnId(I, w);
@expansion{} // ** redefining d **
@expansion{} // ** redefining newcoMx **
@expansion{} // ** redefining coMx **
@expansion{} // ** redefining d **
@expansion{} // ** redefining newcoMx **
@expansion{} // ** redefining coMx **
def S1 = stab[1]; setring S1;  stabid;
@expansion{} stabid[1]=s(1)^2-1
@expansion{} stabid[2]=s(2)^3-1
@expansion{} stabid[3]=s(3)^6-1
def S2 = stab[2]; setring S2;  actionid;
@expansion{} actionid[1]=s(1)*x
@expansion{} actionid[2]=s(2)*y
@expansion{} actionid[3]=s(3)*z
@c end example StabEqnId d2t_singular/qhmoduli_lib.doc:219
@end smallexample
@c ---end content StabEqnId---

@c ------------------- StabOrder -------------
@node StabOrder, UpperMonomials, StabEqnId, qhmoduli_lib
@subsubsection StabOrder
@cindex StabOrder
@c ---content StabOrder---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
StabOrder(f); poly f;

@item @strong{Purpose:}
compute the order of the stabilizer group of f.

@item @strong{Assume:}
f quasihomogeneous polynomial with an isolated singularity at 0

@item @strong{Return:}
int

@item @strong{Global:}
varSubsList

@end table
@c ---end content StabOrder---

@c ------------------- UpperMonomials -------------
@node UpperMonomials, Max, StabOrder, qhmoduli_lib
@subsubsection UpperMonomials
@cindex UpperMonomials
@c ---content UpperMonomials---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
UpperMonomials(poly f, [intvec w])

@item @strong{Purpose:}
compute the upper monomials of the milnor algebra of f.

@item @strong{Assume:}
f is quasihomogeneous (w.r.t. w)

@item @strong{Return:}
ideal

@end table
@strong{Example:}
@smallexample
@c computed example UpperMonomials d2t_singular/qhmoduli_lib.doc:280 
LIB "qhmoduli.lib";
ring B   = 0,(x,y,z), ls;
poly f = -z5+y5+x2z+x2y;
UpperMonomials(f);
@expansion{} _[1]=y3z3
@expansion{} _[2]=x2y3
@expansion{} _[3]=x2y2
@c end example UpperMonomials d2t_singular/qhmoduli_lib.doc:280
@end smallexample
@c ---end content UpperMonomials---

@c ------------------- Max -------------
@node Max, Min, UpperMonomials, qhmoduli_lib
@subsubsection Max
@cindex Max
@c ---content Max---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
Max(data); intvec/list of integers data

@item @strong{Purpose:}
find the maximal integer contained in 'data'

@item @strong{Return:}
list

@item @strong{Assume:}
'data' contains only integers and is not empty

@end table
@c ---end content Max---

@c ------------------- Min -------------
@node Min, Table, Max, qhmoduli_lib
@subsubsection Min
@cindex Min
@c ---content Min---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
Min(data); intvec/list of integers data

@item @strong{Purpose:}
find the minimal integer contained in 'data'

@item @strong{Return:}
list

@item @strong{Assume:}
'data' contains only integers and is not empty

@end table
@c ---end content Min---

@c ------------------- Table -------------
@node Table,, Min, qhmoduli_lib
@subsubsection Table
@cindex Table
@c ---content Table---
Procedure from library @code{qhmoduli.lib} (@pxref{qhmoduli_lib}).

@table @asis
@item @strong{Usage:}
Table(cmd,i, lb, ub); string cmd, i; int lb, ub

@item @strong{Purpose:}
generate a list of size ub - lb + 1 s.t. _[i] = cmd(i)

@item @strong{Return:}
list

@end table
@c ---end content Table---
@c ----------------------------------------------------------
@node sing_lib, spcurve_lib, qhmoduli_lib, Singularities
@subsection sing_lib
@c include of docu for sing.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/sing_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/sing_lib.doc INSTEAD
@c library version: (1.24.2.5,2003/04/15)
@c library file: ../Singular/LIB/sing.lib
@cindex sing.lib
@cindex sing_lib
@table @asis
@item @strong{Library:}
sing.lib
@item @strong{Purpose:}
      Invariants of Singularities
@item @strong{Authors:}
Gert-Martin Greuel, email: greuel@@mathematik.uni-kl.de @*
Bernd Martin, email: martin@@math.tu-cottbus.de

@end table

@strong{Procedures:}
@menu
* deform:: infinitesimal deformations of ideal i
* dim_slocus:: dimension of singular locus of ideal i
* is_active:: is poly f an active element mod id? (id ideal/module)
* is_ci:: is ideal i a complete intersection?
* is_is:: is ideal i an isolated singularity?
* is_reg:: is poly f a regular element mod id? (id ideal/module)
* is_regs:: are gen's of ideal i regular sequence modulo id?
* locstd:: SB for local degree ordering without cancelling units
* milnor:: milnor number of ideal i; (assume i is ICIS in nf)
* nf_icis:: generic combinations of generators; get ICIS in nf
* slocus:: ideal of singular locus of ideal i
* qhspectrum:: spectrum numbers of w-homogeneous polynomial f
* Tjurina:: SB of Tjurina module of ideal i (assume i is ICIS)
* tjurina:: Tjurina number of ideal i (assume i is ICIS)
* T_1:: T^1-module of ideal i
* T_2:: T^2-module of ideal i
* T_12:: T^1- and T^2-module of ideal i
* tangentcone:: compute tangent cone of id
@end menu
@c ---end content LibInfo---

@c ------------------- deform -------------
@node deform, dim_slocus,, sing_lib
@subsubsection deform
@cindex deform
@c ---content deform---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
deform(id); id=ideal or poly

@item @strong{Return:}
matrix, columns are kbase of infinitesimal deformations

@end table
@strong{Example:}
@smallexample
@c computed example deform d2t_singular/sing_lib.doc:57 
LIB "sing.lib";
ring r   = 32003,(x,y,z),ds;
ideal i  = xy,xz,yz;
matrix T = deform(i);
print(T);
@expansion{} x,0,0,
@expansion{} 0,0,z,
@expansion{} 0,y,0 
print(deform(x3+y5+z2));
@expansion{} xy3,y3,xy2,y2,xy,y,x,1
@c end example deform d2t_singular/sing_lib.doc:57
@end smallexample
@c ---end content deform---

@c ------------------- dim_slocus -------------
@node dim_slocus, is_active, deform, sing_lib
@subsubsection dim_slocus
@cindex dim_slocus
@c ---content dim_slocus---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
dim_slocus(i); i ideal or poly

@item @strong{Return:}
dimension of singular locus of i

@end table
@strong{Example:}
@smallexample
@c computed example dim_slocus d2t_singular/sing_lib.doc:85 
LIB "sing.lib";
ring r  = 32003,(x,y,z),ds;
ideal i = x5+y6+z6,x2+2y2+3z2;
dim_slocus(i);
@expansion{} 0
@c end example dim_slocus d2t_singular/sing_lib.doc:85
@end smallexample
@c ---end content dim_slocus---

@c ------------------- is_active -------------
@node is_active, is_ci, dim_slocus, sing_lib
@subsubsection is_active
@cindex is_active
@c ---content is_active---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
is_active(f,id); f poly, id ideal or module

@item @strong{Return:}
1 if f is an active element modulo id (i.e. dim(id)=dim(id+f*R^n)+1,
if id is a submodule of R^n) resp. 0 if f is not active.
The basering may be a quotient ring

@item @strong{Note:}
regular parameters are active but not vice versa (id may have embedded
components). proc is_reg tests whether f is a regular parameter

@end table
@strong{Example:}
@smallexample
@c computed example is_active d2t_singular/sing_lib.doc:117 
LIB "sing.lib";
ring r   =32003,(x,y,z),ds;
ideal i  = yx3+y,yz3+y3z;
poly f   = x;
is_active(f,i);
@expansion{} 1
qring q  = std(x4y5);
poly f   = x;
module m = [yx3+x,yx3+y3x];
is_active(f,m);
@expansion{} 0
@c end example is_active d2t_singular/sing_lib.doc:117
@end smallexample
@c ---end content is_active---

@c ------------------- is_ci -------------
@node is_ci, is_is, is_active, sing_lib
@subsubsection is_ci
@cindex is_ci
@c ---content is_ci---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
is_ci(i); i ideal

@item @strong{Return:}
intvec = sequence of dimensions of ideals (j[1],...,j[k]), for
k=1,...,size(j), where j is minimal base of i. i is a complete
intersection if last number equals nvars-size(i)

@item @strong{Note:}
dim(0-ideal) = -1. You may first apply simplify(i,10); in order to
delete zeroes and multiples from set of generators
@*printlevel >=0: display comments (default)

@end table
@strong{Example:}
@smallexample
@c computed example is_ci d2t_singular/sing_lib.doc:155 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;                // display comments
ring r     = 32003,(x,y,z),ds;
ideal i    = x4+y5+z6,xyz,yx2+xz2+zy7;
is_ci(i);
@expansion{} // complete intersection of dim 0
@expansion{} // dim-sequence:
@expansion{} 2,1,0
i          = xy,yz;
is_ci(i);
@expansion{} // no complete intersection
@expansion{} // dim-sequence:
@expansion{} 2,2
printlevel = p;
@c end example is_ci d2t_singular/sing_lib.doc:155
@end smallexample
@c ---end content is_ci---

@c ------------------- is_is -------------
@node is_is, is_reg, is_ci, sing_lib
@subsubsection is_is
@cindex is_is
@c ---content is_is---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
is_is(id); id ideal or poly

@item @strong{Return:}
intvec = sequence of dimensions of singular loci of ideals
generated by id[1]..id[i], k = 1..size(id); @*
dim(0-ideal) = -1;
@*id defines an isolated singularity if last number is 0

@item @strong{Note:}
printlevel >=0: display comments (default)

@end table
@strong{Example:}
@smallexample
@c computed example is_is d2t_singular/sing_lib.doc:192 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 32003,(x,y,z),ds;
ideal i    = x2y,x4+y5+z6,yx2+xz2+zy7;
is_is(i);
@expansion{} // dim of singular locus = 0
@expansion{} // isolated singularity if last number is 0 in dim-sequence:
@expansion{} 2,1,0
poly f     = xy+yz;
is_is(f);
@expansion{} // dim of singular locus = 1
@expansion{} // isolated singularity if last number is 0 in dim-sequence:
@expansion{} 1
printlevel = p;
@c end example is_is d2t_singular/sing_lib.doc:192
@end smallexample
@c ---end content is_is---

@c ------------------- is_reg -------------
@node is_reg, is_regs, is_is, sing_lib
@subsubsection is_reg
@cindex is_reg
@c ---content is_reg---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
is_reg(f,id); f poly, id ideal or module

@item @strong{Return:}
1 if multiplication with f is injective modulo id, 0 otherwise

@item @strong{Note:}
let R be the basering and id a submodule of R^n. The procedure checks
injectivity of multiplication with f on R^n/id. The basering may be a
quotient ring

@end table
@strong{Example:}
@smallexample
@c computed example is_reg d2t_singular/sing_lib.doc:228 
LIB "sing.lib";
ring r  = 32003,(x,y),ds;
ideal i = x8,y8;
ideal j = (x+y)^4;
i       = intersect(i,j);
poly f  = xy;
is_reg(f,i);
@expansion{} 0
@c end example is_reg d2t_singular/sing_lib.doc:228
@end smallexample
@c ---end content is_reg---

@c ------------------- is_regs -------------
@node is_regs, locstd, is_reg, sing_lib
@subsubsection is_regs
@cindex is_regs
@c ---content is_regs---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
is_regs(i[,id]); i poly, id ideal or module (default: id=0)

@item @strong{Return:}
1 if generators of i are a regular sequence modulo id, 0 otherwise

@item @strong{Note:}
let R be the basering and id a submodule of R^n. The procedure checks
injectivity of multiplication with i[k] on R^n/id+i[1..k-1].
The basering may be a quotient ring
@*printlevel >=0: display comments (default)
@*printlevel >=1: display comments during computation

@end table
@strong{Example:}
@smallexample
@c computed example is_regs d2t_singular/sing_lib.doc:264 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;
ring r1    = 32003,(x,y,z),ds;
ideal i    = x8,y8,(x+y)^4;
is_regs(i);
@expansion{} // checking whether element 1 is regular mod 1 .. 0
@expansion{} // checking whether element 2 is regular mod 1 .. 1
@expansion{} // checking whether element 3 is regular mod 1 .. 2
@expansion{} // elements 1..2 are regular, 3 is not regular mod 1..2
@expansion{} 0
module m   = [x,0,y];
i          = x8,(x+z)^4;;
is_regs(i,m);
@expansion{} // checking whether element 1 is regular mod 1 .. 0
@expansion{} // checking whether element 2 is regular mod 1 .. 1
@expansion{} // elements are a regular sequence of length 2
@expansion{} 1
printlevel = p;
@c end example is_regs d2t_singular/sing_lib.doc:264
@end smallexample
@c ---end content is_regs---

@c ------------------- locstd -------------
@node locstd, milnor, is_regs, sing_lib
@subsubsection locstd
@cindex locstd
@c ---content locstd---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
locstd (id); id = ideal

@item @strong{Return:}
a standard basis for a local degree ordering

@item @strong{Note:}
the procedure homogenizes id w.r.t. a new 1st variable @@t@@, computes
a SB wrt (dp(1),dp) and substitutes @@t@@ by 1.
@*Hence the result is a SB with respect to an ordering which sorts
first w.r.t. the order and then refines it with dp. This is a
local degree ordering.
@*This is done in order to avoid cancellation of units and thus
be able to use option(contentSB);

@end table
@strong{Example:}
@smallexample
@c computed example locstd d2t_singular/sing_lib.doc:305 
LIB "sing.lib";
ring R = 0,(x,y,z),ds;
ideal i  = xyz+z5,2x2+y3+z7,3z5+y5;
locstd(i);
@expansion{} _[1]=y5+3z5
@expansion{} _[2]=3x4y3z8-4x3y3z9+6x2y4z9+3y5z10
@expansion{} _[3]=3x4z13-4x3z14+6x2yz14+3y2z15
@expansion{} _[4]=3x4yz12-4x3yz13+6x2y2z13+3y3z14
@expansion{} _[5]=2x2z9+x2y2z8+y3z9
@expansion{} _[6]=2x2y4z5+y7z5-3x2yz9
@expansion{} _[7]=6y2z10-3x2y3z8+4xy3z9-3y4z9
@expansion{} _[8]=3x2y2z8+3y3z9+2xy4z8
@expansion{} _[9]=18z14-4xy6z8+3y7z8-9x2yz12
@expansion{} _[10]=xyz+z5
@expansion{} _[11]=3xz6-y4z5
@expansion{} _[12]=3y3z6+2xy4z5-3xyz9
@expansion{} _[13]=y4z5-2xz9-xy2z8
@expansion{} _[14]=3z10+2xyz9+xy3z8
@expansion{} _[15]=2x2z5+y3z5-xyz8
@expansion{} _[16]=y4z-2xz5+yz8
@expansion{} _[17]=3z6+2xyz5-y2z8
@expansion{} _[18]=2x2+y3+z7
@c end example locstd d2t_singular/sing_lib.doc:305
@end smallexample
@c ---end content locstd---

@c ------------------- milnor -------------
@node milnor, nf_icis, locstd, sing_lib
@subsubsection milnor
@cindex milnor
@c ---content milnor---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
milnor(i); i ideal or poly

@item @strong{Return:}
Milnor number of i, if i is ICIS (isolated complete intersection
singularity) in generic form, resp. -1 if not

@item @strong{Note:}
use proc nf_icis to put generators in generic form
@*printlevel >=0: display comments (default)

@end table
@strong{Example:}
@smallexample
@c computed example milnor d2t_singular/sing_lib.doc:336 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 32003,(x,y,z),ds;
ideal j    = x5+y6+z6,x2+2y2+3z2,xyz+yx;
milnor(j);
@expansion{} //sequence of discriminant numbers: 100,149,70
@expansion{} 21
poly f     = x7+y7+(x-y)^2*x2y2+z2;
milnor(f);
@expansion{} 28
printlevel = p;
@c end example milnor d2t_singular/sing_lib.doc:336
@end smallexample
@c ---end content milnor---

@c ------------------- nf_icis -------------
@node nf_icis, slocus, milnor, sing_lib
@subsubsection nf_icis
@cindex nf_icis
@c ---content nf_icis---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
nf_icis(i); i ideal

@item @strong{Return:}
ideal = generic linear combination of generators of i if i is an ICIS
(isolated complete intersection singularity), return i if not

@item @strong{Note:}
this proc is useful in connection with proc milnor
@*printlevel >=0: display comments (default)

@end table
@strong{Example:}
@smallexample
@c computed example nf_icis d2t_singular/sing_lib.doc:372 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 32003,(x,y,z),ds;
ideal i    = x3+y4,z4+yx;
nf_icis(i);
@expansion{} // complete intersection of dim 1
@expansion{} // dim-sequence:
@expansion{} // dim of singular locus = 0
@expansion{} // isolated singularity if last number is 0 in dim-sequence:
@expansion{} // dim of singular locus = 0
@expansion{} // isolated singularity if last number is 0 in dim-sequence:
@expansion{} // ICIS in generic form after 1 genericity loop(s)
@expansion{} _[1]=2xy+x3+y4+2z4
@expansion{} _[2]=xy+z4
ideal j    = x3+y4,xy,yz;
nf_icis(j);
@expansion{} // no complete intersection
@expansion{} // dim-sequence:
@expansion{} // no complete intersection
@expansion{} _[1]=x3+y4
@expansion{} _[2]=xy
@expansion{} _[3]=yz
printlevel = p;
@c end example nf_icis d2t_singular/sing_lib.doc:372
@end smallexample
@c ---end content nf_icis---

@c ------------------- slocus -------------
@node slocus, qhspectrum, nf_icis, sing_lib
@subsubsection slocus
@cindex slocus
@c ---content slocus---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
slocus(i); i ideal

@item @strong{Return:}
ideal of singular locus of i

@end table
@strong{Example:}
@smallexample
@c computed example slocus d2t_singular/sing_lib.doc:403 
LIB "sing.lib";
ring r  = 0,(u,v,w,x,y,z),dp;
ideal i = wx,wy,wz,vx,vy,vz,ux,uy,uz,y3-x2;;
slocus(i);
@expansion{} _[1]=x
@expansion{} _[2]=w
@expansion{} _[3]=v
@expansion{} _[4]=u
@expansion{} _[5]=y2
@c end example slocus d2t_singular/sing_lib.doc:403
@end smallexample
@c ---end content slocus---

@c ------------------- qhspectrum -------------
@node qhspectrum, Tjurina, slocus, sing_lib
@subsubsection qhspectrum
@cindex qhspectrum
@c ---content qhspectrum---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
qhspectrum(f,w); f=poly, w=intvec;

@item @strong{Assume:}
f is a weighted homogeneous isolated singularity w.r.t. the weights
given by w; w must consist of as many positive integers as there
are variables of the basering

@item @strong{Compute:}
the spectral numbers of the w-homogeneous polynomial f, computed in a
ring of characteristic 0

@item @strong{Return:}
intvec d,s1,...,su where:
@*d = w-degree(f) and si/d = i-th spectral-number(f)
@*No return value if basering has parameters or if f is no isolated
singularity, displays a warning in this case

@end table
@strong{Example:}
@smallexample
@c computed example qhspectrum d2t_singular/sing_lib.doc:441 
LIB "sing.lib";
ring r;
poly f=x3+y5+z2;
intvec w=10,6,15;
qhspectrum(f,w);
@expansion{} 30,1,7,11,13,17,19,23,29
// the spectrum numbers are:
// 1/30,7/30,11/30,13/30,17/30,19/30,23/30,29/30
@c end example qhspectrum d2t_singular/sing_lib.doc:441
@end smallexample
@c ---end content qhspectrum---

@c ------------------- Tjurina -------------
@node Tjurina, tjurina, qhspectrum, sing_lib
@subsubsection Tjurina
@cindex Tjurina
@c ---content Tjurina---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
Tjurina(id[,<any>]); id=ideal or poly

@item @strong{Assume:}
id=ICIS (isolated complete intersection singularity)

@item @strong{Return:}
standard basis of Tjurina-module of id,
@*of type module if id=ideal, resp. of type ideal if id=poly.
If a second argument is present (of any type) return a list: @*
[1] = Tjurina number,
@*[2] = k-basis of miniversal deformation,
@*[3] = SB of Tjurina module,
@*[4] = Tjurina module

@item @strong{Display:}
Tjurina number if printlevel >= 0 (default)

@item @strong{Note:}
Tjurina number = -1 implies that id is not an ICIS

@end table
@strong{Example:}
@smallexample
@c computed example Tjurina d2t_singular/sing_lib.doc:485 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 0,(x,y,z),ds;
poly f     = x5+y6+z7+xyz;        // singularity T[5,6,7]
list T     = Tjurina(f,"");
@expansion{} // Tjurina number = 16
show(T[1]);                       // Tjurina number, should be 16
@expansion{} // int, size 1
@expansion{} 16
show(T[2]);                       // basis of miniversal deformation
@expansion{} // ideal, 16 generator(s)
@expansion{} z6,
@expansion{} z5,
@expansion{} z4,
@expansion{} z3,
@expansion{} z2,
@expansion{} z,
@expansion{} y5,
@expansion{} y4,
@expansion{} y3,
@expansion{} y2,
@expansion{} y,
@expansion{} x4,
@expansion{} x3,
@expansion{} x2,
@expansion{} x,
@expansion{} 1
show(T[3]);                       // SB of Tjurina ideal
@expansion{} // ideal, 6 generator(s)
@expansion{} xy+7z6,
@expansion{} xz+6y5,
@expansion{} yz+5x4,
@expansion{} 5x5-6y6,
@expansion{} 6y6,
@expansion{} z7
show(T[4]); "";                   // Tjurina ideal
@expansion{} // ideal, 4 generator(s)
@expansion{} yz+5x4,
@expansion{} xz+6y5,
@expansion{} xy+7z6,
@expansion{} xyz+x5+y6+z7
@expansion{} 
ideal j    = x2+y2+z2,x2+2y2+3z2;
show(kbase(Tjurina(j)));          // basis of miniversal deformation
@expansion{} // Tjurina number = 5
@expansion{} // module, 5 generator(s)
@expansion{} [z]
@expansion{} [y]
@expansion{} [x]
@expansion{} [1]
@expansion{} [0,1]
hilb(Tjurina(j));                 // Hilbert series of Tjurina module
@expansion{} // Tjurina number = 5
@expansion{} //         2 t^0
@expansion{} //        -3 t^1
@expansion{} //        -3 t^2
@expansion{} //         7 t^3
@expansion{} //        -3 t^4
@expansion{} 
@expansion{} //         2 t^0
@expansion{} //         3 t^1
@expansion{} // dimension (local)   = 0
@expansion{} // multiplicity = 5
printlevel = p;
@c end example Tjurina d2t_singular/sing_lib.doc:485
@end smallexample
@c ---end content Tjurina---

@c ------------------- tjurina -------------
@node tjurina, T_1, Tjurina, sing_lib
@subsubsection tjurina
@cindex tjurina
@c ---content tjurina---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
tjurina(id); id=ideal or poly

@item @strong{Assume:}
id=ICIS (isolated complete intersection singularity)

@item @strong{Return:}
int = Tjurina number of id

@item @strong{Note:}
Tjurina number = -1 implies that id is not an ICIS

@end table
@strong{Example:}
@smallexample
@c computed example tjurina d2t_singular/sing_lib.doc:527 
LIB "sing.lib";
ring r=32003,(x,y,z),(c,ds);
ideal j=x2+y2+z2,x2+2y2+3z2;
tjurina(j);
@expansion{} 5
@c end example tjurina d2t_singular/sing_lib.doc:527
@end smallexample
@c ---end content tjurina---

@c ------------------- T_1 -------------
@node T_1, T_2, tjurina, sing_lib
@subsubsection T_1
@cindex T_1
@c ---content T_1---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
T_1(id[,<any>]); id = ideal or poly

@item @strong{Return:}
T_1(id): of type module/ideal if id is of type ideal/poly.
We call T_1(id) the T_1-module of id. It is a std basis of the
presentation of 1st order deformations of P/id, if P is the basering.
If a second argument is present (of any type) return a list of
3 modules:
@*[1]= T_1(id)
@*[2]= generators of normal bundle of id, lifted to P
@*[3]= module of relations of [2], lifted to P
@*(note: transpose[3]*[2]=0 mod id)
@*The list contains all non-easy objects which must be computed
to get T_1(id).

@item @strong{Display:}
k-dimension of T_1(id) if printlevel >= 0 (default)

@item @strong{Note:}
T_1(id) itself is usually of minor importance. Nevertheless, from it
all relevant information can be obtained. The most important are
probably vdim(T_1(id)); (which computes the Tjurina number),
hilb(T_1(id)); and kbase(T_1(id));
@*If T_1 is called with two argument, then matrix([2])*(kbase([1]))
represents a basis of 1st order semiuniversal deformation of id
(use proc 'deform', to get this in a direct way).
@*For a complete intersection the proc Tjurina is faster

@end table
@strong{Example:}
@smallexample
@c computed example T_1 d2t_singular/sing_lib.doc:576 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 32003,(x,y,z),(c,ds);
ideal i    = xy,xz,yz;
module T   = T_1(i);
@expansion{} // dim T_1 = 3
vdim(T);                      // Tjurina number = dim_K(T_1), should be 3
@expansion{} 3
list L=T_1(i,"");
@expansion{} // dim T_1 = 3
module kB  = kbase(L[1]);
print(L[2]*kB);               // basis of 1st order miniversal deformation
@expansion{} 0,0,0,
@expansion{} z,0,0,
@expansion{} 0,y,z 
show(L[2]);                   // presentation of normal bundle
@expansion{} // module, 6 generator(s)
@expansion{} [x]
@expansion{} [y,z]
@expansion{} [0,x,y]
@expansion{} [0,z]
@expansion{} [0,0,y]
@expansion{} [0,0,z]
print(L[3]);                  // relations of i
@expansion{} z, 0,
@expansion{} -y,y,
@expansion{} 0, -x
print(transpose(L[3])*L[2]);  // should be 0 (mod i)
@expansion{} xz,0, -xy,-yz,0,  0, 
@expansion{} 0, yz,0,  yz, -xy,-xz
printlevel = p;
@c end example T_1 d2t_singular/sing_lib.doc:576
@end smallexample
@c ---end content T_1---

@c ------------------- T_2 -------------
@node T_2, T_12, T_1, sing_lib
@subsubsection T_2
@cindex T_2
@c ---content T_2---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
T_2(id[,<any>]); id = ideal

@item @strong{Return:}
T_2(id): T_2-module of id . This is a std basis of a presentation of
the module of obstructions of R=P/id, if P is the basering.
If a second argument is present (of any type) return a list of
4 modules and 1 ideal:
@*[1]= T_2(id)
@*[2]= standard basis of id (ideal)
@*[3]= module of relations of id (=1st syzygy module of id) @*
[4]= presentation of syz/kos
@*[5]= relations of Hom_P([3]/kos,R), lifted to P
@*The list contains all non-easy objects which must be computed
to get T_2(id).

@item @strong{Display:}
k-dimension of T_2(id) if printlevel >= 0 (default)

@item @strong{Note:}
The most important information is probably vdim(T_2(id)).
Use proc miniversal to get equations of miniversal deformation.

@end table
@strong{Example:}
@smallexample
@c computed example T_2 d2t_singular/sing_lib.doc:629 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;
ring  r    = 32003,(x,y),(c,dp);
ideal j    = x6-y4,x6y6,x2y4-x5y2;
module T   = T_2(j);
@expansion{} // dim T_2 = 6
vdim(T);
@expansion{} 6
hilb(T);"";
@expansion{} //         1 t^0
@expansion{} //        -1 t^2
@expansion{} //        -1 t^3
@expansion{} //         1 t^5
@expansion{} 
@expansion{} //         1 t^0
@expansion{} //         2 t^1
@expansion{} //         2 t^2
@expansion{} //         1 t^3
@expansion{} // dimension (affine)  = 0
@expansion{} // degree      = 6
@expansion{} 
ring r1    = 0,(x,y,z),dp;
ideal id   = xy,xz,yz;
list L     = T_2(id,"");
@expansion{} // dim T_2 = 0
vdim(L[1]);                           // vdim of T_2
@expansion{} 0
print(L[3]);                          // syzygy module of id
@expansion{} -z,-z,
@expansion{} y, 0, 
@expansion{} 0, x  
printlevel = p;
@c end example T_2 d2t_singular/sing_lib.doc:629
@end smallexample
@c ---end content T_2---

@c ------------------- T_12 -------------
@node T_12, tangentcone, T_2, sing_lib
@subsubsection T_12
@cindex T_12
@c ---content T_12---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
T_12(i[,any]); i = ideal

@item @strong{Return:}
T_12(i): list of 2 modules: @*
* standard basis of T_1-module =T_1(i), 1st order deformations @*
* standard basis of T_2-module =T_2(i), obstructions of R=P/i @*
If a second argument is present (of any type) return a list of
9 modules, matrices, integers: @*
[1]= standard basis of T_1-module
@*[2]= standard basis of T_2-module
@*[3]= vdim of T_1
@*[4]= vdim of T_2
@*[5]= matrix, whose cols present infinitesimal deformations @*
[6]= matrix, whose cols are generators of relations of i(=syz(i)) @*
[7]= matrix, presenting Hom_P(syz/kos,R), lifted to P @*
[8]= presentation of T_1-module, no std basis
@*[9]= presentation of T_2-module, no std basis

@item @strong{Display:}
k-dimension of T_1 and T_2 if printlevel >= 0 (default)

@item @strong{Note:}
Use proc miniversal from deform.lib to get miniversal deformation of i,
the list contains all objects used by proc miniversal

@end table
@strong{Example:}
@smallexample
@c computed example T_12 d2t_singular/sing_lib.doc:685 
LIB "sing.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 200,(x,y,z,u,v),(c,ws(4,3,2,3,4));
ideal i    = xz-y2,yz2-xu,xv-yzu,yu-z3,z2u-yv,zv-u2;
//a cyclic quotient singularity
list L     = T_12(i,1);
@expansion{} // dim T_1 = 5
@expansion{} // dim T_2 = 3
print(L[5]);             //matrix of infin. deformations
@expansion{} 0,  0,  0,  0,  0,  
@expansion{} yz, y,  z2, 0,  0,  
@expansion{} -z3,-z2,-zu,yz, yu, 
@expansion{} -z2,-z, -u, 0,  0,  
@expansion{} zu, u,  v,  -z2,-zu,
@expansion{} 0,  0,  0,  u,  v   
printlevel = p;
@c end example T_12 d2t_singular/sing_lib.doc:685
@end smallexample
@c ---end content T_12---

@c ------------------- tangentcone -------------
@node tangentcone,, T_12, sing_lib
@subsubsection tangentcone
@cindex tangentcone
@c ---content tangentcone---
Procedure from library @code{sing.lib} (@pxref{sing_lib}).

@table @asis
@item @strong{Usage:}
tangentcone(id [,n]); id = ideal, n = int

@item @strong{Return:}
the tangent cone of id

@item @strong{Note:}
the procedure works for any monomial ordering.
@*If n=0 use std w.r.t. local ordering ds, if n=1 use locstd

@end table
@strong{Example:}
@smallexample
@c computed example tangentcone d2t_singular/sing_lib.doc:720 
LIB "sing.lib";
ring R = 0,(x,y,z),ds;
ideal i  = 7xyz+z5,x2+y3+z7,5z5+y5;
tangentcone(i);
@expansion{} _[1]=x2
@expansion{} _[2]=7xyz
@expansion{} _[3]=y5+5z5
@expansion{} _[4]=7y4z
@expansion{} _[5]=35z6
@c end example tangentcone d2t_singular/sing_lib.doc:720
@end smallexample
@c ---end content tangentcone---
@c ---------------------------------------------------------
@node spcurve_lib, spectrum_lib, sing_lib, Singularities
@subsection spcurve_lib
@c include of docu for spcurve.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/spcurve_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/spcurve_lib.doc INSTEAD
@c library version: (1.15.2.1,2002/02/20)
@c library file: ../Singular/LIB/spcurve.lib
@cindex spcurve.lib
@cindex spcurve_lib
@table @asis
@item @strong{Library:}
spcurve.lib
@item @strong{Purpose:}
    Deformations and Invariants of CM-codim 2 Singularities
@item @strong{Author:}
Anne Fruehbis-Krueger, anne@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* isCMcod2:: presentation matrix of the ideal i, if i is CM
* CMtype:: Cohen-Macaulay type of the ideal i
* matrixT1:: 1st order deformation T1 in matrix description
* semiCMcod2:: semiuniversal deformation of maximal minors of M
* discr:: discriminant of semiuniversal deformation
* qhmatrix:: weights if M is quasihomogeneous
* relweight:: relative matrix weight of N w.r.t. weights (W,a)
* posweight:: deformation of coker(M) of non-negative weight
* KSpencerKernel:: kernel of the Kodaira-Spencer map
@end menu
@c ---end content LibInfo---

@c ------------------- isCMcod2 -------------
@node isCMcod2, CMtype,, spcurve_lib
@subsubsection isCMcod2
@cindex isCMcod2
@c ---content isCMcod2---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
isCMcod2(i); i an ideal

@item @strong{Return:}
presentation matrix of i, if i is Cohen-Macaulay of codimension 2 @*
a zero matrix otherwise

@end table
@strong{Example:}
@smallexample
@c computed example isCMcod2 d2t_singular/spcurve_lib.doc:48 
LIB "spcurve.lib";
ring r=32003,(x,y,z),ds;
ideal i=xz,yz,x^3-y^4;
print(isCMcod2(i));
@expansion{} -y,-x2,
@expansion{} x, y3, 
@expansion{} 0, z   
@c end example isCMcod2 d2t_singular/spcurve_lib.doc:48
@end smallexample
@c ---end content isCMcod2---

@c ------------------- CMtype -------------
@node CMtype, matrixT1, isCMcod2, spcurve_lib
@subsubsection CMtype
@cindex CMtype
@c ---content CMtype---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
CMtype(i); i an ideal, CM of codimension 2

@item @strong{Return:}
Cohen-Macaulay type of i (integer)
@*(-1, if i is not Cohen-Macaulay of codimension 2)

@end table
@strong{Example:}
@smallexample
@c computed example CMtype d2t_singular/spcurve_lib.doc:75 
LIB "spcurve.lib";
ring r=32003,(x,y,z),ds;
ideal i=xy,xz,yz;
CMtype(i);
@expansion{} 2
@c end example CMtype d2t_singular/spcurve_lib.doc:75
@end smallexample
@c ---end content CMtype---

@c ------------------- matrixT1 -------------
@node matrixT1, semiCMcod2, CMtype, spcurve_lib
@subsubsection matrixT1
@cindex matrixT1
@c ---content matrixT1---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
matrixT1(M,n); M matrix, n integer

@item @strong{Assume:}
M is a presentation matrix of an ideal i, CM of codimension 2;
consider i as a family of ideals in a ring in the first n
variables where the remaining variables are considered as
parameters

@item @strong{Return:}
list consisting of the k x (k+1) matrix M and a module K_M such that
T1=Mat(k,k+1;R)/K_M is the space of first order deformations of i

@end table
@strong{Example:}
@smallexample
@c computed example matrixT1 d2t_singular/spcurve_lib.doc:108 
LIB "spcurve.lib";
ring r=32003,(x(1),x(2),x(3)),ds;
ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
matrix M=isCMcod2(curve);
matrixT1(M,3);
@expansion{} [1]:
@expansion{}    _[1,1]=0
@expansion{}    _[1,2]=-x(3)
@expansion{}    _[2,1]=-x(2)
@expansion{}    _[2,2]=x(2)
@expansion{}    _[3,1]=x(1)
@expansion{}    _[3,2]=0
@expansion{} [2]:
@expansion{}    _[1]=gen(5)
@expansion{}    _[2]=gen(4)-gen(3)
@expansion{}    _[3]=-gen(2)
@expansion{}    _[4]=x(1)*gen(5)-x(2)*gen(3)
@expansion{}    _[5]=x(1)*gen(6)-x(2)*gen(4)
@expansion{}    _[6]=x(2)*gen(3)-x(3)*gen(1)
@expansion{}    _[7]=x(2)*gen(4)-x(3)*gen(2)
@expansion{}    _[8]=-x(3)*gen(2)
@expansion{}    _[9]=x(2)*gen(2)-x(2)*gen(1)
@expansion{}    _[10]=x(1)*gen(1)
@expansion{}    _[11]=-x(3)*gen(4)
@expansion{}    _[12]=x(2)*gen(4)-x(2)*gen(3)
@expansion{}    _[13]=x(1)*gen(3)
@expansion{}    _[14]=-x(3)*gen(6)
@expansion{}    _[15]=x(2)*gen(6)-x(2)*gen(5)
@expansion{}    _[16]=x(1)*gen(5)
@c end example matrixT1 d2t_singular/spcurve_lib.doc:108
@end smallexample
@c ---end content matrixT1---

@c ------------------- semiCMcod2 -------------
@node semiCMcod2, discr, matrixT1, spcurve_lib
@subsubsection semiCMcod2
@cindex semiCMcod2
@c ---content semiCMcod2---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
semiCMcod2(M,t1); M matrix, t1 module

@item @strong{Assume:}
M is a presentation matrix of an ideal i, CM of codimension 2,
and t1 is a presentation of the space of first order deformations
of i ((M,t1) as returned by the procedure matrixT1)

@item @strong{Create:}
new basering with name rneu

@item @strong{Return:}
ideal in rneu describing the semiuniversal deformation of i

@item @strong{Note:}
The current basering should not contain any variables named
A(j) where j is some integer!

@end table
@strong{Example:}
@smallexample
@c computed example semiCMcod2 d2t_singular/spcurve_lib.doc:147 
LIB "spcurve.lib";
ring r=32003,(x(1),x(2),x(3)),ds;
ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
matrix M=isCMcod2(curve);
list l=matrixT1(M,3);
semiCMcod2(l[1],std(l[2]));
@expansion{} _[1]=A(2)*A(3)-x(2)*A(3)-x(1)*x(2)
@expansion{} _[2]=A(1)*A(3)+x(1)*x(3)
@expansion{} _[3]=-x(2)*A(1)-x(3)*A(2)+x(2)*x(3)
@c end example semiCMcod2 d2t_singular/spcurve_lib.doc:147
@end smallexample
@c ---end content semiCMcod2---

@c ------------------- discr -------------
@node discr, qhmatrix, semiCMcod2, spcurve_lib
@subsubsection discr
@cindex discr
@c ---content discr---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
discr(sem,n); sem ideal, n integer

@item @strong{Assume:}
sem is the versal deformation of an ideal of codimension 2. @*
the first n variables of the ring are treated as variables
all the others as parameters

@item @strong{Return:}
ideal describing the discriminant

@item @strong{Note:}
This is not a powerful algorithm!

@end table
@strong{Example:}
@smallexample
@c computed example discr d2t_singular/spcurve_lib.doc:183 
LIB "spcurve.lib";
ring r=32003,(x(1),x(2),x(3)),ds;
ideal curve=x(1)*x(2),x(1)*x(3),x(2)*x(3);
matrix M=isCMcod2(curve);
list l=matrixT1(M,3);
def sem=semiCMcod2(l[1],std(l[2]));
basering;
@expansion{} //   characteristic : 32003
@expansion{} //   number of vars : 6
@expansion{} //        block   1 : ordering ds
@expansion{} //                  : names    x(1) x(2) x(3) 
@expansion{} //        block   2 : ordering dp
@expansion{} //                  : names    A(1) A(2) A(3) 
@expansion{} //        block   3 : ordering C
discr(sem,3);
@expansion{} _[1]=A(1)*A(2)*A(3)
@c end example discr d2t_singular/spcurve_lib.doc:183
@end smallexample
@c ---end content discr---

@c ------------------- qhmatrix -------------
@node qhmatrix, relweight, discr, spcurve_lib
@subsubsection qhmatrix
@cindex qhmatrix
@c ---content qhmatrix---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
qhmatrix(M); M a k x (k+1) matrix

@item @strong{Return:}
list, consisting of an integer vector containing the weights of
the variables of the basering and an integer matrix giving the
weights of the entries of M, if M is quasihomogeneous;
zero integer vector and zero integer matrix, if M is not
quasihomogeneous, i.e. does not allow row and column weights

@end table
@strong{Example:}
@smallexample
@c computed example qhmatrix d2t_singular/spcurve_lib.doc:217 
LIB "spcurve.lib";
ring r=0,(x,y,z),ds;
matrix M[3][2]=z,0,y,x,x^3,y;
qhmatrix(M);
@expansion{} [1]:
@expansion{}    1,2,1
@expansion{} [2]:
@expansion{}    1,0,
@expansion{}    2,1,
@expansion{}    3,2 
pmat(M);
@expansion{} z,  0, 
@expansion{} y,  x, 
@expansion{} x3, y
@c end example qhmatrix d2t_singular/spcurve_lib.doc:217
@end smallexample
@c ---end content qhmatrix---

@c ------------------- relweight -------------
@node relweight, posweight, qhmatrix, spcurve_lib
@subsubsection relweight
@cindex relweight
@c ---content relweight---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Assume:}
N is a non-zero matrix
@*W is an integer matrix of the same size as N
@*a is an integer vector giving the weights of the variables

@item @strong{Return:}
integer, max(a-weighted order(N_ij) - W_ij | all entries ij) @*
string "ERROR" if sizes do not match

@end table
@strong{Example:}
@smallexample
@c computed example relweight d2t_singular/spcurve_lib.doc:247 
LIB "spcurve.lib";
ring r=32003,(x,y,z),ds;
matrix N[2][3]=z,0,y,x,x^3,y;
intmat W[2][3]=1,1,1,1,1,1;
intvec a=1,1,1;
relweight(N,W,a);
@expansion{} 2
@c end example relweight d2t_singular/spcurve_lib.doc:247
@end smallexample
@c ---end content relweight---

@c ------------------- posweight -------------
@node posweight, KSpencerKernel, relweight, spcurve_lib
@subsubsection posweight
@cindex posweight
@c ---content posweight---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
posweight(M,t1,n[,s]); M matrix, t1 module, n int, s string @*
n=0 : all deformations of non-negative weight @*
n=1 : only non-constant deformations of non-negative weight @*
n=2 : all deformations of positive weight @*
As an optional parameter the name of a new ring may be
specified.

@item @strong{Assume:}
M is a presentation matrix of a Cohen-Macaulay codimension 2
ideal and t1 is its T1 space in matrix notation

@item @strong{Create:}
new basering (default name: rneu); a different name for this ring
may be given as a 4th parameter

@item @strong{Return:}
list, consisting of a presentation matrix describing the deformation
given by the generators of T1 of non-negative/positive weight
and the weight vector for the new variables

@item @strong{Note:}
The current basering should not contain any variables named
T(i) where i is some integer!

@end table
@strong{Example:}
@smallexample
@c computed example posweight d2t_singular/spcurve_lib.doc:294 
LIB "spcurve.lib";
ring r=32003,(x(1),x(2),x(3)),ds;
ideal curve=(x(3)-x(1)^2)*x(3),(x(3)-x(1)^2)*x(2),x(2)^2-x(1)^7*x(3);
matrix M=isCMcod2(curve);
list l=matrixT1(M,3);
list li=posweight(l[1],std(l[2]),0);
pmat(li[1]);
@expansion{} T(2)+x(1)*T(1), -x(3)+x(1)^2, 
@expansion{} -x(3),          x(2),         
@expansion{} x(2),           -x(1)^7
li[2];
@expansion{} 3,1
@c end example posweight d2t_singular/spcurve_lib.doc:294
@end smallexample
@c ---end content posweight---

@c ------------------- KSpencerKernel -------------
@node KSpencerKernel,, posweight, spcurve_lib
@subsubsection KSpencerKernel
@cindex KSpencerKernel
@c ---content KSpencerKernel---
Procedure from library @code{spcurve.lib} (@pxref{spcurve_lib}).

@table @asis
@item @strong{Usage:}
KSpencerKernel(M[,s][,v]); M matrix, s string, v intvec @*
optional parameters (please specify in this order, if both are
present):
@** s = first of the names of the new rings
@*e.g. "R" leads to ring names R and R1
@** v of size n(n+1) leads to the following module ordering @*
gen(v[1]) > gen(v[2]) > ... > gen(v[n(n+1)]) where the matrix
entry ij corresponds to gen((i-1)*n+j)

@item @strong{Assume:}
M is a quasihomogeneous n x (n+1) matrix where the n minors define
an isolated space curve singularity

@item @strong{Create:}
2 new rings (default names: rneu and reneu)
@*different ring names may be specified as a 2nd parameter

@item @strong{Return:}
coefficient matrix representing the kernel of the Kodaira-
Spencer map of the family of non-negative deformations
having the given singularity as special fibre

@item @strong{Note:}
* the initial basering should not contain variables with name
e(i) or T(i), since those variable names will internally be
used by the script
@** setting an intvec with 5 entries and name watchProgress
shows the progress of the computations: @*
watchProgress[1]>0 => option(prot) in groebner commands @*
watchProgress[2]>0 => trace output for highcorner @*
watchProgress[3]>0 => output of deformed matrix @*
watchProgress[4]>0 => result of elimination step @*
watchProgress[4]>1 => trace output of multiplications with xyz
and subsequent reductions @*
watchProgress[5]>0 => matrix representing the kernel using print

@end table
@strong{Example:}
@smallexample
@c computed example KSpencerKernel d2t_singular/spcurve_lib.doc:355 
LIB "spcurve.lib";
ring r=0,(x,y,z),ds;
matrix M[3][2]=z-x^7,0,y^2,z,x^9,y;
def KS=KSpencerKernel(M,"ar");
print(KS);
@expansion{} T(7),   0,      0,      0,     0,     0,     0,     0,  
@expansion{} KS[2,1],6*T(3), 3*T(7), 0,     0,     0,     0,     0,  
@expansion{} KS[3,1],KS[3,2],KS[3,3],6*T(3),3*T(7),0,     0,     0,  
@expansion{} 10*T(4),8*T(1), 7*T(5), 5*T(2),4*T(6),2*T(8),2*T(3),T(7)
nameof(basering);
@expansion{} ar
basering;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 17
@expansion{} //        block   1 : ordering Ws
@expansion{} //                  : names    e(1) e(2) e(3) e(4) e(5) e(6) x y z 
@expansion{} //                  : weights  -21 -10 -32 -21 -27 -16 3 16 21 
@expansion{} //        block   2 : ordering wp
@expansion{} //                  : names    T(1) T(2) T(3) T(4) T(5) T(6) T(7) T(8) 
@expansion{} //                  : weights     8    5    2   10    7    4    1    2 
@expansion{} //        block   3 : ordering C
@c end example KSpencerKernel d2t_singular/spcurve_lib.doc:355
@end smallexample
@c ---end content KSpencerKernel---
@c ---------------------------------------------------------
@node spectrum_lib, , spcurve_lib, Singularities
@subsection spectrum_lib
@c include of docu for spectrum.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/spectrum_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/spectrum_lib.doc INSTEAD
@c library version: (1.12.2.3,2002/03/06)
@c library file: ../Singular/LIB/spectrum.lib
@cindex spectrum.lib
@cindex spectrum_lib
@table @asis
@item @strong{Library:}
spectrum.lib
@item @strong{Purpose:}
  Singularity Spectrum for Nondegenerate Singularities
@item @strong{Author:}
S. Endrass

@end table

@strong{Procedures:}
@menu
* spectrumnd:: spectrum of nondegenerate isolated singularity f
@end menu
@c ---end content LibInfo---

@c ------------------- spectrumnd -------------
@node spectrumnd,,, spectrum_lib
@subsubsection spectrumnd
@cindex spectrumnd
@c ---content spectrumnd---
Procedure from library @code{spectrum.lib} (@pxref{spectrum_lib}).

@table @asis
@item @strong{Usage:}
spectrumnd(f[,1]); poly f

@item @strong{Assume:}
basering has characteristic 0 and local ordering,
@*f has isolated singularity at 0 and nondegenerate principal part

@item @strong{Return:}
@format
list S:
  ideal S[1]: spectral numbers in increasing order
  intvec S[2]:
    int S[2][i]: multiplicity of spectral number S[1][i]
@end format

@item @strong{Note:}
if a second argument 1 is given,
@*no test for a degenerate principal part will be done
@*SEE_ALSO: gaussman_lib

@cindex singularities
@cindex Gauss-Manin connection
@cindex spectrum
@end table
@strong{Example:}
@smallexample
@c computed example spectrumnd d2t_singular/spectrum_lib.doc:56 
LIB "spectrum.lib";
ring R=0,(x,y),ds;
poly f=x^31+x^6*y^7+x^2*y^12+x^13*y^2+y^29;
spectrumnd(f);
@expansion{} [1]:
@expansion{}    _[1]=-67/79
@expansion{}    _[2]=-62/79
@expansion{}    _[3]=-45/58
@expansion{}    _[4]=-57/79
@expansion{}    _[5]=-41/58
@expansion{}    _[6]=-55/79
@expansion{}    _[7]=-52/79
@expansion{}    _[8]=-37/58
@expansion{}    _[9]=-50/79
@expansion{}    _[10]=-18/29
@expansion{}    _[11]=-47/79
@expansion{}    _[12]=-45/79
@expansion{}    _[13]=-33/58
@expansion{}    _[14]=-16/29
@expansion{}    _[15]=-43/79
@expansion{}    _[16]=-42/79
@expansion{}    _[17]=-40/79
@expansion{}    _[18]=-1/2
@expansion{}    _[19]=-15/31
@expansion{}    _[20]=-14/29
@expansion{}    _[21]=-38/79
@expansion{}    _[22]=-27/58
@expansion{}    _[23]=-14/31
@expansion{}    _[24]=-35/79
@expansion{}    _[25]=-25/58
@expansion{}    _[26]=-13/31
@expansion{}    _[27]=-33/79
@expansion{}    _[28]=-12/29
@expansion{}    _[29]=-23/58
@expansion{}    _[30]=-31/79
@expansion{}    _[31]=-12/31
@expansion{}    _[32]=-30/79
@expansion{}    _[33]=-21/58
@expansion{}    _[34]=-11/31
@expansion{}    _[35]=-28/79
@expansion{}    _[36]=-10/29
@expansion{}    _[37]=-26/79
@expansion{}    _[38]=-19/58
@expansion{}    _[39]=-10/31
@expansion{}    _[40]=-25/79
@expansion{}    _[41]=-9/29
@expansion{}    _[42]=-17/58
@expansion{}    _[43]=-23/79
@expansion{}    _[44]=-9/31
@expansion{}    _[45]=-8/29
@expansion{}    _[46]=-21/79
@expansion{}    _[47]=-15/58
@expansion{}    _[48]=-8/31
@expansion{}    _[49]=-20/79
@expansion{}    _[50]=-7/29
@expansion{}    _[51]=-19/79
@expansion{}    _[52]=-18/79
@expansion{}    _[53]=-7/31
@expansion{}    _[54]=-13/58
@expansion{}    _[55]=-6/29
@expansion{}    _[56]=-16/79
@expansion{}    _[57]=-6/31
@expansion{}    _[58]=-15/79
@expansion{}    _[59]=-11/58
@expansion{}    _[60]=-14/79
@expansion{}    _[61]=-5/29
@expansion{}    _[62]=-13/79
@expansion{}    _[63]=-5/31
@expansion{}    _[64]=-9/58
@expansion{}    _[65]=-11/79
@expansion{}    _[66]=-4/29
@expansion{}    _[67]=-4/31
@expansion{}    _[68]=-10/79
@expansion{}    _[69]=-7/58
@expansion{}    _[70]=-9/79
@expansion{}    _[71]=-3/29
@expansion{}    _[72]=-8/79
@expansion{}    _[73]=-3/31
@expansion{}    _[74]=-7/79
@expansion{}    _[75]=-5/58
@expansion{}    _[76]=-6/79
@expansion{}    _[77]=-2/29
@expansion{}    _[78]=-2/31
@expansion{}    _[79]=-5/79
@expansion{}    _[80]=-3/58
@expansion{}    _[81]=-4/79
@expansion{}    _[82]=-3/79
@expansion{}    _[83]=-1/29
@expansion{}    _[84]=-1/31
@expansion{}    _[85]=-2/79
@expansion{}    _[86]=-1/58
@expansion{}    _[87]=-1/79
@expansion{}    _[88]=0
@expansion{}    _[89]=1/79
@expansion{}    _[90]=1/58
@expansion{}    _[91]=2/79
@expansion{}    _[92]=1/31
@expansion{}    _[93]=1/29
@expansion{}    _[94]=3/79
@expansion{}    _[95]=4/79
@expansion{}    _[96]=3/58
@expansion{}    _[97]=5/79
@expansion{}    _[98]=2/31
@expansion{}    _[99]=2/29
@expansion{}    _[100]=6/79
@expansion{}    _[101]=5/58
@expansion{}    _[102]=7/79
@expansion{}    _[103]=3/31
@expansion{}    _[104]=8/79
@expansion{}    _[105]=3/29
@expansion{}    _[106]=9/79
@expansion{}    _[107]=7/58
@expansion{}    _[108]=10/79
@expansion{}    _[109]=4/31
@expansion{}    _[110]=4/29
@expansion{}    _[111]=11/79
@expansion{}    _[112]=9/58
@expansion{}    _[113]=5/31
@expansion{}    _[114]=13/79
@expansion{}    _[115]=5/29
@expansion{}    _[116]=14/79
@expansion{}    _[117]=11/58
@expansion{}    _[118]=15/79
@expansion{}    _[119]=6/31
@expansion{}    _[120]=16/79
@expansion{}    _[121]=6/29
@expansion{}    _[122]=13/58
@expansion{}    _[123]=7/31
@expansion{}    _[124]=18/79
@expansion{}    _[125]=19/79
@expansion{}    _[126]=7/29
@expansion{}    _[127]=20/79
@expansion{}    _[128]=8/31
@expansion{}    _[129]=15/58
@expansion{}    _[130]=21/79
@expansion{}    _[131]=8/29
@expansion{}    _[132]=9/31
@expansion{}    _[133]=23/79
@expansion{}    _[134]=17/58
@expansion{}    _[135]=9/29
@expansion{}    _[136]=25/79
@expansion{}    _[137]=10/31
@expansion{}    _[138]=19/58
@expansion{}    _[139]=26/79
@expansion{}    _[140]=10/29
@expansion{}    _[141]=28/79
@expansion{}    _[142]=11/31
@expansion{}    _[143]=21/58
@expansion{}    _[144]=30/79
@expansion{}    _[145]=12/31
@expansion{}    _[146]=31/79
@expansion{}    _[147]=23/58
@expansion{}    _[148]=12/29
@expansion{}    _[149]=33/79
@expansion{}    _[150]=13/31
@expansion{}    _[151]=25/58
@expansion{}    _[152]=35/79
@expansion{}    _[153]=14/31
@expansion{}    _[154]=27/58
@expansion{}    _[155]=38/79
@expansion{}    _[156]=14/29
@expansion{}    _[157]=15/31
@expansion{}    _[158]=1/2
@expansion{}    _[159]=40/79
@expansion{}    _[160]=42/79
@expansion{}    _[161]=43/79
@expansion{}    _[162]=16/29
@expansion{}    _[163]=33/58
@expansion{}    _[164]=45/79
@expansion{}    _[165]=47/79
@expansion{}    _[166]=18/29
@expansion{}    _[167]=50/79
@expansion{}    _[168]=37/58
@expansion{}    _[169]=52/79
@expansion{}    _[170]=55/79
@expansion{}    _[171]=41/58
@expansion{}    _[172]=57/79
@expansion{}    _[173]=45/58
@expansion{}    _[174]=62/79
@expansion{}    _[175]=67/79
@expansion{} [2]:
@expansion{}    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,\
   1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,2,1,1,1\
   ,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,4,1,2,1,1,1,1,1,2,1,1,1,1,2,1,1,1,1,1,2,1,\
   1,1,1,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1\
   ,1,2,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
@c end example spectrumnd d2t_singular/spectrum_lib.doc:56
@end smallexample
@c ---end content spectrumnd---
@c ----------------------------------------------------------------------------
@node Invariant theory, Symbolic-numerical solving, Singularities, SINGULAR libraries
@section Invariant theory
@cindex Invariant theory

@menu
* finvar_lib:: procedures to compute invariant rings of finite groups
* ainvar_lib:: procedures to compute invariants rings of the additive group
* rinvar_lib:: procedures to compute invariants ring of reductive groups
* stratify_lib:: algorithmic stratification by the Greuel-Pfister algorithm
@end menu

@c ----------------------------------------------------------
@node finvar_lib, ainvar_lib, Invariant theory, Invariant theory
@subsection finvar_lib
@c include of docu for finvar.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/finvar_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/finvar_lib.doc INSTEAD
@c library version: (1.32.2.2,2002/08/13)
@c library file: ../Singular/LIB/finvar.lib
@cindex finvar.lib
@cindex finvar_lib
@table @asis
@item @strong{Library:}
finvar.lib
@item @strong{Purpose:}
    Invariant Rings of Finite Groups
@item @strong{Author:}
Agnes E. Heydtmann, email: agnes@@math.uni-sb.de

@item @strong{Overview:}
A library for computing polynomial invariants of finite matrix groups and
generators of related varieties. The algorithms are based on B. Sturmfels,
G. Kemper and W. Decker et al..

@end table

@strong{Main procedures:}
@menu
* invariant_ring:: generators of the invariant ring (i.r.)
* invariant_ring_random:: generators of the i.r., randomized alg.
* primary_invariants:: primary invariants (p.i.)
* primary_invariants_random:: primary invariants, randomized alg.
@end menu
@strong{Auxiliary procedures:}
@menu
* cyclotomic:: cyclotomic polynomial
* group_reynolds:: finite group and Reynolds operator (R.o.)
* molien:: Molien series (M.s.)
* reynolds_molien:: Reynolds operator and Molien series
* partial_molien:: partial expansion of Molien series
* evaluate_reynolds:: image under the Reynolds operator
* invariant_basis:: basis of homogeneous invariants of a degree
* invariant_basis_reynolds:: as invariant_basis(), with R.o.
* primary_char0:: primary invariants in char 0
* primary_charp:: primary invariant in char p
* primary_char0_no_molien:: p.i., char 0, without Molien series
* primary_charp_no_molien:: p.i., char p, without Molien series
* primary_charp_without:: p.i., char p, without R.o. or Molien series
* primary_char0_random:: primary invariants in char 0, randomized
* primary_charp_random:: primary invariants in char p, randomized
* primary_char0_no_molien_random:: p.i., char 0, without M.s., randomized
* primary_charp_no_molien_random:: p.i., char p, without M.s., randomized
* primary_charp_without_random:: p.i., char p, without R.o. or M.s., random.
* power_products:: exponents for power products
* secondary_char0:: secondary (s.i.) invariants in char 0
* secondary_charp:: secondary invariants in char p
* secondary_no_molien:: secondary invariants, without Molien series
* secondary_and_irreducibles_no_molien:: s.i. & irreducible s.i., without M.s.
* secondary_not_cohen_macaulay:: s.i. when invariant ring not Cohen-Macaulay
* orbit_variety:: ideal of the orbit variety
* relative_orbit_variety:: ideal of a relative orbit variety
* image_of_variety:: ideal of the image of a variety
@end menu
@c ---end content LibInfo---

@c ------------------- invariant_ring -------------
@node invariant_ring, invariant_ring_random,, finvar_lib
@subsubsection invariant_ring
@cindex invariant_ring
@c ---content invariant_ring---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
invariant_ring(G1,G2,...[,flags]);
@*G1,G2,...: <matrices> generating a finite matrix group, flags: an
optional <intvec> with three entries: if the first one equals 0, the
program attempts to compute the Molien series and Reynolds operator,
if it equals 1, the program is told that the Molien series should not
be computed, if it equals -1 characteristic 0 is simulated, i.e. the
Molien series is computed as if the base field were characteristic 0
(the user must choose a field of large prime characteristic, e.g.
32003) and if the first one is anything else, it means that the
characteristic of the base field divides the group order (i.e. it will
not even be attempted to compute the Reynolds operator or Molien
series), the second component should give the size of intervals
between canceling common factors in the expansion of Molien series, 0
(the default) means only once after generating all terms, in prime
characteristic also a negative number can be given to indicate that
common factors should always be canceled when the expansion is simple
(the root of the extension field occurs not among the coefficients)

@item @strong{Return:}
primary and secondary invariants (both of type <matrix>) generating
the invariant ring with respect to the matrix group generated by the
matrices in the input and irreducible secondary invariants (type
<matrix>) if the Molien series was available

@item @strong{Display:}
information about the various stages of the program if the third flag
does not equal 0

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and those
are chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1998)). In the
@*non-modular case secondary invariants are calculated by finding a
basis (in terms of monomials) of the basering modulo the primary
invariants, mapping to invariants with the Reynolds operator and using
those or their power products such that they are linearly independent
modulo the primary invariants (see "Some Algorithms in Invariant
Theory of Finite Groups" by Kemper and Steel (1997)). In the modular
case they are generated according to "Generating Invariant Rings of
Finite Groups over Arbitrary Fields" by Kemper (1996).

@end table
@strong{Example:}
@smallexample
@c computed example invariant_ring d2t_singular/finvar_lib.doc:115 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix P,S,IS=invariant_ring(A);
print(P);
@expansion{} z2,x2+y2,x2y2
print(S);
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
print(IS);
@expansion{} xyz,x2z-y2z,x3y-xy3
@c end example invariant_ring d2t_singular/finvar_lib.doc:115
@end smallexample
@c ---end content invariant_ring---

@c ------------------- invariant_ring_random -------------
@node invariant_ring_random, primary_invariants, invariant_ring, finvar_lib
@subsubsection invariant_ring_random
@cindex invariant_ring_random
@c ---content invariant_ring_random---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
invariant_ring_random(G1,G2,...,r[,flags]);
@*G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
where -|r| to |r| is the range of coefficients of random
combinations of bases elements that serve as primary invariants,
flags: an optional <intvec> with three entries: if the first equals 0,
the program attempts to compute the Molien series and Reynolds
operator, if it equals 1, the program is told that the Molien series
should not be computed, if it equals -1 characteristic 0 is simulated,
i.e. the Molien series is computed as if the base field were
characteristic 0 (the user must choose a field of large prime
characteristic, e.g. 32003) and if the first one is anything else,
then the characteristic of the base field divides the group order
(i.e. we will not even attempt to compute the Reynolds operator or
Molien series), the second component should give the size of intervals
between canceling common factors in the expansion of the Molien
series, 0 (the default) means only once after generating all terms,
in prime characteristic also a negative number can be given to
indicate that common factors should always be canceled when the
expansion is simple (the root of the extension field does not occur
among the coefficients)

@item @strong{Return:}
primary and secondary invariants (both of type <matrix>) generating
invariant ring with respect to the matrix group generated by the
matrices in the input and irreducible secondary invariants (type
<matrix>) if the Molien series was available

@item @strong{Display:}
information about the various stages of the program if the third flag
does not equal 0

@item @strong{Theory:}
is the same as for invariant_ring except that random combinations of
basis elements are chosen as candidates for primary invariants and
hopefully they lower the dimension of the previously found primary
invariants by the right amount.

@end table
@strong{Example:}
@smallexample
@c computed example invariant_ring_random d2t_singular/finvar_lib.doc:176 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix P,S,IS=invariant_ring_random(A,1);
print(P);
@expansion{} z2,x2+y2,x4+y4-z4
print(S);
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
print(IS);
@expansion{} xyz,x2z-y2z,x3y-xy3
@c end example invariant_ring_random d2t_singular/finvar_lib.doc:176
@end smallexample
@c ---end content invariant_ring_random---

@c ------------------- primary_invariants -------------
@node primary_invariants, primary_invariants_random, invariant_ring_random, finvar_lib
@subsubsection primary_invariants
@cindex primary_invariants
@c ---content primary_invariants---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_invariants(G1,G2,...[,flags]);
@*G1,G2,...: <matrices> generating a finite matrix group, flags: an
optional <intvec> with three entries, if the first one equals 0 (also
the default), the program attempts to compute the Molien series and
Reynolds operator, if it equals 1, the program is told that the
Molien series should not be computed, if it equals -1 characteristic 0
is simulated, i.e. the Molien series is computed as if the base field
were characteristic 0 (the user must choose a field of large prime
characteristic, e.g. 32003) and if the first one is anything else, it
means that the characteristic of the base field divides the group
order, the second component should give the size of intervals between
canceling common factors in the expansion of the Molien series, 0 (the
default) means only once after generating all terms, in prime
characteristic also a negative number can be given to indicate that
common factors should always be canceled when the expansion is simple
(the root of the extension field occurs not among the coefficients)

@item @strong{Display:}
information about the various stages of the program if the third
flag does not equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring and if
computable Reynolds operator (type <matrix>) and Molien series (type
<matrix>) or ring name (type string) where the Molien series
can be found in the char p case; if the first flag is 1 and we are in
the non-modular case then an <intvec> is returned giving some of the
degrees where no non-trivial homogeneous invariants can be found

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and those
are chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_invariants d2t_singular/finvar_lib.doc:236 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=primary_invariants(A);
print(L[1]);
@expansion{} z2,x2+y2,x2y2
@c end example primary_invariants d2t_singular/finvar_lib.doc:236
@end smallexample
@c ---end content primary_invariants---

@c ------------------- primary_invariants_random -------------
@node primary_invariants_random, cyclotomic, primary_invariants, finvar_lib
@subsubsection primary_invariants_random
@cindex primary_invariants_random
@c ---content primary_invariants_random---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_invariants_random(G1,G2,...,r[,flags]);
@*G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
where -|r| to |r| is the range of coefficients of the random
combinations of bases elements, flags: an optional <intvec> with three
entries, if the first one equals 0 (also the default), the program
attempts to compute the Molien series and Reynolds operator, if it
equals 1, the program is told that the Molien series should not be
computed, if it equals -1 characteristic 0 is simulated, i.e. the
Molien series is computed as if the base field were characteristic 0
(the user must choose a field of large prime characteristic, e.g.
32003) and if the first one is anything else, it means that the
characteristic of the base field divides the group order, the second
component should give the size of intervals between canceling common
factors in the expansion of the Molien series, 0 (the default) means
only once after generating all terms, in prime characteristic also a
negative number can be given to indicate that common factors should
always be canceled when the expansion is simple (the root of the
extension field does not occur among the coefficients)

@item @strong{Display:}
information about the various stages of the program if the third
flag does not equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring and if
computable Reynolds operator (type <matrix>) and Molien series (type
<matrix>), if the first flag is 1 and we are in the non-modular case
then an <intvec> is returned giving some of the degrees where no
non-trivial homogeneous invariants can be found

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and random
linear combinations are chosen as primary invariants that lower the
dimension of the ideal generated by the previously found invariants
(see "Generating a Noetherian Normalization of the Invariant Ring of
a Finite Group" by Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_invariants_random d2t_singular/finvar_lib.doc:295 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=primary_invariants_random(A,1);
print(L[1]);
@expansion{} z2,x2+y2,x4+y4-z4
@c end example primary_invariants_random d2t_singular/finvar_lib.doc:295
@end smallexample
@c ---end content primary_invariants_random---

@c ------------------- cyclotomic -------------
@node cyclotomic, group_reynolds, primary_invariants_random, finvar_lib
@subsubsection cyclotomic
@cindex cyclotomic
@c ---content cyclotomic---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
cyclotomic(i); i integer > 0

@item @strong{Returns:}
the i-th cyclotomic polynomial (type <poly>) as one in the first ring
variable

@item @strong{Theory:}
x^i-1 is divided by the j-th cyclotomic polynomial where j takes on
the value of proper divisors of i

@end table
@strong{Example:}
@smallexample
@c computed example cyclotomic d2t_singular/finvar_lib.doc:327 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
print(cyclotomic(25));
@expansion{} x20+x15+x10+x5+1
@c end example cyclotomic d2t_singular/finvar_lib.doc:327
@end smallexample
@c ---end content cyclotomic---

@c ------------------- group_reynolds -------------
@node group_reynolds, molien, cyclotomic, finvar_lib
@subsubsection group_reynolds
@cindex group_reynolds
@c ---content group_reynolds---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
group_reynolds(G1,G2,...[,v]);
@*G1,G2,...: nxn <matrices> generating a finite matrix group, v: an
optional <int>

@item @strong{Assume:}
n is the number of variables of the basering, g the number of group
elements

@item @strong{Return:}
a <list>, the first list element will be a gxn <matrix> representing
the Reynolds operator if we are in the non-modular case; if the
characteristic is >0, minpoly==0 and the finite group non-cyclic the
second list element is an <int> giving the lowest common multiple of
the matrix group elements' order (used in molien); in general all
other list elements are nxn <matrices> listing all elements of the
finite group

@item @strong{Display:}
information if v does not equal 0

@item @strong{Theory:}
The entire matrix group is generated by getting all left products of
generators with the new elements from the last run through the loop
(or the generators themselves during the first run). All the ones that
have been generated before are thrown out and the program terminates
when no new elements found in one run. Additionally each time a new
group element is found the corresponding ring mapping of which the
Reynolds operator is made up is generated. They are stored in the rows
of the first return value.

@end table
@strong{Example:}
@smallexample
@c computed example group_reynolds d2t_singular/finvar_lib.doc:377 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
print(L[1]);
@expansion{} y, -x,-z,
@expansion{} -x,-y,z, 
@expansion{} -y,x, -z,
@expansion{} x, y, z  
print(L[2..size(L)]);
@expansion{} 0, 1,0,
@expansion{} -1,0,0,
@expansion{} 0, 0,-1
@expansion{} -1,0, 0,
@expansion{} 0, -1,0,
@expansion{} 0, 0, 1 
@expansion{} 0,-1,0,
@expansion{} 1,0, 0,
@expansion{} 0,0, -1
@expansion{} 1,0,0,
@expansion{} 0,1,0,
@expansion{} 0,0,1 
@c end example group_reynolds d2t_singular/finvar_lib.doc:377
@end smallexample
@c ---end content group_reynolds---

@c ------------------- molien -------------
@node molien, reynolds_molien, group_reynolds, finvar_lib
@subsubsection molien
@cindex molien
@c ---content molien---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
molien(G1,G2,...[,ringname,lcm,flags]);
@*G1,G2,...: nxn <matrices>, all elements of a finite matrix group,
ringname: a <string> giving a name for a new ring of characteristic 0
for the Molien series in case of prime characteristic, lcm: an <int>
giving the lowest common multiple of the elements' orders in case of
prime characteristic, minpoly==0 and a non-cyclic group, flags: an
optional <intvec> with three components: if the first element is not
equal to 0 characteristic 0 is simulated, i.e. the Molien series is
computed as if the base field were characteristic 0 (the user must
choose a field of large prime characteristic, e.g. 32003), the second
component should give the size of intervals between canceling common
factors in the expansion of the Molien series, 0 (the default) means
only once after generating all terms, in prime characteristic also a
negative number can be given to indicate that common factors should
always be canceled when the expansion is simple (the root of the
extension field does not occur among the coefficients)

@item @strong{Assume:}
n is the number of variables of the basering, G1,G2... are the group
elements generated by group_reynolds(), lcm is the second return value
of group_reynolds()

@item @strong{Return:}
in case of characteristic 0 a 1x2 <matrix> giving enumerator and
denominator of Molien series; in case of prime characteristic a ring
with the name `ringname` of characteristic 0 is created where the same
Molien series (named M) is stored

@item @strong{Display:}
information if the third component of flags does not equal 0

@item @strong{Theory:}
In characteristic 0 the terms 1/det(1-xE) for all group elements of
the Molien series are computed in a straight forward way. In prime
characteristic a Brauer lift is involved. The returned matrix gives
enumerator and denominator of the expanded version where common
factors have been canceled.

@end table
@strong{Example:}
@smallexample
@c computed example molien d2t_singular/finvar_lib.doc:438 
LIB "finvar.lib";
"         note the case of prime characteristic"; 
@expansion{}          note the case of prime characteristic
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
matrix M=molien(L[2..size(L)]);
print(M);
@expansion{} x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
ring S=3,(x,y,z),dp;
string newring="alksdfjlaskdjf";
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
molien(L[2..size(L)],newring);
setring alksdfjlaskdjf;
print(M);
@expansion{} x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
setring S;
kill alksdfjlaskdjf;
@c end example molien d2t_singular/finvar_lib.doc:438
@end smallexample
@c ---end content molien---

@c ------------------- reynolds_molien -------------
@node reynolds_molien, partial_molien, molien, finvar_lib
@subsubsection reynolds_molien
@cindex reynolds_molien
@c ---content reynolds_molien---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
reynolds_molien(G1,G2,...[,ringname,flags]);
@*G1,G2,...: nxn <matrices> generating a finite matrix group, ringname:
a <string> giving a name for a new ring of characteristic 0 for the
Molien series in case of prime characteristic, flags: an optional
<intvec> with three components: if the first element is not equal to 0
characteristic 0 is simulated, i.e. the Molien series is computed as
if the base field were characteristic 0 (the user must choose a field
of large prime characteristic, e.g. 32003) the second component should
give the size of intervals between canceling common factors in the
expansion of the Molien series, 0 (the default) means only once after
generating all terms, in prime characteristic also a negative number
can be given to indicate that common factors should always be canceled
when the expansion is simple (the root of the extension field does not
occur among the coefficients)

@item @strong{Assume:}
n is the number of variables of the basering, G1,G2... are the group
elements generated by group_reynolds(), g is the size of the group

@item @strong{Return:}
a gxn <matrix> representing the Reynolds operator is the first return
value and in case of characteristic 0 a 1x2 <matrix> giving enumerator
and denominator of Molien series is the second one; in case of prime
characteristic a ring with the name `ringname` of characteristic 0 is
created where the same Molien series (named M) is stored

@item @strong{Display:}
information if the third component of flags does not equal 0

@item @strong{Theory:}
The entire matrix group is generated by getting all left products of
the generators with new elements from the last run through the loop
(or the generators themselves during the first run). All the ones that
have been generated before are thrown out and the program terminates
when are no new elements found in one run. Additionally each time a
new group element is found the corresponding ring mapping of which the
Reynolds operator is made up is generated. They are stored in the rows
of the first return value. In characteristic 0 the terms 1/det(1-xE)
is computed whenever a new element E is found. In prime characteristic
a Brauer lift is involved and the terms are only computed after the
entire matrix group is generated (to avoid the modular case). The
returned matrix gives enumerator and denominator of the expanded
version where common factors have been canceled.

@end table
@strong{Example:}
@smallexample
@c computed example reynolds_molien d2t_singular/finvar_lib.doc:515 
LIB "finvar.lib";
"         note the case of prime characteristic"; 
@expansion{}          note the case of prime characteristic
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix REY,M=reynolds_molien(A);
print(REY);
@expansion{} y, -x,-z,
@expansion{} -x,-y,z, 
@expansion{} -y,x, -z,
@expansion{} x, y, z  
print(M);
@expansion{} x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
ring S=3,(x,y,z),dp;
string newring="Qadjoint";
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix REY=reynolds_molien(A,newring);
print(REY);
@expansion{} y, -x,-z,
@expansion{} -x,-y,z, 
@expansion{} -y,x, -z,
@expansion{} x, y, z  
setring Qadjoint;
print(M);
@expansion{} x3+x2-x+1,-x7+x6+x5-x4+x3-x2-x+1
setring S;
kill Qadjoint;
@c end example reynolds_molien d2t_singular/finvar_lib.doc:515
@end smallexample
@c ---end content reynolds_molien---

@c ------------------- partial_molien -------------
@node partial_molien, evaluate_reynolds, reynolds_molien, finvar_lib
@subsubsection partial_molien
@cindex partial_molien
@c ---content partial_molien---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
partial_molien(M,n[,p]);
@*M: a 1x2 <matrix>, n: an <int> indicating number of terms in the
expansion, p: an optional <poly>

@item @strong{Assume:}
M is the return value of molien or the second return value of
reynolds_molien, p ought to be the second return value of a previous
run of partial_molien and avoids recalculating known terms

@item @strong{Return:}
n terms (type <poly>) of the partial expansion of the Molien series
(first n if there is no third parameter given, otherwise the next n
terms depending on a previous calculation) and an intermediate result
(type <poly>) of the calculation to be used as third parameter in a
next run of partial_molien

@item @strong{Theory:}
The following calculation is implemented:
@format
(1+a1x+a2x^2+...+anx^n)/(1+b1x+b2x^2+...+bmx^m)=(1+(a1-b1)x+...
(1+b1x+b2x^2+...+bmx^m)
-----------------------
   (a1-b1)x+(a2-b2)x^2+...
   (a1-b1)x+b1(a1-b1)x^2+...
@end format

@end table
@strong{Example:}
@smallexample
@c computed example partial_molien d2t_singular/finvar_lib.doc:574 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix REY,M=reynolds_molien(A);
poly p(1..2);
p(1..2)=partial_molien(M,5);
p(1);
@expansion{} 4x5+5x4+2x3+2x2+1
p(1..2)=partial_molien(M,5,p(2));
p(1);
@expansion{} 18x10+12x9+13x8+8x7+8x6
@c end example partial_molien d2t_singular/finvar_lib.doc:574
@end smallexample
@c ---end content partial_molien---

@c ------------------- evaluate_reynolds -------------
@node evaluate_reynolds, invariant_basis, partial_molien, finvar_lib
@subsubsection evaluate_reynolds
@cindex evaluate_reynolds
@c ---content evaluate_reynolds---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
evaluate_reynolds(REY,I);
@*REY: a <matrix> representing the Reynolds operator, I: an arbitrary
<ideal>

@item @strong{Assume:}
REY is the first return value of group_reynolds() or reynolds_molien()

@item @strong{Returns:}
image of the polynomials defining I under the Reynolds operator
(type <ideal>)

@item @strong{Note:}
the characteristic of the coefficient field of the polynomial ring
should not divide the order of the finite matrix group

@item @strong{Theory:}
REY has been constructed in such a way that each row serves as a ring
mapping of which the Reynolds operator is made up.

@end table
@strong{Example:}
@smallexample
@c computed example evaluate_reynolds d2t_singular/finvar_lib.doc:619 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
ideal I=x2,y2,z2;
print(evaluate_reynolds(L[1],I));
@expansion{} 1/2x2+1/2y2,
@expansion{} 1/2x2+1/2y2,
@expansion{} z2
@c end example evaluate_reynolds d2t_singular/finvar_lib.doc:619
@end smallexample
@c ---end content evaluate_reynolds---

@c ------------------- invariant_basis -------------
@node invariant_basis, invariant_basis_reynolds, evaluate_reynolds, finvar_lib
@subsubsection invariant_basis
@cindex invariant_basis
@c ---content invariant_basis---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
invariant_basis(g,G1,G2,...);
@*g: an <int> indicating of which degree (>0) the homogeneous basis
should be, G1,G2,...: <matrices> generating a finite matrix group

@item @strong{Returns:}
the basis (type <ideal>) of the space of invariants of degree g

@item @strong{Theory:}
A general polynomial of degree g is generated and the generators of
the matrix group applied. The difference ought to be 0 and this way a
system of linear equations is created. It is solved by computing
syzygies.

@end table
@strong{Example:}
@smallexample
@c computed example invariant_basis d2t_singular/finvar_lib.doc:655 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
print(invariant_basis(2,A));
@expansion{} x2+y2,
@expansion{} z2
@c end example invariant_basis d2t_singular/finvar_lib.doc:655
@end smallexample
@c ---end content invariant_basis---

@c ------------------- invariant_basis_reynolds -------------
@node invariant_basis_reynolds, primary_char0, invariant_basis, finvar_lib
@subsubsection invariant_basis_reynolds
@cindex invariant_basis_reynolds
@c ---content invariant_basis_reynolds---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
invariant_basis_reynolds(REY,d[,flags]);
@*REY: a <matrix> representing the Reynolds operator, d: an <int>
indicating of which degree (>0) the homogeneous basis should be, flags:
an optional <intvec> with two entries: its first component gives the
dimension of the space (default <0 meaning unknown) and its second
component is used as the number of polynomials that should be mapped
to invariants during one call of evaluate_reynolds if the dimension of
the space is unknown or the number such that number x dimension
polynomials are mapped to invariants during one call of
evaluate_reynolds

@item @strong{Assume:}
REY is the first return value of group_reynolds() or reynolds_molien()
and flags[1] given by partial_molien

@item @strong{Return:}
the basis (type <ideal>) of the space of invariants of degree d

@item @strong{Theory:}
Monomials of degree d are mapped to invariants with the Reynolds
operator. A linearly independent set is generated with the help of
minbase.

@end table
@strong{Example:}
@smallexample
@c computed example invariant_basis_reynolds d2t_singular/finvar_lib.doc:699 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
intvec flags=0,1,0;
matrix REY,M=reynolds_molien(A,flags);
flags=8,6;
print(invariant_basis_reynolds(REY,6,flags));
@expansion{} z6,
@expansion{} x2z4+y2z4,
@expansion{} x2y2z2,
@expansion{} x3yz2-xy3z2,
@expansion{} x4z2+y4z2,
@expansion{} x4y2+x2y4,
@expansion{} x5y-xy5,
@expansion{} x6+y6
@c end example invariant_basis_reynolds d2t_singular/finvar_lib.doc:699
@end smallexample
@c ---end content invariant_basis_reynolds---

@c ------------------- primary_char0 -------------
@node primary_char0, primary_charp, invariant_basis_reynolds, finvar_lib
@subsubsection primary_char0
@cindex primary_char0
@c ---content primary_char0---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_char0(REY,M[,v]);
@*REY: a <matrix> representing the Reynolds operator, M: a 1x2 <matrix>
representing the Molien series, v: an optional <int>

@item @strong{Assume:}
REY is the first return value of group_reynolds or reynolds_molien and
M the one of molien or the second one of reynolds_molien

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and those
are chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_char0 d2t_singular/finvar_lib.doc:745 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix REY,M=reynolds_molien(A);
matrix P=primary_char0(REY,M);
print(P);
@expansion{} z2,x2+y2,x2y2
@c end example primary_char0 d2t_singular/finvar_lib.doc:745
@end smallexample
@c ---end content primary_char0---

@c ------------------- primary_charp -------------
@node primary_charp, primary_char0_no_molien, primary_char0, finvar_lib
@subsubsection primary_charp
@cindex primary_charp
@c ---content primary_charp---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_charp(REY,ringname[,v]);
@*REY: a <matrix> representing the Reynolds operator, ringname: a
<string> giving the name of a ring where the Molien series is stored,
v: an optional <int>

@item @strong{Assume:}
REY is the first return value of group_reynolds or reynolds_molien and
ringname gives the name of a ring of characteristic 0 that has been
created by molien or reynolds_molien

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and those
are chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_charp d2t_singular/finvar_lib.doc:792 
LIB "finvar.lib";
ring R=3,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
string newring="alskdfj";
molien(L[2..size(L)],newring);
matrix P=primary_charp(L[1],newring);
if(system("with","Namespaces")) @{ kill Top::`newring`; @}
kill `newring`;
print(P);
@expansion{} z2,x2+y2,x2y2
@c end example primary_charp d2t_singular/finvar_lib.doc:792
@end smallexample
@c ---end content primary_charp---

@c ------------------- primary_char0_no_molien -------------
@node primary_char0_no_molien, primary_charp_no_molien, primary_charp, finvar_lib
@subsubsection primary_char0_no_molien
@cindex primary_char0_no_molien
@c ---content primary_char0_no_molien---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_char0_no_molien(REY[,v]);
@*REY: a <matrix> representing the Reynolds operator, v: an optional
<int>

@item @strong{Assume:}
REY is the first return value of group_reynolds or reynolds_molien

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring and an
<intvec> listing some of the degrees where no non-trivial homogeneous
invariants are to be found

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and those
are chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_char0_no_molien d2t_singular/finvar_lib.doc:842 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
list l=primary_char0_no_molien(L[1]);
print(l[1]);
@expansion{} z2,x2+y2,x2y2
@c end example primary_char0_no_molien d2t_singular/finvar_lib.doc:842
@end smallexample
@c ---end content primary_char0_no_molien---

@c ------------------- primary_charp_no_molien -------------
@node primary_charp_no_molien, primary_charp_without, primary_char0_no_molien, finvar_lib
@subsubsection primary_charp_no_molien
@cindex primary_charp_no_molien
@c ---content primary_charp_no_molien---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_charp_no_molien(REY[,v]);
@*REY: a <matrix> representing the Reynolds operator, v: an optional
<int>

@item @strong{Assume:}
REY is the first return value of group_reynolds or reynolds_molien

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring and an
<intvec> listing some of the degrees where no non-trivial homogeneous
invariants are to be found

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and those
are chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_charp_no_molien d2t_singular/finvar_lib.doc:888 
LIB "finvar.lib";
ring R=3,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
list l=primary_charp_no_molien(L[1]);
print(l[1]);
@expansion{} z2,x2+y2,x2y2
@c end example primary_charp_no_molien d2t_singular/finvar_lib.doc:888
@end smallexample
@c ---end content primary_charp_no_molien---

@c ------------------- primary_charp_without -------------
@node primary_charp_without, primary_char0_random, primary_charp_no_molien, finvar_lib
@subsubsection primary_charp_without
@cindex primary_charp_without
@c ---content primary_charp_without---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_charp_without(G1,G2,...[,v]);
@*G1,G2,...: <matrices> generating a finite matrix group, v: an optional
<int>

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and those
are chosen as primary invariants that lower the dimension of the ideal
generated by the previously found invariants (see paper "Generating a
Noetherian Normalization of the Invariant Ring of a Finite Group" by
Decker, Heydtmann, Schreyer (1998)). No Reynolds
@*operator or Molien series is used.

@end table
@strong{Example:}
@smallexample
@c computed example primary_charp_without d2t_singular/finvar_lib.doc:930 
LIB "finvar.lib";
ring R=2,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix P=primary_charp_without(A);
print(P);
@expansion{} x+y,z,xy
@c end example primary_charp_without d2t_singular/finvar_lib.doc:930
@end smallexample
@c ---end content primary_charp_without---

@c ------------------- primary_char0_random -------------
@node primary_char0_random, primary_charp_random, primary_charp_without, finvar_lib
@subsubsection primary_char0_random
@cindex primary_char0_random
@c ---content primary_char0_random---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_char0_random(REY,M,r[,v]);
@*REY: a <matrix> representing the Reynolds operator, M: a 1x2 <matrix>
representing the Molien series, r: an <int> where -|r| to |r| is the
range of coefficients of the random combinations of bases elements,
v: an optional <int>

@item @strong{Assume:}
REY is the first return value of group_reynolds or reynolds_molien and
M the one of molien or the second one of reynolds_molien

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and random
linear combinations are chosen as primary invariants that lower the
dimension of the ideal generated by the previously found invariants
(see "Generating a Noetherian Normalization of the Invariant Ring of
a Finite Group" by Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_char0_random d2t_singular/finvar_lib.doc:976 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix REY,M=reynolds_molien(A);
matrix P=primary_char0_random(REY,M,1);
print(P);
@expansion{} z2,x2+y2,x4+y4-z4
@c end example primary_char0_random d2t_singular/finvar_lib.doc:976
@end smallexample
@c ---end content primary_char0_random---

@c ------------------- primary_charp_random -------------
@node primary_charp_random, primary_char0_no_molien_random, primary_char0_random, finvar_lib
@subsubsection primary_charp_random
@cindex primary_charp_random
@c ---content primary_charp_random---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_charp_random(REY,ringname,r[,v]);
@*REY: a <matrix> representing the Reynolds operator, ringname: a
<string> giving the name of a ring where the Molien series is stored,
r: an <int> where -|r| to |r| is the range of coefficients of the
random combinations of bases elements, v: an optional <int>

@item @strong{Assume:}
REY is the first return value of group_reynolds or reynolds_molien and
ringname gives the name of a ring of characteristic 0 that has been
created by molien or reynolds_molien

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and random
linear combinations are chosen as primary invariants that lower the
dimension of the ideal generated by the previously found invariants
(see "Generating a Noetherian Normalization of the Invariant Ring of
a Finite Group" by Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_charp_random d2t_singular/finvar_lib.doc:1024 
LIB "finvar.lib";
ring R=3,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
string newring="alskdfj";
molien(L[2..size(L)],newring);
matrix P=primary_charp_random(L[1],newring,1);
if(system("with","Namespaces")) @{ kill Top::`newring`; @}
kill `newring`;
print(P);
@expansion{} z2,x2+y2,x4+y4-z4
@c end example primary_charp_random d2t_singular/finvar_lib.doc:1024
@end smallexample
@c ---end content primary_charp_random---

@c ------------------- primary_char0_no_molien_random -------------
@node primary_char0_no_molien_random, primary_charp_no_molien_random, primary_charp_random, finvar_lib
@subsubsection primary_char0_no_molien_random
@cindex primary_char0_no_molien_random
@c ---content primary_char0_no_molien_random---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_char0_no_molien_random(REY,r[,v]);
@*REY: a <matrix> representing the Reynolds operator, r: an <int> where
-|r| to |r| is the range of coefficients of the random combinations of
bases elements, v: an optional <int>

@item @strong{Assume:}
REY is the first return value of group_reynolds or reynolds_molien

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring and an
<intvec> listing some of the degrees where no non-trivial homogeneous
invariants are to be found

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and random
linear combinations are chosen as primary invariants that lower the
dimension of the ideal generated by the previously found invariants
(see "Generating a Noetherian Normalization of the Invariant Ring of
a Finite Group" by Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_char0_no_molien_random d2t_singular/finvar_lib.doc:1075 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
list l=primary_char0_no_molien_random(L[1],1);
print(l[1]);
@expansion{} z2,x2+y2,x4+y4-z4
@c end example primary_char0_no_molien_random d2t_singular/finvar_lib.doc:1075
@end smallexample
@c ---end content primary_char0_no_molien_random---

@c ------------------- primary_charp_no_molien_random -------------
@node primary_charp_no_molien_random, primary_charp_without_random, primary_char0_no_molien_random, finvar_lib
@subsubsection primary_charp_no_molien_random
@cindex primary_charp_no_molien_random
@c ---content primary_charp_no_molien_random---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_charp_no_molien_random(REY,r[,v]);
@*REY: a <matrix> representing the Reynolds operator, r: an <int> where
-|r| to |r| is the range of coefficients of the random combinations of
bases elements, v: an optional <int>

@item @strong{Assume:}
REY is the first return value of group_reynolds or reynolds_molien

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring and an
<intvec> listing some of the degrees where no non-trivial homogeneous
invariants are to be found

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and random
linear combinations are chosen as primary invariants that lower the
dimension of the ideal generated by the previously found invariants
(see "Generating a Noetherian Normalization of the Invariant Ring of
a Finite Group" by Decker, Heydtmann, Schreyer (1998)).

@end table
@strong{Example:}
@smallexample
@c computed example primary_charp_no_molien_random d2t_singular/finvar_lib.doc:1122 
LIB "finvar.lib";
ring R=3,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=group_reynolds(A);
list l=primary_charp_no_molien_random(L[1],1);
print(l[1]);
@expansion{} z2,x2+y2,x4+y4-z4
@c end example primary_charp_no_molien_random d2t_singular/finvar_lib.doc:1122
@end smallexample
@c ---end content primary_charp_no_molien_random---

@c ------------------- primary_charp_without_random -------------
@node primary_charp_without_random, power_products, primary_charp_no_molien_random, finvar_lib
@subsubsection primary_charp_without_random
@cindex primary_charp_without_random
@c ---content primary_charp_without_random---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
primary_charp_without_random(G1,G2,...,r[,v]);
@*G1,G2,...: <matrices> generating a finite matrix group, r: an <int>
where -|r| to |r| is the range of coefficients of the random
combinations of bases elements, v: an optional <int>

@item @strong{Display:}
information about the various stages of the program if v does not
equal 0

@item @strong{Return:}
primary invariants (type <matrix>) of the invariant ring

@item @strong{Theory:}
Bases of homogeneous invariants are generated successively and random
linear combinations are chosen as primary invariants that lower the
dimension of the ideal generated by the previously found invariants
(see "Generating a Noetherian Normalization of the Invariant Ring of
a Finite Group" by Decker, Heydtmann, Schreyer (1998)). No Reynolds
operator or Molien series is used.

@end table
@strong{Example:}
@smallexample
@c computed example primary_charp_without_random d2t_singular/finvar_lib.doc:1165 
LIB "finvar.lib";
ring R=2,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
matrix P=primary_charp_without_random(A,1);
print(P);
@expansion{} x+y,z,xy
@c end example primary_charp_without_random d2t_singular/finvar_lib.doc:1165
@end smallexample
@c ---end content primary_charp_without_random---

@c ------------------- power_products -------------
@node power_products, secondary_char0, primary_charp_without_random, finvar_lib
@subsubsection power_products
@cindex power_products
@c ---content power_products---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
power_products(dv,d);
@*dv: an <intvec> giving the degrees of homogeneous polynomials, d: the
degree of the desired power products

@item @strong{Return:}
a size(dv)*m <intmat> where each column ought to be interpreted as
containing the exponents of the corresponding polynomials. The product
of the powers is then homogeneous of degree d.

@end table
@strong{Example:}
@smallexample
@c computed example power_products d2t_singular/finvar_lib.doc:1196 
LIB "finvar.lib";
intvec dv=5,5,5,10,10;
print(power_products(dv,10));
@expansion{}      2     1     1     0     0     0     0     0
@expansion{}      0     1     0     2     1     0     0     0
@expansion{}      0     0     1     0     1     2     0     0
@expansion{}      0     0     0     0     0     0     1     0
@expansion{}      0     0     0     0     0     0     0     1
print(power_products(dv,7));
@expansion{}      0
@expansion{}      0
@expansion{}      0
@expansion{}      0
@expansion{}      0
@c end example power_products d2t_singular/finvar_lib.doc:1196
@end smallexample
@c ---end content power_products---

@c ------------------- secondary_char0 -------------
@node secondary_char0, secondary_charp, power_products, finvar_lib
@subsubsection secondary_char0
@cindex secondary_char0
@c ---content secondary_char0---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
secondary_char0(P,REY,M[,v]);
@*P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
representing the Reynolds operator, M: a 1x2 <matrix> giving numerator
and denominator of the Molien series, v: an optional <int>

@item @strong{Assume:}
n is the number of variables of the basering, g the size of the group,
REY is the 1st return value of group_reynolds(), reynolds_molien() or
the second one of primary_invariants(), M the return value of molien()
or the second one of reynolds_molien() or the third one of
primary_invariants()

@item @strong{Return:}
secondary invariants of the invariant ring (type <matrix>) and
irreducible secondary invariants (type <matrix>)

@item @strong{Display:}
information if v does not equal 0

@item @strong{Theory:}
The secondary invariants are calculated by finding a basis (in terms
of monomials) of the basering modulo the primary invariants, mapping
those to invariants with the Reynolds operator and using these images
or their power products such that they are linearly independent modulo
the primary invariants (see paper "Some Algorithms in Invariant
Theory of Finite Groups" by Kemper and Steel (1997)).

@end table
@strong{Example:}
@smallexample
@c computed example secondary_char0 d2t_singular/finvar_lib.doc:1244 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=primary_invariants(A);
matrix S,IS=secondary_char0(L[1..3]);
print(S);
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
print(IS);
@expansion{} xyz,x2z-y2z,x3y-xy3
@c end example secondary_char0 d2t_singular/finvar_lib.doc:1244
@end smallexample
@c ---end content secondary_char0---

@c ------------------- secondary_charp -------------
@node secondary_charp, secondary_no_molien, secondary_char0, finvar_lib
@subsubsection secondary_charp
@cindex secondary_charp
@c ---content secondary_charp---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
secondary_charp(P,REY,ringname[,v]);
@*P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
representing the Reynolds operator, ringname: a <string> giving the
name of a ring of characteristic 0 where the Molien series is stored,
v: an optional <int>

@item @strong{Assume:}
n is the number of variables of the basering, g the size of the group,
REY is the 1st return value of group_reynolds(), reynolds_molien() or
the second one of primary_invariants(), `ringname` is a ring of
char 0 that has been created by molien() or reynolds_molien() or
primary_invariants()

@item @strong{Return:}
secondary invariants of the invariant ring (type <matrix>) and
irreducible secondary invariants (type <matrix>)

@item @strong{Display:}
information if v does not equal 0

@item @strong{Theory:}
Secondary invariants are calculated by finding a basis (in terms of
monomials) of the basering modulo primary invariants, mapping those
to invariants with the Reynolds operator and using these images or
their power products such that they are linearly independent modulo
the primary invariants (see paper "Some Algorithms in Invariant
Theory of Finite Groups" by Kemper and Steel (1997)).

@end table
@strong{Example:}
@smallexample
@c computed example secondary_charp d2t_singular/finvar_lib.doc:1296 
LIB "finvar.lib";
ring R=3,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=primary_invariants(A);
matrix S,IS=secondary_charp(L[1..size(L)]);
print(S);
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
print(IS);
@expansion{} xyz,x2z-y2z,x3y-xy3
@c end example secondary_charp d2t_singular/finvar_lib.doc:1296
@end smallexample
@c ---end content secondary_charp---

@c ------------------- secondary_no_molien -------------
@node secondary_no_molien, secondary_and_irreducibles_no_molien, secondary_charp, finvar_lib
@subsubsection secondary_no_molien
@cindex secondary_no_molien
@c ---content secondary_no_molien---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
secondary_no_molien(P,REY[,deg_vec,v]);
@*P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
representing the Reynolds operator, deg_vec: an optional <intvec>
listing some degrees where no non-trivial homogeneous invariants can
be found, v: an optional <int>

@item @strong{Assume:}
n is the number of variables of the basering, g the size of the group,
REY is the 1st return value of group_reynolds(), reynolds_molien() or
the second one of primary_invariants(), deg_vec is the second return
value of primary_char0_no_molien(), primary_charp_no_molien(),
primary_char0_no_molien_random() or primary_charp_no_molien_random()

@item @strong{Return:}
secondary invariants of the invariant ring (type <matrix>)

@item @strong{Display:}
information if v does not equal 0

@item @strong{Theory:}
Secondary invariants are calculated by finding a basis (in terms of
monomials) of the basering modulo primary invariants, mapping those to
invariants with the Reynolds operator and using these images as
candidates for secondary invariants.

@end table
@strong{Example:}
@smallexample
@c computed example secondary_no_molien d2t_singular/finvar_lib.doc:1345 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=primary_invariants(A,intvec(1,1,0));
matrix S=secondary_no_molien(L[1..3]);
print(S);
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
@c end example secondary_no_molien d2t_singular/finvar_lib.doc:1345
@end smallexample
@c ---end content secondary_no_molien---

@c ------------------- secondary_and_irreducibles_no_molien -------------
@node secondary_and_irreducibles_no_molien, secondary_not_cohen_macaulay, secondary_no_molien, finvar_lib
@subsubsection secondary_and_irreducibles_no_molien
@cindex secondary_and_irreducibles_no_molien
@c ---content secondary_and_irreducibles_no_molien---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
secondary_and_irreducibles_no_molien(P,REY[,v]);
@*P: a 1xn <matrix> with primary invariants, REY: a gxn <matrix>
representing the Reynolds operator, v: an optional <int>

@item @strong{Assume:}
n is the number of variables of the basering, g the size of the group,
REY is the 1st return value of group_reynolds(), reynolds_molien() or
the second one of primary_invariants()

@item @strong{Return:}
secondary invariants of the invariant ring (type <matrix>) and
irreducible secondary invariants (type <matrix>)

@item @strong{Display:}
information if v does not equal 0

@item @strong{Theory:}
Secondary invariants are calculated by finding a basis (in terms of
monomials) of the basering modulo primary invariants, mapping those to
invariants with the Reynolds operator and using these images or their
power products such that they are linearly independent modulo the
primary invariants (see paper "Some Algorithms in Invariant Theory of
Finite Groups" by Kemper and Steel (1997)).

@end table
@strong{Example:}
@smallexample
@c computed example secondary_and_irreducibles_no_molien d2t_singular/finvar_lib.doc:1392 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=primary_invariants(A,intvec(1,1,0));
matrix S,IS=secondary_and_irreducibles_no_molien(L[1..2]);
print(S);
@expansion{} 1,xyz,x2z-y2z,x3y-xy3
print(IS);
@expansion{} xyz,x2z-y2z,x3y-xy3
@c end example secondary_and_irreducibles_no_molien d2t_singular/finvar_lib.doc:1392
@end smallexample
@c ---end content secondary_and_irreducibles_no_molien---

@c ------------------- secondary_not_cohen_macaulay -------------
@node secondary_not_cohen_macaulay, orbit_variety, secondary_and_irreducibles_no_molien, finvar_lib
@subsubsection secondary_not_cohen_macaulay
@cindex secondary_not_cohen_macaulay
@c ---content secondary_not_cohen_macaulay---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
secondary_not_cohen_macaulay(P,G1,G2,...[,v]);
@*P: a 1xn <matrix> with primary invariants, G1,G2,...: nxn <matrices>
generating a finite matrix group, v: an optional <int>

@item @strong{Assume:}
n is the number of variables of the basering

@item @strong{Return:}
secondary invariants of the invariant ring (type <matrix>)

@item @strong{Display:}
information if v does not equal 0

@item @strong{Theory:}
Secondary invariants are generated following "Generating Invariant
Rings of Finite Groups over Arbitrary Fields" by Kemper (1996).

@end table
@strong{Example:}
@smallexample
@c computed example secondary_not_cohen_macaulay d2t_singular/finvar_lib.doc:1433 
LIB "finvar.lib";
ring R=2,(x,y,z),dp;
matrix A[3][3]=0,1,0,-1,0,0,0,0,-1;
list L=primary_invariants(A);
matrix S=secondary_not_cohen_macaulay(L[1],A);
print(S);
@expansion{} 1
@c end example secondary_not_cohen_macaulay d2t_singular/finvar_lib.doc:1433
@end smallexample
@c ---end content secondary_not_cohen_macaulay---

@c ------------------- orbit_variety -------------
@node orbit_variety, relative_orbit_variety, secondary_not_cohen_macaulay, finvar_lib
@subsubsection orbit_variety
@cindex orbit_variety
@c ---content orbit_variety---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
orbit_variety(F,s);
@*F: a 1xm <matrix> defining an invariant ring, s: a <string> giving the
name for a new ring

@item @strong{Return:}
a Groebner basis (type <ideal>, named G) for the ideal defining the
orbit variety (i.e. the syzygy ideal) in the new ring (named `s`)

@item @strong{Theory:}
The ideal of algebraic relations of the invariant ring generators is
calculated, then the variables of the original ring are eliminated and
the polynomials that are left over define the orbit variety

@end table
@strong{Example:}
@smallexample
@c computed example orbit_variety d2t_singular/finvar_lib.doc:1469 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix F[1][7]=x2+y2,z2,x4+y4,1,x2z-1y2z,xyz,x3y-1xy3;
string newring="E";
orbit_variety(F,newring);
print(G);
@expansion{} y(4)-1,
@expansion{} y(5)*y(6)-y(2)*y(7),
@expansion{} y(2)*y(3)-y(5)^2-2*y(6)^2,
@expansion{} y(1)^2*y(6)-2*y(3)*y(6)+y(5)*y(7),
@expansion{} y(1)^2*y(5)-y(3)*y(5)-2*y(6)*y(7),
@expansion{} y(1)^2*y(2)-y(2)*y(3)-2*y(6)^2,
@expansion{} y(1)^4-3*y(1)^2*y(3)+2*y(3)^2+2*y(7)^2
basering;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 7
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    y(1) y(2) y(3) y(4) y(5) y(6) y(7) 
@expansion{} //        block   2 : ordering C
@c end example orbit_variety d2t_singular/finvar_lib.doc:1469
@end smallexample
@c ---end content orbit_variety---

@c ------------------- relative_orbit_variety -------------
@node relative_orbit_variety, image_of_variety, orbit_variety, finvar_lib
@subsubsection relative_orbit_variety
@cindex relative_orbit_variety
@c ---content relative_orbit_variety---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
relative_orbit_variety(I,F,s);
@*I: an <ideal> invariant under the action of a group, F: a 1xm
<matrix> defining the invariant ring of this group, s: a <string>
giving a name for a new ring

@item @strong{Return:}
a Groebner basis (type <ideal>, named G) for the ideal defining the
relative orbit variety with respect to I in the new ring (named s)

@item @strong{Theory:}
A Groebner basis of the ideal of algebraic relations of the invariant
ring generators is calculated, then one of the basis elements plus the
ideal generators. The variables of the original ring are eliminated
and the polynomials that are left define the relative orbit variety
with respect to I.

@end table
@strong{Example:}
@smallexample
@c computed example relative_orbit_variety d2t_singular/finvar_lib.doc:1509 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix F[1][3]=x+y+z,xy+xz+yz,xyz;
ideal I=x2+y2+z2-1,x2y+y2z+z2x-2x-2y-2z,xy2+yz2+zx2-2x-2y-2z;
string newring="E";
relative_orbit_variety(I,F,newring);
print(G);
@expansion{} 27*y(3)^6-513*y(3)^4+33849*y(3)^2-784,
@expansion{} 1475*y(2)+9*y(3)^4-264*y(3)^2+736,
@expansion{} 8260*y(1)+9*y(3)^5-87*y(3)^3+5515*y(3)
basering;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering lp
@expansion{} //                  : names    y(1) y(2) y(3) 
@expansion{} //        block   2 : ordering C
@c end example relative_orbit_variety d2t_singular/finvar_lib.doc:1509
@end smallexample
@c ---end content relative_orbit_variety---

@c ------------------- image_of_variety -------------
@node image_of_variety,, relative_orbit_variety, finvar_lib
@subsubsection image_of_variety
@cindex image_of_variety
@c ---content image_of_variety---
Procedure from library @code{finvar.lib} (@pxref{finvar_lib}).

@table @asis
@item @strong{Usage:}
image_of_variety(I,F);
@*I: an arbitrary <ideal>, F: a 1xm <matrix> defining an invariant ring
of a some matrix group

@item @strong{Return:}
the <ideal> defining the image under that group of the variety defined
by I

@item @strong{Theory:}
relative_orbit_variety(I,F,s) is called and the newly introduced
variables in the output are replaced by the generators of the
invariant ring. This ideal in the original variables defines the image
of the variety defined by I

@end table
@strong{Example:}
@smallexample
@c computed example image_of_variety d2t_singular/finvar_lib.doc:1548 
LIB "finvar.lib";
ring R=0,(x,y,z),dp;
matrix F[1][3]=x+y+z,xy+xz+yz,xyz;
ideal I=xy;
print(image_of_variety(I,F));
@expansion{} xyz
@c end example image_of_variety d2t_singular/finvar_lib.doc:1548
@end smallexample
@c ---end content image_of_variety---
@c ----------------------------------------------------------
@node ainvar_lib, rinvar_lib, finvar_lib, Invariant theory
@subsection ainvar_lib
@c include of docu for ainvar.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/ainvar_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/ainvar_lib.doc INSTEAD
@c library version: (1.6.2.2,2002/04/12)
@c library file: ../Singular/LIB/ainvar.lib
@cindex ainvar.lib
@cindex ainvar_lib
@table @asis
@item @strong{Library:}
ainvar.lib
@item @strong{Purpose:}
    Invariant Rings of the Additive Group
@item @strong{Authors:}
Gerhard Pfister (email: pfister@@mathematik.uni-kl.de),
Gert-Martin Greuel (email: greuel@@mathematik.uni-kl.de)

@end table

@strong{Procedures:}
@menu
* invariantRing:: compute ring of invariants of (K,+)-action given by m
* derivate:: derivation of f with respect to the vector field m
* actionIsProper:: tests whether action defined by m is proper
* reduction:: SAGBI reduction of p in the subring generated by I
* completeReduction:: complete SAGBI reduction
* localInvar:: invariant polynomial under m computed from p,...
* furtherInvar:: compute further invariants of m from the given ones
* sortier:: sorts generators of id by increasing leading terms
@end menu
@c ---end content LibInfo---

@c ------------------- invariantRing -------------
@node invariantRing, derivate,, ainvar_lib
@subsubsection invariantRing
@cindex invariantRing
@c ---content invariantRing---
Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).

@table @asis
@item @strong{Usage:}
invariantRing(m,p,q,b[,r,pa]); m matrix, p,q poly, b,r int, pa string

@item @strong{Assume:}
p,q variables with m(p)=q and q invariant under m
@*i.e. if p=x(i) and q=x(j) then m[j,1]=0 and m[i,1]=x(j)

@item @strong{Return:}
ideal, containing generators of the ring of invariants of the
additive group (K,+) given by the vector field
@format
         m = m[1,1]*d/dx(1) +...+ m[n,1]*d/dx(n).
@end format
If b>0 the computation stops after all invariants of degree <= b
(and at least one of higher degree) are found or when all invariants
are computed.
@*If b<=0, the computation continues until all generators
of the ring of invariants are computed (should be used only if the
ring of invariants is known to be finitely generated otherwise the
algorithm might not stop).
@*If r=1 a different reduction is used which is sometimes faster
(default r=0).

@item @strong{Display:}
if pa is given (any string as 5th or 6th argument), the computation
pauses whenever new invariants are found and displays them

@item @strong{Theory:}
The algorithm to compute the ring of invariants works in char 0
or big enough characteristic. (K,+) acts as the exponential of the
vector field defined by the matrix m. For background see G.-M. Greuel,
G. Pfister, Geometric quotients of unipotent group actions, Proc.
London Math. Soc. (3) 67, 75-105 (1993).

@end table
@strong{Example:}
@smallexample
@c computed example invariantRing d2t_singular/ainvar_lib.doc:75 
LIB "ainvar.lib";
//Winkelmann: free action but Spec(k[x(1),...,x(5)]) --> Spec(invariant ring)
//is not surjective
ring rw=0,(x(1..5)),dp;
matrix m[5][1];
m[3,1]=x(1);
m[4,1]=x(2);
m[5,1]=1+x(1)*x(4)+x(2)*x(3);
ideal in=invariantRing(m,x(3),x(1),0);      //compute full invarint ring
in;
@expansion{} in[1]=x(1)
@expansion{} in[2]=x(2)
@expansion{} in[3]=x(2)*x(3)*x(4)-x(2)*x(5)+x(4)
@expansion{} in[4]=x(1)*x(3)*x(4)-x(1)*x(5)+x(3)
//Deveney/Finston: The ring of invariants is not finitely generated
ring rf=0,(x(1..7)),dp;
matrix m[7][1];
m[4,1]=x(1)^3;
m[5,1]=x(2)^3;
m[6,1]=x(3)^3;
m[7,1]=(x(1)*x(2)*x(3))^2;
ideal in=invariantRing(m,x(4),x(1),6);      //all invariants up to degree 6
in;
@expansion{} in[1]=x(1)
@expansion{} in[2]=x(3)
@expansion{} in[3]=x(2)
@expansion{} in[4]=x(3)^3*x(4)-x(1)^3*x(6)
@expansion{} in[5]=x(2)^3*x(4)-x(1)^3*x(5)
@expansion{} in[6]=x(2)^2*x(3)^2*x(4)-x(1)*x(7)
@expansion{} in[7]=x(1)^2*x(2)^2*x(6)-x(3)*x(7)
@expansion{} in[8]=x(1)^2*x(3)^2*x(5)-x(2)*x(7)
@expansion{} in[9]=x(1)^2*x(2)*x(3)^4*x(4)*x(5)+x(1)^2*x(2)^4*x(3)*x(4)*x(6)-x(1)^5*x(\
   2)*x(3)*x(5)*x(6)-2*x(2)^2*x(3)^2*x(4)*x(7)+x(1)*x(7)^2
@c end example invariantRing d2t_singular/ainvar_lib.doc:75
@end smallexample
@c ---end content invariantRing---

@c ------------------- derivate -------------
@node derivate, actionIsProper, invariantRing, ainvar_lib
@subsubsection derivate
@cindex derivate
@c ---content derivate---
Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).

@table @asis
@item @strong{Usage:}
derivate(m,id); m matrix, id poly/vector/ideal

@item @strong{Assume:}
m is a nx1 matrix, where n = number of variables of the basering

@item @strong{Return:}
poly/vector/ideal (same type as input), result of applying the
vector field by the matrix m componentwise to id;

@item @strong{Note:}
the vector field is m[1,1]*d/dx(1) +...+ m[1,n]*d/dx(n)

@end table
@strong{Example:}
@smallexample
@c computed example derivate d2t_singular/ainvar_lib.doc:123 
LIB "ainvar.lib";
ring q=0,(x,y,z,u,v,w),dp;
poly f=2xz-y2;
matrix m[6][1] =x,y,0,u,v;
derivate(m,f);
@expansion{} -2y2+2xz
vector v = [2xz-y2,u6-3];
derivate(m,v);
@expansion{} 6u6*gen(2)-2y2*gen(1)+2xz*gen(1)
derivate(m,ideal(2xz-y2,u6-3));
@expansion{} _[1]=-2y2+2xz
@expansion{} _[2]=6u6
@c end example derivate d2t_singular/ainvar_lib.doc:123
@end smallexample
@c ---end content derivate---

@c ------------------- actionIsProper -------------
@node actionIsProper, reduction, derivate, ainvar_lib
@subsubsection actionIsProper
@cindex actionIsProper
@c ---content actionIsProper---
Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).

@table @asis
@item @strong{Usage:}
actionIsProper(m); m matrix

@item @strong{Assume:}
m is a nx1 matrix, where n = number of variables of the basering

@item @strong{Return:}
int = 1, if the action defined by m is proper, 0 if not

@item @strong{Note:}
m defines a group action which is the exponential of the vector
field m[1,1]*d/dx(1) +...+ m[1,n]*d/dx(n)

@end table
@strong{Example:}
@smallexample
@c computed example actionIsProper d2t_singular/ainvar_lib.doc:160 
LIB "ainvar.lib";
ring rf=0,x(1..7),dp;
matrix m[7][1];
m[4,1]=x(1)^3;
m[5,1]=x(2)^3;
m[6,1]=x(3)^3;
m[7,1]=(x(1)*x(2)*x(3))^2;
actionIsProper(m);
@expansion{} 0
ring rd=0,x(1..5),dp;
matrix m[5][1];
m[3,1]=x(1);
m[4,1]=x(2);
m[5,1]=1+x(1)*x(4)^2;
actionIsProper(m);
@expansion{} 1
@c end example actionIsProper d2t_singular/ainvar_lib.doc:160
@end smallexample
@c ---end content actionIsProper---

@c ------------------- reduction -------------
@node reduction, completeReduction, actionIsProper, ainvar_lib
@subsubsection reduction
@cindex reduction
@c ---content reduction---
Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).

@table @asis
@item @strong{Usage:}
reduction(p,I[,q,n]); p poly, I ideal, [q monomial, n int (optional)]

@item @strong{Return:}
a polynomial equal to p-H(f1,...,fr), in case the leading
term LT(p) of p is of the form H(LT(f1),...,LT(fr)) for some
polynomial H in r variables over the base field, I=f1,...,fr;
if q is given, a maximal power a is computed such that q^a divides
p-H(f1,...,fr), and then (p-H(f1,...,fr))/q^a is returned;
return p if no H is found
@*if n=1, a different algorithm is chosen which is sometimes faster
(default: n=0; q and n can be given (or not) in any order)

@item @strong{Note:}
this is a kind of SAGBI reduction in the subalgebra K[f1,...,fr] of
the basering

@end table
@strong{Example:}
@smallexample
@c computed example reduction d2t_singular/ainvar_lib.doc:207 
LIB "ainvar.lib";
ring q=0,(x,y,z,u,v,w),dp;
poly p=x2yz-x2v;
ideal dom =x-w,u2w+1,yz-v;
reduction(p,dom);
@expansion{} 2xyzw-yzw2-2xvw+vw2
reduction(p,dom,w);
@expansion{} 2xyz-yzw-2xv+vw
@c end example reduction d2t_singular/ainvar_lib.doc:207
@end smallexample
@c ---end content reduction---

@c ------------------- completeReduction -------------
@node completeReduction, localInvar, reduction, ainvar_lib
@subsubsection completeReduction
@cindex completeReduction
@c ---content completeReduction---
Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).

@table @asis
@item @strong{Usage:}
completeReduction(p,I[,q,n]); p poly, I ideal, [q monomial, n int]

@item @strong{Return:}
a polynomial, the SAGBI reduction of the polynomial p with I
via the procedure 'reduction' as long as possible
@*if n=1, a different algorithm is chosen which is sometimes faster
(default: n=0; q and n can be given (or not) in any order)

@item @strong{Note:}
help reduction; shows an explanation of SAGBI reduction

@end table
@strong{Example:}
@smallexample
@c computed example completeReduction d2t_singular/ainvar_lib.doc:241 
LIB "ainvar.lib";
ring q=0,(x,y,z,u,v,w),dp;
poly p=x2yz-x2v;
ideal dom =x-w,u2w+1,yz-v;
completeReduction(p,dom);
@expansion{} 2xyzw-yzw2-2xvw+vw2
completeReduction(p,dom,w);
@expansion{} 0
@c end example completeReduction d2t_singular/ainvar_lib.doc:241
@end smallexample
@c ---end content completeReduction---

@c ------------------- localInvar -------------
@node localInvar, furtherInvar, completeReduction, ainvar_lib
@subsubsection localInvar
@cindex localInvar
@c ---content localInvar---
Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).

@table @asis
@item @strong{Usage:}
localInvar(m,p,q,h); m matrix, p,q,h polynomials

@item @strong{Assume:}
m(q) and h are invariant under the vector field m, i.e. m(m(q))=m(h)=0
h must be a ring variable

@item @strong{Return:}
a polynomial, the invariant polynomial of the vector field
@format
         m = m[1,1]*d/dx(1) +...+ m[n,1]*d/dx(n)
@end format
with respect to p,q,h. It is defined as follows: set inv = p if p is
invariant, and else as
@*inv = m(q)^N * sum_i=1..N-1@{ (-1)^i*(1/i!)*m^i(p)*(q/m(q))^i @}
where m^N(p) = 0, m^(N-1)(p) != 0;
@*the result is inv divided by h as much as possible

@end table
@strong{Example:}
@smallexample
@c computed example localInvar d2t_singular/ainvar_lib.doc:281 
LIB "ainvar.lib";
ring q=0,(x,y,z),dp;
matrix m[3][1];
m[2,1]=x;
m[3,1]=y;
poly in=localInvar(m,z,y,x);
in;
@expansion{} -1/2y2+xz
@c end example localInvar d2t_singular/ainvar_lib.doc:281
@end smallexample
@c ---end content localInvar---

@c ------------------- furtherInvar -------------
@node furtherInvar, sortier, localInvar, ainvar_lib
@subsubsection furtherInvar
@cindex furtherInvar
@c ---content furtherInvar---
Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).

@table @asis
@item @strong{Usage:}
furtherInvar(m,id,karl,q); m matrix, id,karl ideals, q poly, n int

@item @strong{Assume:}
karl,id,q are invariant under the vector field m,
@*moreover, q must be a variable

@item @strong{Return:}
list of two ideals, the first ideal contains further invariants of
the vector field
@format
         m = sum m[i,1]*d/dx(i) with respect to id,p,q,
@end format
i.e. we compute elements in the (invariant) subring generated by id
which are divisible by q and divide them by q as much as possible
the second ideal contains all invariants given before
if n=1, a different algorithm is chosen which is sometimes faster
(default: n=0)

@end table
@strong{Example:}
@smallexample
@c computed example furtherInvar d2t_singular/ainvar_lib.doc:323 
LIB "ainvar.lib";
ring r=0,(x,y,z,u),dp;
matrix m[4][1];
m[2,1]=x;
m[3,1]=y;
m[4,1]=z;
ideal id=localInvar(m,z,y,x),localInvar(m,u,y,x);
ideal karl=id,x;
list in=furtherInvar(m,id,karl,x);
in;
@expansion{} [1]:
@expansion{}    _[1]=y2z2-8/3xz3-2y3u+6xyzu-3x2u2
@expansion{} [2]:
@expansion{}    _[1]=-1/2y2+xz
@expansion{}    _[2]=1/3y3-xyz+x2u
@expansion{}    _[3]=x
@c end example furtherInvar d2t_singular/ainvar_lib.doc:323
@end smallexample
@c ---end content furtherInvar---

@c ------------------- sortier -------------
@node sortier,, furtherInvar, ainvar_lib
@subsubsection sortier
@cindex sortier
@c ---content sortier---
Procedure from library @code{ainvar.lib} (@pxref{ainvar_lib}).

@table @asis
@item @strong{Usage:}
sortier(id); id ideal/module

@item @strong{Return:}
the same ideal/module but with generators ordered by there
leading term, starting with the smallest

@end table
@strong{Example:}
@smallexample
@c computed example sortier d2t_singular/ainvar_lib.doc:356 
LIB "ainvar.lib";
ring q=0,(x,y,z,u,v,w),dp;
ideal i=w,x,z,y,v;
sortier(i);
@expansion{} _[1]=w
@expansion{} _[2]=v
@expansion{} _[3]=z
@expansion{} _[4]=y
@expansion{} _[5]=x
@c end example sortier d2t_singular/ainvar_lib.doc:356
@end smallexample
@c ---end content sortier---
@c ----------------------------------------------------------
@node rinvar_lib, stratify_lib, ainvar_lib, Invariant theory
@subsection rinvar_lib
@c include of docu for rinvar.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/rinvar_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/rinvar_lib.doc INSTEAD
@c library version: (1.7.2.3,2002/02/20)
@c library file: ../Singular/LIB/rinvar.lib
@cindex rinvar.lib
@cindex rinvar_lib
@table @asis
@item @strong{Library:}
rinvar.lib
@item @strong{Purpose:}
      Invariant Rings of Reductive Groups
@item @strong{Author:}
Thomas Bayer, tbayer@@in.tum.de
@*http://wwwmayr.informatik.tu-muenchen.de/personen/bayert/
Current Adress: Institut fuer Informatik, TU Muenchen

@item @strong{Overview:}
Implementation based on Derksen's algorithm. Written in the frame of the
diploma thesis (advisor: Prof. Gert-Martin Greuel) 'Computations of moduli
spaces of semiquasihomogeneous singularities and an implementation in Singular'

@end table

@strong{Procedures:}
@menu
* HilbertSeries:: Hilbert series of the ideal I w.r.t. weight w
* HilbertWeights:: weighted degrees of the generators of I
* ImageVariety:: ideal of the image variety F(variety(I))
* ImageGroup:: ideal of G w.r.t. the induced representation
* InvariantRing:: generators of the invariant ring of G
* InvariantQ:: decide if f is invariant w.r.t. G
* LinearizeAction:: linearization of the action 'Gaction' of G
* LinearActionQ:: decide if action is linear in var(s..nvars)
* LinearCombinationQ:: decide if f is in the linear hull of 'base'
* MinimalDecomposition:: minimal decomposition of f (like coef)
* NullCone:: ideal of the null cone of the action 'act' of G
* ReynoldsImage:: image of f under the Reynolds operator 'RO'
* ReynoldsOperator:: Reynolds operator of the group G
* SimplifyIdeal:: simplify the ideal I (try to reduce variables)
* TransferIdeal:: transfer the ideal 'name' from R to basering
@end menu
@c inserted refs from d2t_singular/rinvar_lib.doc:41
@menu
See also:
* qhmoduli_lib::
* zeroset_lib::
@end menu
@c end inserted refs from d2t_singular/rinvar_lib.doc:41

@c ---end content LibInfo---

@c ------------------- HilbertSeries -------------
@node HilbertSeries, HilbertWeights,, rinvar_lib
@subsubsection HilbertSeries
@cindex HilbertSeries
@c ---content HilbertSeries---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
HilbertSeries(I, w); ideal I, intvec wt

@item @strong{Purpose:}
compute the polynomial p of the Hilbert Series,represented by p/q, of
the ring K[t_1,...,t_m,y_1,...,y_r]/I1 where 'w' are the weights of
the variables, computed, e.g., by 'HilbertWeights', 'I1' is of the
form I[1] - y_1,...,I[r] - y_r and is quasihomogeneous w.r.t. 'w'

@item @strong{Return:}
intvec

@item @strong{Note:}
the leading 0 of the result does not belong to p, but is needed in
the hilbert-driven 'std'.

@end table
@c ---end content HilbertSeries---

@c ------------------- HilbertWeights -------------
@node HilbertWeights, ImageVariety, HilbertSeries, rinvar_lib
@subsubsection HilbertWeights
@cindex HilbertWeights
@c ---content HilbertWeights---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Purpose:}
compute the weights of the "slack" variables needed for the
computation of the algebraic relations of the generators of 'I' s.t.
the Hilbert driven 'std' can be used.

@item @strong{Return:}
intvec

@item @strong{Assume:}
basering = K[t_1,...,t_m,...], 'I' is quasihomogeneous w.r.t. 'w' and
contains only polynomials in t_1,...,t_m

@end table
@c ---end content HilbertWeights---

@c ------------------- ImageVariety -------------
@node ImageVariety, ImageGroup, HilbertWeights, rinvar_lib
@subsubsection ImageVariety
@cindex ImageVariety
@c ---content ImageVariety---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
ImageVariety(ideal I, F [, w]);ideal I; F is a list/ideal, intvec w.

@item @strong{Purpose:}
compute the Zariski closure of the image of the variety of I under
the morphism F.

@item @strong{Note:}
if 'I' and 'F' are quasihomogeneous w.r.t. 'w' then the Hilbert-driven
'std' is used.

@item @strong{Return:}
polynomial ring over the same ground field, containing the ideal
'imageid'. The variables are Y(1),...,Y(k) where k = size(F)
- 'imageid' is the ideal of the Zariski closure of F(X) where
X is the variety of I.

@end table
@strong{Example:}
@smallexample
@c computed example ImageVariety d2t_singular/rinvar_lib.doc:125 
LIB "rinvar.lib";
ring B   = 0,(x,y),dp;
ideal I  = x4 - y4;
ideal F  = x2, y2, x*y;
def R = ImageVariety(I, F);
setring R;
imageid;
@expansion{} imageid[1]=Y(1)*Y(2)-Y(3)^2
@expansion{} imageid[2]=Y(1)^2-Y(2)^2
@expansion{} imageid[3]=Y(2)^3-Y(1)*Y(3)^2
@c end example ImageVariety d2t_singular/rinvar_lib.doc:125
@end smallexample
@c ---end content ImageVariety---

@c ------------------- ImageGroup -------------
@node ImageGroup, InvariantRing, ImageVariety, rinvar_lib
@subsubsection ImageGroup
@cindex ImageGroup
@c ---content ImageGroup---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
ImageGroup(G, action); ideal G, action;

@item @strong{Purpose:}
compute the ideal of the image of G in GL(m,K) induced by the linear
action 'action', where G is an algebraic group and 'action' defines
an action of G on K^m (size(action) = m).

@item @strong{Return:}
ring, a polynomial ring over the same ground field as the basering,
containing the ideals 'groupid' and 'actionid'.
@*- 'groupid' is the ideal of the image of G (order <= order of G)
- 'actionid' defines the linear action of 'groupid' on K^m.

@item @strong{Note:}
'action' and 'actionid' have the same orbits
@*all variables which give only rise to 0's in the m x m matrices of G
have been omitted.

@item @strong{Assume:}
basering K[s(1..r),t(1..m)] has r + m variables, G is the ideal of an
algebraic group and F is an action of G on K^m. G contains only the
variables s(1)...s(r). The action 'action' is given by polynomials
f_1,...,f_m in basering, s.t. on the ring level we have
K[t_1,...,t_m] --> K[s_1,...,s_r,t_1,...,t_m]/G
@*t_i --> f_i(s_1,...,s_r,t_1,...,t_m)

@end table
@strong{Example:}
@smallexample
@c computed example ImageGroup d2t_singular/rinvar_lib.doc:175 
LIB "rinvar.lib";
ring B   = 0,(s(1..2), t(1..2)),dp;
ideal G = s(1)^3-1, s(2)^10-1;
ideal action = s(1)*s(2)^8*t(1), s(1)*s(2)^7*t(2);
def R = ImageGroup(G, action);
setring R;
groupid;
@expansion{} groupid[1]=-s(1)+s(2)^4
@expansion{} groupid[2]=s(1)^8-s(2)^2
@expansion{} groupid[3]=s(1)^7*s(2)^2-1
actionid;
@expansion{} actionid[1]=s(1)*t(1)
@expansion{} actionid[2]=s(2)*t(2)
@c end example ImageGroup d2t_singular/rinvar_lib.doc:175
@end smallexample
@c ---end content ImageGroup---

@c ------------------- InvariantRing -------------
@node InvariantRing, InvariantQ, ImageGroup, rinvar_lib
@subsubsection InvariantRing
@cindex InvariantRing
@c ---content InvariantRing---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
InvariantRing(G, Gact [, opt]); ideal G, Gact; int opt

@item @strong{Purpose:}
compute generators of the invariant ring of G w.r.t. the action 'Gact'

@item @strong{Assume:}
G is a finite group and 'Gact' is a linear action.

@item @strong{Return:}
polynomial ring over a simple extension of the ground field of the
basering (the extension might be trivial), containing the ideals
'invars' and 'groupid' and the poly 'newA'
@*- 'invars' contains the algebra-generators of the invariant ring
- 'groupid' is the ideal of G in the new ring
@*- 'newA' if the minpoly changes this is the new representation of the
algebraic number, otherwise it is set to 'a'.

@item @strong{Note:}
the delivered ring might have a different minimal polynomial

@end table
@strong{Example:}
@smallexample
@c computed example InvariantRing d2t_singular/rinvar_lib.doc:220 
LIB "rinvar.lib";
ring B = 0, (s(1..2), t(1..2)), dp;
ideal G = -s(1)+s(2)^3, s(1)^4-1;
ideal action = s(1)*t(1), s(2)*t(2);
def R = InvariantRing(std(G), action);
setring R;
invars;
@expansion{} invars[1]=t(1)^4
@expansion{} invars[2]=t(1)^3*t(2)^3
@expansion{} invars[3]=t(1)^2*t(2)^6
@expansion{} invars[4]=t(1)*t(2)^9
@expansion{} invars[5]=t(2)^12
@c end example InvariantRing d2t_singular/rinvar_lib.doc:220
@end smallexample
@c ---end content InvariantRing---

@c ------------------- InvariantQ -------------
@node InvariantQ, LinearizeAction, InvariantRing, rinvar_lib
@subsubsection InvariantQ
@cindex InvariantQ
@c ---content InvariantQ---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
InvariantQ(f, G, action); poly f; ideal G, action

@item @strong{Purpose:}
check if the polynomial f is invariant w.r.t. G where G acts via
'action' on K^m.

@item @strong{Assume:}
basering = K[s_1,...,s_m,t_1,...,t_m] where K = Q of K = Q(a) and
minpoly != 0, f contains only t_1,...,t_m, G is the ideal of an
algebraic group and a standard basis.

@item @strong{Return:}
int;
@*0 if f is not invariant,
@*1 if f is invariant

@item @strong{Note:}
G need not be finite

@end table
@c ---end content InvariantQ---

@c ------------------- LinearizeAction -------------
@node LinearizeAction, LinearActionQ, InvariantQ, rinvar_lib
@subsubsection LinearizeAction
@cindex LinearizeAction
@c ---content LinearizeAction---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
LinearizeAction(G,action,r); ideal G, action; int r

@item @strong{Purpose:}
linearize the group action 'action' and find an equivariant embedding
of K^m where m = size(action).

@item @strong{Assume:}
G contains only variables var(1..r) (r = nrs)
@*basering = K[s(1..r),t(1..m)], K = Q or K = Q(a) and minpoly != 0.

@item @strong{Return:}
polynomial ring containing the ideals 'actionid', 'embedid', 'groupid'
- 'actionid' is the ideal defining the linearized action of G
- 'embedid' is a parameterization of an equivariant embedding (closed)
- 'groupid' is the ideal of G in the new ring

@item @strong{Note:}
set printlevel > 0 to see a trace

@end table
@strong{Example:}
@smallexample
@c computed example LinearizeAction d2t_singular/rinvar_lib.doc:294 
LIB "rinvar.lib";
ring B   = 0,(s(1..5), t(1..3)),dp;
ideal G =  s(3)-s(4), s(2)-s(5), s(4)*s(5), s(1)^2*s(4)+s(1)^2*s(5)-1, s(1)^2*s(5)^2-s(5), s(4)^4-s(5)^4+s(1)^2, s(1)^4+s(4)^3-s(5)^3, s(5)^5-s(1)^2*s(5);
ideal action = -s(4)*t(1)+s(5)*t(1), -s(4)^2*t(2)+2*s(4)^2*t(3)^2+s(5)^2*t(2), s(4)*t(3)+s(5)*t(3);
LinearActionQ(action, 5);
@expansion{} 0
def R = LinearizeAction(G, action, 5);
setring R;
R;
@expansion{} //   characteristic : 0
@expansion{} //   number of vars : 9
@expansion{} //        block   1 : ordering dp
@expansion{} //                  : names    s(1) s(2) s(3) s(4) s(5) t(1) t(2) t(3) t(\
   4) 
@expansion{} //        block   2 : ordering C
actionid;
@expansion{} actionid[1]=-s(4)*t(1)+s(5)*t(1)
@expansion{} actionid[2]=-s(4)^2*t(2)+s(5)^2*t(2)+2*s(4)^2*t(4)
@expansion{} actionid[3]=s(4)*t(3)+s(5)*t(3)
@expansion{} actionid[4]=s(4)^2*t(4)+s(5)^2*t(4)
embedid;
@expansion{} embedid[1]=t(1)
@expansion{} embedid[2]=t(2)
@expansion{} embedid[3]=t(3)
@expansion{} embedid[4]=t(3)^2
groupid;
@expansion{} groupid[1]=s(3)-s(4)
@expansion{} groupid[2]=s(2)-s(5)
@expansion{} groupid[3]=s(4)*s(5)
@expansion{} groupid[4]=s(1)^2*s(4)+s(1)^2*s(5)-1
@expansion{} groupid[5]=s(1)^2*s(5)^2-s(5)
@expansion{} groupid[6]=s(4)^4-s(5)^4+s(1)^2
@expansion{} groupid[7]=s(1)^4+s(4)^3-s(5)^3
@expansion{} groupid[8]=s(5)^5-s(1)^2*s(5)
LinearActionQ(actionid, 5);
@expansion{} 1
@c end example LinearizeAction d2t_singular/rinvar_lib.doc:294
@end smallexample
@c ---end content LinearizeAction---

@c ------------------- LinearActionQ -------------
@node LinearActionQ, LinearCombinationQ, LinearizeAction, rinvar_lib
@subsubsection LinearActionQ
@cindex LinearActionQ
@c ---content LinearActionQ---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
LinearActionQ(action,nrs,nrt); ideal action, int nrs

@item @strong{Purpose:}
check if the action defined by 'action' is linear w.r.t. the variables
var(nrs + 1...nvars(basering)).

@item @strong{Return:}
0 action not linear
@*1 action is linear

@end table
@strong{Example:}
@smallexample
@c computed example LinearActionQ d2t_singular/rinvar_lib.doc:333 
LIB "rinvar.lib";
ring R   = 0,(s(1..5), t(1..3)),dp;
ideal G =  s(3)-s(4), s(2)-s(5), s(4)*s(5), s(1)^2*s(4)+s(1)^2*s(5)-1, s(1)^2*s(5)^2-s(5), s(4)^4-s(5)^4+s(1)^2, s(1)^4+s(4)^3-s(5)^3, s(5)^5-s(1)^2*s(5);
ideal Gaction = -s(4)*t(1)+s(5)*t(1), -s(4)^2*t(2)+2*s(4)^2*t(3)^2+s(5)^2*t(2), s(4)*t(3)+s(5)*t(3);
LinearActionQ(Gaction, 5, 3);
@expansion{} // ** too many arguments for LinearActionQ
@expansion{} 0
@c end example LinearActionQ d2t_singular/rinvar_lib.doc:333
@end smallexample
@c ---end content LinearActionQ---

@c ------------------- LinearCombinationQ -------------
@node LinearCombinationQ, MinimalDecomposition, LinearActionQ, rinvar_lib
@subsubsection LinearCombinationQ
@cindex LinearCombinationQ
@c ---content LinearCombinationQ---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
LinearCombination(I, f); ideal I, poly f

@item @strong{Purpose:}
test if f can be written as a linear combination of the generators of I.

@item @strong{Return:}
0 f is not a linear combination
@*1 f is a linear combination

@end table
@c ---end content LinearCombinationQ---

@c ------------------- MinimalDecomposition -------------
@node MinimalDecomposition, NullCone, LinearCombinationQ, rinvar_lib
@subsubsection MinimalDecomposition
@cindex MinimalDecomposition
@c ---content MinimalDecomposition---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
MinimalDecomposition(f,a,b); poly f; int a, b.

@item @strong{Purpose:}
decompose f as a sum M[1,1]*M[2,1] + ... + M[1,r]*M[2,r] where M[1,i]
contains only s(1..a), M[2,i] contains only t(1...b) s.t. r is minimal

@item @strong{Assume:}
f polynomial in K[s(1..a),t(1..b)], K = Q or K = Q(a) and minpoly != 0

@item @strong{Return:}
2 x r matrix M s.t. f = M[1,1]*M[2,1] + ... + M[1,r]*M[2,r]

@end table
@strong{Example:}
@smallexample
@c computed example MinimalDecomposition d2t_singular/rinvar_lib.doc:388 
LIB "rinvar.lib";
ring R = 0, (s(1..2), t(1..2)), dp;
poly h = s(1)*(t(1) + t(1)^2) +  (t(2) + t(2)^2)*(s(1)^2 + s(2));
matrix M = MinimalDecomposition(h, 2, 2);
M;
@expansion{} M[1,1]=s(1)^2+s(2)
@expansion{} M[1,2]=s(1)
@expansion{} M[2,1]=t(2)^2+t(2)
@expansion{} M[2,2]=t(1)^2+t(1)
M[1,1]*M[2,1] + M[1,2]*M[2,2] - h;
@expansion{} 0
@c end example MinimalDecomposition d2t_singular/rinvar_lib.doc:388
@end smallexample
@c ---end content MinimalDecomposition---

@c ------------------- NullCone -------------
@node NullCone, ReynoldsImage, MinimalDecomposition, rinvar_lib
@subsubsection NullCone
@cindex NullCone
@c ---content NullCone---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
NullCone(G, action); ideal G, action

@item @strong{Purpose:}
compute the ideal of the null cone of the linear action of G on K^n,
given by 'action', by means of Derksen's algorithm

@item @strong{Assume:}
basering = K[s(1..r),t(1..n)], K = Q or K = Q(a) and minpoly != 0,
G is an ideal of a reductive algebraic group in K[s(1..r)],
'action' is a linear group action of G on K^n (n = ncols(action))

@item @strong{Return:}
ideal of the null cone of G.

@item @strong{Note:}
the generators of the null cone are homogeneous, but i.g. not invariant

@end table
@strong{Example:}
@smallexample
@c computed example NullCone d2t_singular/rinvar_lib.doc:428 
LIB "rinvar.lib";
ring R = 0, (s(1..2), x, y), dp;
ideal G = -s(1)+s(2)^3, s(1)^4-1;
ideal action = s(1)*x, s(2)*y;
ideal inv = NullCone(G, action);
inv;
@expansion{} inv[1]=x^4
@expansion{} inv[2]=x^3*y^3
@expansion{} inv[3]=x^2*y^6
@expansion{} inv[4]=x*y^9
@expansion{} inv[5]=y^12
@c end example NullCone d2t_singular/rinvar_lib.doc:428
@end smallexample
@c ---end content NullCone---

@c ------------------- ReynoldsImage -------------
@node ReynoldsImage, ReynoldsOperator, NullCone, rinvar_lib
@subsubsection ReynoldsImage
@cindex ReynoldsImage
@c ---content ReynoldsImage---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
ReynoldsImage(RO, f); list RO, poly f

@item @strong{Purpose:}
compute the Reynolds image of the polynomial f where RO represents
the Reynolds operator

@item @strong{Return:}
poly

@end table
@c ---end content ReynoldsImage---

@c ------------------- ReynoldsOperator -------------
@node ReynoldsOperator, SimplifyIdeal, ReynoldsImage, rinvar_lib
@subsubsection ReynoldsOperator
@cindex ReynoldsOperator
@c ---content ReynoldsOperator---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Usage:}
ReynoldsOperator(G, action [, opt); ideal G, action; int opt

@item @strong{Purpose:}
compute the Reynolds operator of the group G which act via 'action'

@item @strong{Return:}
polynomial ring R over a simple extension of the ground field of the
basering (the extension might be trivial), containing a list
'ROelements', the ideals 'id', 'actionid' and the polynomial 'newA'.
R = K(a)[s(1..r),t(1..n)].
@*- 'ROelements' is a list of ideal, each ideal represents a
substitution map F : R -> R according to the zero-set of G
- 'id' is the ideal of G in the new ring
@*- 'newA' is the new representation of a' in terms of a. If the
basering does not contain a parameter then 'newA' = 'a'.

@item @strong{Assume:}
basering = K[s(1..r),t(1..n)], K = Q or K = Q(a') and minpoly != 0,
G is the ideal of a finite group in K[s(1..r)], 'action' is a linear
group action of G

@end table
@c ---end content ReynoldsOperator---

@c ------------------- SimplifyIdeal -------------
@node SimplifyIdeal, TransferIdeal, ReynoldsOperator, rinvar_lib
@subsubsection SimplifyIdeal
@cindex SimplifyIdeal
@c ---content SimplifyIdeal---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@item @strong{Purpose:}
simplify ideal I to the ideal I', do not change the names of the
first m variables, new ideal I' might contain less variables.
I' contains variables var(1..m)

@item @strong{Return:}
list
@*_[1] ideal I'
@*_[2] ideal representing a map phi to a ring with probably less vars. s.t.
phi(I) = I'
@*_[3] list of variables
@*_[4] list from 'elimpart'

@end table
@c ---end content SimplifyIdeal---

@c ------------------- TransferIdeal -------------
@node TransferIdeal,, SimplifyIdeal, rinvar_lib
@subsubsection TransferIdeal
@cindex TransferIdeal
@c ---content TransferIdeal---
Procedure from library @code{rinvar.lib} (@pxref{rinvar_lib}).

@table @asis
@end table
@c ---end content TransferIdeal---
@c ----------------------------------------------------------
@node stratify_lib, ,rinvar_lib, Invariant theory
@subsection stratify_lib
@c include of docu for stratify.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/stratify_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/stratify_lib.doc INSTEAD
@c library version: (1.7.2.4,2002/04/11)
@c library file: ../Singular/LIB/stratify.lib
@cindex stratify.lib
@cindex stratify_lib
@table @asis
@item @strong{Library:}
stratify.lib
@item @strong{Purpose:}
   Algorithmic Stratification for Unipotent Group-Actions
@item @strong{Author:}
Anne Fruehbis-Krueger, anne@@mathematik.uni-kl.de

@item @strong{Overview:}
This library provides an implementation of the algorithm
of Greuel and Pfister introduced in the article <Geometric
quotients of unipotent group actions>.

@end table

@strong{Procedures:}
@menu
* prepMat:: list of submatrices corresp. to given filtration
* stratify:: algorithmic stratification (main procedure)
@end menu
@c ---end content LibInfo---

@c ------------------- prepMat -------------
@node prepMat, stratify,, stratify_lib
@subsubsection prepMat
@cindex prepMat
@c ---content prepMat---
Procedure from library @code{stratify.lib} (@pxref{stratify_lib}).

@table @asis
@item @strong{Usage:}
prepMat(M,wr,ws,step);
@*where M is a matrix, wr is an intvec of size ncols(M),
ws an intvec of size nrows(M) and step is an integer

@item @strong{Return:}
2 lists of submatrices corresponding to the filtrations
specified by wr and ws
@*the first list corresponds to the list for the filtration
of AdA, i.e. the ranks of these matrices will be the r_i,
the second one to the list for the filtration of L, i.e.
the ranks of these matrices will be the s_i

@item @strong{Note:}
* the entries of the matrix M are M_ij=delta_i(x_j),
@** wr is used to determine what subset of the set of all dx_i is
generating AdF^l(A):
@*if (k-1)*step <= wr[i] < k*step, then dx_i is in the set of
generators of AdF^l(A) for all l>=k and the i-th column
of M appears in each submatrix starting from the k-th
@** ws is used to determine what subset of the set of all delta_i
is generating Z_l(L):
@*if (k-1)*step <= ws[i] < k*step, then delta_i is in the set
of generators of Z_l(A) for l < k and the i-th row of M
appears in each submatrix up to the (k-1)th
@** the entries of wr and ws as well as step should be positive
integers

@end table
@strong{Example:}
@smallexample
@c computed example prepMat d2t_singular/stratify_lib.doc:67 
LIB "stratify.lib";
ring r=0,(t(1..3)),dp;
matrix M[2][3]=0,t(1),3*t(2),0,0,t(1);
print(M);
@expansion{} 0,t(1),3*t(2),
@expansion{} 0,0,   t(1)   
intvec wr=1,3,5;
intvec ws=2,4;
int step=2;
prepMat(M,wr,ws,step);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1,1]=0
@expansion{}       _[2,1]=0
@expansion{}    [2]:
@expansion{}       _[1,1]=0
@expansion{}       _[1,2]=t(1)
@expansion{}       _[2,1]=0
@expansion{}       _[2,2]=0
@expansion{}    [3]:
@expansion{}       _[1,1]=0
@expansion{}       _[1,2]=t(1)
@expansion{}       _[1,3]=3*t(2)
@expansion{}       _[2,1]=0
@expansion{}       _[2,2]=0
@expansion{}       _[2,3]=t(1)
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1,1]=0
@expansion{}       _[1,2]=t(1)
@expansion{}       _[1,3]=3*t(2)
@expansion{}       _[2,1]=0
@expansion{}       _[2,2]=0
@expansion{}       _[2,3]=t(1)
@expansion{}    [2]:
@expansion{}       _[1,1]=0
@expansion{}       _[1,2]=0
@expansion{}       _[1,3]=t(1)
@c end example prepMat d2t_singular/stratify_lib.doc:67
@end smallexample
@c ---end content prepMat---

@c ------------------- stratify -------------
@node stratify,, prepMat, stratify_lib
@subsubsection stratify
@cindex stratify
@c ---content stratify---
Procedure from library @code{stratify.lib} (@pxref{stratify_lib}).

@table @asis
@item @strong{Usage:}
stratify(M,wr,ws,step);
@*where M is a matrix, wr is an intvec of size ncols(M),
ws an intvec of size nrows(M) and step is an integer

@item @strong{Return:}
list of lists, each entry of the big list corresponds to one
locally closed set and has the following entries:
@*1) intvec giving the corresponding rs-vector
@*2) ideal determining the closed set
@*3) list d of polynomials determining the open set D(d[1])
empty list if there is more than one open set
@*4-n) lists of polynomials determining open sets which all lead
to the same rs-vector

@item @strong{Note:}
* ring ordering should be global, i.e. the ring should be a
polynomial ring
@** the entries of the matrix M are M_ij=delta_i(x_j),
@** wr is used to determine what subset of the set of all dx_i is
generating AdF^l(A):
@*if (k-1)*step < wr[i] <= k*step, then dx_i is in the set of
generators of AdF^l(A) for all l>=k
@** ws is used to determine what subset of the set of all delta_i
is generating Z_l(L):
@*if (k-1)*step <= ws[i] < k*step, then delta_i is in the set
of generators of Z_l(A) for l < k
@** the entries of wr and ws as well as step should be positive
integers
@** the filtrations have to be known, no sanity checks concerning
the filtrations are performed !!!

@end table
@strong{Example:}
@smallexample
@c computed example stratify d2t_singular/stratify_lib.doc:123 
LIB "stratify.lib";
ring r=0,(t(1..3)),dp;
matrix M[2][3]=0,t(1),3*t(2),0,0,t(1);
intvec wr=1,3,5;
intvec ws=2,4;
int step=2;
stratify(M,wr,ws,step);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       0,0,0,0
@expansion{}    [2]:
@expansion{}       _[1]=t(2)
@expansion{}       _[2]=t(1)
@expansion{}    [3]:
@expansion{}       [1]:
@expansion{}          1
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       0,1,0,1
@expansion{}    [2]:
@expansion{}       _[1]=t(1)
@expansion{}    [3]:
@expansion{}       [1]:
@expansion{}          t(2)
@expansion{}       [2]:
@expansion{}          t(2)
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1,2,1,2
@expansion{}    [2]:
@expansion{}       _[1]=0
@expansion{}    [3]:
@expansion{}       [1]:
@expansion{}          t(1)
@expansion{}       [2]:
@expansion{}          t(1)
@c end example stratify d2t_singular/stratify_lib.doc:123
@end smallexample
@c ---end content stratify---
@c ----------------------------------------------------------------------------
@node Symbolic-numerical solving, Visualization, Invariant theory, SINGULAR libraries
@section Symbolic-numerical solving
@cindex Symbolic-numerical solving

@menu
* presolve_lib:: procedures for pre-solving polynomial equations
* solve_lib:: procedures to solve polynomial systems
* triang_lib:: procedures for decomposing zero-dimensional ideals
* ntsolve_lib:: one real solution of polynomial systems (Newton iteration)
* zeroset_lib:: procedures for roots and factorization
@end menu

@c ---------------------------------------------------------
@node presolve_lib, solve_lib, Symbolic-numerical solving, Symbolic-numerical solving
@subsection presolve_lib
@c include of docu for presolve.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/presolve_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/presolve_lib.doc INSTEAD
@c library version: (1.17.2.7,2003/06/12)
@c library file: ../Singular/LIB/presolve.lib
@cindex presolve.lib
@cindex presolve_lib
@table @asis
@item @strong{Library:}
presolve.lib
@item @strong{Purpose:}
     Pre-Solving of Polynomial Equations
@item @strong{Author:}
Gert-Martin Greuel, email: greuel@@mathematik.uni-kl.de,

@end table

@strong{Procedures:}
@menu
* degreepart:: elements of id of total degree >= d1 and <= d2
* elimlinearpart:: linear part eliminated from id
* elimpart:: partial elimination of vars [among first n vars]
* elimpartanyr:: factors of p partially eliminated from i in any ring
* fastelim:: fast elimination of factors of p from i [options]
* findvars:: ideal of variables occurring in id [more information]
* hilbvec:: intvec of Hilbert-series of id [in char c and ord o]
* linearpart:: elements of id of total degree <=1
* tolessvars:: maps id to new basering having only vars occurring in id
* solvelinearpart:: reduced std-basis of linear part of id
* sortandmap:: map to new basering with vars sorted w.r.t. complexity
* sortvars:: sort vars w.r.t. complexity in id [different blocks]
* shortid:: generators of id having <= n terms
* valvars:: valuation of vars w.r.t. to their complexity in id
* idealSimplify:: eliminates variables which are linear in id
* idealSplit:: intersection of the ideals has the same radical as id
@end menu
@c ---end content LibInfo---

@c ------------------- degreepart -------------
@node degreepart, elimlinearpart,, presolve_lib
@subsubsection degreepart
@cindex degreepart
@c ---content degreepart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
degreepart(id,d1,d2[,v]); id=ideal/module, d1,d1=integers, v=intvec

@item @strong{Return:}
generators of id of [v-weighted] total degree >= d1 and <= d2
(default: v = 1,...,1)

@end table
@strong{Example:}
@smallexample
@c reused example degreepart d2t_singular/presolve_lib.doc:55 
LIB "presolve.lib";
ring r=0,(x,y,z),dp;
ideal i=1+x+x2+x3+x4,3,xz+y3+z8;
degreepart(i,0,4);
@expansion{} _[1]=x4+x3+x2+x+1
@expansion{} _[2]=3
module m=[x,y,z],x*[x3,y2,z],[1,x2,z3,0,1];
intvec v=2,3,6;
show(degreepart(m,8,8,v));
@expansion{} // module, 1 generator(s)
@expansion{} [x4,xy2,xz]
@c end example degreepart d2t_singular/presolve_lib.doc:55
@end smallexample
@c ---end content degreepart---

@c ------------------- elimlinearpart -------------
@node elimlinearpart, elimpart, degreepart, presolve_lib
@subsubsection elimlinearpart
@cindex elimlinearpart
@c ---content elimlinearpart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
elimlinearpart(i[,n]); i=ideal, n=integer,@*
default: n=nvars(basering)

@item @strong{Return:}
list L with 5 entries:
  @format
  L[1]: (interreduced) ideal obtained from i by substituing
        from the first n variables those, which appear in a linear part
        of i, by putting this part into triangular form
  L[2]: ideal of variables which have been substituted
  L[3]: ideal, j-th element defines substitution of j-th var in [2]
  L[4]: ideal of variables of basering, eliminated ones are set to 0
  L[5]: ideal, describing the map from the basering to itself such that
        L[1] is the image of i
  @end format

@item @strong{Note:}
the procedure does always interreduce the ideal i internally w.r.t.
ordering dp.

@end table
@strong{Example:}
@smallexample
@c reused example elimlinearpart d2t_singular/presolve_lib.doc:99 
LIB "presolve.lib";
ring s=0,(x,y,z),dp;
ideal i = x3+y2+z,x2y2+z3,y+z+1;
elimlinearpart(i);
@expansion{} [1]:
@expansion{}    _[1]=x3+z2+3z+1
@expansion{}    _[2]=x2z2+2x2z+z3+x2
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{} [3]:
@expansion{}    _[1]=y+z+1
@expansion{} [4]:
@expansion{}    _[1]=x
@expansion{}    _[2]=0
@expansion{}    _[3]=z
@expansion{} [5]:
@expansion{}    _[1]=x
@expansion{}    _[2]=-z-1
@expansion{}    _[3]=z
@c end example elimlinearpart d2t_singular/presolve_lib.doc:99
@end smallexample
@c ---end content elimlinearpart---

@c ------------------- elimpart -------------
@node elimpart, elimpartanyr, elimlinearpart, presolve_lib
@subsubsection elimpart
@cindex elimpart
@c ---content elimpart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
elimpart(i [,n,e] ); i=ideal, n,e=integers
@*n : only the first n vars are considered for substitution,@*
e =0: substitute from linear part of i (same as elimlinearpart)@*
e!=0: eliminate also by direct substitution@*
(default: n = nvars(basering), e = 1)

@item @strong{Return:}
list of 5 objects:
  @format
  [1]: ideal obtained by substituting from the first n variables those
       from i, which appear in the linear part of i (or, if e!=0, which
       can be expressed directly in the remaining vars)
  [2]: ideal, variables which have been substituted
  [3]: ideal, i-th element defines substitution of i-th var in [2]
  [4]: ideal of variables of basering, substituted ones are set to 0
  [5]: ideal, describing the map from the basering, say k[x(1..m)], to
       itself onto k[..variables fom [4]..] and [1] is the image of i
  @end format
The ideal i is generated by [1] and [3] in k[x(1..m)], the map [5]
maps [3] to 0, hence induces an isomorphism
  @format
            k[x(1..m)]/i -> k[..variables fom [4]..]/[1]
  @end format

@item @strong{Note:}
If the basering has ordering (c,dp), this is faster for big ideals,
since it avoids internal ring change and mapping.

@end table
@strong{Example:}
@smallexample
@c reused example elimpart d2t_singular/presolve_lib.doc:148 
LIB "presolve.lib";
ring s=0,(x,y,z),dp;
ideal i =x2+y2,x2+y+1;
elimpart(i,3,0);
@expansion{} [1]:
@expansion{}    _[1]=y2-y-1
@expansion{}    _[2]=x2+y+1
@expansion{} [2]:
@expansion{}    _[1]=0
@expansion{} [3]:
@expansion{}    _[1]=0
@expansion{} [4]:
@expansion{}    _[1]=x
@expansion{}    _[2]=y
@expansion{}    _[3]=z
@expansion{} [5]:
@expansion{}    _[1]=x
@expansion{}    _[2]=y
@expansion{}    _[3]=z
elimpart(i,3,1);
@expansion{} [1]:
@expansion{}    _[1]=x4+3x2+1
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{} [3]:
@expansion{}    _[1]=x2+y+1
@expansion{} [4]:
@expansion{}    _[1]=x
@expansion{}    _[2]=0
@expansion{}    _[3]=z
@expansion{} [5]:
@expansion{}    _[1]=x
@expansion{}    _[2]=-x2-1
@expansion{}    _[3]=z
@c end example elimpart d2t_singular/presolve_lib.doc:148
@end smallexample
@c ---end content elimpart---

@c ------------------- elimpartanyr -------------
@node elimpartanyr, fastelim, elimpart, presolve_lib
@subsubsection elimpartanyr
@cindex elimpartanyr
@c ---content elimpartanyr---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
elimpartanyr(i [,p,e] ); i=ideal, p=polynomial, e=integer@*
p: product of vars to be eliminated,@*
e =0: substitute from linear part of i (same as elimlinearpart)@*
e!=0: eliminate also by direct substitution@*
(default: p=product of all vars, e=1)

@item @strong{Return:}
list of 6 objects:
  @format
  [1]: (interreduced) ideal obtained by substituting from i those vars
       appearing in p, which occur in the linear part of i (or which can
       be expressed directly in the remaining variables, if e!=0)
  [2]: ideal, variables which have been substituted
  [3]: ideal, i-th element defines substitution of i-th var in [2]
  [4]: ideal of variables of basering, substituted ones are set to 0
  [5]: ideal, describing the map from the basering, say k[x(1..m)], to
       itself onto k[..variables fom [4]..] and [1] is the image of i
  [6]: int, # of vars considered for substitution (= # of factors of p)
  @end format
The ideal i is generated by [1] and [3] in k[x(1..m)], the map [5]
maps [3] to 0, hence induces an isomorphism
  @format
            k[x(1..m)]/i -> k[..variables fom [4]..]/[1]
  @end format

@item @strong{Note:}
the proc uses @code{execute} to create a ring with ordering dp and vars
placed correctly and then applies @code{elimpart}.

@end table
@strong{Example:}
@smallexample
@c reused example elimpartanyr d2t_singular/presolve_lib.doc:199 
LIB "presolve.lib";
ring s=0,(x,y,z),dp;
ideal i = x3+y2+z,x2y2+z3,y+z+1;
elimpartanyr(i,z);
@expansion{} [1]:
@expansion{}    _[1]=x3+y2-y-1
@expansion{}    _[2]=x2y2-y3-3y2-3y-1
@expansion{} [2]:
@expansion{}    _[1]=z
@expansion{} [3]:
@expansion{}    _[1]=y+z+1
@expansion{} [4]:
@expansion{}    _[1]=0
@expansion{}    _[2]=x
@expansion{}    _[3]=y
@expansion{} [5]:
@expansion{}    _[1]=-y-1
@expansion{}    _[2]=x
@expansion{}    _[3]=y
@expansion{} [6]:
@expansion{}    1
@c end example elimpartanyr d2t_singular/presolve_lib.doc:199
@end smallexample
@c ---end content elimpartanyr---

@c ------------------- fastelim -------------
@node fastelim, findvars, elimpartanyr, presolve_lib
@subsubsection fastelim
@cindex fastelim
@c ---content fastelim---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
fastelim(i,p[h,o,a,b,e,m]); i=ideal, p=polynomial; h,o,a,b,e=integers
p: product of variables to be eliminated;@*
Optional parameters:
  @format
  - h !=0: use Hilbert-series driven std-basis computation
  - o !=0: use proc @code{valvars} for a - hopefully - optimal ordering of vars
  - a !=0: order vars to be eliminated w.r.t. increasing complexity
  - b !=0: order vars not to be eliminated w.r.t. increasing complexity
  - e !=0: use @code{elimpart} first to eliminate easy part
  - m !=0: compute a minimal system of generators
  @end format
(default: h,o,a,b,e,m = 0,1,0,0,0,0)

@item @strong{Return:}
ideal obtained from i by eliminating those variables, which occur in p

@end table
@strong{Example:}
@smallexample
@c reused example fastelim d2t_singular/presolve_lib.doc:236 
LIB "presolve.lib";
ring s=31991,(e,f,x,y,z,t,u,v,w,a,b,c,d),dp;
ideal i = w2+f2-1, x2+t2+a2-1,  y2+u2+b2-1, z2+v2+c2-1,
d2+e2-1, f4+2u, wa+tf, xy+tu+ab;
fastelim(i,xytua,1,1);       //with hilb,valvars
@expansion{} _[1]=f2+w2-1
@expansion{} _[2]=z2+v2+c2-1
@expansion{} _[3]=e2+d2-1
fastelim(i,xytua,1,0,1);     //with hilb,minbase
@expansion{} _[1]=z2+v2+c2-1
@expansion{} _[2]=f2+w2-1
@expansion{} _[3]=e2+d2-1
@c end example fastelim d2t_singular/presolve_lib.doc:236
@end smallexample
@c ---end content fastelim---

@c ------------------- findvars -------------
@node findvars, hilbvec, fastelim, presolve_lib
@subsubsection findvars
@cindex findvars
@c ---content findvars---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
findvars(id [,any] ); id=poly/ideal/vector/module/matrix, any=any type

@item @strong{Return:}
if no second argument is present: ideal of variables occurring in id,@*
if a second argument is given (of any type): list L with 4 entries:
  @format
  L[1]: ideal of variables occurring in id
  L[2]: intvec of variables occurring in id
  L[3]: ideal of variables not occurring in id
  L[4]: intvec of variables not occurring in id
  @end format

@end table
@strong{Example:}
@smallexample
@c reused example findvars d2t_singular/presolve_lib.doc:271 
LIB "presolve.lib";
ring s  = 0,(e,f,x,y,t,u,v,w,a,d),dp;
ideal i = w2+f2-1, x2+t2+a2-1;
findvars(i);
@expansion{} _[1]=f
@expansion{} _[2]=x
@expansion{} _[3]=t
@expansion{} _[4]=w
@expansion{} _[5]=a
findvars(i,1);
@expansion{} [1]:
@expansion{}    _[1]=f
@expansion{}    _[2]=x
@expansion{}    _[3]=t
@expansion{}    _[4]=w
@expansion{}    _[5]=a
@expansion{} [2]:
@expansion{}    2,3,5,8,9
@expansion{} [3]:
@expansion{}    _[1]=e
@expansion{}    _[2]=y
@expansion{}    _[3]=u
@expansion{}    _[4]=v
@expansion{}    _[5]=d
@expansion{} [4]:
@expansion{}    1,4,6,7,10
@c end example findvars d2t_singular/presolve_lib.doc:271
@end smallexample
@c ---end content findvars---

@c ------------------- hilbvec -------------
@node hilbvec, linearpart, findvars, presolve_lib
@subsubsection hilbvec
@cindex hilbvec
@c ---content hilbvec---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
hilbvec(id[,c,o]); id=poly/ideal/vector/module/matrix, c,o=strings,@*
c=char, o=ordering used by @code{hilb}@*
(default: c="32003", o="dp")

@item @strong{Return:}
intvec of 1-st Hilbert-series of id, computed in char c and ordering o

@item @strong{Note:}
id must be homogeneous (i.e. all vars have weight 1)

@end table
@strong{Example:}
@smallexample
@c reused example hilbvec d2t_singular/presolve_lib.doc:303 
LIB "presolve.lib";
ring s   = 0,(e,f,x,y,z,t,u,v,w,a,b,c,d,H),dp;
ideal id = w2+f2-1, x2+t2+a2-1,  y2+u2+b2-1, z2+v2+c2-1,
d2+e2-1, f4+2u, wa+tf, xy+tu+ab;
id = homog(id,H);
hilbvec(id);
@expansion{} 1,0,-7,0,20,0,-28,0,14,0,14,0,-28,0,20,0,-7,0,1,0
@c end example hilbvec d2t_singular/presolve_lib.doc:303
@end smallexample
@c ---end content hilbvec---

@c ------------------- linearpart -------------
@node linearpart, tolessvars, hilbvec, presolve_lib
@subsubsection linearpart
@cindex linearpart
@c ---content linearpart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
linearpart(id); id=ideal/module

@item @strong{Return:}
generators of id of total degree <= 1

@end table
@strong{Example:}
@smallexample
@c reused example linearpart d2t_singular/presolve_lib.doc:331 
LIB "presolve.lib";
ring r=0,(x,y,z),dp;
ideal i=1+x+x2+x3,3,x+3y+5z;
linearpart(i);
@expansion{} _[1]=3
@expansion{} _[2]=x+3y+5z
module m=[x,y,z],x*[x3,y2,z],[1,x2,z3,0,1];
show(linearpart(m));
@expansion{} // module, 1 generator(s)
@expansion{} [x,y,z]
@c end example linearpart d2t_singular/presolve_lib.doc:331
@end smallexample
@c ---end content linearpart---

@c ------------------- tolessvars -------------
@node tolessvars, solvelinearpart, linearpart, presolve_lib
@subsubsection tolessvars
@cindex tolessvars
@c ---content tolessvars---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
tolessvars(id [,s1,s2] ); id poly/ideal/vector/module/matrix,
s1,s2=strings@*
s1: name of new ring,@*
s2: new ordering@*
(default: s1="R(n)" where n is the # of vars in the new ring,
s2="dp" or "ds" depending whether the first block of the old
ordering is a p- resp. an s-ordering)

@item @strong{Create:}
nothing, if id contains all vars of the basering.@*
Else, create a ring with same char as the basering, but possibly less
variables (only those variables which actually occur in id) and map
id to the new ring, which will be the basering after the proc has
finished.

@item @strong{Display:}
If printlevel >=0, display ideal of vars, which have been omitted from
the old ring

@item @strong{Return:}
the original ideal id (see NOTE)

@item @strong{Note:}
You must not type, say, 'ideal id=tolessvars(id);' since the ring
to which 'id' would belong will only be defined by the r.h.s.. But you
may type 'def id=tolessvars(id);' or 'list id=tolessvars(id);'
since then 'id' does not a priory belong to a ring, its type will
be defined by the right hand side. Moreover, do not use a name which
occurs in the old ring, for the same reason.

@end table
@strong{Example:}
@smallexample
@c reused example tolessvars d2t_singular/presolve_lib.doc:384 
LIB "presolve.lib";
ring r  = 0,(x,y,z),dp;
ideal i = y2-x3,x-3,y-2x;
def j   = tolessvars(i,"R_r","lp");
@expansion{} 
@expansion{} // variables which did not occur:
@expansion{} z
@expansion{} // basering is now R_r
show(basering);
@expansion{} // ring: (0),(x,y),(lp(2),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // j                    [0]  ideal, 3 generator(s)
j;
@expansion{} j[1]=-x3+y2
@expansion{} j[2]=x-3
@expansion{} j[3]=-2x+y
kill R_r;
@c end example tolessvars d2t_singular/presolve_lib.doc:384
@end smallexample
@c ---end content tolessvars---

@c ------------------- solvelinearpart -------------
@node solvelinearpart, sortandmap, tolessvars, presolve_lib
@subsubsection solvelinearpart
@cindex solvelinearpart
@c ---content solvelinearpart---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
solvelinearpart(id [,n] ); id=ideal/module, n=integer,@*
(default: n=0)

@item @strong{Return:}
(interreduced) generators of id of degree <=1 in reduced triangular
form if n=0 [non-reduced triangular form if n!=0]

@item @strong{Assume:}
monomial ordering is a global ordering (p-ordering)

@item @strong{Note:}
may be used to solve a system of linear equations
see proc @code{gauss_row} from 'matrix.lib' for a different method

@item @strong{Warning:}
the result is very likely to be false for 'real' coefficients, use
char 0 instead!

@end table
@strong{Example:}
@smallexample
@c reused example solvelinearpart d2t_singular/presolve_lib.doc:426 
LIB "presolve.lib";
// Solve the system of linear equations:
//         3x +   y +  z -  u = 2
//         3x +  8y + 6z - 7u = 1
//        14x + 10y + 6z - 7u = 0
//         7x +  4y + 3z - 3u = 3
ring r = 0,(x,y,z,u),lp;
ideal i= 3x +   y +  z -  u,
13x +  8y + 6z - 7u,
14x + 10y + 6z - 7u,
7x +  4y + 3z - 3u;
ideal j= 2,1,0,3;
j = i-j;                        // difference of 1x4 matrices
// compute reduced triangular form, setting
solvelinearpart(j);             // the RHS equal 0 gives the solutions!
@expansion{} _[1]=u-4
@expansion{} _[2]=z-4
@expansion{} _[3]=y+1
@expansion{} _[4]=x-1
solvelinearpart(j,1); "";       // triangular form, not reduced
@expansion{} _[1]=u-4
@expansion{} _[2]=3z-8u+20
@expansion{} _[3]=18y-6z+7u+14
@expansion{} _[4]=13x+8y+6z-7u-1
@expansion{} 
@c end example solvelinearpart d2t_singular/presolve_lib.doc:426
@end smallexample
@c ---end content solvelinearpart---

@c ------------------- sortandmap -------------
@node sortandmap, sortvars, solvelinearpart, presolve_lib
@subsubsection sortandmap
@cindex sortandmap
@c ---content sortandmap---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
sortandmap(id,s1,s2[,n1,p1,n2,p2...,o1,m1,o2,m2...]);@*
id=poly/ideal/vector/module,@*
s1,s2 = strings (names for new ring and mapped id),@*
p1,p2,...= polynomials (product of variables),@*
n1,n2,...= integers,@*
o1,o2,...= strings,@*
m1,m2,...= integers@*
(default: p1=product of all vars, n1=0, o1="dp",m1=0)
@*the last pi (containing the remaining vars) may be omitted

@item @strong{Create:}
a new ring and map id into it, the new ring has same char as basering
but with new ordering and vars sorted in the following manner:
  @format
  - each block of vars occurring in pi is sorted w.r.t. its complexity in id,
  - ni controls the sorting in i-th block (= vars occurring in pi):
    ni=0 (resp.!=0) means that less (resp. more) complex vars come first
  - oi and mi define the monomial ordering of the i-th block:
    if mi =0, oi=ordstr(i-th block)
    if mi!=0, the ordering of the i-th block itself is a blockordering,
      each subblock having ordstr=oi, such that vars of same complexity are
      in one block
  @end format
Note that only simple ordstrings oi are allowed:
@*"lp","dp","Dp","ls","ds","Ds".

@item @strong{Return:}
nothing

@item @strong{Note:}
We define a variable x to be more complex than y (with respect to id)
if val(x) > val(y) lexicographically, where val(x) denotes the
valuation vector of x:@*
consider id as list of polynomials in x with coefficients in the
remaining variables. Then:@*
val(x) = (maximal occurring power of x, # of all monomials in leading
coefficient, # of all monomials in coefficient of next smaller power
of x,...).

@end table
@strong{Example:}
@smallexample
@c reused example sortandmap d2t_singular/presolve_lib.doc:498 
LIB "presolve.lib";
ring s = 32003,(x,y,z),dp;
ideal i=x3+y2,xz+z2;
sortandmap(i,"R_r","i");
// i is now an ideal in the new basering R_r
show(R_r);
@expansion{} // ring: (32003),(y,z,x),(dp(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // i                    [0]  ideal, 2 generator(s)
kill R_r; setring s;
sortandmap(i,"R_r","i",1,xy,0,z,0,"ds",0,"lp",0);
show(R_r);
@expansion{} // ring: (32003),(x,y,z),(ds(2),lp(1),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // i                    [0]  ideal, 2 generator(s)
kill R_r;
@c end example sortandmap d2t_singular/presolve_lib.doc:498
@end smallexample
@c ---end content sortandmap---

@c ------------------- sortvars -------------
@node sortvars, shortid, sortandmap, presolve_lib
@subsubsection sortvars
@cindex sortvars
@c ---content sortvars---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
sortvars(id[,n1,p1,n2,p2,...]);@*
id=poly/ideal/vector/module,@*
p1,p2,...= polynomials (product of vars),@*
n1,n2,...=integers@*
(default: p1=product of all vars, n1=0)
@*the last pi (containing the remaining vars) may be omitted

@item @strong{Compute:}
sort variables with respect to their complexity in id

@item @strong{Return:}
list of two elements, an ideal and a list:
  @format
  [1]: ideal, variables of basering sorted w.r.t their complexity in id
       ni controls the ordering in i-th block (= vars occurring in pi):
       ni=0 (resp.!=0) means that less (resp. more) complex vars come first
  [2]: a list with 4 entries for each pi:
       ideal ai : vars of pi in correct order,
       intvec vi: permutation vector describing the ordering in ai,
       intmat Mi: valuation matrix of ai, the columns of Mi being the
                  valuation vectors of the vars in ai
       intvec wi: size of 1-st, 2-nd,... block of identical columns of Mi
                  (vars with same valuation)
  @end format

@item @strong{Note:}
We define a variable x to be more complex than y (with respect to id)
if val(x) > val(y) lexicographically, where val(x) denotes the
valuation vector of x:@*
consider id as list of polynomials in x with coefficients in the
remaining variables. Then:@*
val(x) = (maximal occurring power of x, # of all monomials in leading
coefficient, # of all monomials in coefficient of next smaller power
of x,...).

@end table
@strong{Example:}
@smallexample
@c reused example sortvars d2t_singular/presolve_lib.doc:560 
LIB "presolve.lib";
ring s=0,(x,y,z,w),dp;
ideal i = x3+y2+yw2,xz+z2,xyz-w2;
sortvars(i,0,xy,1,zw);
@expansion{} [1]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x
@expansion{}    _[3]=w
@expansion{}    _[4]=z
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=y
@expansion{}       _[2]=x
@expansion{}    [2]:
@expansion{}       2,1
@expansion{}    [3]:
@expansion{}       2,3,
@expansion{}       1,1,
@expansion{}       2,0,
@expansion{}       0,2 
@expansion{}    [4]:
@expansion{}       1,1
@expansion{}    [5]:
@expansion{}       _[1]=w
@expansion{}       _[2]=z
@expansion{}    [6]:
@expansion{}       2,1
@expansion{}    [7]:
@expansion{}       2,2,
@expansion{}       2,1,
@expansion{}       0,2 
@expansion{}    [8]:
@expansion{}       1,1
@c end example sortvars d2t_singular/presolve_lib.doc:560
@end smallexample
@c ---end content sortvars---

@c ------------------- shortid -------------
@node shortid, valvars, sortvars, presolve_lib
@subsubsection shortid
@cindex shortid
@c ---content shortid---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
shortid(id,n[,e]); id= ideal/module, n,e=integers

@item @strong{Return:}
- if called with two arguments or e=0:
@* same type as id, containing generators of id having <= n terms.
@* - if called with three arguments and e!=0:
@* a list L:
@* L[1]: same type as id, containing generators of id having <= n terms.
@* L[2]: number of corresponding generator of id

@item @strong{Note:}
May be used to compute partial standard basis in case id is to hard

@end table
@strong{Example:}
@smallexample
@c reused example shortid d2t_singular/presolve_lib.doc:594 
LIB "presolve.lib";
ring s=0,(x,y,z,w),dp;
ideal i = (x3+y2+yw2)^2,(xz+z2)^2,xyz-w2-xzw; 
shortid(i,3);
@expansion{} _[1]=x2z2+2xz3+z4
@expansion{} _[2]=xyz-xzw-w2
@c end example shortid d2t_singular/presolve_lib.doc:594
@end smallexample
@c ---end content shortid---

@c ------------------- valvars -------------
@node valvars, idealSimplify, shortid, presolve_lib
@subsubsection valvars
@cindex valvars
@c ---content valvars---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
valvars(id[,n1,p1,n2,p2,...]);@*
id=poly/ideal/vector/module,@*
p1,p2,...= polynomials (product of vars),@*
n1,n2,...= integers,

ni controls the ordering of vars occurring in pi: ni=0 (resp.!=0) means
that less (resp. more) complex vars come first@*
(default: p1=product of all vars, n1=0)
@*the last pi (containing the remaining vars) may be omitted

@item @strong{Compute:}
valuation (complexity) of variables with respect to id.@*
ni controls the ordering of vars occurring in pi:@*
ni=0 (resp.!=0) means that less (resp. more) complex vars come first.

@item @strong{Return:}
list with 3 entries:
  @format
  [1]: intvec, say v, describing the permutation such that the permuted
       ringvariables are ordered with respect to their complexity in id
  [2]: list of intvecs, i-th intvec, say v(i) describing permutation
       of vars in a(i) such that v=v(1),v(2),...
  [3]: list of ideals and intmat's, say a(i) and M(i), where
       a(i): factors of pi,
       M(i): valuation matrix of a(i), such that the j-th column of M(i)
             is the valuation vector of j-th generator of a(i)
         @end format

@item @strong{Note:}
Use @code{sortvars} in order to actually sort the variables!
We define a variable x to be more complex than y (with respect to id)
if val(x) > val(y) lexicographically, where val(x) denotes the
valuation vector of x:@*
consider id as list of polynomials in x with coefficients in the
remaining variables. Then:@*
val(x) = (maximal occurring power of x, # of all monomials in leading
coefficient, # of all monomials in coefficient of next smaller power
of x,...).

@end table
@strong{Example:}
@smallexample
@c reused example valvars d2t_singular/presolve_lib.doc:654 
LIB "presolve.lib";
ring s=0,(x,y,z,a,b),dp;
ideal i=ax2+ay3-b2x,abz+by2;
valvars (i,0,xyz);
@expansion{} [1]:
@expansion{}    3,1,2,4,5
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       3,1,2
@expansion{}    [2]:
@expansion{}       1,2
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=x
@expansion{}       _[2]=y
@expansion{}       _[3]=z
@expansion{}    [2]:
@expansion{}       2,3,1,
@expansion{}       1,1,1,
@expansion{}       1,1,0 
@expansion{}    [3]:
@expansion{}       _[1]=a
@expansion{}       _[2]=b
@expansion{}    [4]:
@expansion{}       1,2,
@expansion{}       3,1,
@expansion{}       0,2 
@c end example valvars d2t_singular/presolve_lib.doc:654
@end smallexample
@c ---end content valvars---

@c ------------------- idealSimplify -------------
@node idealSimplify, idealSplit, valvars, presolve_lib
@subsubsection idealSimplify
@cindex idealSimplify
@c ---content idealSimplify---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
idealSimplify(id); id ideal

@item @strong{Return:}
ideal I = eliminate(Id,m) m is a product of variables
which are only linearly involved in the generators of id

@end table
@strong{Example:}
@smallexample
@c reused example idealSimplify d2t_singular/presolve_lib.doc:681 
LIB "presolve.lib";
ring r=0,(x,y,z,w,t),dp;
ideal i=
t,
x3+y2+2z,
x2+3y,
x2+y2+z2,
w2+z;
ideal j=idealSimplify(i);
ideal k=eliminate(i,zyt);
reduce(k,std(j));
@expansion{} _[1]=0
@expansion{} _[2]=0
reduce(j,std(k));
@expansion{} _[1]=0
@expansion{} _[2]=0
@c end example idealSimplify d2t_singular/presolve_lib.doc:681
@end smallexample
@c ---end content idealSimplify---

@c ------------------- idealSplit -------------
@node idealSplit,, idealSimplify, presolve_lib
@subsubsection idealSplit
@cindex idealSplit
@c ---content idealSplit---
Procedure from library @code{presolve.lib} (@pxref{presolve_lib}).

@table @asis
@item @strong{Usage:}
idealSplit(id,timeF,timeS); id ideal and optional
@*timeF ,timeS integers to bound the time which can be used
for factorization resp. standard basis computation

@item @strong{Return:}
a list of ideals such that their intersection
@*has the same radical as id

@end table
@strong{Example:}
@smallexample
@c reused example idealSplit d2t_singular/presolve_lib.doc:718 
LIB "presolve.lib";
ring r=32003,(b,s,t,u,v,w,x,y,z),dp;
ideal i=
bv+su,
bw+tu,
sw+tv,
by+sx,
bz+tx,
sz+ty,
uy+vx,
uz+wx,
vz+wy,
bvz;
idealSplit(i);
@expansion{} [1]:
@expansion{}    _[1]=x
@expansion{}    _[2]=u
@expansion{}    _[3]=t
@expansion{}    _[4]=s
@expansion{}    _[5]=b
@expansion{}    _[6]=wy+vz
@expansion{} [2]:
@expansion{}    _[1]=z
@expansion{}    _[2]=w
@expansion{}    _[3]=t
@expansion{}    _[4]=s
@expansion{}    _[5]=b
@expansion{}    _[6]=vx+uy
@expansion{} [3]:
@expansion{}    _[1]=z
@expansion{}    _[2]=x
@expansion{}    _[3]=w
@expansion{}    _[4]=u
@expansion{}    _[5]=t
@expansion{}    _[6]=b
@expansion{} [4]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=t
@expansion{}    _[5]=s
@expansion{}    _[6]=b
@expansion{} [5]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=u
@expansion{}    _[5]=b
@expansion{}    _[6]=tv+sw
@expansion{} [6]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=w
@expansion{}    _[5]=t
@expansion{}    _[6]=su+bv
@expansion{} [7]:
@expansion{}    _[1]=w
@expansion{}    _[2]=v
@expansion{}    _[3]=u
@expansion{}    _[4]=t
@expansion{}    _[5]=s
@expansion{}    _[6]=b
@expansion{} [8]:
@expansion{}    _[1]=x
@expansion{}    _[2]=w
@expansion{}    _[3]=v
@expansion{}    _[4]=u
@expansion{}    _[5]=b
@expansion{}    _[6]=ty+sz
@expansion{} [9]:
@expansion{}    _[1]=z
@expansion{}    _[2]=w
@expansion{}    _[3]=v
@expansion{}    _[4]=u
@expansion{}    _[5]=t
@expansion{}    _[6]=sx+by
@expansion{} [10]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=w
@expansion{}    _[5]=v
@expansion{}    _[6]=u
@expansion{} [11]:
@expansion{}    _[1]=y
@expansion{}    _[2]=v
@expansion{}    _[3]=t
@expansion{}    _[4]=s
@expansion{}    _[5]=b
@expansion{}    _[6]=wx+uz
@expansion{} [12]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x
@expansion{}    _[3]=v
@expansion{}    _[4]=u
@expansion{}    _[5]=s
@expansion{}    _[6]=b
@expansion{} [13]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=x
@expansion{}    _[4]=v
@expansion{}    _[5]=s
@expansion{}    _[6]=tu+bw
@expansion{} [14]:
@expansion{}    _[1]=z
@expansion{}    _[2]=y
@expansion{}    _[3]=w
@expansion{}    _[4]=v
@expansion{}    _[5]=t
@expansion{}    _[6]=s
@expansion{} [15]:
@expansion{}    _[1]=y
@expansion{}    _[2]=w
@expansion{}    _[3]=v
@expansion{}    _[4]=u
@expansion{}    _[5]=s
@expansion{}    _[6]=tx+bz
@c end example idealSplit d2t_singular/presolve_lib.doc:718
@end smallexample
@c ---end content idealSplit---
@c ---------------------------------------------------------
@node solve_lib, triang_lib, presolve_lib, Symbolic-numerical solving
@subsection solve_lib
@c include of docu for solve.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/solve_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/solve_lib.doc INSTEAD
@c library version: (1.21.2.14,2003/05/16)
@c library file: ../Singular/LIB/solve.lib
@cindex solve.lib
@cindex solve_lib
@table @asis
@item @strong{Library:}
solve.lib
@item @strong{Purpose:}
     Complex Solving of Polynomial Systems
@item @strong{Author:}
Moritz Wenk, email: wenk@@mathematik.uni-kl.de
@*Wilfred Pohl, email: pohl@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* laguerre_solve:: find all roots of univariate polynomial p
* solve:: all roots of 0-dim. ideal i using triangular sets
* ures_solve:: find all roots of 0-dimensional ideal i with resultants
* mp_res_mat:: multipolynomial resultant matrix of ideal i
* interpolate:: interpolate poly from evaluation points i and results j
* fglm_solve:: find roots of 0-dim. ideal using FGLM and lex_solve
* lex_solve:: find roots of reduced lexicographic standard basis
* simplexOut:: prints solution of simplex in nice format
* triangLf_solve:: find roots using triangular sys. (factorizing Lazard)
* triangM_solve:: find roots of given triangular system (Moeller)
* triangL_solve:: find roots using triangular system (Lazard)
* triang_solve:: find roots of given triangular system
@end menu
@c ---end content LibInfo---

@c ------------------- laguerre_solve -------------
@node laguerre_solve, solve,, solve_lib
@subsubsection laguerre_solve
@cindex laguerre_solve
@c ---content laguerre_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
laguerre_solve(f [, m, l, n, s] ); f = polynomial,@*
m, l, n, s = integers (control parameters of the method)
@format
 m: precision of output in digits ( 4 <= m), if basering is not ring of 
      complex numbers;
 l: precision of internal computation in decimal digits ( l >=8 )
      only if the basering is not complex or complex with smaller precision;
 n: control of multiplicity of roots or of splitting of f into
      squarefree factors
      n < 0, no split of f (good, if all roots are simple)
      n >= 0, try to split
      n = 0, return only different roots
      n > 0, find all roots (with multiplicity)
 s: s != 0, returns ERROR if  | f(root) | > 0.1^m (when computing in the 
      current ring)
 ( default: m, l, n, s = 8, 30, 1, 0 )
@end format

@item @strong{Assume:}
f is a univariate polynomial;@*
basering has characteristic 0 and is either complex or without
parameters.

@item @strong{Return:}
list of (complex) roots of the polynomial f, depending on n. The
result is of type
@format
 string: if the basering is not complex,
 number: otherwise.
@end format

@item @strong{Note:}
If printlevel >0: displays comments ( default = 0 ).
@*If s != 0 and if the procedure stops with ERROR, try a higher
internal precision m.

@end table
@strong{Example:}
@smallexample
@c reused example laguerre_solve d2t_singular/solve_lib.doc:82 
LIB "solve.lib";
// Find all roots of an univariate polynomial using Laguerre's method:
ring rs1= 0,(x,y),lp;
poly f = 15x5 + x3 + x2 - 10;
// 10 digits precision
laguerre_solve(f,10);
@expansion{} [1]:
@expansion{}    (0.2930464644-i*0.9003002396)
@expansion{} [2]:
@expansion{}    (0.2930464644+i*0.9003002396)
@expansion{} [3]:
@expansion{}    (-0.7392783383-i*0.5355190078)
@expansion{} [4]:
@expansion{}    (-0.7392783383+i*0.5355190078)
@expansion{} [5]:
@expansion{}    0.8924637479
// Now with complex coefficients,
// internal precision is 30 digits (default)
printlevel=2;
ring rsc= (real,10,i),x,lp;
poly f = (15.4+i*5)*x^5 + (25.0e-2+i*2)*x^3 + x2 - 10*i;
list l = laguerre_solve(f);
@expansion{} //BEGIN laguerre_solve
@expansion{} //control: complex ring with precision 30
@expansion{} //working in:  ring lagc=(complex,30,30),x,lp;
@expansion{} //         polynomial has complex coefficients
@expansion{} //split in working ring:
@expansion{} // split without result
@expansion{} //END laguerre_solve
l;
@expansion{} [1]:
@expansion{}    (0.04588498039+i*0.9133296179)
@expansion{} [2]:
@expansion{}    (0.5037408279-i*0.8058051828)
@expansion{} [3]:
@expansion{}    (-0.5462895588-i*0.6796668873)
@expansion{} [4]:
@expansion{}    (0.8524014357+i*0.2163760334)
@expansion{} [5]:
@expansion{}    (-0.8557376852+i*0.3557664188)
// check result, value of substituted poly should be near to zero
// remember that l contains a list of strings
// in the case of a different ring
subst(f,x,l[1]);
@expansion{} 0
subst(f,x,l[2]);
@expansion{} 0
@c end example laguerre_solve d2t_singular/solve_lib.doc:82
@end smallexample
@c ---end content laguerre_solve---

@c ------------------- solve -------------
@node solve, ures_solve, laguerre_solve, solve_lib
@subsubsection solve
@cindex solve
@c ---content solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Assume:}
the ideal is 0-dimensional;@*
basering has characteristic 0 and is either complex or
without parameters;

@item @strong{Return:}
list of solutions of the ideal G, depending on n; one solution is a
list of complex numbers in the generated output ring (the new
basering).
@format
 The result is a list L
    n  = 0: a list of all different solutions (L[i]),
    n != 0: a list of two elements,
            L[i][1] contains all different solutions with the same multiplicity
            L[i][2] the multiplicity
 L is ordered w.r.t. multiplicity (the smallest first).
@end format

@item @strong{Note:}
If the problem is not 0-dim. the procedure stops with ERROR, if the
ideal G is not a lex. standard basis, it is generated with internal
computation (Hilbert driven), if the input-ring (with char 0) has
the name "<A>", the lexicographical and complex output-ring has the
name "<A>C".

@end table
@strong{Example:}
@smallexample
@c reused example solve d2t_singular/solve_lib.doc:141 
LIB "solve.lib";
// Find all roots of a multivariate ideal using triangular sets:
int d=4;// with these 3 parameters you may construct
int t=3;// very hard problems for 'solve'
int s=2;
int i;
ring A=0,(x(1..d)),dp;
poly p=-1;
for(i=d;i>0;i--)@{p=p+x(i)^s;@}
ideal I=x(d)^t-x(d)^s+p;
for(i=d-1;i>0;i--)@{I=x(i)^t-x(i)^s+p,I;@}
I;
@expansion{} I[1]=x(1)^3+x(2)^2+x(3)^2+x(4)^2-1
@expansion{} I[2]=x(2)^3+x(1)^2+x(3)^2+x(4)^2-1
@expansion{} I[3]=x(3)^3+x(1)^2+x(2)^2+x(4)^2-1
@expansion{} I[4]=x(4)^3+x(1)^2+x(2)^2+x(3)^2-1
// the mutiplicity is
vdim(std(I));
@expansion{} 81
list l1=solve(I,6,0);
@expansion{} // name of new current ring: AC
// the current ring is
AC;
@expansion{} //   characteristic : 0 (complex:6 digits, additional 6 digits)
@expansion{} //   1 parameter    : i 
@expansion{} //   minpoly        : (i^2+1)
@expansion{} //   number of vars : 4
@expansion{} //        block   1 : ordering lp
@expansion{} //                  : names    x(1) x(2) x(3) x(4) 
@expansion{} //        block   2 : ordering C
// you must start with char. 0
setring A;
list l2=solve(I,6,1);
@expansion{} // name of current ring: AC
// the number of different solutions is
size(l1);
@expansion{} 37
// this is equal to
size(l2[1][1])+size(l2[2][1]);
@expansion{} 37
// the number of solutions with multiplicity is
size(l2[1][1])*l2[1][2]+size(l2[2][1])*l2[2][2];
@expansion{} 81
// the solutions with multiplicity
l2[2][2];
@expansion{} 12
// are
l2[2][1];
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       0
@expansion{}    [2]:
@expansion{}       0
@expansion{}    [3]:
@expansion{}       1
@expansion{}    [4]:
@expansion{}       0
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       0
@expansion{}    [2]:
@expansion{}       1
@expansion{}    [3]:
@expansion{}       0
@expansion{}    [4]:
@expansion{}       0
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       0
@expansion{}    [3]:
@expansion{}       0
@expansion{}    [4]:
@expansion{}       0
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       0
@expansion{}    [2]:
@expansion{}       0
@expansion{}    [3]:
@expansion{}       0
@expansion{}    [4]:
@expansion{}       1
@c end example solve d2t_singular/solve_lib.doc:141
@end smallexample
@c ---end content solve---

@c ------------------- ures_solve -------------
@node ures_solve, mp_res_mat, solve, solve_lib
@subsubsection ures_solve
@cindex ures_solve
@c ---content ures_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
ures_solve(i [, k, p] ); i = ideal, k, p = integers
@format
   k=0: use sparse resultant matrix of Gelfand, Kapranov and Zelevinsky,
   k=1: use resultant matrix of Macaulay which works only for
          homogeneous ideals,
   p>0: defines precision of the long floats for internal computation
          if the basering is not complex (in decimal digits),
   (default: k=0, p=30)
@end format

@item @strong{Assume:}
i is a zerodimensional ideal with
@*nvars(basering) = ncols(i) = number of vars
@*actually occurring in i,

@item @strong{Return:}
list of all (complex) roots of the polynomial system i = 0; the
result is of type
@format
   string: if the basering is not complex,
   number: otherwise.
@end format

@end table
@strong{Example:}
@smallexample
@c reused example ures_solve d2t_singular/solve_lib.doc:211 
LIB "solve.lib";
// compute the intersection points of two curves
ring rsq = 0,(x,y),lp;
ideal gls=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
ures_solve(gls,0,16);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       2.82842712474619
@expansion{}    [2]:
@expansion{}       1.414213562373095
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -2.82842712474619
@expansion{}    [2]:
@expansion{}       -1.414213562373095
// result is a list (x,y)-coordinates as strings
// now with complex coefficient field, precision is 20 digits
ring rsc= (real,20,I),(x,y),lp;
ideal i = (2+3*I)*x2 + (0.35+I*45.0e-2)*y2 - 8, x2 + xy + (42.7)*y2;
list l= ures_solve(i,0,10);
// result is a list of (x,y)-coordinates of complex numbers
l;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       (-1.315392899374542198+I*0.70468233142752928117)
@expansion{}    [2]:
@expansion{}       (0.12292646536251281054+I*0.19245727404407015049)
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       (1.315392899374542198-I*0.70468233142752928117)
@expansion{}    [2]:
@expansion{}       (-0.12292646536251281054-I*0.19245727404407015049)
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       (1.31584587549391830705-I*0.70396753310002259573)
@expansion{}    [2]:
@expansion{}       (0.092006639590217681983+I*0.20902112035965287775)
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       (-1.31584587549391830705+I*0.70396753310002259573)
@expansion{}    [2]:
@expansion{}       (-0.092006639590217681983-I*0.20902112035965287775)
// check the result
subst(subst(i[1],x,l[1][1]),y,l[1][2]);
@expansion{} 0
@c end example ures_solve d2t_singular/solve_lib.doc:211
@end smallexample
@c ---end content ures_solve---

@c ------------------- mp_res_mat -------------
@node mp_res_mat, interpolate, ures_solve, solve_lib
@subsubsection mp_res_mat
@cindex mp_res_mat
@c ---content mp_res_mat---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
mp_res_mat(i [, k] ); i ideal, k integer,
@format
    k=0: sparse resultant matrix of Gelfand, Kapranov and Zelevinsky,
    k=1: resultant matrix of Macaulay (k=0 is default)
@end format

@item @strong{Assume:}
The number of elements in the input system must be the number of
variables in the basering plus one;
@*if k=1 then i must be homogeneous.

@item @strong{Return:}
module representing the multipolynomial resultant matrix

@end table
@strong{Example:}
@smallexample
@c reused example mp_res_mat d2t_singular/solve_lib.doc:256 
LIB "solve.lib";
// compute resultant matrix in ring with parameters (sparse resultant matrix)
ring rsq= (0,u0,u1,u2),(x1,x2),lp;
ideal i= u0+u1*x1+u2*x2,x1^2 + x2^2 - 10,x1^2 + x1*x2 + 2*x2^2 - 16;
module m = mp_res_mat(i);
print(m);
@expansion{} -16,0,  -10,0,  (u0),0,   0,  0,   0,   0,  
@expansion{} 0,  -16,0,  -10,(u2),(u0),0,  0,   0,   0,  
@expansion{} 2,  0,  1,  0,  0,   (u2),0,  0,   0,   0,  
@expansion{} 0,  2,  0,  1,  0,   0,   0,  0,   0,   0,  
@expansion{} 0,  0,  0,  0,  (u1),0,   -10,(u0),0,   -16,
@expansion{} 1,  0,  0,  0,  0,   (u1),0,  (u2),(u0),0,  
@expansion{} 0,  1,  0,  0,  0,   0,   1,  0,   (u2),2,  
@expansion{} 1,  0,  1,  0,  0,   0,   0,  (u1),0,   0,  
@expansion{} 0,  1,  0,  1,  0,   0,   0,  0,   (u1),1,  
@expansion{} 0,  0,  0,  0,  0,   0,   1,  0,   0,   1   
// computing sparse resultant
det(m);
@expansion{} (-2*u0^4+18*u0^2*u1^2+4*u0^2*u1*u2+22*u0^2*u2^2-16*u1^4+80*u1^3*u2-52*u1^\
   2*u2^2-120*u1*u2^3-36*u2^4)
// compute resultant matrix (Macaulay resultant matrix)
ring rdq= (0,u0,u1,u2),(x0,x1,x2),lp;
ideal h=  homog(imap(rsq,i),x0);
h;
@expansion{} h[1]=(u0)*x0+(u1)*x1+(u2)*x2
@expansion{} h[2]=-10*x0^2+x1^2+x2^2
@expansion{} h[3]=-16*x0^2+x1^2+x1*x2+2*x2^2
module m = mp_res_mat(h,1);
print(m);
@expansion{} x0, x1, x2, 0, 0, 0, 0,0, 0, 0,
@expansion{} 0,  x0, 0,  x1,x2,0, 0,0, 0, 0,
@expansion{} 0,  0,  x0, 0, x1,x2,0,0, 0, 0,
@expansion{} -10,0,  0,  1, 0, 1, 0,0, 0, 0,
@expansion{} 0,  0,  0,  0, x0,0, 0,x1,x2,0,
@expansion{} -16,0,  0,  1, 1, 2, 0,0, 0, 0,
@expansion{} 0,  -10,0,  0, 0, 0, 1,0, 1, 0,
@expansion{} 0,  0,  -10,0, 0, 0, 0,1, 0, 1,
@expansion{} 0,  -16,0,  0, 0, 0, 1,1, 2, 0,
@expansion{} 0,  0,  -16,0, 0, 0, 0,1, 1, 2 
// computing Macaulay resultant (should be the same as above!)
det(m);
@expansion{} 2*x0^4-18*x0^2*x1^2-4*x0^2*x1*x2-22*x0^2*x2^2+16*x1^4-80*x1^3*x2+52*x1^2*\
   x2^2+120*x1*x2^3+36*x2^4
// compute numerical sparse resultant matrix
setring rsq;
ideal ir= 15+2*x1+5*x2,x1^2 + x2^2 - 10,x1^2 + x1*x2 + 2*x2^2 - 16;
module mn = mp_res_mat(ir);
print(mn);
@expansion{} 15,0, -10,0,  0, 0, 0,  -16,0,  0,  
@expansion{} 5, 15,0,  -10,0, 0, 0,  0,  -16,0,  
@expansion{} 0, 5, 1,  0,  0, 0, 0,  2,  0,  0,  
@expansion{} 0, 0, 0,  1,  0, 0, 0,  0,  2,  0,  
@expansion{} 2, 0, 0,  0,  15,0, -10,0,  0,  -16,
@expansion{} 0, 2, 0,  0,  5, 15,0,  1,  0,  0,  
@expansion{} 0, 0, 0,  0,  0, 5, 1,  0,  1,  2,  
@expansion{} 0, 0, 1,  0,  2, 0, 0,  1,  0,  0,  
@expansion{} 0, 0, 0,  1,  0, 2, 0,  0,  1,  1,  
@expansion{} 0, 0, 0,  0,  0, 0, 1,  0,  0,  1   
// computing sparse resultant
det(mn);
@expansion{} -7056
@c end example mp_res_mat d2t_singular/solve_lib.doc:256
@end smallexample
@c ---end content mp_res_mat---

@c ------------------- interpolate -------------
@node interpolate, fglm_solve, mp_res_mat, solve_lib
@subsubsection interpolate
@cindex interpolate
@c ---content interpolate---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
interpolate(p,v,d); p,v=ideals of numbers, d=integer

@item @strong{Assume:}
Ground field K is the field of rational numbers, p and v are lists
of elements of the ground field K with p[j] != -1,0,1, size(p) = n
(= number of vars) and size(v)=N=(d+1)^n.

@item @strong{Return:}
poly f, the unique polynomial f of degree n*d with prescribed values
v[i] at the points p(i)=(p[1]^(i-1),..,p[n]^(i-1)), i=1,..,N.

@item @strong{Note:}
mainly useful when n=1, i.e. f is satisfying f(p^(i-1)) = v[i],
i=1..d+1.

@end table
@strong{Example:}
@smallexample
@c reused example interpolate d2t_singular/solve_lib.doc:311 
LIB "solve.lib";
ring r1 = 0,(x),lp;
// determine f with deg(f) = 4 and
// v = values of f at points 3^0, 3^1, 3^2, 3^3, 3^4
ideal v=16,0,11376,1046880,85949136;
interpolate( 3, v, 4 );
@expansion{} 2x4-22x2+36
@c end example interpolate d2t_singular/solve_lib.doc:311
@end smallexample
@c inserted refs from d2t_singular/solve_lib.doc:320
@menu
See also:
* vandermonde::
@end menu
@c end inserted refs from d2t_singular/solve_lib.doc:320

@c ---end content interpolate---

@c ------------------- fglm_solve -------------
@node fglm_solve, lex_solve, interpolate, solve_lib
@subsubsection fglm_solve
@cindex fglm_solve
@c ---content fglm_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
fglm_solve(i [, p] ); i ideal, p integer

@item @strong{Assume:}
the ground field has char 0.

@item @strong{Return:}
a list of numbers, the complex roots of i;
@*p>0: gives precision of complex numbers in decimal digits (default:
p=30).

@item @strong{Note:}
The procedure uses a standard basis of i to determine all complex
roots of i.
@*It creates a ring rC with the same number of variables but with
complex coefficients (and precision p).

@end table
@strong{Example:}
@smallexample
@c reused example fglm_solve d2t_singular/solve_lib.doc:354 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
fglm_solve(s,10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@c end example fglm_solve d2t_singular/solve_lib.doc:354
@end smallexample
@c ---end content fglm_solve---

@c ------------------- lex_solve -------------
@node lex_solve, simplexOut, fglm_solve, solve_lib
@subsubsection lex_solve
@cindex lex_solve
@c ---content lex_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
lex_solve( i[,p] ); i=ideal, p=integer,
 @format
  p>0: gives precision of complex numbers in decimal digits (default: p=30).
 @end format

@item @strong{Assume:}
i is a reduced lexicographical Groebner bases of a zero-dimensional
ideal, sorted by increasing leading terms.

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a complec ring with the same variables but
with complex coefficients (and precision p).
@*In this ring a list rlist of numbers is created, in which the complex
roots of i are stored.

@end table
@strong{Example:}
@smallexample
@c reused example lex_solve d2t_singular/solve_lib.doc:395 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
lex_solve(stdfglm(s),10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@c end example lex_solve d2t_singular/solve_lib.doc:395
@end smallexample
@c ---end content lex_solve---

@c ------------------- simplexOut -------------
@node simplexOut, triangLf_solve, lex_solve, solve_lib
@subsubsection simplexOut
@cindex simplexOut
@c ---content simplexOut---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
simplexOut(l); l list

@item @strong{Assume:}
l is the output of simplex.

@item @strong{Return:}
nothing. The procedure prints the computed solution of simplex
(as strings) in a nice format.

@end table
@strong{Example:}
@smallexample
@c reused example simplexOut d2t_singular/solve_lib.doc:427 
LIB "solve.lib";
ring r = (real,10),(x),lp;
// consider the max. problem:
//
//    maximize  x(1) + x(2) + 3*x(3) - 0.5*x(4)
//
//  with constraints:   x(1) +          2*x(3)          <= 740
//                             2*x(2)          - 7*x(4) <=   0
//                               x(2) -   x(3) + 2*x(4) >=   0.5
//                      x(1) +   x(2) +   x(3) +   x(4)  =   9
//
matrix sm[5][5]=   0, 1, 1, 3,-0.5,
740,-1, 0,-2, 0,
0, 0,-2, 0, 7,
0.5, 0,-1, 1,-2,
9,-1,-1,-1,-1;
int n = 4;  // number of constraints
int m = 4;  // number of variables
int m1= 2;  // number of <= constraints
int m2= 1;  // number of >= constraints
int m3= 1;  // number of == constraints
list sol=simplex(sm, n, m, m1, m2, m3);
simplexOut(sol);
@expansion{} z = 17.025
@expansion{} x2 = 3.325
@expansion{} x4 = 0.95
@expansion{} x3 = 4.725
@c end example simplexOut d2t_singular/solve_lib.doc:427
@end smallexample
@c inserted refs from d2t_singular/solve_lib.doc:453
@menu
See also:
* simplex::
@end menu
@c end inserted refs from d2t_singular/solve_lib.doc:453

@c ---end content simplexOut---

@c ------------------- triangLf_solve -------------
@node triangLf_solve, triangM_solve, simplexOut, solve_lib
@subsubsection triangLf_solve
@cindex triangLf_solve
@c ---content triangLf_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
triangLf_solve(i [, p] ); i ideal, p integer,
@*p>0: gives precision of complex numbers in digits (default: p=30).

@item @strong{Assume:}
the ground field has char 0; i is a zero-dimensional ideal

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a ring rC with the same number of variables but
with complex coefficients (and precision p).@*
In rC a list rlist of numbers is created, in which the complex
roots of i are stored.@*
The proc uses a triangular system (Lazard's Algorithm with
factorization) computed from a standard basis to determine recursively
all complex roots with Laguerre's algorithm of input ideal i.

@end table
@strong{Example:}
@smallexample
@c reused example triangLf_solve d2t_singular/solve_lib.doc:489 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
triangLf_solve(s,10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@c end example triangLf_solve d2t_singular/solve_lib.doc:489
@end smallexample
@c ---end content triangLf_solve---

@c ------------------- triangM_solve -------------
@node triangM_solve, triangL_solve, triangLf_solve, solve_lib
@subsubsection triangM_solve
@cindex triangM_solve
@c ---content triangM_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
triangM_solve(i [, p ] ); i=ideal, p=integer,
@*p>0: gives precision of complex numbers in digits (default: p=30).

@item @strong{Assume:}
the ground field has char 0;@*
i zero-dimensional ideal

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a ring rC with the same number of variables but
with complex coefficients (and precision p).@*
In rC a list rlist of numbers is created, in which the complex
roots of i are stored.@*
The proc uses a triangular system (Moellers Algorithm) computed from a
standard basis to determine recursively all complex roots with
Laguerre's algorithm of input ideal i.

@end table
@strong{Example:}
@smallexample
@c reused example triangM_solve d2t_singular/solve_lib.doc:531 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
triangM_solve(s,10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@c end example triangM_solve d2t_singular/solve_lib.doc:531
@end smallexample
@c ---end content triangM_solve---

@c ------------------- triangL_solve -------------
@node triangL_solve, triang_solve, triangM_solve, solve_lib
@subsubsection triangL_solve
@cindex triangL_solve
@c ---content triangL_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
triangL_solve(i [, p] ); i=ideal, p=integer,@*
p>0: gives precision of complex numbers in digits (default: p=30).

@item @strong{Assume:}
the ground field has char 0; i is a zero-dimensional ideal.

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a ring rC with the same number of variables but
with complex coefficients (and precision p).@*
In rC a list rlist of numbers is created, in which the complex
roots of i are stored.@*
The proc uses a triangular system (Lazard's Algorithm) computed from
a standard basis to determine recursively all complex roots with
Laguerre's algorithm of input ideal i.

@end table
@strong{Example:}
@smallexample
@c reused example triangL_solve d2t_singular/solve_lib.doc:572 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
triangL_solve(s,10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@c end example triangL_solve d2t_singular/solve_lib.doc:572
@end smallexample
@c ---end content triangL_solve---

@c ------------------- triang_solve -------------
@node triang_solve,, triangL_solve, solve_lib
@subsubsection triang_solve
@cindex triang_solve
@c ---content triang_solve---
Procedure from library @code{solve.lib} (@pxref{solve_lib}).

@table @asis
@item @strong{Usage:}
triang_solve(l,p [, d] ); l=list, p,d=integers,@*
l a list of finitely many triangular systems, such that the union of
their varieties equals the variety of the initial ideal.@*
p>0: gives precision of complex numbers in digits,@*
d>0: gives precision (1<d<p) for near-zero-determination,@*
(default: d=1/2*p).

@item @strong{Assume:}
the ground field has char 0;@*
l was computed using Algorithm of Lazard or Algorithm of Moeller
(see triang.lib).

@item @strong{Return:}
nothing

@item @strong{Create:}
The procedure creates a ring rC with the same number of variables but
with complex coefficients (and precision p).@*
In rC a list rlist of numbers is created, in which the complex
roots of i are stored.@*

@end table
@strong{Example:}
@smallexample
@c reused example triang_solve d2t_singular/solve_lib.doc:616 
LIB "solve.lib";
ring r = 0,(x,y),lp;
// compute the intersection points of two curves
ideal s=  x2 + y2 - 10, x2 + xy + 2y2 - 16;
triang_solve(triangLfak(stdfglm(s)),10);
@expansion{} // name of new ring: rC
@expansion{} // list of roots: rlist
rlist;
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       -1
@expansion{}    [2]:
@expansion{}       3
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       -3
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       2.8284271247
@expansion{}    [2]:
@expansion{}       1.4142135624
@expansion{} [4]:
@expansion{}    [1]:
@expansion{}       -2.8284271247
@expansion{}    [2]:
@expansion{}       -1.4142135624
@c end example triang_solve d2t_singular/solve_lib.doc:616
@end smallexample
@c ---end content triang_solve---
@c ---------------------------------------------------------
@node triang_lib, ntsolve_lib,  solve_lib, Symbolic-numerical solving
@subsection triang_lib
@c include of docu for triang.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/triang_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/triang_lib.doc INSTEAD
@c library version: (1.7,2001/02/19)
@c library file: ../Singular/LIB/triang.lib
@cindex triang.lib
@cindex triang_lib
@table @asis
@item @strong{Library:}
triang.lib
@item @strong{Purpose:}
   Decompose Zero-dimensional Ideals into Triangular Sets
@item @strong{Author:}
D. Hillebrand

@end table

@strong{Procedures:}
@menu
* triangL:: Decomposition of (G) into triangular systems (Lazard).
* triangLfak:: Decomp. of (G) into tri. systems plus factorization.
* triangM:: Decomposition of (G) into triangular systems (Moeller).
* triangMH:: Decomp. of (G) into tri. syst. with disjoint varieties.
@end menu
@c ---end content LibInfo---

@c ------------------- triangL -------------
@node triangL, triangLfak,, triang_lib
@subsubsection triangL
@cindex triangL
@c ---content triangL---
Procedure from library @code{triang.lib} (@pxref{triang_lib}).

@table @asis
@item @strong{Usage:}
triangL(G); G=ideal

@item @strong{Assume:}
G is the reduced lexicographical Groebner bases of the
zero-dimensional ideal (G), sorted by increasing leading terms.

@item @strong{Return:}
a list of finitely many triangular systems, such that
the union of their varieties equals the variety of (G).

@item @strong{Note:}
Algorithm of Lazard (see: Lazard, D.: Solving zero-dimensional
algebraic systems, J. Symb. Comp. 13, 117 - 132, 1992).

@end table
@strong{Example:}
@smallexample
@c skipped computation of example triangL d2t_singular/triang_lib.doc:51 
LIB "triang.lib";
ring rC5 = 0,(e,d,c,b,a),lp;
triangL(stdfglm(cyclic(5)));
@end smallexample
@c ---end content triangL---

@c ------------------- triangLfak -------------
@node triangLfak, triangM, triangL, triang_lib
@subsubsection triangLfak
@cindex triangLfak
@c ---content triangLfak---
Procedure from library @code{triang.lib} (@pxref{triang_lib}).

@table @asis
@item @strong{Usage:}
triangLfak(G); G=ideal

@item @strong{Assume:}
G is the reduced lexicographical Groebner bases of the
zero-dimensional ideal (G), sorted by increasing leading terms.

@item @strong{Return:}
a list of finitely many triangular systems, such that
the union of their varieties equals the variety of (G).

@item @strong{Note:}
Algorithm of Lazard with factorization (see: Lazard, D.: Solving
zero-dimensional algebraic systems, J. Symb. Comp. 13, 117 - 132, 1992).

@item @strong{Remark:}
each polynomial of the triangular systems is factorized.

@end table
@strong{Example:}
@smallexample
@c skipped computation of example triangLfak d2t_singular/triang_lib.doc:88 
LIB "triang.lib";
ring rC5 = 0,(e,d,c,b,a),lp;
triangLfak(stdfglm(cyclic(5)));
@end smallexample
@c ---end content triangLfak---

@c ------------------- triangM -------------
@node triangM, triangMH, triangLfak, triang_lib
@subsubsection triangM
@cindex triangM
@c ---content triangM---
Procedure from library @code{triang.lib} (@pxref{triang_lib}).

@table @asis
@item @strong{Usage:}
triangM(G[,i]); G=ideal, i=integer,@*

@item @strong{Assume:}
G is the reduced lexicographical Groebner bases of the
zero-dimensional ideal (G), sorted by increasing leading terms.

@item @strong{Return:}
a list of finitely many triangular systems, such that
the union of their varieties equals the variety of (G).
If i = 2, then each polynomial of the triangular systems
is factorized.

@item @strong{Note:}
Algorithm of Moeller (see: Moeller, H.M.:
@*On decomposing systems of polynomial equations with
@*finitely many solutions, Appl. Algebra Eng. Commun. Comput. 4,
217 - 230, 1993).

@end table
@strong{Example:}
@smallexample
@c skipped computation of example triangM d2t_singular/triang_lib.doc:126 
LIB "triang.lib";
ring rC5 = 0,(e,d,c,b,a),lp;
triangM(stdfglm(cyclic(5))); //oder: triangM(stdfglm(cyclic(5)),2);
@end smallexample
@c ---end content triangM---

@c ------------------- triangMH -------------
@node triangMH,, triangM, triang_lib
@subsubsection triangMH
@cindex triangMH
@c ---content triangMH---
Procedure from library @code{triang.lib} (@pxref{triang_lib}).

@table @asis
@item @strong{Usage:}
triangMH(G[,i]); G=ideal, i=integer

@item @strong{Assume:}
G is the reduced lexicographical Groebner bases of the
zero-dimensional ideal (G), sorted by increasing leading terms.

@item @strong{Return:}
a list of finitely many triangular systems, such that
the disjoint union of their varieties equals the variety of (G).
If i = 2, then each polynomial of the triangular systems is factorized.

@item @strong{Note:}
Algorithm of Moeller and Hillebrand (see: Moeller, H.M.:
On decomposing systems of polynomial equations with finitely many
solutions, Appl. Algebra Eng. Commun. Comput. 4, 217 - 230, 1993 and
Hillebrand, D.: Triangulierung nulldimensionaler Ideale -
Implementierung und Vergleich zweier Algorithmen, master thesis,
Universitaet Dortmund, Fachbereich Mathematik, Prof. Dr. H.M. Moeller,
1999).

@end table
@strong{Example:}
@smallexample
@c skipped computation of example triangMH d2t_singular/triang_lib.doc:166 
LIB "triang.lib";
ring rC5 = 0,(e,d,c,b,a),lp;
triangMH(stdfglm(cyclic(5)));
@end smallexample
@c ---end content triangMH---
@c ---------------------------------------------------------
@node ntsolve_lib, zeroset_lib, triang_lib, Symbolic-numerical solving
@subsection ntsolve_lib
@c include of docu for ntsolve.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/ntsolve_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/ntsolve_lib.doc INSTEAD
@c library version: (1.12.2.1,2002/04/12)
@c library file: ../Singular/LIB/ntsolve.lib
@cindex ntsolve.lib
@cindex ntsolve_lib
@table @asis
@item @strong{Library:}
ntsolve.lib
@item @strong{Purpose:}
     Real Newton Solving of Polynomial Systems
@item @strong{Authors:}
Wilfred Pohl, email: pohl@@mathematik.uni-kl.de
@*Dietmar Hillebrand

@end table

@strong{Procedures:}
@menu
* nt_solve:: find one real root of 0-dimensional ideal G
* triMNewton:: find one real root for 0-dim triangular system G
@end menu
@c ---end content LibInfo---

@c ------------------- nt_solve -------------
@node nt_solve, triMNewton,, ntsolve_lib
@subsubsection nt_solve
@cindex nt_solve
@c ---content nt_solve---
Procedure from library @code{ntsolve.lib} (@pxref{ntsolve_lib}).

@table @asis
@item @strong{Usage:}
nt_solve(gls,ini[,ipar]); gls,ini= ideals, ipar=list/intvec,@*
gls: contains the equations, for which a solution will be computed
ini: ideal of initial values (approximate solutions to start with),@*
ipar: control integers (default: ipar = 100,10)
  @format
 ipar[1]: max. number of iterations
 ipar[2]: accuracy (we have the l_2-norm ||.||): accept solution @code{sol}
          if ||gls(sol)|| < eps0*(0.1^ipar[2])
          where eps0 = ||gls(ini)|| is the initial error
  @end format

@item @strong{Assume:}
gls is a zerodimensional ideal with nvars(basering) = size(gls) (>1)

@item @strong{Return:}
ideal, coordinates of one solution (if found), 0 else

@item @strong{Note:}
if printlevel >0: displays comments (default =0)

@end table
@strong{Example:}
@smallexample
@c computed example nt_solve d2t_singular/ntsolve_lib.doc:56 
LIB "ntsolve.lib";
ring rsq = (real,40),(x,y,z,w),lp;
ideal gls =  x2+y2+z2-10, y2+z3+w-8, xy+yz+xz+w5 - 1,w3+y;
ideal ini = 3.1,2.9,1.1,0.5;
intvec ipar = 200,0;
ideal sol = nt_solve(gls,ini,ipar);
sol;
@expansion{} sol[1]=0.8698104581550055082008024750939710335537
@expansion{} sol[2]=2.8215774457503246008496262517717182369409
@expansion{} sol[3]=1.1323120084664179900060940157112668717318
@expansion{} sol[4]=-1.413071026406678849397999475590194239628
@c end example nt_solve d2t_singular/ntsolve_lib.doc:56
@end smallexample
@c ---end content nt_solve---

@c ------------------- triMNewton -------------
@node triMNewton,, nt_solve, ntsolve_lib
@subsubsection triMNewton
@cindex triMNewton
@c ---content triMNewton---
Procedure from library @code{ntsolve.lib} (@pxref{ntsolve_lib}).

@table @asis
@item @strong{Usage:}
triMNewton(G,a[,ipar]); G,a= ideals, ipar=list/intvec

@item @strong{Assume:}
G: g1,..,gn, a triangular system of n equations in n vars, i.e.
gi=gi(var(n-i+1),..,var(n)),@*
a: ideal of numbers, coordinates of an approximation of a common
zero of G to start with (with a[i] to be substituted in var(i)),@*
ipar: control integer vector (default: ipar = 100,10)
  @format
  ipar[1]: max. number of iterations
  ipar[2]: accuracy (we have as norm |.| absolute value ):
           accept solution @code{sol} if |G(sol)| < |G(a)|*(0.1^ipar[2]).
  @end format

@item @strong{Return:}
an ideal, coordinates of a better approximation of a zero of G

@end table
@strong{Example:}
@smallexample
@c computed example triMNewton d2t_singular/ntsolve_lib.doc:97 
LIB "ntsolve.lib";
ring r = (real,30),(z,y,x),(lp);
ideal i = x^2-1,y^2+x4-3,z2-y4+x-1;
ideal a = 2,3,4;
intvec e = 20,10;
ideal l = triMNewton(i,a,e);
l;
@expansion{} l[1]=-2.000000000042265738880279143423
@expansion{} l[2]=1.41421356237309504880168872421
@expansion{} l[3]=1
@c end example triMNewton d2t_singular/ntsolve_lib.doc:97
@end smallexample
@c ---end content triMNewton---
@c ---------------------------------------------------------
@node zeroset_lib, , ntsolve_lib, Symbolic-numerical solving
@subsection zeroset_lib
@c include of docu for zeroset.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/zeroset_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/zeroset_lib.doc INSTEAD
@c library version: (1.7.2.2,2002/02/20)
@c library file: ../Singular/LIB/zeroset.lib
@cindex zeroset.lib
@cindex zeroset_lib
@table @asis
@item @strong{Library:}
zeroset.lib
@item @strong{Purpose:}
      Procedures For Roots and Factorization
@item @strong{Author:}
Thomas Bayer, email: tbayer@@mathematik.uni-kl.de
@*http://wwwmayr.informatik.tu-muenchen.de/personen/bayert/
Current Adress: Institut fuer Informatik, TU Muenchen

@item @strong{Overview:}
Algorithms for finding the zero-set of a zero-dim. ideal in Q(a)[x_1,..,x_n],
Roots and Factorization of univariate polynomials over Q(a)[t]
where a is an algebraic number. Written in the frame of the
diploma thesis (advisor: Prof. Gert-Martin Greuel) 'Computations of moduli
spaces of semiquasihomogeneous singularities and an implementation in Singular'.
This library is meant as a preliminary extension of the functionality
of Singular for univariate factorization of polynomials over simple algebraic
extensions in characteristic 0.
@*Subprocedures with postfix 'Main' require that the ring contains a variable
'a' and no parameters, and the ideal 'mpoly', where 'minpoly' from the
basering is stored.

@end table

@strong{Procedures:}
@menu
* EGCD:: gcd over an algebraic extension field of Q
* Factor:: factorization of f over an algebraic extension field
* Quotient:: quotient q of f w.r.t. g (in f = q*g + remainder)
* Remainder:: remainder of the division of f by g
* Roots:: computes all roots of f in an extension field of Q
* SQFRNorm:: norm of f (f must be squarefree)
* ZeroSet:: zero-set of the 0-dim. ideal I
@end menu
@strong{Auxiliary procedures:}
@menu
* EGCDMain:: gcd over an algebraic extension field of Q
* FactorMain:: factorization of f over an algebraic extension field
* InvertNumberMain:: inverts an element of an algebraic extension field
* QuotientMain:: quotient of f w.r.t. g
* RemainderMain:: remainder of the division of f by g
* RootsMain:: computes all roots of f, might extend the ground field
* SQFRNormMain:: norm of f (f must be squarefree)
* ContainedQ:: f in data ?
* SameQ:: a == b (list a,b)
@end menu
@c ---end content LibInfo---

@c ------------------- EGCD -------------
@node EGCD, Factor,, zeroset_lib
@subsubsection EGCD
@cindex EGCD
@c ---content EGCD---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
EGCD(f, g); where f,g are polynomials

@item @strong{Purpose:}
compute the polynomial gcd of f and g over Q(a)[x]

@item @strong{Return:}
polynomial h s.t. h is a greatest common divisor of f and g (not nec.
monic)

@item @strong{Assume:}
basering = Q(a)[t]

@end table
@strong{Example:}
@smallexample
@c computed example EGCD d2t_singular/zeroset_lib.doc:79 
LIB "zeroset.lib";
ring R = (0,a), x, lp;
minpoly = a2+1;
poly f =  x4 - 1;
poly g = x2 - 2*a*x - 1;
EGCD(f, g);
@expansion{} (-4a)*x-4
@c end example EGCD d2t_singular/zeroset_lib.doc:79
@end smallexample
@c ---end content EGCD---

@c ------------------- Factor -------------
@node Factor, Quotient, EGCD, zeroset_lib
@subsubsection Factor
@cindex Factor
@c ---content Factor---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
Factor(f); where f is a polynomial

@item @strong{Purpose:}
compute the factorization of the squarefree poly f over Q(a)[t]

@item @strong{Return:}
list with two entries
  @format
  _[1] = factors (monic), first entry is the leading coefficient
  _[2] = multiplicities (not yet implemented)
  @end format

@item @strong{Assume:}
basering must be the univariate polynomial ring over a field, which
is Q or a simple extension of Q given by a minpoly.

@item @strong{Note:}
if basering = Q[t] then this is the built-in @code{factorize}

@end table
@strong{Example:}
@smallexample
@c computed example Factor d2t_singular/zeroset_lib.doc:121 
LIB "zeroset.lib";
ring R = (0,a), x, lp;
minpoly = a2+1;
poly f =  x4 - 1;
list fl = Factor(f);
fl;
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=(40a+60)*x+(40a+60)
@expansion{}    _[3]=(1/65a-29/130)*x+(-1/65a+29/130)
@expansion{}    _[4]=(4a)*x+4
@expansion{}    _[5]=(7/520a+1/130)*x+(1/130a-7/520)
@expansion{} [2]:
@expansion{}    _[1]=1
@expansion{}    _[2]=1
@expansion{}    _[3]=1
@expansion{}    _[4]=1
@expansion{}    _[5]=1
fl[1][1]*fl[1][2]*fl[1][3]*fl[1][4]*fl[1][5] - f;
@expansion{} 0
@c end example Factor d2t_singular/zeroset_lib.doc:121
@end smallexample
@c ---end content Factor---

@c ------------------- Quotient -------------
@node Quotient, Remainder, Factor, zeroset_lib
@subsubsection Quotient
@cindex Quotient
@c ---content Quotient---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
Quotient(f, g); where f,g are polynomials;

@item @strong{Purpose:}
compute the quotient q and remainder r s.t. f = g*q + r, deg(r) < deg(g)

@item @strong{Return:}
list of polynomials
  @format
  _[1] = quotient  q
  _[2] = remainder r
  @end format

@item @strong{Assume:}
basering = Q[x] or Q(a)[x]

@end table
@strong{Example:}
@smallexample
@c computed example Quotient d2t_singular/zeroset_lib.doc:160 
LIB "zeroset.lib";
ring R = (0,a), x, lp;
minpoly = a2+1;
poly f =  x4 - 2;
poly g = x - a;
list qr = Quotient(f, g);
qr;
@expansion{} [1]:
@expansion{}    x3+(a)*x2-x+(-a)
@expansion{} [2]:
@expansion{}    0
qr[1]*g + qr[2] - f;
@expansion{} 1
@c end example Quotient d2t_singular/zeroset_lib.doc:160
@end smallexample
@c ---end content Quotient---

@c ------------------- Remainder -------------
@node Remainder, Roots, Quotient, zeroset_lib
@subsubsection Remainder
@cindex Remainder
@c ---content Remainder---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
Remainder(f, g); where f,g are polynomials

@item @strong{Purpose:}
compute the remainder of the division of f by g, i.e. a polynomial r
s.t. f = g*q + r, deg(r) < deg(g).

@item @strong{Return:}
poly

@item @strong{Assume:}
basering = Q[x] or Q(a)[x]

@end table
@strong{Example:}
@smallexample
@c computed example Remainder d2t_singular/zeroset_lib.doc:197 
LIB "zeroset.lib";
ring R = (0,a), x, lp;
minpoly = a2+1;
poly f =  x4 - 1;
poly g = x3 - 1;
Remainder(f, g);
@expansion{} x-1
@c end example Remainder d2t_singular/zeroset_lib.doc:197
@end smallexample
@c ---end content Remainder---

@c ------------------- Roots -------------
@node Roots, SQFRNorm, Remainder, zeroset_lib
@subsubsection Roots
@cindex Roots
@c ---content Roots---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
Roots(f); where f is a polynomial

@item @strong{Purpose:}
compute all roots of f in a finite extension of the ground field
without multiplicities.

@item @strong{Return:}
ring, a polynomial ring over an extension field of the ground field,
containing a list 'roots' and polynomials 'newA' and 'f':
  @format
  - 'roots' is the list of roots of the polynomial f (no multiplicities)
  - if the ground field is Q(a') and the extension field is Q(a), then
    'newA' is the representation of a' in Q(a). 
    If the basering contains a parameter 'a' and the minpoly remains unchanged
    then 'newA' = 'a'.
    If the basering does not contain a parameter then 'newA' = 'a' (default).
  - 'f' is the polynomial f in Q(a) (a' being substituted by 'newA')
  @end format

@item @strong{Assume:}
ground field to be Q or a simple extension of Q given by a minpoly

@end table
@strong{Example:}
@smallexample
@c computed example Roots d2t_singular/zeroset_lib.doc:242 
LIB "zeroset.lib";
ring R = (0,a), x, lp;
minpoly = a2+1;
poly f = x3 - a;
def R1 = Roots(f);
@expansion{} 
@expansion{} // 'Roots' created a new ring which contains the list 'roots' and
@expansion{} // the polynomials 'f' and 'newA'
@expansion{} // To access the roots, newA and the new representation of f, type
@expansion{}    def R = Roots(f); setring R; roots; newA; f;
@expansion{} 
setring R1;
minpoly;
@expansion{} (a4-a2+1)
newA;
@expansion{} (a3)
f;
@expansion{} x3+(-a3)
roots;
@expansion{} [1]:
@expansion{}    (-a3)
@expansion{} [2]:
@expansion{}    (a3-a)
@expansion{} [3]:
@expansion{}    (a)
map F;
F[1] = roots[1];
F(f);
@expansion{} 0
@c end example Roots d2t_singular/zeroset_lib.doc:242
@end smallexample
@c ---end content Roots---

@c ------------------- SQFRNorm -------------
@node SQFRNorm, ZeroSet, Roots, zeroset_lib
@subsubsection SQFRNorm
@cindex SQFRNorm
@c ---content SQFRNorm---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
SQFRNorm(f); where f is a polynomial

@item @strong{Purpose:}
compute the norm of the squarefree polynomial f in Q(a)[x].

@item @strong{Return:}
list with 3 entries
  @format
  _[1] = squarefree norm of g (poly)
  _[2] = g (= f(x - s*a)) (poly)
  _[3] = s (int)
  @end format

@item @strong{Assume:}
f must be squarefree, basering = Q(a)[x] and minpoly != 0.

@item @strong{Note:}
the norm is an element of Q[x]

@end table
@strong{Example:}
@smallexample
@c computed example SQFRNorm d2t_singular/zeroset_lib.doc:291 
LIB "zeroset.lib";
ring R = (0,a), x, lp;
minpoly = a2+1;
poly f =  x4 - 2*x + 1;
SQFRNorm(f);
@expansion{} [1]:
@expansion{}    x8+4*x6-4*x5+8*x4+8*x3-4*x2+8*x+8
@expansion{} [2]:
@expansion{}    x4+(-4a)*x3-6*x2+(4a-2)*x+(2a+2)
@expansion{} [3]:
@expansion{}    1
@c end example SQFRNorm d2t_singular/zeroset_lib.doc:291
@end smallexample
@c ---end content SQFRNorm---

@c ------------------- ZeroSet -------------
@node ZeroSet, EGCDMain, SQFRNorm, zeroset_lib
@subsubsection ZeroSet
@cindex ZeroSet
@c ---content ZeroSet---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
ZeroSet(I [,opt] ); I=ideal, opt=integer

@item @strong{Purpose:}
compute the zero-set of the zero-dim. ideal I, in a finite extension
of the ground field.

@item @strong{Return:}
ring, a polynomial ring over an extension field of the ground field,
containing a list 'zeroset', a polynomial 'newA', and an
ideal 'id':
  @format
  - 'zeroset' is the list of the zeros of the ideal I, each zero is an ideal.
  - if the ground field is Q(a') and the extension field is Q(a), then
    'newA' is the representation of a' in Q(a).
    If the basering contains a parameter 'a' and the minpoly remains unchanged
    then 'newA' = 'a'.
    If the basering does not contain a parameter then 'newA' = 'a' (default).    
  - 'id' is the ideal I in Q(a)[x_1,...] (a' substituted by 'newA')
  @end format

@item @strong{Assume:}
dim(I) = 0, and ground field to be Q or a simple extension of Q given
by a minpoly.

@item @strong{Options:}
opt = 0 no primary decomposition (default)
@*opt > 0 primary decomposition

@item @strong{Note:}
If I contains an algebraic number (parameter) then 'I' must be
transformed w.r.t. 'newA' in the new ring.

@end table
@strong{Example:}
@smallexample
@c computed example ZeroSet d2t_singular/zeroset_lib.doc:345 
LIB "zeroset.lib";
ring R = (0,a), (x,y,z), lp;
minpoly = a2 + 1;
ideal I = x2 - 1/2, a*z - 1, y - 2;
def T = ZeroSet(I);
@expansion{} 1
setring T;
minpoly;
@expansion{} (4a4+4a2+9)
newA;
@expansion{} (1/3a3+5/6a)
id;
@expansion{} id[1]=(1/3a3+5/6a)*z-1
@expansion{} id[2]=y-2
@expansion{} id[3]=2*x2-1
zeroset;
@expansion{} [1]:
@expansion{}    _[1]=(1/3a3-1/6a)
@expansion{}    _[2]=2
@expansion{}    _[3]=(-1/3a3-5/6a)
@expansion{} [2]:
@expansion{}    _[1]=(-1/3a3+1/6a)
@expansion{}    _[2]=2
@expansion{}    _[3]=(-1/3a3-5/6a)
map F1 = basering, zeroset[1];
map F2 = basering, zeroset[2];
F1(id);
@expansion{} _[1]=0
@expansion{} _[2]=0
@expansion{} _[3]=0
F2(id);
@expansion{} _[1]=0
@expansion{} _[2]=0
@expansion{} _[3]=0
@c end example ZeroSet d2t_singular/zeroset_lib.doc:345
@end smallexample
@c ---end content ZeroSet---

@c ------------------- EGCDMain -------------
@node EGCDMain, FactorMain, ZeroSet, zeroset_lib
@subsubsection EGCDMain
@cindex EGCDMain
@c ---content EGCDMain---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Purpose:}
compute the polynomial gcd of f and g over Q(a)[x]

@item @strong{Return:}
poly

@item @strong{Assume:}
basering = Q[x,a] and ideal mpoly is defined (it might be 0),
this represents the ring Q(a)[x] together with its minimal polynomial.

@end table
@c ---end content EGCDMain---

@c ------------------- FactorMain -------------
@node FactorMain, InvertNumberMain, EGCDMain, zeroset_lib
@subsubsection FactorMain
@cindex FactorMain
@c ---content FactorMain---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Purpose:}
compute the factorization of the squarefree poly f over Q(a)[t],
minpoly = p(a).

@item @strong{Return:}
list with 2 entries
  @format
  _[1] = factors, first is a constant
  _[2] = multiplicities (not yet implemented)
  @end format

@item @strong{Assume:}
basering = Q[x,a], representing Q(a)[x]. An ideal mpoly must
be defined, representing the minimal polynomial (it might be 0!).

@end table
@c ---end content FactorMain---

@c ------------------- InvertNumberMain -------------
@node InvertNumberMain, QuotientMain, FactorMain, zeroset_lib
@subsubsection InvertNumberMain
@cindex InvertNumberMain
@c ---content InvertNumberMain---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
InvertNumberMain(f); where f is a polynomial

@item @strong{Purpose:}
compute 1/f if f is a number in Q(a) i.e., f is represented by a
polynomial in Q[a].

@item @strong{Return:}
poly 1/f

@item @strong{Assume:}
basering = Q[x_1,...,x_n,a], ideal mpoly must be defined and != 0 !

@end table
@c ---end content InvertNumberMain---

@c ------------------- QuotientMain -------------
@node QuotientMain, RemainderMain, InvertNumberMain, zeroset_lib
@subsubsection QuotientMain
@cindex QuotientMain
@c ---content QuotientMain---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
QuotientMain(f, g); where f,g are polynomials

@item @strong{Purpose:}
compute the quotient q and remainder r s.t. f = g*q + r, deg(r) < deg(g)

@item @strong{Return:}
list of polynomials
  @format
  _[1] = quotient  q
  _[2] = remainder r
  @end format

@item @strong{Assume:}
basering = Q[x,a] and ideal mpoly is defined (it might be 0),
this represents the ring Q(a)[x] together with its minimal polynomial.

@end table
@c ---end content QuotientMain---

@c ------------------- RemainderMain -------------
@node RemainderMain, RootsMain, QuotientMain, zeroset_lib
@subsubsection RemainderMain
@cindex RemainderMain
@c ---content RemainderMain---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
RemainderMain(f, g); where f,g are polynomials

@item @strong{Purpose:}
compute the remainder r s.t. f = g*q + r, deg(r) < deg(g)

@item @strong{Return:}
poly

@item @strong{Assume:}
basering = Q[x,a] and ideal mpoly is defined (it might be 0),
this represents the ring Q(a)[x] together with its minimal polynomial.

@end table
@c ---end content RemainderMain---

@c ------------------- RootsMain -------------
@node RootsMain, SQFRNormMain, RemainderMain, zeroset_lib
@subsubsection RootsMain
@cindex RootsMain
@c ---content RootsMain---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
RootsMain(f); where f is a polynomial

@item @strong{Purpose:}
compute all roots of f in a finite extension of the ground field
without multiplicities.

@item @strong{Return:}
list, all entries are polynomials
  @format
  _[1] = roots of f, each entry is a polynomial
  _[2] = 'newA' - if the ground field is Q(a') and the extension field
         is Q(a), then 'newA' is the representation of a' in Q(a)
  _[3] = minpoly of the algebraic extension of the ground field
  @end format

@item @strong{Assume:}
basering = Q[x,a] ideal mpoly must be defined, it might be 0!

@item @strong{Note:}
might change the ideal mpoly !!

@end table
@c ---end content RootsMain---

@c ------------------- SQFRNormMain -------------
@node SQFRNormMain, ContainedQ, RootsMain, zeroset_lib
@subsubsection SQFRNormMain
@cindex SQFRNormMain
@c ---content SQFRNormMain---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
SQFRNorm(f); where f is a polynomial

@item @strong{Purpose:}
compute the norm of the squarefree polynomial f in Q(a)[x].

@item @strong{Return:}
list with 3 entries
  @format
  _[1] = squarefree norm of g (poly)
  _[2] = g (= f(x - s*a)) (poly)
  _[3] = s (int)
  @end format

@item @strong{Assume:}
f must be squarefree, basering = Q[x,a] and ideal mpoly is equal to
'minpoly',this represents the ring Q(a)[x] together with 'minpoly'.

@item @strong{Note:}
the norm is an element of Q[x]

@end table
@c ---end content SQFRNormMain---

@c ------------------- ContainedQ -------------
@node ContainedQ, SameQ, SQFRNormMain, zeroset_lib
@subsubsection ContainedQ
@cindex ContainedQ
@c ---content ContainedQ---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
ContainedQ(data, f [, opt]); data=list; f=any type, opt=integer

@item @strong{Purpose:}
test if f is an element of data.

@item @strong{Return:}
int
@*0 if f not contained in data
@*1 if f contained in data

@item @strong{Options:}
opt = 0 : use '==' for comparing f with elements from data@*
opt = 1 : use @code{SameQ} for comparing f with elements from data

@end table
@c ---end content ContainedQ---

@c ------------------- SameQ -------------
@node SameQ,, ContainedQ, zeroset_lib
@subsubsection SameQ
@cindex SameQ
@c ---content SameQ---
Procedure from library @code{zeroset.lib} (@pxref{zeroset_lib}).

@table @asis
@item @strong{Usage:}
SameQ(a, b); a,b=list/intvec

@item @strong{Purpose:}
test a == b elementwise, i.e., a[i] = b[i].

@item @strong{Return:}
int
@*0 if a != b
@*1 if a == b

@end table
@c ---end content SameQ---

@c ----------------------------------------------------------------------------
@node Visualization, Coding theory, Symbolic-numerical solving, SINGULAR libraries
@section Visualization
@cindex Visualization

@menu
* graphics_lib:: procedures to draw  with Mathematica
* latex_lib:: procedures for typesetting in TeX
* paramet_lib:: procedures for parametrizations
* surf_lib:: interface to the surf program
@end menu

@c ---------------------------------------------------------
@node graphics_lib, latex_lib, Visualization, Visualization
@subsection graphics_lib
@c include of docu for graphics.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/graphics_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/graphics_lib.doc INSTEAD
@c library version: (1.10,2001/02/19)
@c library file: ../Singular/LIB/graphics.lib
@cindex graphics.lib
@cindex graphics_lib
@table @asis
@item @strong{Library:}
graphics.lib
@item @strong{Purpose:}
    Procedures to use Graphics with Mathematica
@item @strong{Author:}
Christian Gorzel, gorzelc@@math.uni-muenster.de

@end table

@strong{Procedures:}
@menu
* staircase:: Mathematica text for displaying staircase of I
* mathinit:: string for loading Mathematica's ImplicitPlot
* mplot:: Mathematica text for various plots
@end menu
@c ---end content LibInfo---

@c ------------------- staircase -------------
@node staircase, mathinit,, graphics_lib
@subsubsection staircase
@cindex staircase
@c ---content staircase---
Procedure from library @code{graphics.lib} (@pxref{graphics_lib}).

@table @asis
@item @strong{Usage:}
staircase(s,I); s a string, I ideal in two variables

@item @strong{Return:}
string with Mathematica input for displaying staircase diagrams of an
ideal I, i.e. exponent vectors of the initial ideal of I

@item @strong{Note:}
ideal I should be given by a standard basis. Let s="" and copy and
paste the result into a Mathematica notebook.

@end table
@strong{Example:}
@smallexample
@c skipped computation of example staircase d2t_singular/graphics_lib.doc:46 
LIB "graphics.lib";
ring r0 = 0,(x,y),ls;
ideal I = -1x2y6-1x4y2, 7x6y5+1/2x7y4+6x4y6;
staircase("",std(I));
ring r1 = 0,(x,y),dp;
ideal I = fetch(r0,I);
staircase("",std(I));
ring r2 = 0,(x,y),wp(2,3);
ideal I = fetch(r0,I);
staircase("",std(I));
// Paste the output into a Mathematica notebook
// active evalutation of the cell with SHIFT RETURN
@end smallexample
@c ---end content staircase---

@c ------------------- mathinit -------------
@node mathinit, mplot, staircase, graphics_lib
@subsubsection mathinit
@cindex mathinit
@c ---content mathinit---
Procedure from library @code{graphics.lib} (@pxref{graphics_lib}).

@table @asis
@item @strong{Usage:}
mathinit();

@item @strong{Return:}
initializing string for loading Mathematica's ImplicitPlot

@end table
@strong{Example:}
@smallexample
@c skipped computation of example mathinit d2t_singular/graphics_lib.doc:80 
LIB "graphics.lib";
mathinit();
// Paste the output into a Mathematica notebook
// active evalutation of the cell with SHIFT RETURN
@end smallexample
@c ---end content mathinit---

@c ------------------- mplot -------------
@node mplot,, mathinit, graphics_lib
@subsubsection mplot
@cindex mplot
@c ---content mplot---
Procedure from library @code{graphics.lib} (@pxref{graphics_lib}).

@table @asis
@item @strong{Usage:}
mplot(fname, I [,I1,I2,..,s] ); fname=string; I,I1,I2,..=ideals,
s=string representing the plot region.@*
Use the ideals I1,I2,.. in order to produce multiple plots (they need
to have the same number of entries as I!).

@item @strong{Return:}
string, text with Mathematica commands to display a plot

@item @strong{Note:}
The plotregion is defaulted to -1,1 around zero.
@*For implicit given curves enter first the string returned by
proc mathinit into Mathematica in order to load ImplicitPlot.
The following conventions for I are used:
  @format
  - ideal with 2 entries in one variable means a parametrised plane curve,
  - ideal with 3 entries in one variable means a parametrised space curve,
  - ideal with 3 entries in two variables means a parametrised surface,
  - ideal with 2 entries in two variables means an implicit curve
    given as I[1]==I[2],
  - ideal with 1 entry (or one polynomial) in two variables means
    an implicit curve given as  f == 0,
  @end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example mplot d2t_singular/graphics_lib.doc:124 
LIB "graphics.lib";
// ---------  plane curves ------------
ring rr0 = 0,x,dp; export rr0;
ideal I = x3 + x, x2;
ideal J = x2, -x+x3;
mplot("",I,J,"-2,2");
// Paste the output into a Mathematica notebook
// active evalutation of the cell with SHIFT RETURN
// --------- space curves --------------
I = x3,-1/10x3+x2,x2;
mplot("",I);
// Paste the output into a Mathematica notebook
// active evalutation of the cell with SHIFT RETURN
// ----------- surfaces -------------------
ring rr1 = 0,(x,y),dp; export rr1;
ideal J = xy,y,x2;
mplot("",J,"-2,1","1,2");
// Paste the output into a Mathematica notebook
// active evalutation of the cell with SHIFT RETURN
kill rr0,rr1;
@end smallexample
@c ---end content mplot---
@c ---------------------------------------------------------
@node latex_lib, paramet_lib, graphics_lib, Visualization
@subsection latex_lib
@c include of docu for latex.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/latex_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/latex_lib.doc INSTEAD
@c library version: (1.19.2.1,2002/02/20)
@c library file: ../Singular/LIB/latex.lib
@cindex latex.lib
@cindex latex_lib
@table @asis
@item @strong{Library:}
latex.lib
@item @strong{Purpose:}
    Typesetting of Singular-Objects in LaTeX2e
@item @strong{Author:}
Christian Gorzel, gorzelc@@math.uni-muenster.de

@end table

@strong{Procedures:}
@menu
* closetex:: writes closing line for LaTeX-document
* opentex:: writes header for LaTeX-file fnm
* tex:: calls LaTeX2e for LaTeX-file fnm
* texdemo:: produces a file explaining the features of this lib
* texfactorize:: creates string in LaTeX-format for factors of poly f
* texmap:: creates string in LaTeX-format for map m:r1->r2
* texname:: creates string in LaTeX-format for identifier
* texobj:: creates string in LaTeX-format for any (basic) type
* texpoly:: creates string in LaTeX-format for poly
* texproc:: creates string in LaTeX-format of text from proc p
* texring:: creates string in LaTeX-format for ring/qring
* rmx:: removes .aux and .log files of LaTeX-files
* xdvi:: calls xdvi for dvi-files
@end menu
@table @asis
@item @strong{Global variables:}
TeXwidth, TeXnofrac, TeXbrack, TeXproj, TeXaligned, TeXreplace, NoDollars
are used to control the typesetting.
Call @code{texdemo();} to obtain a LaTeX2e file @code{texlibdemo.tex}
explaining the features of @code{latex.lib} and its global variables.
@format
  @code{TeXwidth} (int) -1, 0, 1..9, >9:  controls breaking of long polynomials
  @code{TeXnofrac} (int) flag:  write 1/2 instead of \frac@{1@}@{2@}
  @code{TeXbrack} (string) "@{", "(", "<", "|", empty string: 
                                   controls brackets around ideals and matrices
  @code{TeXproj} (int) flag:  write ":" instead of "," in vectors
  @code{TeXaligned} (int) flag:  write maps (and ideals) aligned
  @code{TeXreplace} (list) list entries = 2 strings:  replacing symbols
  @code{NoDollars} (int) flag:  suppresses surrounding $ signs
@end format

@end table
@c ---end content LibInfo---

@c ------------------- closetex -------------
@node closetex, opentex,, latex_lib
@subsubsection closetex
@cindex closetex
@c ---content closetex---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
closetex(fname); fname string

@item @strong{Return:}
nothing; writes a LaTeX2e closing line into file @code{<fname>}.

@item @strong{Note:}
preceding ">>" are deleted and suffix ".tex" (if not given)
is added to @code{fname}.

@end table
@strong{Example:}
@smallexample
@c computed example closetex d2t_singular/latex_lib.doc:73 
LIB "latex.lib";
opentex("exmpl");
texobj("exmpl","@{\\large \\bf hello@}");
closetex("exmpl");
@c end example closetex d2t_singular/latex_lib.doc:73
@end smallexample
@c ---end content closetex---

@c ------------------- opentex -------------
@node opentex, tex, closetex, latex_lib
@subsubsection opentex
@cindex opentex
@c ---content opentex---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
opentex(fname); fname string

@item @strong{Return:}
nothing; writes a LaTeX2e header into a new file @code{<fname>}.

@item @strong{Note:}
preceding ">>" are deleted and suffix ".tex" (if not given)
is added to @code{fname}.

@end table
@strong{Example:}
@smallexample
@c computed example opentex d2t_singular/latex_lib.doc:103 
LIB "latex.lib";
opentex("exmpl");
texobj("exmpl","hello");
closetex("exmpl");
@c end example opentex d2t_singular/latex_lib.doc:103
@end smallexample
@c ---end content opentex---

@c ------------------- tex -------------
@node tex, texdemo, opentex, latex_lib
@subsubsection tex
@cindex tex
@c ---content tex---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
tex(fname); fname string

@item @strong{Return:}
nothing; calls latex (LaTeX2e) for compiling the file fname

@item @strong{Note:}
preceding ">>" are deleted and suffix ".tex" (if not given)
is added to @code{fname}.

@end table
@strong{Example:}
@smallexample
@c computed example tex d2t_singular/latex_lib.doc:133 
LIB "latex.lib";
ring r;
ideal I = maxideal(7);
opentex("exp001");              // open latex2e document
texobj("exp001","An ideal ",I);
closetex("exp001");
tex("exp001"); 
@expansion{} calling  latex2e  for : exp001.tex 
@expansion{} 
@expansion{} This is TeX, Version 3.14159 (Web2C 7.3.1)
@expansion{} (exp001.tex
@expansion{} LaTeX2e <1998/12/01> patch level 1
@expansion{} Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
   man, i
@expansion{} talian, nohyphenation, loaded.
@expansion{} (/usr/share/texmf/tex/latex/base/article.cls
@expansion{} Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
@expansion{} (/usr/share/texmf/tex/latex/base/size10.clo))
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amstext.sty
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
@expansion{} No file exp001.aux.
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
@expansion{} Output written on exp001.dvi (1 page, 2912 bytes).
@expansion{} Transcript written on exp001.log.
system("sh","rm exp001.*");
@expansion{} 0
@c end example tex d2t_singular/latex_lib.doc:133
@end smallexample
@c ---end content tex---

@c ------------------- texdemo -------------
@node texdemo, texfactorize, tex, latex_lib
@subsubsection texdemo
@cindex texdemo
@c ---content texdemo---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
texdemo();

@item @strong{Return:}
nothing; generates a LaTeX2e file called @code{texlibdemo.tex}
explaining the features of @code{latex.lib} and its global variables.

@item @strong{Note:}
this proc may take some time.

@end table
@c ---end content texdemo---

@c ------------------- texfactorize -------------
@node texfactorize, texmap, texdemo, latex_lib
@subsubsection texfactorize
@cindex texfactorize
@c ---content texfactorize---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
texfactorize(fname,f); fname string, f poly

@item @strong{Return:}
if @code{fname=""}: string, f as a product of its irreducible
factors@*
otherwise: append this string to the file @code{<fname>}, and
return nothing.

@item @strong{Note:}
preceding ">>" are deleted and suffix ".tex" (if not given)
is added to @code{fname}.

@end table
@strong{Example:}
@smallexample
@c computed example texfactorize d2t_singular/latex_lib.doc:191 
LIB "latex.lib";
ring r2 = 13,(x,y),dp;
poly f = (x+1+y)^2*x3y*(2x-2y)*y12;
texfactorize("",f);
@expansion{} $-2\cdot x^@{3@}\cdot y^@{13@}\cdot (-x+y)\cdot (x+y+1)^@{2@}$
ring R49 = (7,a),x,dp;
minpoly = a2+a+3;
poly f = (a24x5+x3)*a2x6*(x+1)^2;
f;
@expansion{} (a+3)*x13+(2a-1)*x12+(-2a+1)*x10+(-a-3)*x9
texfactorize("",f);
@expansion{} $(a+3)\cdot (x-1)\cdot (x+1)^@{3@}\cdot x^@{9@}$
@c end example texfactorize d2t_singular/latex_lib.doc:191
@end smallexample
@c ---end content texfactorize---

@c ------------------- texmap -------------
@node texmap, texname, texfactorize, latex_lib
@subsubsection texmap
@cindex texmap
@c ---content texmap---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
texmap(fname,m,@@r1,@@r2); fname string, m string/map, @@r1,@@r2 rings

@item @strong{Return:}
if @code{fname=""}: string, the map m from @@r1 to @@r2 (preceded
by its name if m = string) in TeX-typesetting;@*
otherwise: append this string to the file @code{<fname>}, and
return nothing.

@item @strong{Note:}
preceding ">>" are deleted in @code{fname}, and suffix ".tex"
(if not given) is added to @code{fname}.
If m is a string then it has to be the name of an existing map
from @@r1 to @@r2.

@end table
@strong{Example:}
@smallexample
@c computed example texmap d2t_singular/latex_lib.doc:231 
LIB "latex.lib";
// -------- prepare for example ---------
if (defined(TeXaligned)) @{int Teali=TeXaligned; kill TeXaligned;@}
if (defined(TeXreplace)) @{list Terep=TeXreplace; kill TeXreplace;@}
// -------- the example starts here ---------
//
string fname = "tldemo";
ring @@r1=0,(x,y,z),dp;
if(system("with","Namespaces")) @{ exportto(Current, @@r1); @}
else @{ export @@r1; @}
@expansion{} // ** `@@r1` is already global
ring r2=0,(u,v),dp;
map @@phi =(@@r1,u2,uv -v,v2); export @@phi;
@expansion{} // ** `@@phi` is already global
list TeXreplace;
TeXreplace[1] = list("@@phi","\\phi");    // @@phi --> \phi
export TeXreplace;
@expansion{} // ** `TeXreplace` is already global
texmap("","@@phi",@@r1,r2);                // standard form
@expansion{} $$
@expansion{} \begin@{array@}@{rcc@}
@expansion{} \phi:\Q[x,y,z] & \longrightarrow & \Q[u,v]\\[2mm]
@expansion{} \left(x,y,z\right) & \longmapsto & 
@expansion{}  \left(
@expansion{} \begin@{array@}@{c@}
@expansion{} u^@{2@}\\
@expansion{} uv-v\\
@expansion{} v^@{2@}
@expansion{} \end@{array@}
@expansion{} \right)
@expansion{} \end@{array@}
@expansion{} $$
//
int TeXaligned; export TeXaligned;       // map in one line
@expansion{} // ** `TeXaligned` is already global
texmap("",@@phi,@@r1,r2);
@expansion{} $\Q[x,y,z]\longrightarrow\Q[u,v], \ \left(x,y,z\right)\longmapsto \left(u\
   ^@{2@},uv-v,v^@{2@}\right)$
//
kill @@r1,TeXreplace,TeXaligned;
//
// --- restore global variables if previously defined ---
if (defined(Teali)) @{int TeXaligned=Teali; export TeXaligned; kill Teali;@}
if (defined(Terep)) @{list TeXreplace=Terep; export TeXreplace; kill Terep;@}
@c end example texmap d2t_singular/latex_lib.doc:231
@end smallexample
@c ---end content texmap---

@c ------------------- texname -------------
@node texname, texobj, texmap, latex_lib
@subsubsection texname
@cindex texname
@c ---content texname---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
texname(fname,s); fname,s strings

@item @strong{Return:}
if @code{fname=""}: string, the transformed string s, where the
following rules apply:
@smallexample
      s' + "~"             -->  "\\tilde@{"+ s' +"@}"
     "_" + int             -->       "_@{" + int +"@}" 
  "[" + s' + "]"           -->      "_@{" + s' + "@}"
   "A..Z" + int            --> "A..Z" + "^@{" + int + "@}"    
   "a..z" + int            --> "a..z" + "_@{" + int + "@}"
"(" + int + "," + s' + ")" --> "_@{"+ int +"@}" + "^@{" + s'+"@}"
@end smallexample
Anyhow, strings which begin with a @code{"@{"} are only changed
by deleting the first and last character (intended to remove the
surrounding curly brackets).

if @code{fname!=""}: append the transformed string s to the file
@code{<fname>}, and return nothing.

@item @strong{Note:}
preceding ">>" are deleted in @code{fname}, and suffix ".tex"
(if not given) is added to @code{fname}.

@end table
@strong{Example:}
@smallexample
@c computed example texname d2t_singular/latex_lib.doc:297 
LIB "latex.lib";
ring r = 0,(x,y),lp;
poly f = 3xy4 + 2xy2 + x5y3 + x + y6;
texname("","@{f(10)@}");
@expansion{} f(10)
texname("","f(10) =");
@expansion{} f_@{10@} =
texname("","n1");
@expansion{} n_@{1@}
texname("","T1_12");
@expansion{} T^@{1@}_@{12@}
texname("","g'_11");
@expansion{} g'_@{11@}
texname("","f23");
@expansion{} f_@{23@}
texname("","M[2,3]");
@expansion{} M_@{2,3@}
texname("","A(0,3);");
@expansion{} A_@{0@}^@{3@};
texname("","E~(3)");
@expansion{} \tilde@{E@}_@{3@}
@c end example texname d2t_singular/latex_lib.doc:297
@end smallexample
@c ---end content texname---

@c ------------------- texobj -------------
@node texobj, texpoly, texname, latex_lib
@subsubsection texobj
@cindex texobj
@c ---content texobj---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
texobj(fname,l); fname string, l list

@item @strong{Return:}
if @code{fname=""}: string, the entries of l in LaTeX-typesetting;@*
otherwise: append this string to the file @code{<fname>}, and
return nothing.

@item @strong{Note:}
preceding ">>" are deleted in @code{fname}, and suffix ".tex"
(if not given) is added to @code{fname}.

@end table
@strong{Example:}
@smallexample
@c computed example texobj d2t_singular/latex_lib.doc:337 
LIB "latex.lib";
// -------- prepare for example ---------
if (defined(TeXaligned)) @{int Teali=TeXaligned; kill TeXaligned;@}
if (defined(TeXbrack))@{string Tebra=TeXbrack; kill TeXbrack;@}
//
//  --------------  typesetting for polynomials ----------
ring r = 0,(x,y),lp;
poly f = x5y3 + 3xy4 + 2xy2 + y6;
f;
@expansion{} x5y3+3xy4+2xy2+y6
texobj("",f);
@expansion{} $$\begin@{array@}@{rl@}
@expansion{} & x^@{5@}y^@{3@}+3xy^@{4@}+2xy^@{2@}+y^@{6@}\\
@expansion{} \end@{array@}
@expansion{} $$
@expansion{} 
//  --------------  typesetting for ideals ----------
ideal G = jacob(f);
G;
@expansion{} G[1]=5x4y3+3y4+2y2
@expansion{} G[2]=3x5y2+12xy3+4xy+6y5
texobj("",G);
@expansion{} $$\left(
@expansion{} \begin@{array@}@{c@}
@expansion{} 5x^@{4@}y^@{3@}+3y^@{4@}+2y^@{2@}, \\
@expansion{} 3x^@{5@}y^@{2@}+12xy^@{3@}+4xy+6y^@{5@}
@expansion{} \end@{array@}
@expansion{} \right)$$
@expansion{} 
//  --------------  variation of typesetting for ideals ----------
int TeXaligned = 1; export TeXaligned;
@expansion{} // ** `TeXaligned` is already global
string TeXbrack = "<"; export TeXbrack;
@expansion{} // ** `TeXbrack` is already global
texobj("",G);
@expansion{} $\left<5x^@{4@}y^@{3@}+3y^@{4@}+2y^@{2@},3x^@{5@}y^@{2@}+12xy^@{3@}+4xy+6y^@{5@}\right>$
@expansion{} 
kill TeXaligned, TeXbrack;
//  --------------  typesetting for matrices ----------
matrix J = jacob(G);
texobj("",J);
@expansion{} $$\left(
@expansion{} \begin@{array@}@{*@{2@}@{c@}@}
@expansion{} 20x^@{3@}y^@{3@} & 15x^@{4@}y^@{2@}+12y^@{3@}+4y \\
@expansion{} 15x^@{4@}y^@{2@}+12y^@{3@}+4y & 6x^@{5@}y+36xy^@{2@}+4x+30y^@{4@}
@expansion{} \end@{array@}
@expansion{} \right)
@expansion{} $$
@expansion{} 
//  --------------  typesetting for intmats ----------
intmat m[3][4] = 9,2,4,5,2,5,-2,4,-6,10,-1,2,7;
texobj("",m);
@expansion{} $$\left(
@expansion{} \begin@{array@}@{*@{4@}@{r@}@}
@expansion{} 9 & 2 & 4 & 5\\
@expansion{} 2 & 5 & -2 & 4\\
@expansion{} -6 & 10 & -1 & 2
@expansion{} \end@{array@}
@expansion{} \right)
@expansion{} $$
@expansion{} 
//
// --- restore global variables if previously defined ---
if (defined(Teali))@{int TeXaligned=Teali; export TeXaligned; kill Teali;@}
if (defined(Tebra))@{string TeXbrack=Tebra; export TeXbrack; kill Tebra;@}
@c end example texobj d2t_singular/latex_lib.doc:337
@end smallexample
@c ---end content texobj---

@c ------------------- texpoly -------------
@node texpoly, texproc, texobj, latex_lib
@subsubsection texpoly
@cindex texpoly
@c ---content texpoly---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
texpoly(fname,p); fname string, p poly

@item @strong{Return:}
if @code{fname=""}: string, the poly p in LaTeX-typesetting;@*
otherwise: append this string to the file @code{<fname>}, and
return nothing.

@item @strong{Note:}
preceding ">>" are deleted in @code{fname}, and suffix ".tex"
(if not given) is added to @code{fname}.

@end table
@strong{Example:}
@smallexample
@c computed example texpoly d2t_singular/latex_lib.doc:394 
LIB "latex.lib";
ring r0=0,(x,y,z),dp;
poly f = -1x^2 + 2;
texpoly("",f);
@expansion{} $-x^@{2@}+2$
ring rr= real,(x,y,z),dp;
texpoly("",2x2y23z);
@expansion{} $2.000x^@{2@}y^@{23@}z$
ring r7= 7,(x,y,z),dp;
poly f = 2x2y23z;
texpoly("",f);
@expansion{} $2x^@{2@}y^@{23@}z$
ring rab =(0,a,b),(x,y,z),dp;
poly f = (-2a2 +b3 -2)/a * x2y4z5 + (a2+1)*x + a+1;
f;
@expansion{} (-2a2+b3-2)/(a)*x2y4z5+(a2+1)*x+(a+1)
texpoly("",f);
@expansion{} $-\frac@{2a^@{2@}-b^@{3@}+2@}@{a@}x^@{2@}y^@{4@}z^@{5@}+(a^@{2@}+1)x+(a+1)$
@c end example texpoly d2t_singular/latex_lib.doc:394
@end smallexample
@c ---end content texpoly---

@c ------------------- texproc -------------
@node texproc, texring, texpoly, latex_lib
@subsubsection texproc
@cindex texproc
@c ---content texproc---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
texproc(fname,pname); fname,pname strings

@item @strong{Assume:}
@code{`pname`} is a procedure.

@item @strong{Return:}
if @code{fname=""}: string, the proc @code{`pname`} in a verbatim
environment in LaTeX-typesetting;@*
otherwise: append this string to the file @code{<fname>}, and
return nothing.

@item @strong{Note:}
preceding ">>" are deleted in @code{fname}, and suffix ".tex"
(if not given) is added to @code{fname}.@*
@code{texproc} cannot be applied to itself correctly.

@end table
@strong{Example:}
@smallexample
@c computed example texproc d2t_singular/latex_lib.doc:440 
LIB "latex.lib";
proc exp(int i,int j,list #)
@{ string s;
if (size(#))
@{
for(i;i<=j;i++)
@{ s = s + string(j) + string(#); @}
@}
return(s);
@}
export exp;
@expansion{} // ** `exp` is already global
texproc("","exp");
@expansion{} \begin@{verbatim@}
@expansion{} proc exp(int i,int j,list #)
@expansion{} @{ 
@expansion{}  string s;
@expansion{} if (size(#))
@expansion{} @{
@expansion{} for(i;i<=j;i++)
@expansion{} @{ s = s + string(j) + string(#); @}
@expansion{} @}
@expansion{} return(s);
@expansion{} 
@expansion{} @}
@expansion{} \end@{verbatim@}
@expansion{} 
kill exp;
@c end example texproc d2t_singular/latex_lib.doc:440
@end smallexample
@c ---end content texproc---

@c ------------------- texring -------------
@node texring, rmx, texproc, latex_lib
@subsubsection texring
@cindex texring
@c ---content texring---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
texring(fname, r[,L]); fname string, r ring, L list

@item @strong{Return:}
if @code{fname=""}: string, the ring in TeX-typesetting;@*
otherwise: append this string to the file @code{<fname>} and
return nothing.

@item @strong{Note:}
preceding ">>" are deleted and suffix ".tex" (if not given)
is added to @code{fname}.@*
The optional list L is assumed to be a list of strings which control,
e.g., the symbol for the field of coefficients.@*
For more details call @code{texdemo();} (generates a LaTeX2e
file called @code{texlibdemo.tex} which explains all features of
@code{texring}).

@end table
@strong{Example:}
@smallexample
@c computed example texring d2t_singular/latex_lib.doc:486 
LIB "latex.lib";
ring r0 = 0,(x,y),dp;                // char = 0, polynomial ordering
texring("",r0);
@expansion{} $\Q[x,y]$
//
ring r7 =7,(x(0..2)),ds;             // char = 7, local ordering
texring("",r7);
@expansion{} $\Z_@{7@}[[x_@{0@},x_@{1@},x_@{2@}]]$
//
ring r1 = 0,(x1,x2,y1,y2),wp(1,2,3,4);
texring("",r1);
@expansion{} $\Q[x_@{1@},x_@{2@},y_@{1@},y_@{2@}]$
//
ring rr = real,(x),dp;               // real numbers
texring("",rr);
@expansion{} $\R[x]$
//
ring rabc =(0,t1,t2,t3),(x,y),dp;    // ring with parameters
texring("",rabc);
@expansion{} $\Q(t_@{1@},t_@{2@},t_@{3@})[x,y]$
//
ring ralg = (7,a),(x1,x2),ds;        // algebraic extension
minpoly = a2-a+3;
texring("",ralg);
@expansion{} $\Z_@{7@}(a)[[x_@{1@},x_@{2@}]]$
texring("",ralg,"mipo");
@expansion{} $\Z_@{7@}(a)/(a^@{2@}-a+3)[[x_@{1@},x_@{2@}]]$
//
ring r49=(49,a),x,dp;                // Galois field  
texring("",r49);
@expansion{} $\F_@{49@}[x]$
//
setring r0;                          // quotient ring
ideal i = x2-y3;
qring q = std(i);
texring("",q);
@expansion{} $\Q[x,y]/\left(y^@{3@}-x^@{2@}\right)
@expansion{} $
//
// ------------------ additional features -------------------
ring r9 =0,(x(0..9)),ds;
texring("",r9,1);
@expansion{} $\Q[[x_@{0@},\ldots,x_@{9@}]]$
texring("",r9,"C","@{","^G");
@expansion{} $\C\@{x_@{0@},x_@{1@},x_@{2@},x_@{3@},x_@{4@},x_@{5@},x_@{6@},x_@{7@},x_@{8@},x_@{9@}\@}^G$
//
ring rxy = 0,(x(1..5),y(1..6)),ds;
intvec v = 5,6;
texring("",rxy,v);
@expansion{} $\Q[[x_@{1@},\ldots,x_@{5@},y_@{1@},\ldots,y_@{6@}]]$
@c end example texring d2t_singular/latex_lib.doc:486
@end smallexample
@c ---end content texring---

@c ------------------- rmx -------------
@node rmx, xdvi, texring, latex_lib
@subsubsection rmx
@cindex rmx
@c ---content rmx---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
rmx(fname); fname string

@item @strong{Return:}
nothing; removes the @code{.log} and @code{.aux} files associated to
the LaTeX file <fname>.@*

@item @strong{Note:}
If @code{fname} ends by @code{".dvi"} or @code{".tex"}, the
@code{.dvi} or @code{.tex} file will be deleted, too.

@end table
@strong{Example:}
@smallexample
@c computed example rmx d2t_singular/latex_lib.doc:550 
LIB "latex.lib";
ring r;
poly f = x+y+z;
opentex("exp001");              // defaulted latex2e document
texobj("exp001","A polynom",f);
closetex("exp001");
tex("exp001");
@expansion{} calling  latex2e  for : exp001.tex 
@expansion{} 
@expansion{} This is TeX, Version 3.14159 (Web2C 7.3.1)
@expansion{} (exp001.tex
@expansion{} LaTeX2e <1998/12/01> patch level 1
@expansion{} Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
   man, i
@expansion{} talian, nohyphenation, loaded.
@expansion{} (/usr/share/texmf/tex/latex/base/article.cls
@expansion{} Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
@expansion{} (/usr/share/texmf/tex/latex/base/size10.clo))
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amstext.sty
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
@expansion{} No file exp001.aux.
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
@expansion{} Output written on exp001.dvi (1 page, 308 bytes).
@expansion{} Transcript written on exp001.log.
rmx("exp001");   // removes aux and log file of exp001
system("sh","rm exp001.*");
@expansion{} 0
@c end example rmx d2t_singular/latex_lib.doc:550
@end smallexample
@c ---end content rmx---

@c ------------------- xdvi -------------
@node xdvi,, rmx, latex_lib
@subsubsection xdvi
@cindex xdvi
@c ---content xdvi---
Procedure from library @code{latex.lib} (@pxref{latex_lib}).

@table @asis
@item @strong{Usage:}
xdvi(fname[,style]); fname,style = string

@item @strong{Return:}
nothing; displays dvi-file fname.dvi with previewer xdvi

@item @strong{Note:}
ending .dvi may miss in fname
@*style overwrites the default setting xdvi

@end table
@strong{Example:}
@smallexample
@c computed example xdvi d2t_singular/latex_lib.doc:585 
LIB "latex.lib";
intmat m[3][4] = 9,2,4,5,2,5,-2,4,-6,10,-1,2,7;
opentex("exp001"); 
texobj("exp001","An intmat:  ",m);
closetex("exp001");
tex("exp001");
@expansion{} calling  latex2e  for : exp001.tex 
@expansion{} 
@expansion{} This is TeX, Version 3.14159 (Web2C 7.3.1)
@expansion{} (exp001.tex
@expansion{} LaTeX2e <1998/12/01> patch level 1
@expansion{} Babel <v3.6x> and hyphenation patterns for american, french, german, nger\
   man, i
@expansion{} talian, nohyphenation, loaded.
@expansion{} (/usr/share/texmf/tex/latex/base/article.cls
@expansion{} Document Class: article 1999/01/07 v1.4a Standard LaTeX document class
@expansion{} (/usr/share/texmf/tex/latex/base/size10.clo))
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsmath.sty
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amstext.sty
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsgen.sty))
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsbsy.sty)
@expansion{} (/usr/share/texmf/tex/latex/amslatex/amsopn.sty))
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/amssymb.sty
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/amsfonts.sty))
@expansion{} No file exp001.aux.
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsa.fd)
@expansion{} (/usr/share/texmf/tex/latex/amsfonts/umsb.fd) [1] (exp001.aux) )
@expansion{} Output written on exp001.dvi (1 page, 524 bytes).
@expansion{} Transcript written on exp001.log.
xdvi("exp001");
@expansion{} calling  xdvi  for : exp001 
@expansion{} 
system("sh","rm exp001.*");
@expansion{} 0
@c end example xdvi d2t_singular/latex_lib.doc:585
@end smallexample
@c ---end content xdvi---
@c ---------------------------------------------------------
@node paramet_lib, surf_lib, latex_lib, Visualization
@subsection paramet_lib
@c include of docu for paramet.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/paramet_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/paramet_lib.doc INSTEAD
@c library version: (1.11.2.1,2002/10/21)
@c library file: ../Singular/LIB/paramet.lib
@cindex paramet.lib
@cindex paramet_lib
@table @asis
@item @strong{Library:}
paramet.lib
@item @strong{Purpose:}
   Parametrization of Varieties
@item @strong{Author:}
Thomas Keilen, keilen@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* parametrize:: parametrizes a prime ideal via the normalization
* parametrizepd:: calculates the prim.dec. and parametrizes the components
* parametrizesing:: parametrizes an isolated plane curve singularity
@end menu
@table @asis
@item @strong{Overview:}
A library to compute parametrizations of algebraic varieties (if possible)
with the aid of a normalization, or a primary decomposition, resp. to compute
a parametrization of a plane curve singularity with the aid of a
Hamburger-Noether expansion.

@end table
@c inserted refs from d2t_singular/paramet_lib.doc:30
@menu
See also:
* hnoether_lib::
* normal_lib::
* primdec_lib::
@end menu
@c end inserted refs from d2t_singular/paramet_lib.doc:30

@c ---end content LibInfo---

@c ------------------- parametrize -------------
@node parametrize, parametrizepd,, paramet_lib
@subsubsection parametrize
@cindex parametrize
@c ---content parametrize---
Procedure from library @code{paramet.lib} (@pxref{paramet_lib}).

@table @asis
@item @strong{Usage:}
parametrize(I); I ideal in an arbitrary number of variables,
whose radical is prime, in a ring with global ordering

@item @strong{Create:}
If the parametrization is successful, the basering will be changed to
the parametrization ring, that is to the ring PR=0,(s,t),dp;
respectively PR=0,t(1..d),dp;, depending on the dimension of the
parametrized variety.

@item @strong{Return:}
a list containing the parametrization ideal resp. the original ideal,
the number of variables needed for the parametrization resp. 0, and
1 resp. 0 depending on whether the parametrization was successful
or not

@cindex parametrization
@cindex normalization
@end table
@strong{Example:}
@smallexample
@c computed example parametrize d2t_singular/paramet_lib.doc:65 
LIB "paramet.lib";
ring RING=0,(x,y,z),dp;
ideal I=z2-y2x2+x3;
parametrize(I);
@expansion{} [1]:
@expansion{}    _[1]=s2-t2
@expansion{}    _[2]=s
@expansion{}    _[3]=s2t-t3
@expansion{} [2]:
@expansion{}    2
@expansion{} [3]:
@expansion{}    1
@c end example parametrize d2t_singular/paramet_lib.doc:65
@end smallexample
@c inserted refs from d2t_singular/paramet_lib.doc:72
@menu
See also:
* normal::
* parametrizepd::
* primdecGTZ::
* radical::
@end menu
@c end inserted refs from d2t_singular/paramet_lib.doc:72

@c ---end content parametrize---

@c ------------------- parametrizepd -------------
@node parametrizepd, parametrizesing, parametrize, paramet_lib
@subsubsection parametrizepd
@cindex parametrizepd
@c ---content parametrizepd---
Procedure from library @code{paramet.lib} (@pxref{paramet_lib}).

@table @asis
@item @strong{Usage:}
parametrizepd(I); I ideal in a polynomial ring with global ordering

@item @strong{Create:}
If the parametrization is successful, the basering will be changed to
the parametrization ring, that is to the ring PR=0,(s,t),dp;
respectively PR=0,t(1..d),dp;, depending on the dimension of the
parametrized variety.

@item @strong{Return:}
a list of lists, where each entry contains the parametrization
of a primary component of I resp. 0, the number of variables
resp. 0, and 1 resp. 0 depending on whether the parametrization
of the component was successful or not

@cindex parametrization
@cindex normalization
@end table
@strong{Example:}
@smallexample
@c computed example parametrizepd d2t_singular/paramet_lib.doc:106 
LIB "paramet.lib";
ring RING=0,(x,y,z),dp;
ideal I=(x2-y2z2+z3)*(x2-z2-z3),(x2-y2z2+z3)*yz;
parametrizepd(I);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=s2t-t3
@expansion{}       _[2]=s
@expansion{}       _[3]=s2-t2
@expansion{}    [2]:
@expansion{}       2
@expansion{}    [3]:
@expansion{}       1
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=0
@expansion{}       _[2]=s
@expansion{}       _[3]=0
@expansion{}    [2]:
@expansion{}       1
@expansion{}    [3]:
@expansion{}       1
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=s3-s
@expansion{}       _[2]=0
@expansion{}       _[3]=s2-1
@expansion{}    [2]:
@expansion{}       1
@expansion{}    [3]:
@expansion{}       1
@c end example parametrizepd d2t_singular/paramet_lib.doc:106
@end smallexample
@c inserted refs from d2t_singular/paramet_lib.doc:113
@menu
See also:
* normal::
* parametrize::
* primdecGTZ::
@end menu
@c end inserted refs from d2t_singular/paramet_lib.doc:113

@c ---end content parametrizepd---

@c ------------------- parametrizesing -------------
@node parametrizesing,, parametrizepd, paramet_lib
@subsubsection parametrizesing
@cindex parametrizesing
@c ---content parametrizesing---
Procedure from library @code{paramet.lib} (@pxref{paramet_lib}).

@table @asis
@item @strong{Usage:}
parametrizesing(f); f a polynomial in two variables, ordering ls or ds

@item @strong{Create:}
If the parametrization is successful, the basering will be changed to
the parametrization ring, that is to the ring 0,(x,y),ls;

@item @strong{Return:}
a list containing the parametrizations of the different branches of the
singularity at the origin resp. 0, if f was not of the desired kind

@cindex parametrization
@cindex curve singularities
@end table
@strong{Example:}
@smallexample
@c computed example parametrizesing d2t_singular/paramet_lib.doc:143 
LIB "paramet.lib";
ring RING=0,(x,y),ls;
poly f=(x^2-y^3)*(x^2-y^2-y^3);
parametrizesing(f);
@expansion{} [1]:
@expansion{}    _[1]=x
@expansion{}    _[2]=x-1/2x2
@expansion{} [2]:
@expansion{}    _[1]=x
@expansion{}    _[2]=-x-1/2x2
@expansion{} [3]:
@expansion{}    _[1]=x3
@expansion{}    _[2]=x2
@c end example parametrizesing d2t_singular/paramet_lib.doc:143
@end smallexample
@c inserted refs from d2t_singular/paramet_lib.doc:150
@menu
See also:
* develop::
* hnexpansion::
* hnoether_lib::
@end menu
@c end inserted refs from d2t_singular/paramet_lib.doc:150

@c ---end content parametrizesing---
@c ---------------------------------------------------------
@node surf_lib,, paramet_lib, Visualization
@subsection surf_lib
@c include of docu for surf.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/surf_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/surf_lib.doc INSTEAD
@c library version: (1.19.2.6,2002/07/17)
@c library file: ../Singular/LIB/surf.lib
@cindex surf.lib
@cindex surf_lib
@table @asis
@item @strong{Library:}
surf.lib
@item @strong{Purpose:}
    Procedures for Graphics with Surf
@item @strong{Author:}
Hans Schoenemann,
@*the program surf is written by Stefan Endrass

@item @strong{Note:}
To use this library requires the program @code{surf} to be installed.
 @code{surf} is only available for Linux PCs and Sun workstations.
 You can download @code{surf} either from
  @uref{http://sourceforge.net/projects/surf}
  or from @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils/}.

@end table

@strong{Procedures:}
@menu
* plot:: plots plane curves and surfaces
@end menu
@c ---end content LibInfo---

@c ------------------- plot -------------
@node plot,,, surf_lib
@subsubsection plot
@cindex plot
@c ---content plot---
Procedure from library @code{surf.lib} (@pxref{surf_lib}).

@table @asis
@item @strong{Usage:}
plot(I); I ideal or poly

@item @strong{Assume:}
I defines a plane curve or a surface given by one equation

@item @strong{Return:}
nothing

@item @strong{Note:}
requires the external program 'surf' to be installed

@end table
@strong{Example:}
@smallexample
@c skipped computation of example plot d2t_singular/surf_lib.doc:53 
LIB "surf.lib";
// ---------  plane curves ------------
ring rr0 = 0,(x1,x2),dp;
ideal I = x1^3 - x2^2;
plot(I);
ring rr1 = 0,(x,y,z),dp;
ideal I(1) = 2x2-1/2x3 +1-y+1;
plot(I(1));
//  ---- Singular Logo --------------
poly logo = ((x+3)^3 + 2*(x+3)^2 - y^2)*(x^3 - y^2)*((x-3)^3-2*(x-3)^2-y^2);
plot(logo);
// Steiner surface
ideal J(2) = x^2*y^2+x^2*z^2+y^2*z^2-17*x*y*z;
plot(J(2));
// --------------------
plot(x*(x2-y2)+z2);
// E7
plot(x^3-x*y^3+z^2);
// Whitney umbrella
plot(z^2-x^2*y);
@end smallexample
@c ---end content plot---

@c ----------------------------------------------------------------------------
@node Coding theory, , Visualization, SINGULAR libraries
@section Coding theory
@cindex Coding theory

@menu
* brnoeth_lib:: Brill-Noether algorithm, Weierstrass semigroups and AG codes
@end menu

@c ---------------------------------------------------------
@node brnoeth_lib, , , Coding theory
@subsection brnoeth_lib
@c include of docu for brnoeth.lib
@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/brnoeth_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/brnoeth_lib.doc INSTEAD
@c library version: (1.11.2.5,2002/10/18)
@c library file: ../Singular/LIB/brnoeth.lib
@cindex brnoeth.lib
@cindex brnoeth_lib
@table @asis
@item @strong{Library:}
brnoeth.lib
@item @strong{Purpose:}
  Brill-Noether Algorithm, Weierstrass-SG and AG-codes
@item @strong{Authors:}
Jose Ignacio Farran Martin, ignfar@@eis.uva.es
@*Christoph Lossen, lossen@@mathematik.uni-kl.de

@item @strong{Overview:}
Implementation of the Brill-Noether algorithm for solving the
Riemann-Roch problem and applications in Algebraic Geometry codes.
The computation of Weierstrass semigroups is also implemented.@*
The procedures are intended only for plane (singular) curves defined over
a prime field of positive characteristic.@*
For more information about the library see the end of the file brnoeth.lib.

@end table

@strong{Main procedures:}
@menu
* Adj_div:: computes the conductor of a curve
* NSplaces:: computes non-singular places with given degrees
* BrillNoether:: computes a vector space basis of the linear system L(D)
* Weierstrass:: computes the Weierstrass semigroup of C at P up to m
* extcurve:: extends the curve C to an extension of degree d
* AGcode_L:: computes the evaluation AG code with divisors G and D
* AGcode_Omega:: computes the residual AG code with divisors G and D
* prepSV:: preprocessing for the basic decoding algorithm
* decodeSV:: decoding of a word with the basic decoding algorithm
@end menu
@strong{Auxiliary procedures:}
@menu
* closed_points:: computes the zero-set of a zero-dim. ideal in 2 vars
* dual_code:: computes the dual code
* sys_code:: computes an equivalent systematic code
* permute_L:: applies a permutation to a list
@end menu
@cindex Weierstrass semigroup
@cindex Algebraic Geometry codes
@cindex Brill-Noether algorithm
@c inserted refs from d2t_singular/brnoeth_lib.doc:47
@menu
See also:
* hnoether_lib::
* triang_lib::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:47

@c ---end content LibInfo---

@c ------------------- Adj_div -------------
@node Adj_div, NSplaces,, brnoeth_lib
@subsubsection Adj_div
@cindex Adj_div
@c ---content Adj_div---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
Adj_div( f [,l] ); f a poly, [l a list]

@item @strong{Return:}
list L with the computed data:
  @format
  L[1] a list of rings: L[1][1]=aff_r (affine), L[1][2]=Proj_R (projective),
  L[2] an intvec with 2 entries (degree, genus),
  L[3] a list of intvec (closed places),
  L[4] an intvec (conductor),
  L[5] a list of lists:
     L[5][d][1] a (local) ring over an extension of degree d,
     L[5][d][2] an intvec (degrees of base points of places of degree d)
  @end format

@item @strong{Note:}
@code{Adj_div(f);} computes and stores the fundamental data of the
plane curve defined by f as needed for AG codes.
@*In the affine ring you can find the following data:
   @format
   poly CHI:  affine equation of the curve,
   ideal Aff_SLocus:  affine singular locus (std),
   list Inf_Points:  points at infinity
            Inf_Points[1]:  singular points
            Inf_Points[2]:  non-singular points,
   list Aff_SPoints:  affine singular points (if not empty).
   @end format
In the projective ring you can find the projective equation
CHI of the curve (poly).
@*In the local rings L[5][d][1] you find:
   @format
   list POINTS:  base points of the places of degree d,
   list LOC_EQS:  local equations of the curve at the base points,
   list BRANCHES:  Hamburger-Noether developments of the places,
   list PARAMETRIZATIONS:  local parametrizations of the places,
   @end format
Each entry of the list L[3] corresponds to one closed place (i.e.,
a place and all its conjugates) which is represented by an intvec
of size two, the first entry is the degree of the place (in
particular, it tells the local ring where to find the data
describing one representative of the closed place), and the
second one is the position of those data in the lists POINTS, etc.,
inside this local ring.@*
In the intvec L[4] (conductor) the i-th entry corresponds to the
i-th entry in the list of places L[3].

With no optional arguments, the conductor is computed by
local invariants of the singularities; otherwise it is computed
by the Dedekind formula. @*
An affine point is represented by a list P where P[1] is std
of a prime ideal and P[2] is an intvec containing the position
of the places above P in the list of closed places L[3]. @*
If the point is at infinity, P[1] is a homogeneous irreducible
polynomial in two variables.

If @code{printlevel>=0} additional comments are displayed (default:
@code{printlevel=0}).

@cindex Hamburger-Noether expansions
@cindex adjunction divisor
@end table
@strong{Example:}
@smallexample
@c computed example Adj_div d2t_singular/brnoeth_lib.doc:124 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(y9+y8+xy6+x2y3+y2+x3);
@expansion{} The genus of the curve is 3
def aff_R=C[1][1];      // the affine ring
setring aff_R;
listvar(aff_R);         // data in the affine ring
@expansion{} // aff_R                [0]  *ring
@expansion{} // Inf_Points           [0]  list, size: 2
@expansion{} // Aff_SPoints          [0]  list, size: 3
@expansion{} // Aff_SLocus           [0]  ideal (SB), 2 generator(s)
@expansion{} // CHI                  [0]  poly
CHI;                    // affine equation of the curve
@expansion{} x3+x2y3+xy6+y9+y8+y2
Aff_SLocus;             // ideal of the affine singular locus
@expansion{} Aff_SLocus[1]=y8+y2
@expansion{} Aff_SLocus[2]=x2+y6
Aff_SPoints[1];         // 1st affine singular point: (1:1:1), no.1
@expansion{} [1]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x+1
@expansion{} [2]:
@expansion{}    1
Inf_Points[1];          // singular point(s) at infinity: (1:0:0), no.4
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       y
@expansion{}    [2]:
@expansion{}       4
Inf_Points[2];          // list of non-singular points at infinity
@expansion{} empty list
//
def proj_R=C[1][2];     // the projective ring
setring proj_R;
CHI;                    // projective equation of the curve
@expansion{} x3z6+x2y3z4+xy6z2+y9+y8z+y2z7
C[2][1];                // degree of the curve
@expansion{} 9
C[2][2];                // genus of the curve
@expansion{} 3
C[3];                   // list of computed places
@expansion{} [1]:
@expansion{}    2,1
@expansion{} [2]:
@expansion{}    1,1
@expansion{} [3]:
@expansion{}    1,2
@expansion{} [4]:
@expansion{}    1,3
C[4];                   // adjunction divisor (all points are singular!)
@expansion{} 2,2,2,42
//
// we look at the place(s) of degree 2 by changing to the ring
C[5][2][1];
@expansion{} //   characteristic : 2
@expansion{} //   1 parameter    : a 
@expansion{} //   minpoly        : ...
@expansion{} //   number of vars : 3
@expansion{} //        block   1 : ordering ls
@expansion{} //                  : names    x y t 
@expansion{} //        block   2 : ordering C
def S(2)=C[5][2][1];
setring S(2);
POINTS;                // base point(s) of place(s) of degree 2: (1:a:1)
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       1
@expansion{}    [2]:
@expansion{}       (a)
@expansion{}    [3]:
@expansion{}       1
LOC_EQS;               // local equation(s)
@expansion{} [1]:
@expansion{}    y2+y3+(a+1)*y4+y6+(a+1)*y8+y9+(a)*xy2+(a+1)*xy4+xy6+(a+1)*x2y+(a)*x2y2\
   +x2y3+x3
PARAMETRIZATIONS;      // parametrization(s) and exactness
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=t2+(a+1)*t3
@expansion{}       _[2]=t3+(a+1)*t4
@expansion{}    [2]:
@expansion{}       3,4
BRANCHES;              // Hamburger-Noether development
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1,1]=0
@expansion{}       _[1,2]=x
@expansion{}       _[1,3]=0
@expansion{}       _[2,1]=0
@expansion{}       _[2,2]=1
@expansion{}       _[2,3]=(a+1)
@expansion{}    [2]:
@expansion{}       1,-4
@expansion{}    [3]:
@expansion{}       0
@expansion{}    [4]:
@expansion{}       y+(a+1)*xy+(a)*x2y+(a)*x2y2+(a+1)*x3+x3y+x3y3+(a)*x4+(a+1)*x4y2+(a+\
   1)*x4y3+x5+x5y2+(a)*x6+(a+1)*x6y2+x6y4+x6y5+x7y+(a+1)*x8+(a+1)*x8y+x8y4+(\
   a+1)*x8y6+x9+x9y7+(a+1)*x10+x11y6+(a+1)*x12y4+x13y5+x14+x14y+x15y4+x16+(a\
   +1)*x16y2+x17y3+x19y2+(a+1)*x20+x21y+x23
printlevel=plevel;
@c end example Adj_div d2t_singular/brnoeth_lib.doc:124
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:158
@menu
See also:
* NSplaces::
* closed_points::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:158

@c ---end content Adj_div---

@c ------------------- NSplaces -------------
@node NSplaces, BrillNoether, Adj_div, brnoeth_lib
@subsubsection NSplaces
@cindex NSplaces
@c ---content NSplaces---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
NSplaces( h, CURVE ), where h is an intvec and CURVE is a list

@item @strong{Return:}
list L with updated data of CURVE after computing all non-singular
affine closed places whose degrees are in the intvec h: @*
   @format
   in L[1][1]: (affine ring) lists Aff_Points(d) with affine non-singular
               (closed) points of degree d (if non-empty),
   in L[3]:    the newly computed closed places are added,
   in L[5]:    local rings created/updated to store (repres. of) new places.
   @end format
See @ref{Adj_div} for a description of the entries in L.

@item @strong{Note:}
The list_expression should be the output of the procedure Adj_div.@*
If @code{printlevel>=0} additional comments are displayed (default:
@code{printlevel=0}).

@end table
@strong{Example:}
@smallexample
@c computed example NSplaces d2t_singular/brnoeth_lib.doc:194 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(x3y+y3+x);
@expansion{} The genus of the curve is 3
// The list of computed places:
C[3];
@expansion{} [1]:
@expansion{}    1,1
@expansion{} [2]:
@expansion{}    1,2
// create places up to degree 4
list L=NSplaces(1..4,C);
// The list of computed places is now:
L[3];
@expansion{} [1]:
@expansion{}    1,1
@expansion{} [2]:
@expansion{}    1,2
@expansion{} [3]:
@expansion{}    1,3
@expansion{} [4]:
@expansion{}    2,1
@expansion{} [5]:
@expansion{}    3,1
@expansion{} [6]:
@expansion{}    3,2
@expansion{} [7]:
@expansion{}    3,3
@expansion{} [8]:
@expansion{}    3,4
@expansion{} [9]:
@expansion{}    3,5
@expansion{} [10]:
@expansion{}    3,6
@expansion{} [11]:
@expansion{}    3,7
@expansion{} [12]:
@expansion{}    4,1
@expansion{} [13]:
@expansion{}    4,2
@expansion{} [14]:
@expansion{}    4,3
// e.g., affine non-singular points of degree 4 :
def aff_r=L[1][1];
setring aff_r;
Aff_Points(4);
@expansion{} [1]:
@expansion{}    [1]:
@expansion{}       _[1]=y2+y+1
@expansion{}       _[2]=x2+xy+x+1
@expansion{}    [2]:
@expansion{}       12
@expansion{} [2]:
@expansion{}    [1]:
@expansion{}       _[1]=y4+y3+y2+y+1
@expansion{}       _[2]=x+y2+y+1
@expansion{}    [2]:
@expansion{}       13
@expansion{} [3]:
@expansion{}    [1]:
@expansion{}       _[1]=y4+y3+1
@expansion{}       _[2]=x+y3+y
@expansion{}    [2]:
@expansion{}       14
// e.g., base point of the 1st place of degree 4 :
def S(4)=L[5][4][1];
setring S(4);
POINTS[1];
@expansion{} [1]:
@expansion{}    (a3)
@expansion{} [2]:
@expansion{}    (a2+a)
@expansion{} [3]:
@expansion{}    1
printlevel=plevel;
@c end example NSplaces d2t_singular/brnoeth_lib.doc:194
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:217
@menu
See also:
* Adj_div::
* closed_points::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:217

@c ---end content NSplaces---

@c ------------------- BrillNoether -------------
@node BrillNoether, Weierstrass, NSplaces, brnoeth_lib
@subsubsection BrillNoether
@cindex BrillNoether
@c ---content BrillNoether---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
BrillNoether(G,CURVE); G an intvec, CURVE a list

@item @strong{Return:}
list of ideals (each of them with two homogeneous generators,
which represent the numerator, resp. denominator, of a rational
function).@*
The corresponding rational functions form a vector basis of the
linear system L(G), G a rational divisor over a non-singular curve.

@item @strong{Note:}
The procedure must be called from the ring CURVE[1][2], where
CURVE is the output of the procedure @code{NSplaces}. @*
The intvec G represents a rational divisor supported on the closed
places of CURVE[3] (e.g. @code{G=2,0,-1;} means 2 times the closed
place 1 minus 1 times the closed place 3).

@end table
@strong{Example:}
@smallexample
@c computed example BrillNoether d2t_singular/brnoeth_lib.doc:251 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(x3y+y3+x);
@expansion{} The genus of the curve is 3
C=NSplaces(1..4,C);
// the first 3 Places in C[3] are of degree 1.
// we define the rational divisor G = 4*C[3][1]+4*C[3][3] (of degree 8):
intvec G=4,0,4;
def R=C[1][2];
setring R;
list LG=BrillNoether(G,C);
@expansion{} Vector basis successfully computed 
// here is the vector basis of L(G):
LG;
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=1
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x
@expansion{} [3]:
@expansion{}    _[1]=z
@expansion{}    _[2]=x
@expansion{} [4]:
@expansion{}    _[1]=y2
@expansion{}    _[2]=x2
@expansion{} [5]:
@expansion{}    _[1]=xz2+y3
@expansion{}    _[2]=x3
@expansion{} [6]:
@expansion{}    _[1]=xyz2+y4
@expansion{}    _[2]=x4
printlevel=plevel;
@c end example BrillNoether d2t_singular/brnoeth_lib.doc:251
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:269
@menu
See also:
* Adj_div::
* NSplaces::
* Weierstrass::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:269

@c ---end content BrillNoether---

@c ------------------- Weierstrass -------------
@node Weierstrass, extcurve, BrillNoether, brnoeth_lib
@subsubsection Weierstrass
@cindex Weierstrass
@c ---content Weierstrass---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
Weierstrass( i, m, CURVE ); i,m integers and CURVE a list

@item @strong{Return:}
list WS of two lists:
  @format
  WS[1] list of integers (Weierstr. semigroup of the curve at place i up to m)
  WS[2] list of ideals (the associated rational functions)
  @end format

@item @strong{Note:}
The procedure must be called from the ring CURVE[1][2],
where CURVE is the output of the procedure @code{NSplaces}.
@* i represents the place CURVE[3][i].
@* Rational functions are represented by numerator/denominator
in form of ideals with two homogeneous generators.

@item @strong{Warning:}
The place must be rational, i.e., necessarily CURVE[3][i][1]=1. @*

@end table
@strong{Example:}
@smallexample
@c computed example Weierstrass d2t_singular/brnoeth_lib.doc:306 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(x3y+y3+x);
@expansion{} The genus of the curve is 3
C=NSplaces(1..4,C);
def R=C[1][2];
setring R;
// Place C[3][1] has degree 1 (i.e it is rational);
list WS=Weierstrass(1,7,C);
@expansion{} Vector basis successfully computed 
// the first part of the list is the Weierstrass semigroup up to 7 :
WS[1];
@expansion{} [1]:
@expansion{}    0
@expansion{} [2]:
@expansion{}    3
@expansion{} [3]:
@expansion{}    5
@expansion{} [4]:
@expansion{}    6
@expansion{} [5]:
@expansion{}    7
// and the second part are the corresponding functions :
WS[2];
@expansion{} [1]:
@expansion{}    _[1]=1
@expansion{}    _[2]=1
@expansion{} [2]:
@expansion{}    _[1]=y
@expansion{}    _[2]=z
@expansion{} [3]:
@expansion{}    _[1]=xy
@expansion{}    _[2]=z2
@expansion{} [4]:
@expansion{}    _[1]=y2
@expansion{}    _[2]=z2
@expansion{} [5]:
@expansion{}    _[1]=y3
@expansion{}    _[2]=xz2
printlevel=plevel;
@c end example Weierstrass d2t_singular/brnoeth_lib.doc:306
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:324
@menu
See also:
* Adj_div::
* BrillNoether::
* NSplaces::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:324

@c ---end content Weierstrass---

@c ------------------- extcurve -------------
@node extcurve, AGcode_L, Weierstrass, brnoeth_lib
@subsubsection extcurve
@cindex extcurve
@c ---content extcurve---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
extcurve( d, CURVE ); d an integer, CURVE a list

@item @strong{Return:}
list L which is the update of the list CURVE with additional entries
   @format
   L[1][3]: ring (p,a),(x,y),lp (affine),
   L[1][4]: ring (p,a),(x,y,z),lp (projective),
   L[1][5]: ring (p,a),(x,y,t),ls (local),
   L[2][3]: int  (the number of rational places),
   @end format
the rings being defined over a field extension of degree d. @*
If d<2 then @code{extcurve(d,CURVE);} creates a list L which
is the update of the list CURVE with additional entries
   @format
   L[1][5]: ring p,(x,y,t),ls,
   L[2][3]: int  (the number of computed places over the base field).
   @end format
In both cases, in the ring L[1][5] lists with the data for all the
computed rational places (after a field extension of degree d) are
created (see @ref{Adj_div}):
   @format
   lists POINTS, LOC_EQS, BRANCHES, PARAMETRIZATIONS.
   @end format

@item @strong{Note:}
The list CURVE should be the output of @code{NSplaces},
and must contain (at least) one place of degree d. @*
You actually need all the places with degree dividing d.
Otherwise, not all the places are computed, but only part of them. @*
This procedure must be executed before constructing AG codes,
even if no extension is needed. The ring L[1][4] must be active
when constructing codes over the field extension.@*

@end table
@strong{Example:}
@smallexample
@c computed example extcurve d2t_singular/brnoeth_lib.doc:375 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list C=Adj_div(x5+y2+y);
@expansion{} The genus of the curve is 2
C=NSplaces(1..4,C);
// since we have all points up to degree 4, we can extend the curve
// to that extension, in order to get rational points over F_16;
C=extcurve(4,C);
@expansion{} Total number of rational places : NrRatPl = 33
// e.g., display the basepoint of place no. 32:
def R=C[1][5];
setring R;
POINTS[32];
@expansion{} [1]:
@expansion{}    (a3+a2+a+1)
@expansion{} [2]:
@expansion{}    (a2+a)
@expansion{} [3]:
@expansion{}    1
printlevel=plevel;
@c end example extcurve d2t_singular/brnoeth_lib.doc:375
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:392
@menu
See also:
* AGcode_L::
* AGcode_Omega::
* Adj_div::
* NSplaces::
* closed_points::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:392

@c ---end content extcurve---

@c ------------------- AGcode_L -------------
@node AGcode_L, AGcode_Omega, extcurve, brnoeth_lib
@subsubsection AGcode_L
@cindex AGcode_L
@c ---content AGcode_L---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
AGcode_L( G, D, EC ); G,D intvec, EC a list

@item @strong{Return:}
a generator matrix for the evaluation AG code defined by the
divisors G and D.

@item @strong{Note:}
The procedure must be called within the ring EC[1][4],
where EC is the output of @code{extcurve(d)} (or within
the ring EC[1][2] if d=1). @*
The entry i in the intvec D refers to the i-th rational
place in EC[1][5] (i.e., to POINTS[i], etc., see @ref{extcurve}).@*
The intvec G represents a rational divisor (see @ref{BrillNoether}
for more details).@*
The code evaluates the vector basis of L(G) at the rational
places given by D.

@item @strong{Warnings:}
G should satisfy 
@math{ 2*genus-2 < deg(G) < size(D) }
@tex
$ 2*genus-2 < deg(G) < size(D) $
@end tex
, which is
not checked by the algorithm.
@*G and D should have disjoint supports (checked by the algorithm).

@end table
@strong{Example:}
@smallexample
@c computed example AGcode_L d2t_singular/brnoeth_lib.doc:432 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list HC=Adj_div(x3+y2+y);
@expansion{} The genus of the curve is 1
HC=NSplaces(1..2,HC);
HC=extcurve(2,HC);
@expansion{} Total number of rational places : NrRatPl = 9
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// let us construct the corresponding evaluation AG code :
matrix C=AGcode_L(G,D,HC);
@expansion{} Vector basis successfully computed 
// here is a linear code of type [8,5,>=3] over F_4
print(C);
@expansion{} 0,0,(a),  (a+1),1,  1,    (a+1),(a),  
@expansion{} 1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),
@expansion{} 1,1,1,    1,    1,  1,    1,    1,    
@expansion{} 0,0,(a+1),(a),  1,  1,    (a),  (a+1),
@expansion{} 0,0,(a+1),(a),  (a),(a+1),1,    1     
printlevel=plevel;
@c end example AGcode_L d2t_singular/brnoeth_lib.doc:432
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:451
@menu
See also:
* AGcode_Omega::
* Adj_div::
* BrillNoether::
* extcurve::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:451

@c ---end content AGcode_L---

@c ------------------- AGcode_Omega -------------
@node AGcode_Omega, prepSV, AGcode_L, brnoeth_lib
@subsubsection AGcode_Omega
@cindex AGcode_Omega
@c ---content AGcode_Omega---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
AGcode_Omega( G, D, EC ); G,D intvec, EC a list

@item @strong{Return:}
a generator matrix for the residual AG code defined by the
divisors G and D.

@item @strong{Note:}
The procedure must be called within the ring EC[1][4],
where EC is the output of @code{extcurve(d)} (or within
the ring EC[1][2] if d=1). @*
The entry i in the intvec D refers to the i-th rational
place in EC[1][5] (i.e., to POINTS[i], etc., see @ref{extcurve}).@*
The intvec G represents a rational divisor (see @ref{BrillNoether}
for more details).@*
The code computes the residues of a vector space basis of

@math{\Omega(G-D)}
@tex
$\Omega(G-D)$
@end tex
 at the rational places given by D.

@item @strong{Warnings:}
G should satisfy 
@math{ 2*genus-2 < deg(G) < size(D) }
@tex
$ 2*genus-2 < deg(G) < size(D) $
@end tex
, which is
not checked by the algorithm.
@*G and D should have disjoint supports (checked by the algorithm).

@end table
@strong{Example:}
@smallexample
@c computed example AGcode_Omega d2t_singular/brnoeth_lib.doc:491 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list HC=Adj_div(x3+y2+y);
@expansion{} The genus of the curve is 1
HC=NSplaces(1..2,HC);
HC=extcurve(2,HC);
@expansion{} Total number of rational places : NrRatPl = 9
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// let us construct the corresponding residual AG code :
matrix C=AGcode_Omega(G,D,HC);
@expansion{} Vector basis successfully computed 
// here is a linear code of type [8,3,>=5] over F_4
print(C);
@expansion{} 0,    (a),(a),(a),  (a+1),1,0,  0,
@expansion{} (a+1),1,  (a),0,    (a),  0,(a),0,
@expansion{} (a+1),0,  (a),(a+1),(a+1),0,0,  1 
printlevel=plevel;
@c end example AGcode_Omega d2t_singular/brnoeth_lib.doc:491
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:510
@menu
See also:
* AGcode_L::
* Adj_div::
* BrillNoether::
* extcurve::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:510

@c ---end content AGcode_Omega---

@c ------------------- prepSV -------------
@node prepSV, decodeSV, AGcode_Omega, brnoeth_lib
@subsubsection prepSV
@cindex prepSV
@c ---content prepSV---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
prepSV( G, D, F, EC ); G,D,F intvecs and EC a list

@item @strong{Return:}
list E of size n+3, where n=size(D). All its entries but E[n+3]
are matrices:
   @format
   E[1]:  parity check matrix for the current AG code
   E[2] ... E[n+2]:  matrices used in the procedure decodeSV
   E[n+3]:  intvec with
       E[n+3][1]: correction capacity 
@math{epsilon}
@tex
$epsilon$
@end tex
 of the algorithm
       E[n+3][2]: designed Goppa distance 
@math{delta}
@tex
$delta$
@end tex
 of the current AG code
   @end format

@item @strong{Note:}
Computes the preprocessing for the basic (Skorobogatov-Vladut)
decoding algorithm.@*
The procedure must be called within the ring EC[1][4], where EC is
the output of @code{extcurve(d)} (or in the ring EC[1][2] if d=1) @*
The intvec G and F represent rational divisors (see
@ref{BrillNoether} for more details).@*
The intvec D refers to rational places (see @ref{AGcode_Omega}
for more details.).
The current AG code is @code{AGcode_Omega(G,D,EC)}.@*
If you know the exact minimum distance d and you want to use it in
@code{decodeSV} instead of 
@math{delta}
@tex
$delta$
@end tex
, you can change the value
of E[n+3][2] to d before applying decodeSV.
@*If you have a systematic encoding for the current code and want to
keep it during the decoding, you must previously permute D (using
@code{permute_L(D,P);}), e.g., according to the permutation
P=L[3], L being the output of @code{sys_code}.

@item @strong{Warnings:}
F must be a divisor with support disjoint from the support of D and
with degree 
@math{epsilon + genus}
@tex
$epsilon + genus$
@end tex
, where

@math{epsilon:=[(deg(G)-3*genus+1)/2]}
@tex
$epsilon:=[(deg(G)-3*genus+1)/2]$
@end tex
.@*
G should satisfy 
@math{ 2*genus-2 < deg(G) < size(D) }
@tex
$ 2*genus-2 < deg(G) < size(D) $
@end tex
, which is
not checked by the algorithm.
@*G and D should also have disjoint supports (checked by the
algorithm).

@cindex SV-decoding algorithm, preprocessing
@end table
@strong{Example:}
@smallexample
@c computed example prepSV d2t_singular/brnoeth_lib.doc:569 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list HC=Adj_div(x3+y2+y);
@expansion{} The genus of the curve is 1
HC=NSplaces(1..2,HC);
HC=extcurve(2,HC);
@expansion{} Total number of rational places : NrRatPl = 9
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// construct the corresp. residual AG code of type [8,3,>=5] over F_4:
matrix C=AGcode_Omega(G,D,HC);
@expansion{} Vector basis successfully computed 
// we can correct 1 error and the genus is 1, thus F must have degree 2
// and support disjoint from that of D;
intvec F=2;
list SV=prepSV(G,D,F,HC);
@expansion{} Vector basis successfully computed 
@expansion{} Vector basis successfully computed 
@expansion{} Vector basis successfully computed 
// now everything is prepared to decode with the basic algorithm;
// for example, here is a parity check matrix to compute the syndrome :
print(SV[1]);
@expansion{} 0,0,(a),  (a+1),1,  1,    (a+1),(a),  
@expansion{} 1,0,(a),  (a+1),(a),(a+1),(a),  (a+1),
@expansion{} 1,1,1,    1,    1,  1,    1,    1,    
@expansion{} 0,0,(a+1),(a),  1,  1,    (a),  (a+1),
@expansion{} 0,0,(a+1),(a),  (a),(a+1),1,    1     
// and here you have the correction capacity of the algorithm :
int epsilon=SV[size(D)+3][1];
epsilon;
@expansion{} 1
printlevel=plevel;
@c end example prepSV d2t_singular/brnoeth_lib.doc:569
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:596
@menu
See also:
* AGcode_Omega::
* decodeSV::
* extcurve::
* permute_L::
* sys_code::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:596

@c ---end content prepSV---

@c ------------------- decodeSV -------------
@node decodeSV, closed_points, prepSV, brnoeth_lib
@subsubsection decodeSV
@cindex decodeSV
@c ---content decodeSV---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
decodeSV( y, K ); y a row-matrix and K a list

@item @strong{Return:}
a codeword (row-matrix) if possible, resp. the 0-matrix (of size
1) if decoding is impossible.
@*For decoding the basic (Skorobogatov-Vladut) decoding algorithm
is applied.

@item @strong{Note:}
The list_expression should be the output K of the procedure
@code{prepSV}.@*
The matrix_expression should be a (1 x n)-matrix, where
n = ncols(K[1]).@*
The decoding may fail if the number of errors is greater than
the correction capacity of the algorithm.

@cindex SV-decoding algorithm
@end table
@strong{Example:}
@smallexample
@c computed example decodeSV d2t_singular/brnoeth_lib.doc:631 
LIB "brnoeth.lib";
int plevel=printlevel;
printlevel=-1;
ring s=2,(x,y),lp;
list HC=Adj_div(x3+y2+y);
@expansion{} The genus of the curve is 1
HC=NSplaces(1..2,HC);
HC=extcurve(2,HC);
@expansion{} Total number of rational places : NrRatPl = 9
def ER=HC[1][4];
setring ER;
intvec G=5;      // the rational divisor G = 5*HC[3][1]
intvec D=2..9;   // D = sum of the rational places no. 2..9 over F_4
// construct the corresp. residual AG code of type [8,3,>=5] over F_4:
matrix C=AGcode_Omega(G,D,HC);
@expansion{} Vector basis successfully computed 
// we can correct 1 error and the genus is 1, thus F must have degree 2
// and support disjoint from that of D
intvec F=2;
list SV=prepSV(G,D,F,HC);
@expansion{} Vector basis successfully computed 
@expansion{} Vector basis successfully computed 
@expansion{} Vector basis successfully computed 
// now we produce 1 error on the zero-codeword :
matrix y[1][8];
y[1,3]=a;
// and then we decode :
print(decodeSV(y,SV));
@expansion{} 0,0,0,0,0,0,0,0
printlevel=plevel;
@c end example decodeSV d2t_singular/brnoeth_lib.doc:631
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:657
@menu
See also:
* AGcode_Omega::
* extcurve::
* prepSV::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:657

@c ---end content decodeSV---

@c ------------------- closed_points -------------
@node closed_points, dual_code, decodeSV, brnoeth_lib
@subsubsection closed_points
@cindex closed_points
@c ---content closed_points---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
closed_points(I); I an ideal

@item @strong{Return:}
list of prime ideals (each a Groebner basis), corresponding to
the (distinct affine closed) points of V(I)

@item @strong{Note:}
The ideal must have dimension 0, the basering must have 2
variables, the ordering must be lp, and the base field must
be finite and prime.@*
It might be convenient to set the option(redSB) in advance.

@end table
@strong{Example:}
@smallexample
@c computed example closed_points d2t_singular/brnoeth_lib.doc:687 
LIB "brnoeth.lib";
ring s=2,(x,y),lp;
// this is just the affine plane over F_4 :
ideal I=x4+x,y4+y;
list L=closed_points(I);
// and here you have all the points :
L;
@expansion{} [1]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x+y
@expansion{} [2]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x+1
@expansion{} [3]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x+y+1
@expansion{} [4]:
@expansion{}    _[1]=y2+y+1
@expansion{}    _[2]=x
@expansion{} [5]:
@expansion{}    _[1]=y+1
@expansion{}    _[2]=x2+x+1
@expansion{} [6]:
@expansion{}    _[1]=y+1
@expansion{}    _[2]=x+1
@expansion{} [7]:
@expansion{}    _[1]=y+1
@expansion{}    _[2]=x
@expansion{} [8]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x2+x+1
@expansion{} [9]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x+1
@expansion{} [10]:
@expansion{}    _[1]=y
@expansion{}    _[2]=x
@c end example closed_points d2t_singular/brnoeth_lib.doc:687
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:697
@menu
See also:
* triang_lib::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:697

@c ---end content closed_points---

@c ------------------- dual_code -------------
@node dual_code, sys_code, closed_points, brnoeth_lib
@subsubsection dual_code
@cindex dual_code
@c ---content dual_code---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
dual_code(G); G a matrix of numbers

@item @strong{Return:}
a generator matrix of the dual code generated by G

@item @strong{Note:}
The input should be a matrix G of numbers. @*
The output is also a parity check matrix for the code defined by G

@cindex linear code, dual
@end table
@strong{Example:}
@smallexample
@c computed example dual_code d2t_singular/brnoeth_lib.doc:725 
LIB "brnoeth.lib";
ring s=2,T,lp;
// here is the Hamming code of length 7 and dimension 3
matrix G[3][7]=1,0,1,0,1,0,1,0,1,1,0,0,1,1,0,0,0,1,1,1,1;
print(G);
@expansion{} 1,0,1,0,1,0,1,
@expansion{} 0,1,1,0,0,1,1,
@expansion{} 0,0,0,1,1,1,1 
matrix H=dual_code(G);
print(H);
@expansion{} 1,1,1,0,0,0,0,
@expansion{} 1,0,0,1,1,0,0,
@expansion{} 0,1,0,1,0,1,0,
@expansion{} 1,1,0,1,0,0,1 
@c end example dual_code d2t_singular/brnoeth_lib.doc:725
@end smallexample
@c ---end content dual_code---

@c ------------------- sys_code -------------
@node sys_code, permute_L, dual_code, brnoeth_lib
@subsubsection sys_code
@cindex sys_code
@c ---content sys_code---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
sys_code(C); C is a matrix of constants

@item @strong{Return:}
list L with:
   @format
   L[1] is the generator matrix in standard form of an equivalent code,
   L[2] is the parity check matrix in standard form of such code,
   L[3] is an intvec which represents the needed permutation.
   @end format

@item @strong{Note:}
Computes a systematic code which is equivalent to the given one.@*
The input should be a matrix of numbers.@*
The output has to be interpreted as follows: if the input was
the generator matrix of an AG code then one should apply the
permutation L[3] to the divisor D of rational points by means
of @code{permute_L(D,L[3]);} before continuing to work with the
code (for instance, if you want to use the systematic encoding
together with a decoding algorithm).

@cindex linear code, systematic
@end table
@strong{Example:}
@smallexample
@c computed example sys_code d2t_singular/brnoeth_lib.doc:770 
LIB "brnoeth.lib";
ring s=3,T,lp;
matrix C[2][5]=0,1,0,1,1,0,1,0,0,1;
print(C);
@expansion{} 0,1,0,1,1,
@expansion{} 0,1,0,0,1 
list L=sys_code(C);
L[3];
@expansion{} 2,4,3,1,5
// here is the generator matrix in standard form
print(L[1]);
@expansion{} 1,0,0,0,1,
@expansion{} 0,1,0,0,0 
// here is the control matrix in standard form
print(L[2]);
@expansion{} 0, 0,1,0,0,
@expansion{} 0, 0,0,1,0,
@expansion{} -1,0,0,0,1 
// we can check that both codes are dual to each other
print(L[1]*transpose(L[2]));
@expansion{} 0,0,0,
@expansion{} 0,0,0 
@c end example sys_code d2t_singular/brnoeth_lib.doc:770
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:785
@menu
See also:
* AGcode_Omega::
* permute_L::
* prepSV::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:785

@c ---end content sys_code---

@c ------------------- permute_L -------------
@node permute_L,, sys_code, brnoeth_lib
@subsubsection permute_L
@cindex permute_L
@c ---content permute_L---
Procedure from library @code{brnoeth.lib} (@pxref{brnoeth_lib}).

@table @asis
@item @strong{Usage:}
permute_L( L, P ); L,P either intvecs or lists

@item @strong{Return:}
list obtained from L by applying the permutation given by P.

@item @strong{Note:}
If P is a list, all entries must be integers.

@end table
@strong{Example:}
@smallexample
@c computed example permute_L d2t_singular/brnoeth_lib.doc:811 
LIB "brnoeth.lib";
list L=list();
L[1]="a";
L[2]="b";
L[3]="c";
L[4]="d";
intvec P=1,3,4,2;
// the list L is permuted according to P :
permute_L(L,P);
@expansion{} [1]:
@expansion{}    a
@expansion{} [2]:
@expansion{}    c
@expansion{} [3]:
@expansion{}    d
@expansion{} [4]:
@expansion{}    b
@c end example permute_L d2t_singular/brnoeth_lib.doc:811
@end smallexample
@c inserted refs from d2t_singular/brnoeth_lib.doc:823
@menu
See also:
* AGcode_Omega::
* prepSV::
* sys_code::
@end menu
@c end inserted refs from d2t_singular/brnoeth_lib.doc:823

@c ---end content permute_L---
@c ----------------------------------------------------------
@node Release Notes, Index, SINGULAR libraries, Top
@chapter Release Notes
@cindex Release Notes
@comment -*-texinfo-*-
@comment This file was generated by doc2tex.pl from platform.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT platform.doc INSTEAD
@comment Id: platform.tex,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains Release notes and various howto's

@c The following directives are necessary for proper compilation
@c with emacs (C-c C-e C-r).  Please keep it as it is.  Since it
@c is wrapped in `@ignore' and `@end ignore' it does not harm `tex' or
@c `makeinfo' but is a great help in editing this file (emacs
@c ignores the `@ignore').

@menu
* News and changes::
* Downloading instructions::
* Unix installation instructions::
* Windows installation instructions::
* Macintosh installation instructions::
@end menu

@c ----------------------------------------------------------
@node News and changes, Downloading instructions,,Release Notes
@section News and changes
@cindex news
@cindex changes

@comment -*-texinfo-*-
@comment Id: NEWS.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@comment this file contains the News about Singular versions
@comment Unix

@majorheading NEWS in SINGULAR 2-0-4


@macro nref{what}
@ref{\what\}
@end macro

The current version 2-0-4 is an update to the 
release series version 2-0. 

Changes with respect to version 2-0-3:

@heading Factorizing algorithms revisited
Starting with version 2-0-4, we use NTL (by Victor Shoup) for factoring
univariate polynomials. The multivariate factoring code in libfac/factory
does now also work over algebraic extension fields.

@heading Help system is configurable via LIB/help.cnf
The help browsers of Singular can be configured via the file
LIB/help.cnf, also the addition of new help browsers is possible.

@heading Extensions of the ring concept

@table @asis
@item new coefficient domains: arbitrary long real and complex numbers
@item no restriction on number of parameters
@item degree bound on exponent values (maximum is now 2^31, standard 2^15)
@item non-positives weights get a better handling (converts wp/Wp to ws/Ws)
@item handle blocks of mixed orders correctly
@item maximal prime characteristic is now 2147483629 instead of 32003
@c @item TBC: parameters over real/complex
@c @item TBC: declaration with "ring of ring".
@end table

@heading Changes in @sc{Singular} libraries
The documentation of libraries was generally improved.
@table @asis
@item @ref{equising_lib}
procedures esStratum, isEquising now also for reducible polynomials
@*new procedures: tau_es (codim of mu-const stratum in semi-universal def. base);
esIdeal ((Wahl's) equisingularity ideal)
@item @ref{gaussman_lib}
added bernstein: roots of the Bernstein polynomial of t
@item @ref{hnoether_lib}
HNdevelop, reddevelop, essdevelop are obsolete, replaced by hnexpansion
@*multsequence is "repaired" (since branches computed by hnexpansion
et al) are now ordered according to the needs of multsequence.
@*newtonpoly needs no longer that ordering of the basering is ls
@*new procedures: is_NND      test if f is Newton non-degenerate
@item @ref{homolog_lib}
new procedures: depth, fitting, flatteningStrat, isCM, isFlat, isLocallyFree,
isReg, KoszulHomology, tensorMod, Tor
@item @ref{matrix_lib}
in proc tensor(A,B):  check if ncols(A)==0
@item @ref{normal_lib}
new procedure: deltaLoc(f,S);      (sum of) delta invariant(s) at conjugated
singular points
@*proc genus makes now use of is_NND of hnoether.lib
@item @ref{primdec_lib}
optimizations again
@item @ref{solve_lib}
procedure laguerre_solve ignores no longer the 2nd parameter (precision of 
internal computation)
@* new procedure simplexOut:     prints solution of simplex in nice format
@end table

@heading Internal Changes
@table @asis
@item normal form computation uses
Bucket representation of polynomials.
@item factorization
revisited, missing cases implemented
@item NTL
NTL is used for univariate factorization
@item source code
adapted for use with gcc 3.1/3.2, gmp 4.x
@end table

@heading Porting
@itemize @bullet
@item Singular is available for ix86-libc5, ix86-libc6, HPUX_9, HPUX_10,
SunOS-4, SunOS-5, IRIX-6, ix86-Win (Windows 95/98/ME/NT/2K/XP),
FreeBSD 4.x, MacOS X
@c @item @code{dbm} functionality is not available on 
Windows 95/98/ME/NT/2K/XP and MacOS X
@item @code{MP} functionality is not available on
Windows 95/98/ME/NT/2K/XP and MacOS X.
@item Singular 2-0-2 was the last version for MacOS 9
@end itemize

@c ----------------------------------------------------------
@node Downloading instructions, Unix installation instructions, News and changes, Release Notes
@section Downloading instructions
@cindex downloading
@cindex instructions, downloading
@cindex howto, download

@sc{Singular} is available as binary program for most common hard-
and software platforms. Release versions of @sc{Singular} can be
downloaded with ftp from our FTP site
@display
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/},
@end display
or, using your favorite WWW browser, from
@display
@uref{http://www.mathematik.uni-kl.de/ftp/pub/Math/Singular/}.
@end display

@comment -*-texinfo-*-
@comment Id: README_download.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@c FILE: README_download.texi
@c PURPOSE: downloading instructions, to be includeded in manual and README_ftp
@c


@heading To download @sc{Singular} for a Unix platform

Make sure that you have approximately 20 MByte of free disk space and follow
these steps.

@enumerate
@item
You need to download two (archive) files:
@table @code
@item Singular-2-0-4-share.tar.gz 
contains architecture independent data like documentation and libraries
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-share.tar.gz}
@item Singular-2-0-4-<uname>.tar.gz
contains architecture dependent executables, like the @sc{Singular}
program.
@end table
@code{<uname>} is a description of the processor and operating
system for which @sc{Singular} is compiled. Choose one of the following:
@multitable @columnfractions .2 .8
@item @code{ix86-Linux}
@tab PC's running under Linux with @code{libc} version 6 (e.g., for SuSe
Linux distribution version >= 6; RedHat Linux distribution version >= 5.2).
@*
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-Linux.tar.gz}
@item @code{ix86-Linux-libc5}
@tab PC's running under Linux with @code{libc} version 5 (if you are not 
sure which @code{libc} version you have, run @code{ldd /bin/ls}).
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-Linux-libc5.tar.gz}
@item @code{ix86-freebsd}
@tab 's running under FreeBSD
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-ix86-freebsd.tar.gz}
@item @code{ix86-Win}
@tab PC's running Windows 95/98/ME/NT/2K/XP which have Cygwin version 1.3.9 (or
higher) already installed. Unless you are familiar with Cygwin, we
recommend that you download one of the self-extracting archives as
described below.
@item @code{HPUX-9}
@tab HP workstations running under HPUX version 9
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-HPUX-9.tar.gz}
@item @code{HPUX-10}
@tab HP workstations running under HPUX version 10
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-HPUX-10.tar.gz}
@item @code{SunOS-5}
@tab Sun workstations running Solaris version 5
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-SunOS-5.tar.gz}
@item @code{IRIX-6}
@tab IRIX workstations running IRIX version 6
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-IRIX-6.tar.gz}
@item @code{AIX-4}
@tab AIX workstations running AIX version 4
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-AIX-4.tar.gz}
@item @code{PowerMacintosh-darwin}
@tab PowerMacintosh running Mac OS X
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/OsX/Singular-2-0-4-PowerMacintosh-darwin.tar.gz}
@item @code{DecAlpha-Linux}
@tab Digital Dec Alpha running Linux (RedHat 5.2)
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-DecAlpha-Linux.tar.gz}
@item @code{DecAlpha-OSF1}
@tab Digital Dec Alpha running OSF 1
@*@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/UNIX/Singular-2-0-4-DecAlpha-OSF1.tar.gz}
@end multitable
Please contact us if
you can not find an appropriate architecture dependent archive.

@item
Simply change to the directory in which you wish to install
@sc{Singular} (usually wherever you install 3rd-party software):
@smallexample
cd /usr/local/	
@end smallexample

@sc{Singular} specific subdirectories will be created in such a way
that multiple versions and multiple architecture dependent files
of @sc{Singular} can peaceably coexist under the same @code{/usr/local/}
tree.

@item
Unpack the archives:
@smallexample
gzip -dc Singular-2-0-4-<uname>.tar.gz | tar -pxf -
gzip -dc Singular-2-0-4-share.tar.gz | tar -pxf -
@end smallexample
If you have downloaded @code{Singular-2-0-4-share.zip},
unpack with 
@smallexample
unzip -u Singular-2-0-4-share.zip
@end smallexample

@item 
After unpacking, see the created file
@code{Singular/2-0-4/INSTALL} (which is also located at
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/INSTALL_unix.html}
for details on how to finish the installation.
@end enumerate

@heading To download @sc{Singular} for Windows 95/98/ME/NT/2K/XP

@enumerate
@item
Download one of the following self-extracting archives:
@table @code
@item @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/Singular-2-0-4-Compact.exe,Singular-2-0-4-Compact.exe}
Minimal archive to download. Installs Singular and minimal set of needed
tools and DLLs.
@item @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/Singular-2-0-4-Typical.exe,Singular-2-0-4-Typical.exe}
Typical archive to download. Installs Singular and the XEmacs editor to
run ESingular.
@end table

@item 
Double-click (or, execute), the self-extracting archives, and
@strong{carefully} follow the instructions given there.

@item 
If, while running setup, you obtain the following message 
@code{Setup failed to launch installation engine:} 
@code{Error loading type library/DLL}, then you need to download and execute Microsoft DCOM98 package
@uref{http://www.microsoft.com/com/dcom/dcom98/download.asp}. 
Such a problem could appear on Win 95/98.

@item
In case of problems, see the created file 
@code{/etc/INSTALL.txt} (which is also located at
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/WINDOWS/INSTALL_win.htm}
for details on how to finish the installation.
@end enumerate

@heading To download @sc{Singular} for the Macintosh
For the @sc{Singular} version for Mac OS X refer to the Unix section.
@*The @sc{Singular} version for Mac OS 9 is available as 
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-2-html.sea.hqx} (documentation) and @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-2-ppc-MPW.sea.hqx} (binaries and libraries). 
The file @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/INSTALL_mac.html}
gives details on how to finish the installation.




@c ----------------------------------------------------------
@node Unix installation instructions, Windows installation instructions,Downloading instructions, Release Notes
@section Unix installation instructions
@cindex Unix installation
@cindex instructions, Unix installation
@cindex howto, install on Unix

@comment -*-texinfo-*-
@comment Id: INSTALL_unix.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@c FILE: INSTALL_unix.texi
@c PURPOSE: Installation instruction for Singular on Unix
@c



@set _UNAME <uname>


To install @sc{Singular} on a
Unix
platform, you need the following two
archives:
@table @code
@item Singular-2-0-4-share.tar.gz
contains architecture independent data like documentation and libraries
(alternatively, you may also download
@code{Singular-2-0-4-share.zip}).
@item Singular-2-0-4-<uname>.tar.gz
contains architecture dependent executables, like the @sc{Singular}
program.
@end table
@*
@code{<uname>} is a description of the processor and operating system
for which @sc{Singular} is compiled (e.g, @code{ix86-Linux}). Please contact us if
you can not find an appropriate architecture dependent archive.

You can obtain these (and other) archives from
@display
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular}.
@end display


@heading To install SINGULAR

Make sure that you have approximately 12MByte of free disk space and follow
these steps.
@enumerate
@item
Simply change to the directory in which you wish to install
@sc{Singular} (usually wherever you install 3rd-party software), for example:
@smallexample
cd /usr/local
or
mkdir install;cd install 
(you do not need root privileges in this case)
@end smallexample

@sc{Singular} specific subdirectories will be created in such a way
that multiple versions and multiple architecture dependent files
of @sc{Singular} can peaceably coexist under the same @code{/usr/local}
tree.

@item
Unpack the archives:
@smallexample
gzip -dc <path_to>/Singular-2-0-4-<uname>.tar.gz | tar -pxf -
gzip -dc <path_to>/Singular-2-0-4-share.tar.gz | tar -pxf -
@end smallexample
@c version 2-0-x does not have *-share.zip:
@c If you have downloaded @code{Singular-@value{VERSION}-share.zip},
@c unpack with
@c @smallexample
@c unzip -u Singular-@value{VERSION}-share.zip
@c @end smallexample

This creates the the directory Singular/2-0-4 with 
@multitable @columnfractions .36 .64
@item (sub)directories
@tab  which contain
@item @code{<uname>}
@tab @code{Singular} and @code{ESingular} executables
@item @code{LIB}
@tab @sc{Singular} libraries (@code{*.lib} files)
@item @code{emacs}
@tab files for the @sc{Singular} Emacs user interface
@item @code{info}
@tab info files of @sc{Singular} manual
@item @code{html}
@tab html files of @sc{Singular} manual
@item @code{doc}
@tab miscellaneous documentation files
@item @code{examples}
@tab @sc{Singular} examples (@code{*.sing} files)
@end multitable

For the executable to work, the directory layout must look pretty much
like this; the executable looks for "sibling" directories at run-time
to figure out where its @sc{Singular} libraries and on-line
documentation files are. These constraints on the local directory layout
are necessary to avoid having to hard-code pathnames into the
executables, or require that environment variables be set before
running the executable. In particular, you @strong{must not move or copy}
the @sc{Singular} executables to another place, but use soft-links
instead.
@end enumerate

The following steps are optional:

@itemize @bullet
@item
Arrange that typing @code{Singular} at the shell prompt starts up the
installed @sc{Singular} executable.

If you have root permission, do:
@smallexample
ln -s `pwd`/Singular/2-0-4/<uname>/Singular  /usr/local/bin/Singular-2-0-4
ln -s `pwd`/Singular/2-0-4/<uname>/ESingular  /usr/local/bin/ESingular-2-0-4
ln -s /usr/local/bin/Singular-2-0-4 /usr/local/bin/Singular
ln -s /usr/local/bin/ESingular-2-0-4 /usr/local/bin/ESingular
@end smallexample
	
Otherwise, append the directory
@code{`pwd`/Singular/2-0-4/<uname>/} to your @code{$PATH}
environment variable. For the @code{csh} (or, @code{tcsh}) shell do:
@smallexample
set path=(`pwd`/Singular/2-0-4/<uname> $path)
@end smallexample
For the @code{bash} (or, @code{ksh}) shell do:
@smallexample
export PATH=`pwd`/Singular/2-0-4/<uname>/:$PATH
@end smallexample

You also might want to adjust your personal start-up files
(@code{~/.cshrc} for @code{csh}, @code{~/.tcshrc} for @code{tcsh}, or
@code{~/.profile} for @code{bash}) accordingly,
so that the @code{$PATH} variable is set automatically each time you login.

@strong{IMPORTANT:} Do @emph{never} move or copy the file
@code{Singular/2-0-4/<uname>/Singular} to another
place, but use soft-links instead.

@item
If you wish to use any of following features of
@sc{Singular}, make sure that the respective programs are installed on your system:

@multitable @columnfractions .5 .5
@item @strong{Feature} @tab @strong{Requires}
@item running @code{ESingular}, or @code{Singular} within Emacs
@tab @uref{http://www.fsf.org/software/emacs/emacs.html,,Emacs} version
20 or higher, or, @uref{http://www.xemacs.org,,XEmacs} version 20.3 or
higher (ESingular is only included in the Linux distribution,
on other Unix platforms you can download the
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/src/,,
Singular emacs lisp files} but we give no warranties for specific platforms).
@item on-line @code{html} help
@tab @uref{http://www.netscape.com,,netscape} browser
@item on-line @code{info} help
@tab @uref{http://www.texinfo.org,,info}, or
@uref{http://math-www.uni-paderborn.de/~axel/tkinfo/,,tkinfo} texinfo browser programs
@item TAB completion and history mechanism of ASCII-terminal interface
@tab shared @uref{ftp://ftp.de.uu.net/pub/gnu/readline/,,readline}
library, i.e. @code{/usr/lib/libreadline.so}
@item visualization of curves and surfaces
@tab
@uref{http://www.mathematik.uni-mainz.de/AlgebraischeGeometrie/surf/surf.shtml,,surf}
version 0.9 or higher (only available for Linux and Solaris).
@end multitable

You may download most of these programs from
@display
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils/}.
@end display

@item Customize the on-line help system:

By default, on-line help is displayed in the @code{html} format using
the @code{netscape} program.

However, this behavior can be customized in several ways
using the @sc{Singular} commands @code{system("--browser",<browser>)}
and @code{system("--allow-net", 1)} (or, by starting up @sc{Singular}
with the respective command line options).

In particular, creating the file
@code{Singular/2-0-4/LIB/.singularrc} and putting the
@sc{Singular} command
@smallexample
system("--allow-net", 1);
@end smallexample
in it, allows the on-line help system to fetch its @code{html} pages
from @uref{http://www.singular.uni-kl.de, Singular's WWW
home site}
in case its local html pages are not found. That is, you may delete your
local html pages, after setting this option.

See also
@ref{The online help system}, @ref{Command line options}, and
@ref{Startup sequence},
for more details on customizing the on-line help system.

@item
Add the line
@smallexample
* Singular:(singular.hlp).     A system for polynomial computations
@end smallexample
to your system-wide @code{dir} file (usually @code{/usr/info/dir} or
@code{/usr/local/info/dir} and  copy or soft-link the file
@code{Singular/2-0-4/info/singular.hlp}
to the directory of your @code{dir} file.
@*This assures that the
@sc{Singular} manual can be  accessed from stand-alone texinfo
browser programs such as @code{info} or @code{Emacs}.
(It is not necessary for the use of the help system from within @code{Singular}.)
@end itemize

@heading Troubleshooting

@itemize @bullet
@item General: @sc{Singular} can not find its libraries or on-line help
@enumerate
@item
Make sure that you have read and/or execute permission the files and
directories of the Singular distribution. If in doubt, @code{cd} to the
directory where you unpacked @sc{Singular}, and do (as root, if
necessary):
@smallexample
chmod -R a+rX Singular
@end smallexample

@item
Start up @sc{Singular}, and issue the command @code{system("Singular");}.
If this does not return the correct and expanded location of the
@sc{Singular} executable, then you found a bug in @sc{Singular}, which we
ask you to report (see below).
@item
Check whether the directories containing the libraries and on-line help
files can be found by @sc{Singular}: If @code{$bindir} denotes the
directory where the @sc{Singular} executable resides, then @sc{Singular}
looks for library files as follows:
@* (0) the current directory
@* (1) all dirs of the environment variable SINGULARPATH
@* (2) @code{$bindir/LIB}
@* (3) @code{$bindir/../LIB}
@* (4) @code{/usr/local/Singular/2-0-4/LIB}
@* (4) @code{/usr/local/Singular/LIB}
@* The on-line @code{info} files need to be at  @code{$bindir/../info} and the
@code{html} pages at @code{$bindir/../html}.
@end enumerate

You can inspect the found library and @code{info}/@code{html}
directories by starting up @sc{Singular} with the
@code{--version} option, or by issuing the @sc{Singular} command
@code{system("--version");}.

@item Under SuSE-Linux, @sc{ESingular} does not display a prompt:
@cindex SuSE, ESingular bug
@cindex ESingular, no prompt
@cindex bug, ESingular
This is due to the very restrictive access rights of @code{/dev/pty*} of
the standard @uref{http:/www.suse.de,SuSE} distribution (starting from
version 6.3 on). As root, do one of the following: Either
@example
chmod 666 /dev/pty*
@end example
or,
@example
chmod g+s $(which emacs)
chgrp tty $(which emacs)
chmod g+s $(which xemacs)
chgrp tty $(which xemacs)
@end example
See also @uref{http://sdb.suse.de/sdb/de/html/ke_devpts-63.html} for
details.

@item For @code{HPUX} systems:
@*The /etc/termcap files which are pre-installed on these systems are
broken which leads to messages like
@example
Name collision between 9826 9836
@end example
when @sc{Singular} is started. To fix this, you can get fixed termcap
files from @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/utils}
by downloading the files termcap-<uname-description> and either
replace your /etc/termcap file by the file found there, or view, and
redo the respective changes by @code{diff}'ing the downloaded and the
original file.

@item For @code{ix86-Linux} systems:
@*Due to some incompatibilities of shared libraries, the start-up of
@sc{Singular} might fail with messages like
@example
  Can not find shared library ...
@end example
For DEBIAN systems, try to do
@code{ln -s /usr/lib/libncurses.so /usr/lib/libncurses.so.4}.
@*If this fails (and on other systems)
download and install
@code{Singular-2-0-4-ix86-Linux-static.tar.gz}.

@item For @code{AIX} systems:
@*The default @code{info} program of the system is not GNU's texinfo
browser which is used to display the on-line documentation in the
@code{info} format. Therefore, the distribution of the AIX executable
already contains the @code{info} browser program.
If you remove this program, make sure that the GNU
@code{info} program is executed if you call '@code{info}' from your shell.

@item For any other troubles:
@*Please send an email to @email{singular@@mathematik.uni-kl.de}
and include the header which is displayed by starting up @sc{Singular}
with the @code{-v} option, and a description of your machine (issue the
command @code{uname -a} on your shell) in your report.
@end itemize




@c ----------------------------------------------------------
@node Windows installation instructions, Macintosh installation instructions, Unix installation instructions, Release Notes
@section Windows installation instructions
@cindex Windows installation
@cindex instructions, Windows installation
@cindex howto, install on Windows

@comment -*-texinfo-*-
@comment Id: INSTALL_win.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@c FILE:    INSTALL.texi
@c PURPOSE: Installation instructions for Singular on MSWindows
@c          This file is displayed during installation and copied to
@c          /etc/INSTALL

@c use set CD for producing a special INSTALL_win which will be opened
@c by the autorun on the Singular CD




@heading For the impatient:
@itemize
@item
If you run Windows NT/2K/XP, make sure you are logged in with the
@code{Administrator} rights.
@item
If you have some older version of @code{Singular} installed, please uninstall it
before installing @code{Singular-2-0-4}. It is recommended to
install the new @code{Singular} in the same directory where the previous
version was installed. Thus your existing environment will be used automatically.
@item 
If you have @code{Cygwin} or @code{XEmacs} installed and they do not belong
of some previous @code{Singular} installation,
please read the information below.
@item
Execute the self-extracting installation archive and
@strong{carefully} follow the instructions given there. 
Setup will analyze your system, create the corresponding configuration
and give you further tips on the installation process.
@item
In case of troubles, see the installed files @code{/etc/INSTALL.txt},
@code{/etc/TROUBLESHOOTING.txt} or visit
the @strong{Singular Forum} at @uref{http://www.singular.uni-kl.de/forum}.
@end itemize


@heading Installation preliminaries

Running @code{Singular} on MS Windows requires that the Cygwin DLL
(dynamically linked library) version 1.3.9 or higher is installed on your
system (see @uref{http://sources.redhat.com/cygwin/} for details about
Cygwin). We install and configure @code{Cygwin} version 1.3.9 automatically, if
the @code{BasicCygwin} component is selected (default setting).

To run @code{ESingular} (i.e. @code{Singular} within its Emacs interface) on
MS Windows requires furthermore that the @code{XEmacs} editor is installed on
your system. We install and configure @code{XEmacs} version 21.1.13 automatically, if the @code{XEmacs} component is selected.

@cindex Windows installation, components
@cindex Components of Windows installation

The @code{Singular} installation is divided into the following
components (you see them explicitly if you choose the Custom Setup Type
during the installation):
@table @code
@item @strong{Program Files:}
        @table @code
@item Singular
Contains the @code{Singular} Program, documentation and example files.
@*All files of this component are installed under the directory
@code{/usr/local/Singular/2-0-4}
@item BasicCygwin
Contains the Cygwin DLL and basic tools/programs (like @code{bash} or
@code{info}) of the  Cygwin environment.
@*The Cygwin DLL and programs are installed in the directory
@code{/bin}. Miscellaneous documentation and configuration files are
installed into the directory @code{/etc}.
@item XEmacs
Contains the Cygwin port of the @code{XEmacs} editor (see
@url{http://www.xemacs.org} for more about @code{XEmacs}) version 21.1.13.
@*All files of this component are installed under the directory
@code{/usr/local}.
@item ESingular
Contains the @code{ESingular}, the most comfortable Singular interface.
Requires @code{XEmacs} to run.
        @end table
@item @strong{Remark:}
All essential DLLs, some programs and symbolic links are installed in the directory
@code{/usr/local/Singular/2-0-4/ix86-Win}, which must be present in your @code{PATH} system variable.
@item @strong{Help Files:}
@table @code
@item WinHelp
Contains Singular Manual, converted to Windows help format (.hlp).
We recommend to install it, because it is small in size. Moreover,
we set it as default help browser in all the Singular executables.
@item HTML Help
Contains the "native" Singular Manual. It's not included by default,
because it is much bigger than WinHelp, though it has better typesetting
of mathematical formulae.
@end table
@end table

The Typical Setup Type of the Singular-2-0-4-Typical.exe contains
@code{BasicCygwin}, @code{Singular}, 
@code{XEmacs}, @code{ESingular}, @code{WinHelp} and @code{HTML Help} 
components. The Compact Setup Type does not contain only the @code{HTML Help} component.

@heading Downloading preliminaries

To install @code{Singular} on a PC running Windows 95/98/ME/NT/2K/XP, you need
to download @strong{one} of the following archive files:

Minimal archive: @uref{Singular-2-0-4-Compact.exe, Singular-2-0-4-Compact.exe}      (@code{BasicCygwin}, @code{Singular}, @code{WinHelp} components)

Typical archive : @uref{Singular-2-0-4-Typical.exe, Singular-2-0-4-Typical.exe}      (@code{BasicCygwin}, @code{Singular}, @code{XEmacs}, @code{ESingular}, @code{WinHelp}, @code{HTML Help} components)

You can obtain these (and other) archives 
either from the @code{WINDOWS} directory on the @code{Singular} CD or from
@display
@uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular/}.
@end display



@heading Installing Singular

The recent Setup program analyzes your system, e.g. it detects
whether Cygwin and XEmacs are present and functional. Then it gives you
hints and/or error messages with instructions during the installation.

@table @code
@item If you have Cygwin installed
        If the version of @code{cygwin1.dll} is not less than 1.3.9,
        you will be prompted that the @code{BasicCygwin} component will not
        be installed. Moreover, the existing Cygwin root directory will be proposed as
        the default installation directory. You can accept it, then
        @code{Singular} will be placed into the existing Cygwin environment.
        If you choose another destination, @code{Singular} will use Cygwin
        programs anyway. If your Cygwin has incorrect settings (like
        inconsistent mount points among the important ones), @code{Singular}
        Setup will correct them. 
@*      If setup could not detect @code{cygwin}, present in the system, you
        can try to break the installation, start it once more, choose the
        "Custom" setup type and unselect the @code{BasicCygwin} component.

@item If you have XEmacs installed
        The @code{Cygwin} port of @code{XEmacs} version 21.1.13 together 
        with the most
        important packages is included in the distribution. The use of 
        non-@code{Cygwin} ports or earlier @code{Cygwin} ports has some 
        quirks and does not work 
        properly together with @code{Singular} (i.e., running @code{ESingular} 
        results in problems). Nevertheless, if you want to test the
        compatibility of @code{ESingular} with your own @code{XEmacs}, just
        de-select the XEmacs component, but leave @code{ESingular} selected.
        If your @code{XEmacs} happens to be incompatible with ESingular, you can
        install just the XEmacs component and use in fact two different
        @code{XEmacs} programs. 
        The setup program will search for @code{XEmacs} and packages 
        in @code{<TARGETDIR>/usr/local/lib} (here @code{<TARGETDIR>} is the directory which you selected while running setup). If you have @code{Cygwin} and the Cygwin port of
        @code{XEmacs}, you might have @code{XEmacs} installed there. To avoid overwriting your @code{XEmacs} files, setup will ask you what to do.
@end table


@heading Customizing Singular

The following step(s) are optional:
@itemize
@item
To conveniently access all files on your computer, mount the drives of
your disk(s):
@enumerate
@item
Open a rxvt terminal (from Start->Programs->Singular 2.0->Tools).
@item
For each drive (letter) issue the following command (the drive @code{C:}
is used in the example):
@example
mount -f -s -t C: /C
@end example
@end enumerate
After mounting the drive(s) this way, you can conveniently access the
files on a drive from the @code{bash} shell and from @code{XEmacs} using the @code{/C/} prefix. Otherwise, you need to type @code{/cygdrive/C} - that is
the Cygwin convention. You can get more information on @code{mount} command by invoking @code{mount --help}. Command @code{umount} unmount the selected
mount point.


@item
Create your personal @code{HOME} directory.
@*Various applications (e.g., @code{bash} or @code{XEmacs}) store
user-specific configuration/customization files in the @code{HOME}
directory of the current user. During the installation, the @code{HOME}
directory is globally set for all users to @code{/home/Singular}. To
create your individual  @code{HOME} directory follow these steps:
@enumerate
@item
Create a directory (folder), say, @code{C:\home\MyHome}.
@item
Copy all files from @code{/home/Singular} to @code{C:\home\MyHome}.
@item
Set the @emph{user} environment variable @code{HOME} to @code{C:\home\MyHome}:
@*On Windows 95/98/ME, edit the respective line the @code{AUTOEXEC.BAT}
file.
@*On Windows NT/2K/XP add an entry in your @code{Environment} control
panel.
@item
Restart your computer (On Windows 95/98/ME).
@end enumerate
You may furthermore examine the files copied into your @code{HOME}
directory and adjust (i.e. edit) them to your personal
preferences/needs. System-wide settings are stored in the file 
@code{/etc/profile}.

@end itemize

@heading Uninstalling Singular

You can uninstall individual or all installed components by opening the
@code{Software} shortcut of the @code{Control panel}. 
Simply double-click the @code{Singular} item and
follow the instructions given there.


For any other troubles,
please send an email to @email{singular@@mathematik.uni-kl.de}
and include the header which is displayed by starting up @code{Singular}
with the @code{-v} option, and a description of your machine and
operating system.




@c ----------------------------------------------------------
@node Macintosh installation instructions,,Windows installation instructions, Release Notes
@section Macintosh installation instructions
@cindex Macintosh installation
@cindex instructions, Macintosh installation
@cindex howto, install on Macintosh

For the SINGULAR version for Mac OS X refer to the Unix section.
The SINGULAR version for Mac OS 9 is available as
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-4-html.sea.hqx'
(documentation) and
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/Singular-2-0-4-ppc-MPW.sea.hqx'
(binaries and libraries).  The file
`ftp://www.mathematik.uni-kl.de/pub/Math/Singular/MAC/classic/INSTALL_mac.txt'
gives details on how to finish the installation.

@comment -*-texinfo-*-
@comment Id: INSTALL_mac.texi,v 1.1 2003/08/08 14:27:06 pertusus Exp $
@c FILE:    INSTALL_classicMac.texi
@c PURPOSE: Installation instructions for Singular on Macintosh



@heading Installation preliminaries

This is the final distribution of @sc{Singular} as MPW tool.
Newer versions of @sc{Singular} will only be available for MacOS X (which is handled like other @sc{Unix}-systems).
To install @sc{Singular} on a Macintosh (PPC only), you need the file @code{Singular-2-0-2-ppc-MPW.sea.hqx} resp. @code{Singular-2-0-2-ppc-MPW.hqx} which you can obtain by public ftp from @uref{ftp://www.mathematik.uni-kl.de/pub/Math/Singular}.
Furthermore, you need MacOS version >= 8.5 with an installed MPW shell. 
This version works also without Carbon.



@heading Installing @sc{Singular} on MacOS X

Please see @uref{INSTALL_unix.html}. 
In contrast to other Unix systems, under MacOS X, @sc{Singular} is only available as a shell command and there is no Emacs interface.
Enter @code{Singular} in a terminal under Aqua to run @sc{Singular}.
Alternatively, you may choose @code{Terminal} as the application to open the file @code{Singular} with and put it into the dock.


@heading Installing Singular

@enumerate

@item
Make sure that you have MPW  installed on your system. 
See below for instructions on how to install MPW and how to avoid conflicts with the @code{Carbon.lib}.

@item
Download the file @code{Singular-2-0-2-ppc-MPW.sea.hqx}.

@item
Expand the downloaded file using a standard Expander (like Compact Pro or StuffIt) to obtain the corresponding self-extracting @code{Singular-2-0-2-ppc-MPW.sea} file.

@item
Click on the self-extracting @code{Singular-2-0-2-ppc-MPW.sea} file. 
This  will create a new folder named @code{Singular:} which contains the @sc{Singular} program in the subfolder @code{2-0-2:ppc-MPW:}. 
Do not change the structure of the subfolders.

@item
Make the folder which contains the executable to the working directory of the MPW shell. 
To start @sc{Singular}, you need to type @code{Singular} in the MPW worksheet. 
Clicking on the @sc{Singular} icon on the desktop, starts up the MPW shell (the working directory of the MPW shell is then the directory of the executable). 
If you start the MPW shell manually, you must set the working directory to the directory of the @sc{Singular} program. 
You may use the directory menu or write into the startup file of the MPW shell the line
@smallexample
setdirectory "@{Boot@}"Singular:2-0-2:ppc-MPW:
@end smallexample
if @code{"@{Boot@}"Singular:2-0-2:ppc-MPW:} is the folder of the executable.

After unpacking, you will have a directory structure like:
@table @code
@item Singular:2-0-2:ppc-MPW:Singular
Singular executable
@item Singular:2-0-2:ppc-MPW:libparse
parser for Singular libraries
@item Singular:2-0-2:LIB:
Singular libraries
@item Singular:2-0-2:LIB:gftables:
Singular gftables
@item Singular:2-0-2:doc:singular.idx
index of inline help
@item Singular:2-0-2:doc:singular.hlp
file for inline help
@item Singular:2-0-2:README
information of the distribution
@item Singular:2-0-2:README.hlml
@item Singular:2-0-2:COPYING
license information
@item Singular:2-0-2:COPYING.html
@item Singular:2-0-2:NEWS
news in the distribution
@item Singular:2-0-2:NEWS.html
@item Singular:2-0-2:INSTALL
instructions like this file
@end table

The @sc{Singular} libraries have a special form to work here. 
Do not use the libraries from other distributions. 
They are not compatible. 
A supplementary file is @code{Singular-2-0-2-html.sea.hqx} which contains the html pages. 
You can use this with a browser but not from the program @sc{Singular}.
The self-extracting archive will create the folder @code{html:} and you may extract it at @code{"@{Boot@}"Singular:2-0-2:}.

@end enumerate


@heading Installing MPW

The final version of MPW is downloadable from Apple at @uref{ftp://ftp.apple.com/developer/Tool_Chest/Core_Mac_OS_Tools/MPW_etc./MPW-GM_Images/}.
Older versions of @code{Carbon.lib} may conflict with the latest MPW. 
In this case, you need to update @code{Carbon.lib} or work without it.


@heading Restrictions

Some typical Unix features of @sc{Singular} are not working with MPW, e.g. links and cooperation with other programs like XEmacs and xterm.

For any other troubles, please send an email to @email{singular@@mathematik.uni-kl.de} and include the header which is displayed by starting up @sc{Singular}
with the @code{-v} option, and a description of your machine and operating system.




@c ----------------------------------------------------------
@node Index, , Release Notes, Top
@chapter Index
@cindex Index
@printindex cp
@c ---------------------------------------------------------

@c generate table of content and short table of content
@contents
@bye
