<div id="What-is-CVS-not_003f"></div>
<div class="header">
<p>
Next: [[cvs: A sample session#A sample session|A sample session]], Previous: [[cvs: What is CVS?#What is CVS?|What is CVS?]], Up: [[cvs: Overview#Overview|Overview]] &nbsp; |[[cvs: Index#SEC_Contents|Contents]]||[[cvs: Index#Index|Index]]|</p>
</div>

----

<div id="What-is-CVS-not_003f-1"></div>
=== What is CVS not? ===
<div id="index-What-is-CVS-not_003f"></div>

<small>CVS</small> can do a lot of things for you, but it does
not try to be everything for everyone.

;<small>CVS</small> is not a build system.

: Though the structure of your repository and modules file interact with your build system (e.g. &lsquo;<tt>Makefile</tt>&rsquo;s), they are essentially independent.

: <small>CVS</small> does not dictate how you build anything.  It merely stores files for retrieval in a tree structure you devise.

: <small>CVS</small> does not dictate how to use disk space in the checked out working directories.  If you write your &lsquo;<tt>Makefile</tt>&rsquo;s or scripts in every directory so they have to know the relative positions of everything else, you wind up requiring the entire repository to be checked out.

: If you modularize your work, and construct a build system that will share files (via links, mounts, <code>VPATH</code> in &lsquo;<tt>Makefile</tt>&rsquo;s, etc.), you can arrange your disk usage however you like.

: But you have to remember that ''any'' such system is a lot of work to construct and maintain.  <small>CVS</small> does not address the issues involved.

: Of course, you should place the tools created to support such a build system (scripts, &lsquo;<tt>Makefile</tt>&rsquo;s, etc) under <small>CVS</small>.

: Figuring out what files need to be rebuilt when something changes is, again, something to be handled outside the scope of <small>CVS</small>.  One traditional approach is to use <code>make</code> for building, and use some automated tool for generating the dependencies which <code>make</code> uses.

: See [[cvs: How your build system interacts with CVS#How your build system interacts with CVS|Builds]], for more information on doing builds in conjunction with <small>CVS</small>.

;<small>CVS</small> is not a substitute for management.

: Your managers and project leaders are expected to talk to you frequently enough to make certain you are aware of schedules, merge points, branch names and release dates.  If they don&rsquo;t, <small>CVS</small> can&rsquo;t help.

: <small>CVS</small> is an instrument for making sources dance to your tune.  But you are the piper and the composer.  No instrument plays itself or writes its own music.

;<small>CVS</small> is not a substitute for developer communication.

: When faced with conflicts within a single file, most developers manage to resolve them without too much effort.  But a more general definition of &ldquo;conflict&rdquo; includes problems too difficult to solve without communication between developers.

: <small>CVS</small> cannot determine when simultaneous changes within a single file, or across a whole collection of files, will logically conflict with one another.  Its concept of a <em>conflict</em> is purely textual, arising when two changes to the same base file are near enough to spook the merge (i.e. <code>diff3</code>) command.

: <small>CVS</small> does not claim to help at all in figuring out non-textual or distributed conflicts in program logic.

: For example: Say you change the arguments to function <code>X</code> defined in file &lsquo;<tt>A</tt>&rsquo;.  At the same time, someone edits file &lsquo;<tt>B</tt>&rsquo;, adding new calls to function <code>X</code> using the old arguments.  You are outside the realm of <small>CVS</small>&rsquo;s competence.

: Acquire the habit of reading specs and talking to your peers.


;<small>CVS</small> does not have change control

: Change control refers to a number of things.  First of all it can mean <em>bug-tracking</em>, that is being able to keep a database of reported bugs and the status of each one (is it fixed?  in what release?  has the bug submitter agreed that it is fixed?).  For interfacing <small>CVS</small> to an external bug-tracking system, see the &lsquo;<tt>rcsinfo</tt>&rsquo; and &lsquo;<tt>verifymsg</tt>&rsquo; files (see [[cvs: Reference manual for Administrative files#Reference manual for Administrative files|Administrative files]]).

: Another aspect of change control is keeping track of the fact that changes to several files were in fact changed together as one logical change.  If you check in several files in a single <code>cvs commit</code> operation, <small>CVS</small> then forgets that those files were checked in together, and the fact that they have the same log message is the only thing tying them together.  Keeping a <small>GNU</small> style &lsquo;<tt>ChangeLog</tt>&rsquo; can help somewhat.

: Another aspect of change control, in some systems, is the ability to keep track of the status of each change.  Some changes have been written by a developer, others have been reviewed by a second developer, and so on.  Generally, the way to do this with <small>CVS</small> is to generate a diff (using <code>cvs diff</code> or <code>diff</code>) and email it to someone who can then apply it using the <code>patch</code> utility.  This is very flexible, but depends on mechanisms outside <small>CVS</small> to make sure nothing falls through the cracks.

;<small>CVS</small> is not an automated testing program

: It should be possible to enforce mandatory use of a testsuite using the <code>commitinfo</code> file.  I haven&rsquo;t heard a lot about projects trying to do that or whether there are subtle gotchas, however.

;<small>CVS</small> does not have a builtin process model

: Some systems provide ways to ensure that changes or releases go through various steps, with various approvals as needed.  Generally, one can accomplish this with <small>CVS</small> but it might be a little more work. In some cases you&rsquo;ll want to use the &lsquo;<tt>commitinfo</tt>&rsquo;, &lsquo;<tt>loginfo</tt>&rsquo;, &lsquo;<tt>rcsinfo</tt>&rsquo;, or &lsquo;<tt>verifymsg</tt>&rsquo; files, to require that certain steps be performed before cvs will allow a checkin.  Also consider whether features such as branches and tags can be used to perform tasks such as doing work in a development tree and then merging certain changes over to a stable tree only once they have been proven.


----

<div class="header">
<p>
Next: [[cvs: A sample session#A sample session|A sample session]], Previous: [[cvs: What is CVS?#What is CVS?|What is CVS?]], Up: [[cvs: Overview#Overview|Overview]] &nbsp; |[[cvs: Index#SEC_Contents|Contents]]||[[cvs: Index#Index|Index]]|</p>
</div>
This document was generated on ''a sunny day'' using [http://www.gnu.org/software/texinfo/ ''texi2html''].
