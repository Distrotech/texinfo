<div id="Alias-modules"></div>
<div class="node">
<p>
Next: [cvs: Regular modules#Regular-modules Regular modules], Up: [cvs: The modules file#modules modules] &nbsp; |[cvs: Index#SEC_Contents Contents]||[cvs: Index#Index Index]|</p>
</div>
<hr>
<div id="Alias-modules-1"></div>
==== Alias modules ====
<div id="index-Alias-modules"></div>
<div id="index-_002da_002c-in-modules-file"></div>

<p>Alias modules are the simplest kind of module:
</p>
<dl compact="compact">
<dt><code><var>mname</var> -a <var>aliases</var>&hellip;</code></dt>
<dd><p>This represents the simplest way of defining a module
<var>mname</var>.  The &lsquo;<samp>-a</samp>&rsquo; flags the definition as a
simple alias: <small>CVS</small> will treat any use of <var>mname</var> (as
a command argument) as if the list of names
<var>aliases</var> had been specified instead.
<var>aliases</var> may contain either other module names or
paths.  When you use paths in aliases, <code>checkout</code>
creates all intermediate directories in the working
directory, just as if the path had been specified
explicitly in the <small>CVS</small> arguments.
</p></dd>
</dl>

<p>For example, if the modules file contains:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><nowiki>amodule -a first-dir
</nowiki></pre></td></tr></table>

<p>then the following two commands are equivalent:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><nowiki>$ cvs co amodule
$ cvs co first-dir
</nowiki></pre></td></tr></table>

<p>and they each would provide output such as:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example"><nowiki>cvs checkout: Updating first-dir
U first-dir/file1
U first-dir/file2
cvs checkout: Updating first-dir/sdir
U first-dir/sdir/sfile
</nowiki></pre></td></tr></table>

This document was generated on <i>a sunny day</i> using [http://www.nongnu.org/texi2html/ <i>texi2html</i>].
