14 File Handling
****************

  The basic unit of stored data in Unix is the file.  To edit a file,
you must tell Emacs to examine the file and prepare a buffer containing a
copy of the file's text.  This is called visiting the file.  Editing
commands apply directly to text in the buffer; that is, to the copy inside
Emacs.  Your changes appear in the file itself only when you save the
buffer back into the file.

  Emacs is also able to handle "remote files" which are stored on
other hosts.  Not only is Emacs somewhat aware of the special issues
involved with network file systems, but it can also use FTP and ssh (or
rsh) to make local copies of the files, and refresh them on the remote
host automatically when you save the buffer.  The FTP interface is
provided by the standard `efs' package (efs)EFS.  The
ssh/rsh interface is provided by the optional `tramp' package
(tramp)TRAMP.  These packages attempt to implement all of
the operations described below, making remote file use transparent
(except for unavoidable network delays).

  In addition to visiting and saving files, Emacs can delete, copy, rename,
and append to files, and operate on file directories.

* File Names::       How to type and edit file name arguments.
* Visiting::         Visiting a file prepares Emacs to edit the file.
* Saving::           Saving makes your changes permanent.
* Reverting::        Reverting cancels all the changes not saved.
* Auto Save::        Auto Save periodically protects against loss of data.
* Version Control::  Version control systems (RCS and SCCS).
* ListDir::          Listing the contents of a file directory.
* Comparing Files::  Finding where two files differ.
* Dired::            "Editing" a directory to delete, rename, etc.
                     the files in it.
* Misc File Ops::    Other things you can do on files.

14.1 File Names
===============

  Most Emacs commands that operate on a file require you to specify the
file name.  (Saving and reverting are exceptions; the buffer knows which
file name to use for them.)  File names are specified in the minibuffer
(see Minibuffer).  Completion is available, to make it easier to
specify long file names.  See Completion.

  There is always a default file name which is used if you
enter an empty argument by typing just <RET>.  Normally the default
file name is the name of the file visited in the current buffer; this
makes it easy to operate on that file with any of the Emacs file
commands.

The syntax for accessing remote files unfortunately varies depending on
the method used.  The syntax for using FTP is
`/user@remote-host:path-on-remote-host'.  The
syntax for using ssh is
`/[user@remote-host]path-on-remote-host'.

  In both cases the `user@' portion is optional (it defaults
to your local user name).  path-on-remote-host may use the
`~' notation to indicate user's home directory on the remote
host.  The default file name will reflect the remote host information.

  Each buffer has a default directory, normally the same as the
directory of the file visited in that buffer.  When Emacs reads a file
name, the default directory is used if you do not specify a directory.
If you specify a directory in a relative fashion, with a name that does
not start with a slash, it is interpreted with respect to the default
directory.  The default directory of the current buffer is kept in the
variable default-directory, which has a separate value in every
buffer.  The value of the variable should end with a slash.

  For example, if the default file name is `/u/rms/gnu/gnu.tasks' then
the default directory is `/u/rms/gnu/'.  If you type just `foo',
which does not specify a directory, it is short for `/u/rms/gnu/foo'.
`../.login' would stand for `/u/rms/.login'.  `new/foo'
would stand for the filename `/u/rms/gnu/new/foo'.

  When visiting a remote file via EFS or TRAMP, the remote directory
becomes the default directory (see Visiting) for that buffer, just
as a local directory would.

The variable default-directory-alist takes an alist of major
modes and their opinions on default-directory as a Lisp
expression to evaluate.  A resulting value of nil is ignored in
favor of default-directory.

You can create a new directory with the function make-directory,
which takes as an argument a file name string. The current directory is
displayed in the minibuffer when the function is called; you can delete
the old directory name and supply a new directory name. For example, if
the current directory is `/u/rms/gnu', you can delete `gnu'
and type `oryx' and <RET> to create `/u/rms/oryx'.
Removing a directory is similar to creating one.  To remove a directory,
use remove-directory; it takes one argument, a file name string.

  The command M-x pwd prints the current buffer's default directory,
and the command M-x cd sets it (to a value read using the
minibuffer).  A buffer's default directory changes only when the cd
command is used.  A file-visiting buffer's default directory is initialized
to the directory of the file that is visited there.  If a buffer is created
with C-x b, its default directory is copied from that of the
buffer that was current at the time.

  The default directory name actually appears in the minibuffer when the
minibuffer becomes active to read a file name.  This serves two
purposes: it shows you what the default is, so that you can type a
relative file name and know with certainty what it will mean, and it
allows you to edit the default to specify a different directory.  To
inhibit the insertion of the default directory, set the variable
insert-default-directory to nil.

  Note that it is legitimate to type an absolute file name after you
enter the minibuffer, ignoring the presence of the default directory
name.  The final minibuffer contents may look invalid, but that is not
so.  See Minibuffer File.

  `$' in a file name is used to substitute environment variables.  For
example, if you have used the shell command `setenv FOO rms/hacks' to
set up an environment variable named `FOO', then you can use
`/u/$FOO/test.c' or `/u/${FOO}/test.c' as an abbreviation for
`/u/rms/hacks/test.c'.  The environment variable name consists of all
the alphanumeric characters after the `$'; alternatively, it may be
enclosed in braces after the `$'.  Note that the `setenv' command
affects Emacs only if done before Emacs is started.

  To access a file with `$' in its name, type `$$'.  This pair
is converted to a single `$' at the same time variable substitution
is performed for single `$'.  The Lisp function that performs the
substitution is called substitute-in-file-name.  The substitution
is performed only on filenames read as such using the minibuffer.

14.2 Visiting Files
===================

C-x C-f
Visit a file (find-file).
C-x C-v
Visit a different file instead of the one visited last
(find-alternate-file).
C-x 4 C-f
Visit a file, in another window (find-file-other-window).  Don't
change this window.
C-x 5 C-f
Visit a file, in another frame (find-file-other-frame).  Don't
change this window or frame.

  Visiting a file means copying its contents into an Emacs buffer
so you can edit it.  Emacs creates a new buffer for each file you
visit.  We say that the buffer is visiting the file that it was created
to hold.  Emacs constructs the buffer name from the file name by
throwing away the directory and keeping just the file name.  For example,
a file named `/usr/rms/emacs.tex' is displayed in a buffer named
`emacs.tex'.  If a buffer with that name exists, a unique
name is constructed by appending `<2>', `<3>',and so on, using
the lowest number that makes a name that is not already in use.

  Each window's mode line shows the name of the buffer that is being displayed
in that window, so you can always tell what buffer you are editing.

  The changes you make with Emacs are made in the Emacs buffer.  They do
not take effect in the file that you visit, or any other permanent
place, until you save the buffer.  Saving the buffer means that
Emacs writes the current contents of the buffer into its visited file.
See Saving.

  If a buffer contains changes that have not been saved, the buffer is said
to be modified.  This is important because it implies that some
changes will be lost if the buffer is not saved.  The mode line displays
two stars near the left margin if the buffer is modified.

  To visit a file, use the command C-x C-f (find-file).  Follow
the command with the name of the file you wish to visit, terminated by a
<RET>.  If you are using XEmacs under X, you can also use the
Open... command from the File menu bar item. 

  The file name is read using the minibuffer (see Minibuffer), with
defaulting and completion in the standard manner (see File Names).
While in the minibuffer, you can abort C-x C-f by typing C-g.

  C-x C-f has completed successfully when text appears on the
screen and a new buffer name appears in the mode line.  If the specified
file does not exist and could not be created or cannot be read, an error
results.  The error message is printed in the echo area, and includes
the name of the file that Emacs was trying to visit.

  If you visit a file that is already in Emacs, C-x C-f does not make
another copy.  It selects the existing buffer containing that file.
However, before doing so, it checks that the file itself has not changed
since you visited or saved it last.  If the file has changed, Emacs
prints a warning message.  See Simultaneous Editing.

You can switch to a specific file called out in the current buffer by
calling the function find-this-file. By providing a prefix
argument, this function calls filename-at-point and switches to a
buffer visiting the file filename. It creates one if none already
exists. You can use this function to edit the file mentioned in the
buffer you are working in or to test if the file exists. You can do that
by using the minibuffer completion after snatching the all or part of
the filename.

If the variable find-file-use-truenames's value is
non-nil, a buffer's visited filename will always be traced back
to the real file. The filename will never be a symbolic link, and there
will never be a symbolic link anywhere in its directory path. In other
words, the buffer-file-name and buffer-file-truename will
be equal.

If the variable find-file-compare-truenames value is
non-nil, the find-file command will check the
buffer-file-truename of all visited files when deciding whether a
given file is already in a buffer, instead of just
buffer-file-name.  If you attempt to visit another file which is
a symbolic link to a file that is already in a buffer, the existing
buffer will be found instead of a newly created one.  This works if any
component of the pathname (including a non-terminal component) is a
symbolic link as well, but doesn't work with hard links (nothing does).

   If you want to create a file, just visit it.  Emacs prints
`(New File)' in the echo area, but in other respects behaves as if you
had visited an existing empty file.  If you make any changes and save them,
the file is created.

  If you visit a nonexistent file unintentionally (because you typed the
wrong file name), use the C-x C-v (find-alternate-file)
command to visit the file you wanted.  C-x C-v is similar to C-x
C-f, but it kills the current buffer (after first offering to save it if
it is modified).  C-x C-v is allowed even if the current buffer
is not visiting a file.

  If the file you specify is actually a directory, Dired is called on
that directory (see Dired).  To inhibit this, set the variable
find-file-run-dired to nil; then it is an error to try to
visit a directory.

  C-x 4 f (find-file-other-window) is like C-x C-f
except that the buffer containing the specified file is selected in another
window.  The window that was selected before C-x 4 f continues to
show the same buffer it was already showing.  If you use this command when
only one window is being displayed, that window is split in two, with one
window showing the same buffer as before, and the other one showing the
newly requested file.  See Windows.

C-x 5 C-f (find-file-other-frame) is like C-x C-f
except that it creates a new frame in which the file is displayed.

 Use the function find-this-file-other-window to edit a file
mentioned in the buffer you are editing or to test if that file exists.
To do this, use the minibuffer completion after snatching the part or
all of the filename. By providing a prefix argument, the function calls
filename-at-point and switches you to a buffer visiting the file
filename in another window. The function creates a buffer if none
already exists. This function is similar to find-file-other-window.

  There are two hook variables that allow extensions to modify the
operation of visiting files.  Visiting a file that does not exist runs the
functions in the list find-file-not-found-hooks; the value of this
variable is expected to be a list of functions which are
called one by one until one of them returns non-nil.  Any visiting
of a file, whether extant or not, expects find-file-hooks to
contain list of functions and calls them all, one by one.  In both cases
the functions receive no arguments.  Visiting a nonexistent file
runs the find-file-not-found-hooks first.

14.3 Saving Files
=================

  Saving a buffer in Emacs means writing its contents back into the file
that was visited in the buffer.

C-x C-s
Save the current buffer in its visited file (save-buffer).
C-x s
Save any or all buffers in their visited files (save-some-buffers).
M-~
Forget that the current buffer has been changed (not-modified).
C-x C-w
Save the current buffer in a specified file, and record that file as
the one visited in the buffer (write-file).
M-x set-visited-file-name
Change file the name under which the current buffer will be saved.

  To save a file and make your changes permanent, type
C-x C-s (save-buffer).  After saving is finished, C-x C-s
prints a message such as:

Wrote /u/rms/gnu/gnu.tasks

If the selected buffer is not modified (no changes have been made in it
since the buffer was created or last saved), Emacs does not save it
because it would have no effect.  Instead, C-x C-s prints a message
in the echo area saying:

(No changes need to be saved)

  The command C-x s (save-some-buffers) can save any or all
modified buffers.  First it asks, for each modified buffer, whether to
save it.  The questions should be answered with y or n.
C-x C-c, the key that kills Emacs, invokes
save-some-buffers and therefore asks the same questions.

  If you have changed a buffer and do not want the changes to be saved,
you should take some action to prevent it.  Otherwise, you are liable to
save it by mistake each time you use save-some-buffers or a
related command.  One thing you can do is type M-~
(not-modified), which removes the indication that the buffer
is modified.  If you do this, none of the save commands will believe
that the buffer needs to be saved.  (`~' is often used as a
mathematical symbol for `not'; thus Meta-~ is `not', metafied.)
You could also use set-visited-file-name (see below) to mark the
buffer as visiting a different file name, not in use for
anything important. 

You can also undo all the changes made since the file was visited or
saved, by reading the text from the file again.  This is called
reverting.  See Reverting.  Alternatively, you can undo all the
changes by repeating the undo command C-x u; but this only works
if you have not made more changes than the undo mechanism can remember.

  M-x set-visited-file-name alters the name of the file that the
current buffer is visiting.  It prompts you for the new file name in the
minibuffer.  You can also use set-visited-file-name on a buffer
that is not visiting a file.  The buffer's name is changed to correspond
to the file it is now visiting unless the new name is already used by a
different buffer; in that case, the buffer name is not changed.
set-visited-file-name does not save the buffer in the newly
visited file; it just alters the records inside Emacs so that it will
save the buffer in that file.  It also marks the buffer as "modified"
so that C-x C-s will save.

  If you wish to mark a buffer as visiting a different file and save it
right away, use C-x C-w (write-file).  It is precisely
equivalent to set-visited-file-name followed by C-x C-s.
C-x C-s used on a buffer that is not visiting  a file has the
same effect as C-x C-w; that is, it reads a file name, marks the
buffer as visiting that file, and saves it there.  The default file name in
a buffer that is not visiting a file is made by combining the buffer name
with the buffer's default directory.

  If Emacs is about to save a file and sees that the date of the latest
version on disk does not match what Emacs last read or wrote, Emacs
notifies you of this fact, because it probably indicates a problem caused
by simultaneous editing and requires your immediate attention.
See Simultaneous Editing.

  If the variable require-final-newline is non-nil, Emacs
puts a newline at the end of any file that doesn't already end in one,
every time a file is saved or written.

  Use the hook variable write-file-hooks to implement other ways
to write files, and specify things to be done before files are written.  The
value of this variable should be a list of Lisp functions.  When a file
is to be written, the functions in the list are called, one by one, with
no arguments.  If one of them returns a non-nil value, Emacs
takes this to mean that the file has been written in some suitable
fashion; the rest of the functions are not called, and normal writing is
not done. Use the hook variable after-save-hook to list
all the functions to be called after writing out a buffer to a file.

* Backup::       How Emacs saves the old version of your file.
* Interlocking:: How Emacs protects against simultaneous editing
                  of one file by two users.

14.3.1 Backup Files
-------------------

  Because Unix does not provide version numbers in file names, rewriting a
file in Unix automatically destroys all record of what the file used to
contain.  Thus, saving a file from Emacs throws away the old contents of
the file--or it would, except that Emacs carefully copies the old contents
to another file, called the backup file, before actually saving.
(Make sure that the variable make-backup-files is non-nil.
Backup files are not written if this variable is nil).

  At your option, Emacs can keep either a single backup file or a series of
numbered backup files for each file you edit.

  Emacs makes a backup for a file only the first time a file is saved
from one buffer.  No matter how many times you save a file, its backup file
continues to contain the contents from before the file was visited.
Normally this means that the backup file contains the contents from before
the current editing session; however, if you kill the buffer and then visit
the file again, a new backup file is made by the next save.

* Names: Backup Names.		How backup files are named;
				Choosing single or numbered backup files.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.

14.3.1.1 Single or Numbered Backups
...................................

  If you choose to have a single backup file (the default),
the backup file's name is constructed by appending `~' to the
file name being edited; thus, the backup file for `eval.c' is
`eval.c~'.

  If you choose to have a series of numbered backup files, backup file
names are made by appending `.~', the number, and another `~' to
the original file name.  Thus, the backup files of `eval.c' would be
called `eval.c.~1~', `eval.c.~2~', and so on, through names
like `eval.c.~259~' and beyond.

  If protection stops you from writing backup files under the usual names,
the backup file is written as `%backup%~' in your home directory.
Only one such file can exist, so only the most recently made backup is
available.

  The choice of single backup or numbered backups is controlled by the
variable version-control.  Its possible values are:

t
Make numbered backups.
nil
Make numbered backups for files that have numbered backups already.
Otherwise, make single backups.
never
Never make numbered backups; always make single backups.

version-control may be set locally in an individual buffer to
control the making of backups for that buffer's file.  For example,
Rmail mode locally sets version-control to never to make sure
that there is only one backup for an Rmail file.  See Locals.

14.3.1.2 Automatic Deletion of Backups
......................................

  To prevent unlimited consumption of disk space, Emacs can delete numbered
backup versions automatically.  Generally Emacs keeps the first few backups
and the latest few backups, deleting any in between.  This happens every
time a new backup is made.  The two variables that control the deletion are
kept-old-versions and kept-new-versions.  Their values are, respectively
the number of oldest (lowest-numbered) backups to keep and the number of
newest (highest-numbered) ones to keep, each time a new backup is made.
The values are used just after a new backup version is made;
that newly made backup is included in the count in kept-new-versions.
By default, both variables are 2.

  If delete-old-versions is non-nil,  excess
middle versions are deleted without notification.  If it is nil, the
default, you are asked whether the excess middle versions should
really be deleted.

  You can also use Dired's . (Period) command to delete old versions.
See Dired.

14.3.1.3 Copying vs. Renaming
.............................

  You can make backup files by copying the old file or by renaming it.
This makes a difference when the old file has multiple names.  If you
rename the old file into the backup file, the alternate names
become names for the backup file.  If you copy the old file instead,
the alternate names remain names for the file that you are editing,
and the contents accessed by those names will be the new contents.

  How you make a backup file may also affect the file's owner
and group.  If you use copying, they do not change.  If renaming is used,
you become the file's owner, and the file's group becomes the default
(different operating systems have different defaults for the group).

  Having the owner change is usually a good idea, because then the owner
is always the person who last edited the file.  Occasionally there is a 
file whose owner should not change.  Since most files should change
owners, it is a good idea to use local variable lists to set 
backup-by-copying-when-mismatch for the special cases where the 
owner should not change (see File Variables).

  Three variables control the choice of renaming or copying.
Normally, renaming is done.  If the variable backup-by-copying is
non-nil, copying is used.  Otherwise, if the variable
backup-by-copying-when-linked is non-nil, copying is
done for files that have multiple names, but renaming may still be done when
the file being edited has only one name.  If the variable
backup-by-copying-when-mismatch is non-nil, copying is
done if renaming would cause the file's owner or group to change.  

14.3.2 Protection Against Simultaneous Editing
----------------------------------------------

  Simultaneous editing occurs when two users visit the same file, both
make changes, and both save their changes.  If no one was informed that
this was happening, and you saved first, you would later find that your
changes were lost.  On some systems, Emacs notices immediately when the
second user starts to change a file already being edited, and issues a
warning.  When this is not possible, or if the second user has started
to change the file despite the warning, Emacs checks when the file is
saved, and issues a second warning when a user is about to overwrite a
file containing another user's changes.  If you are the user editing the
file, you can take corrective action at this point and prevent actual
loss of work.

  When you make the first modification in an Emacs buffer that is visiting
a file, Emacs records that you have locked the file.  (It does this by
writing another file in a directory reserved for this purpose.)  The lock
is removed when you save the changes.  The idea is that the file is locked
whenever the buffer is modified.  If you begin to modify the buffer while
the visited file is locked by someone else, this constitutes a collision,
and Emacs asks you what to do.  It does this by calling the Lisp function
ask-user-about-lock, which you can redefine to customize what it
does.  The standard definition of this function asks you a
question and accepts three possible answers:

s
Steal the lock.  Whoever was already changing the file loses the lock,
and you get the lock.
p
Proceed.  Go ahead and edit the file despite its being locked by someone else.
q
Quit.  This causes an error (file-locked) and the modification you
were trying to make in the buffer does not actually take place.

  Note that locking works on the basis of a file name; if a file has
multiple names, Emacs does not realize that the two names are the same file
and cannot prevent two users from editing it simultaneously under different
names.  However, basing locking on names means that Emacs can interlock the
editing of new files that do not really exist until they are saved.

  Some systems are not configured to allow Emacs to make locks.  On
these systems, Emacs cannot detect trouble in advance, but it can still
detect it in time to prevent you from overwriting someone else's changes.

  Every time Emacs saves a buffer, it first checks the last-modification
date of the existing file on disk to see that it has not changed since the
file was last visited or saved.  If the date does not match, it implies
that changes were made in the file in some other way, and these changes are
about to be lost if Emacs actually does save.  To prevent this, Emacs
prints a warning message and asks for confirmation before saving.
Occasionally you will know why the file was changed and know that it does
not matter; then you can answer yes and proceed.  Otherwise, you should
cancel the save with C-g and investigate the situation.

  The first thing you should do when notified that simultaneous editing
has already taken place is to list the directory with C-u C-x C-d
(see Directory Listing).  This will show the file's current
author.  You should attempt to contact that person and ask him not to
continue editing.  Often the next step is to save the contents of your
Emacs buffer under a different name, and use diff to compare the
two files.

  Simultaneous editing checks are also made when you visit a file that
is already visited with C-x C-f and when you start to modify a
file.  This is not strictly necessary, but it is useful to find out
about such a problem as early as possible, when corrective action takes
less work.

Another way to protect your file is to set the read, write, and
executable permissions for the file. Use the function
set-default-file-modes to set the UNIX umask value to the
nmask argument. The umask value is the default protection
mode for new files.

14.4 Reverting a Buffer
=======================

  If you have made extensive changes to a file and then change your mind
about them, you can get rid of all changes by reading in the previous
version of the file.  To do this, use M-x revert-buffer, which
operates on the current buffer.  Since reverting a buffer can result in
very extensive changes, you must confirm it with yes.

  You may request that revert-buffer check for an auto-save file
that is more recent than the visited file by providing a prefix
argument.  If a recent auto-save file exists, revert-buffer
offers to read the auto-save file instead of the visited file
(see Auto Save).  Emacs asks you about the auto-save file before the
request for confirmation of the revert-buffer operation, and
demands y or n as an answer.  If you have started to type
yes to confirm the revert operation, the y will answer the
question about using the auto-save file, but the es will not be
valid confirmation for the reversion.  This gives you a chance to cancel
the operation with C-g and try again with the answers you really
intend.

  revert-buffer preserves the value of point (in characters from
the beginning of the file).  If the file was edited only slightly, you
will be at approximately the same piece of text after reverting as
before.  If you have made more extensive changes, after reversion point
may be in a totally different context than your last edits before
reversion.

A buffer reverted from its visited file is marked "not modified" until
you make a change.  The buffer's modes will also be recalculated, by
normal-mode.

  Some kinds of buffers whose contents reflect data bases other than files,
such as Dired buffers, can also be reverted.  For them, reverting means
refreshing their contents from the appropriate data.  Buffers created
randomly with C-x b cannot be reverted; revert-buffer
reports an error when asked to do so.

14.5 Auto-Saving: Protection Against Disasters
==============================================

  Emacs saves all the visited files from time to time (based on counting
your keystrokes) without being asked.  This is called auto-saving.
It prevents you from losing more than a limited amount of work if the
system crashes.

  When Emacs determines it is time for auto-saving, each buffer is
considered and is auto-saved if auto-saving is turned on for it and it has
changed since the last time it was auto-saved.  If any auto-saving is
done, the message `Auto-saving...' is displayed in the echo area until
auto-saving is finished.  Errors occurring during auto-saving are caught
so that they do not interfere with the execution of commands you have been
typing.

* Files: Auto Save Files.
* Control: Auto Save Control.
* Recover::		Recovering text from auto-save files.

14.5.1 Auto-Save Files
----------------------

  Auto-saving does not normally write to the files you visited, because
it can be undesirable to save a program that is in an inconsistent
state when you have made only half of a planned change.  Instead, auto-saving
is done in a different file called the auto-save file, and the
visited file is changed only when you save explicitly, for example, 
with C-x C-s.

  Normally, the name of the auto-save file is generated by appending
`#' to the front and back of the visited file name.  Thus, a buffer
visiting file `foo.c' would be auto-saved in a file `#foo.c#'.
Most buffers that are not visiting files are auto-saved only if you
request it explicitly; when they are auto-saved, the auto-save file name
is generated by appending `#%' to the front and `#' to the
back of buffer name.  For example, the `*mail*' buffer in which you
compose messages to be sent is auto-saved in a file named
`#%*mail*#'.  Names of auto-save files are generated this way
unless you customize the functions make-auto-save-file-name and
auto-save-file-name-p to do something different.  The file name
to be used for auto-saving a buffer is calculated at the time auto-saving is
turned on in that buffer.

  If you want auto-saving to be done in the visited file, set the variable
auto-save-visited-file-name to be non-nil.  In this mode,
there is really no difference between auto-saving and explicit saving.

  Emacs deletes a buffer's auto-save file when you explicitly save the
buffer.  To inhibit the deletion, set the variable
delete-auto-save-files to nil.  Changing the visited file
name with C-x C-w or set-visited-file-name renames any
auto-save file to correspond to the new visited name.

14.5.2 Controlling Auto-Saving
------------------------------

  Each time you visit a file, auto-saving is turned on for that file's
buffer if the variable auto-save-default is non-nil (but
not in batch mode; see Entering Emacs).  The default for this
variable is t, so Emacs auto-saves buffers that visit files by
default.  You can use the command M-x auto-save-mode to turn
auto-saving for a buffer on or off.  Like other minor mode commands,
M-x auto-save-mode turns auto-saving on with a positive argument,
off with a zero or negative argument; with no argument, it toggles.

  Emacs performs auto-saving periodically based on counting how many
characters you have typed since the last time auto-saving happened.  The
variable auto-save-interval specifies the number of characters
between auto-saves.  By default, it is 300.  Emacs also auto-saves
whenever you call the function do-auto-save.

  Emacs also does auto-saving whenever it gets a fatal error.  This
includes killing the Emacs job with a shell command such as kill
-emacs, or disconnecting a phone line or network connection.

You can set the number of seconds of idle time before an auto-save is
done. Setting the value of the variable auto-save-timeout to zero or 
nil will  disable auto-saving due to idleness.

The actual amount of idle time between auto-saves is logarithmically
related to the size of the current buffer.  This variable is the number
of seconds after which an auto-save will happen when the current buffer
is 50k or less; the timeout will be 2 1/4 times this in a 200k buffer, 3
3/4 times this in a 1000k buffer, and 4 1/2 times this in a 2000k
buffer.

For this variable to have any effect, you must do (require 'timer).

14.5.3 Recovering Data from Auto-Saves
--------------------------------------

  If you want to use the contents of an auto-save file to recover from a
loss of data, use the command M-x recover-file <RET> file
<RET>.  Emacs visits file and then (after your confirmation)
restores the contents from the auto-save file `#file#'.  You
can then save the file with C-x C-s to put the recovered text into
file itself.  For example, to recover file `foo.c' from its
auto-save file `#foo.c#', do:

M-x recover-file <RET> foo.c <RET>
C-x C-s

  Before asking for confirmation, M-x recover-file displays a
directory listing describing the specified file and the auto-save file,
so you can compare their sizes and dates.  If the auto-save file
is older, M-x recover-file does not offer to read it.

  Auto-saving is disabled by M-x recover-file because using
this command implies that the auto-save file contains valuable data
from a past session.  If you save the data in the visited file and
then go on to make new changes, turn auto-saving back on
with M-x auto-save-mode.

14.6 Version Control
====================

  Version control systems are packages that can record multiple
versions of a source file, usually storing the unchanged parts of the
file just once.  Version control systems also record history information
such as the creation time of each version, who created it, and a 
description of what was changed in that version.

  The GNU project recommends the version control system known as RCS,
which is free software and available from the Free Software Foundation.
Emacs supports use of either RCS or SCCS (a proprietary, but widely
used, version control system that is not quite as powerful as RCS)
through a facility called VC.  The same Emacs commands work with either
RCS or SCCS, so you hardly have to know which one of them you are
using.

* Concepts of VC::              Basic version control information;
                                  checking files in and out.
* Editing with VC::             Commands for editing a file maintained
                                  with version control.
* Variables for Check-in/out::  Variables that affect the commands used
                                  to check files in or out.
* Log Entries::                 Logging your changes.
* Change Logs and VC::          Generating a change log file from log
                                  entries. 
* Old Versions::                Examining and comparing old versions.
* VC Status::                   Commands to view the VC status of files and
                                  look at log entries.
* Renaming and VC::             A command to rename both the source and
                                  master file correctly.
* Snapshots::                   How to make and use snapshots, a set of
                                  file versions that can be treated as a unit.
* Version Headers::             Inserting version control headers into
                                  working files.

14.6.1 Concepts of Version Control
----------------------------------

   When a file is under version control, we also say that it is
registered in the version control system.  Each registered file
has a corresponding master file which represents the file's
present state plus its change history, so that you can reconstruct from
it either the current version or any specified earlier version.  Usually
the master file also records a log entry for each version describing
what was changed in that version.

  The file that is maintained under version control is sometimes called
the work file corresponding to its master file.

   To examine a file, you check it out.  This extracts a version
of the source file (typically, the most recent) from the master file.
If you want to edit the file, you must check it out locked.  Only
one user can do this at a time for any given source file.  (This kind 
of locking is completely unrelated to the locking that Emacs uses to
detect simultaneous editing of a file.)

  When you are done with your editing, you must check in the new
version.  This records the new version in the master file, and unlocks
the source file so that other people can lock it and thus modify it.

  Checkin and checkout are the basic operations of version control.  You
can do both of them with a single Emacs command: C-x C-q
(vc-toggle-read-only).

  A snapshot is a coherent collection of versions of the various
files that make up a program.  See Snapshots.

14.6.2 Editing with Version Control
-----------------------------------

  When you visit a file that is maintained using version control, the
mode line displays `RCS' or `SCCS' to inform you that version
control is in use, and also (in case you care) which low-level system
the file is actually stored in.  Normally, such a source file is
read-only, and the mode line indicates this with `%%'.  With RCS,
the mode line also indicates the number of the head version, which is
normally also the version you are looking at.

  These are the commands for editing a file maintained with
version control:

C-x C-q
Check the visited file in or out.

C-x v u
Revert the buffer and the file to the last checked in version.

C-x v c
Remove the last-entered change from the master for the visited file.
This undoes your last check-in.

C-x v i
Register the visited file in version control.

(C-x v is the prefix key for version control commands; all of these
commands except for C-x C-q start with C-x v.)

  When you want to modify a file maintained with version control, type
C-x C-q (vc-toggle-read-only).  This checks out the
file, and tells RCS or SCCS to lock the file.  This means making the
file writable for you (but not for anyone else).

  When you are finished editing the file, type C-x C-q again.
When used on a file that is checked out, this command checks the file
in.  But check-in does not start immediately; first, you must enter the
log entry--a description of the changes in the new version.
C-x C-q pops up a buffer for you to enter this in.  When you are
finished typing in the log entry, type C-c C-c to terminate it; this is
when actual check-in takes place.

  Once you have checked in your changes, the file is unlocked, so that
other users can lock it and modify it.

  Emacs does not save backup files for source files that are maintained
with version control.  If you want to make backup files despite version
control, set the variable vc-make-backup-files to a
non-nil value.

  Normally the work file exists all the time, whether it is locked or
not.  If you set vc-keep-workfiles to nil, then checking
in a new version with C-x C-q deletes the work file; but any
attempt to visit the file with Emacs creates it again.

  It is not impossible to lock a file that someone else has locked.  If
you try to check out a file that is locked, C-x C-q asks you
whether you want to "steal the lock."  If you say yes, the file
becomes locked by you, but a message is sent to the person who had
formerly locked the file, to inform him of what has happened.  The mode
line indicates that a file is locked by someone else by displaying the
login name of that person, before the version number.

  If you want to discard your current set of changes and revert to the
last version checked in, use C-x v u (vc-revert-buffer).
This cancels your last check-out, leaving the file unlocked.  If you want
to make a different set of changes, you must first check the file out
again.  C-x v u requires confirmation, unless it sees that 
you haven't made any changes since the last checked-in version.

  C-x v u is also the command to use if you lock a file and then
don't actually change it.

  You can cancel a change after checking it in, with C-x v c
(vc-cancel-version).  This command discards all record of the
most recent checked in version, so be careful about using it.  It
requires confirmation with yes.  By default, C-x v c reverts
your workfile and buffer to the previous version (the one that precedes
the version that is deleted), but you can prevent the reversion by
giving the command a prefix argument.  Then the buffer does not change.

  This command with a prefix argument is useful when you have checked in
a change and then discover a trivial error in it; you can cancel the
erroneous check-in, fix the error, and repeat the check-in.

  Be careful when invoking C-x v c, as it is easy to throw away a
lot of work with it.  To help you be careful, this command always
requires confirmation with `yes'.

  You can register the visited file for version control using
C-x v i (vc-register).  If the variable
vc-default-back-end is non-nil, it specifies which
version control system to use; otherwise, this uses RCS if it is
installed on your system and SCCS if not.  After C-x v i,
the file is unlocked and read-only.  Type C-x C-q if you wish to
edit it.

  By default, the initial version number is 1.1.  If you want to use a
different number, give C-x v i a prefix argument; then it reads
the initial version number using the minibuffer.

  If vc-initial-comment is non-nil, C-x v i reads
an initial comment (much like a log entry) to describe the purpose of
this source file.

  To specify the version number for a subsequent checkin, use the
command C-u C-x v v.  C-x v v (vc-next-action) is the
command that C-x C-q uses to do the "real work" when the visited
file uses version control.  When used for checkin, and given a prefix
argument, it reads the version number with the minibuffer.

14.6.3 Variables Affecting Check-in and Check-out
-------------------------------------------------

  If vc-suppress-confirm is non-nil, then C-x C-q
and C-x v i can save the current buffer without asking, and
C-x v u also operates without asking for confirmation.
(This variable does not affect C-x v c; that is so drastic
that it should always ask for confirmation.)

  VC mode does much of its work by running the shell commands for RCS
and SCCS.  If vc-command-messages is non-nil, VC displays
messages to indicate which shell commands it runs, and additional
messages when the commands finish.

  Normally, VC assumes that it can deduce the locked/unlocked state of
files by looking at the file permissions of the work file; this is
fast.  However, if the `RCS' or `SCCS' subdirectory is
actually a symbolic link, then VC does not trust the file permissions to
reflect this status.

You can specify the criterion for whether to trust the file permissions
by setting the variable vc-mistrust-permissions.  Its value may
be t (always mistrust the file permissions and check the master
file), nil (always trust the file permissions), or a function of
one argument which makes the decision.  The argument is the directory
name of the `RCS' or `SCCS' subdirectory.  A non-nil
value from the function says to mistrust the file permissions.

  If you find that the file permissions of work files are changed
erroneously, set vc-mistrust-permissions to t.  Then VC
always checks the master file to determine the file's status.

  You can specify additional directories to search for version control
programs by setting the variable vc-path.  These directories
are searched before the usual search path.  The proper result usually
happens automatically.

14.6.4 Log Entries
------------------

  When you're editing an initial comment or log entry for inclusion in a
master file, finish your entry by typing C-c C-c.

C-c C-c
Finish the comment edit normally (vc-finish-logentry).
This finishes check-in.

  To abort check-in, just don't type C-c C-c in that buffer.  You
can switch buffers and do other editing.  As long as you don't try to
check in another file, the entry you were editing remains in its
buffer, and you can go back to that buffer at any time to complete the
check-in.

  If you change several source files for the same reason, it is often
convenient to specify the same log entry for many of the files.  To do
this, use the history of previous log entries.  The commands M-n,
M-p, M-s and M-r for doing this work just like the
minibuffer history commands (except that these versions are used outside
the minibuffer).

  Each time you check in a file, the log entry buffer is put into VC Log
mode, which involves running two hooks: text-mode-hook and
vc-log-mode-hook.

14.6.5 Change Logs and VC
-------------------------

  If you use RCS for a program and also maintain a change log file for
it (see Change Log), you can generate change log entries
automatically from the version control log entries:

C-x v a
Visit the current directory's change log file and create new entries for
versions checked in since the most recent entry in the change log file
(vc-update-change-log).

This command works with RCS only; it does not work with SCCS.

  For example, suppose the first line of `ChangeLog' is dated 10
April 1992, and that the only check-in since then was by Nathaniel
Bowditch to `rcs2log' on 8 May 1992 with log text `Ignore log
messages that start with `#'.'.  Then C-x v a visits
`ChangeLog' and inserts text like this:

Fri May  8 21:45:00 1992  Nathaniel Bowditch  (nat@apn.org)

        * rcs2log: Ignore log messages that start with `#'.

You can then edit the new change log entry further as you wish.

  Normally, the log entry for file `foo' is displayed as `*
foo: text of log entry'.  The `:' after `foo' is omitted
if the text of the log entry starts with `(functionname):
'.  For example, if the log entry for `vc.el' is
`(vc-do-command): Check call-process status.', then the text in
`ChangeLog' looks like this:

Wed May  6 10:53:00 1992  Nathaniel Bowditch  (nat@apn.org)

        * vc.el (vc-do-command): Check call-process status.

  When C-x v a adds several change log entries at once, it groups
related log entries together if they all are checked in by the same
author at nearly the same time.  If the log entries for several such
files all have the same text, it coalesces them into a single entry.
For example, suppose the most recent checkins have the following log
entries:

For `vc.texinfo':
Fix expansion typos.
For `vc.el':
Don't call expand-file-name.
For `vc-hooks.el':
Don't call expand-file-name.

  They appear like this in `ChangeLog':

Wed Apr  1 08:57:59 1992  Nathaniel Bowditch  (nat@apn.org)

        * vc.texinfo: Fix expansion typos.

        * vc.el, vc-hooks.el: Don't call expand-file-name.

  Normally, C-x v a separates log entries by a blank line, but you
can mark several related log entries to be clumped together (without an
intervening blank line) by starting the text of each related log entry
with a label of the form `{clumpname} '.  The label
itself is not copied to `ChangeLog'.  For example, suppose the log
entries are:

For `vc.texinfo':
{expand} Fix expansion typos.
For `vc.el':
{expand} Don't call expand-file-name.
For `vc-hooks.el':
{expand} Don't call expand-file-name.

Then the text in `ChangeLog' looks like this:

Wed Apr  1 08:57:59 1992  Nathaniel Bowditch  (nat@apn.org)

        * vc.texinfo: Fix expansion typos.
        * vc.el, vc-hooks.el: Don't call expand-file-name.

  A log entry whose text begins with `#' is not copied to
`ChangeLog'.  For example, if you merely fix some misspellings in
comments, you can log the change with an entry beginning with `#'
to avoid putting such trivia into `ChangeLog'.

14.6.6 Examining And Comparing Old Versions
-------------------------------------------

C-x v ~ version <RET>
Examine version version of the visited file, in a buffer of its
own (vc-version-other-window).

C-x v =
Compare the current buffer contents with the latest checked-in version
of the file.

C-u C-x v = file <RET> oldvers <RET> newvers <RET>
Compare the specified two versions of file.

  You can examine any version of a file by first visiting it, and then
using C-x v ~ version <RET>
(vc-version-other-window).  This puts the text of version
version in a file named `filename.~version~',
then visits it in a separate window.

  To compare two versions of a file, use the command C-x v =
(vc-diff).

  Plain C-x v = compares the current buffer contents (saving them
in the file if necessary) with the last checked-in version of the file.
With a prefix argument, C-x v = reads a file name and two version
numbers, then compares those versions of the specified file.

  If you supply a directory name instead of the name of a work file,
this command compares the two specified versions of all registered files
in that directory and its subdirectories.  You can also specify a
snapshot name (see Snapshots) instead of one or both version
numbers.

  You can specify a checked-in version by its number; you can specify
the most recent checked-in version with an empty version number.

  This command works by running the vcdiff utility, getting the
options from the variable diff-switches.  It displays the output
in a special buffer in another window.  Unlike the M-x diff
command, C-x v = does not try to find the changes in the old and
new versions.  This is because one or both versions normally do not
exist as files.  They exist only in the records of the master file.
See Comparing Files, for more information about M-x diff.

14.6.7 VC Status Commands
-------------------------

  To view the detailed version control status and history of a file,
type C-x v l (vc-print-log).  It displays the history of
changes to the current file, including the text of the log entries.  The
output appears in a separate window.

  When you are working on a large program, it's often useful to find all
the files that are currently locked, or all the files maintained in
version control at all.  You can use C-x v d (vc-directory)
to show all the locked files in or beneath the current directory.  This
includes all files that are locked by any user.  C-u C-x v d lists
all files in or beneath the current directory that are maintained with
version control.

  The list of files is displayed as a buffer that uses an augmented
Dired mode.  The names of the users locking various files are shown (in
parentheses) in place of the owner and group.  All the normal Dired
commands work in this buffer.  Most interactive VC commands work also,
and apply to the file name on the current line.

  The C-x v v command (vc-next-action), when used in the
augmented Dired buffer, operates on all the marked files (or the file on
the current line).  If it operates on more than one file, it handles
each file according to its current state; thus, it may check out one
file and check in another (because it is already checked out).  If it
has to check in any files, it reads a single log entry, then uses that
text for all the files being checked in.  This can be convenient for
registering or checking in several files at once, as part of the same
change.

14.6.8 Renaming VC Work Files and Master Files
----------------------------------------------

  When you rename a registered file, you must also rename its master
file correspondingly to get proper results.  Use vc-rename-file
to rename the source file as you specify, and rename its master file
accordingly.  It also updates any snapshots (see Snapshots) that
mention the file, so that they use the new name; despite this, the
snapshot thus modified may not completely work (see Snapshot Caveats).

  You cannot use vc-rename-file on a file that is locked by
someone else.

14.6.9 Snapshots
----------------

  A snapshot is a named set of file versions (one for each
registered file) that you can treat as a unit.  One important kind of
snapshot is a release, a (theoretically) stable version of the
system that is ready for distribution to users.

* Making Snapshots::		The snapshot facilities.
* Snapshot Caveats::		Things to be careful of when using snapshots.

14.6.9.1 Making and Using Snapshots
...................................

  There are two basic commands for snapshots; one makes a
snapshot with a given name, the other retrieves a named snapshot.

C-x v s name <RET>
Define the last saved versions of every registered file in or under the
current directory as a snapshot named name
(vc-create-snapshot).

C-x v r name <RET>
Check out all registered files at or below the current directory level
using whatever versions correspond to the snapshot name
(vc-retrieve-snapshot).

This command reports an error if any files are locked at or below the
current directory, without changing anything; this is to avoid
overwriting work in progress.

  A snapshot uses a very small amount of resources--just enough to record
the list of file names and which version belongs to the snapshot.  Thus,
you need not hesitate to create snapshots whenever they are useful.

  You can give a snapshot name as an argument to C-x v = or
C-x v ~ (see Old Versions).  Thus, you can use it to compare a
snapshot against the current files, or two snapshots against each other,
or a snapshot against a named version.

14.6.9.2 Snapshot Caveats
.........................

  VC's snapshot facilities are modeled on RCS's named-configuration
support.  They use RCS's native facilities for this, so under VC
snapshots made using RCS are visible even when you bypass VC.

  For SCCS, VC implements snapshots itself.  The files it uses contain
name/file/version-number triples.  These snapshots are visible only
through VC.

  A snapshot is a set of checked-in versions.  So make sure that all the
files are checked in and not locked when you make a snapshot.

  File renaming and deletion can create some difficulties with snapshots.
This is not a VC-specific problem, but a general design issue in version
control systems that no one has solved very well yet.

  If you rename a registered file, you need to rename its master along
with it (the command vc-rename-file does this automatically).  If
you are using SCCS, you must also update the records of the snapshot, to
mention the file by its new name (vc-rename-file does this,
too).  An old snapshot that refers to a master file that no longer
exists under the recorded name is invalid; VC can no longer retrieve
it.  It would be beyond the scope of this manual to explain enough about
RCS and SCCS to explain how to update the snapshots by hand.

  Using vc-rename-file makes the snapshot remain valid for
retrieval, but it does not solve all problems.  For example, some of the
files in the program probably refer to others by name.  At the very
least, the makefile probably mentions the file that you renamed.  If you
retrieve an old snapshot, the renamed file is retrieved under its new
name, which is not the name that the makefile expects.  So the program
won't really work as retrieved.

14.6.10 Inserting Version Control Headers
-----------------------------------------

   Sometimes it is convenient to put version identification strings
directly into working files.  Certain special strings called
version headers are replaced in each successive version by the
number of that version.

  You can use the C-x v h command (vc-insert-headers) to
insert a suitable header string.

C-x v h
Insert headers in a file for use with your version-control system.

  The default header string is `\$Id\$' for RCS and `\%W\%'
for SCCS. (The actual strings inserted do not have the backslashes
in them.  They were placed in the Info source file so that the
strings don't get interpreted as version-control headers when the
Info source files are maintained under version control.) You can
specify other headers to insert by setting the variable
vc-header-alist.  Its value is a list of elements of the form
(program . string) where program is RCS
or SCCS and string is the string to use.

  Instead of a single string, you can specify a list of strings; then
each string in the list is inserted as a separate header on a line of
its own.

  It is often necessary to use "superfluous" backslashes when writing
the strings that you put in this variable.  This is to prevent the
string in the constant from being interpreted as a header itself if the
Emacs Lisp file containing it is maintained with version control.

  Each header is inserted surrounded by tabs, inside comment delimiters,
on a new line at the start of the buffer.  Normally the ordinary comment
start and comment end strings of the current mode are used, but for
certain modes, there are special comment delimiters for this purpose;
the variable vc-comment-alist specifies them.  Each element of
this list has the form (mode starter ender).

  The variable vc-static-header-alist specifies further strings
to add based on the name of the buffer.  Its value should be a list of
elements of the form (regexp . format).  Whenever
regexp matches the buffer name, format is inserted as part
of the header.  A header line is inserted for each element that matches
the buffer name, and for each string specified by
vc-header-alist.  The header line is made by processing the
string from vc-header-alist with the format taken from the
element.  The default value for vc-static-header-alist is:

(("\\.c$" .
  "\n#ifndef lint\nstatic char vcid[] = \"\%s\";\n\
#endif /* lint */\n"))

which specifies insertion of a string of this form:


#ifndef lint
static char vcid[] = "string";
#endif /* lint */

14.7 Listing a File Directory
=============================

  Files are organized by Unix into directories.  A directory
listing is a list of all the files in a directory.  Emacs provides
directory listings in brief format (file names only) and verbose format
(sizes, dates, and authors included).

C-x C-d dir-or-pattern
Print a brief directory listing (list-directory).
C-u C-x C-d dir-or-pattern
Print a verbose directory listing.

  To print a directory listing, use C-x C-d
(list-directory).  This command prompts in the minibuffer for a
file name which is either a  directory to be listed or pattern
containing wildcards for the files to be listed.  For example,

C-x C-d /u2/emacs/etc <RET>

lists all the files in directory `/u2/emacs/etc'.  An example of
specifying a file name pattern is:

C-x C-d /u2/emacs/src/*.c <RET>

  Normally, C-x C-d prints a brief directory listing containing just
file names.  A numeric argument (regardless of value) tells it to print a
verbose listing (like ls -l).

  Emacs obtains the text of a directory listing by running ls in
an inferior process.  Two Emacs variables control the switches passed to
ls: list-directory-brief-switches is a string giving the
switches to use in brief listings ("-CF" by default).
list-directory-verbose-switches is a string giving the switches
to use in a verbose listing ("-l" by default).

The variable directory-abbrev-alist is an alist of abbreviations
for file directories.  The list consists of elements of the form
(FROM .  TO), each meaning to replace FROM with TO
when it appears in a directory name.  This replacement is done when
setting up the default directory of a newly visited file.  Every FROM
string should start with ``^''.

Use this feature when you have directories which you normally refer to
via absolute symbolic links.  Make TO the name of the link, and
FROM the name it is linked to.

14.8 Comparing Files
====================

  The command M-x diff compares two files, displaying the
differences in an Emacs buffer named `*Diff*'.  It works by running
the diff program, using options taken from the variable
diff-switches, whose value should be a string.

  The buffer `*Diff*' has Compilation mode as its major mode, so
you can use C-x ` to visit successive changed locations in the two
source files.  You can also move to a particular hunk of changes and
type C-c C-c to find the corresponding source location.  You can
also use the other special commands of Compilation mode: <SPC> and
<DEL> for scrolling, and M-p and M-n for cursor motion.
See Compilation.

  The command M-x diff-backup compares a specified file with its most
recent backup.  If you specify the name of a backup file,
diff-backup compares it with the source file that it is a backup
of.

  The command M-x compare-windows compares the text in the current
window with that in the next window.  Comparison starts at point in each
window.  Point moves forward in each window, a character at a time in each
window, until the next characters in the two windows are different.  Then
the command is finished.  For more information about windows in Emacs,
Windows.

  With a numeric argument, compare-windows ignores changes in
whitespace.  If the variable compare-ignore-case is
non-nil, it ignores differences in case as well.

14.9 Dired, the Directory Editor
================================

  Dired makes it easy to delete or visit many of the files in a single
directory at once.  It creates an Emacs buffer containing a listing of the
directory.  You can use the normal Emacs commands to move around in this
buffer and special Dired commands to operate on the files.

* Enter: Dired Enter.         How to invoke Dired.
* Edit: Dired Edit.           Editing the Dired buffer.
* Deletion: Dired Deletion.   Deleting files with Dired.
* Immed: Dired Immed.         Other file operations through Dired.

14.9.1 Entering Dired
---------------------

  To invoke dired, type C-x d or M-x dired.  The command reads a
directory name or wildcard file name pattern as a minibuffer argument just
like the list-directory command, C-x C-d.  Where dired
differs from list-directory is in naming the buffer after the
directory name or the wildcard pattern used for the listing, and putting
the buffer into Dired mode so that the special commands of Dired are
available in it.  The variable dired-listing-switches is a string
used as an argument to ls in making the directory; this string
must contain `-l'.

  To display the Dired buffer in another window rather than in the selected
window, use C-x 4 d (dired-other-window) instead of C-x d.

14.9.2 Editing in Dired
-----------------------

  Once the Dired buffer exists, you can switch freely between it and other
Emacs buffers.  Whenever the Dired buffer is selected, certain special
commands are provided that operate on files that are listed.  The Dired
buffer is "read-only", and inserting text in it is not useful, so
ordinary printing characters such as d and x are used for Dired
commands.  Most Dired commands operate on the file described by the line
that point is on.  Some commands perform operations immediately; others
"flag" a file to be operated on later.

  Most Dired commands that operate on the current line's file also treat a
numeric argument as a repeat count, meaning to act on the files of the
next few lines.  A negative argument means to operate on the files of the
preceding lines, and leave point on the first of those lines.

  All the usual Emacs cursor motion commands are available in Dired
buffers.  Some special purpose commands are also provided.  The keys
C-n and C-p are redefined so that they try to position
the cursor at the beginning of the filename on the line, rather than
at the beginning of the line.

  For extra convenience, <SPC> and n in Dired are equivalent to
C-n.  p is equivalent to C-p.  Moving by lines is done so
often in Dired that it deserves to be easy to type.  <DEL> (move up and
unflag) is often useful simply for moving up.

  The g command in Dired runs revert-buffer to reinitialize
the buffer from the actual disk directory and show any changes made in the
directory by programs other than Dired.  All deletion flags in the Dired
buffer are lost when this is done.

14.9.3 Deleting Files With Dired
--------------------------------

  The primary use of Dired is to flag files for deletion and then delete
them.

d
Flag this file for deletion.
u
Remove deletion-flag on this line.
<DEL>
Remove deletion-flag on previous line, moving point to that line.
x
Delete the files that are flagged for deletion.
#
Flag all auto-save files (files whose names start and end with `#')
for deletion (see Auto Save).
~
Flag all backup files (files whose names end with `~') for deletion
(see Backup).
. (Period)
Flag excess numeric backup files for deletion.  The oldest and newest
few backup files of any one file are exempt; the middle ones are flagged.

  You can flag a file for deletion by moving to the line describing the
file and typing d or C-d.  The deletion flag is visible as a
`D' at the beginning of the line.  Point is moved to the beginning of
the next line, so that repeated d commands flag successive files.

  The files are flagged for deletion rather than deleted immediately to
avoid the danger of deleting a file accidentally.  Until you direct Dired
to delete the flagged files, you can remove deletion flags using the
commands u and <DEL>.  u works just like d, but
removes flags rather than making flags.  <DEL> moves upward, removing
flags; it is like u with numeric argument automatically negated.

  To delete the flagged files, type x.  This command first displays a
list of all the file names flagged for deletion, and requests confirmation
with yes.  Once you confirm, all the flagged files are deleted, and their
lines are deleted from the text of the Dired buffer.  The shortened Dired
buffer remains selected.  If you answer no or quit with C-g, you
return immediately to Dired, with the deletion flags still present and no
files actually deleted.

  The #, ~, and . commands flag many files for
deletion, based on their names.  These commands are useful precisely
because they do not actually delete any files; you can remove the
deletion flags from any flagged files that you really wish to keep.

  # flags for deletion all files that appear to have been made by
auto-saving (that is, files whose names begin and end with `#').
~ flags for deletion all files that appear to have been made as
backups for files that were edited (that is, files whose names end with
`~').

  . (Period) flags just some of the backup files for deletion: only
numeric backups that are not among the oldest few nor the newest few
backups of any one file.  Normally dired-kept-versions (not
kept-new-versions; that applies only when saving) specifies the
number of newest versions of each file to keep, and
kept-old-versions specifies the number of oldest versions to keep.
Period with a positive numeric argument, as in C-u 3 ., specifies the
number of newest versions to keep, overriding dired-kept-versions.
A negative numeric argument overrides kept-old-versions, using minus
the value of the argument to specify the number of oldest versions of each
file to keep.

14.9.4 Immediate File Operations in Dired
-----------------------------------------

  Some file operations in Dired take place immediately when they are
requested.

C
Copies the file described on the current line.  You must supply a file name
to copy to, using the minibuffer.
f
Visits the file described on the current line.  It is just like typing
C-x C-f and supplying that file name.  If the file on this line is a
subdirectory, f actually causes Dired to be invoked on that
subdirectory.  See Visiting.
o
Like f, but uses another window to display the file's buffer.  The
Dired buffer remains visible in the first window.  This is like using
C-x 4 C-f to visit the file.  See Windows.
R
Renames the file described on the current line.  You must supply a file
name to rename to, using the minibuffer.
v
Views the file described on this line using M-x view-file.  Viewing a
file is like visiting it, but is slanted toward moving around in the file
conveniently and does not allow changing the file.  See View File.  Viewing a file that is a directory runs Dired on that
directory.

14.10 Miscellaneous File Operations
===================================

  Emacs has commands for performing many other operations on files.
All operate on one file; they do not accept wildcard file names.

  You can use the command M-x add-name-to-file to add a name to an
existing file without removing the old name.  The new name must belong
on the file system that the file is on.

  M-x append-to-file adds the text of the region to the end of the
specified file.

  M-x copy-file reads the file old and writes a new file
named new with the same contents.  Confirmation is required if a
file named new already exists, because copying overwrites the old
contents of the file new.

  M-x delete-file deletes a specified file, like the rm
command in the shell.  If you are deleting many files in one directory, it
may be more convenient to use Dired (see Dired).

  M-x insert-file inserts a copy of the contents of a specified
file into the current buffer at point, leaving point unchanged before the
contents and the mark after them.  See Mark.

  M-x make-symbolic-link reads two file names old and
linkname, and then creates a symbolic link named linkname
and pointing at old.  Future attempts to open file
linkname will then refer to the file named old at the time
the opening is done, or will result in an error if the name old is
not in use at that time.  Confirmation is required if you create the
link while linkname is in use.  Note that not all systems support
symbolic links.

  M-x rename-file reads two file names old and new using
the minibuffer, then renames file old as new.  If a file named
new already exists, you must confirm with yes or renaming is not
done; this is because renaming causes the previous meaning of the 
name new to be lost.  If old and new are on different 
file systems, the file old is copied and deleted.

  M-x view-file allows you to scan or read a file by sequential
screenfuls.  It reads a file name argument using the minibuffer.  After
reading the file into an Emacs buffer, view-file reads and displays
one windowful.  You can then type <SPC> to scroll forward one window,
or <DEL> to scroll backward.  Various other commands are provided for
moving around in the file, but none for changing it; type C-h while
viewing a file for a list of them.  Most commands are the default Emacs
cursor motion commands.  To exit from viewing, type C-c.

