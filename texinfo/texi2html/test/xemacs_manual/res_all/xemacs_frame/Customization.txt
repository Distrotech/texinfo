27 Customization
****************

  This chapter talks about various topics relevant to adapting the
behavior of Emacs in minor ways.

  All kinds of customization affect only the particular Emacs job that you
do them in.  They are completely lost when you kill the Emacs job, and
have no effect on other Emacs jobs you may run at the same time or
later.  The only way an Emacs job can affect anything outside of it is
by writing a file; in particular, the only way to make a customization
`permanent' is to put something in your init file or other appropriate
file to do the customization in each session.  See Init File.

* Minor Modes::     Each minor mode is one feature you can turn on
                     independently of any others.
* Variables::       Many Emacs commands examine Emacs variables
                     to decide what to do; by setting variables,
                     you can control their functioning.
* Keyboard Macros:: A keyboard macro records a sequence of keystrokes
                     to be replayed with a single command.
* Key Bindings::    The keymaps say what command each key runs.
                     By changing them, you can "redefine keys".
* Syntax::          The syntax table controls how words and expressions
                     are parsed.
* Init File::       How to write common customizations in the init file.
* Audible Bell::    Changing how Emacs sounds the bell.
* Faces::           Changing the fonts and colors of a region of text.
* Frame Components::  Controlling the presence and positions of the
                     menubar, toolbars, and gutters.
* X Resources::     X resources controlling various aspects of the
                     behavior of XEmacs.

27.1 Minor Modes
================

  Minor modes are options which you can use or not.  For example, Auto
Fill mode is a minor mode in which <SPC> breaks lines between words
as you type.  All the minor modes are independent of each other and of
the selected major mode.  Most minor modes inform you in the mode line
when they are on; for example, `Fill' in the mode line means that
Auto Fill mode is on.

  Append -mode to the name of a minor mode to get the name of a
command function that turns the mode on or off.  Thus, the command to
enable or disable Auto Fill mode is called M-x auto-fill-mode.  These
commands are usually invoked with M-x, but you can bind keys to them
if you wish.  With no argument, the function turns the mode on if it was
off and off if it was on.  This is known as toggling.  A positive
argument always turns the mode on, and an explicit zero argument or a
negative argument always turns it off.

  Auto Fill mode allows you to enter filled text without breaking lines
explicitly.  Emacs inserts newlines as necessary to prevent lines from
becoming too long.  See Filling.

  Overwrite mode causes ordinary printing characters to replace existing
text instead of moving it to the right.  For example, if point is in
front of the `B' in `FOOBAR', and you type a G in Overwrite
mode, it changes to `FOOGAR', instead of `FOOGBAR'.

  Abbrev mode allows you to define abbreviations that automatically expand
as you type them.  For example, `amd' might expand to `abbrev
mode'.  See Abbrevs, for full information.

27.2 Variables
==============

  A variable is a Lisp symbol which has a value.  Variable names
can contain any characters, but by convention they are words separated
by hyphens.  A variable can also have a documentation string, which
describes what kind of value it should have and how the value will be
used.

  Lisp allows any variable to have any kind of value, but most variables
that Emacs uses require a value of a certain type.  Often the value has
to be a string or a number.  Sometimes we say that a certain feature is
turned on if a variable is "non-nil," meaning that if the
variable's value is nil, the feature is off, but the feature is
on for any other value.  The conventional value to turn on the
feature--since you have to pick one particular value when you set the
variable--is t.

  Emacs uses many Lisp variables for internal recordkeeping, as any Lisp
program must, but the most interesting variables for you are the ones that
exist for the sake of customization.  Emacs does not (usually) change the
values of these variables; instead, you set the values, and thereby alter
and control the behavior of certain Emacs commands.  These variables are
called options.  Most options are documented in this manual and
appear in the Variable Index (see Variable Index).

  One example of a variable which is an option is fill-column, which
specifies the position of the right margin (as a number of characters from
the left margin) to be used by the fill commands (see Filling).

* Examining::           Examining or setting one variable's value.
* Easy Customization::  Convenient and easy customization of variables.
* Edit Options::        Examining or editing list of all variables' values.
* Locals::              Per-buffer values of variables.
* File Variables::      How files can specify variable values.

27.2.1 Examining and Setting Variables
--------------------------------------

C-h v
M-x describe-variable
Print the value and documentation of a variable.
M-x set-variable
Change the value of a variable.

  To examine the value of a single variable, use C-h v
(describe-variable), which reads a variable name using the
minibuffer, with completion.  It prints both the value and the
documentation of the variable.

C-h v fill-column <RET>

prints something like:

fill-column's value is 75

Documentation:
*Column beyond which automatic line-wrapping should happen.
Automatically becomes local when set in any fashion.

The star at the beginning of the documentation indicates that this variable
is an option.  C-h v is not restricted to options; it allows any
variable name.

  If you know which option you want to set, you can use M-x
set-variable to set it.  This prompts for the variable name in the
minibuffer (with completion), and then prompts for a Lisp expression for the
new value using the minibuffer a second time.  For example,

M-x set-variable <RET> fill-column <RET> 75 <RET>

sets fill-column to 75, as if you had executed the Lisp expression
(setq fill-column 75).

  Setting variables in this way, like all means of customizing Emacs
except where explicitly stated, affects only the current Emacs session.

27.2.2 Easy Customization Interface
-----------------------------------

  A convenient way to find the user option variables that you want to
change, and then change them, is with M-x customize (or use a
keyboard shortcut, C-h C.  This command
creates a customization buffer with which you can browse through
the Emacs user options in a logically organized structure, then edit and
set their values.  You can also use the customization buffer to save
settings permanently.  (Not all Emacs user options are included in this
structure as of yet, but we are adding the rest.)

* Groups: Customization Groups.
                             How options are classified in a structure.
* Changing an Option::       How to edit a value and set an option.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Making a customization buffer for specific
                                options, faces, or groups.

27.2.2.1 Customization Groups
.............................

  For customization purposes, user options are organized into
groups to help you find them.  Groups are collected into bigger
groups, all the way up to a master group called Emacs.

  M-x customize (or C-h C) creates a customization buffer that
shows the top-level Emacs group and the second-level groups immediately
under it.  It looks like this, in part:

/- Emacs group: ---------------------------------------------------\
      [State]: visible group members are all at standard settings.
   Customization of the One True Editor.
   See also [Manual].

 [Open] Editing group
Basic text editing facilities.

 [Open] External group
Interfacing to external utilities.

more second-level groups

\- Emacs group end ------------------------------------------------/


This says that the buffer displays the contents of the Emacs
group.  The other groups are listed because they are its contents.  But
they are listed differently, without indentation and dashes, because
their contents are not included.  Each group has a single-line
documentation string; the Emacs group also has a `[State]'
line.

  Most of the text in the customization buffer is read-only, but it
typically includes some editable fields that you can edit.  There
are also active fields; this means a field that does something
when you invoke it.  To invoke an active field, either click on it
with Mouse-1, or move point to it and type <RET>.

  For example, the phrase `[Open]' that appears in a second-level
group is an active field.  Invoking the `[Open]' field for a group
opens up a new customization buffer, which shows that group and its
contents.  This field is a kind of hypertext link to another group.

  The Emacs group does not include any user options itself, but
other groups do.  By examining various groups, you will eventually find
the options and faces that belong to the feature you are interested in
customizing.  Then you can use the customization buffer to set them.

  You can view the structure of customization groups on a larger scale
with M-x customize-browse.  This command creates a special kind of
customization buffer which shows only the names of the groups (and
options and faces), and their structure.

  In this buffer, you can show the contents of a group by invoking
`[+]'.  When the group contents are visible, this button changes to
`[-]'; invoking that hides the group contents.

  Each group, option or face name in this buffer has an active field
which says `[Group]', `[Option]' or `[Face]'.  Invoking
that active field creates an ordinary customization buffer showing just
that group and its contents, just that option, or just that face.
This is the way to set values in it.

27.2.2.2 Changing an Option
...........................

  Here is an example of what a user option looks like in the
customization buffer:

Kill Ring Max: [Hide] 30
   [State]: this option is unchanged from its standard setting.
Maximum length of kill ring before oldest elements are thrown away.

  The text following `[Hide]', `30' in this case, indicates
the current value of the option.  If you see `[Show]' instead of
`[Hide]', it means that the value is hidden; the customization
buffer initially hides values that take up several lines.  Invoke
`[Show]' to show the value.

  The line after the option name indicates the customization state
of the option: in the example above, it says you have not changed the
option yet.  The word `[State]' at the beginning of this line is
active; you can get a menu of various operations by invoking it with
Mouse-1 or <RET>.  These operations are essential for
customizing the variable.

  The line after the `[State]' line displays the beginning of the
option's documentation string.  If there are more lines of
documentation, this line ends with `[More]'; invoke this to show
the full documentation string.

  To enter a new value for `Kill Ring Max', move point to the value
and edit it textually.  For example, you can type M-d, then insert
another number.

  When you begin to alter the text, you will see the `[State]' line
change to say that you have edited the value:

[State]: you have edited the value as text, but not set the option.

  Editing the value does not actually set the option variable.  To do
that, you must set the option.  To do this, invoke the word
`[State]' and choose `Set for Current Session'.

  The state of the option changes visibly when you set it:

[State]: you have set this option, but not saved it for future sessions.

   You don't have to worry about specifying a value that is not valid;
setting the option checks for validity and will not really install an
unacceptable value.

  While editing a value or field that is a file name, directory name,
command name, or anything else for which completion is defined, you can
type M-<TAB> (widget-complete) to do completion.

  Some options have a small fixed set of possible legitimate values.
These options don't let you edit the value textually.  Instead, an
active field `[Value Menu]' appears before the value; invoke this
field to edit the value.  For a boolean "on or off" value, the active
field says `[Toggle]', and it changes to the other value.
`[Value Menu]' and `[Toggle]' edit the buffer; the changes
take effect when you use the `Set for Current Session' operation.

  Some options have values with complex structure.  For example, the
value of load-path is a list of directories.  Here is how it
appears in the customization buffer:

Load Path:
[INS] [DEL] [Current dir?]: /usr/local/share/emacs/19.34.94/site-lisp
[INS] [DEL] [Current dir?]: /usr/local/share/emacs/site-lisp
[INS] [DEL] [Current dir?]: /usr/local/share/emacs/19.34.94/leim
[INS] [DEL] [Current dir?]: /usr/local/share/emacs/19.34.94/lisp
[INS] [DEL] [Current dir?]: /build/emacs/e19/lisp
[INS] [DEL] [Current dir?]: /build/emacs/e19/lisp/gnus
[INS]
   [State]: this item has been changed outside the customization buffer.
List of directories to search for files to load....

Each directory in the list appears on a separate line, and each line has
several editable or active fields.

  You can edit any of the directory names.  To delete a directory from
the list, invoke `[DEL]' on that line.  To insert a new directory in
the list, invoke `[INS]' at the point where you want to insert it.

  You can also invoke `[Current dir?]' to switch between including
a specific named directory in the path, and including nil in the
path.  (nil in a search path means "try the current
directory.")

  Two special commands, <TAB> and S-<TAB>, are useful for
moving through the customization buffer.  <TAB>
(widget-forward) moves forward to the next active or editable
field; S-<TAB> (widget-backward) moves backward to the
previous active or editable field.

  Typing <RET> on an editable field also moves forward, just like
<TAB>.  The reason for this is that people have a tendency to type
<RET> when they are finished editing a field.  If you have occasion
to insert a newline in an editable field, use C-o or C-q
C-j,

  Setting the option changes its value in the current Emacs session;
saving the value changes it for future sessions as well.  This
works by writing code into your init file so as to set the option
variable again each time you start Emacs.  See Init File.  To save
the option, invoke `[State]' and select the `Save for Future
Sessions' operation.

  You can also restore the option to its standard value by invoking
`[State]' and selecting the `Reset' operation.  There are
actually three reset operations:

`Reset to Current'
If you have made some modifications and not yet set the option,
this restores the text in the customization buffer to match
the actual value.

`Reset to Saved'
This restores the value of the option to the last saved value,
and updates the text accordingly.

`Reset to Standard Settings'
This sets the option to its standard value, and updates the text
accordingly.  This also eliminates any saved value for the option,
so that you will get the standard value in future Emacs sessions.

  The state of a group indicates whether anything in that group has been
edited, set or saved.  You can select `Set for Current Session',
`Save for Future Sessions' and the various kinds of `Reset'
operation for the group; these operations on the group apply to all
options in the group and its subgroups.

  Near the top of the customization buffer there are two lines
containing several active fields:

 [Set] [Save] [Reset]  [Done]

Invoking `[Done]' buries this customization buffer.  Each of the
other fields performs an operation--set, save or reset--on each of the
items in the buffer that could meaningfully be set, saved or reset.

27.2.2.3 Customizing Faces
..........................

  In addition to user options, some customization groups also include
faces.  When you show the contents of a group, both the user options and
the faces in the group appear in the customization buffer.  Here is an
example of how a face looks:

Custom Changed Face: (sample)
   [State]: this face is unchanged from its standard setting.
Face used when the customize item has been changed.
Parent groups: [Custom Magic Faces]
Attributes: [ ] Bold: [Toggle]  off (nil)
            [ ] Italic: [Toggle]  off (nil)
            [ ] Underline: [Toggle]  off (nil)
            [ ] Foreground: white       (sample)
            [ ] Background: blue        (sample)
            [ ] Inverse: [Toggle]  off (nil)
            [ ] Stipple: 
            [ ] Font Family: 
            [ ] Size: 
            [ ] Strikethru: off

  Each face attribute has its own line.  The `[x]' field
before the attribute name indicates whether the attribute is
enabled; `X' means that it is.  You can enable or disable the
attribute by invoking that field.  When the attribute is enabled, you
can change the attribute value in the usual ways.

See Faces, for description of how face-frob-from-locale-first
variable affects changing `Bold' and `Italic' attributes.

  Setting, saving and resetting a face work like the same operations for
options (see Changing an Option).

  A face can specify different appearances for different types of
display.  For example, a face can make text red on a color display, but
use a bold font on a monochrome display.  To specify multiple
appearances for a face, select `Show Display Types' in the menu you
get from invoking `[State]'.


27.2.2.4 Customizing Specific Items
...................................

  Instead of finding the options you want to change by moving down
through the structure of groups, you can specify the particular option,
face or group that you want to customize.

M-x customize-option <RET> option <RET>
Set up a customization buffer with just one option, option.
M-x customize-face <RET> face <RET>
Set up a customization buffer with just one face, face.
M-x customize-group <RET> group <RET>
Set up a customization buffer with just one group, group.
M-x customize-apropos <RET> regexp <RET>
Set up a customization buffer with all the options, faces and groups
that match regexp.
M-x customize-saved
Set up a customization buffer containing all options and faces that you
have saved with customization buffers.
M-x customize-customized
Set up a customization buffer containing all options and faces that you
have customized but not saved.

  If you want to alter a particular user option variable with the
customization buffer, and you know its name, you can use the command
M-x customize-option and specify the option name.  This sets up
the customization buffer with just one option--the one that you asked
for.  Editing, setting and saving the value work as described above, but
only for the specified option.

  Likewise, you can modify a specific face, chosen by name, using
M-x customize-face.

  You can also set up the customization buffer with a specific group,
using M-x customize-group.  The immediate contents of the chosen
group, including option variables, faces, and other groups, all appear
as well.  However, these subgroups' own contents start out hidden.  You
can show their contents in the usual way, by invoking `[Show]'.

  To control more precisely what to customize, you can use M-x
customize-apropos.  You specify a regular expression as argument; then
all options, faces and groups whose names match this regular expression
are set up in the customization buffer.  If you specify an empty regular
expression, this includes all groups, options and faces in the
customization buffer (but that takes a long time).

  If you change option values and then decide the change was a mistake,
you can use two special commands to revisit your previous changes.  Use
customize-saved to look at the options and faces that you have
saved.  Use M-x customize-customized to look at the options and
faces that you have set but not saved.

27.2.3 Editing Variable Values
------------------------------

M-x list-options
Display a buffer listing names, values, and documentation of all options.
M-x edit-options
Change option values by editing a list of options.

  M-x list-options displays a list of all Emacs option variables in
an Emacs buffer named `*List Options*'.  Each option is shown with its
documentation and its current value.  Here is what a portion of it might
look like:

;; exec-path:
("." "/usr/local/bin" "/usr/ucb" "/bin" "/usr/bin" "/u2/emacs/etc")
*List of directories to search programs to run in subprocesses.
Each element is a string (directory name)
or nil (try the default directory).
;;
;; fill-column:
75
*Column beyond which automatic line-wrapping should happen.
Automatically becomes local when set in any fashion.
;;

  M-x edit-options goes one step further and immediately selects the
`*List Options*' buffer; this buffer uses the major mode Options mode,
which provides commands that allow you to point at an option and change its
value:

s
Set the variable point is in or near to a new value read using the
minibuffer.
x
Toggle the variable point is in or near: if the value was nil,
it becomes t; otherwise it becomes nil.
1
Set the variable point is in or near to t.
0
Set the variable point is in or near to nil.
n
p
Move to the next or previous variable.

27.2.4 Local Variables
----------------------

M-x make-local-variable
Make a variable have a local value in the current buffer.
M-x kill-local-variable
Make a variable use its global value in the current buffer.
M-x make-variable-buffer-local
Mark a variable so that setting it will make it local to the
buffer that is current at that time.

   You can make any variable local to a specific Emacs buffer.
This means that the variable's value in that buffer is independent of
its value in other buffers.  A few variables are always local in every
buffer.  All other Emacs variables have a global value which is in
effect in all buffers that have not made the variable local.

  Major modes always make the variables they set local to the buffer.
This is why changing major modes in one buffer has no effect on other
buffers.

  M-x make-local-variable reads the name of a variable and makes it
local to the current buffer.  Further changes in this buffer will not
affect others, and changes in the global value will not affect this
buffer.

  M-x make-variable-buffer-local reads the name of a variable and
changes the future behavior of the variable so that it automatically
becomes local when it is set.  More precisely, once you have marked a
variable in this way, the usual ways of setting the
variable will automatically invoke make-local-variable first.  We
call such variables per-buffer variables.

  Some important variables have been marked per-buffer already.  They
include abbrev-mode, auto-fill-function,
case-fold-search, comment-column, ctl-arrow,
fill-column, fill-prefix, indent-tabs-mode,
left-margin, 
mode-line-format, overwrite-mode,
selective-display-ellipses, 
selective-display,
tab-width, and truncate-lines.  Some other variables are
always local in every buffer, but they are used for internal
purposes.

Note: the variable auto-fill-function was formerly named
auto-fill-hook.

  If you want a variable to cease to be local to the current buffer,
call M-x kill-local-variable and provide the name of a variable to
the prompt.  The global value of the variable
is again in effect in this buffer.  Setting the major mode kills all
the local variables of the buffer.

  To set the global value of a variable, regardless of whether the
variable has a local value in the current buffer, you can use the
Lisp function setq-default.  It works like setq.
If there is a local value in the current buffer, the local value is
not affected by setq-default; thus, the new global value may
not be visible until you switch to another buffer, as in the case of:

(setq-default fill-column 75)

setq-default is the only way to set the global value of a variable
that has been marked with make-variable-buffer-local.

  Programs can look at a variable's default value with default-value.
This function takes a symbol as an argument and returns its default value.
The argument is evaluated; usually you must quote it explicitly, as in
the case of:

(default-value 'fill-column)

27.2.5 Local Variables in Files
-------------------------------

  A file can contain a local variables list, which specifies the
values to use for certain Emacs variables when that file is edited.
Visiting the file checks for a local variables list and makes each variable
in the list local to the buffer in which the file is visited, with the
value specified in the file.

  A local variables list goes near the end of the file, in the last page.
(It is often best to put it on a page by itself.)  The local variables list
starts with a line containing the string `Local Variables:', and ends
with a line containing the string `End:'.  In between come the
variable names and values, one set per line, as `variable:
value'.  The values are not evaluated; they are used literally.

  The line which starts the local variables list does not have to say
just `Local Variables:'.  If there is other text before `Local
Variables:', that text is called the prefix, and if there is other
text after, that is called the suffix.  If a prefix or suffix are
present, each entry in the local variables list should have the prefix
before it and the suffix after it.  This includes the `End:' line.
The prefix and suffix are included to disguise the local variables list
as a comment so the compiler or text formatter  will ignore it.
If you do not need to disguise the local variables list as a comment in
this way, there is no need to include a prefix or a suffix.

  Two "variable" names are special in a local variables list: a value
for the variable mode sets the major mode, and a value for the
variable eval is simply evaluated as an expression and the value
is ignored.  These are not real variables; setting them in any other
context does not have the same effect.  If mode is used in a
local variables list, it should be the first entry in the list.

Here is an example of a local variables list:
;;; Local Variables: ***
;;; mode:lisp ***
;;; comment-column:0 ***
;;; comment-start: ";;; "  ***
;;; comment-end:"***" ***
;;; End: ***

  Note that the prefix is `;;; ' and the suffix is ` ***'.
Note also that comments in the file begin with and end with the same
strings.  Presumably the file contains code in a language which is
enough like Lisp for Lisp mode to be useful but in which comments
start and end differently.  The prefix and suffix are used in the local
variables list to make the list look like several lines of comments when
the compiler or interpreter for that language reads the file. 

  The start of the local variables list must be no more than 3000
characters from the end of the file, and must be in the last page if the
file is divided into pages.  Otherwise, Emacs will not notice it is
there.  The purpose is twofold: a stray `Local Variables:' not in
the last page does not confuse Emacs, and Emacs never needs to search a
long file that contains no page markers and has no local variables list.

  You may be tempted to turn on Auto Fill mode with a local variable
list.  That is inappropriate.  Whether you use Auto Fill mode or not is
a matter of personal taste, not a matter of the contents of particular
files.  If you want to use Auto Fill, set up major mode hooks with your
init file to turn it on (when appropriate) for you alone
(see Init File).  Don't try to use a local variable list that would
impose your taste on everyone working with the file.

XEmacs allows you to specify local variables in the first line
of a file, in addition to specifying them in the Local Variables
section at the end of a file.

If the first line of a file contains two occurrences of `-*-',
XEmacs uses the information between them to determine what the major
mode and variable settings should be.  For example, these are all legal:

        ;;; -*- mode: emacs-lisp -*-
        ;;; -*- mode: postscript; version-control: never -*-
        ;;; -*- tags-file-name: "/foo/bar/TAGS" -*-

For historical reasons, the syntax `-*- modename -*-' is allowed
as well; for example, you can use:

        ;;; -*- emacs-lisp -*-

The variable enable-local-variables controls the use of local
variables lists in files you visit.  The value can be t,
nil, or something else.  A value of t means local variables
lists are obeyed; nil means they are ignored; anything else means
query.

The command M-x normal-mode always obeys local variables lists
and ignores this variable.

27.3 Keyboard Macros
====================

  A keyboard macro is a command defined by the user to abbreviate a
sequence of keys.  For example, if you discover that you are about to type
C-n C-d forty times, you can speed your work by defining a keyboard
macro to invoke C-n C-d and calling it with a repeat count of forty.

C-x (
Start defining a keyboard macro (start-kbd-macro).
C-x )
End the definition of a keyboard macro (end-kbd-macro).
C-x e
Execute the most recent keyboard macro (call-last-kbd-macro).
C-u C-x (
Re-execute last keyboard macro, then add more keys to its definition.
C-x q
When this point is reached during macro execution, ask for confirmation
(kbd-macro-query).
M-x name-last-kbd-macro
Give a command name (for the duration of the session) to the most
recently defined keyboard macro.
M-x insert-kbd-macro
Insert in the buffer a keyboard macro's definition, as Lisp code.

  Keyboard macros differ from other Emacs commands in that they are
written in the Emacs command language rather than in Lisp.  This makes it
easier for the novice to write them and makes them more convenient as
temporary hacks.  However, the Emacs command language is not powerful
enough as a programming language to be useful for writing anything
general or complex.  For such things, Lisp must be used.

  You define a keyboard macro by executing the commands which are its
definition.  Put differently, as you are defining a keyboard macro, the
definition is being executed for the first time.  This way, you see
what the effects of your commands are, and don't have to figure
them out in your head.  When you are finished, the keyboard macro is
defined and also has been executed once.  You can then execute the same
set of commands again by invoking the macro.

* Basic Kbd Macro::     Defining and running keyboard macros.
* Save Kbd Macro::      Giving keyboard macros names; saving them in files.
* Kbd Macro Query::     Keyboard macros that do different things each use.

27.3.1 Basic Use
----------------

  To start defining a keyboard macro, type C-x (
(start-kbd-macro).  From then on, anything you type continues to be
executed, but also becomes part of the definition of the macro.  `Def'
appears in the mode line to remind you of what is going on.  When you are
finished, the C-x ) command (end-kbd-macro) terminates the
definition, without becoming part of it. 

  For example,

C-x ( M-f foo C-x )

defines a macro to move forward a word and then insert `foo'.

You can give C-x ) a repeat count as an argument, in which case it
repeats the macro that many times right after defining it, but defining
the macro counts as the first repetition (since it is executed as you
define it).  If you give C-x ) an argument of 4, it executes the
macro immediately 3 additional times.  An argument of zero to C-x
e or C-x ) means repeat the macro indefinitely (until it gets an
error or you type C-g).

  Once you have defined a macro, you can invoke it again with the
C-x e command (call-last-kbd-macro).  You can give the
command a repeat count numeric argument to execute the macro many times.

  To repeat an operation at regularly spaced places in the
text, define a macro and include as part of the macro the commands to move
to the next place you want to use it.  For example, if you want to change
each line, you should position point at the start of a line, and define a
macro to change that line and leave point at the start of the next line.
Repeating the macro will then operate on successive lines.

  After you have terminated the definition of a keyboard macro, you can add
to the end of its definition by typing C-u C-x (.  This is equivalent
to plain C-x ( followed by retyping the whole definition so far.  As
a consequence it re-executes the macro as previously defined.

27.3.2 Naming and Saving Keyboard Macros
----------------------------------------

  To save a keyboard macro for longer than until you define the
next one, you must give it a name using M-x name-last-kbd-macro.
This reads a name as an argument using the minibuffer and defines that name
to execute the macro.  The macro name is a Lisp symbol, and defining it in
this way makes it a valid command name for calling with M-x or for
binding a key to with global-set-key (see Keymaps).  If you
specify a name that has a prior definition other than another keyboard
macro, Emacs prints an error message and nothing is changed.

  Once a macro has a command name, you can save its definition in a file.
You can then use it in another editing session.  First visit the file
you want to save the definition in.  Then use the command:

M-x insert-kbd-macro <RET> macroname <RET>

This inserts some Lisp code that, when executed later, will define the same
macro with the same definition it has now.  You need not understand Lisp
code to do this, because insert-kbd-macro writes the Lisp code for you.
Then save the file.  You can load the file with load-file
(see Lisp Libraries).  If the file you save in is your initialization file
(see Init File), then the macro will be defined each
time you run Emacs.

  If you give insert-kbd-macro a prefix argument, it creates
additional Lisp code to record the keys (if any) that you have bound to the
keyboard macro, so that the macro is reassigned the same keys when you
load the file.

27.3.3 Executing Macros With Variations
---------------------------------------

  You can use C-x q (kbd-macro-query), to get an effect similar
to that of query-replace.  The macro asks you  each time
whether to make a change.  When you are defining the macro, type C-x
q at the point where you want the query to occur.  During macro
definition, the C-x q does nothing, but when you invoke the macro,
C-x q reads a character from the terminal to decide whether to
continue.

  The special answers to a C-x q query are <SPC>, <DEL>,
C-d, C-l, and C-r.  Any other character terminates
execution of the keyboard macro and is then read as a command.
<SPC> means to continue.  <DEL> means to skip the remainder of
this repetition of the macro, starting again from the beginning in the
next repetition.  C-d means to skip the remainder of this
repetition and cancel further repetition.  C-l redraws the frame
and asks you again for a character to specify what to do.  C-r enters
a recursive editing level, in which you can perform editing that is not
part of the macro.  When you exit the recursive edit using C-M-c,
you are asked again how to continue with the keyboard macro.  If you
type a <SPC> at this time, the rest of the macro definition is
executed.  It is up to you to leave point and the text in a state such
that the rest of the macro will do what you want.

  C-u C-x q, which is C-x q with a numeric argument, performs a
different function.  It enters a recursive edit reading input from the
keyboard, both when you type it during the definition of the macro and
when it is executed from the macro.  During definition, the editing you do
inside the recursive edit does not become part of the macro.  During macro
execution, the recursive edit gives you a chance to do some particularized
editing.  See Recursive Edit.

27.4 Customizing Key Bindings
=============================

  This section deals with the keymaps that define the bindings
between keys and functions, and shows how you can customize these bindings.

  A command is a Lisp function whose definition provides for interactive
use.  Like every Lisp function, a command has a function name, which is
a Lisp symbol whose name usually consists of lower case letters and
hyphens.

* Keymaps::    Definition of the keymap data structure.
               Names of Emacs's standard keymaps.
* Rebinding::  How to redefine one key's meaning conveniently.
* Disabling::  Disabling a command means confirmation is required
                before it can be executed.  This is done to protect
                beginners from surprises.

27.4.1 Keymaps
--------------

  The bindings between characters and command functions are recorded in
data structures called keymaps.  Emacs has many of these.  One, the
global keymap, defines the meanings of the single-character keys that
are defined regardless of major mode.  It is the value of the variable
global-map.

  Each major mode has another keymap, its local keymap, which
contains overriding definitions for the single-character keys that are
redefined in that mode.  Each buffer records which local keymap is
installed for it at any time, and the current buffer's local keymap is
the only one that directly affects command execution.  The local keymaps
for Lisp mode, C mode, and many other major modes always exist even when
not in use.  They are the values of the variables lisp-mode-map,
c-mode-map, and so on.  For less frequently used major modes, the
local keymap is sometimes constructed only when the mode is used for the
first time in a session, to save space.

  There are local keymaps for the minibuffer, too; they contain various
completion and exit commands.

* minibuffer-local-map is used for ordinary input (no completion).
* minibuffer-local-ns-map is similar, except that <SPC> exits
just like <RET>.  This is used mainly for Mocklisp compatibility.
* minibuffer-local-completion-map is for permissive completion.
* minibuffer-local-must-match-map is for strict completion and
for cautious completion.
* repeat-complex-command-map is for use in C-x <ESC> <ESC>.
* isearch-mode-map contains the bindings of the special keys which
are bound in the pseudo-mode entered with C-s and C-r.

  Finally, each prefix key has a keymap which defines the key sequences
that start with it.  For example, ctl-x-map is the keymap used for
characters following a C-x.

* ctl-x-map is the variable name for the map used for characters that
follow C-x.
* help-map is used for characters that follow C-h.
* esc-map is for characters that follow <ESC>. All Meta
characters are actually defined by this map.
* ctl-x-4-map is for characters that follow C-x 4.
* mode-specific-map is for characters that follow C-c.

  The definition of a prefix key is the keymap to use for looking up
the following character.  Sometimes the definition is actually a Lisp
symbol whose function definition is the following character keymap.  The
effect is the same, but it provides a command name for the prefix key that
you can use as a description of what the prefix key is for.  Thus the
binding of C-x is the symbol Ctl-X-Prefix, whose function
definition is the keymap for C-x commands, the value of
ctl-x-map.

  Prefix key definitions can appear in either the global
map or a local map.  The definitions of C-c, C-x, C-h,
and <ESC> as prefix keys appear in the global map, so these prefix
keys are always available.  Major modes can locally redefine a key as a
prefix by putting a prefix key definition for it in the local
map.

  A mode can also put a prefix definition of a global prefix character such
as C-x into its local map.  This is how major modes override the
definitions of certain keys that start with C-x.  This case is
special, because the local definition does not entirely replace the global
one.  When both the global and local definitions of a key are other
keymaps, the next character is looked up in both keymaps, with the local
definition overriding the global one.  The character after the
C-x is looked up in both the major mode's own keymap for redefined
C-x commands and in ctl-x-map.  If the major mode's own keymap
for C-x commands contains nil, the definition from the global
keymap for C-x commands is used.

27.4.2 Changing Key Bindings
----------------------------

  You can redefine an Emacs key by changing its entry in a keymap.
You can change the global keymap, in which case the change is effective in
all major modes except those that have their own overriding local
definitions for the same key.  Or you can change the current buffer's
local map, which affects all buffers using the same major mode.

* Interactive Rebinding::      Changing Key Bindings Interactively   
* Programmatic Rebinding::     Changing Key Bindings Programmatically
* Key Bindings Using Strings:: Using Strings for Changing Key Bindings 

27.4.2.1 Changing Key Bindings Interactively
............................................

M-x global-set-key <RET> key cmd <RET>
Defines key globally to run cmd.
M-x local-set-key <RET> keys cmd <RET>
Defines key locally (in the major mode now in effect) to run
cmd.
M-x local-unset-key <RET> keys <RET>
Removes the local binding of key.

cmd is a symbol naming an interactively-callable function.

When called interactively, key is the next complete key sequence
that you type.  When called as a function, key is a string, a
vector of events, or a vector of key-description lists as described in
the define-key function description.  The binding goes in
the current buffer's local map, which is shared with other buffers in
the same major mode.

The following example:

M-x global-set-key <RET> C-f next-line <RET>

redefines C-f to move down a line.  The fact that cmd is
read second makes it serve as a kind of confirmation for key.

  These functions offer no way to specify a particular prefix keymap as
the one to redefine in, but that is not necessary, as you can include
prefixes in key.  key is read by reading characters one by
one until they amount to a complete key (that is, not a prefix key).
Thus, if you type C-f for key, Emacs enters
the minibuffer immediately to read cmd.  But if you type
C-x, another character is read; if that character is 4,
another character is read, and so on.  For example,

M-x global-set-key <RET> C-x 4 $ spell-other-window <RET>

redefines C-x 4 $ to run the (fictitious) command
spell-other-window.

  The most general way to modify a keymap is the function
define-key, used in Lisp code (such as your init file).
define-key takes three arguments: the keymap, the key to modify
in it, and the new definition.  See Init File, for an example.
substitute-key-definition is used similarly; it takes three
arguments, an old definition, a new definition, and a keymap, and
redefines in that keymap all keys that were previously defined with the
old definition to have the new definition instead.

27.4.2.2 Changing Key Bindings Programmatically
...............................................

  You can use the functions global-set-key and define-key
to rebind keys under program control.


(global-set-key keys cmd)
Defines keys globally to run cmd.
(define-key keymap keys def)
Defines keys to run def in the keymap keymap.
 
keymap is a keymap object.

keys is the sequence of keystrokes to bind.

def is anything that can be a key's definition:

* nil, meaning key is undefined in this keymap
* A command, that is, a Lisp function suitable for interactive calling
* A string or key sequence vector, which is treated as a keyboard macro
* A keymap to define a prefix key
* A symbol so that when the key is looked up, the symbol stands for its
function definition, which should at that time be one of the above,
or another symbol whose function definition is used, and so on
* A cons, (string . defn), meaning that defn is the definition
(defn should be a valid definition in its own right)
* A cons, (keymap . char), meaning use the definition of
char in map keymap

For backward compatibility, XEmacs allows you to specify key
sequences as strings.  However, the preferred method is to use the
representations of key sequences as vectors of keystrokes.
See Keystrokes, for more information about the rules for constructing
key sequences.

Emacs allows you to abbreviate representations for key sequences in 
most places where there is no ambiguity.
Here are some rules for abbreviation:

* The keysym by itself is equivalent to a list of just that keysym, i.e.,
f1 is equivalent to (f1).
* A keystroke by itself is equivalent to a vector containing just that
keystroke, i.e.,  (control a) is equivalent to [(control a)].
* You can use ASCII codes for keysyms that have them. i.e.,
65 is equivalent to A. (This is not so much an
abbreviation as an alternate representation.)

Here are some examples of programmatically binding keys:


;;;  Bind my-command to <f1>
(global-set-key 'f1 'my-command)                

;;;  Bind my-command to Shift-f1
(global-set-key '(shift f1) 'my-command)

;;; Bind my-command to C-c Shift-f1
(global-set-key '[(control c) (shift f1)] 'my-command)  

;;; Bind my-command to the middle mouse button.
(global-set-key 'button2 'my-command)

;;; Bind my-command to <META> <CTL> <Right Mouse Button>
;;; in the keymap that is in force when you are running dired.
(define-key dired-mode-map '(meta control button3) 'my-command)



27.4.2.3 Using Strings for Changing Key Bindings
................................................

  For backward compatibility, you can still use strings to represent
key sequences.  Thus you can use commands like the following:

;;; Bind end-of-line to C-f
(global-set-key "\C-f" 'end-of-line)

Note, however, that in some cases you may be binding more than one
key sequence by using a single command.  This situation can 
arise because in ASCII, C-i and <TAB> have
the same representation.  Therefore, when Emacs sees:

(global-set-key "\C-i" 'end-of-line)

it is unclear whether the user intended to bind C-i or <TAB>.
The solution XEmacs adopts is to bind both of these key
sequences.

After binding a command to two key sequences with a form like:

        (define-key global-map "\^X\^I" 'command-1)

it is possible to redefine only one of those sequences like so:

        (define-key global-map [(control x) (control i)] 'command-2)
        (define-key global-map [(control x) tab] 'command-3)

This applies only when running under a window system.  If you are
talking to Emacs through an ASCII-only channel, you do not get any of
these features.

Here is a table of pairs of key sequences that behave in a
similar fashion:

        control h      backspace           
        control l      clear
        control i      tab 
        control m      return              
        control j      linefeed 
        control [      escape
        control @      control space

27.4.3 Disabling Commands
-------------------------

  Disabling a command marks it as requiring confirmation before it
can be executed.  The purpose of disabling a command is to prevent
beginning users from executing it by accident and being confused.

  The direct mechanism for disabling a command is to have a non-nil
disabled property on the Lisp symbol for the command.  These
properties are normally set by the user's init file with
Lisp expressions such as:

(put 'delete-region 'disabled t)

See Init File.

  If the value of the disabled property is a string, that string
is included in the message printed when the command is used:

(put 'delete-region 'disabled
     "Text deleted this way cannot be yanked back!\n")

  You can disable a command either by editing the init file
directly or with the command M-x disable-command, which edits the
init file for you.  See Init File.

  When you attempt to invoke a disabled command interactively in Emacs,
a window is displayed containing the command's name, its
documentation, and some instructions on what to do next; then
Emacs asks for input saying whether to execute the command as requested,
enable it and execute, or cancel it.  If you decide to enable the
command, you are asked whether to do this permanently or just for the
current session.  Enabling permanently works by automatically editing
your init file.  You can use M-x enable-command at any
time to enable any command permanently.

  Whether a command is disabled is independent of what key is used to
invoke it; it also applies if the command is invoked using M-x.
Disabling a command has no effect on calling it as a function from Lisp
programs.

27.5 The Syntax Table
=====================

  All the Emacs commands which parse words or balance parentheses are
controlled by the syntax table.  The syntax table specifies which
characters are opening delimiters, which are parts of words, which are
string quotes, and so on.  Actually, each major mode has its own syntax
table (though sometimes related major modes use the same one) which it
installs in each buffer that uses that major mode.  The syntax table
installed in the current buffer is the one that all commands use, so we
call it "the" syntax table.  A syntax table is a Lisp object, a vector of
length 256 whose elements are numbers.

* Entry: Syntax Entry.    What the syntax table records for each character.
* Change: Syntax Change.  How to change the information.

27.5.1 Information About Each Character
---------------------------------------

  The syntax table entry for a character is a number that encodes six
pieces of information:

* The syntactic class of the character, represented as a small integer
* The matching delimiter, for delimiter characters only
(the matching delimiter of `(' is `)', and vice versa)
* A flag saying whether the character is the first character of a
two-character comment starting sequence
* A flag saying whether the character is the second character of a
two-character comment starting sequence
* A flag saying whether the character is the first character of a
two-character comment ending sequence
* A flag saying whether the character is the second character of a
two-character comment ending sequence

  The syntactic classes are stored internally as small integers, but are
usually described to or by the user with characters.  For example, `('
is used to specify the syntactic class of opening delimiters.  Here is a
table of syntactic classes, with the characters that specify them.

`-'
The class of whitespace characters.  Please don't use the formerly
advertised  , which is not supported by GNU Emacs.
`w'
The class of word-constituent characters.
`_'
The class of characters that are part of symbol names but not words.
This class is represented by `_' because the character `_'
has this class in both C and Lisp.
`.'
The class of punctuation characters that do not fit into any other
special class.
`('
The class of opening delimiters.
`)'
The class of closing delimiters.
`''
The class of expression-adhering characters.  These characters are
part of a symbol if found within or adjacent to one, and are part
of a following expression if immediately preceding one, but are like
whitespace if surrounded by whitespace.
`"'
The class of string-quote characters.  They match each other in pairs,
and the characters within the pair all lose their syntactic
significance except for the `\' and `/' classes of escape
characters, which can be used to include a string-quote inside the
string.
`$'
The class of self-matching delimiters.  This is intended for TeX's
`$', which is used both to enter and leave math mode.  Thus,
a pair of matching `$' characters surround each piece of math mode
TeX input.  A pair of adjacent `$' characters act like a single
one for purposes of matching.

`/'
The class of escape characters that always just deny the following
character its special syntactic significance.  The character after one
of these escapes is always treated as alphabetic.
`\'
The class of C-style escape characters.  In practice, these are
treated just like `/'-class characters, because the extra
possibilities for C escapes (such as being followed by digits) have no
effect on where the containing expression ends.
`<'
The class of comment-starting characters.  Only single-character
comment starters (such as `;' in Lisp mode) are represented this
way.
`>'
The class of comment-ending characters.  Newline has this syntax in
Lisp mode.

  The characters flagged as part of two-character comment delimiters can
have other syntactic functions most of the time.  For example, `/' and
`*' in C code, when found separately, have nothing to do with
comments.  The comment-delimiter significance overrides when the pair of
characters occur together in the proper order.  Only the list and sexp
commands use the syntax table to find comments; the commands specifically
for comments have other variables that tell them where to find comments.
Moreover, the list and sexp commands notice comments only if
parse-sexp-ignore-comments is non-nil.  This variable is set
to nil in modes where comment-terminator sequences are liable to
appear where there is no comment, for example, in Lisp mode where the
comment terminator is a newline but not every newline ends a comment.

27.5.2 Altering Syntax Information
----------------------------------

  It is possible to alter a character's syntax table entry by storing a new
number in the appropriate element of the syntax table, but it would be hard
to determine what number to use.  Emacs therefore provides a command that
allows you to specify the syntactic properties of a character in a
convenient way.

  M-x modify-syntax-entry is the command to change a character's
syntax.  It can be used interactively and is also used by major
modes to initialize their own syntax tables.  Its first argument is the
character to change.  The second argument is a string that specifies the
new syntax.  When called from Lisp code, there is a third, optional
argument, which specifies the syntax table in which to make the change.  If
not supplied, or if this command is called interactively, the third
argument defaults to the current buffer's syntax table.

1. The first character in the string specifies the syntactic class.  It
is one of the characters in the previous table (see Syntax Entry).

2. The second character is the matching delimiter.  For a character that
is not an opening or closing delimiter, this should be a space, and may
be omitted if no following characters are needed.

3. The remaining characters are flags.  The flag characters allowed are:

`1'
Flag this character as the first of a two-character comment starting sequence.
`2'
Flag this character as the second of a two-character comment starting sequence.
`3'
Flag this character as the first of a two-character comment ending sequence.
`4'
Flag this character as the second of a two-character comment ending sequence.

  Use C-h s (describe-syntax) to display a description of
the contents of the current syntax table.  The description of each
character includes both the string you have to pass to
modify-syntax-entry to set up that character's current syntax,
and some English to explain that string if necessary.

27.6 The Init File
==================

  When you start Emacs, it normally loads either `.xemacs/init.el'
or the file `.emacs' (whichever comes first) in your home directory.
This file, if it exists, should contain Lisp code.  It is called your
initialization file or init file.  Use the command line switch
`-q' to tell Emacs whether to load an init file (see Entering Emacs).  Use the command line switch `-user-init-file'
(see Command Switches) to tell Emacs to load a different file
instead of `~/.xemacs/init.el'/`~/.emacs'.

When the init file is read, the variable user-init-file says
which init file was loaded.

  At some sites there is a default init file, which is the
library named `default.el', found via the standard search path for
libraries.  The Emacs distribution contains no such library; your site
may create one for local customizations.  If this library exists, it is
loaded whenever you start Emacs.  But your init file, if any, is loaded
first; if it sets inhibit-default-init non-nil, then
`default' is not loaded.

  If you have a large amount of code in your init file, you should
byte-compile it to `~/.xemacs/init.elc' or `~/.emacs.elc'.

* Init Syntax::     Syntax of constants in Emacs Lisp.
* Init Examples::   How to do some things with an init file.
* Terminal Init::   Each terminal type can have an init file.

27.6.1 Init File Syntax
-----------------------

  The init file contains one or more Lisp function call
expressions.  Each consists of a function name followed by
arguments, all surrounded by parentheses.  For example, (setq
fill-column 60) represents a call to the function setq which is
used to set the variable fill-column (see Filling) to 60.

  The second argument to setq is an expression for the new value
of the variable.  This can be a constant, a variable, or a function call
expression.  In the init file, constants are used most of the time.
They can be:

Numbers
Integers are written in decimal, with an optional initial minus sign.

If a sequence of digits is followed by a period and another sequence
of digits, it is interpreted as a floating point number.

The number prefixes `#b', `#o', and `#x' are supported to
represent numbers in binary, octal, and hexadecimal notation (or radix).

Strings
Lisp string syntax is the same as C string syntax with a few extra
features.  Use a double-quote character to begin and end a string constant.

Newlines and special characters may be present literally in strings.  They
can also be represented as backslash sequences: `\n' for newline,
`\b' for backspace, `\r' for return, `\t' for tab,
`\f' for formfeed (control-l), `\e' for escape, `\\' for a
backslash, `\"' for a double-quote, or `\ooo' for the
character whose octal code is ooo.  Backslash and double-quote are
the only characters for which backslash sequences are mandatory.

You can use `\C-' as a prefix for a control character, as in
`\C-s' for ASCII Control-S, and `\M-' as a prefix for
a Meta character, as in `\M-a' for Meta-A or `\M-\C-a' for
Control-Meta-A.

Characters
Lisp character constant syntax consists of a `?' followed by
either a character or an escape sequence starting with `\'.
Examples: ?x, ?\n, ?\", ?\).  Note that
strings and characters are not interchangeable in Lisp; some contexts
require one and some contexts require the other.

True
t stands for `true'.

False
nil stands for `false'.

Other Lisp objects
Write a single-quote (') followed by the Lisp object you want.

27.6.2 Init File Examples
-------------------------

  Here are some examples of doing certain commonly desired things with
Lisp expressions:

* Make <TAB> in C mode just insert a tab if point is in the middle of a
line.

(setq c-tab-always-indent nil)

Here we have a variable whose value is normally t for `true'
and the alternative is nil for `false'.

* Make searches case sensitive by default (in all buffers that do not
override this).

(setq-default case-fold-search nil)

This sets the default value, which is effective in all buffers that do
not have local values for the variable.  Setting case-fold-search
with setq affects only the current buffer's local value, which
is probably not what you want to do in an init file.

* Make Text mode the default mode for new buffers.

(setq default-major-mode 'text-mode)

Note that text-mode is used because it is the command for entering
the mode we want.  A single-quote is written before it to make a symbol
constant; otherwise, text-mode would be treated as a variable name.

* Turn on Auto Fill mode automatically in Text mode and related modes.

(setq text-mode-hook
  '(lambda () (auto-fill-mode 1)))

Here we have a variable whose value should be a Lisp function.  The
function we supply is a list starting with lambda, and a single
quote is written in front of it to make it (for the purpose of this
setq) a list constant rather than an expression.  Lisp functions
are not explained here; for mode hooks it is enough to know that
(auto-fill-mode 1) is an expression that will be executed when
Text mode is entered.  You could replace it with any other expression
that you like, or with several expressions in a row.

(setq text-mode-hook 'turn-on-auto-fill)

This is another way to accomplish the same result.
turn-on-auto-fill is a symbol whose function definition is
(lambda () (auto-fill-mode 1)).

* Load the installed Lisp library named `foo' (actually a file
`foo.elc' or `foo.el' in a standard Emacs directory).

(load "foo")

When the argument to load is a relative pathname, not starting
with `/' or `~', load searches the directories in
load-path (see Loading).

* Load the compiled Lisp file `foo.elc' from your home directory.

(load "~/foo.elc")

Here an absolute file name is used, so no searching is done.

* Rebind the key C-x l to run the function make-symbolic-link.

(global-set-key "\C-xl" 'make-symbolic-link)

or

(define-key global-map "\C-xl" 'make-symbolic-link)

Note once again the single-quote used to refer to the symbol
make-symbolic-link instead of its value as a variable.

* Do the same thing for C mode only.

(define-key c-mode-map "\C-xl" 'make-symbolic-link)

* Bind the function key <F1> to a command in C mode.
Note that the names of function keys must be lower case.

(define-key c-mode-map 'f1 'make-symbolic-link)

* Bind the shifted version of <F1> to a command.

(define-key c-mode-map '(shift f1) 'make-symbolic-link)

* Redefine all keys which now run next-line in Fundamental mode
to run forward-line instead.

(substitute-key-definition 'next-line 'forward-line
                           global-map)

* Make C-x C-v undefined.

(global-unset-key "\C-x\C-v")

One reason to undefine a key is so that you can make it a prefix.
Simply defining C-x C-v anything would make C-x C-v
a prefix, but C-x C-v must be freed of any non-prefix definition
first.

* Make `$' have the syntax of punctuation in Text mode.
Note the use of a character constant for `$'.

(modify-syntax-entry ?\$ "." text-mode-syntax-table)

* Enable the use of the command eval-expression without confirmation.

(put 'eval-expression 'disabled nil)

27.6.3 Terminal-Specific Initialization
---------------------------------------

  Each terminal type can have a Lisp library to be loaded into Emacs when
it is run on that type of terminal.  For a terminal type named
termtype, the library is called `term/termtype' and it is
found by searching the directories load-path as usual and trying the
suffixes `.elc' and `.el'.  Normally it appears in the
subdirectory `term' of the directory where most Emacs libraries are
kept.

  The usual purpose of the terminal-specific library is to define the
escape sequences used by the terminal's function keys using the library
`keypad.el'.  See the file
`term/vt100.el' for an example of how this is done.

  When the terminal type contains a hyphen, only the part of the name
before the first hyphen is significant in choosing the library name.
Thus, terminal types `aaa-48' and `aaa-30-rv' both use
the library `term/aaa'.  The code in the library can use
(getenv "TERM") to find the full terminal type name.

  The library's name is constructed by concatenating the value of the
variable term-file-prefix and the terminal type.  Your init
file can prevent the loading of the terminal-specific library by setting
term-file-prefix to nil.  See Init File.

  The value of the variable term-setup-hook, if not nil, is
called as a function of no arguments at the end of Emacs initialization,
after both your init file and any terminal-specific library have been
read.  See Init File.  You can set the value in the init file to
override part of any of the terminal-specific libraries and to define
initializations for terminals that do not have a library.

27.7 Changing the Bell Sound
============================

You can now change how the audible bell sounds using the variable
sound-alist.

sound-alist's value is an list associating symbols with, among
other things, strings of audio-data.  When ding is called with
one of the symbols, the associated sound data is played instead of the
standard beep.  This only works if you are logged in on the console of a
machine with audio hardware. To listen to a sound of the provided type,
call the function play-sound with the argument sound. You
can also set the volume of the sound with the optional argument 
volume.

Each element of sound-alist is a list describing a sound.
The first element of the list is the name of the sound being defined.
Subsequent elements of the list are alternating keyword/value pairs:

sound
A string of raw sound data, or the name of another sound to play.   
The symbol t here means use the default X beep.

volume
An integer from 0-100, defaulting to bell-volume.

pitch
If using the default X beep, the pitch (Hz) to generate.

duration
If using the default X beep, the duration (milliseconds).

For compatibility, elements of `sound-alist' may also be of the form:

( sound-name . <sound> )
( sound-name <volume> <sound> )

You should probably add things to this list by calling the function
load-sound-file.

Note that you can only play audio data if running on the console screen
of a machine with audio hardware which emacs understands, which at this
time means a Sun SparcStation, SGI, or HP9000s700.

Also note that the pitch, duration, and volume options are available
everywhere, but most X servers ignore the `pitch' option.

The variable bell-volume should be an integer from 0 to 100,
with 100 being loudest, which controls how loud the sounds emacs makes
should be.  Elements of the sound-alist may override this value.
This variable applies to the standard X bell sound as well as sound files.

If the symbol t is in place of a sound-string, Emacs uses the
default X beep.  This allows you to define beep-types of 
different volumes even when not running on the console.

You can add things to this list by calling the function
load-sound-file, which reads in an audio-file and adds its data to
the sound-alist. You can specify the sound with the sound-name
argument and the file into which the sounds are loaded with the
filename argument. The optional volume argument sets the
volume.

load-sound-file (filename sound-name &optional volume)

To load and install some sound files as beep-types, use the function
load-default-sounds (note that this only works if you are on
display 0 of a machine with audio hardware).

The following beep-types are used by Emacs itself. Other Lisp
packages may use other beep types, but these are the ones that the C
kernel of Emacs uses.

auto-save-error
An auto-save does not succeed

command-error
The Emacs command loop catches an error

undefined-key
You type a key that is undefined

undefined-click
You use an undefined mouse-click combination

no-completion
Completion was not possible

y-or-n-p
You type something other than the required y or n

yes-or-no-p
You type something other than yes or no

27.8 Faces
==========

XEmacs has objects called extents and faces.  An extent
is a region of text and a face is a collection of textual
attributes, such as fonts and colors.  Every extent is displayed in some
face; therefore, changing the properties of a face immediately updates the
display of all associated extents.  Faces can be frame-local: you can
have a region of text that displays with completely different
attributes when its buffer is viewed from a different X window.

The display attributes of faces may be specified either in Lisp or through
the X resource manager.

27.8.1 Customizing Faces
------------------------

You can change the face of an extent with the functions in
this section.  All the functions prompt for a face as an
argument; use completion for a list of possible values.

M-x invert-face
Swap the foreground and background colors of the given face.
M-x make-face-bold
Make the font of the given face bold.  When called from a
program, returns nil if this is not possible.
M-x make-face-bold-italic
Make the font of the given face bold italic.  
When called from a program, returns nil if not possible.
M-x make-face-italic
Make the font of the given face italic.  
When called from a program, returns nil if not possible.
M-x make-face-unbold
Make the font of the given face non-bold.  
When called from a program, returns nil if not possible.
M-x make-face-unitalic
Make the font of the given face non-italic.
When called from a program, returns nil if not possible.
M-x make-face-larger
Make the font of the given face a little larger.
When called from a program, returns nil if not possible.
M-x make-face-smaller
Make the font of the given face a little smaller.
When called from a program, returns nil if not possible.
M-x set-face-background
Change the background color of the given face.
M-x set-face-background-pixmap
Change the background pixmap of the given face.
M-x set-face-font
Change the font of the given face.
M-x set-face-foreground
Change the foreground color of the given face.
M-x set-face-underline-p
Change whether the given face is underlined.


You can exchange the foreground and background color of the selected
face with the function invert-face. If the face does not
specify both foreground and background, then its foreground and
background are set to the background and foreground of the default face.
When calling this from a program, you can supply the optional argument 
frame to specify which frame is affected; otherwise, all frames
are affected.

The work of make-face-bold, make-face-bold-italic,
make-face-italic, make-face-unbold,
make-face-unitalic functions is affected by
face-frob-from-locale-first variable.  If it is nil, those
functions first try to manipulate device specific data like X font names
to obtain the desired font face specification.  This may be unsuitable
in environments using different font face specifications for different
frames, non-Mule environments in particular.

If the variable is non-nil, those functions first try to figure
out whether the face font is the same as one of predefined faces:
default, bold, italic, bold-italic.  If it
is the same, then the new face font specification is set to be the same
as that of a corresponding predefined face.  Thus if the predefined face
is set up properly for different frames, the same will hold for the face
being changed by the functions.  This is the behavior one might desire
in non-Mule environments mentioned above: face being changed still looks
right in all frames.

How predefined faces might be set up for different frames in such an
environments is described in Face Resources.

You can set the background color of the specified face with the
function set-face-background.  The argument color should
be a string, the name of a color.  When called from a program, if the
optional frame argument is provided, the face is changed only 
in that frame; otherwise, it is changed in all frames.

You can set the background pixmap of the specified face with the
function set-face-background-pixmap.  The pixmap argument
name should be a string, the name of a file of pixmap data.  The
directories listed in the x-bitmap-file-path variable are
searched.  The bitmap may also be a list of the form (width
height data), where width and height are the size in
pixels, and data is a string containing the raw bits of the
bitmap.  If the optional frame argument is provided, the face is
changed only in that frame; otherwise, it is changed in all frames.

The variable x-bitmap-file-path takes as a value a list of the
directories in which X bitmap files may be found.  If the value is
nil, the list is initialized from the *bitmapFilePath
resource.

If the environment variable XBMLANGPATH is set, then it is consulted
before the x-bitmap-file-path variable.

You can set the font of the specified face with the function
set-face-font.  The font argument should be a string, the
name of a font.  When called from a program, if the
optional frame argument is provided, the face is changed only 
in that frame; otherwise, it is changed in all frames.

You can set the foreground color of the specified face with the
function set-face-foreground.  The argument color should be
a string, the name of a color.  If the optional frame argument is
provided, the face is changed only in that frame; otherwise, it is
changed in all frames.

You can set underline the specified face with the function
set-face-underline-p. The argument underline-p can be used
to make underlining an attribute of the face or not. If the optional
frame argument is provided, the face is changed only in that
frame; otherwise, it is changed in all frames.

27.9 Frame Components
=====================

You can control the presence and position of most frame components, such
as the menubar, toolbars, and gutters.

This section is not written yet.  Try the Lisp Reference Manual:
(lispref)Menubar, (lispref)Toolbar Intro, and
(lispref)Gutter Intro.

27.10 X Resources
=================

Historically, XEmacs has used the X resource application class `Emacs'
for its resources.  Unfortunately, GNU Emacs uses the same application
class, and resources are not compatible between the two Emacsen.  This
sharing of the application class often leads to trouble if you want to
run both variants.

Starting with XEmacs 21, XEmacs uses the class `XEmacs' if it finds
any XEmacs resources in the resource database when the X connection is
initialized.  Otherwise, it will use the class `Emacs' for
backwards compatibility.  The variable x-emacs-application-class
may be consulted to determine the application class being used.

The examples in this section assume the application class is `Emacs'.

The Emacs resources are generally set per-frame. Each Emacs frame can have 
its own name or the same name as another, depending on the name passed to the 
make-frame function.

You can specify resources for all frames with the syntax:

Emacs*parameter: value

or

Emacs*EmacsFrame.parameter:value

You can specify resources for a particular frame with the syntax:

Emacs*FRAME-NAME.parameter: value

* Geometry Resources::     Controlling the size and position of frames.
* Iconic Resources::       Controlling whether frames come up iconic.
* Resource List::          List of resources settable on a frame or device.
* Face Resources::         Controlling faces using resources.
* Widgets::                The widget hierarchy for XEmacs.
* Menubar Resources::      Specifying resources for the menubar.

27.10.1 Geometry Resources
--------------------------

To make the default size of all Emacs frames be 80 columns by 55 lines,
do this:

Emacs*EmacsFrame.geometry: 80x55

To set the geometry of a particular frame named `fred', do this:

Emacs*fred.geometry: 80x55

Important! Do not use the following syntax:

Emacs*geometry: 80x55

You should never use *geometry with any X application. It does
not say "make the geometry of Emacs be 80 columns by 55 lines."  It
really says, "make Emacs and all subwindows thereof be 80x55 in whatever
units they care to measure in."  In particular, that is both telling the
Emacs text pane to be 80x55 in characters, and telling the menubar pane
to be 80x55 pixels, which is surely not what you want.

As a special case, this geometry specification also works (and sets the
default size of all Emacs frames to 80 columns by 55 lines):

Emacs.geometry: 80x55

since that is the syntax used with most other applications (since most
other applications have only one top-level window, unlike Emacs).  In
general, however, the top-level shell (the unmapped ApplicationShell
widget named `Emacs' that is the parent of the shell widgets that
actually manage the individual frames) does not have any interesting
resources on it, and you should set the resources on the frames instead.

The -geometry command-line argument sets only the geometry of the
initial frame created by Emacs.

A more complete explanation of geometry-handling is

* The -geometry command-line option sets the Emacs.geometry
resource, that is, the geometry of the ApplicationShell.

* For the first frame created, the size of the frame is taken from the
ApplicationShell if it is specified, otherwise from the geometry of the
frame.

* For subsequent frames, the order is reversed: First the frame, and then
the ApplicationShell.

* For the first frame created, the position of the frame is taken from the
ApplicationShell (Emacs.geometry) if it is specified, otherwise
from the geometry of the frame.

* For subsequent frames, the position is taken only from the frame, and 
never from the ApplicationShell.

This is rather complicated, but it does seem to provide the most
intuitive behavior with respect to the default sizes and positions of
frames created in various ways.

27.10.2 Iconic Resources
------------------------

Analogous to -geometry, the -iconic command-line option
sets the iconic flag of the ApplicationShell (Emacs.iconic) and
always applies to the first frame created regardless of its name.
However, it is possible to set the iconic flag on particular frames (by
name) by using the Emacs*FRAME-NAME.iconic resource.

27.10.3 Resource List
---------------------

Emacs frames accept the following resources:

geometry (class Geometry): string
Initial geometry for the frame.  See Geometry Resources, for a
complete discussion of how this works.

iconic (class Iconic): boolean
Whether this frame should appear in the iconified state.

internalBorderWidth (class InternalBorderWidth): int
How many blank pixels to leave between the text and the edge of the 
window.

interline (class Interline): int
How many pixels to leave between each line (may not be implemented).

menubar (class Menubar): boolean
Whether newly-created frames should initially have a menubar.  Set to
true by default.

initiallyUnmapped (class InitiallyUnmapped): boolean
Whether XEmacs should leave the initial frame unmapped when it starts
up.  This is useful if you are starting XEmacs as a server (e.g. in
conjunction with gnuserv or the external client widget).  You can also
control this with the -unmapped command-line option.

barCursor (class BarColor): boolean
Whether the cursor should be displayed as a bar, or the traditional box.

cursorColor (class CursorColor): color-name
The color of the text cursor.

scrollBarWidth (class ScrollBarWidth): integer
How wide the vertical scrollbars should be, in pixels; 0 means no
vertical scrollbars.  You can also use a resource specification of the
form *scrollbar.width, or the usual toolkit scrollbar resources:
*XmScrollBar.width (Motif), *XlwScrollBar.width (Lucid),
or *Scrollbar.thickness (Athena).  We don't recommend that you
use the toolkit resources, though, because they're dependent on how
exactly your particular build of XEmacs was configured.

scrollBarHeight (class ScrollBarHeight): integer
How high the horizontal scrollbars should be, in pixels; 0 means no
horizontal scrollbars.  You can also use a resource specification of the
form *scrollbar.height, or the usual toolkit scrollbar resources:
*XmScrollBar.height (Motif), *XlwScrollBar.height (Lucid),
or *Scrollbar.thickness (Athena).  We don't recommend that you use
the toolkit resources, though, because they're dependent on how exactly
your particular build of XEmacs was configured.

scrollBarPlacement (class ScrollBarPlacement): string
Where the horizontal and vertical scrollbars should be positioned.  This
should be one of the four strings `BOTTOM_LEFT',
`BOTTOM_RIGHT', `TOP_LEFT', and `TOP_RIGHT'.  Default is
`BOTTOM_RIGHT' for the Motif and Lucid scrollbars and
`BOTTOM_LEFT' for the Athena scrollbars.

topToolBarHeight (class TopToolBarHeight): integer
bottomToolBarHeight (class BottomToolBarHeight): integer
leftToolBarWidth (class LeftToolBarWidth): integer
rightToolBarWidth (class RightToolBarWidth): integer
Height and width of the four possible toolbars.

topToolBarShadowColor (class TopToolBarShadowColor): color-name
bottomToolBarShadowColor (class BottomToolBarShadowColor): color-name
Color of the top and bottom shadows for the toolbars.  NOTE: These resources
do not have anything to do with the top and bottom toolbars (i.e. the
toolbars at the top and bottom of the frame)!  Rather, they affect the top
and bottom shadows around the edges of all four kinds of toolbars.

topToolBarShadowPixmap (class TopToolBarShadowPixmap): pixmap-name
bottomToolBarShadowPixmap (class BottomToolBarShadowPixmap): pixmap-name
Pixmap of the top and bottom shadows for the toolbars.  If set, these
resources override the corresponding color resources. NOTE: These
resources do not have anything to do with the top and bottom
toolbars (i.e. the toolbars at the top and bottom of the frame)!
Rather, they affect the top and bottom shadows around the edges of all
four kinds of toolbars.

toolBarShadowThickness (class ToolBarShadowThickness): integer
Thickness of the shadows around the toolbars, in pixels.

visualBell (class VisualBell): boolean
Whether XEmacs should flash the screen rather than making an audible beep.

bellVolume (class BellVolume): integer
Volume of the audible beep.

useBackingStore (class UseBackingStore): boolean
Whether XEmacs should set the backing-store attribute of the X windows
it creates.  This increases the memory usage of the X server but decreases
the amount of X traffic necessary to update the screen, and is useful
when the connection to the X server goes over a low-bandwidth line
such as a modem connection.

Emacs devices accept the following resources:

textPointer (class Cursor): cursor-name
The cursor to use when the mouse is over text.  This resource is used to
initialize the variable x-pointer-shape.

selectionPointer (class Cursor): cursor-name
The cursor to use when the mouse is over a selectable text region (an
extent with the `highlight' property; for example, an Info
cross-reference).  This resource is used to initialize the variable
x-selection-pointer-shape.

spacePointer (class Cursor): cursor-name
The cursor to use when the mouse is over a blank space in a buffer (that
is, after the end of a line or after the end-of-file).  This resource is
used to initialize the variable x-nontext-pointer-shape.

modeLinePointer (class Cursor): cursor-name
The cursor to use when the mouse is over a modeline.  This resource is
used to initialize the variable x-mode-pointer-shape.

gcPointer (class Cursor): cursor-name
The cursor to display when a garbage-collection is in progress.  This
resource is used to initialize the variable x-gc-pointer-shape.

scrollbarPointer (class Cursor): cursor-name
The cursor to use when the mouse is over the scrollbar.  This resource
is used to initialize the variable x-scrollbar-pointer-shape.

pointerColor (class Foreground): color-name
pointerBackground (class Background): color-name
The foreground and background colors of the mouse cursor.  These
resources are used to initialize the variables
x-pointer-foreground-color and x-pointer-background-color.

27.10.4 Face Resources
----------------------

The attributes of faces are also per-frame. They can be specified as:

Emacs.FACE_NAME.parameter: value

or

Emacs*FRAME_NAME.FACE_NAME.parameter: value

Faces accept the following resources:

attributeFont (class AttributeFont): font-name
The font of this face.

attributeForeground (class AttributeForeground): color-name
attributeBackground (class AttributeBackground): color-name
The foreground and background colors of this face.

attributeBackgroundPixmap (class AttributeBackgroundPixmap): file-name
The name of an XBM file (or XPM file, if your version of Emacs
supports XPM), to use as a background stipple.

attributeUnderline (class AttributeUnderline): boolean
Whether text in this face should be underlined.

All text is displayed in some face, defaulting to the face named
default.  To set the font of normal text, use
Emacs*default.attributeFont. To set it in the frame named
fred, use Emacs*fred.default.attributeFont.

These are the names of the predefined faces:

default
Everything inherits from this.

bold
If this is not specified in the resource database, Emacs tries to find a
bold version of the font of the default face.

italic
If this is not specified in the resource database, Emacs tries to find
an italic version of the font of the default face.

bold-italic
If this is not specified in the resource database, Emacs tries to find a
bold-italic version of the font of the default face.

modeline
This is the face that the modeline is displayed in.  If not specified in
the resource database, it is determined from the default face by
reversing the foreground and background colors.

highlight
This is the face that highlighted extents (for example, Info
cross-references and possible completions, when the mouse passes over
them) are displayed in.

left-margin
right-margin
These are the faces that the left and right annotation margins are
displayed in.

zmacs-region
This is the face that mouse selections are displayed in.
 
isearch
This is the face that the matched text being searched for is displayed
in.

info-node
This is the face of info menu items.  If unspecified, it is copied from
bold-italic.

info-xref
This is the face of info cross-references.  If unspecified, it is copied
from bold. (Note that, when the mouse passes over a
cross-reference, the cross-reference's face is determined from a
combination of the info-xref and highlight faces.)

Other packages might define their own faces; to see a list of all faces,
use any of the interactive face-manipulation commands such as
set-face-font and type `?' when you are prompted for the
name of a face.

If the bold, italic, and bold-italic faces are not
specified in the resource database, then XEmacs attempts to derive them
from the font of the default face.  It can only succeed at this if you
have specified the default font using the XLFD (X Logical Font
Description) format, which looks like

*-courier-medium-r-*-*-*-120-*-*-*-*-*-*

If you use any of the other, less strict font name formats, some of which
look like

lucidasanstypewriter-12
fixed
9x13

then XEmacs won't be able to guess the names of the bold and italic
versions.  All X fonts can be referred to via XLFD-style names, so you
should use those forms.  See the man pages for `X(1)',
`xlsfonts(1)', and `xfontsel(1)'.

27.10.5 Widgets
---------------

There are several structural widgets between the terminal EmacsFrame
widget and the top level ApplicationShell; the exact names and types of
these widgets change from release to release (for example, they changed
between 19.8 and 19.9, 19.9 and 19.10, and 19.10 and 19.12) and are
subject to further change in the future, so you should avoid mentioning
them in your resource database.  The above-mentioned syntaxes should be
forward- compatible.  As of 19.13, the exact widget hierarchy is as
follows:

INVOCATION-NAME            "shell"       "container"     FRAME-NAME
x-emacs-application-class  "EmacsShell"  "EmacsManager"  "EmacsFrame"

where INVOCATION-NAME is the terminal component of the name of the
XEmacs executable (usually `xemacs'), and
`x-emacs-application-class' is generally `Emacs'.

27.10.6 Menubar Resources
-------------------------

As the menubar is implemented as a widget which is not a part of XEmacs
proper, it does not use the face mechanism for specifying fonts and
colors: It uses whatever resources are appropriate to the type of widget
which is used to implement it.

If Emacs was compiled to use only the Lucid Motif-lookalike menu widgets,
then one way to specify the font of the menubar would be

Emacs*menubar*font: *-courier-medium-r-*-*-*-120-*-*-*-*-*-*

If both the Lucid Motif-lookalike menu widgets and X Font Sets are 
configured to allow multilingual menubars, then one uses

*menubar*FontSet:       -*-helvetica-bold-r-*-*-*-120-*-*-*-*-iso8859-*, \
                        -*-*-*-*-*-*-*-120-*-jisx0208.1983-0

That would specify fonts for a Japanese menubar.  Specifying only one
XLFD is acceptable; specifying more than one for a given registry
(language) is also allowed.  When X Font Sets are configured, some .font
resources (eg, menubars) are ignored in favor of the corresponding
.fontSet resources.

If the Motif library is being used, then one would have to use 

Emacs*menubar*fontList: *-courier-medium-r-*-*-*-120-*-*-*-*-*-*

because the Motif library uses the fontList resource name instead
of font, which has subtly different semantics.

The same is true of the scrollbars: They accept whichever resources are 
appropriate for the toolkit in use.


27.11 Quitting and Aborting
===========================

C-g
Quit.  Cancel running or partially typed command.
C-]
Abort innermost recursive editing level and cancel the command which
invoked it (abort-recursive-edit).
M-x top-level
Abort all recursive editing levels that are currently executing.
C-x u
Cancel an already-executed command, usually (undo).

  There are two ways of cancelling commands which are not finished
executing: quitting with C-g, and aborting with C-]
or M-x top-level.  Quitting is cancelling a partially typed command
or one which is already running.  Aborting is getting out of a recursive
editing level and cancelling the command that invoked the recursive edit.

  Quitting with C-g is used for getting rid of a partially typed
command or a numeric argument that you don't want.  It also stops a
running command in the middle in a relatively safe way, so you can use
it if you accidentally start executing a command that takes a long
time.  In particular, it is safe to quit out of killing; either your
text will all still be there, or it will all be in the kill
ring (or maybe both).  Quitting an incremental search does special
things documented under searching; in general, it may take two
successive C-g characters to get out of a search.  C-g works
by setting the variable quit-flag to t the instant
C-g is typed; Emacs Lisp checks this variable frequently and quits
if it is non-nil.  C-g is only actually executed as a
command if it is typed while Emacs is waiting for input.

If you quit twice in a row before the first C-g is recognized, you
activate the "emergency escape" feature and return to the shell.
See Emergency Escape.

  You can use C-] (abort-recursive-edit) to get out
of a recursive editing level and cancel the command which invoked it.
Quitting with C-g does not do this, and could not do this because it
is used to cancel a partially typed command within the recursive
editing level.  Both operations are useful.  For example, if you are in the
Emacs debugger (see Lisp Debug) and have typed C-u 8 to enter a
numeric argument, you can cancel that argument with C-g and remain in
the debugger.

  The command M-x top-level is equivalent to "enough" C-]
commands to get you out of all the levels of recursive edits that you are
in.  C-] only gets you out one level at a time, but M-x top-level
goes out all levels at once.  Both C-] and M-x top-level are
like all other commands and unlike C-g in that they are effective
only when Emacs is ready for a command.  C-] is an ordinary key and
has its meaning only because of its binding in the keymap.
See Recursive Edit.

  C-x u (undo) is not strictly speaking a way of cancelling a
command, but you can think of it as cancelling a command already finished
executing.  See Undo.

27.12 Dealing With Emacs Trouble
================================

  This section describes various conditions in which Emacs fails to work,
and how to recognize them and correct them.

* Stuck Recursive::    `[...]' in mode line around the parentheses.
* Screen Garbled::     Garbage on the screen.
* Text Garbled::       Garbage in the text.
* Unasked-for Search:: Spontaneous entry to incremental search.
* Emergency Escape::   Emergency escape--
                        What to do if Emacs stops responding.
* Total Frustration::  When you are at your wits' end.

27.12.1 Recursive Editing Levels
--------------------------------

  Recursive editing levels are important and useful features of Emacs, but
they can seem like malfunctions to the user who does not understand them.

  If the mode line has square brackets `[...]' around the parentheses
that contain the names of the major and minor modes, you have entered a
recursive editing level.  If you did not do this on purpose, or if you
don't understand what that means, you should just get out of the recursive
editing level.  To do so, type M-x top-level.  This is called getting
back to top level.  See Recursive Edit.

27.12.2 Garbage on the Screen
-----------------------------

  If the data on the screen looks wrong, the first thing to do is see
whether the text is actually wrong.  Type C-l, to redisplay the
entire screen.  If the text appears correct after this, the problem was
entirely in the previous screen update.

  Display updating problems often result from an incorrect termcap entry
for the terminal you are using.  The file `etc/TERMS' in the Emacs
distribution gives the fixes for known problems of this sort.
`INSTALL' contains general advice for these problems in one of its
sections.  Very likely there is simply insufficient padding for certain
display operations.  To investigate the possibility that you have this
sort of problem, try Emacs on another terminal made by a different
manufacturer.  If problems happen frequently on one kind of terminal but
not another kind, the real problem is likely to be a bad termcap entry,
though it could also be due to a bug in Emacs that appears for terminals
that have or lack specific features.

27.12.3 Garbage in the Text
---------------------------

  If C-l shows that the text is wrong, try undoing the changes to it
using C-x u until it gets back to a state you consider correct.  Also
try C-h l to find out what command you typed to produce the observed
results.

  If a large portion of text appears to be missing at the beginning or
end of the buffer, check for the word `Narrow' in the mode line.
If it appears, the text is still present, but marked off-limits.
To make it visible again, type C-x n w.  See Narrowing.

27.12.4 Spontaneous Entry to Incremental Search
-----------------------------------------------

  If Emacs spontaneously displays `I-search:' at the bottom of the
screen, it means that the terminal is sending C-s and C-q
according to the poorly designed xon/xoff "flow control" protocol.  You
should try to prevent this by putting the terminal in a mode where it will
not use flow control, or by giving it enough padding that it will never send a
C-s.  If that cannot be done, you must tell Emacs to expect flow
control to be used, until you can get a properly designed terminal.

  Information on how to do these things can be found in the file
`INSTALL' in the Emacs distribution.

27.12.5 Emergency Escape
------------------------

  Because at times there have been bugs causing Emacs to loop without
checking quit-flag, a special feature causes Emacs to be suspended
immediately if you type a second C-g while the flag is already set,
so you can always get out of XEmacs.  Normally Emacs recognizes and
clears quit-flag (and quits!) quickly enough to prevent this from
happening.

  When you resume Emacs after a suspension caused by multiple C-g, it
asks two questions before going back to what it had been doing:

Auto-save? (y or n)
Abort (and dump core)? (y or n)

Answer each one with y or n followed by <RET>.

  Saying y to `Auto-save?' causes immediate auto-saving of all
modified buffers in which auto-saving is enabled.

  Saying y to `Abort (and dump core)?' causes an illegal
instruction to be executed, dumping core.  This is to enable a wizard to
figure out why Emacs was failing to quit in the first place.  Execution
does not continue after a core dump.  If you answer n, execution
does continue.  With luck, Emacs will ultimately check
quit-flag and quit normally.  If not, and you type another
C-g, it is suspended again.

  If Emacs is not really hung, but is just being slow, you may invoke
the double C-g feature without really meaning to.  In that case,
simply resume and answer n to both questions, and you will arrive
at your former state.  Presumably the quit you requested will happen
soon.

  The double-C-g feature may be turned off when Emacs is running under
a window system, since the window system always enables you to kill Emacs
or to create another window and run another program.

27.12.6 Help for Total Frustration
----------------------------------

  If using Emacs (or something else) becomes terribly frustrating and none
of the techniques described above solve the problem, Emacs can still help
you.

  First, if the Emacs you are using is not responding to commands, type
C-g C-g to get out of it and then start a new one.

  Second, type M-x doctor <RET>.

  The doctor will make you feel better.  Each time you say something to
the doctor, you must end it by typing <RET> <RET>.  This lets the
doctor know you are finished.

27.13 Reporting Bugs
====================

  Sometimes you will encounter a bug in Emacs.  Although we cannot promise
we can or will fix the bug, and we might not even agree that it is a bug,
we want to hear about bugs you encounter in case we do want to fix them.

  To make it possible for us to fix a bug, you must report it.  In order
to do so effectively, you must know when and how to do it.

27.13.1 When Is There a Bug
---------------------------

  If Emacs executes an illegal instruction, or dies with an operating
system error message that indicates a problem in the program (as opposed to
something like "disk full"), then it is certainly a bug.

  If Emacs updates the display in a way that does not correspond to what is
in the buffer, then it is certainly a bug.  If a command seems to do the
wrong thing but the problem corrects itself if you type C-l, it is a
case of incorrect display updating.

  Taking forever to complete a command can be a bug, but you must make
certain that it was really Emacs's fault.  Some commands simply take a long
time.  Type C-g and then C-h l to see whether the input Emacs
received was what you intended to type; if the input was such that you
know it should have been processed quickly, report a bug.  If you
don't know whether the command should take a long time, find out by looking
in the manual or by asking for assistance.

  If a command you are familiar with causes an Emacs error message in a
case where its usual definition ought to be reasonable, it is probably a
bug.

  If a command does the wrong thing, that is a bug.  But be sure you know
for certain what it ought to have done.  If you aren't familiar with the
command, or don't know for certain how the command is supposed to work,
then it might actually be working right.  Rather than jumping to
conclusions, show the problem to someone who knows for certain.

  Finally, a command's intended definition may not be best for editing
with.  This is a very important sort of problem, but it is also a matter of
judgment.  Also, it is easy to come to such a conclusion out of ignorance
of some of the existing features.  It is probably best not to complain
about such a problem until you have checked the documentation in the usual
ways, feel confident that you understand it, and know for certain that what
you want is not available.  If you are not sure what the command is
supposed to do after a careful reading of the manual, check the index and
glossary for any terms that may be unclear.  If you still do not
understand, this indicates a bug in the manual.  The manual's job is to
make everything clear.  It is just as important to report documentation
bugs as program bugs.

  If the online documentation string of a function or variable disagrees
with the manual, one of them must be wrong, so report the bug.

27.13.2 How to Report a Bug
---------------------------

  When you decide that there is a bug, it is important to report it and to
report it in a way which is useful.  What is most useful is an exact
description of what commands you type, starting with the shell command to
run Emacs, until the problem happens.  Always include the version number
of Emacs that you are using; type M-x emacs-version to print this.

  The most important principle in reporting a bug is to report facts,
not hypotheses or categorizations.  It is always easier to report the facts,
but people seem to prefer to strain to posit explanations and report
them instead.  If the explanations are based on guesses about how Emacs is
implemented, they will be useless; we will have to try to figure out what
the facts must have been to lead to such speculations.  Sometimes this is
impossible.  But in any case, it is unnecessary work for us.

  For example, suppose that you type C-x C-f /glorp/baz.ugh
<RET>, visiting a file which (you know) happens to be rather large,
and Emacs prints out `I feel pretty today'.  The best way to report
the bug is with a sentence like the preceding one, because it gives all the
facts and nothing but the facts.

  Do not assume that the problem is due to the size of the file and say,
"When I visit a large file, Emacs prints out `I feel pretty today'."
This is what we mean by "guessing explanations".  The problem is just as
likely to be due to the fact that there is a `z' in the file name.  If
this is so, then when we got your report, we would try out the problem with
some "large file", probably with no `z' in its name, and not find
anything wrong.  There is no way in the world that we could guess that we
should try visiting a file with a `z' in its name.

  Alternatively, the problem might be due to the fact that the file starts
with exactly 25 spaces.  For this reason, you should make sure that you
inform us of the exact contents of any file that is needed to reproduce the
bug.  What if the problem only occurs when you have typed the C-x a l
command previously?  This is why we ask you to give the exact sequence of
characters you typed since starting to use Emacs.

  You should not even say "visit a file" instead of C-x C-f unless
you know that it makes no difference which visiting command is used.
Similarly, rather than saying "if I have three characters on the line,"
say "after I type <RET> A B C <RET> C-p," if that is
the way you entered the text.

  If you are not in Fundamental mode when the problem occurs, you should
say what mode you are in.

  If the manifestation of the bug is an Emacs error message, it is
important to report not just the text of the error message but a backtrace
showing how the Lisp program in Emacs arrived at the error.  To make the
backtrace, you must execute the Lisp expression 
(setq debug-on-error t) before the error happens (that is to
say, you must execute that expression and then make the bug happen).  This
causes the Lisp debugger to run (see Lisp Debug).  The debugger's
backtrace can be copied as text into the bug report.  This use of the
debugger is possible only if you know how to make the bug happen again.  Do
note the error message the first time the bug happens, so if you can't make
it happen again, you can report at least that.

  Check whether any programs you have loaded into the Lisp world, including
your init file, set any variables that may affect the functioning of
Emacs.  See Init File.  Also, see whether the problem happens in a
freshly started Emacs without loading your init file (start Emacs with
the -q switch to prevent loading the init file).  If the problem
does not occur then, it is essential that we know the contents of
any programs that you must load into the Lisp world in order to cause
the problem to occur.

  If the problem does depend on an init file or other Lisp programs that
are not part of the standard Emacs system, then you should make sure it is
not a bug in those programs by complaining to their maintainers first.
After they verify that they are using Emacs in a way that is supposed to
work, they should report the bug.

  If you can tell us a way to cause the problem without visiting any files,
please do so.  This makes it much easier to debug.  If you do need files,
make sure you arrange for us to see their exact contents.  For example, it
can often matter whether there are spaces at the ends of lines, or a
newline after the last line in the buffer (nothing ought to care whether
the last line is terminated, but tell that to the bugs).

  The easy way to record the input to Emacs precisely is to write a
dribble file; execute the Lisp expression:

(open-dribble-file "~/dribble")

using Meta-<ESC> or from the `*scratch*' buffer just after starting
Emacs.  From then on, all Emacs input will be written in the specified
dribble file until the Emacs process is killed.

  For possible display bugs, it is important to report the terminal type
(the value of environment variable TERM), the complete termcap entry
for the terminal from `/etc/termcap' (since that file is not identical
on all machines), and the output that Emacs actually sent to the terminal.
The way to collect this output is to execute the Lisp expression:

(open-termscript "~/termscript")

using Meta-<ESC> or from the `*scratch*' buffer
just after starting Emacs.  From then on, all output from Emacs to the
terminal will be written in the specified termscript file as well, until
the Emacs process is killed.  If the problem happens when Emacs starts
up, put this expression into your init file so that the termscript file
will be open when Emacs displays the screen for the first time.
See Init File. Be warned: it is often difficult, and sometimes
impossible, to fix a terminal-dependent bug without access to a terminal
of the type that stimulates the bug.

The newsgroup `comp.emacs.xemacs' may be used for bug reports,
other discussions and requests for assistance.  

If you don't have access to this newgroup, you can subscribe to the
mailing list version: the newsgroup is bidirectionally gatewayed into
the mailing list `xemacs@xemacs.org'.

To be added or removed from this mailing list, send mail to
`xemacs-request@xemacs.org'.  Do not send requests for addition
to the mailing list itself.

The mailing lists and newsgroups are archived on our anonymous FTP server,
`ftp.xemacs.org', and at various other archive sites around the net. You 
should also check the `FAQ' in `/pub/xemacs' on our anonymous 
FTP server. It provides some introductory information and help for initial 
configuration problems.



