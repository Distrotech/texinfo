@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/homolog_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/homolog_lib.doc INSTEAD
@c library version: (1.15.2.2,2002/10/07)
@c library file: ../Singular/LIB/homolog.lib
@cindex homolog.lib
@cindex homolog_lib
@table @asis
@item @strong{Library:}
homolog.lib
@item @strong{Purpose:}
   Procedures for Homological Algebra
@item @strong{Authors:}
Gert-Martin Greuel, greuel@@mathematik.uni-kl.de,
@* Bernd Martin, martin@@math.tu-cottbus.de
@* Christoph Lossen, lossen@@mathematik.uni-kl.de

@end table

@strong{Procedures:}
@menu
* cup:: cup: Ext^1(M',M') x Ext^1() --> Ext^2()
* cupproduct:: cup: Ext^p(M',N') x Ext^q(N',P') --> Ext^p+q(M',P')
* depth:: depth(I,M'), I ideal, M module, M'=coker(M)
* Ext_R:: Ext^k(M',R), M module, R basering, M'=coker(M)
* Ext:: Ext^k(M',N'), M,N modules, M'=coker(M), N'=coker(N)
* fitting:: n-th Fitting ideal of M'=coker(M), M module, n int
* flatteningStrat:: Flattening stratification of M'=coker(M), M module
* Hom:: Hom(M',N'), M,N modules, M'=coker(M), N'=coker(N)
* homology:: ker(B)/im(A), homology of complex R^k--A->M'--B->N'
* isCM:: test if coker(M) is Cohen-Macaulay, M module
* isFlat:: test if coker(M) is flat, M module
* isLocallyFree:: test if coker(M) is locally free of constant rank r
* isReg:: test if I is coker(M)-sequence, I ideal, M module
* kernel:: ker(M'--A->N') M,N modules, A matrix
* kohom:: Hom(R^k,A), A matrix over basering R
* kontrahom:: Hom(A,R^k), A matrix over basering R
* KoszulHomology:: n-th Koszul homology H_n(I,coker(M)), I=ideal
* tensorMod:: Tensor product of modules M'=coker(M), N'=coker(N)
* Tor:: Tor_k(M',N'), M,N modules, M'=coker(M), N'=coker(N)
@end menu
@c ---end content LibInfo---

@c ------------------- cup -------------
@node cup, cupproduct,, homolog_lib
@subsubsection cup
@cindex cup
@c ---content cup---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
cup(M,[,any,any]); M=module

@item @strong{Compute:}
cup-product Ext^1(M',M') x Ext^1(M',M') ---> Ext^2(M',M'), where
M':=R^m/M, if M in R^m, R basering (i.e. M':=coker(matrix(M))).
@* If called with >= 2 arguments: compute symmetrized cup-product

@item @strong{Assume:}
all Ext's are finite dimensional

@item @strong{Return:}
- if called with 1 argument: matrix, the columns of the output present
the coordinates of b_i&b_j with respect to a kbase of Ext^2, where
b_1,b_2,... is a kbase of Ext^1 and & denotes cup product;@*
- if called with 2 arguments: matrix, the columns of the output
present the coordinates of (1/2)(b_i&b_j + b_j&b_i) with respect to
a kbase of Ext^2;
@*- if called with 3 arguments: list,
@format
      L[1] = matrix see above (symmetric case, for >=2 arguments)
      L[2] = matrix of kbase of Ext^1
      L[3] = matrix of kbase of Ext^2
@end format

@item @strong{Note:}
printlevel >=1; shows what is going on.
@*printlevel >=2; shows result in another representation.
@* For computing cupproduct of M itself, apply proc to syz(M)!

@end table
@strong{Example:}
@smallexample
@c computed example cup d2t_singular/homolog_lib.doc:83 
LIB "homolog.lib";
int p      = printlevel;
ring  rr   = 32003,(x,y,z),(dp,C);
ideal  I   = x4+y3+z2;
qring  o   = std(I);
module M   = [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
print(cup(M));
@expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
print(cup(M,1));
@expansion{} 0,1,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,0,0,0,0,0,0,0,
@expansion{} 0,0,0,0,1,0,0,0,0,0,0 
// 2nd EXAMPLE  (shows what is going on)
printlevel = 3;
ring   r   = 0,(x,y),(dp,C);
ideal  i   = x2-y3;
qring  q   = std(i);
module M   = [-x,y],[-y2,x];
print(cup(M));
@expansion{} // vdim (Ext^1) = 2
@expansion{} // kbase of Ext^1(M,M)
@expansion{} //  - the columns present the kbase elements in Hom(F(1),F(0))
@expansion{} //  - F(*) a free resolution of M
@expansion{} -1,0,
@expansion{} 0, y,
@expansion{} 0, 1,
@expansion{} -1,0 
@expansion{} // lift kbase of Ext^1:
@expansion{} //  - the columns present liftings of kbase elements into Hom(F(2),F(1))
@expansion{} //  - F(*) a free resolution of M 
@expansion{} 1,0,
@expansion{} 0,y,
@expansion{} 0,1,
@expansion{} 1,0 
@expansion{} // vdim (Ext^2) = 2
@expansion{} // kbase of Ext^2(M,M)
@expansion{} //  - the columns present the kbase elements in Hom(F(2),F(0))
@expansion{} //  - F(*) is a a free resolution of M 
@expansion{} -1,0,
@expansion{} 0, y,
@expansion{} 0, 1,
@expansion{} -1,0 
@expansion{} // matrix of cup-products (in Ext^2)
@expansion{} 0,-1,0, 0,y,
@expansion{} 0,0, -y,y,0,
@expansion{} 0,0, -1,1,0,
@expansion{} 0,-1,0, 0,y 
@expansion{} ////// end level 2 //////
@expansion{} // the associated matrices of the bilinear mapping 'cup' 
@expansion{} // corresponding to the kbase elements of Ext^2(M,M) are shown,
@expansion{} //  i.e. the rows of the final matrix are written as matrix of
@expansion{} //  a bilinear form on Ext^1 x Ext^1
@expansion{} //-----component 1:
@expansion{} 0,1,
@expansion{} 0,0 
@expansion{} //-----component 2:
@expansion{} 0, 0,
@expansion{} -1,1 
@expansion{} ////// end level 3 //////
@expansion{} 0,1,0, 0,0,
@expansion{} 0,0,-1,1,0 
printlevel = p;
@c end example cup d2t_singular/homolog_lib.doc:83
@end smallexample
@c ---end content cup---

@c ------------------- cupproduct -------------
@node cupproduct, depth, cup, homolog_lib
@subsubsection cupproduct
@cindex cupproduct
@c ---content cupproduct---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
cupproduct(M,N,P,p,q[,any]); M,N,P modules, p,q integers

@item @strong{Compute:}
cup-product Ext^p(M',N') x Ext^q(N',P') ---> Ext^p+q(M',P'),
where M':=R^m/M, if M in R^m, R basering (i.e. M':=coker(matrix(M)))

@item @strong{Assume:}
all Ext's are of finite dimension

@item @strong{Return:}
- if called with 5 arguments: matrix of the associated linear map
Ext^p (tensor) Ext^q --> Ext^p+q, i.e. the columns of <matrix>
present the coordinates of the cup products (b_i & c_j) with respect
to a kbase of Ext^p+q (b_i resp. c_j are the choosen bases of Ext^p,
resp. Ext^q).@*
- if called with 6 arguments: list L,
@format
      L[1] = matrix (see above)
      L[2] = matrix of kbase of Ext^p(M',N')
      L[3] = matrix of kbase of Ext^q(N',P')
      L[4] = matrix of kbase of Ext^p+q(N',P')
@end format

@item @strong{Note:}
printlevel >=1; shows what is going on.
@*printlevel >=2; shows the result in another representation.@*
For computing the cupproduct of M,N itself, apply proc to syz(M),
syz(N)!

@end table
@strong{Example:}
@smallexample
@c computed example cupproduct d2t_singular/homolog_lib.doc:145 
LIB "homolog.lib";
int p      = printlevel;
ring  rr   = 32003,(x,y,z),(dp,C);
ideal  I   = x4+y3+z2;
qring  o   = std(I);
module M   = [x,y,0,z],[y2,-x3,z,0],[z,0,-y,-x3],[0,z,x,-y2];
print(cupproduct(M,M,M,1,3));
@expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
printlevel = 3;
list l     = (cupproduct(M,M,M,1,3,"any"));
@expansion{} // vdim Ext(M,N) = 4
@expansion{} // kbase of Ext^p(M,N)
@expansion{} //  - the columns present the kbase elements in Hom(F(p),G(0))
@expansion{} //  - F(*),G(*) are free resolutions of M and N
@expansion{} 0, 0, 1, 0,  
@expansion{} 0, y, 0, 0,  
@expansion{} 1, 0, 0, 0,  
@expansion{} 0, 0, 0, y,  
@expansion{} 0, -1,0, 0,  
@expansion{} 0, 0, x2,0,  
@expansion{} 0, 0, 0, -x2,
@expansion{} 1, 0, 0, 0,  
@expansion{} 0, 0, 0, -1, 
@expansion{} -1,0, 0, 0,  
@expansion{} 0, 1, 0, 0,  
@expansion{} 0, 0, 1, 0,  
@expansion{} -1,0, 0, 0,  
@expansion{} 0, 0, 0, x2y,
@expansion{} 0, 0, x2,0,  
@expansion{} 0, -y,0, 0   
@expansion{} // vdim Ext(N,P) = 4
@expansion{} // kbase of Ext(N,P):
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 0, 0,  y,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, -1,0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, 0, 0,  -x2,
@expansion{} 0, 0, -x2,0,  
@expansion{} 0, 0, 0,  -1, 
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 1, 0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} -1,0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, 0, x2, 0,  
@expansion{} 0, 0, 0,  -x2y
@expansion{} // kbase of Ext^q(N,P)
@expansion{} //  - the columns present the kbase elements in Hom(G(q),H(0))
@expansion{} //  - G(*),H(*) are free resolutions of N and P
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 0, 0,  y,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, -1,0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, 0, 0,  -x2,
@expansion{} 0, 0, -x2,0,  
@expansion{} 0, 0, 0,  -1, 
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 1, 0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} -1,0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, 0, x2, 0,  
@expansion{} 0, 0, 0,  -x2y
@expansion{} // vdim Ext(M,P) = 4
@expansion{} // kbase of Ext^p+q(M,P)
@expansion{} //  - the columns present the kbase elements in Hom(F(p+q),H(0))
@expansion{} //  - F(*),H(*) are free resolutions of M and P
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 0, 0,  y,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, -1,0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} 0, 0, 0,  -x2,
@expansion{} 0, 0, -x2,0,  
@expansion{} 0, 0, 0,  -1, 
@expansion{} 0, 0, 1,  0,  
@expansion{} 0, 1, 0,  0,  
@expansion{} 1, 0, 0,  0,  
@expansion{} -1,0, 0,  0,  
@expansion{} 0, -y,0,  0,  
@expansion{} 0, 0, x2, 0,  
@expansion{} 0, 0, 0,  -x2y
@expansion{} // lifting of kbase of Ext^p(M,N)
@expansion{} //  - the columns present liftings of kbase elements in Hom(F(p+q),G(q))
@expansion{} 1,0, 0, 0,  
@expansion{} 0,-y,0, 0,  
@expansion{} 0,0, x2,0,  
@expansion{} 0,0, 0, x2y,
@expansion{} 0,1, 0, 0,  
@expansion{} 1,0, 0, 0,  
@expansion{} 0,0, 0, -x2,
@expansion{} 0,0, x2,0,  
@expansion{} 0,0, -1,0,  
@expansion{} 0,0, 0, y,  
@expansion{} 1,0, 0, 0,  
@expansion{} 0,y, 0, 0,  
@expansion{} 0,0, 0, -1, 
@expansion{} 0,0, -1,0,  
@expansion{} 0,-1,0, 0,  
@expansion{} 1,0, 0, 0   
@expansion{} // matrix of cup-products (in Ext^p+q)
@expansion{} 0,0, 0, -1, 0,   0, 0, 0,   y,   1,  0,  0,  0,  0,   y,   0,  0,   
@expansion{} 0,0, 0, 0,  y,   0, 0, y,   0,   0,  -y, 0,  0,  y,   0,   0,  0,   
@expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
@expansion{} 0,0, y, 0,  0,   -y,0, 0,   0,   0,  0,  0,  x2y,0,   0,   x2y,0,   
@expansion{} 0,0, 1, 0,  0,   -1,0, 0,   0,   0,  0,  0,  x2, 0,   0,   x2, 0,   
@expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
@expansion{} 0,0, 0, 0,  -x2, 0, 0, -x2, 0,   0,  x2, 0,  0,  -x2, 0,   0,  0,   
@expansion{} 0,0, 0, x2, 0,   0, 0, 0,   -x2y,-x2,0,  0,  0,  0,   -x2y,0,  0,   
@expansion{} 0,0, 0, 0,  -1,  0, 0, -1,  0,   0,  1,  0,  0,  -1,  0,   0,  0,   
@expansion{} 0,0, 0, -1, 0,   0, 0, 0,   y,   1,  0,  0,  0,  0,   y,   0,  0,   
@expansion{} 0,0, -1,0,  0,   1, 0, 0,   0,   0,  0,  0,  -x2,0,   0,   -x2,0,   
@expansion{} 0,1, 0, 0,  0,   0, y, 0,   0,   0,  0,  x2, 0,  0,   0,   0,  -x2y,
@expansion{} 0,-1,0, 0,  0,   0, -y,0,   0,   0,  0,  -x2,0,  0,   0,   0,  x2y, 
@expansion{} 0,0, y, 0,  0,   -y,0, 0,   0,   0,  0,  0,  x2y,0,   0,   x2y,0,   
@expansion{} 0,0, 0, -x2,0,   0, 0, 0,   x2y, x2, 0,  0,  0,  0,   x2y, 0,  0,   
@expansion{} 0,0, 0, 0,  -x2y,0, 0, -x2y,0,   0,  x2y,0,  0,  -x2y,0,   0,  0    
@expansion{} ////// end level 2 //////
@expansion{} // the associated matrices of the bilinear mapping 'cup' 
@expansion{} // corresponding to the kbase elements of Ext^p+q(M,P) are shown,
@expansion{} //  i.e. the rows of the final matrix are written as matrix of
@expansion{} //  a bilinear form on Ext^p x Ext^q
@expansion{} //----component 1:
@expansion{} 0,1,0,0,
@expansion{} 0,0,0,0,
@expansion{} 0,0,0,0,
@expansion{} 0,0,0,0 
@expansion{} //----component 2:
@expansion{} 0,0,-1,0,
@expansion{} 0,1,0, 0,
@expansion{} 0,0,0, 0,
@expansion{} 0,0,0, 0 
@expansion{} //----component 3:
@expansion{} 0,0,0,-1,
@expansion{} 0,0,0,0, 
@expansion{} 0,1,0,0, 
@expansion{} 0,0,0,0  
@expansion{} //----component 4:
@expansion{} 0,0,0, 0,
@expansion{} 1,0,0, 1,
@expansion{} 0,0,-1,0,
@expansion{} 0,1,0, 0 
@expansion{} ////// end level 3 //////
show(l[1]);show(l[2]);
@expansion{} // matrix, 4x17
@expansion{} 0,1,0, 0, 0,0,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,-1,0, 0,1,0,0,0,0,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, -1,0,0,0,0,0,1,0, 0,0,0,0,0,0,
@expansion{} 0,0,0, 0, 1,0,0,1,0,0,-1,0,0,1,0,0,0 
@expansion{} // matrix, 16x4
@expansion{} 0, 0, 1, 0,  
@expansion{} 0, y, 0, 0,  
@expansion{} 1, 0, 0, 0,  
@expansion{} 0, 0, 0, y,  
@expansion{} 0, -1,0, 0,  
@expansion{} 0, 0, x2,0,  
@expansion{} 0, 0, 0, -x2,
@expansion{} 1, 0, 0, 0,  
@expansion{} 0, 0, 0, -1, 
@expansion{} -1,0, 0, 0,  
@expansion{} 0, 1, 0, 0,  
@expansion{} 0, 0, 1, 0,  
@expansion{} -1,0, 0, 0,  
@expansion{} 0, 0, 0, x2y,
@expansion{} 0, 0, x2,0,  
@expansion{} 0, -y,0, 0   
printlevel = p;
@c end example cupproduct d2t_singular/homolog_lib.doc:145
@end smallexample
@c ---end content cupproduct---

@c ------------------- depth -------------
@node depth, Ext_R, cupproduct, homolog_lib
@subsubsection depth
@cindex depth
@c ---content depth---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
depth(M,[I]); M module, I ideal

@item @strong{Return:}
int,
@*- if called with 1 argument: the depth of M'=coker(M) w.r.t. the
maxideal in the basering (which is then assumed to be local)@*
- if called with 2 arguments: the depth of M'=coker(M) w.r.t. the
ideal I.

@item @strong{Note:}
procedure makes use of KoszulHomology.

@end table
@strong{Example:}
@smallexample
@c computed example depth d2t_singular/homolog_lib.doc:185 
LIB "homolog.lib";
ring R=0,(x,y,z),dp;
ideal I=x2,xy,yz;
module M=0;
depth(M,I);   // depth(<x2,xy,yz>,Q[x,y,z])
@expansion{} 2
ring r=0,(x,y,z),ds;  // local ring
matrix M[2][2]=x,xy,1+yz,0;
print(M);
@expansion{} x,   xy,
@expansion{} 1+yz,0  
depth(M);     // depth(maxideal,coker(M))
@expansion{} 2
ideal I=x;
depth(M,I);   // depth(<x>,coker(M))
@expansion{} 0
I=x+z;
depth(M,I);   // depth(<x+z>,coker(M))
@expansion{} 1
@c end example depth d2t_singular/homolog_lib.doc:185
@end smallexample
@c ---end content depth---

@c ------------------- Ext_R -------------
@node Ext_R, Ext, depth, homolog_lib
@subsubsection Ext_R
@cindex Ext_R
@c ---content Ext_R---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
Ext_R(v,M[,p]); v int resp. intvec , M module, p int

@item @strong{Compute:}
A presentation of Ext^k(M',R); for k=v[1],v[2],..., M'=coker(M).
Let
@smallexample
  0 <-- M' <-- F0 <-M-- F1 <-- F2 <-- ...
@end smallexample
be a free resolution of M'. If
@smallexample
        0 --> F0* -A1-> F1* -A2-> F2* -A3-> ...
@end smallexample
is the dual sequence, Fi*=Hom(Fi,R), then Ext^k = ker(Ak+1)/im(Ak)
is presented as in the following exact sequences:
@smallexample
    R^p --syz(Ak+1)-> Fk* ---Ak+1---->  Fk+1* ,
    R^q ----Ext^k---> R^p --syz(Ak+1)-> Fk*/im(Ak).
@end smallexample
Hence, Ext^k=modulo(syz(Ak+1),Ak) presents Ext^k(M',R).

@item @strong{Return:}
- module Ext, a presentation of Ext^k(M',R) if v is of type int@*
- a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.@*
- In case of a third argument of type int return a list l:
@format
     l[1] = module Ext^k resp. list of Ext^k
     l[2] = SB of Ext^k resp. list of SB of Ext^k
     l[3] = matrix resp. list of matrices, each representing a kbase of Ext^k 
              (if finite dimensional)
@end format

@item @strong{Display:}
printlevel >=0: (affine) dimension of Ext^k for each k (default)
printlevel >=1: Ak, Ak+1 and kbase of Ext^k in Fk*

@item @strong{Note:}
In order to compute Ext^k(M,R) use the command Ext_R(k,syz(M));
or the 2 commands: list L=mres(M,2); Ext_R(k,L[2]);

@end table
@strong{Example:}
@smallexample
@c computed example Ext_R d2t_singular/homolog_lib.doc:254 
LIB "homolog.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 0,(x,y,z),dp;
ideal i    = x2y,y2z,z3x;
module E   = Ext_R(1,i);    //computes Ext^1(r/i,r)
@expansion{} // Computing Ext^1:
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
@expansion{} // then F1*-->F2* is given by:
@expansion{} x2, -yz,0,  
@expansion{} 0,  z3, -xy,
@expansion{} xz2,0,  -y2 
@expansion{} // and F0*-->F1* is given by:
@expansion{} y2z,
@expansion{} x2y,
@expansion{} xz3 
@expansion{} 
@expansion{} // dimension of Ext^1:  -1
@expansion{} 
is_zero(E);
@expansion{} 1
qring R    = std(x2+yz);
intvec v   = 0,2;
printlevel = 2;             //shows what is going on
ideal i    = x,y,z;         //computes Ext^i(r/(x,y,z),r/(x2+yz)), i=0,2
list L     = Ext_R(v,i,1);  //over the qring R=r/(x2+yz), std and kbase
@expansion{} // Computing Ext^0:
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
@expansion{} // then F0*-->F1* is given by:
@expansion{} z,
@expansion{} y,
@expansion{} x 
@expansion{} // and F-1*-->F0* is given by:
@expansion{} 0
@expansion{} 
@expansion{} // dimension of Ext^0:  -1
@expansion{} 
@expansion{} // columns of matrix are kbase of Ext^0 in F0*:
@expansion{} 0
@expansion{} 
@expansion{} // Computing Ext^2:
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of M,
@expansion{} // then F2*-->F3* is given by:
@expansion{} x,-y,z, 0,
@expansion{} z,x, 0, z,
@expansion{} 0,0, x, y,
@expansion{} 0,0, -z,x 
@expansion{} // and F1*-->F2* is given by:
@expansion{} y,-z,0, 
@expansion{} x,0, -z,
@expansion{} 0,x, -y,
@expansion{} 0,z, x  
@expansion{} 
@expansion{} // dimension of Ext^2:  0
@expansion{} // vdim of Ext^2:       1
@expansion{} 
@expansion{} // columns of matrix are kbase of Ext^2 in F2*:
@expansion{} x, 
@expansion{} -z,
@expansion{} 0, 
@expansion{} 0  
@expansion{} 
printlevel = p;
@c end example Ext_R d2t_singular/homolog_lib.doc:254
@end smallexample
@c ---end content Ext_R---

@c ------------------- Ext -------------
@node Ext, fitting, Ext_R, homolog_lib
@subsubsection Ext
@cindex Ext
@c ---content Ext---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
Ext(v,M,N[,any]); v int resp. intvec, M,N modules

@item @strong{Compute:}
A presentation of Ext^k(M',N'); for k=v[1],v[2],... where
M'=coker(M) and N'=coker(N). Let
@smallexample
       0 <-- M' <-- F0 <-M-- F1 <-- F2 <--... ,   
       0 <-- N' <-- G0 <--N- G1
@end smallexample
be a free resolution of M', resp. a presentation of N'. Consider
the commutative diagram
@smallexample
           0                  0                  0
           |^                 |^                 |^
   --> Hom(Fk-1,N') -Ak-> Hom(Fk,N') -Ak+1-> Hom(Fk+1,N')
           |^                 |^                 |^
   --> Hom(Fk-1,G0) -Ak-> Hom(Fk,G0) -Ak+1-> Hom(Fk+1,G0)
                              |^                 |^
                              |C                 |B
                          Hom(Fk,G1) ------> Hom(Fk+1,G1)

      (Ak,Ak+1 induced by M and B,C induced by N).
@end smallexample
Let K=modulo(Ak+1,B), J=module(Ak)+module(C) and Ext=modulo(K,J),
then we have exact sequences
@smallexample
    R^p --K-> Hom(Fk,G0) --Ak+1-> Hom(Fk+1,G0)/im(B),

    R^q -Ext-> R^p --K-> Hom(Fk,G0)/(im(Ak)+im(C)).
@end smallexample
Hence, Ext presents Ext^k(M',N').

@item @strong{Return:}
- module Ext, a presentation of Ext^k(M',N') if v is of type int@*
- a list of Ext^k (k=v[1],v[2],...) if v is of type intvec.@*
- In case of a third argument of any type return a list l:
@format
             l[1] = module Ext/list of Ext^k
             l[2] = SB of Ext/list of SB of Ext^k
             l[3] = matrix/list of matrices, each representing a kbase of Ext^k
                       (if finite dimensional)
@end format

@item @strong{Display:}
printlevel >=0: dimension, vdim of Ext^k for each k (default).
@* printlevel >=1: matrices Ak, Ak+1 and kbase of Ext^k in Hom(Fk,G0)
(if finite dimensional)

@item @strong{Note:}
In order to compute Ext^k(M,N) use the command Ext(k,syz(M),syz(N));
or: list P=mres(M,2); list Q=mres(N,2); Ext(k,P[2],Q[2]);

@end table
@strong{Example:}
@smallexample
@c computed example Ext d2t_singular/homolog_lib.doc:336 
LIB "homolog.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 0,(x,y),dp;
ideal i    = x2-y3;
ideal j    = x2-y5;
list E     = Ext(0..2,i,j);    // Ext^k(r/i,r/j) for k=0,1,2 over r
@expansion{} // Computing Ext^0 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F0,G0)-->Hom(F1,G0) is given by:
@expansion{} y3-x2
@expansion{} // and Hom(F-1,G0) + Hom(F0,G1)-->Hom(F0,G0) is given by:
@expansion{} 0,-y5+x2
@expansion{} 
@expansion{} // dimension of Ext^0:  -1
@expansion{} 
@expansion{} // Computing Ext^1 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F1,G0)-->Hom(F2,G0) is given by:
@expansion{} 0
@expansion{} // and Hom(F0,G0) + Hom(F1,G1)-->Hom(F1,G0) is given by:
@expansion{} y3-x2,-y5+x2
@expansion{} 
@expansion{} // dimension of Ext^1:  0
@expansion{} // vdim of Ext^1:       10
@expansion{} 
@expansion{} // Computing Ext^2 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F2,G0)-->Hom(F3,G0) is given by:
@expansion{} 1
@expansion{} // and Hom(F1,G0) + Hom(F2,G1)-->Hom(F2,G0) is given by:
@expansion{} 0,-y5+x2
@expansion{} 
@expansion{} // dimension of Ext^2:  -1
@expansion{} 
qring R    = std(i);
ideal j    = fetch(r,j);
module M   = [-x,y],[-y2,x];
printlevel = 2;
module E1  = Ext(1,M,j);       // Ext^1(R^2/M,R/j) over R=r/i
@expansion{} // Computing Ext^1 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F1,G0)-->Hom(F2,G0) is given by:
@expansion{} x, -y,
@expansion{} y2,-x 
@expansion{} // and Hom(F0,G0) + Hom(F1,G1)-->Hom(F1,G0) is given by:
@expansion{} x, -y,-y5+x2,0,    
@expansion{} y2,-x,0,     -y5+x2
@expansion{} 
@expansion{} // dimension of Ext^1:  -1
@expansion{} 
list l     = Ext(4,M,M,1);     // Ext^4(R^2/M,R^2/M) over R=r/i
@expansion{} // Computing Ext^4 (help Ext; gives an explanation):
@expansion{} // Let 0<--coker(M)<--F0<--F1<--F2<--... be a resolution of coker(M),
@expansion{} // and 0<--coker(N)<--G0<--G1 a presentation of coker(N),
@expansion{} // then Hom(F4,G0)-->Hom(F5,G0) is given by:
@expansion{} x, -y,0, 0, 
@expansion{} y2,-x,0, 0, 
@expansion{} 0, 0, x, -y,
@expansion{} 0, 0, y2,-x 
@expansion{} // and Hom(F3,G0) + Hom(F4,G1)-->Hom(F4,G0) is given by:
@expansion{} x, -y,0, 0, -x,0, -y2,0,  
@expansion{} y2,-x,0, 0, 0, -x,0,  -y2,
@expansion{} 0, 0, x, -y,y, 0, x,  0,  
@expansion{} 0, 0, y2,-x,0, y, 0,  x   
@expansion{} 
@expansion{} // dimension of Ext^4:  0
@expansion{} // vdim of Ext^4:       2
@expansion{} 
@expansion{} // columns of matrix are kbase of Ext^4 in Hom(F4,G0)
@expansion{} 1,0,
@expansion{} 0,y,
@expansion{} 0,1,
@expansion{} 1,0 
@expansion{} 
@expansion{} // element 1 of kbase of Ext^4 in Hom(F4,G0)
@expansion{} // as matrix: F4-->G0
@expansion{} 1,0,
@expansion{} 0,1 
@expansion{} // element 2 of kbase of Ext^4 in Hom(F4,G0)
@expansion{} // as matrix: F4-->G0
@expansion{} 0,y,
@expansion{} 1,0 
@expansion{} 
printlevel = p;
@c end example Ext d2t_singular/homolog_lib.doc:336
@end smallexample
@c ---end content Ext---

@c ------------------- fitting -------------
@node fitting, flatteningStrat, Ext, homolog_lib
@subsubsection fitting
@cindex fitting
@c ---content fitting---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
fitting (M,n); M module, n int

@item @strong{Return:}
ideal, (standard basis of) n-th Fitting ideal of M'=coker(M).

@end table
@strong{Example:}
@smallexample
@c computed example fitting d2t_singular/homolog_lib.doc:372 
LIB "homolog.lib";
ring R=0,x(0..4),dp;
matrix M[2][4]=x(0),x(1),x(2),x(3),x(1),x(2),x(3),x(4);
print(M);
@expansion{} x(0),x(1),x(2),x(3),
@expansion{} x(1),x(2),x(3),x(4) 
fitting(M,-1);
@expansion{} _[1]=0
fitting(M,0);
@expansion{} _[1]=x(3)^2-x(2)*x(4)
@expansion{} _[2]=x(2)*x(3)-x(1)*x(4)
@expansion{} _[3]=x(1)*x(3)-x(0)*x(4)
@expansion{} _[4]=x(2)^2-x(0)*x(4)
@expansion{} _[5]=x(1)*x(2)-x(0)*x(3)
@expansion{} _[6]=x(1)^2-x(0)*x(2)
fitting(M,1);
@expansion{} _[1]=x(4)
@expansion{} _[2]=x(3)
@expansion{} _[3]=x(2)
@expansion{} _[4]=x(1)
@expansion{} _[5]=x(0)
fitting(M,2);
@expansion{} _[1]=1
@c end example fitting d2t_singular/homolog_lib.doc:372
@end smallexample
@c ---end content fitting---

@c ------------------- flatteningStrat -------------
@node flatteningStrat, Hom, fitting, homolog_lib
@subsubsection flatteningStrat
@cindex flatteningStrat
@c ---content flatteningStrat---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
flatteningStrat(M); M module

@item @strong{Return:}
list of ideals.
@*The list entries L[1],...,L[r] describe the flattening stratification
of M'=coker(M): setting L[0]=0, L[r+1]=1, the flattening
stratification is given by the open sets Spec(A/V(L[i-1])) \ V(L[i]),
i=1,...,r+1 (A = basering).

@item @strong{Note:}
for more information see the book 'A Singular Introduction to
Commutative Algebra' (by Greuel/Pfister, Springer 2002).

@end table
@strong{Example:}
@smallexample
@c computed example flatteningStrat d2t_singular/homolog_lib.doc:410 
LIB "homolog.lib";
ring A = 0,x(0..4),dp;
// presentation matrix:
matrix M[2][4] = x(0),x(1),x(2),x(3),x(1),x(2),x(3),x(4);
list L = flatteningStrat(M);
L;
@expansion{} [1]:
@expansion{}    _[1]=x(3)^2-x(2)*x(4)
@expansion{}    _[2]=x(2)*x(3)-x(1)*x(4)
@expansion{}    _[3]=x(1)*x(3)-x(0)*x(4)
@expansion{}    _[4]=x(2)^2-x(0)*x(4)
@expansion{}    _[5]=x(1)*x(2)-x(0)*x(3)
@expansion{}    _[6]=x(1)^2-x(0)*x(2)
@expansion{} [2]:
@expansion{}    _[1]=x(4)
@expansion{}    _[2]=x(3)
@expansion{}    _[3]=x(2)
@expansion{}    _[4]=x(1)
@expansion{}    _[5]=x(0)
@c end example flatteningStrat d2t_singular/homolog_lib.doc:410
@end smallexample
@c ---end content flatteningStrat---

@c ------------------- Hom -------------
@node Hom, homology, flatteningStrat, homolog_lib
@subsubsection Hom
@cindex Hom
@c ---content Hom---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
Hom(M,N,[any]); M,N=modules

@item @strong{Compute:}
A presentation of Hom(M',N'), M'=coker(M), N'=coker(N) as follows:
let
@smallexample
   F1 --M-> F0 -->M' --> 0,    G1 --N-> G0 --> N' --> 0  
@end smallexample
be presentations of M' and N'. Consider
@smallexample
                                  0               0
                                  |^              |^
       0 --> Hom(M',N') ----> Hom(F0,N') ----> Hom(F1,N')
                                  |^              |^
  (A:  induced by M)          Hom(F0,G0) --A-> Hom(F1,G0)
                                  |^              |^
  (B,C:induced by N)              |C              |B
                              Hom(F0,G1) ----> Hom(F1,G1)

@end smallexample
Let D=modulo(A,B) and Hom=modulo(D,C), then we have exact sequences
@smallexample
   R^p  --D-> Hom(F0,G0) --A-> Hom(F1,G0)/im(B),

 R^q -Hom-> R^p --D-> Hom(F0,G0)/im(C) --A-> Hom(F1,G0)/im(B).
@end smallexample
Hence Hom presents Hom(M',N')

@item @strong{Return:}
module Hom, a presentation of Hom(M',N'), resp., in case of
3 arguments, a list l (of size <=3):
@format
           - l[1] = Hom
           - l[2] = SB of Hom
           - l[3] = kbase of coker(Hom) (if finite dimensional, not 0),
                    represented by elements in Hom(F0,G0) via mapping D
@end format

@item @strong{Display:}
printlevel >=0: (affine) dimension of Hom (default)
@* printlevel >=1: D and C and kbase of coker(Hom) in Hom(F0,G0)
@* printlevel >=2: elements of kbase of coker(Hom) as matrix :F0-->G0

@item @strong{Note:}
DISPLAY is as described only for a direct call of 'Hom'. Calling 'Hom'
from another proc has the same effect as decreasing printlevel by 1.

@end table
@strong{Example:}
@smallexample
@c computed example Hom d2t_singular/homolog_lib.doc:480 
LIB "homolog.lib";
int p     = printlevel;
printlevel= 1;   //in 'example proc' printlevel has to be increased by 1
ring r    = 0,(x,y),dp;
ideal i   = x2-y3,xy;
qring q   = std(i);
ideal i   = fetch(r,i);
module M  = [-x,y],[-y2,x],[x3];
module H  = Hom(M,i);
@expansion{} // dimension of Hom:  0
@expansion{} // vdim of Hom:       5
@expansion{} 
@expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
@expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
@expansion{} y,x, 0,
@expansion{} x,y2,x2
@expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
@expansion{} -y3+x2,0,     xy,0,
@expansion{} 0,     -y3+x2,0, xy
@expansion{} 
print(H);
@expansion{} 0, x, 0,y2,0, 
@expansion{} y, 0, 0,-x,x2,
@expansion{} -1,-1,x,0, 0  
printlevel= 2;
list L    = Hom(M,i,1);"";
@expansion{} // dimension of Hom:  0
@expansion{} // vdim of Hom:       5
@expansion{} 
@expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
@expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
@expansion{} y,x, 0,
@expansion{} x,y2,x2
@expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
@expansion{} -y3+x2,0,     xy,0,
@expansion{} 0,     -y3+x2,0, xy
@expansion{} 
@expansion{} // element 1 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} y2,xy
@expansion{} // element 2 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} y,x
@expansion{} // element 3 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} x2,xy2
@expansion{} // element 4 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} x,y2
@expansion{} // element 5 of kbase of Hom in Hom(F0,G0) as matrix: F0-->G0:
@expansion{} 0,x2
@expansion{} 
printlevel=1;
ring s    = 3,(x,y,z),(c,dp);
ideal i   = jacob(ideal(x2+y5+z4));
qring rq=std(i);
matrix M[2][2]=xy,x3,5y,4z,x2;
matrix N[3][2]=x2,x,y3,3xz,x2z,z;
print(M);
@expansion{} xy,x3,
@expansion{} -y,z  
print(N);
@expansion{} x2, x,
@expansion{} y3, 0,
@expansion{} x2z,z 
list l=Hom(M,N,1);
@expansion{} // dimension of Hom:  0
@expansion{} // vdim of Hom:       16
@expansion{} 
@expansion{} // given  F1 --M-> F0 -->M'--> 0 and  G1 --N-> G0 -->N'--> 0,
@expansion{} // show D = ker( Hom(F0,G0) --> Hom(F1,G0)/im(Hom(F1,G1)->Hom(F1,G0)) )
@expansion{} 0,0, 0,0, 0,   0,0,   1,
@expansion{} 0,0, 0,0, 0,   0,y3z2,0,
@expansion{} 0,0, 0,0, 0,   1,0,   0,
@expansion{} 0,0, 0,y3,y2z2,0,0,   0,
@expansion{} 0,0, 1,0, 0,   0,0,   0,
@expansion{} z,y3,0,0, 0,   0,0,   0 
@expansion{} // show C = im ( Hom(F0,G1) --> Hom(F0,G0) )
@expansion{} x2, 0,  x,0,
@expansion{} 0,  x2, 0,x,
@expansion{} y3, 0,  0,0,
@expansion{} 0,  y3, 0,0,
@expansion{} x2z,0,  z,0,
@expansion{} 0,  x2z,0,z 
@expansion{} 
@expansion{} // columns of matrix are kbase of Hom in Hom(F0,G0)
@expansion{} 0, 0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,0,   
@expansion{} 0, 0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,y3z2,
@expansion{} 0, 0, 0, 0,0,0,   y2z2,yz2,z2,y2z,yz,z,y2,y,1,0,   
@expansion{} 0, 0, 0, 0,0,y2z2,0,   0,  0, 0,  0, 0,0, 0,0,0,   
@expansion{} 0, y3,y2,y,1,0,   0,   0,  0, 0,  0, 0,0, 0,0,0,   
@expansion{} y3,0, 0, 0,0,0,   0,   0,  0, 0,  0, 0,0, 0,0,0    
printlevel = p;
@c end example Hom d2t_singular/homolog_lib.doc:480
@end smallexample
@c ---end content Hom---

@c ------------------- homology -------------
@node homology, isCM, Hom, homolog_lib
@subsubsection homology
@cindex homology
@c ---content homology---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
homology(A,B,M,N);

@item @strong{Compute:}
Let M and N be submodules of R^m and R^n presenting M'=R^m/M, N'=R^n/N
(R=basering) and let A,B matrices inducing maps
@smallexample
    R^k --A--> R^m --B--> R^n.
@end smallexample
Compute a presentation of the module
@smallexample
    ker(B)/im(A) := ker(M'/im(A) --B--> N'/im(BM)+im(BA)).
@end smallexample
If B induces a map M'-->N' (i.e BM=0) and if im(A) is contained in
ker(B) (that is, BA=0) then ker(B)/im(A) is the homology of the
complex
@smallexample
    R^k--A-->M'--B-->N'. 
@end smallexample

@item @strong{Return:}
module H, a presentation of ker(B)/im(A).

@item @strong{Note:}
homology returns a free module of rank m if ker(B)=im(A).

@end table
@strong{Example:}
@smallexample
@c computed example homology d2t_singular/homolog_lib.doc:544 
LIB "homolog.lib";
ring r;
ideal id=maxideal(4);
qring qr=std(id);
module N=maxideal(3)*freemodule(2);
module M=maxideal(2)*freemodule(2);
module B=[2x,0],[x,y],[z2,y];
module A=M;
module H=homology(A,B,M,N);
H=std(H);
// dimension of homology:
dim(H);
@expansion{} 0
// vector space dimension: 
vdim(H);
@expansion{} 19
ring s=0,x,ds;
qring qs=std(x4);
module A=[x];
module B=A;
module M=[x3];
module N=M;
homology(A,B,M,N);
@expansion{} _[1]=gen(1)
@c end example homology d2t_singular/homolog_lib.doc:544
@end smallexample
@c ---end content homology---

@c ------------------- isCM -------------
@node isCM, isFlat, homology, homolog_lib
@subsubsection isCM
@cindex isCM
@c ---content isCM---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
isCM(M); M module

@item @strong{Return:}
1 if M'=coker(M) is Cohen-Macaulay;@*
0 if this is not the case.

@item @strong{Assume:}
basering is local.

@end table
@strong{Example:}
@smallexample
@c computed example isCM d2t_singular/homolog_lib.doc:591 
LIB "homolog.lib";
ring R=0,(x,y,z),ds;  // local ring R = Q[x,y,z]_<x,y,z>
module M=xz,yz,z2;   
isCM(M);             // test if R/<xz,yz,z2> is Cohen-Macaulay
@expansion{} 0
M=x2+y2,z7;          // test if R/<x2+y2,z7> is Cohen-Macaulay
isCM(M);
@expansion{} 1
@c end example isCM d2t_singular/homolog_lib.doc:591
@end smallexample
@c ---end content isCM---

@c ------------------- isFlat -------------
@node isFlat, isLocallyFree, isCM, homolog_lib
@subsubsection isFlat
@cindex isFlat
@c ---content isFlat---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
isFlat(M); M module

@item @strong{Return:}
1 if M'=coker(M) is flat;@*
0 if this is not the case.

@end table
@strong{Example:}
@smallexample
@c computed example isFlat d2t_singular/homolog_lib.doc:620 
LIB "homolog.lib";
ring A = 0,(x,y),dp;
matrix M[3][3] = x-1,y,x,x,x+1,y,x2,xy+x+1,x2+y;
print(M);
@expansion{} x-1,y,     x,  
@expansion{} x,  x+1,   y,  
@expansion{} x2, xy+x+1,x2+y
isFlat(M);             // coker(M) is not flat over A=Q[x,y]
@expansion{} 0
qring B = std(x2+x-y);   // the ring B=Q[x,y]/<x2+x-y>
matrix M = fetch(A,M);
isFlat(M);             // coker(M) is flat over B
@expansion{} 1
setring A;
qring C = std(x2+x+y);   // the ring C=Q[x,y]/<x2+x+y>
matrix M = fetch(A,M);
isFlat(M);             // coker(M) is not flat over C
@expansion{} 0
@c end example isFlat d2t_singular/homolog_lib.doc:620
@end smallexample
@c ---end content isFlat---

@c ------------------- isLocallyFree -------------
@node isLocallyFree, isReg, isFlat, homolog_lib
@subsubsection isLocallyFree
@cindex isLocallyFree
@c ---content isLocallyFree---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
isLocallyFree(M,r); M module, r int

@item @strong{Return:}
1 if M'=coker(M) is locally free of constant rank r;@*
0 if this is not the case.

@end table
@strong{Example:}
@smallexample
@c computed example isLocallyFree d2t_singular/homolog_lib.doc:655 
LIB "homolog.lib";
ring R=0,(x,y,z),dp;
matrix M[2][3];     // the presentation matrix
M=x-1,y-1,z,y-1,x-2,x;
ideal I=fitting(M,0); // 0-th Fitting ideal of coker(M)
qring Q=I;
matrix M=fetch(R,M);
isLocallyFree(M,1); // as R/I-module, coker(M) is locally free of rk 1
@expansion{} 1
isLocallyFree(M,0);
@expansion{} 0
@c end example isLocallyFree d2t_singular/homolog_lib.doc:655
@end smallexample
@c ---end content isLocallyFree---

@c ------------------- isReg -------------
@node isReg, kernel, isLocallyFree, homolog_lib
@subsubsection isReg
@cindex isReg
@c ---content isReg---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
isReg(I,M); I ideal, M module

@item @strong{Return:}
1 if given (ordered) list of generators for I is coker(M)-sequence;@*
0 if this is not the case.

@end table
@strong{Example:}
@smallexample
@c computed example isReg d2t_singular/homolog_lib.doc:687 
LIB "homolog.lib";
ring R = 0,(x,y,z),dp;
ideal I = x*(y-1),y,z*(y-1);
isReg(I,0);             // given list of generators is Q[x,y,z]-sequence
@expansion{} 1
I = x*(y-1),z*(y-1),y;  // change sorting of generators 
isReg(I,0);
@expansion{} 0
ring r = 0,(x,y,z),ds;  // local ring
ideal I=fetch(R,I);
isReg(I,0);             // result independent of sorting of generators
@expansion{} 1
@c end example isReg d2t_singular/homolog_lib.doc:687
@end smallexample
@c ---end content isReg---

@c ------------------- kernel -------------
@node kernel, kohom, isReg, homolog_lib
@subsubsection kernel
@cindex kernel
@c ---content kernel---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
kernel(A,M,N);

@item @strong{Compute:}
Let M and N be submodules of R^m and R^n, presenting M'=R^m/M,
N'=R^n/N (R=basering), and let A:R^m-->R^n be a matrix inducing a
map A':M'-->N'. Then kernel(A,M,N); computes a presentation K of
ker(A') as in the commutative diagram:
@smallexample
          ker(A') --->  M' --A'--> N'
             |^         |^         |^
             |          |          |
             R^r  ---> R^m --A--> R^n
             |^         |^         |^
             |K         |M         |N
             |          |          |
             R^s  ---> R^p -----> R^q
@end smallexample

@item @strong{Return:}
module K, a presentation of ker(A':coker(M)->coker(N)).

@end table
@strong{Example:}
@smallexample
@c computed example kernel d2t_singular/homolog_lib.doc:734 
LIB "homolog.lib";
ring r;
module N=[2x,x],[0,y];
module M=maxideal(1)*freemodule(2);
matrix A[2][2]=2x,0,x,y,z2,y;
module K=kernel(A,M,N);
// dimension of kernel:  
dim(std(K));
@expansion{} 0
// vector space dimension of kernel: 
vdim(std(K));
@expansion{} 2
print(K);
@expansion{} z,0,y,0,x,0,
@expansion{} 0,z,0,y,0,x 
@c end example kernel d2t_singular/homolog_lib.doc:734
@end smallexample
@c ---end content kernel---

@c ------------------- kohom -------------
@node kohom, kontrahom, kernel, homolog_lib
@subsubsection kohom
@cindex kohom
@c ---content kohom---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
kohom(A,k); A=matrix, k=integer

@item @strong{Return:}
matrix Hom(R^k,A), i.e. let A be a matrix defining a map F1-->F2
of free R-modules, then the matrix of Hom(R^k,F1)-->Hom(R^k,F2)
is computed (R=basering).

@end table
@strong{Example:}
@smallexample
@c computed example kohom d2t_singular/homolog_lib.doc:769 
LIB "homolog.lib";
ring r;
matrix n[2][3]=x,y,5,z,77,33;
print(kohom(n,3));
@expansion{} x,0,0,y, 0, 0, 5, 0, 0,
@expansion{} 0,x,0,0, y, 0, 0, 5, 0,
@expansion{} 0,0,x,0, 0, y, 0, 0, 5,
@expansion{} z,0,0,77,0, 0, 33,0, 0,
@expansion{} 0,z,0,0, 77,0, 0, 33,0,
@expansion{} 0,0,z,0, 0, 77,0, 0, 33
@c end example kohom d2t_singular/homolog_lib.doc:769
@end smallexample
@c ---end content kohom---

@c ------------------- kontrahom -------------
@node kontrahom, KoszulHomology, kohom, homolog_lib
@subsubsection kontrahom
@cindex kontrahom
@c ---content kontrahom---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
kontrahom(A,k); A=matrix, k=integer

@item @strong{Return:}
matrix Hom(A,R^k), i.e. let A be a matrix defining a map F1-->F2 of
free R-modules, then the matrix of Hom(F2,R^k)-->Hom(F1,R^k) is
computed (R=basering).

@end table
@strong{Example:}
@smallexample
@c computed example kontrahom d2t_singular/homolog_lib.doc:797 
LIB "homolog.lib";
ring r;
matrix n[2][3]=x,y,5,z,77,33;
print(kontrahom(n,3));
@expansion{} x,z, 0,0, 0,0, 
@expansion{} y,77,0,0, 0,0, 
@expansion{} 5,33,0,0, 0,0, 
@expansion{} 0,0, x,z, 0,0, 
@expansion{} 0,0, y,77,0,0, 
@expansion{} 0,0, 5,33,0,0, 
@expansion{} 0,0, 0,0, x,z, 
@expansion{} 0,0, 0,0, y,77,
@expansion{} 0,0, 0,0, 5,33 
@c end example kontrahom d2t_singular/homolog_lib.doc:797
@end smallexample
@c ---end content kontrahom---

@c ------------------- KoszulHomology -------------
@node KoszulHomology, tensorMod, kontrahom, homolog_lib
@subsubsection KoszulHomology
@cindex KoszulHomology
@c ---content KoszulHomology---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Compute:}
A presentation of the p-th Koszul homology module H_p(f_1,...,f_k;M'),
where M'=coker(M) and f_1,...,f_k are the given (ordered list
of generators of the) ideal I. The computed presentation is minimized
via prune. In particular, if H_p(f_1,...,f_k;M')=0 then the
return value is 0.

@item @strong{Return:}
module H, s.th. coker(H) = H_p(f_1,...,f_k;M').

@item @strong{Note:}
size of input ideal has to be <= 20.

@end table
@strong{Example:}
@smallexample
@c computed example KoszulHomology d2t_singular/homolog_lib.doc:830 
LIB "homolog.lib";
ring R=0,x(1..3),dp;
ideal x=maxideal(1);
module M=0;
KoszulHomology(x,M,0);  // H_0(x,R), x=(x_1,x_2,x_3)
@expansion{} _[1]=x(3)*gen(1)
@expansion{} _[2]=x(2)*gen(1)
@expansion{} _[3]=x(1)*gen(1)
KoszulHomology(x,M,1);  // H_1(x,R), x=(x_1,x_2,x_3)
@expansion{} _[1]=0
qring S=std(x(1)*x(2));
module M=0;
ideal x=maxideal(1);
KoszulHomology(x,M,1);
@expansion{} _[1]=-x(3)*gen(1)
@expansion{} _[2]=-x(2)*gen(1)
@expansion{} _[3]=-x(1)*gen(1)
KoszulHomology(x,M,2);
@expansion{} _[1]=0
@c end example KoszulHomology d2t_singular/homolog_lib.doc:830
@end smallexample
@c ---end content KoszulHomology---

@c ------------------- tensorMod -------------
@node tensorMod, Tor, KoszulHomology, homolog_lib
@subsubsection tensorMod
@cindex tensorMod
@c ---content tensorMod---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Usage:}
tensorMod(M,N); M,N modules

@item @strong{Compute:}
presentation matrix A of the tensor product T of the modules
M'=coker(M), N'=coker(N): if matrix(M) defines a map M: R^r-->R^s and
matrix(N) defines a map N: R^p-->R^q, then A defines a presentation
@smallexample
         R^(sp+rq) --A-> R^(sq)  --> T --> 0 .
@end smallexample

@item @strong{Return:}
matrix A satisfying coker(A) = tensorprod(coker(M),coker(N)) .

@end table
@strong{Example:}
@smallexample
@c computed example tensorMod d2t_singular/homolog_lib.doc:871 
LIB "homolog.lib";
ring A=0,(x,y,z),dp;
matrix M[3][3]=1,2,3,4,5,6,7,8,9;
matrix N[2][2]=x,y,0,z;
print(M);
@expansion{} 1,2,3,
@expansion{} 4,5,6,
@expansion{} 7,8,9 
print(N);
@expansion{} x,y,
@expansion{} 0,z 
print(tensorMod(M,N));
@expansion{} x,y,0,0,0,0,1,0,2,0,3,0,
@expansion{} 0,z,0,0,0,0,0,1,0,2,0,3,
@expansion{} 0,0,x,y,0,0,4,0,5,0,6,0,
@expansion{} 0,0,0,z,0,0,0,4,0,5,0,6,
@expansion{} 0,0,0,0,x,y,7,0,8,0,9,0,
@expansion{} 0,0,0,0,0,z,0,7,0,8,0,9 
@c end example tensorMod d2t_singular/homolog_lib.doc:871
@end smallexample
@c ---end content tensorMod---

@c ------------------- Tor -------------
@node Tor,, tensorMod, homolog_lib
@subsubsection Tor
@cindex Tor
@c ---content Tor---
Procedure from library @code{homolog.lib} (@pxref{homolog_lib}).

@table @asis
@item @strong{Compute:}
a presentation of Tor_k(M',N'), for k=v[1],v[2],... , where
M'=coker(M) and N'=coker(N): let
@smallexample
       0 <-- M' <-- G0 <-M-- G1                
       0 <-- N' <-- F0 <--N- F1 <-- F2 <--...  
@end smallexample
be a presentation of M', resp. a free resolution of N', and consider
the commutative diagram
@smallexample
          0                    0                    0
          |^                   |^                   |^
  Tensor(M',Fk+1) -Ak+1-> Tensor(M',Fk) -Ak-> Tensor(M',Fk-1)
          |^                   |^                   |^
  Tensor(G0,Fk+1) -Ak+1-> Tensor(G0,Fk) -Ak-> Tensor(G0,Fk-1)
                               |^                   |^
                               |C                   |B
                          Tensor(G1,Fk) ----> Tensor(G1,Fk-1)

       (Ak,Ak+1 induced by N and B,C induced by M).
@end smallexample
Let K=modulo(Ak,B), J=module(C)+module(Ak+1) and Tor=modulo(K,J),
then we have exact sequences
@smallexample
    R^p  --K-> Tensor(G0,Fk) --Ak-> Tensor(G0,Fk-1)/im(B),

    R^q -Tor-> R^p --K-> Tensor(G0,Fk)/(im(C)+im(Ak+1)). 
@end smallexample
Hence, Tor presents Tor_k(M',N').

@item @strong{Return:}
- if v is of type int: module Tor, a presentation of Tor_k(M',N');@*
- if v is of type intvec: a list of Tor_k(M',N') (k=v[1],v[2],...);@*
- in case of a third argument of any type: list l with
@format
     l[1] = module Tor/list of Tor_k(M',N'),
     l[2] = SB of Tor/list of SB of Tor_k(M',N'),
     l[3] = matrix/list of matrices, each representing a kbase of Tor_k(M',N')
                (if finite dimensional), or 0.
@end format

@item @strong{Display:}
printlevel >=0: (affine) dimension of Tor_k for each k (default).
@* printlevel >=1: matrices Ak, Ak+1 and kbase of Tor_k in Tensor(G0,Fk)
(if finite dimensional).

@item @strong{Note:}
In order to compute Tor_k(M,N) use the command Tor(k,syz(M),syz(N));
or: list P=mres(M,2); list Q=mres(N,2); Tor(k,P[2],Q[2]);

@end table
@strong{Example:}
@smallexample
@c computed example Tor d2t_singular/homolog_lib.doc:944 
LIB "homolog.lib";
int p      = printlevel;
printlevel = 1;
ring r     = 0,(x,y),dp;
ideal i    = x2,y;
ideal j    = x;
list E     = Tor(0..2,i,j);    // Tor_k(r/i,r/j) for k=0,1,2 over r
@expansion{} // dimension of Tor_0:  0
@expansion{} // vdim of Tor_0:       1
@expansion{} 
@expansion{} // Computing Tor_1 (help Tor; gives an explanation):
@expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
@expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
@expansion{} // coker(N), then Tensor(G0,F1)-->Tensor(G0,F0) is given by:
@expansion{} x
@expansion{} // and Tensor(G0,F2) + Tensor(G1,F1)-->Tensor(G0,F1) is given by:
@expansion{} 0,x2,y
@expansion{} 
@expansion{} // dimension of Tor_1:  0
@expansion{} // vdim of Tor_1:       1
@expansion{} 
@expansion{} // Computing Tor_2 (help Tor; gives an explanation):
@expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
@expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
@expansion{} // coker(N), then Tensor(G0,F2)-->Tensor(G0,F1) is given by:
@expansion{} 0
@expansion{} // and Tensor(G0,F3) + Tensor(G1,F2)-->Tensor(G0,F2) is given by:
@expansion{} 1,x2,y
@expansion{} 
@expansion{} // dimension of Tor_2:  -1
@expansion{} 
qring R    = std(i);
ideal j    = fetch(r,j);
module M   = [x,0],[0,x];
printlevel = 2;
module E1  = Tor(1,M,j);       // Tor_1(R^2/M,R/j) over R=r/i
@expansion{} // Computing Tor_1 (help Tor; gives an explanation):
@expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
@expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
@expansion{} // coker(N), then Tensor(G0,F1)-->Tensor(G0,F0) is given by:
@expansion{} x,0,
@expansion{} 0,x 
@expansion{} // and Tensor(G0,F2) + Tensor(G1,F1)-->Tensor(G0,F1) is given by:
@expansion{} x,0,x,0,
@expansion{} 0,x,0,x 
@expansion{} 
@expansion{} // dimension of Tor_1:  0
@expansion{} // vdim of Tor_1:       2
@expansion{} 
list l     = Tor(3,M,M,1);     // Tor_3(R^2/M,R^2/M) over R=r/i
@expansion{} // Computing Tor_3 (help Tor; gives an explanation):
@expansion{} // Let 0 <- coker(M) <- G0 <-M- G1 be the present. of coker(M),
@expansion{} // and 0 <- coker(N) <- F0 <-N- F1 <- F2 <- ... a resolution of
@expansion{} // coker(N), then Tensor(G0,F3)-->Tensor(G0,F2) is given by:
@expansion{} x,0,0,0,
@expansion{} 0,x,0,0,
@expansion{} 0,0,x,0,
@expansion{} 0,0,0,x 
@expansion{} // and Tensor(G0,F4) + Tensor(G1,F3)-->Tensor(G0,F3) is given by:
@expansion{} x,0,0,0,x,0,0,0,
@expansion{} 0,x,0,0,0,x,0,0,
@expansion{} 0,0,x,0,0,0,x,0,
@expansion{} 0,0,0,x,0,0,0,x 
@expansion{} 
@expansion{} // dimension of Tor_3:  0
@expansion{} // vdim of Tor_3:       4
@expansion{} 
@expansion{} // columns of matrix are kbase of Tor_3 in Tensor(G0,F3)
@expansion{} 1,0,0,0,
@expansion{} 0,1,0,0,
@expansion{} 0,0,1,0,
@expansion{} 0,0,0,1 
@expansion{} 
printlevel = p;
@c end example Tor d2t_singular/homolog_lib.doc:944
@end smallexample
@c ---end content Tor---
