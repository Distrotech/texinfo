@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/linalg_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/linalg_lib.doc INSTEAD
@c library version: (1.10.2.15,2003/04/04)
@c library file: ../Singular/LIB/linalg.lib
@cindex linalg.lib
@cindex linalg_lib
@table @asis
@item @strong{Library:}
linalg.lib
@item @strong{Purpose:}
  Algorithmic Linear Algebra
@item @strong{Authors:}
Ivor Saynisch (ivs@@math.tu-cottbus.de)
@* Mathias Schulze (mschulze@@mathematik.uni-kl.de)

@end table

@strong{Procedures:}
@menu
* inverse:: matrix, the inverse of A
* inverse_B:: list(matrix Inv,poly p),Inv*A=p*En ( using busadj(A) )
* inverse_L:: list(matrix Inv,poly p),Inv*A=p*En ( using lift )
* sym_gauss:: symmetric gaussian algorithm
* orthogonalize:: Gram-Schmidt orthogonalization
* diag_test:: test whether A can be diagonalized
* busadj:: coefficients of Adj(E*t-A) and coefficients of det(E*t-A)
* charpoly:: characteristic polynomial of A ( using busadj(A) )
* adjoint:: adjoint of A ( using busadj(A) )
* det_B:: determinant of A ( using busadj(A) )
* gaussred:: gaussian reduction: P*A=U*S, S a row reduced form of A
* gaussred_pivot:: gaussian reduction: P*A=U*S, uses row pivoting
* gauss_nf:: gaussian normal form of A
* mat_rk:: rank of constant matrix A
* U_D_O:: P*A=U*D*O, P,D,U,O=permutation,diag,lower-,upper-triang
* pos_def:: test symmetric matrix for positive definiteness
* hessenberg:: Hessenberg form of M
* evnf:: eigenvalues normal form of (e[,m])
* eigenvals:: eigenvalues with multiplicities of M
* minipoly:: minimal polynomial of M
* jordan:: Jordan data of M
* jordanbasis:: Jordan basis and weight filtration of M
* jordanmatrix:: Jordan matrix with Jordan data (e,s,m)
* jordannf:: Jordan normal form of M
@end menu
@c ---end content LibInfo---

@c ------------------- inverse -------------
@node inverse, inverse_B,, linalg_lib
@subsubsection inverse
@cindex inverse
@c ---content inverse---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
inverse(A [,opt]); A a square matrix, opt integer

@item @strong{Return:}
@format
          a matrix:
          - the inverse matrix of A, if A is invertible;
          - the 1x1 0-matrix if A is not invertible (in the polynomial ring!).
          There are the following options:
          - opt=0 or not given: heuristically best option from below
          - opt=1 : apply std to (transpose(E,A)), ordering (C,dp).
          - opt=2 : apply interred (transpose(E,A)), ordering (C,dp).
          - opt=3 : apply lift(A,E), ordering (C,dp).
@end format

@item @strong{Note:}
parameters and minpoly are allowed; opt=2 is only correct for
matrices with entries in a field

@end table
@strong{Example:}
@smallexample
@c skipped computation of example inverse d2t_singular/linalg_lib.doc:76 
LIB "linalg.lib";
ring r=0,(x,y,z),lp;
matrix A[3][3]=
1,4,3,
1,5,7,
0,4,17;
print(inverse(A));"";
matrix B[3][3]=
y+1,  x+y,    y,
z,    z+1,    z,
y+z+2,x+y+z+2,y+z+1;
print(inverse(B));
print(B*inverse(B));
@end smallexample
@c inserted refs from d2t_singular/linalg_lib.doc:92
@ifinfo
@menu
See also:
* inverse_B::
* inverse_L::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{inverse_B};
@ref{inverse_L}.
@end iftex
@c end inserted refs from d2t_singular/linalg_lib.doc:92

@c ---end content inverse---

@c ------------------- inverse_B -------------
@node inverse_B, inverse_L, inverse, linalg_lib
@subsubsection inverse_B
@cindex inverse_B
@c ---content inverse_B---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
inverse_B(A); A = square matrix

@item @strong{Return:}
list Inv with
@*- Inv[1] = matrix I and
@*- Inv[2] = poly p
@*such that I*A = unitmat(n)*p;

@item @strong{Note:}
p=1 if 1/det(A) is computable and p=det(A) if not;
@*the computation uses busadj.

@end table
@strong{Example:}
@smallexample
@c skipped computation of example inverse_B d2t_singular/linalg_lib.doc:122 
LIB "linalg.lib";
ring r=0,(x,y),lp;
matrix A[3][3]=x,y,1,1,x2,y,x,6,0;
print(A);
list Inv=inverse_B(A);
print(Inv[1]);
print(Inv[2]);
print(Inv[1]*A);
@end smallexample
@c inserted refs from d2t_singular/linalg_lib.doc:133
@ifinfo
@menu
See also:
* inverse::
* inverse_L::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{inverse};
@ref{inverse_L}.
@end iftex
@c end inserted refs from d2t_singular/linalg_lib.doc:133

@c ---end content inverse_B---

@c ------------------- inverse_L -------------
@node inverse_L, sym_gauss, inverse_B, linalg_lib
@subsubsection inverse_L
@cindex inverse_L
@c ---content inverse_L---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
inverse_L(A); A = square matrix

@item @strong{Return:}
list Inv representing a left inverse of A, i.e
@*- Inv[1] = matrix I and
@*- Inv[2] = poly p
@*such that I*A = unitmat(n)*p;

@item @strong{Note:}
p=1 if 1/det(A) is computable and p=det(A) if not;
@*the computation computes first det(A) and then uses lift

@end table
@strong{Example:}
@smallexample
@c skipped computation of example inverse_L d2t_singular/linalg_lib.doc:163 
LIB "linalg.lib";
ring r=0,(x,y),lp;
matrix A[3][3]=x,y,1,1,x2,y,x,6,0;
print(A);
list Inv=inverse_L(A);
print(Inv[1]);
print(Inv[2]);
print(Inv[1]*A);
@end smallexample
@c inserted refs from d2t_singular/linalg_lib.doc:174
@ifinfo
@menu
See also:
* inverse::
* inverse_B::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{inverse};
@ref{inverse_B}.
@end iftex
@c end inserted refs from d2t_singular/linalg_lib.doc:174

@c ---end content inverse_L---

@c ------------------- sym_gauss -------------
@node sym_gauss, orthogonalize, inverse_L, linalg_lib
@subsubsection sym_gauss
@cindex sym_gauss
@c ---content sym_gauss---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
sym_gauss(A); A = symmetric matrix

@item @strong{Return:}
matrix, diagonalisation with symmetric gauss algorithm

@end table
@strong{Example:}
@smallexample
@c skipped computation of example sym_gauss d2t_singular/linalg_lib.doc:197 
LIB "linalg.lib";
ring r=0,(x),lp;
matrix A[2][2]=1,4,4,15;
print(A);
print(sym_gauss(A));
@end smallexample
@c ---end content sym_gauss---

@c ------------------- orthogonalize -------------
@node orthogonalize, diag_test, sym_gauss, linalg_lib
@subsubsection orthogonalize
@cindex orthogonalize
@c ---content orthogonalize---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
orthogonalize(A); A = constant matrix

@item @strong{Return:}
matrix, orthogonal basis of the column space of A

@end table
@strong{Example:}
@smallexample
@c skipped computation of example orthogonalize d2t_singular/linalg_lib.doc:224 
LIB "linalg.lib";
ring r=0,(x),lp;
matrix A[4][4]=5,6,12,4,7,3,2,6,12,1,1,2,6,4,2,10;
print(A);
print(orthogonalize(A));
@end smallexample
@c ---end content orthogonalize---

@c ------------------- diag_test -------------
@node diag_test, busadj, orthogonalize, linalg_lib
@subsubsection diag_test
@cindex diag_test
@c ---content diag_test---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
diag_test(A); A = const square matrix

@item @strong{Return:}
int, 1 if A is diagonalisable, 0 if not
@*-1 no statement is possible, since A does not split.

@item @strong{Note:}
The test works only for split matrices, i.e if eigenvalues of A
are in the ground field.
@*Does not work with parameters (uses factorize,gcd).

@end table
@strong{Example:}
@smallexample
@c skipped computation of example diag_test d2t_singular/linalg_lib.doc:257 
LIB "linalg.lib";
ring r=0,(x),dp;
matrix A[4][4]=6,0,0,0,0,0,6,0,0,6,0,0,0,0,0,6;
print(A);
diag_test(A);
@end smallexample
@c ---end content diag_test---

@c ------------------- busadj -------------
@node busadj, charpoly, diag_test, linalg_lib
@subsubsection busadj
@cindex busadj
@c ---content busadj---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
busadj(A); A = square matrix (of size nxn)

@item @strong{Return:}
list L:
@format
         L[1] contains the (n+1) coefficients of the characteristic
              polynomial X of A, i.e.
              X = L[1][1]+..+L[1][k]*t^(k-1)+..+(L[1][n+1])*t^n
         L[2] contains the n (nxn)-matrices Hk which are the coefficients of
              the busadjoint bA = adjoint(E*t-A) of A, i.e.
              bA = (Hn-1)*t^(n-1)+...+Hk*t^k+...+H0,  ( Hk=L[2][k+1] )
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example busadj d2t_singular/linalg_lib.doc:292 
LIB "linalg.lib";
ring r = 0,(t,x),lp;
matrix A[2][2] = 1,x2,x,x2+3x;
print(A);
list L = busadj(A);
poly X = L[1][1]+L[1][2]*t+L[1][3]*t2; X;
matrix bA[2][2] = L[2][1]+L[2][2]*t;
print(bA);               //the busadjoint of A;
print(bA*(t*unitmat(2)-A));
@end smallexample
@c ---end content busadj---

@c ------------------- charpoly -------------
@node charpoly, adjoint, busadj, linalg_lib
@subsubsection charpoly
@cindex charpoly
@c ---content charpoly---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
charpoly(A[,v]); A square matrix, v string, name of a variable

@item @strong{Return:}
poly, the characteristic polynomial det(E*v-A)
@*(default: v=name of last variable)

@item @strong{Note:}
A must be independent of the variable v. The computation uses det.
If printlevel>0, det(E*v-A) is diplayed recursively.

@end table
@strong{Example:}
@smallexample
@c skipped computation of example charpoly d2t_singular/linalg_lib.doc:328 
LIB "linalg.lib";
ring r=0,(x,t),dp;
matrix A[3][3]=1,x2,x,x2,6,4,x,4,1;
print(A);
charpoly(A,"t");
@end smallexample
@c ---end content charpoly---

@c ------------------- adjoint -------------
@node adjoint, det_B, charpoly, linalg_lib
@subsubsection adjoint
@cindex adjoint
@c ---content adjoint---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
adjoint(A); A = square matrix

@item @strong{Return:}
adjoint matrix of A, i.e. Adj*A=det(A)*E

@item @strong{Note:}
computation uses busadj(A)

@end table
@strong{Example:}
@smallexample
@c skipped computation of example adjoint d2t_singular/linalg_lib.doc:358 
LIB "linalg.lib";
ring r=0,(t,x),lp;
matrix A[2][2]=1,x2,x,x2+3x;
print(A);
matrix Adj[2][2]=adjoint(A);
print(Adj);                    //Adj*A=det(A)*E
print(Adj*A);
@end smallexample
@c ---end content adjoint---

@c ------------------- det_B -------------
@node det_B, gaussred, adjoint, linalg_lib
@subsubsection det_B
@cindex det_B
@c ---content det_B---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
det_B(A); A any matrix

@item @strong{Return:}
returns the determinant of A

@item @strong{Note:}
the computation uses the busadj algorithm

@end table
@strong{Example:}
@smallexample
@c skipped computation of example det_B d2t_singular/linalg_lib.doc:390 
LIB "linalg.lib";
ring r=0,(x),dp;
matrix A[10][10]=random(2,10,10)+unitmat(10)*x;
print(A);
det_B(A);
@end smallexample
@c ---end content det_B---

@c ------------------- gaussred -------------
@node gaussred, gaussred_pivot, det_B, linalg_lib
@subsubsection gaussred
@cindex gaussred
@c ---content gaussred---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
gaussred(A); A any constant matrix

@item @strong{Return:}
list Z: Z[1]=P , Z[2]=U , Z[3]=S , Z[4]=rank(A)
@*gives a row reduced matrix S, a permutation matrix P and a
normalized lower triangular matrix U, with P*A=U*S

@item @strong{Note:}
This procedure is designed for teaching purposes mainly.
The straight forward implementation in the interpreted library
is not very efficient (no standard basis computation).

@end table
@strong{Example:}
@smallexample
@c skipped computation of example gaussred d2t_singular/linalg_lib.doc:424 
LIB "linalg.lib";
ring r=0,(x),dp;
matrix A[5][4]=1,3,-1,4,2,5,-1,3,1,3,-1,4,0,4,-3,1,-3,1,-5,-2;
print(A);
list Z=gaussred(A);   //construct P,U,S s.t. P*A=U*S
print(Z[1]);          //P
print(Z[2]);          //U
print(Z[3]);          //S
print(Z[4]);          //rank
print(Z[1]*A);        //P*A
print(Z[2]*Z[3]);     //U*S
@end smallexample
@c ---end content gaussred---

@c ------------------- gaussred_pivot -------------
@node gaussred_pivot, gauss_nf, gaussred, linalg_lib
@subsubsection gaussred_pivot
@cindex gaussred_pivot
@c ---content gaussred_pivot---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
gaussred_pivot(A); A any constant matrix

@item @strong{Return:}
list Z: Z[1]=P , Z[2]=U , Z[3]=S , Z[4]=rank(A)
@*gives n row reduced matrix S, a permutation matrix P and a
normalized lower triangular matrix U, with P*A=U*S

@item @strong{Note:}
with row pivoting

@end table
@strong{Example:}
@smallexample
@c skipped computation of example gaussred_pivot d2t_singular/linalg_lib.doc:462 
LIB "linalg.lib";
ring r=0,(x),dp;
matrix A[5][4] = 1, 3,-1,4,
2, 5,-1,3,
1, 3,-1,4,
0, 4,-3,1,
-3,1,-5,-2;
list Z=gaussred_pivot(A);  //construct P,U,S s.t. P*A=U*S
print(Z[1]);               //P
print(Z[2]);               //U
print(Z[3]);               //S
print(Z[4]);               //rank
print(Z[1]*A);             //P*A
print(Z[2]*Z[3]);          //U*S
@end smallexample
@c ---end content gaussred_pivot---

@c ------------------- gauss_nf -------------
@node gauss_nf, mat_rk, gaussred_pivot, linalg_lib
@subsubsection gauss_nf
@cindex gauss_nf
@c ---content gauss_nf---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
gauss_nf(A); A any constant matrix

@item @strong{Return:}
matrix; gauss normal form of A (uses gaussred)

@end table
@strong{Example:}
@smallexample
@c skipped computation of example gauss_nf d2t_singular/linalg_lib.doc:498 
LIB "linalg.lib";
ring r = 0,(x),dp;
matrix A[4][4] = 1,4,4,7,2,5,5,4,4,1,1,3,0,2,2,7;
print(gauss_nf(A));
@end smallexample
@c ---end content gauss_nf---

@c ------------------- mat_rk -------------
@node mat_rk, U_D_O, gauss_nf, linalg_lib
@subsubsection mat_rk
@cindex mat_rk
@c ---content mat_rk---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
mat_rk(A); A any constant matrix

@item @strong{Return:}
int, rank of A

@end table
@strong{Example:}
@smallexample
@c skipped computation of example mat_rk d2t_singular/linalg_lib.doc:524 
LIB "linalg.lib";
ring r = 0,(x),dp;
matrix A[4][4] = 1,4,4,7,2,5,5,4,4,1,1,3,0,2,2,7;
mat_rk(A);
@end smallexample
@c ---end content mat_rk---

@c ------------------- U_D_O -------------
@node U_D_O, pos_def, mat_rk, linalg_lib
@subsubsection U_D_O
@cindex U_D_O
@c ---content U_D_O---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
U_D_O(A); constant invertible matrix A

@item @strong{Return:}
list Z: Z[1]=P , Z[2]=U , Z[3]=D , Z[4]=O
@*gives a permutation matrix P,
@*a normalized lower triangular matrix U ,
@*a diagonal matrix D, and
@*a normalized upper triangular matrix O
@*with P*A=U*D*O

@item @strong{Note:}
Z[1]=-1 means that A is not regular (proc uses gaussred)

@end table
@strong{Example:}
@smallexample
@c skipped computation of example U_D_O d2t_singular/linalg_lib.doc:558 
LIB "linalg.lib";
ring r = 0,(x),dp;
matrix A[5][5] = 10, 4,  0, -9,  8,
-3, 6, -6, -4,  9,
0, 3, -1, -9, -8,
-4,-2, -6, -10,10,
-9, 5, -1, -6,  5;
list Z = U_D_O(A);              //construct P,U,D,O s.t. P*A=U*D*O
print(Z[1]);                    //P
print(Z[2]);                    //U
print(Z[3]);                    //D
print(Z[4]);                    //O
print(Z[1]*A);                  //P*A
print(Z[2]*Z[3]*Z[4]);          //U*D*O
@end smallexample
@c ---end content U_D_O---

@c ------------------- pos_def -------------
@node pos_def, hessenberg, U_D_O, linalg_lib
@subsubsection pos_def
@cindex pos_def
@c ---content pos_def---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
pos_def(A); A = constant, symmetric square matrix

@item @strong{Return:}
int:
@*1 if A is positive definit ,
@*0 if not,
@*-1 if unknown

@end table
@strong{Example:}
@smallexample
@c skipped computation of example pos_def d2t_singular/linalg_lib.doc:597 
LIB "linalg.lib";
ring r = 0,(x),dp;
matrix A[5][5] = 20,  4,  0, -9,   8,
4, 12, -6, -4,   9,
0, -6, -2, -9,  -8,
-9, -4, -9, -20, 10,
8,  9, -8,  10, 10;
pos_def(A);
matrix B[3][3] =  3,  2,  0,
2, 12,  4,
0,  4,  2;
pos_def(B);
@end smallexample
@c ---end content pos_def---

@c ------------------- hessenberg -------------
@node hessenberg, evnf, pos_def, linalg_lib
@subsubsection hessenberg
@cindex hessenberg
@c ---content hessenberg---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
hessenberg(M); matrix M

@item @strong{Assume:}
M constant square matrix

@item @strong{Return:}
matrix H; Hessenberg form of M

@end table
@strong{Example:}
@smallexample
@c skipped computation of example hessenberg d2t_singular/linalg_lib.doc:634 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
print(hessenberg(M));
@end smallexample
@c ---end content hessenberg---

@c ------------------- evnf -------------
@node evnf, eigenvals, hessenberg, linalg_lib
@subsubsection evnf
@cindex evnf
@c ---content evnf---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
evnf(e[,m]); ideal e, intvec m

@item @strong{Assume:}
ncols(e)==size(m)

@item @strong{Return:}
order eigenvalues e with multiplicities m

@end table
@c ---end content evnf---

@c ------------------- eigenvals -------------
@node eigenvals, minipoly, evnf, linalg_lib
@subsubsection eigenvals
@cindex eigenvals
@c ---content eigenvals---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
eigenvals(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
@format
list l; 
  ideal l[1];
    number l[1][i];  i-th eigenvalue of M
  intvec l[2]; 
    int l[2][i];  multiplicity of i-th eigenvalue of M
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example eigenvals d2t_singular/linalg_lib.doc:690 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
eigenvals(M);
@end smallexample
@c ---end content eigenvals---

@c ------------------- minipoly -------------
@node minipoly, jordan, eigenvals, linalg_lib
@subsubsection minipoly
@cindex minipoly
@c ---content minipoly---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
minpoly(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
@format
list l;  minimal polynomial of M
  ideal l[1]; 
    number l[1][i];  i-th root of minimal polynomial of M
  intvec l[2]; 
    int l[2][i];  multiplicity of i-th root of minimal polynomial of M
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example minipoly d2t_singular/linalg_lib.doc:726 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
minipoly(M);
@end smallexample
@c ---end content minipoly---

@c ------------------- jordan -------------
@node jordan, jordanbasis, minipoly, linalg_lib
@subsubsection jordan
@cindex jordan
@c ---content jordan---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
jordan(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
@format
list l;  Jordan data of M
  ideal l[1]; 
    number l[1][i];  eigenvalue of i-th Jordan block of M
  intvec l[2]; 
    int l[2][i];  size of i-th Jordan block of M
  intvec l[3]; 
    int l[3][i];  multiplicity of i-th Jordan block of M
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example jordan d2t_singular/linalg_lib.doc:764 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
jordan(M);
@end smallexample
@c ---end content jordan---

@c ------------------- jordanbasis -------------
@node jordanbasis, jordanmatrix, jordan, linalg_lib
@subsubsection jordanbasis
@cindex jordanbasis
@c ---content jordanbasis---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
jordanbasis(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
@format
list l:
  module l[1];  inverse(l[1])*M*l[1] in Jordan normal form
  intvec l[2]; 
    int l[2][i];  weight filtration index of l[1][i]
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example jordanbasis d2t_singular/linalg_lib.doc:799 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
list l=jordanbasis(M);
print(l[1]);
print(l[2]);
print(inverse(l[1])*M*l[1]);
@end smallexample
@c ---end content jordanbasis---

@c ------------------- jordanmatrix -------------
@node jordanmatrix, jordannf, jordanbasis, linalg_lib
@subsubsection jordanmatrix
@cindex jordanmatrix
@c ---content jordanmatrix---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
jordanmatrix(e,s,m); ideal e, intvec s, intvec m

@item @strong{Assume:}
ncols(e)==size(s)==size(m)

@item @strong{Return:}
@format
matrix J;  Jordan matrix with list(e,s,m)==jordan(J)
@end format

@end table
@strong{Example:}
@smallexample
@c skipped computation of example jordanmatrix d2t_singular/linalg_lib.doc:834 
LIB "linalg.lib";
ring R=0,x,dp;
ideal e=ideal(2,3);
intvec s=1,2;
intvec m=1,1;
print(jordanmatrix(e,s,m));
@end smallexample
@c ---end content jordanmatrix---

@c ------------------- jordannf -------------
@node jordannf,, jordanmatrix, linalg_lib
@subsubsection jordannf
@cindex jordannf
@c ---content jordannf---
Procedure from library @code{linalg.lib} (@pxref{linalg_lib}).

@table @asis
@item @strong{Usage:}
jordannf(M); matrix M

@item @strong{Assume:}
eigenvalues of M in basefield

@item @strong{Return:}
matrix J; Jordan normal form of M

@end table
@strong{Example:}
@smallexample
@c skipped computation of example jordannf d2t_singular/linalg_lib.doc:865 
LIB "linalg.lib";
ring R=0,x,dp;
matrix M[3][3]=3,2,1,0,2,1,0,0,3;
print(M);
print(jordannf(M));
@end smallexample
@c ---end content jordannf---
