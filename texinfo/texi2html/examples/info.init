
########## WORK IN PROGRESS ##################

#+##############################################################################
#
# info.init: convert to info
#
#    Copyright (C) 2008  Patrice Dumas <dumas@centre-cired.fr>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#    02110-1301  USA
#
#-##############################################################################

use Data::Dumper;

use strict;

$USE_NODES = 1;
$USE_SECTIONS = 0;
@EXPAND = ('info');
$EXTENSION = 'info';
$SHOW_MENU = 1;
$USE_SETFILENAME = 1;
$IGNORE_BEFORE_SETFILENAME = 1;
$NODE_NAME_IN_MENU = 1;
$SPLIT_INDEX = 0;
$SEPARATED_FOOTNOTES = 0;
$INLINE_CONTENTS = 1;
$SIMPLE_MENU = 1;
$MENU_SYMBOL = '*';
$USE_MENU_DIRECTIONS = 0;
$USE_ISO = 0;

$no_paragraph_commands{'anchor'} = 1;

%simple_map = %ascii_simple_map;
%simple_map_pre = %simple_map;
%simple_map_texi = %simple_map;

%things_map = %ascii_things_map;
%pre_map = %things_map;

$misc_command{'exdent'}->{'keep'} = 1;
$misc_command{'noindent'}->{'keep'} = 1;
$misc_command{'indent'}->{'keep'} = 1;

# sc and var upcase.
my @simple_quoted_commands = ('cite', 'code', 'command', 'env', 'file', 'kbd',
  'option', 'samp');
# slanted? 
my @asis_commands = ('asis', 'b', 'ctrl', 'dmn', 'i', 'math', 'sc', 't', 'r', 
  'slanted', 'var', 'titlefont', 'verb');
my @chevron_commands = ('key', 'indicateurl');

my %info_default_accent_commands = ();

foreach my $accent_command ('tieaccent', 'dotless', keys(%unicode_accents), keys(%accent_map))
{
     $info_default_accent_commands{$accent_command} = 1;
     $style_map{$accent_command} = { 'function' => \&info_default_accent };
}

foreach my $command (keys(%style_map))
{
    delete $style_map{$command}->{'attribute'} if (exists($style_map{$command}->{'attribute'}));
    delete $style_map{$command}->{'quote'} if (exists($style_map{$command}->{'quote'}));
    if (grep {$_ eq $command} @simple_quoted_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        $style_map{$command}->{'begin'} = '`';
        $style_map{$command}->{'end'} = "'";
        next;
    }
    elsif (grep {$_ eq $command} @asis_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        delete $style_map{$command}->{'begin'} if  (exists($style_map{$command}->{'begin'}));
        delete $style_map{$command}->{'end'} if  (exists($style_map{$command}->{'end'}));
    }
    if (grep {$_ eq $command} @chevron_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        $style_map{$command}->{'begin'} = '<';
        $style_map{$command}->{'end'} = '>';
        next;
    }
}

$style_map{'strong'}->{'begin'} = '*';
$style_map{'strong'}->{'end'} = '*';
$style_map{'dfn'}->{'begin'} = '"';
$style_map{'dfn'}->{'end'} = '"';
$style_map{'emph'}->{'begin'} = '_';
$style_map{'emph'}->{'end'} = '_';

foreach my $command (keys(%style_map))
{
    $style_map_pre{$command} = {};
    $style_map_texi{$command} = {};
    foreach my $key (keys(%{$style_map{$command}}))
    {
        $style_map_pre{$command}->{$key} = $style_map{$command}->{$key};
        $style_map_texi{$command}->{$key} = $style_map{$command}->{$key};
    }
}

$style_map{'uref'}->{'function'} = \&info_default_uref;
$style_map{'url'}->{'function'} = \&info_default_uref;

sub info_default_uref($$)
{
    shift;
    my $args = shift;
    my $url = shift @$args;
    my $text = shift @$args;
    my $replacement = shift @$args;
    #$url =~ s/\s*$//;
    #$url =~ s/^\s*//;
    $url = main::normalise_space($url);
    $replacement = '' if (!defined($replacement));
    $replacement = main::normalise_space($replacement);
    return $replacement if ($replacement ne '');
    $text = '' if (!defined($text));
    $text = main::normalise_space($text);
    return "`$url'" if ($text eq '');
    return "$text ($url)";
}

$style_map{'email'}->{'function'} = \&info_default_email;
sub info_default_email($$)
{
    my $command = shift;
    my $args = shift;
    my $mail = shift @$args;
    my $text = shift @$args;
    $mail = main::normalise_space($mail);
    $text = '' if (!defined($text));
    $text = main::normalise_space($text);
    $mail = "<$mail>";
    return $mail unless ($text ne '');
    return "$text $mail";
}

$style = \&info_default_style;
$print_page_head   = \&info_default_print_page_head;
$toc_body = \&info_default_noop;
$about_body = \&info_default_noop;
$copying_comment   = \&info_default_copying_comment;
$element_heading   = \&info_default_element_heading;
$heading           = \&info_default_heading;
$normal_text       = \&info_default_normal_text;
$paragraph         = \&info_default_paragraph;
$preformatted      = \&info_default_preformatted;
$empty_line               = \&info_default_empty_line;
# maybe should not be called from the main program?
$print_page_foot       = \&info_default_print_page_foot;
$print_Top_footer      = \&info_default_print_Top_footer;
$print_section         = \&info_default_print_section;
$end_section           = \&info_default_end_section;
$one_section           = \&info_default_one_section;
$begin_format_texi     = \&info_default_begin_format_texi;
$begin_style_texi      = \&info_default_begin_style_texi;
$begin_paragraph_texi  = \&info_default_begin_paragraph_texi;
$simple_command        = \&info_default_simple_command;
$thing_command         = \&info_default_thing_command;
$begin_special_region  = \&info_default_begin_special_region;
$end_special_region    = \&info_default_end_special_region;
$anchor_label          = \&info_default_anchor_label;
$menu_link             = \&info_default_menu_link;
$menu_command          = \&info_default_menu_command;
$complex_format        = \&info_default_complex_format;
$quotation             = \&info_default_quotation;
$unknown               = \&info_default_misc_commands;

sub info_default_accent($$$)
{
    my @args = @_;
    my $command = shift;
    my $args = shift;
    my $text = $args->[0];
    my $style_stack = shift;
    my $state = shift;

    if (scalar(@$style_stack) and $info_default_accent_commands{$style_stack->[-1]})
    {
        return &t2h_default_ascii_accent(@args);
    }
    my $result = &t2h_default_ascii_accent(@args);
    return info_default_store_text($state,$result,'accents_commands');
#    return '' if info_default_store_text($state,$result,'accents_commands');
#    return $result;
}

sub info_default_noop
{
    return '';
}

sub info_default_copying_comment($$$$)
{
    my $copying_lines = shift;
    my $copying_text = shift;
    my $copying_no_texi = shift;
    my $copying_simple_text = shift;
    return '' if ($copying_text eq '');
    return $copying_text;
}

# FIXME initialize
my %info_default_state_map = ();
my $info_default_state;
my $info_default_offset_in_file;
my @info_default_pending_tags;

sub info_default_reset_state($)
{
    my $info_state = shift;
    $info_state->{'top'} = {};
    $info_state->{'current'} = $info_state->{'top'};
}

sub info_default_iterator_next($$$)
{
   my $current_command = shift;
   my $command_index = shift;
   my $command_close = shift;
   
   my $sub_command = $current_command->{'content'}->[$command_index];
   
   if ($sub_command->{'content'} and !$command_close)
   {
      return ($sub_command, 0, 0);
   }
   
   if ($current_command->{'content'}->[$command_index+1])
   {
      return ($current_command, $command_index+1, 0);
   }
   elsif (defined($current_command->{'parent'}))
   {
      return ($current_command->{'parent'}, $current_command->{'index_in_parent'}, 1);
   }
   else
   {
      return (undef, undef, undef);
   }
}

my $info_default_max_column = 72;

# Beware that there is a pending word if the text doesn't end with
# a space
sub info_default_process_text($$$$;$)
{
   my $text = shift;
   my $line_char_counter = shift;
   my $pending_spaces = shift;
   my $pending_word = shift;
   my $indent_text = shift;
   $indent_text = '' if (!defined($indent_text));
   my $line_passed = 0;
   my $result = '';

my $line_char_counter_text = 'undef';
$line_char_counter_text = "$line_char_counter" if (defined($line_char_counter));
print STDERR "process_text(indent `$indent_text') line_char_counter $line_char_counter_text `$text'\n";
   if (!defined($line_char_counter))
   {
       my $chomped_text = $text;
       $line_passed = 1 if (chomp($chomped_text));
       return ($line_char_counter, $pending_spaces, $pending_word, $line_passed, $text);
   }
   
   while ($text ne '')
   {
      if ($text =~ s/^(\s+)//)
      {
          my $new_spaces = $1;
          if (defined($pending_word))
          {
             if ($line_char_counter == 0)
             {
                 $pending_spaces = $indent_text . $pending_spaces;
             }
             $result .= $pending_spaces . $pending_word;
             $line_char_counter += length($pending_spaces)+length($pending_word);
             $pending_spaces = $new_spaces;
             $pending_word = undef;
         }
         else
         {
             $pending_spaces .= $new_spaces;
         }
         if (length($pending_spaces) +  $line_char_counter > $info_default_max_column)
         {
             $pending_spaces = substr($pending_spaces, $info_default_max_column - $line_char_counter +1);
             $result .= "\n";
             $line_passed++;
             $line_char_counter = 0;
         }
      }
      elsif ($text =~ s/^([^\s]+)//)
      {
         my $word = $1;
         $pending_word = '' if (!defined($pending_word));
         $pending_word .= $word;
         if (length($pending_spaces)+length($pending_word) + $line_char_counter > $info_default_max_column)
         {
             $pending_spaces = '';
             $result .= "\n";
             $line_passed++;
             $line_char_counter = 0;
         }
      }
   }
   return ($line_char_counter, $pending_spaces, $pending_word, $line_passed, $result)
}

sub info_default_skip_spaces($$$)
{
    my $current = shift;
    my $index = shift;
    my $close = shift;

    while(1)
    {
       my ($current_next, $index_next, $close_next) = info_default_iterator_next($current, $index, $close);
        return ($current, $index, $close) if (!defined($close_next) or $close_next);
        my $content = $current_next->{'content'}->[$index_next];
        if (defined($content->{'begin'}))
        {
            $content->{'begin'} =~ s/^\s*//;
            return ($current, $index, $close) if ($content->{'begin'} ne '');
        } 
        if (defined($content->{'content'}))
        { # non empty commands stop space skipping, even if they contain 
          # only spaces, like @asis{ }
            return ($current, $index, $close);
        }
        if (defined($content->{'text'}))
        {
            $content->{'text'} =~ s/^\s*//;
            return ($current, $index, $close) if ($content->{'text'} ne '');
        }
        ($current, $index, $close) = ($current_next, $index_next, $close_next);
    }
}

sub info_default_store_pending($$$;$)
{
   my $line_char_counter = shift;
   my $pending_spaces = shift;
   my $pending_word = shift;
   my $indent_text = shift;
   $indent_text = '' if (!defined($indent_text));
   
   if (defined($line_char_counter) and $line_char_counter == 0)
   {
      $pending_spaces = $indent_text . $pending_spaces;
   }
   my $result = $pending_spaces;
   $pending_spaces = '';
   if (defined($pending_word))
   {
      $result .= $pending_word;
      $pending_word = undef;
   }
   $line_char_counter += length($result) if (defined($line_char_counter));
   return ($line_char_counter, $pending_spaces, $pending_word, $result);
}

my $info_default_end_sentence_character = quotemeta('.');
my $info_default_indent_length = 5;
my $info_default_para_indent_length = 3;

my %info_default_indented_commands = ( 'quotation' => 1 );
foreach my $complex_command (keys (%{$complex_format_map}))
{
    $info_default_indented_commands{$complex_command} = 1;
}

sub info_default_output($)
{
   my $info_state = shift;
   my $result = '';

   if (!defined($info_state->{'current'}->{'command'}))
   {
      print STDERR "Storing the stack\n";
      print STDERR "" . Data::Dumper->Dump([$info_state->{'top'}]);
      my $characters_count;
      my $in_main_document;
      $in_main_document = 1 if ($info_state->{'state'}->{'inside_document'} and !$info_state->{'state'}->{'duplicated'});
      $info_state->{'offset_in_file'} = $info_default_offset_in_file if ($in_main_document);
      ($characters_count, $result) = info_default_process_content($info_state->{'top'}, $info_state);
      $info_state->{'offset_in_file'} += $characters_count;
      $info_default_offset_in_file = $info_state->{'offset_in_file'} if ($in_main_document);
      info_default_reset_state($info_state);
   }
   return $result;
}

sub info_default_process_content($$)
{
   my $current_command = shift;
   my $info_state = shift;

   my $length = 0;
   my $result = '';

   my $line_char_counter;
   my $pending_spaces = '';
   my $pending_word;
   my $preformatted = 0;
   my $indent_level = 0;
   my $exdent_line = 0;
   my $line_beginning = 0;
   my $indent_para;
   my $noindent_para;

   my ($current, $index, $close) = ($current_command, 0, 0);

   #print STDERR "info_default_process_content: $current_command\n";
   while(1)
   {
      last if (!defined($current));
      my $content = $current->{'content'}->[$index];
      my $text_added = '';
      my $line_passed = 0;

my $line_char_counter_text = 'undef';
$line_char_counter_text = "$line_char_counter" if (defined($line_char_counter));
my $text_length = '';
$text_length = $content->{'length'} if defined($content->{'length'});
my $text_command = '';
$text_command = $content->{'command'} if defined($content->{'command'});
      print STDERR "($text_command|$text_length|$close) preformatted $preformatted, line_beginning $line_beginning, indent_level $indent_level exdent_line $exdent_line line_char_counter $line_char_counter_text\n";
my $pending_word_text = 'undef';
$pending_word_text = "`$pending_word'" if (defined($pending_word));
print STDERR "         spaces: `$pending_spaces' word: $pending_word_text\n";

      if ($close)
      {
          if (defined($content->{'end'}))
          {
              $text_added = $content->{'end'};
          }
          # if ending a paragraph, go straight to the text addition 
          # without processing of the end of lines. Same if ending a 
          # quotation or an @example
          if (defined($content->{'command'}))
          {
              if ($info_default_indented_commands{$content->{'command'}})
              {
                  $indent_level--;
                  # don't do that for quotations, quotations already have
                  # end of paragraph end of lines.
                  if ($indent_level > 0 and $complex_format_map->{$content->{'command'}})
                  {
                     $text_added .= "\n";
                  }
                  #$line_beginning = 1;
                  goto new_text;
              }
              if ($content->{'command'} eq 'paragraph')
              {
                  $pending_spaces = '';
                  $line_char_counter = undef;
                  $indent_para = undef;
                  $noindent_para = undef;
                  $text_added = $content->{'end'};
                  $info_state->{'waiting_for_line'} = 1;
                  goto new_text;
              }
              elsif ($content->{'command'} eq 'preformatted')
              {
                  $preformatted--;
                  $line_beginning = 0;
              }
          }
      }
      else
      {
          if ($content->{'command'})
          { 
              if ($content->{'command'} eq 'anchor')
              {
                  my $pending;
                  ($line_char_counter, $pending_spaces, $pending_word, $pending) = info_default_store_pending($line_char_counter, $pending_spaces, $pending_word, ' ' x ($indent_level * $info_default_indent_length));
                  if (defined($line_char_counter) or ($preformatted) or $pending !~ /^\s*$/)
                  {
                      $length += length($pending);
                      $result .= $pending;
                  }
                  $content->{'anchor_reference'}->{'info_offset'} = $length + $info_state->{'offset_in_file'};
                  push @info_default_pending_tags, $content->{'anchor_reference'};
              }
              elsif ($content->{'command'} eq '*' and !$preformatted)
              {
                 if (defined($pending_word))
                 {
                    $text_added .= $pending_spaces . $pending_word;
                    $pending_word = undef;
                 }
                 $pending_spaces = '';
                 $line_char_counter = 0;
                 $text_added .=  $content->{'text'};
                 ($current, $index, $close) = info_default_skip_spaces($current, $index, $close);
                 # FIXME new line
                 goto new_text;
              }
              elsif ($content->{'command'} eq 'paragraph')
              {
                  ($current, $index, $close) = info_default_skip_spaces($current, $index, $close);
                  $line_char_counter = 0;
                  $content->{'begin'} = ' ' x $info_default_para_indent_length if 
                    (!($content->{'top_stack'} eq 'quotation') and ($indent_para or (!$noindent_para and  $content->{'paragraph_in_element_nr'})));
              }
              elsif ($content->{'command'} eq 'preformatted')
              {
                  $preformatted++;
                  $line_beginning = 1;
                  $exdent_line = 0;
              }
              elsif ($content->{'command'} eq 'exdent' and $preformatted)
              {
                  $exdent_line = 1;
              }
              elsif ($content->{'command'} eq 'indent')
              {
                  $indent_para = 1;
              }
              elsif ($content->{'command'} eq 'noindent')
              {
                  $noindent_para = 1;
              }
              if ($info_default_indented_commands{$content->{'command'}})
              {
                  $indent_level++;
              }
          }

          if (defined($content->{'begin'}))
          {
              $text_added .= $content->{'begin'};
          }

          if ($content->{'length'})
          {
              if (defined($line_char_counter))
              {
                  if (chomp($content->{'text'}))
                  {
                      $content->{'text'} =~ s/(\s*)$/ /;
                      if ($content->{'text'} =~ /$info_default_end_sentence_character $/)
                      {
                          $content->{'text'} .= ' ';
                      }
                  }
                  $text_added .= $content->{'text'};
              } # ignore spaces outside of paragraphs and preformatted
              else
              {
                  my $chomped_text = $content->{'text'};
                  if ($chomped_text =~ /^\s*$/ and chomp($chomped_text))
                  {
                      if ($info_state->{'waiting_for_line'})
                      {
                           $text_added ="\n";
                           $info_state->{'waiting_for_line'} = 0;
                      }
                  }
                  else
                  { # may this happen?
                       $text_added .= $content->{'text'};
                       $info_state->{'waiting_for_line'} = 0;
                  }
              }
              
              
# unless (!defined($line_char_counter) and !$preformatted and $content->{'text'} =~ /^\s*$/);
          }
      }
      if (!$preformatted)
      {
          ($line_char_counter, $pending_spaces, $pending_word, $line_passed, $text_added) = info_default_process_text($text_added, $line_char_counter, $pending_spaces, $pending_word, ' ' x ($indent_level * $info_default_indent_length)) if ($text_added ne '');
      }
      else
      {
print STDERR "text_added `$text_added' line_beginning $line_beginning\n";
          if ($text_added ne '' and $line_beginning)
          {
              my $used_indent_level = $indent_level;
              $used_indent_level-- if ($indent_level and $exdent_line);
              $exdent_line = 0;
print STDERR "                     indent_level $indent_level\n";
              $text_added =  ' ' x ($used_indent_level * $info_default_indent_length) 
                             .$text_added;
              $line_beginning = 0;
          }
      }
    new_text:
print STDERR "ADDING `$text_added'\n" if ($text_added ne '');
      $result .= $text_added;
      $length += length($text_added);
      if ($preformatted)
      {
          my $chomped_text = $text_added;
          $line_beginning = 1 if (chomp($chomped_text));
      }

    iterate:
      ($current, $index, $close) = info_default_iterator_next($current, $index, $close);
   }
   return ($length, $result);
}

my $state_nr = 0;
sub info_default_get_state($)
{
   my $state = shift;
   if (!exists $info_default_state_map{$state})
   {
print STDERR "NEW state\n";
      my ($current_command, $top_stack);
      $info_default_state_map{$state} = {};
      info_default_reset_state($info_default_state_map{$state});
      $info_default_state_map{$state}->{'nr'} = $state_nr;
      $info_default_state_map{$state}->{'state'} = $state;
      $state_nr++;
   }
my $text_inside = 0;
$text_inside = $state->{'inside_document'} if (defined($state->{'inside_document'}));
my $text_outside = 0;
$text_outside = $state->{'outside_document'} if (defined($state->{'outside_document'}));
my $text_duplicate = 0;
$text_duplicate = 0;
$text_duplicate =  $state->{'duplicated'} if (defined($state->{'duplicated'}));
print STDERR "RETURN state $state $info_default_state_map{$state} $text_inside $text_outside $text_duplicate $info_default_state_map{$state}->{'nr'}\n";
   return $info_default_state_map{$state};
}

sub info_default_open_command($$$$$)
{
   my $state = shift;
   my $command = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;

   my $index = 0;
   
   $info_default_state = info_default_get_state($state);
   # index in the parent content list
   $index = scalar(@{$info_default_state->{'current'}->{'content'}}) 
       if (defined($info_default_state->{'current'}->{'content'}));
   my $new_command = {'command' => $command, 'parent' => $info_default_state->{'current'}, 'index_in_parent' => $index };
   push @{$info_default_state->{'current'}->{'content'}}, $new_command;
   $info_default_state->{'current'} = $new_command;
   print STDERR "Opened $command ". 
     "\n";
#     Data::Dumper->Dump([$info_default_state->{'top'}]);
}

sub info_default_close_command($$$$$$$$$;$)
{
   my $state = shift;
   my $command_stack = shift;
   my $command = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;
   my $begin = shift;
   my $text = shift;
   my $end = shift;
   my $additional_entries = shift;

   $no_open = 0 if (!defined($no_open));
   $no_close = 0 if (!defined($no_close));
   $state = $Texi2HTML::THISDOC{'state'} if (!defined($state));
   #print STDERR "" . Data::Dumper->Dump([$current_command]);
   print STDERR "Closing $command ".
     "\n";
   if (!defined($info_default_state->{'current'}))
   {
      print STDERR "info_default_state->{'current'} not defined\n";
   }
   elsif (!defined($info_default_state->{'current'}->{'command'}))
   {
      print STDERR "info_default_state->{'current'}->{'command'} not defined\n";
   }
   elsif ($command ne $info_default_state->{'current'}->{'command'})
   {
     print STDERR "Was waiting for $info_default_state->{'current'}->{'command'}\n";
   }
#     Data::Dumper->Dump([$info_default_state->{'top'}]);
   #return if $no_close;
   $info_default_state->{'current'}->{'no_close'} = 1 if ($no_close);
   $info_default_state->{'current'}->{'begin'} = $begin;
   $info_default_state->{'current'}->{'text'} = $text;
   $info_default_state->{'current'}->{'end'} = $end;
   if (defined($additional_entries))
   {
       foreach my $key (keys(%$additional_entries))
       {
           $info_default_state->{'current'}->{$key} = $additional_entries->{$key};
       }
   }

   $info_default_state->{'current'} = $info_default_state->{'current'}->{'parent'};

   return info_default_output($info_default_state);
}

sub info_default_store_text($$;$)
{
   my $state = shift;
   my $text = shift;
   my $command = shift;
#   $state = $Texi2HTML::THISDOC{'state'} if (!defined($state));

   my $info_state = info_default_get_state($state);
   my $len = length($text);
   # When state is 'outside_document' it means that we are outputting some
   # text as part of special regions but not inside the document.
   # when state is duplicated, it may mean that we risk storing some
   # output that is not directly outputted to the document, for example
   # node names.
   # however in some cases the state is duplicated, but we want to store
   # the text. In that case the command is used.
#   return 0 if (!(defined($command) and $command eq 'menu_entry') and ((!$state->{'inside_document'} and !$state->{'outside_document'}) or ($state->{'duplicated'} and $state->{'inside_document'})));
   return '' if ($len == 0 and !defined($command));
   print STDERR "Storing text($len) $text\n";
   my $text_stored = {'text' => $text, 'length' => $len};
   $text_stored->{'command'} = $command if (defined($command));
   push @{$info_state->{'current'}->{'content'}}, $text_stored;
   return  info_default_output($info_state);
#   return 1;
}

sub info_default_begin_format_texi($$$)
{
   my $command = shift;
   my $line = shift;
   my $state = shift;
   info_default_open_command($state,$command, undef, undef, undef);
   return $line;
}

sub info_default_begin_style_texi($$$$)
{
   my $command = shift;
   my $state = shift;
   my $stack = shift;
   my $real_style_command = shift;
   info_default_open_command($state,$command, undef, undef, undef)
     unless ($info_default_accent_commands{$command});
#      if ($real_style_command);
}

sub info_default_begin_paragraph_texi($$$)
{
   my $command = shift;
   my $paragraph_macros = shift;
   my $paragraph_command = shift;
   print STDERR "begin_paragraph $command\n";
   my $state = shift;
   my $stack = shift;
   info_default_open_command($state,$command, undef, undef, undef);
   foreach my $style_command (@$paragraph_macros)
   {
     print STDERR "para stack: $style_command->{'style'}\n";
     info_default_open_command($state,$style_command->{'style'}, undef, undef, undef);
     $info_default_state->{'current'}->{'no_open'} = 1;
   }
}

sub info_default_simple_command($$$$)
{
    my $command = shift;
    my $in_preformatted = shift;
    my $line_nr = shift;
    my $state = shift;

    my $result = $simple_map{$command};
    return info_default_store_text($state,$result,$command);
    #return '' if info_default_store_text($state,$result,$command);
    #return $result;
}


sub info_default_thing_command($$$$$)
{
    my $command = shift;
    my $text = shift;
    my $in_preformatted = shift;
    my $line_nr = shift;
    my $state = shift;

    my $result = $things_map{$command};
    return info_default_close_command($state, undef, $command, undef, undef, $line_nr, $result, $text, '');
#    return $result . $text;
}


sub info_default_style($$$$$$$$$)
{
   my $style = shift; 
   my $command = shift;
   my $text = shift;
   my $args = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;
   my $state = shift;
   my $command_stack = shift;

   my $begin = '';
   my $end = '';

   if (defined($style->{'function'}))
   {
      $text = &{$style->{'function'}}($command, $args, $command_stack, $state, $line_nr);
   }
   if (defined($style->{'begin'}) and !$no_open)
   {
      $begin = $style->{'begin'};
   }
   if (defined($style->{'end'}) and !$no_close)
   {
      $end = $style->{'end'};
   }
   unless($state->{'remove_texi'} or $special_style{$command} or ($command eq 'cmd_line') or $info_default_accent_commands{$command})
   {
      return info_default_close_command($state, $command_stack, $command, $no_close, $no_open, $line_nr, $begin, $text, $end);
   }
   return $begin.$text.$end;
}

sub info_default_print_page_head($)
{
    my $fh = shift;
    my $setfilename = $Texi2HTML::THISDOC{'setfilename'} if (defined($Texi2HTML::THISDOC{'setfilename'}));
    $setfilename = $Texi2HTML::THISDOC{'file_base_name'}.$EXTENSION if (!defined($setfilename));
    #my $result = "This is $setfilename, produced by $Texi2HTML::THISDOC{program} from $Texi2HTML::THISDOC{'input_file_name'}.\n\n";
    # this is wrong, $Texi2HTML::THISDOC{'input_file_name'} should be used 
    # directly, but then tests are not reproducible in out of source builds
    my $basename = $Texi2HTML::THISDOC{'input_file_name'};
    $basename =~ s/^.*\///;
    my $result = "This is $setfilename, produced by makeinfo version 4.13 from $basename. ";
    my $dummy;
    ($dummy, $dummy, $dummy, $dummy, $result) = info_default_process_text($result, 0, '', undef);
    $result .= "\n\n";
    $result .= "$Texi2HTML::THISDOC{'copying_comment'}";
    $info_default_offset_in_file = length($result);
    @info_default_pending_tags = ();
    print $fh $result;
}

my $info_default_paragraph_in_element_nr;

sub info_default_paragraph($$$$$$$$$$$$)
{
    my $text = shift;
    my $align = shift;
    my $indent = shift;
    my $paragraph_command = shift;
    my $paragraph_command_formatted = shift;
    my $paragraph_number = shift;
    my $format = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $command_stack_at_end = shift;
    my $command_stack_at_begin = shift;

    my $top_stack = '';
    $top_stack = $command_stack_at_begin->[-1] if (scalar (@$command_stack_at_begin));

    $info_default_paragraph_in_element_nr++;
    return info_default_close_command(undef, undef, 'paragraph', undef, undef, undef, '', undef, "\n", {'paragraph_in_element_nr' => ($info_default_paragraph_in_element_nr -1), 'top_stack' => $top_stack});
}

sub info_default_preformatted($$$$$$$$$$$$)
{
    my $text = shift;
    my $pre_style = shift;
    my $class = shift;
    my $leading_command = shift;
    my $leading_command_formatted = shift;
    my $preformatted_number = shift;
    my $format = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $command_stack_at_end = shift;
    my $command_stack_at_begin = shift;

#    if (defined($preformatted_number) and defined($$preformatted_number))
#    {
#        $$preformatted_number++;
#    }
    # a paragraph after a preformatted is indented. So looks like 
    # preformatted count as paragraphs.
    $info_default_paragraph_in_element_nr++;
    return info_default_close_command(undef, undef, 'preformatted', undef, undef, undef, undef, undef, undef);
} 


my %default_info_level_to_symbol = (
  0 => '*',
  1 => '*',
  2 => '=',
  3 => '-',
  4 => '.'
);

sub info_default_element_heading($$$$$$$$$$$$)
{
    my $element = shift;
    my $command = shift;
    my $texi_line = shift;
    my $line = shift;
    my $in_preformatted = shift;
    my $one_section = shift;
    my $element_heading = shift;
    my $first_in_page = shift;
    my $is_top = shift;
    my $previous_is_top = shift;
    my $command_line = shift;
    my $element_id = shift;
    my $new_element = shift;

    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    if ($new_element and ($element ne $new_element or !$element->{'node'}))
    {
        die "There is a new element, but element $element->{'texi'} is not a node or not the new element\n";
    }
    return &$heading($element, $command, $texi_line, $line, $in_preformatted, $one_section, $element_heading) unless ($new_element);

print STDERR "HHHHHHHHHHHHHHH node $info_state->{'nr'}\n";
    my $before = '';
    if ($info_state->{'waiting_for_line'})
    {
       $before = "\n";
       $info_default_offset_in_file += length($before);
       $info_state->{'waiting_for_line'} = 0;
    }
    $element->{'info_offset'} = $info_default_offset_in_file;
    push @info_default_pending_tags, $element;
    my $result = "\x{1F}\nFile: $Texi2HTML::THIS_ELEMENT->{'file'},  Node: $element->{'text'}";
    if (defined($Texi2HTML::THIS_ELEMENT->{'NodeNext'}))
    {
       $result .= ','.&$I('  Next: %{node_next}', {'node_next' => $Texi2HTML::THIS_ELEMENT->{'NodeNext'}->{'text'}});
    }
    if (defined($Texi2HTML::THIS_ELEMENT->{'NodePrev'}))
    {
       $result .= ','.&$I('  Prev: %{node_prev}', {'node_prev' => $Texi2HTML::THIS_ELEMENT->{'NodePrev'}->{'text'}});
    }
    if (defined($Texi2HTML::THIS_ELEMENT->{'NodeUp'}))
    {
       $result .= ','.&$I('  Up: %{node_up}', {'node_up' => $Texi2HTML::THIS_ELEMENT->{'NodeUp'}->{'text'}});
    }
    $result .= "\n\n";
    $info_default_offset_in_file += length($result);
    return $before.$result;
}

sub info_default_heading($$$$$;$$)
{
    my $element = shift;
    my $command = shift;
    my $texi_line = shift;
    my $line = shift;
    my $in_preformatted = shift;
    my $one_section = shift;
    my $element_heading = shift;

    die "Heading called for a node\n" if ($element->{'node'});
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
print STDERR "HHHHHHHHHHHHHHH section $info_state->{'nr'}\n";
    $info_default_paragraph_in_element_nr = 0;
    my $text = "$element->{'text'}";
    # to do the same than makeinfo a trailing dot in section number is removed
    $text =~ s/^(\w+)\. /$1 /;
    my $heading = $text . "\n" . 
       ($default_info_level_to_symbol{$element->{'level'}} x length($text)) . "\n\n";
    if ($info_state->{'waiting_for_line'})
    {
       $heading = "\n" .$heading;
       $info_state->{'waiting_for_line'} = 0;
    }
    # FIXME use state
    $info_default_offset_in_file += length($heading);
    return $heading;
}

sub info_default_normal_text($$$$$$;$)
{
   my $text = shift;
   my $in_raw_text = shift; # remove_texi
   my $in_preformatted = shift;
   my $in_code = shift;
   my $in_simple = shift;
   my $style_stack = shift;
   my $state = shift;

#Data::Dumper->Dump([$state]);

#print STDERR "info_default_normal_text $text $in_preformatted $in_code \n";
   $text = uc($text) if (in_cmd($style_stack, 'sc'));
#   $text = &$protect_text($text) unless($in_raw_text);
   if (! $in_code and !$in_preformatted)
   {
       $text =~ s/---/\x{1F}/g;
       $text =~ s/--/-/g;
       $text =~ s/\x{1F}/--/g;
       $text =~ s/``/"/g;
       $text =~ s/\'\'/"/g;
   }
   else
   {
       # to be like texinfo
#       my $special_code = 0;
#       $special_code = 1 if (in_cmd($style_stack, 'code') or 
#           in_cmd($style_stack, 'example') or in_cmd($style_stack, 'verbatim'));
#       $text =~ s/'/\&rsquo\;/g unless ($special_code and exists($main::value{'txicodequoteundirected'}));
#       $text =~ s/`/\&lsquo\;/g unless ($special_code and exists($main::value{'txicodequotebacktick'}));
   }
   return info_default_store_text($state,$text);
   # We never store in the stack text in raw text (remove_texi).
#   unless ($in_raw_text)
#   {
#      return '' if (info_default_store_text($state,$text));
#   }
#   return $text;
}

# this is not called in preformatted
sub info_default_empty_line($$)
{
    my $text = shift;
    my $state = shift;
    #ignore the line if it just follows a deff
    #return '' if ($state->{'deff_line'});
    return info_default_store_text($state,$text);
#    return '';
}

# change interface?
sub info_default_anchor_label($$$)
{
    my $id = shift;
    my $anchor_text = shift;
    my $anchor_reference = shift;
    # give it as an argument?
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state($state);
    #return if (!$state->{'inside_document'} and !$state->{'outside_document'});
    print STDERR "Storing anchor $anchor_reference->{'text'}\n";
    my $anchor_stored = {'command' => 'anchor', 'anchor_reference' => $anchor_reference};
    push @{$info_state->{'current'}->{'content'}}, $anchor_stored;
    return info_default_output($info_state);
}

sub info_default_acronym_like($$$$$$)
{
    my $command = shift;
    my $acronym_texi = shift;
    my $acronym_text = shift;
    my $with_explanation = shift;
    my $explanation_lines = shift;
    my $explanation_text = shift;
    my $explanation_simply_formatted = shift;

   if ($with_explanation)
   {
       return "$acronym_text ($explanation_text)";
   }
   else
   {
       return "$acronym_text";
   }
}


sub info_default_print_page_foot($)
{
   my $fh = shift;
   # makeinfo seems to add systematically an additional \n, done just below
   print $fh "\n\x{1F}\nTag Table:\n";
   # 
   foreach my $element (@info_default_pending_tags)
   {
      my $prefix;
      $prefix = 'Node' if ($element->{'node'});
      $prefix = 'Ref' if ($element->{'anchor'});
      print $fh "$prefix: $element->{'text'}\x{7F}$element->{'info_offset'}\n";
   }
   print $fh "\x{1F}\nEnd Tag Table\n";
}

sub info_default_print_Top_footer($$$)
{
    my $fh = shift;
    my $end_page = shift;
    my $element = shift;
    if ($end_page)
    {
        &$print_page_foot($fh);
    }
}

sub info_default_print_section
{
    my $fh = shift;
    my $first_in_page = shift;
    my $previous_is_top = shift;
    my $element = shift;
    my $nw = main::print_lines($fh);
}

sub info_default_end_section($$$)
{
    my $fh = shift;
    my $end_foot_navigation = shift;
    my $element = shift;
}

sub info_default_one_section($$)
{
    my $fh = shift;
    my $element = shift;
    &$print_section($fh, 1, 0, $element);
    &$print_page_foot($fh);
}

sub info_default_begin_special_region($$$)
{
    my $region = shift;
    my $state = shift;
    my $lines = shift;
    if ($state->{'outside_document'})
    {
        $info_default_paragraph_in_element_nr = 0;
    }
}

sub info_default_end_special_region($$$)
{
    my $region = shift;
    my $state = shift;
    my $text = shift;
    my $info_state = info_default_get_state ($state);
    my $end = '';
    if ($info_state->{'waiting_for_line'})
    {
       $end = "\n";
       $info_state->{'offset_in_file'} += length($end);
       $info_state->{'waiting_for_line'} = 0;
    }
    return $text.$end;
}

sub info_default_menu_link($$$$$$$$)
{
    my $entry = shift;
    my $state = shift;
    my $href = shift;
    my $node = shift;
    my $title = shift;
    my $ending = shift;
    my $has_title = shift;
    my $command_stack = shift;
    my $preformatted = shift;

    $title = '' unless ($has_title);
    $title .= ':' if ($title ne '');
    my $result = "$MENU_SYMBOL$title$node$ending";
#print STDERR "$result return 0 if ((!$state->{'inside_document'} and !$state->{'outside_document'}) or ($state->{'duplicated'} and $state->{'inside_document'}))\n";
    return info_default_store_text($state,$result,'menu_entry');
#    return '' if info_default_store_text($state,$result,'menu_entry');
#    #print STDERR "GGGGGGGGGG ${ending} GGGGGGG $result\n";
#    return $result;
}

# not used, menu is a normal preformatted command
#sub info_default_menu_command($$$)
#{
#    my $format = shift;
#    my $text = shift;
#    my $in_preformatted = shift;
#print STDERR "MENU $format\n";
#    return info_default_close_command(undef, $format, undef, undef, undef, "* Menu:\n", undef, "\n");
#}   

sub info_default_complex_format($$)
{
    my $name = shift;
    my $text = shift;
    my ($begin, $end);
    if ($name eq 'menu')
    {
        $begin = "* Menu:\n\n";
        $end = "\n";
    }
    return info_default_close_command(undef, undef, $name, undef, undef, undef, $begin, undef, $end);
}

sub info_default_quotation($$$$)
{
    my $command = shift;
    my $text = shift;
    my $argument_text = shift;
    my $argument_text_texi = shift;

    return info_default_close_command(undef, undef, $command, undef, undef, undef, undef, undef, undef);
}

sub info_default_misc_commands($$$$$)
{
    my $command = shift;
    my $line = shift;
    my $pass = shift;
    my $stack = shift;
    my $state = shift;

    return ($line, 0, undef, undef) unless ($pass == 2);
    return ($line, 0, undef, undef) unless ($command eq 'exdent' or $command eq 'noindent' or $command eq 'indent');
    my ($result_line, $text, $args) = &$preserve_misc_command ($line, $command);
    # FIXME the information may need to be kept in the info_state
    # if processing outside of an environment
    info_default_store_text($state,'',$command);
#print STDERR "ZZZZZZZZZZZZZZz `$result_line' `$text'\n";
    return ($result_line, 1, '', undef);
}

1;
