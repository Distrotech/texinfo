
########## WORK IN PROGRESS ##################

#+##############################################################################
#
# info.init: convert to info
#
#    Copyright (C) 2008  Patrice Dumas <dumas@centre-cired.fr>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#    02110-1301  USA
#
#-##############################################################################

use Data::Dumper;

use strict;

$Data::Dumper::Maxdepth = 12;

$USE_NODES = 1;
$USE_SECTIONS = 0;
@EXPAND = ('info');
$EXTENSION = 'info';
$SHOW_MENU = 1;
$USE_SETFILENAME = 1;
$IGNORE_BEFORE_SETFILENAME = 1;
$NODE_NAME_IN_MENU = 1;
$SPLIT_INDEX = 0;
$SEPARATED_FOOTNOTES = 0;
$INLINE_CONTENTS = 1;
$SIMPLE_MENU = 1;
$MENU_SYMBOL = '*';
$USE_MENU_DIRECTIONS = 0;
$USE_UP_FOR_ADJACENT_NODES = 0;
$USE_ISO = 0;
@IMAGE_EXTENSIONS = ('png', 'jpg', 'txt');
$CAPTION_STYLE = 'asis';

$no_paragraph_commands{'anchor'} = 1;

%simple_map = %ascii_simple_map;
%simple_map_pre = %simple_map;
%simple_map_texi = %simple_map;

%things_map = %ascii_things_map;
%pre_map = %things_map;

$misc_command{'exdent'}->{'keep'} = 1;
$misc_command{'noindent'}->{'keep'} = 1;
$misc_command{'indent'}->{'keep'} = 1;

%line_command_map = ( 
   'dircategory' => ''
);

# sc and var upcase.
my @simple_quoted_commands = ('cite', 'code', 'command', 'env', 'file', 'kbd',
  'option', 'samp');
# slanted? 
my @asis_commands = ('asis', 'b', 'ctrl', 'dmn', 'i', 'math', 'sc', 't', 'r', 
  'slanted', 'var', 'titlefont', 'verb', 'clickstyle');
my @chevron_commands = ('key', 'indicateurl');

my %info_default_accent_commands = ();

foreach my $accent_command ('tieaccent', 'dotless', keys(%unicode_accents), keys(%accent_map))
{
     $info_default_accent_commands{$accent_command} = 1;
     $style_map{$accent_command} = { 'function' => \&info_default_accent };
}

foreach my $command (keys(%style_map))
{
    delete $style_map{$command}->{'attribute'} if (exists($style_map{$command}->{'attribute'}));
    delete $style_map{$command}->{'quote'} if (exists($style_map{$command}->{'quote'}));
    if (grep {$_ eq $command} @simple_quoted_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        $style_map{$command}->{'begin'} = '`';
        $style_map{$command}->{'end'} = "'";
        next;
    }
    elsif (grep {$_ eq $command} @asis_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        delete $style_map{$command}->{'begin'} if  (exists($style_map{$command}->{'begin'}));
        delete $style_map{$command}->{'end'} if  (exists($style_map{$command}->{'end'}));
    }
    if (grep {$_ eq $command} @chevron_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        $style_map{$command}->{'begin'} = '<';
        $style_map{$command}->{'end'} = '>';
        next;
    }
}

$style_map{'strong'}->{'begin'} = '*';
$style_map{'strong'}->{'end'} = '*';
$style_map{'dfn'}->{'begin'} = '"';
$style_map{'dfn'}->{'end'} = '"';
$style_map{'emph'}->{'begin'} = '_';
$style_map{'emph'}->{'end'} = '_';


my %info_default_leaf_command = ();
foreach my $command ('uref', 'url', 'email', 'click')
{
   $info_default_leaf_command{$command} = 1;
   if (defined ($style_map{$command}->{'args'}))
   {
      $style_map{$command}->{'orig_args'} = [ @{$style_map{$command}->{'args'}} ];
   }
   else
   {
      $style_map{$command}->{'orig_args'} = [ 'normal' ];
   }
   $style_map{$command}->{'args'} = [];
   foreach my $arg (@{$style_map{$command}->{'orig_args'}})
   {
      push  @{$style_map{$command}->{'args'}}, 'keep';
   }
}

$style_map{'uref'}->{'function'} = \&info_default_uref;
$style_map{'url'}->{'function'} = \&info_default_uref;

sub info_default_uref($$)
{
    shift;
    my $args = shift;
    my $url = shift @$args;
    my $text = shift @$args;
    my $replacement = shift @$args;
    #$url =~ s/\s*$//;
    #$url =~ s/^\s*//;
    $url = main::normalise_space($url);
    $replacement = '' if (!defined($replacement));
    $replacement = main::normalise_space($replacement);
    return $replacement if ($replacement ne '');
    $text = '' if (!defined($text));
    $text = main::normalise_space($text);
    return "`$url'" if ($text eq '');
    return "$text ($url)";
}

$style_map{'email'}->{'function'} = \&info_default_email;
sub info_default_email($$)
{
    my $command = shift;
    my $args = shift;
    my $mail = shift @$args;
    my $text = shift @$args;
    $mail = main::normalise_space($mail);
    $text = '' if (!defined($text));
    $text = main::normalise_space($text);
    $mail = "<$mail>";
    return $mail unless ($text ne '');
    return "$text $mail";
}

foreach my $command (keys(%style_map))
{
    $style_map_pre{$command} = {};
    $style_map_texi{$command} = {};
    foreach my $key (keys(%{$style_map{$command}}))
    {
        $style_map_pre{$command}->{$key} = $style_map{$command}->{$key};
        $style_map_texi{$command}->{$key} = $style_map{$command}->{$key};
    }
}

$special_list_commands{'itemize'} = {};
my @info_default_normal_formats = ('table', 'vtable', 'ftable', 'enumerate',
   'itemize');
foreach my $format (@info_default_normal_formats, 'group')
{
    $format_map{$format} = '';
}

my %info_default_indented_commands;
foreach my $command (keys (%{$complex_format_map}), @info_default_normal_formats, 'quotation', 'deff_item', 'deff_itemx')
{
    $info_default_indented_commands{$command} = 1;
}

my %info_default_format;
foreach my $command (keys(%info_default_indented_commands), 'multitable', 'float', 'menu', 'flushright', 'flushleft', 'center')
{
    $info_default_format{$command} = 1;
} 

$info_default_indented_commands{'format'} = 0;
$info_default_indented_commands{'smallformat'} = 0;

$style = \&info_default_style;
$print_page_head   = \&info_default_print_page_head;
$toc_body = \&info_default_noop;
$about_body = \&info_default_noop;
$print_Footnotes = \&info_default_noop;
$copying_comment   = \&info_default_copying_comment;
$element_heading   = \&info_default_element_heading;
$heading           = \&info_default_heading;
$normal_text       = \&info_default_normal_text;
$paragraph         = \&info_default_paragraph;
$preformatted      = \&info_default_preformatted;
$empty_preformatted      = \&info_default_preformatted;
$empty_line               = \&info_default_empty_line;
# maybe should not be called from the main program?
$print_page_foot       = \&info_default_print_page_foot;
$print_Top_footer      = \&info_default_print_Top_footer;
$print_Top             = \&info_default_print_section;
$print_section         = \&info_default_print_section;
$end_section           = \&info_default_end_section;
$one_section           = \&info_default_one_section;
$begin_format_texi     = \&info_default_begin_format_texi;
$begin_style_texi      = \&info_default_begin_style_texi;
$begin_paragraph_texi  = \&info_default_begin_paragraph_texi;
$simple_command        = \&info_default_simple_command;
$thing_command         = \&info_default_thing_command;
$begin_special_region  = \&info_default_begin_special_region;
$end_special_region    = \&info_default_end_special_region;
$anchor_label          = \&info_default_anchor_label;
$element_label         = \&info_default_noop;
$menu_link             = \&info_default_menu_link;
$menu_command          = \&info_default_menu_command;
$complex_format        = \&info_default_complex_format;
$quotation             = \&info_default_quotation;
$unknown               = \&info_default_misc_commands;
$external_ref          = \&info_default_external_ref;
$internal_ref          = \&info_default_internal_ref;
$image                 = \&info_default_image;
$image_files           = \&info_default_image_files;
$index_summary      = \&info_default_index_summary;
$summary_letter     = \&info_default_summary_letter;
$index_entry        = \&info_default_index_entry;
$index_letter       = \&info_default_index_letter;
$print_index        = \&info_default_print_index;
$index_entry_label  = \&info_default_index_entry_label;
$foot_section       = \&info_default_foot_lines;
$foot_line_and_ref  = \&info_default_foot_line_and_ref;
$footnote_texi      = \&info_default_footnote_texi;
$list_item          = \&info_default_list_item;
$format_list_item_texi = \&info_default_format_list_item_texi;
$format             = \&info_default_format;
$tab_item_texi      = \&info_default_tab_item_texi;
$acronym_like       = \&info_default_acronym_like;
$sp                 = \&info_default_sp;
$paragraph_style_command = \&info_default_paragraph_style_command;
$cell               = \&info_default_cell;
$row                = \&info_default_row;
$table_list         = \&info_default_table_list;
$def_item           = \&info_default_def_item;
$def                = \&info_default_def;
$def_line           = \&info_default_def_line;
$float              = \&info_default_float;
$listoffloats_entry = \&info_default_listoffloats_entry;
$listoffloats       = \&info_default_listoffloats;
$colon_command      = \&info_default_colon_command;
$raw                = \&info_default_raw;
$line_command       = \&info_default_line_command;
$element_file_name  = \&info_default_element_file_name;


sub info_default_accent($$$)
{
    my @args = @_;
    my $command = shift;
    my $args = shift;
    my $text = $args->[0];
    my $style_stack = shift;
    my $state = shift;

    if (scalar(@$style_stack) and $info_default_accent_commands{$style_stack->[-1]})
    {
        return &t2h_default_ascii_accent(@args);
    }
    my $result = &t2h_default_ascii_accent(@args);
    return info_default_store_text($state,$result,'accents_commands');
#    return '' if info_default_store_text($state,$result,'accents_commands');
#    return $result;
}

sub info_default_noop
{
    return '';
}

sub info_default_copying_comment($$$$)
{
    my $copying_lines = shift;
    my $copying_text = shift;
    my $copying_no_texi = shift;
    my $copying_simple_text = shift;
    return '' if ($copying_text eq '');
    return $copying_text;
}

sub info_default_count_lines($$;$$)
{
      my $text = shift;
      my $info_state = shift;
      my $indent_length = shift;
      my $indentation_done = shift;
      my $no_indentation = 0;
 
      if (!defined($indentation_done) or $indentation_done)
      {
          $no_indentation = 1;
          $indent_length = 0;
      }
      my @lines = split /^/, $text;
      # don't accept empty text.
      @lines = ('') if (!@lines);
      my $line_passed = scalar(@lines);
      $line_passed-- if ($line_passed);

      my $end_of_line = 0;
      if (($#lines > 1) and !$end_of_line and ($lines[-1] !~ /\S/) and ($lines[-2] !~ /\S/))
      {
         $info_state->{'blank_line'} = 1;
      }
      my $last_line = $lines[-1];

      my $indented_text = shift (@lines);
print STDERR "COUNT info_default_count_lines(i_done $no_indentation, i_l $indent_length) i_t `$indented_text'\n";
      foreach my $line (@lines)
      {
print STDERR "ZZZZZZZZZZZZZzz `$line'\n";
         if ($indent_length and $line =~ /\S/)
         {
            $indented_text .= ' ' x $indent_length . $line;
         }
         else
         {
            $indented_text .= $line;
         }
      }
      if (chomp($text))
      {
         $line_passed++;
         $end_of_line = 1;
      }
      return ($line_passed, $end_of_line, $last_line, $indented_text);
}

# FIXME initialize
my %info_default_state_map = ();
my $info_default_state;
my $info_default_out_file_nr = 1;
my $info_default_dir_specification = '';
my @info_default_pending_indirect = ();
my @info_default_pending_footnotes = ();

sub info_default_reset_state($)
{
    my $info_state = shift;
    $info_state->{'top'} = {};
    $info_state->{'current'} = $info_state->{'top'};
}

sub info_default_iterator_next($$$)
{
   my $current_command = shift;
   my $command_index = shift;
   my $command_close = shift;
print STDERR "NNNNNNNNNNNNNN iterator_next current $current_command idx $command_index close $command_close\n";
   
   my $sub_command = $current_command->{'content'}->[$command_index];
   
   if ($sub_command->{'content'} and !$command_close)
   {
      return ($sub_command, 0, 0);
   }
   
   if ($current_command->{'content'}->[$command_index+1])
   {
      return ($current_command, $command_index+1, 0);
   }
   elsif (defined($current_command->{'parent'}))
   {
      return ($current_command->{'parent'}, $current_command->{'index_in_parent'}, 1);
   }
   else
   {
      return (undef, undef, undef);
   }
}

my $info_default_max_column = 72;

sub info_default_next($$$)
{
    my $current = shift;
    my $index = shift;
    my $close = shift;

    my $text;
    my $command;

    my ($current_next, $index_next, $close_next) = info_default_iterator_next($current, $index, $close);
    return ($current_next, $index_next, $close_next, $text, $command) if (!defined($current_next));

    my $content = $current_next->{'content'}->[$index_next];
    $command = $content->{'command'} if (defined($content->{'command'}));
    if ($close_next)
    {
        return ($current_next, $index_next, $close_next, $content->{'end'}, $command);
    }
    if (defined($content->{'text'}))
    {
        return ($current_next, $index_next, $close_next, $content->{'text'}, $command);
    }
    if (defined($content->{'begin'}))
    {
        $text = $content->{'begin'};
    }
    if (defined($content->{'end'}) and !defined($content->{'content'}))
    {
        if (!defined($text))
        {
            $text = $content->{'end'};
        }
        else
        {
            $text .= $content->{'end'};
        }
    }
    return ($current_next, $index_next, $close_next, $text, $command);
}


# Beware that there is a pending word if the text doesn't end with
# a space
sub info_default_process_text($$$$$$$;$)
{
   my $text = shift;
   my $line_char_counter = shift;
   my $pending_spaces = shift;
   my $pending_word = shift;
   my $indent_length = shift;
   my $in_para = shift;
   my $max_column = shift;
# indentation for the lines except for the first one
   my $indent_length_next = shift;

   $indent_length_next = $indent_length if (!defined($indent_length_next));

   $indent_length = 0 if (!defined($indent_length));
   
   my $line_passed = 0;
   my $result = '';

print STDERR "process_text(indent($indent_length), in_para $in_para spaces `$pending_spaces') line_char_counter $line_char_counter `$text'\n";
   if (!$in_para)
   { # should never be in preformatted, but in string processing
       my $chomped_text = $text;
       chomp($chomped_text);
       if ($indent_length > $line_char_counter and $chomped_text ne '')
       {
           $text = ' ' x ($indent_length - $line_char_counter) . $text;
       }
       $line_char_counter += length($text);
       if (chomp($chomped_text))
       {
          $line_passed = 1;
          $line_char_counter = 0;
       }
       return ($line_char_counter, $pending_spaces, $pending_word, $line_passed, $text);
   }
   
   while ($text ne '')
   {
my $pending_word_text = 'UNDEF';
$pending_word_text = $pending_word  if (defined($pending_word));

#print STDERR "l_c_c $line_char_counter  pending_word $pending_word_text, pending_spaces `$pending_spaces', result `$result'\n";
      if ($text =~ s/^(\s+)//)
      {
          my $new_spaces = $1;
          # in general there are no end of lines in the lines cut. However, it
          # may happen with @* in @def* lines
          my @lines = split /^/, $new_spaces;
          my $eol_spaces;
          if (@lines > 1)
          {
              $new_spaces = pop @lines;
              $eol_spaces = join ("", @lines);
print STDERR "EOL_SPACES[$line_char_counter](+$pending_spaces) `$eol_spaces'\n";
          }
          if (defined($pending_word))
          {
             if ($indent_length > $line_char_counter + length($pending_spaces))
             {
                 $pending_spaces = ' ' x ($indent_length - $line_char_counter) . $pending_spaces;
             }
             $result .= $pending_spaces . $pending_word;
             $line_char_counter += length($pending_spaces)+length($pending_word);
             $pending_spaces = $new_spaces;
             $pending_word = undef;
         }
         elsif (!$eol_spaces)
         {
             $pending_spaces .= $new_spaces;
         }
         if ($eol_spaces)
         {
             #$result .= $pending_spaces . $eol_spaces;
             $result .= $eol_spaces;
             $line_passed += scalar(@lines);
             $indent_length = $indent_length_next;
             $line_char_counter = 0;
             #$pending_spaces = $new_spaces;
             $pending_spaces = '';
         }
         if (length($pending_spaces) +  $line_char_counter > $max_column)
         {
             if ($line_char_counter > $max_column)
             {
                 $pending_spaces = '';
             }
             else
             {
                 $pending_spaces = substr($pending_spaces, $max_column - $line_char_counter +1);
             }
             $result .= "\n";
             $line_passed++;
             $indent_length = $indent_length_next;
             $line_char_counter = 0;
         }
      }
      elsif ($text =~ s/^([^\s]+)//)
      {
         my $word = $1;
         $pending_word = '' if (!defined($pending_word));
         $pending_word .= $word;
         # The $line_char_counter != 0 is here to cope with the case of a 
         # word longer than $line_char_counter followed by more letters:
         # a line would be passed each time some text is appended.
         if ((length($pending_spaces)+length($pending_word) + $line_char_counter > $max_column) and $line_char_counter != 0)
         {
             $pending_spaces = '';
             $result .= "\n";
             $line_passed++;
             $indent_length = $indent_length_next;
             $line_char_counter = 0;
         }
      }
   }
   return ($line_char_counter, $pending_spaces, $pending_word, $line_passed, $result)
}

sub info_default_skip_spaces($$$)
{
    my $current = shift;
    my $index = shift;
    my $close = shift;

    print STDERR "SKIP_SPACES\n";
    while(1)
    {
       my ($current_next, $index_next, $close_next) = info_default_iterator_next($current, $index, $close);
        return if ($close_next or (!defined($current_next)));
        my $content = $current_next->{'content'}->[$index_next];
        if (defined($content->{'begin'}))
        {
            $content->{'begin'} =~ s/^\s*//;
print STDERR "SKIP_SPACES begin\n";
            return if ($content->{'begin'} ne '');
        } 
        if (defined($content->{'content'}) or defined($content->{'format_name'})
            or $content->{'definition_line'})
        { # non empty commands stop space skipping, even if they contain 
          # only spaces, like @asis{ }
          # also for item(x) that have format_name defined
print STDERR "SKIP_SPACES command?\n";
            return;
        }
        if (defined($content->{'text'}))
        {
print STDERR "SKIP_SPACES text\n";
            $content->{'text'} =~ s/^\s*//;
            return if ($content->{'text'} ne '');
        }
        if (defined($content->{'end'}))
        {
print STDERR "SKIP_SPACES end\n";
            $content->{'end'} =~ s/^\s*//;
            return if ($content->{'end'} ne '');
        }
        ($current, $index, $close) = ($current_next, $index_next, $close_next);
    }
}

sub info_default_store_pending($$$;$)
{
   my $line_char_counter = shift;
   my $pending_spaces = shift;
   my $pending_word = shift;
   my $indent_length = shift;

   $indent_length = 0 if (!defined($indent_length));
   my $indent_text = '';
   $indent_text = ' ' x $indent_length;

   my $pending_word_text = 'undef';
   $pending_word_text = $pending_word if (defined($pending_word));
   print STDERR "store_pending(spaces `$pending_spaces', indent($indent_length) `$indent_text' word `$pending_word_text'\n";
   my $result = $pending_spaces;
   $pending_spaces = '';
   if (defined($pending_word))
   {
      $result .= $pending_word;
      $pending_word = undef;
   }

   my $chomped_result = $result;
   chomp ($chomped_result);
   if ($line_char_counter == 0 and $chomped_result ne '')
   {
      $result = $indent_text . $result;
   }

   $line_char_counter += length($result);
   return ($line_char_counter, $pending_spaces, $pending_word, $result);
}

my $info_default_end_sentence_character = quotemeta($punctuation_characters);
my $info_default_after_punctuation_characters = quotemeta($after_punctuation_characters);
my $info_default_indent_length = 5;
my $info_default_para_indent_length = 3;
my $info_default_first_para_indent = 'none';

sub info_default_output($)
{
   my $info_state = shift;
   my $result = '';
   print STDERR "Storing the stack\n";
#   print STDERR "" . Data::Dumper->Dump([$info_state->{'top'}]);
   my ($characters_count, $lines_count);
   ($characters_count, $result, $lines_count) = info_default_process_content($info_state->{'top'}, $info_state);
   $info_state->{'offset_in_file'} += $characters_count;
   $info_state->{'line_count'} += $lines_count;
   info_default_reset_state($info_state) 
       if (!defined($info_state->{'current'}->{'command'}));
   return $result;
}

my %info_default_index_line_string_length;
my %info_default_index_entries;

my %info_default_indent_format_length = ('enumerate' => 2,
    'itemize' => 3,
    'table' => 0,
    'vtable' => 0,
    'ftable' => 0,
 );

sub info_default_process_content($$)
{
   my $current_command = shift;
   my $info_state = shift;

   my $length = 0;
   my $result = '';

   my $line_char_counter = 0;
   my $all_line_passed = 0;

   my $pending_spaces = '';
   my $pending_word;
   my $preformatted = 0;
   my $indent_level = 0;
   my $item_pending;
   my $in_exdent = 0;
   my $in_para = 0;
   my $table_item_line = 0;
   my $in_table_item = 0;
   my $max_column = $info_default_max_column;

   # for formats that needs to process a full line (center and flushright) 
   # to know the line length before outputing
   my $current_line = undef;

   my ($current, $index, $close) = ($current_command, 0, 0);

   #print STDERR "info_default_process_content: $current_command\n";
   while(1)
   {
      last if (!defined($current));
      my $content = $current->{'content'}->[$index];
      my $text_added = '';
      my $item_line_added = 0;
      my $indentation_done = 0;
my $text_item_pending = '';
$text_item_pending = $item_pending if (defined($item_pending));
my $text_length = '';
$text_length = "$content->{'text'}" if defined($content->{'text'});
my $text_command = '';
$text_command = $content->{'command'} if defined($content->{'command'});
my $in_node_count = 0;
$in_node_count = $info_state->{'line_count'} if defined($info_state->{'line_count'});
      print STDERR "($text_command|$text_length|$close|${all_line_passed}+$in_node_count|l_c_cnt $line_char_counter)  prfrmted $preformatted para $in_para indent_lvl $indent_level in_exdent $in_exdent only_spaces $info_state->{'only_spaces'} blank_line $info_state->{'blank_line'} table_item_line $table_item_line in_table_item $in_table_item item_pending $text_item_pending\n";
my $pending_word_text = 'undef';
$pending_word_text = "`$pending_word'" if (defined($pending_word));
print STDERR "         spaces: `$pending_spaces' word: $pending_word_text\n";

      my $indent_length = $indent_level * $info_default_indent_length;
      # indent_length is also set here for table @item so in that case
      # $info_default_indent_format_length{$item_pending} is not taken 
      # into account, luckily it is 0.
      $indent_length = ($indent_level -1) * $info_default_indent_length
            if ($indent_level and ($in_exdent or $table_item_line));
      my $item_indent_length = 0;
      if ($item_pending)
      {
        $indent_length = ($info_default_indent_format_length{$item_pending}
                   +($indent_level -1)* $info_default_indent_length);
      }
      
      if ($close)
      {
          if (defined($content->{'end'}))
          {
              $text_added .= $content->{'end'};
          }
          # if ending a paragraph, go straight to the text addition 
          # without processing of the end of lines. Same if ending a 
          # quotation or an @example
          if ($info_default_indented_commands{$content->{'command'}})
          {
              $indent_level--;
              if ($indent_level > 0 and !$info_state->{'blank_line'} and $content->{'command'} !~ /^deff_item/ and !$preformatted)
              {
                 $text_added .= "\n";
              }
              # this nullify a potential noindent in a random format
              $info_state->{'indent_para'} = undef;
          }
          elsif ($complex_format_map->{$content->{'command'}})
          {
              if (!$info_state->{'blank_line'} and $info_state->{'only_spaces'} and ($indent_level > 0) and !$preformatted)
              {
                 $text_added .= "\n";
              }
          }
          if ($content->{'command'} eq 'paragraph' and $info_state->{'align_stack'}->[-1]->{'command'} eq 'normal')
          {
              # if there is no space at the end of a paragraph, there may be 
              # pending text, for example, if there is an ending line like
              #         Some text@c a comment
              my $pending;
              ($line_char_counter, $pending_spaces, $pending_word, $pending) = info_default_store_pending($line_char_counter, $pending_spaces, $pending_word, $indent_length);
              $text_added .= $pending if (defined($pending));
              $text_added =~ s/\s*$//;
              $pending_spaces = '';
              $in_para = 0;
              $info_state->{'indent_para'} = undef;
              $text_added .= "\n" unless (($line_char_counter + length($text_added)) == 0);
          }
          elsif ($content->{'command'} eq 'preformatted')
          {
           # if preformatted doesn't end with a newline, it is added here
              $text_added .= "\n" unless ($line_char_counter == 0);
              $preformatted--;
          }
#         FIXME this could be better than the end of menu line that is always
#               prepended to menu
#          elsif ($content->{'command'} eq 'menu')
#          {
#              $text_added .= "\n" unless ($info_state->{'blank_line'});
#          }
          elsif ($content->{'command'} eq 'float')
          {
              $text_added = "\n" . $text_added unless ($info_state->{'blank_line'});
          }
          elsif ($paragraph_style{$content->{'command'}})
          {
              my $popped = pop @{$info_state->{'align_stack'}};
              print STDERR "BUG: align_stack, popped $popped->{'command'} ne command $content->{'command'}\n" if ($popped->{'command'} ne $content->{'command'});
          }
          elsif ($content->{'command'} eq 'multitable')
          {
              my $multitable = pop @{$info_state->{'multitable_stack'}};
              $max_column = $multitable->{'max_column_kept'};
              $result = $multitable->{'result_kept'};
              $line_char_counter = $multitable->{'line_char_counter_kept'};
              $all_line_passed = $multitable->{'all_line_passed_kept'};
              $length = $multitable->{'length_kept'};
              #$info_state->{'offset_in_file'} = $multitable->{'offset_in_file_kept'} + $info_state->{'offset_in_file'};
              $info_state->{'offset_in_file'} = $multitable->{'offset_in_file_kept'};
              #$info_state->{'line_count'} = $multitable->{'line_count_kept'} + $info_state->{'line_count'};
              $info_state->{'line_count'} = $multitable->{'line_count_kept'};
              print STDERR "MULTITABLE close, lines: $multitable->{'line_count_kept'} + $all_line_passed\n";
              foreach my $anchor_and_index (@{$multitable->{'anchors'}}, @{$multitable->{'index_entries'}})
              {
                  $anchor_and_index->{'line_nr'} += $multitable->{'line_count_kept'} + $all_line_passed;
              }
              if (! scalar(@{$info_state->{'multitable_stack'}}))
              {
                  print STDERR "MULTITABLE close, lengths: $multitable->{'offset_in_file_kept'} + $length\n";
                  foreach my $anchor (@{$multitable->{'anchors'}})
                  {
                      $anchor->{'info_offset'} += $multitable->{'offset_in_file_kept'} + $length;
                  }
              }
              else 
              {
                  push @{$info_state->{'multitable_stack'}->[-1]->{'anchors'}}, @{$multitable->{'anchors'}};
                  push @{$info_state->{'multitable_stack'}->[-1]->{'index_entries'}}, @{$multitable->{'index_entries'}};
              }
              $text_added .= $multitable->{'result'};
          }
          elsif ($content->{'command'} eq 'multitable_cell')
          {
              my $cell = $info_state->{'multitable_stack'}->[-1]->{'cells'}->[-1];
              $cell->{'result'} = $result;
              $cell->{'length'} = $length;
              $cell->{'line_passed'} = $all_line_passed;
          }
          elsif ($content->{'command'} eq 'multitable_row')
          {
              my $multitable = $info_state->{'multitable_stack'}->[-1];
              my $row_length = 0;
              my $row = '';
              my $max_lines = 0;
              my $cell_beginning = 0;
              my @anchor_lines_array;
              my $cell_idx = 0;
              my @anchors;
              my @indices;
              foreach my $cell (@{$multitable->{'cells'}})
              {
                  $cell->{'beginning'} = $cell_beginning; 
                  $cell_beginning += $cell->{'cell_width'}+1;
                  @{$cell->{'lines'}} = split /^/, $cell->{'result'};
                  $max_lines = scalar(@{$cell->{'lines'}}) if (scalar(@{$cell->{'lines'}}) > $max_lines);
                  foreach my $anchor (@{$cell->{'anchors'}})
                  {
                      push @{$anchor_lines_array[$anchor->{'line_nr'}]}, $anchor;
                      $anchor->{'cell_idx'} = $cell_idx;
                      push @anchors, $anchor;
                  }
                  push @indices, @{$cell->{'index_entries'}};
                  $cell_idx++;
              }
              my $previous_last_cell = scalar(@{$multitable->{'cells'}});
              print STDERR "ROW cell_beginning $cell_beginning, max_lines $max_lines, previous_last_cell $previous_last_cell\n";
              for (my $line_idx = 0; $line_idx < $max_lines; $line_idx++)
              {
                  my $length = 0;
                  my $line = '';
                  # determine the last cell in the line, to fill spaces in 
                  # cells preceding that cell on the line
                  my $last_cell = 0;
                  for (my $cell_idx = 0; $cell_idx < $previous_last_cell; $cell_idx++)
                  {
                      $last_cell = $cell_idx+1 if (defined($multitable->{'cells'}->[$cell_idx]->{'lines'}->[$line_idx]));
                  }
                  print STDERR "  L(last_cell $last_cell): $line_idx\n";
                  for (my $cell_idx = 0; $cell_idx < $last_cell; $cell_idx++)
                  {
                      my $cell_text = $multitable->{'cells'}->[$cell_idx]->{'lines'}->[$line_idx];
                      print STDERR "   C($cell_idx) ";
                      if (defined($cell_text))
                      {
                          chomp($cell_text);
                          print STDERR "$cell_text";
                          $line .= $cell_text;
                          $length += length($cell_text);
                      }
                      if ($cell_idx+1 < $last_cell)
                      {
                          if ($length < $multitable->{'cells'}->[$cell_idx+1]->{'beginning'})
                          {
                              my $spaces = ' ' x ($multitable->{'cells'}->[$cell_idx+1]->{'beginning'} - $length);
                              $length += length($spaces);
                              $line .= $spaces;
                              print STDERR "   Csp($length) `$spaces'";
                          }
                      }
                  }
                  if (defined($anchor_lines_array[$line_idx]))
                  {
                      foreach my $anchor (@{$anchor_lines_array[$line_idx]})
                      {
                          my $anchor_position = $anchor->{'line_char_counter'} + $multitable->{'cells'}->[$anchor->{'cell_idx'}]->{'beginning'};
                          if ($anchor_position > $length)
                          {
                              my $spaces = ' ' x ($anchor_position - $length);
                              $line .= $spaces;
                              $length += length($spaces);
                          }
                          $anchor->{'info_offset'} = $anchor_position + $row_length + $multitable->{'length'};
                          print STDERR "ROW anchor close: anchor[$anchor->{'cell_idx'}]($multitable->{'cells'}->[$anchor->{'cell_idx'}]->{'beginning'}+$anchor->{'line_char_counter'}) $anchor_position $anchor->{'info_offset'}\n";
                          $anchor->{'line_char_counter'} = $anchor_position;
                      }
                  }
                  $line .= "\n";
                  $row_length += length($line);
                  print STDERR "  ($length,".length($line).") $line";
                  $row .= $line;
                  $previous_last_cell = $last_cell;
              }
              foreach my $anchor_and_index (@anchors, @indices)
              {
                  $anchor_and_index->{'line_nr'} += $multitable->{'line_count'};
                  print STDERR "ROW close: new line count: $anchor_and_index->{'line_nr'} + \n";
              }
              if ($content->{'item_command'} eq 'headitem')
              {
                  # at this point cell_beginning is at the beginning of
                  # the cell following the end of the table -> full width
                  my $line = '-' x $cell_beginning . "\n";
                  $row .= $line;
                  $row_length += length($line);
              }
              print STDERR "ROW_LENGTH $row_length\n";
              $multitable->{'result'} .= $row;
              $multitable->{'length'} += $row_length;
              $multitable->{'line_count'} += $max_lines;
              $multitable->{'cells'} = [];
              push @{$multitable->{'anchors'}}, @anchors;
              push @{$multitable->{'index_entries'}}, @indices;
          }
      }
      else
      {
          if ($content->{'command'})
          {
              my $pending_added_length = 0;
              if ($content->{'command'} eq 'anchor' or $content->{'command'} eq 'image' or $content->{'command'} eq 'index_command' or $content->{'command'} eq 'sp')
              {
                  my $pending;
                  ($line_char_counter, $pending_spaces, $pending_word, $pending) = info_default_store_pending($line_char_counter, $pending_spaces, $pending_word, $indent_length);
                  # here spaces out of any environment are ignored.
                  if ($in_para or $preformatted or $pending =~ /\S/)
                  { # this has to be done before the anchor related code
                    # to have the right count.
                    # FIXME this is wrong if an end of line was passed.
                    # in that case line_char_counter has been increased and 
                    # $pending ends with an end of line
                      $pending_added_length += length($pending);
                      $text_added .= $pending;
                  }
              }
              if ($content->{'command'} eq 'anchor' or ($content->{'command'} eq 'float' and $content->{'anchor_reference'}))
              {
print STDERR "anchor: offset_in_file $info_state->{'offset_in_file'}, line_count $info_state->{'line_count'}, line_char_counter $line_char_counter pending_added_length $pending_added_length\n";
                  $content->{'anchor_reference'}->{'info_offset'} = $length + $info_state->{'offset_in_file'} + $pending_added_length;
                  $content->{'anchor_reference'}->{'line_nr'} = $all_line_passed + $info_state->{'line_count'};
                  $content->{'anchor_reference'}->{'line_char_counter'} = $line_char_counter + $pending_added_length;
                  if (@{$info_state->{'multitable_stack'}})
                  {
                      push @{$info_state->{'multitable_stack'}->[-1]->{'cells'}->[-1]->{'anchors'}}, $content->{'anchor_reference'};
                  }
                  push @{$info_state->{'pending_tags'}}, $content->{'anchor_reference'};
                  push @{$info_state->{'align_stack'}->[-1]->{'anchors'}}, $content->{'anchor_reference'} if ($info_state->{'align_stack'}->[-1]->{'command'} eq 'center' or $info_state->{'align_stack'}->[-1]->{'command'} eq 'flushright');
              }
              elsif ($content->{'command'} eq 'index_label')
              {
                  my $index_line_nr = $all_line_passed + $info_state->{'line_count'};
                  my $index_name = $content->{'index_name'};
                  $info_default_index_line_string_length{$index_name} = length($index_line_nr) 
                      if (!defined($info_default_index_line_string_length{$index_name}) or $info_default_index_line_string_length{$index_name} < length($index_line_nr));
print STDERR "RRRRRRRRRRRRR $content->{'index_entry_reference'}->{'texi'}   name: $index_name line: $index_line_nr max: $info_default_index_line_string_length{$index_name}\n";
                  my $index_ref = { 'index_entry_reference' => $content->{'index_entry_reference'}, 'line_nr' => $index_line_nr, 'index_name' => $index_name };
print STDERR "INDEX($index_name) line $index_line_nr\n";
                  $info_default_index_entries{$content->{'index_entry_reference'}} = $index_ref;
                  if (@{$info_state->{'multitable_stack'}})
                  {
                      push @{$info_state->{'multitable_stack'}->[-1]->{'cells'}->[-1]->{'index_entries'}}, $index_ref;
                  }
              }
              elsif ($content->{'command'} eq '*' and !$preformatted)
              {
                 if (defined($pending_word))
                 {
                    $text_added .= $pending_spaces . $pending_word;
                    $pending_word = undef;
                 }
                 # spaces preceding @* are skipped
                 $pending_spaces = '';
                 $text_added .=  $content->{'text'};
                 # just like following spaces
                 info_default_skip_spaces($current, $index, $close);
                 goto new_text;
              }
              elsif ($content->{'command'} eq 'paragraph' and $info_state->{'align_stack'}->[-1]->{'command'} eq 'normal')
              {
                 # empty paragraph
                 goto new_text if (!$content->{'content'});

                 my $paragraphindent = $Texi2HTML::THISDOC{'paragraphindent'};
                 $paragraphindent = $Texi2HTML::Config::PARAGRAPHINDENT if (!defined($paragraphindent));
                 $paragraphindent = 0 if ($paragraphindent eq 'none');
                 if ($paragraphindent ne 'asis')
                 {
                    info_default_skip_spaces($current, $index, $close);
                 }
                 if ($paragraphindent ne 'asis' and $paragraphindent and $line_char_counter == 0 and  !($indent_level) and !scalar(@{$info_state->{'multitable_stack'}}) and ($info_state->{'indent_para'} or (!defined($info_state->{'indent_para'}) and ($content->{'paragraph_in_element_nr'} or (defined($Texi2HTML::THISDOC{'firstparagraphindent'}) and $Texi2HTML::THISDOC{'firstparagraphindent'} eq 'insert')))))
                 {
                    $text_added .= ' ' x $paragraphindent;
                 }
                 $in_para = 1;
              }
              elsif ($content->{'command'} eq 'preformatted')
              {
                  $preformatted++ if ($content->{'content'});
              }
              elsif ($content->{'command'} eq 'exdent')
              {
                  # if an end of line is added, in_exdent is set to 2 and
                  # set to one when processing the end of line that was just
                  # added, and set to 0 at the end of the line.
                  # if there is no end of line added, it is only set to 1.
                  if ($line_char_counter != 0)
                  {
                     $text_added .= "\n";
                     $in_exdent = 2;
                  } 
                  else
                  {
                     $in_exdent = 1;
                  }
                 #goto new_text;
              }
              elsif ($content->{'command'} eq 'indent')
              {
                  $info_state->{'indent_para'} = 1;
              }
              elsif ($content->{'command'} eq 'noindent')
              {
                  $info_state->{'indent_para'} = 0;
              }
              elsif ($content->{'command'} eq 'image' or $content->{'command'} eq 'sp')
              {
                  $text_added .= $content->{'text'};
                  goto new_text;
              }
              elsif ($content->{'definition_line'})
              {
                  
                  my $dummy_line_passed;
print STDERR "BUG: defined pending_word before DEFINITION_LINE\n" if defined($pending_word);
print STDERR "DEFINITION_LINE($line_char_counter,$pending_spaces,$indent_length,$in_para,$max_column): $content->{'text'}";
                  ($line_char_counter, $pending_spaces, $pending_word, $dummy_line_passed, $text_added) = info_default_process_text($content->{'text'}, $line_char_counter, $pending_spaces, $pending_word, $indent_length, 1, $max_column, $indent_length+2*$info_default_indent_length);
                  $text_added .= $pending_spaces;
                  $pending_spaces = '';
                  print STDERR "DEFINITION_LINE($line_char_counter,$pending_spaces) -> $text_added";
print STDERR "BUG: defined pending_word after DEFINITION_LINE\n" if defined($pending_word);
                  $indentation_done = 1;
                  
                  goto new_text;
              }
              elsif (($content->{'command'} eq 'item' or $content->{'command'} eq 'itemx') and exists $format_map{$content->{'format_name'}})
              {
                  $item_pending = $content->{'format_name'};
                  #if (!$info_state->{'blank_line'} and $content->{'command'} eq 'item')
                  my $first_item = 0;
                  
                  if ($content->{'command'} eq 'item')
                  {
                      if (!defined($content->{'parent'}->{'item_nr'}))
                      {
                          $content->{'parent'}->{'item_nr'} = 1;
                          $first_item = 1;
                      }
                      else
                      {
                          $content->{'parent'}->{'item_nr'}++;
                      }
                  }

                  if ($item_pending =~ /table$/)
                  {
                      $table_item_line = 1;
                      $in_table_item = 0;
print STDERR "DDDDDDDDDDDDDDDD $content->{'command'} $first_item or $indent_level $content->{'parent'}->{'command'}\n";
                  }
                  if (!$info_state->{'blank_line'} and ($content->{'command'} ne 'itemx') and (!$first_item or $indent_level != 1))
                  {
                      $text_added = "\n" . $text_added;
                      $item_line_added = 1;
                  }
                  # one less indentation level and no line break
                  # adding item_line_added allows the table_item_line to 
                  # still be active after the additional blank line
                  $table_item_line = 1+$item_line_added if ($item_pending =~ /table$/);
              }
              elsif ($content->{'command'} eq 'menu' or $content->{'command'} eq 'listoffloats')
              {
                  $text_added .= "\n" unless ($info_state->{'blank_line'});
              }
              elsif ($paragraph_style{$content->{'command'}})
              {
                  push @{$info_state->{'align_stack'}}, {'command' => $content->{'command'}};
              }
              elsif ($content->{'command'} eq 'multitable')
              {
                  my $multitable = {
                     'offset_in_file_kept' => $info_state->{'offset_in_file'},
                     'line_count_kept'     => $info_state->{'line_count'},
                     'columns_size'        => [ @{$content->{'columns_size'}} ],
                     'result'              => '',
                     'length'              => 0,
                     'line_count'          => 0,
                     'result_kept'         => $result,
                     'length_kept'         => $length,
                     'all_line_passed_kept' => $all_line_passed,
                     'line_char_counter_kept' => $line_char_counter,
                  };
                  push @{$info_state->{'multitable_stack'}}, $multitable;
                  $info_state->{'offset_in_file'} = 0;
                  $info_state->{'line_count'} = 0;
              }
              elsif ($content->{'command'} eq 'multitable_row')
              {
                  $info_state->{'multitable_stack'}->[-1]->{'cell_index'} = -1;
              }
              elsif ($content->{'command'} eq 'multitable_cell')
              {
                  my $multitable = $info_state->{'multitable_stack'}->[-1];
                  $multitable->{'cell_index'}++;
                  my $cell_width = $content->{'parent'}->{'parent'}->{'columns_size'}->[$multitable->{'cell_index'}];
                  #$max_column = $cell_width-1;
                  $max_column = $cell_width -2;
                  push @{$multitable->{'cells'}}, {'cell_width' => $cell_width, 'index_entries' => [], 'anchors' => []};
                  $result = '';
                  $length = 0;
                  $all_line_passed = 0;
                  $line_char_counter = 0;
              }
              if ($info_default_indented_commands{$content->{'command'}})
              {
                  if ($content->{'command'} =~ /^deff_item/)
                  {
                     info_default_skip_spaces($current, $index, $close);
                  }
                  elsif (!$info_state->{'blank_line'} and $info_state->{'only_spaces'} and ($indent_level != 0) and !$preformatted)
                  {
                     $text_added .= "\n";
                  }
                  # there is no close if !$content->{'content'}
                  $indent_level++ if ($content->{'content'});
              }
              elsif ($complex_format_map->{$content->{'command'}})
              {
                  if (!$info_state->{'blank_line'} and $info_state->{'only_spaces'} and ($indent_level != 0) and !$preformatted)
                  {
                     $text_added .= "\n";
                  }
              }
          }

          if (defined($content->{'text'}))
          {
              if ($in_para and !$in_exdent)
              {
print STDERR "IN_PARA text\n";
                  my $new_text = $content->{'text'};
                  if ((!defined($content->{'command'}) or $content->{'command'} ne ':') and $new_text =~ /([$info_default_end_sentence_character])([$info_default_after_punctuation_characters]*)(\s*)$/)
                  {
                      # the info_default_after_punctuation_characters should
                      # always be in the same text element. 
                      my $spaces_length = length($3);
                      if (chomp($new_text))
                      {
                          $new_text =~ s/(\s*)$/  /;
                      }
                      else
                      {
                          # spaces may be in following commands
                          my ($current_next, $index_next, $close_next, $text_next, $command_next) = info_default_next ($current, $index, $close);
                          while (1)
                          {
                              last if (!defined($current_next) or (defined($command_next) and $command_next eq '*'));
                              if ($text_next =~ /\S/)
                              {
                                  last;
                              }
                              else
                              {
                                  if (chomp($text_next))
                                  {
                                      info_default_skip_spaces($current, $index, $close);
                                      $new_text =~ s/(\s*)$/  /;
                                      last;
                                  }
                              }
                              ($current_next, $index_next, $close_next, $text_next, $command_next) = info_default_next ($current_next, $index_next, $close_next);
                          }
                      }
                      print STDERR "KKKKKKKKKKKK `$1' `$2' `$3'";
                  }
                  elsif (chomp($new_text))
                  {
                      $new_text =~ s/(\s*)$/ /;
                    #  if ($new_text =~ /[$info_default_end_sentence_character] $/)
                    #  {
                    #      $new_text .= ' ';
                    #  }
                  }
                  $text_added .= $new_text;
              } # ignore spaces outside of paragraphs and preformatted
              elsif ($preformatted or $info_state->{'align_stack'}->[-1]->{'command'} ne 'normal')
              {
print STDERR "IN_PREFORMATTED or ALIGN text\n";
                  $text_added .= $content->{'text'};
              }
              else
              {
                  my $chomped_text = $content->{'text'};
                  if ($chomped_text !~ /\S/ and chomp($chomped_text) and !$item_pending)
                  {
                      if ($in_table_item and $info_state->{'only_spaces'})
                      {
                          # in a blank_line
print STDERR "IN_ITEM ignored: `$content->{'text'}'\n";
                      }
                      elsif (!$info_state->{'blank_line'} or !$info_state->{'only_spaces'})
                      {
print STDERR "IN_ADDING_BLANK_LINE because no line before or text before\n";
                          $text_added .= "\n";
                      }
                      else
                      {
print STDERR "IN_NOT_ADDING_BLANK_LINE\n";
                      }
                  }
                  else
                  { # exdent, item not in paragraph nor in preformatted
print STDERR "NOWHERE and not end of line (or item_pending) `$content->{'text'}'\n";
                       $text_added .= $content->{'text'};
                  }
              }
# unless (!defined($line_char_counter) and !$preformatted and $content->{'text'} =~ /^\s*$/);
          }
          else
          {
              if (defined($content->{'begin'}))
              {
                  $text_added .= $content->{'begin'};
              }
              # command that won't be closed, so the end has to be added 
              # here. It should mostly happen for empty style @-commands.
              if (defined($content->{'end'}) and !defined($content->{'content'}))
              {
                  $text_added .= $content->{'end'};
              }
          }
      }
      if (!$preformatted and !$in_exdent and $info_state->{'align_stack'}->[-1]->{'command'} eq 'normal' and $in_para)
      #if (!$preformatted and !$in_exdent)
      {
          # the line_passed returned here are not used, since they are computed
          # below.
          $indentation_done = 1;
          my $dummy_line_passed;
          ($line_char_counter, $pending_spaces, $pending_word, $dummy_line_passed, $text_added) = info_default_process_text($text_added, $line_char_counter, $pending_spaces, $pending_word, $indent_length, $in_para, $max_column) if ($text_added ne '');
      }
      elsif ($info_state->{'align_stack'}->[-1]->{'command'} ne 'center' and $info_state->{'align_stack'}->[-1]->{'command'} ne 'flushright')
      {
          
          my $chomped_text = $text_added;
          #if (chomp($chomped_text))
          #{
          #    $in_exdent = 0;
          #}
          chomp($chomped_text);
print STDERR "NOT IN PARA text_added `$text_added' line_char_counter $line_char_counter\n";
          if ($chomped_text ne '' and $line_char_counter < $indent_length)
          {
print STDERR "                     indent_length $indent_length\n";
              $text_added =  ' ' x ($indent_length - $line_char_counter).$text_added;
          }
          $line_char_counter += length($text_added);
      }
      else
      {
          $line_char_counter += length($text_added);
      }
    new_text:
print STDERR "ADDING `$text_added'\n" if ($text_added ne '');
      if ($text_added ne '')
      {
         if ($item_pending and !$item_line_added)
         {
             info_default_skip_spaces($current, $index, $close);
             $item_pending = undef;
         }
      }
      # from here, the next cmmand is available
      ($current, $index, $close) = info_default_iterator_next($current, $index, $close);

      if ($text_added =~ /\S/)
      {
         $in_table_item = 0 if ($in_table_item);
         $info_state->{'blank_line'} = 0;
      }
      my ($line_passed, $end_of_line, $last_line, $text_indented) = info_default_count_lines($text_added, $info_state, $indent_length, ($indentation_done
        or $info_state->{'align_stack'}->[-1]->{'command'} eq 'center' 
        or $info_state->{'align_stack'}->[-1]->{'command'} eq 'flushright'));
      # only_space is set in all the conditionals
      if ($end_of_line)
      {
         $line_char_counter = 0;
         $in_exdent-- if ($in_exdent);
         if ($table_item_line)
         {
            $table_item_line--;
            $in_table_item = 1;
         }
         $info_state->{'blank_line'} = 1 if ($info_state->{'only_spaces'} and ($last_line !~ /\S/));
         $info_state->{'only_spaces'} = 1;
      }
      else
      {
         if ($line_passed)
         {# in that case we added more than one line, the $line_char_counter
          # is reset to the last line length.
            $line_char_counter = length($last_line);
            $in_exdent = 0;
            if ($last_line !~ /\S/)
            {
               $info_state->{'only_spaces'} = 1;
            }
            else
            {
               $info_state->{'only_spaces'} = 0;
            }
         }
         else
         {
            $info_state->{'only_spaces'} = 0 if ($last_line =~ /\S/);
         }
      }
      if ($info_state->{'align_stack'}->[-1]->{'command'} eq 'center' 
        or $info_state->{'align_stack'}->[-1]->{'command'} eq 'flushright')
      {
          if (defined($current_line))
          {
              $text_added = $current_line . $text_added;
          }
          $text_indented = '';
          $current_line = undef;
          my $length_prepended = undef;
          foreach my $line (split /^/, $text_added) 
          {
             my $chomped_line = $line;
             if (chomp($chomped_line))
             {
                $line =~ s/^\s*//;
                $line =~ s/\s*$//;
                
                if (length($line) eq 0)
                {
                    $length_prepended = 0;
                    $text_indented .= "\n";
                }
                else
                {
                    if (length($line) > $max_column)
                    {
                        $length_prepended = 0;
                    }
                    elsif ($info_state->{'align_stack'}->[-1]->{'command'} eq 'center')
                    {
                         $length_prepended = (($max_column -1 - length($line)) /2);
                    }
                    else
                    {
                         $length_prepended = ($max_column -1 - length($line));
                    }
                    $text_indented .= ' ' x$length_prepended . $line ."\n";
                }
             }
             else
             {
                $current_line = $line;
             }
          }
          if (defined ($length_prepended) and defined($info_state->{'align_stack'}->[-1]->{'anchors'}))
          {
             while (@{$info_state->{'align_stack'}->[-1]->{'anchors'}})
             {
                my $anchor = shift @{$info_state->{'align_stack'}->[-1]->{'anchors'}};
                $anchor->{'info_offset'} += $length_prepended;
             }
          }
      }
      
      $result .= $text_indented;
      $length += length($text_indented);
      $all_line_passed += $line_passed;
   }
   return ($length, $result, $all_line_passed);
}

my $state_nr = 0;
sub info_default_get_state($)
{
   my $state = shift;
   if (!exists $info_default_state_map{$state})
   {
print STDERR "NEW state $state_nr\n";
      my ($current_command, $top_stack);
      $info_default_state_map{$state} = {};
      info_default_reset_state($info_default_state_map{$state});
      # since the page head always leave a blank line, and the state may be
      # used for text right after the page head, we set it to 1 here. 
      # it may be wrong in other contexts, to be seen.
      $info_default_state_map{$state}->{'blank_line'} = 1;
      $info_default_state_map{$state}->{'only_spaces'} = 1;
      $info_default_state_map{$state}->{'nr'} = $state_nr;
      $info_default_state_map{$state}->{'state'} = $state;
      $info_default_state_map{$state}->{'multitable_stack'} = [];
      @{$info_default_state_map{$state}->{'align_stack'}} = ({'command'=>'normal'});
      $state_nr++;
   }
print STDERR "RETURN state $state $info_default_state_map{$state} $info_default_state_map{$state}->{'nr'}\n";
   return $info_default_state_map{$state};
}

sub info_default_open_command($$;$)
{
   my $state = shift;
   my $command = shift;
   my $additional_entries = shift;

   my $index = 0;
   
   my $info_state = info_default_get_state($state);
   # index in the parent content list
   $index = scalar(@{$info_state->{'current'}->{'content'}}) 
       if (defined($info_state->{'current'}->{'content'}));
   my $new_command = {'command' => $command, 'parent' => $info_state->{'current'}, 'index_in_parent' => $index };
   if (defined($additional_entries))
   {
       foreach my $key (keys(%$additional_entries))
       {
           $new_command->{$key} = $additional_entries->{$key};
       }
   }

   push @{$info_state->{'current'}->{'content'}}, $new_command;
   $info_state->{'current'} = $new_command;
   print STDERR "Opened $command ". 
     "\n";
#     Data::Dumper->Dump([$info_state->{'top'}]);
}

sub info_default_close_command($$;$$$)
{
   my $state = shift;
   my $command = shift;
   my $begin = shift;
   my $end = shift;
   my $command_entries = shift;

   $state = $Texi2HTML::THISDOC{'state'} if (!defined($state));
   my $info_state = info_default_get_state($state);
   #print STDERR "" . Data::Dumper->Dump([$current_command]);
   print STDERR "Closing $command ".
     "\n";
   if (!defined($info_state->{'current'}))
   {
      print STDERR "info_state->{'current'} not defined\n";
   }
   elsif (!defined($info_state->{'current'}->{'command'}))
   {
      print STDERR "info_state->{'current'}->{'command'} not defined\n";
   }
   elsif ($command ne $info_state->{'current'}->{'command'})
   {
     print STDERR "Was waiting for $info_state->{'current'}->{'command'}\n";
   }
#     Data::Dumper->Dump([$info_state->{'top'}]);
   #return if $no_close;
   $command_entries->{'begin'} = $begin;
   $command_entries->{'end'} = $end;
   foreach my $key (keys(%$command_entries))
   {
      $info_state->{'current'}->{$key} = $command_entries->{$key} 
           if (defined($command_entries->{$key}));
   }

   $info_state->{'current'} = $info_state->{'current'}->{'parent'};

   return info_default_output($info_state)
     if (!defined($info_state->{'current'}->{'command'}));
   return '';
}

sub info_default_store_text($$;$$)
{
   my $state = shift;
   my $text = shift;
   my $command = shift;
   my $text_entries = shift;

   $state = $Texi2HTML::THISDOC{'state'} if (!defined($state));
   my $info_state = info_default_get_state($state);
   return '' if ((!defined($text) or $text eq '') and !defined($command));

   my $command_text = '';
   $command_text = "\[$command\]" if (defined($command));
   $command_text .= $text if (defined($text));
   print STDERR "Storing text ${command_text}\n";

   $text_entries->{'text'} = $text if (defined($text));
   $text_entries->{'command'} = $command if (defined($command));
   $text_entries->{'parent'} = $info_state->{'current'};
   push @{$info_state->{'current'}->{'content'}}, $text_entries;
   return info_default_output($info_state)
     if (!defined($info_state->{'current'}->{'command'}));
   return '';
}

sub info_default_begin_format_texi($$$)
{
   my $command = shift;
   my $line = shift;
   my $state = shift;

   my $info_state = info_default_get_state ($state);
   my ($parent_format, $in_format);
   ($parent_format, $in_format) = info_default_parent_format($info_state->{'current'});
   $info_state->{'paragraph_in_element_nr'}++ if (!$in_format);

   $parent_format->{'paragraph_in_element_nr'} = 0 if (!defined($parent_format->{'paragraph_in_element_nr'}));
   $parent_format->{'paragraph_in_element_nr'}++;

   info_default_open_command($state,$command) unless ($def_map{$command} and $command =~ /x$/);
   return $line;
}

sub info_default_begin_style_texi($$$$)
{
   my $command = shift;
   my $state = shift;
   my $stack = shift;
   my $real_style_command = shift;
   info_default_open_command($state,$command)
     unless ($info_default_accent_commands{$command} or exists $things_map{$command});
#      if ($real_style_command);
}

sub info_default_begin_paragraph_texi($$$)
{
   my $command = shift;
   my $paragraph_macros = shift;
   my $paragraph_command = shift;
   #print STDERR "begin_paragraph $command\n";
   my $state = shift;
   my $stack = shift;
   #my $info_state = info_default_get_state($state);
   info_default_open_command($state,$command);
   foreach my $style_command (@$paragraph_macros)
   {
     print STDERR "para stack: $style_command->{'style'}\n";
     info_default_open_command($state,$style_command->{'style'});
     #$info_state->{'current'}->{'no_open'} = 1;
   }
}

sub info_default_simple_command($$$$)
{
    my $command = shift;
    my $in_preformatted = shift;
    my $line_nr = shift;
    my $state = shift;

    my $result = $simple_map{$command};
    # discards '-' '|' '/' and ':'. If ':' is associated with a punctuation
    # character it is added to the tree in info_default_colon_command
    return info_default_store_text($state,$result,$command) if ($result ne '');
    return '';
    #return '' if info_default_store_text($state,$result,$command);
    #return $result;
}

sub info_default_colon_command($)
{
   my $punctuation_character = shift;
   if (defined($colon_command_punctuation_characters{$punctuation_character})
         and $punctuation_character =~ /^[$punctuation_characters]$/)
   {
      return info_default_store_text(undef,$colon_command_punctuation_characters{$punctuation_character}, ':');
   }
   else
   {
      return info_default_store_text(undef,$punctuation_character);;
   }
}

sub info_default_thing_command($$$$$)
{
    my $command = shift;
    my $text = shift;
    my $in_preformatted = shift;
    my $line_nr = shift;
    my $state = shift;

    my $result = $things_map{$command};
    #return info_default_close_command($state, $command, $result, $text, '');
    return info_default_store_text($state, $result, $command);
#    return $result . $text;
}


sub info_default_style($$$$$$$$$)
{
   my $style = shift; 
   my $command = shift;
   my $text = shift;
   my $args = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;
   my $state = shift;
   my $command_stack = shift;

   my $begin = '';
   my $end = '';

   # note that the $text is always discarded for closed commands

   # the formatting is done right here, without information on the current
   # state, and the result is entered as text below.
   if ($info_default_leaf_command{$command})
   {
      my $style_index = 0;
      my @formatted_args = ();
      foreach my $arg (@$args)
      {
         my $arg_style = $style->{'orig_args'}->[$style_index];
         if ($arg_style eq 'normal')
         {
            push @formatted_args, main::substitute_line($arg, "\@$command");
         }
         elsif ($arg_style eq 'code')
         {
            push @formatted_args, main::substitute_line($arg, "\@$command", {'code_style' => 1});
         }
         else
         {
            print STDERR "Unknown arg style($style_index) $arg_style for $command\n";
         }
         $style_index++;
      }
      $args = \@formatted_args; 
   }
   if (defined($style->{'function'}))
   {
      $text = &{$style->{'function'}}($command, $args, $command_stack, $state, $line_nr);
   }
   if (defined($style->{'begin'}) and !$no_open)
   {
      $begin = $style->{'begin'};
   }
   if (defined($style->{'end'}) and !$no_close)
   {
      $end = $style->{'end'};
   }
   unless($special_style{$command} or ($command eq 'cmd_line') or $info_default_accent_commands{$command} or ($command eq 'hyphenation') or $info_default_leaf_command{$command})
   {
      return info_default_close_command($state, $command, $begin, $end);
   }
   # this is for *ref, images and footnotes text registering and putting
   # in the tree.
   # anchor is already in the tree, from anchor_label.
   if (($special_style{$command} or $info_default_leaf_command{$command}) and $command ne 'anchor')
   {
       return info_default_store_text ($state, $begin.$text.$end, $command);
   }
   # we go here for cmd_line, and also for accents, hyphenation and anchor
   # (though the result for anchor is always an empty string).
   return $begin.$text.$end;
}

sub info_default_header ()
{
    return $Texi2HTML::THISDOC{'info_header'} if (defined($Texi2HTML::THISDOC{'info_header'}));
    #my $result = "This is $setfilename, produced by $Texi2HTML::THISDOC{program} from $Texi2HTML::THISDOC{'input_file_name'}.\n\n";
    # the following is wrong, $Texi2HTML::THISDOC{'input_file_name'} 
    # should be used 
    # directly, but then tests are not reproducible in out of source builds
    my $basename = $Texi2HTML::THISDOC{'input_file_name'};
    $basename =~ s/^.*\/// if ($TEST);
    $basename = $STDIN_DOCU_NAME if ($basename eq '-');
    my $result = "This is $Texi2HTML::THISDOC{'filename'}->{'top'}, produced by makeinfo version 4.13 from $basename. ";
    my $dummy;
    ($dummy, $dummy, $dummy, $dummy, $result) = info_default_process_text($result, 0, '', undef, undef, 1, $info_default_max_column);
    $result .= "\n\n";
    $result .= "$Texi2HTML::THISDOC{'copying_comment'}";
    if ($info_default_dir_specification)
    {
        $result .= "$info_default_dir_specification\n";
    }
    $Texi2HTML::THISDOC{'info_header'} = $result;
    return $result;
}

sub info_default_print_page_head($)
{
    my $fh = shift;
    my $header = info_default_header();
    print $fh "".$header;

    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    $info_state->{'offset_in_file'} += length($header);
    $info_state->{'blank_line'} = 1 if ($Texi2HTML::THISDOC{'copying_comment'} eq '');
}

sub info_default_parent_format($)
{
    my $parent_format = shift;
    my $in_format = 0;
    while (1)
    {
print STDERR "GGGGGGGGGGG $parent_format->{'command'}\n";
        if (defined($parent_format->{'command'}) and $info_default_format{$parent_format->{'command'}})
        {
            $in_format = 1;
            last;
        }
        last if (!defined($parent_format->{'parent'}));
        $parent_format = $parent_format->{'parent'};
    }
    return ($parent_format, $in_format);
}

sub info_default_paragraph($$$$$$$$$$$$)
{
    my $text = shift;
    my $align = shift;
    my $indent = shift;
    my $paragraph_command = shift;
    my $paragraph_command_formatted = shift;
    my $paragraph_number = shift;
    my $format = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $command_stack_at_end = shift;
    my $command_stack_at_begin = shift;

    my $top_stack = '';
    $top_stack = $command_stack_at_begin->[-1] if (scalar (@$command_stack_at_begin));

    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    my ($parent_format, $in_format);
    ($parent_format, $in_format) = info_default_parent_format($info_state->{'current'}->{'parent'});
    $parent_format->{'paragraph_in_format_nr'} = 0 if (!defined($parent_format->{'paragraph_in_format_nr'}));
    $parent_format->{'paragraph_in_format_nr'}++;

    $info_state->{'paragraph_in_element_nr'}++ if (!$in_format);
    my $additional_args = {'top_stack' => $top_stack, 'parent_format' => $parent_format};
    $additional_args->{'paragraph_in_element_nr'} = ($info_state->{'paragraph_in_element_nr'} - 1) if (!$in_format);
    
    return info_default_close_command(undef, 'paragraph', undef, undef, $additional_args);
}

# currently not used, but could be used if info_default_preformatted
# return something that is not 'false', for example spaces, though we
# want the preformatted to be ignored. Though it is not sure that if there
# are spaces we want to ignore the preformatted.
sub info_default_empty_preformatted($)
{
    my $text = shift;
    my $result = info_default_preformatted($text, undef, undef, undef, undef,
            undef, undef, undef, undef);
    return 0;
}

sub info_default_preformatted($$$$$$$$$$$$)
{
    my $text = shift;
    my $pre_style = shift;
    my $class = shift;
    my $leading_command = shift;
    my $leading_command_formatted = shift;
    my $preformatted_number = shift;
    my $format = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $command_stack_at_end = shift;
    my $command_stack_at_begin = shift;

    return info_default_close_command(undef, 'preformatted');
} 


my %default_info_level_to_symbol = (
  0 => '*',
  1 => '*',
  2 => '=',
  3 => '-',
  4 => '.'
);

sub info_default_node_line($$)
{
    my $element = shift;
    my $info_state = shift;
    my $outfile = $Texi2HTML::THISDOC{'filename'}->{'top'};
    $outfile = $STDOUT_DOCU_NAME if ($outfile eq '-');
    my $result = "\x{1F}\nFile: $outfile,  Node: $element->{'text'}";
    if (defined($element->{'NodeNext'}))
    {
       $result .= ','.&$I('  Next: %{node_next}', {'node_next' => $element->{'NodeNext'}->{'text'}});
    }
    if (defined($element->{'NodePrev'}))
    {
       $result .= ','.&$I('  Prev: %{node_prev}', {'node_prev' => $element->{'NodePrev'}->{'text'}});
    }
    if (defined($element->{'NodeUp'}))
    {
       $result .= ','.&$I('  Up: %{node_up}', {'node_up' => $element->{'NodeUp'}->{'text'}});
    }
    $result .= "\n\n";
    $info_state->{'line_count'} = 3;
    $info_state->{'offset_in_file'} += length($result);
    $info_state->{'blank_line'} = 1;
    return $result;
}

my $info_default_footnote_index;
my $info_default_current_node;
sub info_default_element_heading($$$$$$$$$$$$)
{
    my $element = shift;
    my $command = shift;
    my $texi_line = shift;
    my $line = shift;
    my $in_preformatted = shift;
    my $one_section = shift;
    my $element_heading = shift;
    my $first_in_page = shift;
    my $is_top = shift;
    my $previous_is_top = shift;
    my $command_line = shift;
    my $element_id = shift;
    my $new_element = shift;

    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);

    # FIXME use $element or $Texi2HTML::THIS_ELEMENT? Main program should 
    # ensure they are the same. 
    if ($new_element and ($element ne $new_element or !$element->{'node'}))
    {
        die "There is a new element, but element $element->{'texi'} is not a node or not the new element\n";
    }
    return &$heading($element, $command, $texi_line, $line, $in_preformatted, $one_section, $element_heading) unless ($new_element);

print STDERR "HHHHHHHHHHHHHHH node $info_state->{'nr'}\n";
    my $before = '';
    $element->{'info_offset'} = $info_state->{'offset_in_file'};
    push @{$info_state->{'pending_tags'}}, $element;

    my $result = info_default_node_line($element, $info_state);

    $info_default_footnote_index = 0;
    #$info_default_current_node = $Texi2HTML::THIS_ELEMENT;
    $info_default_current_node = $element;
    
    return $before.$result;
}

sub info_default_heading($$$$$;$$)
{
    my $element = shift;
    my $command = shift;
    my $texi_line = shift;
    my $line = shift;
    my $in_preformatted = shift;
    my $one_section = shift;
    my $element_heading = shift;

    die "Heading called for a node\n" if ($element->{'node'});
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
print STDERR "HHHHHHHHHHHHHHH section $info_state->{'nr'}\n";
    $info_state->{'paragraph_in_element_nr'} = 0;
    my $text = "$element->{'text'}";
    # to do the same than makeinfo a trailing dot in section number is removed
    $text =~ s/^(\w+)\. /$1 /;
    # when @top is empty, use settitle
    $text = $Texi2HTML::THISDOC{'settitle'} if (!length($text) and $element->{'tag'} eq 'top' and defined ($Texi2HTML::THISDOC{'settitle'}) and length($Texi2HTML::THISDOC{'settitle'}));
    $text = "Annexe $text" if ($element->{'tag'} =~ /appendix/ and $element->{'level'} <= 1);
    my $heading = $text . "\n" . 
       ($default_info_level_to_symbol{$element->{'level'}} x length($text)) . "\n";
    if (!$info_state->{'blank_line'})
    {
       $heading = "\n" .$heading;
       $info_state->{'line_count'}++;
    }

    if (length($text))
    {
       $heading .= "\n";
       $info_state->{'line_count'}++;
       $info_state->{'blank_line'} = 1;
    }
   
    $info_state->{'offset_in_file'} += length($heading);
    $info_state->{'line_count'} += 2;
    return $heading;
}

sub info_default_normal_text($$$$$$;$)
{
   my $text = shift;
   my $in_raw_text = shift; # remove_texi
   my $in_preformatted = shift;
   my $in_code = shift;
   my $in_simple = shift;
   my $style_stack = shift;
   my $state = shift;

#Data::Dumper->Dump([$state]);

#print STDERR "info_default_normal_text $text $in_preformatted $in_code \n";
   $text = uc($text) if (in_cmd($style_stack, 'sc'));
   $text = uc($text) if (in_cmd($style_stack, 'var'));
#   $text = &$protect_text($text) unless($in_raw_text);
   if (! $in_code and !$in_preformatted)
   {
       $text =~ s/---/\x{1F}/g;
       $text =~ s/--/-/g;
       $text =~ s/\x{1F}/--/g;
       $text =~ s/``/"/g;
       $text =~ s/\'\'/"/g;
   }
   else
   {
       # to be like texinfo
#       my $special_code = 0;
#       $special_code = 1 if (in_cmd($style_stack, 'code') or 
#           in_cmd($style_stack, 'example') or in_cmd($style_stack, 'verbatim'));
#       $text =~ s/'/\&rsquo\;/g unless ($special_code and exists($main::value{'txicodequoteundirected'}));
#       $text =~ s/`/\&lsquo\;/g unless ($special_code and exists($main::value{'txicodequotebacktick'}));
   }
   # accented characters are not handled as text, but when the last 
   # accent command on the stack is closed.
   if ($style_stack and @$style_stack and $info_default_accent_commands{$style_stack->[-1]})
   {
      return $text;
   }
   return info_default_store_text($state,$text);
   # We never store in the stack text in raw text (remove_texi).
#   unless ($in_raw_text)
#   {
#      return '' if (info_default_store_text($state,$text));
#   }
#   return $text;
}

# this is not called in preformatted
sub info_default_empty_line($$)
{
    my $text = shift;
    my $state = shift;
    #ignore the line if it just follows a deff
    #return '' if ($state->{'deff_line'});
    return info_default_store_text($state,$text);
#    return '';
}

# change interface?
sub info_default_anchor_label($$$)
{
    my $id = shift;
    my $anchor_text = shift;
    my $anchor_reference = shift;
    print STDERR "Storing anchor $anchor_reference->{'text'}\n";
   return info_default_store_text(undef,undef,'anchor',{'anchor_reference' => $anchor_reference});
}

sub info_default_acronym_like($$$$$$)
{
    my $command = shift;
    my $acronym_texi = shift;
    my $acronym_text = shift;
    my $with_explanation = shift;
    my $explanation_lines = shift;
    my $explanation_text = shift;
    my $explanation_simply_formatted = shift;

   if ($with_explanation)
   {
       return "$acronym_text ($explanation_text)";
   }
   else
   {
       return "$acronym_text";
   }
}


sub info_default_print_page_foot($)
{
   my $fh = shift;
   my $state = $Texi2HTML::THISDOC{'state'};
   my $info_state = info_default_get_state ($state);
   my $indirect = 0;
   return unless (defined ($info_state->{'pending_tags'}));
   $indirect = 1 if ($info_default_out_file_nr > 1);
   if ($indirect)
   {
       close ($Texi2HTML::THISDOC{'FH'});
       unless (rename ("$Texi2HTML::THISDOC{'destination_directory'}$Texi2HTML::THISDOC{'filename'}->{'top'}", "$Texi2HTML::THISDOC{'destination_directory'}$Texi2HTML::THISDOC{'filename'}->{'top'}-1"))
       {
           warn "Rename $Texi2HTML::THISDOC{'destination_directory'}$Texi2HTML::THISDOC{'filename'}->{'top'} failed: $!\n";
       }
       unless (open (INDIRECT, ">$Texi2HTML::THISDOC{'destination_directory'}$Texi2HTML::THISDOC{'filename'}->{'top'}"))
       {
           warn "Open $Texi2HTML::THISDOC{'destination_directory'}$Texi2HTML::THISDOC{'filename'}->{'top'} failed: $!\n";
       }
       print INDIRECT "".info_default_header();
       print INDIRECT "\x{1F}\nIndirect:";
       foreach my $indirect (@info_default_pending_indirect)
       {
           print INDIRECT "\n$indirect->{'file'}: $indirect->{'offset'}";
       }
       $fh = \*INDIRECT;
   }
   # makeinfo seems to add systematically an additional \n, done just below
   print $fh "\n\x{1F}\nTag Table:\n";
   
   if ($indirect)
   {
       print $fh "(Indirect)\n";
   }
   foreach my $element (@{$info_state->{'pending_tags'}})
   {
      my $prefix;
      $prefix = 'Node' if ($element->{'node'});
      $prefix = 'Ref' if ($element->{'anchor'} or $element->{'float'});
      print $fh "$prefix: $element->{'text'}\x{7F}$element->{'info_offset'}\n";
   }
   print $fh "\x{1F}\nEnd Tag Table\n";
}

sub info_default_print_Top_footer($$$)
{
    my $fh = shift;
    my $end_page = shift;
    my $element = shift;
    if ($end_page)
    {
        &$print_page_foot($fh);
    }
}

sub info_default_footnote_texi($$$)
{
    my $text = shift;
    my $state = shift;
    my $style_stack = shift;
    
    $info_default_footnote_index++;
    return "($info_default_footnote_index) $text";
}

sub info_default_print_section
{
    my $fh = shift;
    my $first_in_page = shift;
    my $previous_is_top = shift;
    my $element = shift;
    my $nw = main::print_lines($fh);
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    if (!$info_state->{'blank_line'})
    {
       my $end = "\n";
       $info_state->{'offset_in_file'} += length($end);
       $info_state->{'line_count'}++;
       print $fh "$end";
    }
    if (@info_default_pending_footnotes)
    {
        my $footnote_text;
        if ($SEPARATED_FOOTNOTES)
        {
            my $node_ref = $info_default_current_node;
            $node_ref = {'text' => 'no node', 'file' => ''} if (!defined($node_ref));
            my $footnote_element = { 'NodeUp' => $node_ref, 
                       'text' => $node_ref->{'text'} . "-Footnotes", 
                       'file' => $node_ref->{'file'},
                       'info_offset' => $info_state->{'offset_in_file'},
                       'node' => 1
                 };
            push @{$info_state->{'pending_tags'}}, $footnote_element;
            $footnote_text = info_default_node_line($footnote_element, $info_state); 
        }
        else
        {
            $footnote_text = "   ---------- Footnotes ----------\n\n";
            $info_state->{'offset_in_file'} += length($footnote_text);
        }
        while (@info_default_pending_footnotes)
        {
    #push @info_default_pending_footnotes, [$lines, $footnote_text, ${info_default_footnote_index}, $node_name, $footnote_info_state];
            my $footnote = shift @info_default_pending_footnotes;
            my $foot_nr = $footnote->{'footnote_index'};
            my $node_name = $footnote->{'node_name'};
            my $lines = $footnote->{'lines'};
            push @{$info_state->{'pending_tags'}}, {'anchor' => 1, 'text' => "${node_name}-Footnote-${foot_nr}", 'info_offset' => $info_state->{'offset_in_file'} };
            my $footnote_info_state = $footnote->{'footnote_info_state'};
            my $footnote_result = shift @{$lines};
            my $initial_length = length($footnote_result);
            $footnote_result =~ s/^\s*//;
            #$footnote_result = "   ($foot_nr) " . $footnote_result;
            $footnote_result = "   " . $footnote_result;
            foreach my $footnote_pending_tags(@{$footnote_info_state->{'pending_tags'}})
            {
               $footnote_pending_tags->{'info_offset'} += $info_state->{'offset_in_file'} + length($footnote_result) - $initial_length;
               push @{$info_state->{'pending_tags'}}, $footnote_pending_tags;
            }
            my $line;
            while (@$lines)
            {
               $line = shift @$lines;
               $footnote_result .= $line;
            }
            my ($line_passed, $end_of_line, $last_line, $text_indented) = info_default_count_lines($footnote_result, $info_state);
            if ($line_passed == 0)
            {# certainly out of paragraph commands
               $footnote_result =~ s/\s*$//;
               $footnote_result .= "\n";
               $line_passed = 1;
            }
            $footnote_result .= "\n";
            $info_state->{'offset_in_file'} += length($footnote_result);
            $info_state->{'line_count'} += $line_passed +1;
            $footnote_text .= $footnote_result;
        }
        print $fh "$footnote_text";
    }
}

sub info_default_end_section($$$)
{
    my $fh = shift;
    my $end_foot_navigation = shift;
    my $element = shift;
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);

    if (defined($Texi2HTML::THISDOC{'SPLIT_SIZE'}) and 
   $info_state->{'offset_in_file'} > ($info_default_out_file_nr) * $Texi2HTML::THISDOC{'SPLIT_SIZE'})
    {
       if ($info_default_out_file_nr == 1)
       {
          push @info_default_pending_indirect, {'file'=>"$Texi2HTML::THISDOC{'filename'}->{'top'}-$info_default_out_file_nr", 'offset' => $info_state->{'pending_tags'}->[0]->{'info_offset'} };
       }
       $info_default_out_file_nr++;
       close($Texi2HTML::THISDOC{'FH'});
       main::open_out_file("$Texi2HTML::THISDOC{'filename'}->{'top'}-$info_default_out_file_nr");
       print STDERR "X-$info_default_out_file_nr: $info_state->{'offset_in_file'}\n";
       &$print_page_head($Texi2HTML::THISDOC{'FH'});
       push @info_default_pending_indirect, {'file'=>"$Texi2HTML::THISDOC{'filename'}->{'top'}-$info_default_out_file_nr", 'offset' => $info_state->{'offset_in_file'}};
    }
}

sub info_default_one_section($$)
{
    my $fh = shift;
    my $element = shift;
    &$print_section($fh, 1, 0, $element);
    &$print_page_foot($fh);
}

sub info_default_begin_special_region($$$)
{
    my $region = shift;
    my $state = shift;
    my $lines = shift;
    my $info_state = info_default_get_state ($state);
    # reset paragraph_in_element_nr if out ofdocument formatting
    if ($state->{'outside_document'})
    {
        $info_state->{'paragraph_in_element_nr'} = 0;
    }
}

sub info_default_end_special_region($$$)
{
    my $region = shift;
    my $state = shift;
    my $text = shift;
    my $info_state = info_default_get_state ($state);
    my $end = '';
    if (!$info_state->{'blank_line'})
    {
       $end = "\n";
       $info_state->{'offset_in_file'} += length($end);
    }
    return $text.$end;
}

sub info_default_menu_link($$$$$$$$)
{
    my $entry = shift;
    my $state = shift;
    my $href = shift;
    my $node = shift;
    my $title = shift;
    my $ending = shift;
    my $has_title = shift;
    my $command_stack = shift;
    my $preformatted = shift;

    $title = '' unless ($has_title);
    $title .= ':' if ($title ne '');
    my $result = "$MENU_SYMBOL$title$node$ending";
    return info_default_store_text($state,$result,'menu_entry');
}

# not used, menu is a normal preformatted command
#sub info_default_menu_command($$$)
#{
#    my $format = shift;
#    my $text = shift;
#    my $in_preformatted = shift;
#print STDERR "MENU $format\n";
#    return info_default_close_command(undef, $format, "* Menu:\n", undef, "\n");
#}   

sub info_default_complex_format($$)
{
    my $name = shift;
    my $text = shift;
    my ($begin, $end);
    if ($name eq 'menu')
    {
        $begin = "* Menu:\n\n";
        $end = "\n";
    }
    return info_default_close_command(undef, $name, $begin, $end);
}

sub info_default_quotation($$$$)
{
    my $command = shift;
    my $text = shift;
    my $argument_text = shift;
    my $argument_text_texi = shift;

    return info_default_close_command(undef, $command);
}

sub info_default_misc_commands($$$$$)
{
    my $command = shift;
    my $line = shift;
    my $pass = shift;
    my $stack = shift;
    my $state = shift;

    return ($line, 0, undef, undef) unless ($pass == 2);
    return ($line, 0, undef, undef) unless ($command eq 'exdent' or $command eq 'noindent' or $command eq 'indent');
    my ($result_line, $text, $args) = &$preserve_misc_command ($line, $command);
    info_default_store_text($state,'',$command);
    return ($result_line, 1, '', undef);
}

sub info_default_external_ref($$$$$$$$)
{
    my $type = shift;
    my $section = shift;
    my $book = shift;
    my $file_node = shift;
    my $href = shift;
    my $cross_ref = shift;
    my $args_texi = shift;
    my $formatted_args = shift;

    return info_default_inforef($formatted_args) if ($type eq 'inforef');
    return info_default_normal_reference($type, $formatted_args);
}

sub info_default_internal_ref($$$$$$$$)
{
    my $type = shift;
    my $href = shift;
    my $short_name = shift;
    my $name = shift;
    my $is_section = shift;
    my $args_texi = shift;
    my $formatted_args = shift;
    my $element = shift;

    $formatted_args->[1] = $name if ($element->{'float'} and (!defined($formatted_args->[1]) or $formatted_args->[1] eq ''));
    return info_default_inforef($formatted_args) if ($type eq 'inforef');
    return info_default_normal_reference($type, $formatted_args);
}

sub info_default_normal_reference($$)
{
    my $command = shift;
    my $formatted_args = shift;
    for (my $i = 0; $i < scalar(@$formatted_args); $i++)
    {
       $formatted_args->[$i] = undef if (defined($formatted_args->[$i]) and 
          $formatted_args->[$i] =~ /^\s*$/);
    }
    my $node = $formatted_args->[0];
    my $name = $formatted_args->[1];
    $name =  $formatted_args->[2] if (!defined($name));
    my $file = $formatted_args->[3];
    $file = '' if (!defined($file) and defined($formatted_args->[4]));
    $name = $node if (!defined($name) and defined($file));
    my $result = '*note ';
    $result = '*Note ' if ($command eq 'xref');
    if (defined($name))
    {
       $result .= "${name}: ";
       $result .= "($file)" if (defined($file));
       $result .= "$node";
       $result .= '.' if ($command eq 'pxref');
    }
    else
    {
       $result .= "${node}::";
    }
    return $result;
}

sub info_default_inforef($)
{
    my $formatted_args = shift;
    return info_default_normal_reference('ref', [$formatted_args->[0], $formatted_args->[1], undef, $formatted_args->[2], 'dumb manual name']);
}

sub info_default_image_files($$$$)
{
    my $base = shift;
    my $extension = shift;
    my $texi_base = shift;
    my $texi_extension = shift;
    my @files = ();
    return @files if (!defined($base) or ($base eq ''));

    if (defined($extension) and ($extension ne ''))
    {
        push @files, ["${base}$extension", "${texi_base}$extension"];
        push @files, ["$base.$extension", "$texi_base.$extension"];
    }
    foreach my $ext (@IMAGE_EXTENSIONS)
    {
        push @files, ["$base.$ext", "$texi_base.$ext"];
    }
    return @files;
}

sub info_default_image($$$$$$$$$$$$$$$$$)
{
    my $file = shift;
    my $base = shift;
    my $preformatted = shift;
    my $file_name = shift;
    my $alt = shift;
    my $width = shift;
    my $height = shift;
    my $raw_alt = shift;
    my $extension = shift;
    my $working_dir = shift;
    my $file_path = shift;
    my $in_paragraph = shift;
    my $file_locations = shift;
    my $base_simple_format = shift;
    my $extension_simple_format = shift;
    my $file_name_simple_format = shift;
    my $line_nr = shift;

    my $txt_path;
    my $found_file;

    my @extensions = @IMAGE_EXTENSIONS;
    if (defined($extension) and ($extension ne ''))
    {
        unshift @extensions, ".$extension";
        unshift @extensions, "$extension";
    }
    else
    {
        $extension = undef;
    }
    my $file_found_index = undef;
    my $file_index = 0;
    foreach my $file_location (@$file_locations)
    {
        my ($file_located, $path, $file_simple_format) = @$file_location;
        my $extension = shift @extensions;
        if (defined($path))
        {
           if ($extension eq 'txt' and !defined($txt_path))
           {
              $txt_path = $path;
           }
           elsif (!defined($found_file))
           {
              $found_file = [$file_located, $extension, $file_simple_format];
              $file_found_index = $file_index;
           }
        }
        $file_index++;
    }

    my $text;
    if (defined($txt_path))
    {
       if (open(TXT, "<$txt_path"))
       {
          if (defined($Texi2HTML::THISDOC{'IN_ENCODING'}) and $USE_UNICODE)
          {
              binmode(TXT, ":encoding($Texi2HTML::THISDOC{'IN_ENCODING'})");
          }
          $text='[' if ($in_paragraph or $preformatted);
          while (my $img_txt = <TXT>)
          {
              $text .= $img_txt;
          }
          $text .= ']' if ($in_paragraph or $preformatted);
          close(TXT);
       }
       else
       {
          main::echo_warn ("\@image file `$txt_path' unreadable: $!", $line_nr);
       }
    }
    else
    {
        main::echo_warn ("Cannot find \@image file `$base.txt'", $line_nr);
    }
    if (defined($found_file) and (!defined($extension) or $file_found_index <= 1))
    {
        my $filename = $found_file->[2];
        $filename =~ s/\\/\\\\/g;
        $filename =~ s/\"/\\\"/g;
        my $result = "\x{00}\x{08}[image src=\"$filename\"";
        if (defined($alt))
        {
            $alt =~ s/\\/\\\\/g;
            $alt =~ s/\"/\\\"/g;
            $result .= " alt=\"$alt\"";
        }
        if (defined($text))
        {
            $text =~ s/\\/\\\\/g;
            $text =~ s/\"/\\\"/g;
            $result .= " text=\"$text\"";
        }
        $result .= "\x{00}\x{08}]";
        return $result;
    }
    return $text if (defined($text));
    return '';
}

sub info_default_print_index($$)
{
    my $text = shift;
    my $name = shift;
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    my $before = '';
    if (!$info_state->{'blank_line'})
    {
       $before = "\n";
       $info_state->{'offset_in_file'} += length($before);
       $info_state->{'line_count'}++;
       $info_state->{'blank_line'} = 1;
    }
    return $before if (!defined($text));
    my $result = "\x{00}\x{08}[index\x{00}\x{08}]\n* Menu:\n\n" .$text."\n";
    $info_state->{'offset_in_file'} += length($result);

    my ($line_passed, $end_of_line, $last_line, $text_indented) = info_default_count_lines($result, $info_state);
    $info_state->{'blank_line'} = 1 if ($last_line !~ /\S/ and $end_of_line);
    $info_state->{'line_count'} += $line_passed;
    return $before.$result;
}

sub info_default_index_letter($$$)
{
     my $letter = shift;
     my $id = shift;
     my $text = shift;
     return $text;
}

sub info_default_index_entry_label($$$$$$$$)
{
    my $identifier = shift;
    my $preformatted = shift;
    my $entry = shift;
    my $index_name = shift;
    my $index_command = shift;
    my $texi_entry = shift;
    my $formatted_entry = shift;
    my $index_entry_ref = shift;

    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state($state);
    print STDERR "Storing index entry $formatted_entry\n";
    my $index_entry_stored = {'command' => 'index_label', 'index_entry_reference' => $index_entry_ref, 'index_command' => $index_command, 'index_name' => $index_name};
    push @{$info_state->{'current'}->{'content'}}, $index_entry_stored;
   return info_default_output($info_state)
     if (!defined($info_state->{'current'}->{'command'}));
   return '';
}

my $info_default_index_length_to_node = 41;
sub info_default_index_entry($$$$$$$$)
{
    my $text_href = shift;
    my $entry = shift;
    my $element_href = shift;
    my $element_text = shift;
    my $entry_file = shift;
    my $current_element_file = shift;
    my $entry_target = shift;
    my $entry_element_target = shift;
    my $index_entry_ref = shift;

    return '' if ($index_entry_ref->{'hidden'});
    $entry = main::substitute_line($index_entry_ref->{'texi'}, "index entry in \@printindex");

    my $result = "* $entry: ";
    if (length($result) < $info_default_index_length_to_node)
    {
       $result .= ' ' x($info_default_index_length_to_node - length($result));
    }
    $result .= $element_text . '.';
    my $info_index_entry_ref = $info_default_index_entries{$index_entry_ref};
    my $line_nr = $info_index_entry_ref->{'line_nr'};
    # this happens for index entries appearing after @printindex. In that case
    # it is consideered that they are at the beginning of the node.
    $line_nr = 4 if (!defined($line_nr));
    my $max_len = $info_default_index_line_string_length{$info_index_entry_ref->{'index_name'}};
    my $line_nr_spaces = sprintf("%${max_len}d", $line_nr);
    my $line_part = "(line ${line_nr_spaces})";
#print STDERR "GGGGGGGGGG name: $info_index_entry_ref->{'index_name'} max: ${max_len} line_nr: `$line_nr' line_nr_spaces `$line_nr_spaces' $line_part \n";
    if (length($result)+length($line_part) +1 >  $info_default_max_column)
    {
        $result .= "\n" . ' ' x ($info_default_max_column - length($line_part)) ;
    }
    else
    {
        $result .= ' ' x ($info_default_max_column - length($line_part) - length($result));
    }
    $result .= "$line_part\n";

    return $result;
}

sub info_default_index_summary($$)
{
    my $alpha = shift;
    my $nonalpha = shift;

    return '';
}

sub info_default_summary_letter
{
    return '';
}

sub info_default_foot_line_and_ref($$$$$$$$)
{
    my $foot_num = shift;
    my $relative_num = shift;
    my $footid = shift;
    my $docid = shift;
    my $from_file = shift;
    my $footnote_file = shift;
    my $lines = shift;
    my $state = shift;
 
    my $footnote_state = $Texi2HTML::THISDOC{'state'};
    my $footnote_info_state = info_default_get_state ($footnote_state);

    my $footnote_text = "($info_default_footnote_index)";
    my $node_name;
    $node_name = '';
    $node_name = $info_default_current_node->{'text'} if defined($info_default_current_node);
    if ($SEPARATED_FOOTNOTES)
    {
        $footnote_text .=  ' (' . info_default_normal_reference('pxref', ["${node_name}-Footnote-${info_default_footnote_index}"]) . ')';
    }
    push @info_default_pending_footnotes, {'lines' => $lines, 
         'footnote_text' => $footnote_text, 
         'footnote_index' => ${info_default_footnote_index}, 
         'node_name' => $node_name, 
         'footnote_info_state' => $footnote_info_state};
    return ($lines,  $footnote_text);
}

sub info_default_foot_lines($)
{
    my $lines = shift;
    #my $state = $Texi2HTML::THISDOC{'state'};
    #my $info_state = info_default_get_state ($state);
    @$lines = ();
}

# remark: table_item is the html one, but it gets added to the table text
# on the stack, and is ignored there (in info_default_format).
sub info_default_format_list_item_texi($$$$)
{
    my $format = shift;
    my $line = shift;
    my $prepended = shift;
    my $command = shift;
    my $number = shift;

    my $open_command = 0;
    my $result_line;
    $command = 'bullet' if ((!defined($command) or $command eq '') and (!defined($prepended) or $prepended eq '') and $format eq 'itemize');
    $prepended = "\@$command\{\}" if (defined($command) and $command ne '');
    $prepended = "$number." if (defined($number) and $number ne '');
 
    if (defined($command) and $command ne '' and $format ne 'itemize')
    {
        #@*table
        #info_default_begin_style_texi($command, $Texi2HTML::THISDOC{'state'}, undef, undef);
        #$open_command = 1;
        $line =~ s/^\s*//;
        $line =~ s/\s*$//;
        if (exists ($style_map{$command}))
        {
           $result_line = "\@$command\{$line\}\n";
        }
        elsif (exists ($things_map{$command}))
        {
           $result_line = "\@$command\{\} $line\n";
        }
        else
        {
           $result_line = "\@$command $line\n";
        }
    }
    elsif (defined($prepended) and $prepended ne '')
    {
         $prepended =~ s/^\s*//;
         $prepended =~ s/\s*$//;
         $line =~ s/^\s*//;
         $result_line = $prepended . ' ' . $line;
    }

    return ($result_line, $open_command);
}

sub info_default_list_item($$$$$$$$$$$)
{
    my $text = shift;
    my $format = shift;
    my $command = shift;
    my $formatted_command = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $prepended = shift;
    my $prepended_formatted = shift;
    my $only_inter_item_commands = shift;
    my $before_items = shift;

#    my $prepend = '';
#    if (defined($formatted_command) and $formatted_command ne '')
#    {
#        $prepend = $formatted_command;
#    }
#    return $prepend . $text;
    return $text;
}

sub info_default_format($$$)
{
    my $tag = shift;
    my $element = shift;
    my $text = shift;

    # currently no command has something else than '' as $element.
    # notice that any text is discarded
    $element = undef if ($element eq '');
    my $element_end = $element;
    if (defined($element) and $element =~ /^(\w+)(\s+)(.+)/)
    {
        $element = $1;
        $element_end = $2;
    }
    return info_default_close_command(undef, $tag, $element, $element_end);
}

sub info_default_tab_item_texi($$$$$$)
{
   my $command = shift;
   my $commands_stack = shift;
   my $stack = shift;
   my $state = shift;
   my $line = shift;
   my $line_nr = shift;

   my $format;
   $format = $commands_stack->[-1] if (defined($commands_stack) and @$commands_stack and $commands_stack->[-1]);
print STDERR "tab_item_texi $command $commands_stack, $stack, $state, $line, $line_nr\n";
   if ($format eq 'multitable')
   {
       if ($command ne 'tab')
       {
           info_default_open_command($state, 'multitable_row');
       }
       info_default_open_command($state, 'multitable_cell');
   }
   else
   {
       info_default_store_text ($state, '', $command, {'format_name' => $format});
   }
   return undef;
}

sub info_default_sp($$)
{
   my $number = shift;
   my $preformatted = shift;
   my $result = "\n" x $number;
   return info_default_store_text(undef,$result,'sp');
}

sub info_default_paragraph_style_command($$)
{
    my $format = shift;
    my $text = shift;
    return info_default_close_command(undef, $format);
}

sub info_default_row($$$$$$$$)
{
    my $text = shift;
    my $macro = shift;
    my $columnfractions = shift;
    my $prototype_row = shift;
    my $prototype_lengths = shift;
    my $column_number = shift;
    my $only_inter_item_commands = shift;
    my $before_items = shift;

    return info_default_close_command(undef, 'multitable_row', undef, undef, {'item_command' => $macro});
}

sub info_default_cell($$$$$$$$)
{
    my $text = shift;
    my $row_macro = shift;
    my $columnfractions = shift;
    my $prototype_row = shift;
    my $prototype_lengths = shift;
    my $column_number = shift;
    my $only_inter_item_commands = shift;
    my $before_items = shift;

    return info_default_close_command(undef, 'multitable_cell');
}

sub info_default_table_list($$$$$$$$$)
{
    my $format_command = shift;
    my $text = shift;
    my $command = shift;
    my $formatted_command = shift;
# enumerate
    my $item_nr = shift;
    my $enumerate_style = shift;
# itemize
    my $prepended = shift;
    my $prepended_formatted = shift;
# multitable
    my $columnfractions = shift;
    my $prototype_row = shift;
    my $prototype_lengths = shift;
    my $column_number = shift;

    return info_default_close_command(undef, $command) if ($format_command ne 'multitable');

    my $columnsize = [];
    if (defined($prototype_lengths) and @$prototype_lengths)
    {
       $columnsize = [ @$prototype_lengths ];
    }
    elsif (defined($columnfractions) and @$columnfractions)
    {
       foreach my $fraction (@$columnfractions)
       {
          push @$columnsize, int($fraction * $info_default_max_column +0.5);
       }
    }
    else 
    {
       print STDERR "Empty multitable?\n";
    }

    return info_default_close_command(undef, $format_command, undef, undef, {'columns_size' => $columnsize});
}

sub info_default_def_item($$$)
{
    my $text = shift;
    my $only_inter_item_commands = shift;
    my $command = shift;

    my $format = 'deff_item';
    $format = 'deff_itemx' if ($command =~ /x$/);
 print STDERR "LLLLLLLLLLLLLL $format $command\n";
    return info_default_close_command(undef, $format);
}

sub info_default_def_line($$$$$$$$$$$$$$$$)
{
   my $category_prepared = shift;
   my $name = shift;
   my $type = shift;
   my $arguments = shift;
   my $index_label = shift;
   my $arguments_array = shift;
   my $arguments_type_array = shift;
   my $unformatted_arguments_array = shift;
   my $command = shift;
   my $class_name = shift;
   my $category = shift;
   my $class = shift;
   my $style = shift;
   my $original_command = shift;

   $name = '' if (!defined($name) or ($name =~ /^\s*$/));
   $type = '' if (!defined($type) or $type =~ /^\s*$/);
   $arguments = '' if (!defined($arguments) or $arguments =~ /^\s*$/);

   my $type_name = '';
   $type_name .= "$type " if ($type ne '');
   $type_name .= $name if ($name ne '');

   my $result = " -- $category_prepared: ${type_name}$arguments";
   $result =~ s/\s*$//;
   $result .= "\n";
   my $state = $Texi2HTML::THISDOC{'state'};
#   if ($command =~ /x$/)
#   {
    info_default_store_text(undef,$result,"${command}_line",{'definition_line' => 1});
#   }
#   else
#   {
#      return info_default_open_command($state, $command, {'begin'=>$result});
#   }
    my $format = 'deff_item';
    $format = 'deff_itemx' if ($original_command =~ /x$/);
    print STDERR "JJJJJJJJJJJJJ $command GGG $original_command $format\n";
    return info_default_open_command($state, $format);
}

sub info_default_def($$)
{
    my $text = shift;
    my $command = shift;
    return info_default_close_command(undef, $command);
}

sub info_default_float($$$$$)
{
    my $text = shift;
    my $float = shift;
    my $caption = shift;
    my $shortcaption = shift;

    my $additional_arguments;
    if (exists($float->{'id'}))
    {
        $additional_arguments->{'anchor_reference'} = $float;
    }
    my $caption_text = '';

    if (defined($float->{'caption_texi'}))
    {
        $caption_text = $caption;
    }
    elsif (defined($float->{'shortcaption_texi'}))
    {
        $caption_text = $shortcaption;
    }
    elsif (defined($caption))
    {
        $caption_text = $caption;
    }

    #return $caption_text;
    return info_default_close_command(undef, 'float', undef, $caption_text, $additional_arguments);
}

my $info_default_listoffloat_caption_entry_length = 41;
my $info_default_listoffloat_append = '...:    ';
sub  info_default_listoffloats_entry($$$$)
{
    my $style_texi = shift;
    my $float = shift;
    my $float_style = shift;
    my $caption = shift;
    my $href = shift;

    my @lines = split /^/, $caption;
    $caption = $lines[0];
    chomp ($caption);

    my $result = '';
    $caption .= ':' if ($caption ne '');
    my $caption_entry = "* $float_style: $caption";
    my $length = 0;
    while ($caption_entry =~ s/^(\S+\s*)//)
    {
print STDERR "CAPTION_ENTRY($length) $caption_entry\n";
       my $new_word = $1;
       if (length($new_word) + $length > ($info_default_listoffloat_caption_entry_length - 3) or (length($new_word) + $length + length($info_default_listoffloat_append) >  $info_default_listoffloat_caption_entry_length and $caption_entry ne ''))
       {
           $result .= $info_default_listoffloat_append;
           last;
       }
       else
       {
           $result .= $new_word;
           $length += length($new_word);
       }
    }
print STDERR "RESULT `$result'\n";
    $result .= ' ' x ($info_default_listoffloat_caption_entry_length - length($result));
print STDERR "RESULT `$result'\n";
    
    return "${result}$float->{'text'}.\n";
}

sub info_default_listoffloats($$$)
{
   my $style_texi = shift;
   my $style = shift;
   my $float_entries = shift;

   my $state = $Texi2HTML::THISDOC{'state'};
   my $info_state = info_default_get_state ($state);
   my $result = "* Menu:\n\n";
   foreach my $float_entry (@$float_entries)
   {
       $result .= $float_entry;
   }
   my ($parent_format, $in_format);
   ($parent_format, $in_format) = info_default_parent_format($info_state->{'current'});
#print STDERR "JJJJJJJJJJj listoffloats not in top\n" if ($in_format);
   $info_state->{'paragraph_in_element_nr'}++ if (!$in_format);
   return info_default_store_text($state,$result,'listoffloats');
}

sub info_default_raw($$)
{
    my $style = shift;
    my $text = shift;
    my $expanded = 1 if (grep {$style eq $_} @EXPAND);
    if ($style eq 'verbatim' or $style eq 'verbatiminclude' or $expanded)
    {
        return info_default_store_text(undef,$text, $style);
    }
    if ($style eq 'direntry')
    {
        $info_default_dir_specification .= "START-INFO-DIR-ENTRY\n" 
           .$text. "END-INFO-DIR-ENTRY\n";
    }
    return '';
}

sub info_default_line_command($$$$)
{
    my $command = shift;
    my $arg_text = shift;
    my $arg_texi = shift;
    my $state = shift;

    return '' if ($arg_text eq '');
    $info_default_dir_specification .= "INFO-DIR-SECTION $arg_text\n";
    return '';
}

# info is special, since it doesn't use the basename but directly the 
# setfilename output, contrary to all the other formats
sub info_default_element_file_name($$$)
{
    my $element = shift;
    my $type = shift;
    my $prefix = shift;

    my $outname;
    $outname = $OUT if (defined($OUT) and $Texi2HTML::THISDOC{'input_file_number'} == 0);
    if ($type eq 'doc') 
    {
       if (defined($Texi2HTML::THISDOC{'setfilename'}) and !defined($outname))
       {
          $Texi2HTML::THISDOC{'extension'} = '';
          return $Texi2HTML::THISDOC{'setfilename'};
       }
    }

    return undef;
}

1;
