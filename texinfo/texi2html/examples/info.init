
########## WORK IN PROGRESS ##################

#+##############################################################################
#
# info.init: convert to info
#
#    Copyright (C) 2008  Patrice Dumas <dumas@centre-cired.fr>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#    02110-1301  USA
#
#-##############################################################################

use Data::Dumper;

$USE_NODES = 1;
$USE_SECTIONS = 0;
@EXPAND = ('info');
$EXTENSION = 'info';
$SHOW_MENU = 1;
$USE_SETFILENAME = 1;
$IGNORE_BEFORE_SETFILENAME = 1;
$NODE_NAME_IN_MENU = 1;
$SPLIT_INDEX = 0;
$SEPARATED_FOOTNOTES = 0;
$INLINE_CONTENTS = 1;

%simple_map = %ascii_simple_map;
%simple_map_pre = %simple_map;
%simple_map_texi = %simple_map;

%things_map = %ascii_things_map;
%pre_map = %things_map;

# sc and var upcase.
my @simple_quoted_commands = ('cite', 'code', 'command', 'env', 'file', 'kbd',
  'option', 'samp');
# slanted? 
my @asis_commands = ('asis', 'b', 'ctrl', 'dmn', 'i', 'math', 'sc', 't', 'r', 
  'slanted', 'var', 'titlefont', 'verb');
my @chevron_commands = ('key', 'indicateurl');

foreach my $accent_command ('tieaccent', 'dotless', keys(%unicode_accents), keys(%accent_map))
{
     #$style_map{$accent_command} = { 'function' => \&t2h_roff_accent };
     $style_map{$accent_command} = '&roff_accent';
}

foreach my $command (keys(%style_map))
{
    delete $style_map{$command}->{'attribute'} if (exists($style_map{$command}->{'attribute'}));
    delete $style_map{$command}->{'quote'} if (exists($style_map{$command}->{'quote'}));
    if (grep {$_ eq $command} @simple_quoted_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        $style_map{$command}->{'begin'} = '`';
        $style_map{$command}->{'end'} = "'";
        next;
    }
    elsif (grep {$_ eq $command} @asis_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        delete $style_map{$command}->{'begin'} if  (exists($style_map{$command}->{'begin'}));
        delete $style_map{$command}->{'end'} if  (exists($style_map{$command}->{'end'}));
    }
    if (grep {$_ eq $command} @chevron_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        $style_map{$command}->{'begin'} = '<';
        $style_map{$command}->{'end'} = '>';
        next;
    }
}

$style_map{'strong'}->{'begin'} = '*';
$style_map{'strong'}->{'end'} = '*';
$style_map{'dfn'}->{'begin'} = '"';
$style_map{'dfn'}->{'end'} = '"';
$style_map{'emph'}->{'begin'} = '_';
$style_map{'emph'}->{'end'} = '_';

foreach my $command (keys(%style_map))
{
    $style_map_pre{$command} = {};
    $style_map_texi{$command} = {};
    foreach my $key (keys(%{$style_map{$command}}))
    {
        $style_map_pre{$command}->{$key} = $style_map{$command}->{$key};
        $style_map_texi{$command}->{$key} = $style_map{$command}->{$key};
    }
}

$style_map{'uref'}->{'function'} = \&info_default_uref;
$style_map{'url'}->{'function'} = \&info_default_uref;

sub info_default_uref($$)
{
    shift;
    my $args = shift;
    my $url = shift @$args;
    my $text = shift @$args;
    my $replacement = shift @$args;
    #$url =~ s/\s*$//;
    #$url =~ s/^\s*//;
    $url = main::normalise_space($url);
    $replacement = '' if (!defined($replacement));
    $replacement = main::normalise_space($replacement);
    return $replacement if ($replacement ne '');
    $text = '' if (!defined($text));
    $text = main::normalise_space($text);
    return "`$url'" if ($text eq '');
    return "$text ($url)";
}

$style_map{'email'}->{'function'} = \&info_default_email;
sub info_default_email($$)
{
    my $command = shift;
    my $args = shift;
    my $mail = shift @$args;
    my $text = shift @$args;
    $mail = main::normalise_space($mail);
    $text = '' if (!defined($text));
    $text = main::normalise_space($text);
    $mail = "<$mail>";
    return $mail unless ($text ne '');
    return "$text $mail";
}


my $default_style_reference = $style;
$style = \&info_default_style;
$print_page_head   = \&info_default_print_page_head;
$copying_comment   = \&info_default_copying_comment;
$element_heading   = \&info_default_element_heading;
$heading           = \&info_default_heading;
$normal_text       = \&info_default_normal_text;
$paragraph         = \&info_default_paragraph;
$empty_line               = \&info_default_empty_line;
# maybe should not be called from the main program?
$print_page_foot   = \&info_default_print_page_foot;
$print_section     = \&info_default_print_section;
$one_section       = \&info_default_one_section;

sub info_default_count_bytes()
{
}

sub info_default_copying_comment($$$$)
{
    my $copying_lines = shift;
    my $copying_text = shift;
    my $copying_no_texi = shift;
    my $copying_simple_text = shift;
    return '' if ($copying_text eq '');
    return $copying_text;
}
my @all_stacks;
my $info_default_top_stack = {};

sub info_default_close_command($$$$$)
{
   my $command_stack = shift;
   my $command = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;
   $no_open = 0 if (!defined($no_open));
   $no_close = 0 if (!defined($no_close));
   my $current_command = $info_default_top_stack;
   main::echo_warn("$command, (@$command_stack) (n_c:$no_close, n_o:$no_open)", $line_nr);
   print STDERR "" . Data::Dumper->Dump([$current_command]);
   foreach my $command_name (@$command_stack)
   {
      if (!defined($current_command->{'command'}))
      {
         print STDERR "Adding $command_name as $current_command\n";
         $current_command->{'command'} = $command_name;
         $current_command->{'content'} =  [ {} ];
         $current_command = $current_command->{'content'}->[0];
      }
      else
      {
         if ($current_command->{'command'} ne $command_name)
         {
            print STDERR "current_command->{'command'} $current_command->{'command'} ne command_name $command_name\n";
         }
         print STDERR "current_command->{'content'} not defined\n" if (!defined( $current_command->{'content'}));
         print STDERR "current_command->{'content'}->[-1] not defined\n" if (!defined( $current_command->{'content'}->[-1]));
         my $last_command = $current_command->{'content'}->[-1];
         if ($last_command->{'closed'})
         {
            push @{$current_command->{'content'}}, {};
         }
         $current_command = $current_command->{'content'}->[-1];
      }
   }
   return if $no_close;
   
   if (!defined($current_command->{'command'}))
   {
      print STDERR "To close, Adding $command as $current_command\n";
      $current_command->{'command'} = $command;
   }
   print STDERR "Closing $command ($current_command)\n";
   $current_command->{'closed'} = 1;
   if (!@$command_stack)
   {
      push @all_stacks, $info_default_top_stack;
      $info_default_top_stack = {};
      print STDERR "Storing the stack\n";
   }
}

sub info_default_style($$$$$$$$$)
{
   my @orig_args = @_;
   my $style = shift; 
   my $command = shift;
   my $text = shift;
   my $args = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;
   my $state = shift;
   my $command_stack = shift;

   if (defined($style->{'function'}))
   {
      $text = &{$style->{'function'}}($command, $args, $command_stack, $state, $line_nr);
   }
   if (defined($style->{'begin'}) and !$no_open)
   {
      $text = $style->{'begin'} . $text;
   }
   if (defined($style->{'end'}) and !$no_close)
   {
      $text = $text . $style->{'end'};
   }
   info_default_close_command($command_stack, $command, $no_close, $no_open, $line_nr);
   return $text;
}

my $info_default_offset_in_file;
my @info_default_pending_tags;
sub info_default_print_page_head($)
{
    my $fh = shift;
    my $setfilename = $Texi2HTML::THISDOC{'setfilename'} if (defined($Texi2HTML::THISDOC{'setfilename'}));
    $setfilename = $Texi2HTML::THISDOC{file_base_name}.$EXTENSION if (!defined($setfilename));
    #my $result = "This is $setfilename, produced by $Texi2HTML::THISDOC{program} from $Texi2HTML::THISDOC{'input_file_name'}.\n\n";
    my $result = "This is $setfilename, produced by makeinfo version 4.13 from $Texi2HTML::THISDOC{'input_file_name'}.\n\n";
    $result .= "$Texi2HTML::THISDOC{'copying_comment'}";
    $info_default_offset_in_file = length($result);
    @info_default_pending_tags = ();
    print $fh $result;
}

my $info_default_paragraph_in_element_nr;
my $info_default_end_sentence_character = quotemeta('.');
my $info_default_para_indent_length = 3;
my $info_default_max_column = 72;

sub info_default_paragraph($$$$$$$$$$$$)
{
    my $text = shift;
    my $align = shift;
    my $indent = shift;
    my $paragraph_command = shift;
    my $paragraph_command_formatted = shift;
    my $paragraph_number = shift;
    my $format = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $command_stack_at_end = shift;
    my $command_stack_at_begin = shift;

    my $para = '';
    $text =~ /\s*$/;

    if ($info_default_paragraph_in_element_nr)
    {
        # add length(para) before
        $para = ' ' x $info_default_para_indent_length;
    }
    $info_default_paragraph_in_element_nr++;

    my @lines = split (/\n/, $text);
    my $line_char_counter = length($para);
    my $prev_space = '';
    while (@lines)
    {
       my $line = shift (@lines);
       # here may remove characters in front of the line
       $line =~ s/^\s*//;
       # here may remove characters at the end of the line and replace
       # with one space. Not sure it is correct 
       $line =~ s/\s*$//;
       $line .= ' ';
       my ($word, $space);
       while ($line =~ s/^([^\s]+)(\s*)//)
       {
          $word = $1;
          $space = $2;
          if ($line_char_counter + length($word) > $info_default_max_column)
          {
             $para .= "\n";
             $line_char_counter = 0;
          }
          else
          {
              $para .= $prev_space;
              $line_char_counter += length($prev_space);
          }
#print STDERR "$line|$prev_space|$word+$space|$line_char_counter|$para\n";
          $para .= $word;
          $line_char_counter += length($word);
          $prev_space = $space;
       }
#print STDERR "LAST $word\n";
       if ($word =~ /$info_default_end_sentence_character$/ and (scalar(@lines)))
       {
          $para .= ' ';
          $line_char_counter += 1;
       }
    }
    return $para . "\n\n";
}

my %default_info_level_to_symbol = (
  0 => '*',
  1 => '*',
  2 => '=',
  3 => '-',
  4 => '.'
);

sub info_default_element_heading($$$$$$$$$$$$)
{
    my $element = shift;
    my $command = shift;
    my $texi_line = shift;
    my $line = shift;
    my $in_preformatted = shift;
    my $one_section = shift;
    my $element_heading = shift;
    my $first_in_page = shift;
    my $is_top = shift;
    my $previous_is_top = shift;
    my $command_line = shift;
    my $element_id = shift;
    my $new_element = shift;

    if ($new_element and ($element ne $new_element or !$element->{'node'}))
    {
        die "There is a new element, but element $element->{'texi'} is not a node or not the new element\n";
    }
    return &$heading($element, $command, $texi_line, $line, $in_preformatted, $one_section, $element_heading) unless ($new_element);
    $element->{'info_offset'} = $info_default_offset_in_file;
    push @info_default_pending_tags, $element;
    my $result = "\x{1F}\nFile: $Texi2HTML::THIS_ELEMENT->{'file'},  Node: $element->{'text'}";
    # here construct Next, Prev, Up
    $result .= "\n\n";
    return $result;
}

sub info_default_heading($$$$$;$$)
{
    my $element = shift;
    my $command = shift;
    my $texi_line = shift;
    my $line = shift;
    my $in_preformatted = shift;
    my $one_section = shift;
    my $element_heading = shift;

    die "Heading called for a node\n" if ($element->{'node'});
    $info_default_paragraph_in_element_nr = 0;
    return "$element->{'text'}\n" . 
       ($default_info_level_to_symbol{$element->{'level'}} x length($element->{'text'})) . "\n\n";
}

sub  info_default_normal_text($$$$$$)
{
   my $text = shift;
   my $in_raw_text = shift; # remove_texi
   my $in_preformatted = shift;
   my $in_code = shift;
   my $in_simple = shift;
   my $style_stack = shift;
   $text = uc($text) if (in_cmd($style_stack, 'sc'));
#   $text = &$protect_text($text) unless($in_raw_text);
   if (! $in_code and !$in_preformatted)
   {
       $text =~ s/---/\x{1F}/g;
       $text =~ s/--/-/g;
       $text =~ s/\x{1F}/--/g;
   }
   else
   {
       # to be like texinfo
#       my $special_code = 0;
#       $special_code = 1 if (in_cmd($style_stack, 'code') or 
#           in_cmd($style_stack, 'example') or in_cmd($style_stack, 'verbatim'));
#       $text =~ s/'/\&rsquo\;/g unless ($special_code and exists($main::value{'txicodequoteundirected'}));
#       $text =~ s/`/\&lsquo\;/g unless ($special_code and exists($main::value{'txicodequotebacktick'}));
   }
   return $text;
}

sub info_default_empty_line($$)
{
    my $text = shift;
    my $state = shift;
    #ignore the line if it just follows a deff
    #return '' if ($state->{'deff_line'});
    return '';
}

sub info_default_acronym_like($$$$$$)
{
    my $command = shift;
    my $acronym_texi = shift;
    my $acronym_text = shift;
    my $with_explanation = shift;
    my $explanation_lines = shift;
    my $explanation_text = shift;
    my $explanation_simply_formatted = shift;

   if ($with_explanation)
   {
       return "$acronym_text ($explanation_text)";
   }
   else
   {
       return "$acronym_text";
   }
}


sub info_default_print_page_foot($)
{
   my $fh = shift;
   print $fh "\x{1F}\nTag Table:\n";
   # 
   foreach my $element (@info_default_pending_tags)
   {
      my $prefix;
      $prefix = 'Node' if ($element->{'node'});
      print $fh "$prefix: $element->{'text'}\x{7F}$element->{'info_offset'}\n";
   }
   print $fh "\x{1F}\nEnd Tag Table\n";
}

sub info_default_print_section
{
    my $fh = shift;
    my $first_in_page = shift;
    my $previous_is_top = shift;
    my $element = shift;
    my $nw = main::print_lines($fh);
}

sub info_default_one_section($$)
{
    my $fh = shift;
    my $element = shift;
    &$print_section($fh, 1, 0, $element);
    &$print_page_foot($fh);
}

1;
