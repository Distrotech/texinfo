@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/elim_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/elim_lib.doc INSTEAD
@c library version: (1.14.2.4,2003/04/16)
@c library file: ../Singular/LIB/elim.lib
@cindex elim.lib
@cindex elim_lib
@table @asis
@item @strong{Library:}
elim.lib
@item @strong{Purpose:}
      Elimination, Saturation and Blowing up

@end table

@strong{Procedures:}
@menu
* blowup0:: create presentation of blownup ring of ideal j
* elim:: variable n..m eliminated from id (ideal/module)
* elim1:: p=product of vars to be eliminated from id
* nselect:: select generators not containing n-th [..m-th] variable
* sat:: saturated quotient of ideal/module id by ideal j
* select:: select generators containing all variables n...m
* select1:: select generators containing one variable n...m
@end menu
@c ---end content LibInfo---

@c ------------------- blowup0 -------------
@node blowup0, elim,, elim_lib
@subsubsection blowup0
@cindex blowup0
@c ---content blowup0---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
blowup0(j[,s1,s2]); j ideal, s1,s2 nonempty strings

@item @strong{Create:}
Create a presentation of the blowup ring of j

@item @strong{Return:}
no return value

@item @strong{Note:}
s1 and s2 are used to give names to the blownup ring and the blownup
ideal (default: s1="j", s2="A")
@*Assume R = char,x(1..n),ord is the basering of j, and s1="j", s2="A"
then the procedure creates a new ring with name Bl_jR
@*(equal to R[A,B,...])
@*Bl_jR = char,(A,B,...,x(1..n)),(dp(k),ord)
@*with k=ncols(j) new variables A,B,... and ordering wp(d1..dk) if j is
homogeneous with deg(j[i])=di resp. dp otherwise for these vars.
If k>26 or size(s2)>1, say s2="A()", the new vars are A(1),...,A(k).
Let j_ be the kernel of the ring map Bl_jR -> R defined by A(i)->j[i],
x(i)->x(i), then the quotient ring Bl_jR/j_ is the blowup ring of j
in R (being isomorphic to R+j+j^2+...). Moreover the procedure creates
a std basis of j_ with name j_ in Bl_jR.
@*This proc uses 'execute' or calls a procedure using 'execute'.

@item @strong{Display:}
printlevel >=0: explain created objects (default)

@end table
@strong{Example:}
@smallexample
@c computed example blowup0 d2t_singular/elim_lib.doc:65 
LIB "elim.lib";
ring R=0,(x,y),dp;
poly f=y2+x3; ideal j=jacob(f);
blowup0(j);
@expansion{} 
@expansion{} // The proc created the ring Bl_jR (equal to R[A,B])
@expansion{} // it contains the ideal j_ , such that
@expansion{} //             Bl_jR/j_ is the blowup ring
@expansion{} // show(Bl_jR); shows this ring.
@expansion{} // Make Bl_jR the basering and see j_ by typing:
@expansion{}    setring Bl_jR;
@expansion{}    j_;
show(Bl_jR);
@expansion{} // ring: (0),(A,B,x,y),(wp(2,1),dp(2),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // j_                   [0]  ideal, 1 generator(s)
setring Bl_jR;
j_;"";
@expansion{} j_[1]=2Ay-3Bx2
@expansion{} 
ring r=32003,(x,y,z),ds;
blowup0(maxideal(1),"m","T()");
@expansion{} 
@expansion{} // The proc created the ring Bl_mr (equal to r[T(1..3)])
@expansion{} // it contains the ideal m_ , such that
@expansion{} //             Bl_mr/m_ is the blowup ring
@expansion{} // show(Bl_mr); shows this ring.
@expansion{} // Make Bl_mr the basering and see m_ by typing:
@expansion{}    setring Bl_mr;
@expansion{}    m_;
show(Bl_mr);
@expansion{} // ring: (32003),(T(1),T(2),T(3),x,y,z),(wp(1,1,1),ds(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
@expansion{} // m_                   [0]  ideal, 3 generator(s)
setring Bl_mr;
m_;
@expansion{} m_[1]=T(1)y-T(2)x
@expansion{} m_[2]=T(1)z-T(3)x
@expansion{} m_[3]=T(2)z-T(3)y
kill Bl_jR, Bl_mr;
@c end example blowup0 d2t_singular/elim_lib.doc:65
@end smallexample
@c ---end content blowup0---

@c ------------------- elim -------------
@node elim, elim1, blowup0, elim_lib
@subsubsection elim
@cindex elim
@c ---content elim---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
elim(id,n,m); id ideal/module, n,m integers

@item @strong{Returns:}
ideal/module obtained from id by eliminating variables n..m

@item @strong{Note:}
no special monomial ordering is required, result is a SB with
respect to ordering dp (resp. ls) if the first var not to be
eliminated belongs to a -p (resp. -s) block ordering
@*This proc uses 'execute' or calls a procedure using 'execute'.

@end table
@strong{Example:}
@smallexample
@c computed example elim d2t_singular/elim_lib.doc:106 
LIB "elim.lib";
ring r=0,(x,y,u,v,w),dp;
ideal i=x-u,y-u2,w-u3,v-x+y3;
elim(i,3,4);
@expansion{} _[1]=y2-xw
@expansion{} _[2]=xy-w
@expansion{} _[3]=x2-y
module m=i*gen(1)+i*gen(2);
m=elim(m,3,4);show(m);
@expansion{} // module, 6 generator(s)
@expansion{} [y2-xw]
@expansion{} [0,y2-xw]
@expansion{} [xy-w]
@expansion{} [0,xy-w]
@expansion{} [x2-y]
@expansion{} [0,x2-y]
@c end example elim d2t_singular/elim_lib.doc:106
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:115
@ifinfo
@menu
See also:
* elim1::
* eliminate::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{elim1};
@ref{eliminate}.
@end iftex
@c end inserted refs from d2t_singular/elim_lib.doc:115

@c ---end content elim---

@c ------------------- elim1 -------------
@node elim1, nselect, elim, elim_lib
@subsubsection elim1
@cindex elim1
@c ---content elim1---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
elim1(id,p); id ideal/module, p product of vars to be eliminated

@item @strong{Return:}
ideal/module obtained from id by eliminating vars occurring in poly

@item @strong{Note:}
no special monomial ordering is required, result is a SB with
respect to ordering dp (resp. ls) if the first var not to be
eliminated belongs to a -p (resp. -s) block ordering
@*This proc uses 'execute' or calls a procedure using 'execute'.

@end table
@strong{Example:}
@smallexample
@c computed example elim1 d2t_singular/elim_lib.doc:144 
LIB "elim.lib";
ring r=0,(x,y,t,s,z),dp;
ideal i=x-t,y-t2,z-t3,s-x+y3;
elim1(i,ts);
@expansion{} _[1]=y2-xz
@expansion{} _[2]=xy-z
@expansion{} _[3]=x2-y
module m=i*gen(1)+i*gen(2);
m=elim1(m,st); show(m);
@expansion{} // module, 6 generator(s)
@expansion{} [y2-xz]
@expansion{} [0,y2-xz]
@expansion{} [xy-z]
@expansion{} [0,xy-z]
@expansion{} [x2-y]
@expansion{} [0,x2-y]
@c end example elim1 d2t_singular/elim_lib.doc:144
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:153
@ifinfo
@menu
See also:
* elim::
* eliminate::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{elim};
@ref{eliminate}.
@end iftex
@c end inserted refs from d2t_singular/elim_lib.doc:153

@c ---end content elim1---

@c ------------------- nselect -------------
@node nselect, sat, elim1, elim_lib
@subsubsection nselect
@cindex nselect
@c ---content nselect---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
nselect(id,n[,m]); id a module or ideal, n, m integers

@item @strong{Return:}
generators of id not containing the variable n [up to m]

@end table
@strong{Example:}
@smallexample
@c computed example nselect d2t_singular/elim_lib.doc:176 
LIB "elim.lib";
ring r=0,(x,y,t,s,z),(c,dp);
ideal i=x-y,y-z2,z-t3,s-x+y3;
nselect(i,3);
@expansion{} _[1]=x-y
@expansion{} _[2]=-z2+y
@expansion{} _[3]=y3-x+s
module m=i*(gen(1)+gen(2));
show(m);
@expansion{} // module, 4 generator(s)
@expansion{} [x-y,x-y]
@expansion{} [-z2+y,-z2+y]
@expansion{} [-t3+z,-t3+z]
@expansion{} [y3-x+s,y3-x+s]
show(nselect(m,3,4));
@expansion{} // module, 2 generator(s)
@expansion{} [x-y,x-y]
@expansion{} [-z2+y,-z2+y]
@c end example nselect d2t_singular/elim_lib.doc:176
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:186
@ifinfo
@menu
See also:
* select::
* select1::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{select};
@ref{select1}.
@end iftex
@c end inserted refs from d2t_singular/elim_lib.doc:186

@c ---end content nselect---

@c ------------------- sat -------------
@node sat, select, nselect, elim_lib
@subsubsection sat
@cindex sat
@c ---content sat---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
sat(id,j); id=ideal/module, j=ideal

@item @strong{Return:}
list of an ideal/module [1] and an integer [2]:
@*[1] = saturation of id with respect to j (= union_(k=1...) of id:j^k)
[2] = saturation exponent (= min( k | id:j^k = id:j^(k+1) ))

@item @strong{Note:}
[1] is a standard basis in the basering

@item @strong{Display:}
saturation exponent during computation if printlevel >=1

@end table
@strong{Example:}
@smallexample
@c computed example sat d2t_singular/elim_lib.doc:217 
LIB "elim.lib";
int p      = printlevel;
ring r     = 2,(x,y,z),dp;
poly F     = x5+y5+(x-y)^2*xyz;
ideal j    = jacob(F);
sat(j,maxideal(1));
@expansion{} [1]:
@expansion{}    _[1]=x3+x2y+xy2+y3
@expansion{}    _[2]=y4+x2yz+y3z
@expansion{}    _[3]=x2y2+x2yz+y3z
@expansion{} [2]:
@expansion{}    4
printlevel = 2;
sat(j,maxideal(2));
@expansion{} // compute quotient 1
@expansion{} // compute quotient 2
@expansion{} // compute quotient 3
@expansion{} // saturation becomes stable after 2 iteration(s)
@expansion{} 
@expansion{} [1]:
@expansion{}    _[1]=x3+x2y+xy2+y3
@expansion{}    _[2]=y4+x2yz+y3z
@expansion{}    _[3]=x2y2+x2yz+y3z
@expansion{} [2]:
@expansion{}    2
printlevel = p;
@c end example sat d2t_singular/elim_lib.doc:217
@end smallexample
@c ---end content sat---

@c ------------------- select -------------
@node select, select1, sat, elim_lib
@subsubsection select
@cindex select
@c ---content select---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
select(id,n[,m]); id ideal/module, n, m integers

@item @strong{Return:}
generators of id containing the variable n [all variables up to m]

@item @strong{Note:}
use 'select1' for selecting generators containing at least one of the
variables between n and m

@end table
@strong{Example:}
@smallexample
@c computed example select d2t_singular/elim_lib.doc:252 
LIB "elim.lib";
ring r=0,(x,y,t,s,z),(c,dp);
ideal i=x-y,y-z2,z-t3,s-x+y3;
ideal j=select(i,1);
j;
@expansion{} j[1]=x-y
@expansion{} j[2]=y3-x+s
module m=i*(gen(1)+gen(2));
m;
@expansion{} m[1]=[x-y,x-y]
@expansion{} m[2]=[-z2+y,-z2+y]
@expansion{} m[3]=[-t3+z,-t3+z]
@expansion{} m[4]=[y3-x+s,y3-x+s]
select(m,1,2);
@expansion{} _[1]=[x-y,x-y]
@expansion{} _[2]=[y3-x+s,y3-x+s]
@c end example select d2t_singular/elim_lib.doc:252
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:263
@ifinfo
@menu
See also:
* nselect::
* select1::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{nselect};
@ref{select1}.
@end iftex
@c end inserted refs from d2t_singular/elim_lib.doc:263

@c ---end content select---

@c ------------------- select1 -------------
@node select1,, select, elim_lib
@subsubsection select1
@cindex select1
@c ---content select1---
Procedure from library @code{elim.lib} (@pxref{elim_lib}).

@table @asis
@item @strong{Usage:}
select1(id,n[,m]); id ideal/module, n, m integers

@item @strong{Return:}
generators of id containing the variable n
@*[at least one of the variables up to m]

@item @strong{Note:}
use 'select' for selecting generators containing all the
variables between n and m

@end table
@strong{Example:}
@smallexample
@c computed example select1 d2t_singular/elim_lib.doc:291 
LIB "elim.lib";
ring r=0,(x,y,t,s,z),(c,dp);
ideal i=x-y,y-z2,z-t3,s-x+y3;
ideal j=select1(i,1);
j;
@expansion{} j[1]=x-y
@expansion{} j[2]=y3-x+s
module m=i*(gen(1)+gen(2));
m;
@expansion{} m[1]=[x-y,x-y]
@expansion{} m[2]=[-z2+y,-z2+y]
@expansion{} m[3]=[-t3+z,-t3+z]
@expansion{} m[4]=[y3-x+s,y3-x+s]
select1(m,1,2);
@expansion{} _[1]=[x-y,x-y]
@expansion{} _[2]=[-z2+y,-z2+y]
@expansion{} _[3]=[y3-x+s,y3-x+s]
@c end example select1 d2t_singular/elim_lib.doc:291
@end smallexample
@c inserted refs from d2t_singular/elim_lib.doc:302
@ifinfo
@menu
See also:
* nselect::
* select::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{nselect};
@ref{select}.
@end iftex
@c end inserted refs from d2t_singular/elim_lib.doc:302

@c ---end content select1---
