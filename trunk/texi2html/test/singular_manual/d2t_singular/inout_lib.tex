@c ---content LibInfo---
@comment This file was generated by doc2tex.pl from d2t_singular/inout_lib.doc
@comment DO NOT EDIT DIRECTLY, BUT EDIT d2t_singular/inout_lib.doc INSTEAD
@c library version: (1.21.2.5,2002/06/12)
@c library file: ../Singular/LIB/inout.lib
@cindex inout.lib
@cindex inout_lib
@table @asis
@item @strong{Library:}
inout.lib
@item @strong{Purpose:}
     Printing and Manipulating In- and Output

@end table

@strong{Procedures:}
@menu
* allprint:: print list if ALLprint is defined, with pause if >0
* lprint:: display poly/... fitting to pagewidth [size n]
* pmat:: print form-matrix [first n chars of each column]
* rMacaulay:: read Macaulay_1 output and return its Singular format
* show:: display any object in a compact format
* showrecursive:: display id recursively with respect to variables in p
* split:: split given string into lines of length n
* tab:: string of n space tabs
* writelist:: write a list into a file and keep the list structure
* pause:: stop the computation until user input
@end menu
@c ---end content LibInfo---

@c ------------------- allprint -------------
@node allprint, lprint,, inout_lib
@subsubsection allprint
@cindex allprint
@c ---content allprint---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
allprint(L); L list

@item @strong{Display:}
prints L[1], L[2], ... if an integer with name ALLprint is defined.
@* makes "pause", if ALLprint > 0
@* listvar(matrix), if ALLprint = 2

@item @strong{Return:}
no return value

@end table
@strong{Example:}
@smallexample
@c computed example allprint d2t_singular/inout_lib.doc:51 
LIB "inout.lib";
ring S;
matrix M=matrix(freemodule(2),3,3);
int ALLprint; export ALLprint;
@expansion{} // ** `ALLprint` is already global
allprint("M =",M);
@expansion{} M =
@expansion{} 1,0,0,
@expansion{} 0,1,0,
@expansion{} 0,0,0 
kill ALLprint;
@c end example allprint d2t_singular/inout_lib.doc:51
@end smallexample
@c ---end content allprint---

@c ------------------- lprint -------------
@node lprint, pmat, allprint, inout_lib
@subsubsection lprint
@cindex lprint
@c ---content lprint---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
lprint(id[,n]); id poly/ideal/vector/module/matrix, n integer

@item @strong{Return:}
string of id in a format fitting into lines of size n, such that no
monomial is destroyed, i.e. the new line starts with + or -;
(default: n = pagewidth).

@item @strong{Note:}
id is printed columnwise, each column separated by a blank line;
hence lprint(transpose(id)); displays a matrix id in a format which
can be used as input.

@end table
@strong{Example:}
@smallexample
@c computed example lprint d2t_singular/inout_lib.doc:86 
LIB "inout.lib";
ring r= 0,(x,y,z),ds;
poly f=((x+y)*(x-y)*(x+z)*(y+z)^2);
lprint(f,40);
@expansion{}   x3y2-xy4+2x3yz+x2y2z-2xy3z-y4z+x3z2
@expansion{} +2x2yz2-xy2z2-2y3z2+x2z3-y2z3
module m = [f*(x-y)],[0,f*(x-y)];
string s=lprint(m); s;"";
@expansion{}   x4y2-x3y3-x2y4+xy5+2x4yz-x3y2z-3x2y3z+xy4z+y5z+x4z2+x3yz2-3x2y2z2-xy3z2
@expansion{} +2y4z2+x3z3-x2yz3-xy2z3+y3z3,
@expansion{}   0,
@expansion{} 
@expansion{}   0,
@expansion{}   x4y2-x3y3-x2y4+xy5+2x4yz-x3y2z-3x2y3z+xy4z+y5z+x4z2+x3yz2-3x2y2z2-xy3z2
@expansion{} +2y4z2+x3z3-x2yz3-xy2z3+y3z3
@expansion{} 
execute("matrix M[2][2]="+s+";");      //use the string s as input
module m1 = transpose(M);	          //should be the same as m
print(m-m1);
@expansion{} 0,0,
@expansion{} 0,0 
@c end example lprint d2t_singular/inout_lib.doc:86
@end smallexample
@c ---end content lprint---

@c ------------------- pmat -------------
@node pmat, rMacaulay, lprint, inout_lib
@subsubsection pmat
@cindex pmat
@c ---content pmat---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
pmat(M,[n]); M matrix, n integer

@item @strong{Display:}
display M in array format if it fits into pagewidth; if n is given,
only the first n characters of each column are shown

@item @strong{Return:}
no return value

@end table
@strong{Example:}
@smallexample
@c computed example pmat d2t_singular/inout_lib.doc:121 
LIB "inout.lib";
ring r=0,(x,y,z),ls;
ideal i= x,z+3y,x+y,z;
matrix m[3][3]=i^2;
pmat(m);
@expansion{} x2,     xz+3xy,     xy+x2,         
@expansion{} xz,     z2+6yz+9y2, yz+3y2+xz+3xy, 
@expansion{} z2+3yz, y2+2xy+x2,  yz+xz
pmat(m,3);
@expansion{} x2  xz+ xy+ 
@expansion{} xz  z2+ yz+ 
@expansion{} z2+ y2+ yz+ 
@c end example pmat d2t_singular/inout_lib.doc:121
@end smallexample
@c ---end content pmat---

@c ------------------- rMacaulay -------------
@node rMacaulay, show, pmat, inout_lib
@subsubsection rMacaulay
@cindex rMacaulay
@c ---content rMacaulay---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
rMacaulay(s[,n]); s string, n integer

@item @strong{Return:}
A string which should be readable by Singular if s is a string which
was produced by Macaulay. If a second argument is present the first
n lines of the file are deleted (which is useful if the file was
produced e.g. by the putstd command of Macaulay).

@item @strong{Note:}
This does not always work with 'cut and paste' since the character
\ is treated differently

@end table
@strong{Example:}
@smallexample
@c computed example rMacaulay d2t_singular/inout_lib.doc:156 
LIB "inout.lib";
// Assume there exists a file 'Macid' with the following ideal in
// Macaulay format:"
// x[0]3-101/74x[0]2x[1]+7371x[0]x[1]2-13/83x[1]3-x[0]2x[2] \
//     -4/71x[0]x[1]x[2]
// Read this file into Singular and assign it to the string s1 by:
// string s1 = read("Macid");
// This is equivalent to";
string s1 =
"x[0]3-101/74x[0]2x[1]+7371x[0]x[1]2-13/83x[1]3-x[0]2x[2]-4/71x[0]x[1]x[2]";
rMacaulay(s1);
@expansion{} x(0)^3-101/74*x(0)^2*x(1)+7371*x(0)*x(1)^2-13/83*x(1)^3-x(0)^2*x(2)-4/71*\
   x(0)*x(1)*x(2)
// You may wish to assign s1 to a Singular ideal id:
string sid = "ideal id =",rMacaulay(s1),";";
ring r = 0,x(0..3),dp;
execute(sid);
id; "";
@expansion{} id[1]=x(0)^3-101/74*x(0)^2*x(1)+7371*x(0)*x(1)^2-13/83*x(1)^3-x(0)^2*x(2)\
   -4/71*x(0)*x(1)*x(2)
@expansion{} 
// Now treat a matrix in Macaulay format. Using the execute
// command, this could be assinged to a Singular matrix as above.
string s2 = "
0  0  0  0  0
a3 0  0  0  0
0  b3 0  0  0
0  0  c3 0  0
0  0  0  d3 0
0  0  0  0  e3 ";
rMacaulay(s2);
@expansion{} 0, 0, 0, 0, 0,
@expansion{} a3,0, 0, 0, 0,
@expansion{} 0, b3,0, 0, 0,
@expansion{} 0, 0, c3,0, 0,
@expansion{} 0, 0, 0, d3,0,
@expansion{} 0, 0, 0, 0, e3
@c end example rMacaulay d2t_singular/inout_lib.doc:156
@end smallexample
@c ---end content rMacaulay---

@c ------------------- show -------------
@node show, showrecursive, rMacaulay, inout_lib
@subsubsection show
@cindex show
@c ---content show---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
show(id); id any object of basering or of type ring/qring
@* show(R,s); R=ring, s=string (s = name of an object belonging to R)

@item @strong{Display:}
display id/s in a compact format together with some information

@item @strong{Return:}
no return value

@item @strong{Note:}
objects of type string, int, intvec, intmat belong to any ring.
id may be a ring or a qring. In this case the minimal polynomial is
displayed, and, for a qring, also the defining ideal.
@*id may be of type list but the list must not contain a ring.
@* show(R,s) does not work inside a procedure!

@end table
@strong{Example:}
@smallexample
@c computed example show d2t_singular/inout_lib.doc:215 
LIB "inout.lib";
ring r;
show(r);
@expansion{} // ring: (32003),(x,y,z),(dp(3),C);
@expansion{} // minpoly = 0
@expansion{} // objects belonging to this ring:
ideal i=x^3+y^5-6*z^3,xy,x3-y2;
show(i,3);            // introduce 3 space tabs before information
@expansion{}    // ideal, 3 generator(s)
@expansion{} y5+x3-6z3,
@expansion{} xy,
@expansion{} x3-y2
vector v=x*gen(1)+y*gen(3);
module m=v,2*v+gen(4);
list L = i,v,m;
show(L);
@expansion{} // list, 3 element(s):
@expansion{} [1]:
@expansion{}    // ideal, 3 generator(s)
@expansion{} y5+x3-6z3,
@expansion{} xy,
@expansion{} x3-y2
@expansion{} [2]:
@expansion{}    // vector
@expansion{} [x,0,y]
@expansion{} [3]:
@expansion{}    // module, 2 generator(s)
@expansion{} [x,0,y]
@expansion{} [2x,0,2y,1]
ring S=(0,T),(a,b,c,d),ws(1,2,3,4);
minpoly = T^2+1;
ideal i=a2+b,c2+T^2*d2; i=std(i);
qring Q=i;
show(Q);
@expansion{} // qring: (0,T),(a,b,c,d),(ws(1,2,3,4),C);
@expansion{} // minpoly = (T2+1)
@expansion{} // quotient ring from ideal:
@expansion{} _[1]=a2+b
@expansion{} _[2]=c2-d2
map F=r,a2,b^2,3*c3;
show(F);
@expansion{} // i-th variable of preimage ring is mapped to @@map[i]
@expansion{} // @@map                 [1]  map from r
@expansion{} @@map[1]=a2
@expansion{} @@map[2]=b2
@expansion{} @@map[3]=3*c3
// Apply 'show' to i (which does not belong to the basering) by typing
// ring r; ideal i=xy,x3-y2; ring Q; show(r,"i");
@c end example show d2t_singular/inout_lib.doc:215
@end smallexample
@c ---end content show---

@c ------------------- showrecursive -------------
@node showrecursive, split, show, inout_lib
@subsubsection showrecursive
@cindex showrecursive
@c ---content showrecursive---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
showrecursive(id,p[ord]); id= any object of basering, p= product of
variables and ord=string (any allowed ordstr)

@item @strong{Display:}
display 'id' in a recursive format as a polynomial in the variables
occurring in p with coefficients in the remaining variables. This is
done by mapping to a ring with parameters [and ordering 'ord',
if a 3rd argument is present (default: ord="dp")] and applying
procedure 'show'

@item @strong{Return:}
no return value

@end table
@strong{Example:}
@smallexample
@c computed example showrecursive d2t_singular/inout_lib.doc:263 
LIB "inout.lib";
ring r=2,(a,b,c,d,x,y),ds;
poly f=y+ax2+bx3+cx2y2+dxy3;
showrecursive(f,x);
@expansion{} // poly, 4 monomial(s)
@expansion{} (b)*x3+(a+cy2)*x2+(dy3)*x+(y)
showrecursive(f,xy,"lp");
@expansion{} // poly, 5 monomial(s)
@expansion{} (b)*x3+(c)*x2y2+(a)*x2+(d)*xy3+y
@c end example showrecursive d2t_singular/inout_lib.doc:263
@end smallexample
@c ---end content showrecursive---

@c ------------------- split -------------
@node split, tab, showrecursive, inout_lib
@subsubsection split
@cindex split
@c ---content split---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
split(s[,n]); s string, n integer

@item @strong{Return:}
same string, split into lines of length n separated by \
(default: n=pagewidth)

@item @strong{Note:}
may be used in connection with lprint

@end table
@strong{Example:}
@smallexample
@c computed example split d2t_singular/inout_lib.doc:294 
LIB "inout.lib";
ring r= 0,(x,y,z),ds;
poly f = (x+y+z)^4;
split(string(f),50);
@expansion{} x4+4x3y+6x2y2+4xy3+y4+4x3z+12x2yz+12xy2z+4y3z+6x\
@expansion{} 2z2+12xyz2+6y2z2+4xz3+4yz3+z4
split(lprint(f));
@expansion{}   x4+4x3y+6x2y2+4xy3+y4+4x3z+12x2yz+12xy2z+4y3z+6x2z2+12xyz2+6y2z2+4xz3+4\
   yz3\
@expansion{} +z4
@c end example split d2t_singular/inout_lib.doc:294
@end smallexample
@c ---end content split---

@c ------------------- tab -------------
@node tab, writelist, split, inout_lib
@subsubsection tab
@cindex tab
@c ---content tab---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
tab(n); n integer

@item @strong{Return:}
string of n space tabs

@end table
@strong{Example:}
@smallexample
@c computed example tab d2t_singular/inout_lib.doc:321 
LIB "inout.lib";
for(int n=0; n<=5; n=n+1)
@{ tab(5-n)+"*"+tab(n)+"+"+tab(n)+"*"; @}
@expansion{}      *+*
@expansion{}     * + *
@expansion{}    *  +  *
@expansion{}   *   +   *
@expansion{}  *    +    *
@expansion{} *     +     *
@c end example tab d2t_singular/inout_lib.doc:321
@end smallexample
@c ---end content tab---

@c ------------------- writelist -------------
@node writelist, pause, tab, inout_lib
@subsubsection writelist
@cindex writelist
@c ---content writelist---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
writelist(file,name,L); file,name strings (file-name, list-name),
L a list.

@item @strong{Create:}
a file with name `file`, write the content of the list L into it and
call the list `name`, keeping the list structure

@item @strong{Return:}
no return value

@item @strong{Note:}
The syntax of writelist uses and is similar to the syntax of the
write command of Singular which does not manage lists properly.
If (file,name) = ("listfile","L1"), writelist creates (resp.
appends if listfile exists) a file with name listfile and stores
there the list L under the name L1. The Singular command
execute(read("listfile")); assigns the content of L (stored in
listfile) to a list L1.
@* On a UNIX system, write(">file",...) overwrites an existing file
`file` while write("file",...) and write(">>file",...) append.

@end table
@strong{Example:}
@smallexample
@c computed example writelist d2t_singular/inout_lib.doc:362 
LIB "inout.lib";
ring r;
ideal i=x,y,z;
list k="Hi",nameof(basering),i,37;
writelist("zumSpass","lustig",k);
read("zumSpass");
@expansion{} list lustig;
@expansion{}    lustig[1]=
@expansion{} Hi;
@expansion{}    lustig[2]=
@expansion{} r;
@expansion{}    lustig[3]=
@expansion{} x,y,z;
@expansion{}    lustig[4]=
@expansion{} 37;
@expansion{} 
list L=res(i,0);                    //resolution of the ideal i
writelist("res_list","res-name",L); "";
@expansion{} 
read("res_list");
@expansion{} list res-name;
@expansion{}    res-name[1]=
@expansion{} z,y,x;
@expansion{}    res-name[2]=
@expansion{} -y*gen(1)+z*gen(2),-x*gen(1)+z*gen(3),-x*gen(2)+y*gen(3);
@expansion{}    res-name[3]=
@expansion{} x*gen(1)-y*gen(2)+z*gen(3);
@expansion{} 
// execute(read("res_list")); would create a list with name res-name,
// which is the resolution of i (the same content as L)
system("sh","/bin/rm res_list zumSpass");
@expansion{} 0
// Under UNIX, this removes the files 'res_list' and 'zumSpass'
// Type help system; to get more information about the shell escape
// If your operating system does not accept the shell escape, you
// must remove the just created files 'zumSpass' and 'res_list' directly
@c end example writelist d2t_singular/inout_lib.doc:362
@end smallexample
@c ---end content writelist---

@c ------------------- pause -------------
@node pause,, writelist, inout_lib
@subsubsection pause
@cindex pause
@c ---content pause---
Procedure from library @code{inout.lib} (@pxref{inout_lib}).

@table @asis
@item @strong{Usage:}
pause([ prompt ]) prompt string

@item @strong{Return:}
none

@item @strong{Purpose:}
interrupt the execution of commands until user input

@item @strong{Note:}
pause is useful in procedures in connection with printlevel to
interrupt the computation and to display intermediate results.

@end table
@strong{Example:}
@smallexample
@c computed example pause d2t_singular/inout_lib.doc:407 
LIB "inout.lib";
// can only be shown interactively, try the following commands:
// pause("press <return> to continue");
// pause();
// In the following pocedure TTT, xxx is printed and the execution of
// TTT is stopped until the return-key is pressed, if printlevel>0.
// xxx may be any result of a previous computation or a comment, etc:
//
// proc TTT
// @{ int pp = printlevel-voice+2;  //pp=0 if printlevel=0 and if TTT is
//    ....                         //not called from another procedure
//    if( pp>0 )
//    @{
//       print( xxx );
//       pause("press <return> to continue");
//    @}
//     ....
// @}
@c end example pause d2t_singular/inout_lib.doc:407
@end smallexample
@c inserted refs from d2t_singular/inout_lib.doc:428
@ifinfo
@menu
See also:
* printlevel::
* read::
@end menu
@end ifinfo
@iftex
@strong{See also:}
@ref{printlevel};
@ref{read}.
@end iftex
@c end inserted refs from d2t_singular/inout_lib.doc:428

@c ---end content pause---
