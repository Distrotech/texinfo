* conditionals on @set/@value, output format
* implement command_warn properly
* Check everywhere we store values, we check properly what to do if the
  values are already defined.
* check valid nestings
* Implement more parser options
* Character encoding issues - read and pass to Perl correctly.
* gnulib integration for strrchr, strchrnul, asprintf, etc.  Eliminate
  #define _GNU_SOURCE.
* gettext integration
* figure out what to do with parse_texi_line, etc.  Integration with the 
test suites.
* find where "strlen" and "text_append" are used and try to remove them, for 
efficiency.  Also newSVpv (..., 0);
* Add "TODO" anywhere in the code with explanations of what is not done yet.

Texinfo::Report::gdt and parse_texi_line -

Multiple Texinfo::Parser objects are created in a run of texi2any.  The
main one is to parse the input file, but it is also used by gdt - the 
string translation function.  (I haven't ruled out that it is also used 
somewhere else as well.)

This makes replacing the Texinfo::Parser module more complicated.

gdt parses pieces Texinfo code that are the translations of strings in 
po_document/texinfo_document.pot.  It does this by adding "@value" 
before strings surrounded by braces, and then calling "parse_texi_line" 
with these @value's set to the appropriate value.  These values could be 
a string, a hash reference (representing a tree element), or an array 
reference (representing a "content array" of tree elements).

parse_texi_line returns a Perl Texinfo tree which is at last converted 
into the output Info/HTML/etc.

These values that are not strings are a challenge for how they can be 
passed back into C.  We have code (in api.c) to translate our C 
representations of the Texinfo tree to Perl data structures, but not 
vice versa.

Suggestions:
* Convert the values with $self->_convert to strings, then give the 
values as strings, followed by parsing as Texinfo.  Care would have to 
be taken to quote correctly special characters in the values, like "@", 
"{" and "}".
* Don't call parse_texi_line at all.  This would be a simplification of 
the overall structure of the makeinfo program and might not lose much 
flexibility in return.  Most of the strings in texinfo_document.pot 
don't use any Texinfo commands, and the others could be expressed 
directly in the output format, e.g.  instead of

msgid "{category} on {class}: @strong{{name}}

it could be

msgid "{category} on {class}: <strong>{name}</strong>"

Some of the translation strings use Texinfo commands for characters, 
e.g. "@'e".  This would have to be replaced with whatever method other 
programs using gettext use for special characters.
* Write code translating Perl tree elements into C data structures and 
allow them to be passed to the parser as @value's.

To use the current implementation, do the following to 
tp/Texinfo/Report.pm:

Index: Report.pm
===================================================================
--- Report.pm   (revision 6198)
+++ Report.pm   (working copy)
@@ -48,7 +48,8 @@ use File::Basename;
 
 use Locale::Messages;
 # to be able to load a parser if none was given to gdt.
-use Texinfo::Parser;
+#use Texinfo::Parser;
+use Parsetexi;
 
 # return the errors and warnings
 sub errors($)
@@ -399,7 +400,8 @@ sub gdt($$;$$)
     }
   }
   #my $parser = Texinfo::Parser::parser($parser_conf);
-  my $parser = Texinfo::Parser::simple_parser($parser_conf);
+  #my $parser = Texinfo::Parser::simple_parser($parser_conf);
+  my $parser = Parsetexi::parser($parser_conf);
   if ($parser->{'DEBUG'}) {
     print STDERR "GDT $translation_result\n";
   }

===================================================================

As said, the implementation is not complete so it gives output like

 -- <<HASH WITH NO TEXT>>: count-loop <<ARRAY VALUE>>
      This imaginary special form implements a loop that executes the
      BODY forms and then increments the variable VAR on each iteration.




Integration with rest of Perl code:

Passing data as Perl code to be evaluated in very slow, which limits the 
speed-up that is obtained. One way round this would be to access the 
parse tree in the Perl code through an API. This would be done in two 
stages:

* Convert makeinfo backends to use a Perl stub for the C API. The C 
parser will not be used at this point.
* Substitute the XS API implementation for the Perl API when the C 
parser is good enough.

